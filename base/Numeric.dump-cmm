
==================== Output Cmm ====================
2018-03-16 15:58:56.003333996 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:58:56.004620128 UTC

[section ""data" . Numeric.readInt_closure" {
     Numeric.readInt_closure:
         const Numeric.readInt_info;
         const 0;
 },
 sat_s43P9_entry() //  [R1]
         { info_tbl: [(c43WJ,
                       label: sat_s43P9_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43WJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c43WK; else goto c43WL;
       c43WK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c43WL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c43WG_info;
           R6 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Text.Read.Lex.$wreadIntP_entry(R6,
                                               R5,
                                               R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c43WG() //  [R1]
         { info_tbl: [(c43WG,
                       label: block_c43WG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43WG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c43WO; else goto c43WN;
       c43WO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c43WN: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.readInt_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c43WP,
                       label: Numeric.readInt_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43WP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c43WT; else goto c43WS;
       c43WT: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readInt_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c43WS: // global
           I64[Hp - 40] = sat_s43P9_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 40;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.006767343 UTC

[section ""data" . Numeric.readOct_closure" {
     Numeric.readOct_closure:
         const Numeric.readOct_info;
         const 0;
 },
 sat_s43Pc_entry() //  [R1]
         { info_tbl: [(c43X7,
                       label: sat_s43Pc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43X7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c43X8; else goto c43X9;
       c43X8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c43X9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.Read.Lex.readDecP4_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43Pf_entry() //  [R1]
         { info_tbl: [(c43Xd,
                       label: sat_s43Pf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43Xd: // global
           _s43Pf::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c43Xe; else goto c43Xf;
       c43Xf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c43Xh; else goto c43Xg;
       c43Xh: // global
           HpAlloc = 24;
           goto c43Xe;
       c43Xe: // global
           R1 = _s43Pf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c43Xg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43Pf::P64;
           _s43Pa::P64 = P64[_s43Pf::P64 + 16];
           _s43Pb::P64 = P64[_s43Pf::P64 + 24];
           I64[Hp - 16] = sat_s43Pc_info;
           P64[Hp] = _s43Pb::P64;
           I64[Sp - 24] = block_c43Xa_info;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = Hp - 16;
           R3 = _s43Pb::P64;
           R2 = _s43Pa::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wreadIntP'_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _c43Xa() //  [R1]
         { info_tbl: [(c43Xa,
                       label: block_c43Xa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43Xa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c43Xk; else goto c43Xj;
       c43Xk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c43Xj: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.readOct_entry() //  [R2, R3]
         { info_tbl: [(c43Xl,
                       label: Numeric.readOct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43Xl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c43Xp; else goto c43Xo;
       c43Xp: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readOct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c43Xo: // global
           I64[Hp - 24] = sat_s43Pf_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.009207749 UTC

[section ""data" . Numeric.readDec_closure" {
     Numeric.readDec_closure:
         const Numeric.readDec_info;
         const 0;
 },
 sat_s43Pi_entry() //  [R1]
         { info_tbl: [(c43XC,
                       label: sat_s43Pi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43XC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c43XD; else goto c43XE;
       c43XD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c43XE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.Read.Lex.numberToFixed1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43Pl_entry() //  [R1]
         { info_tbl: [(c43XI,
                       label: sat_s43Pl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43XI: // global
           _s43Pl::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c43XJ; else goto c43XK;
       c43XK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c43XM; else goto c43XL;
       c43XM: // global
           HpAlloc = 24;
           goto c43XJ;
       c43XJ: // global
           R1 = _s43Pl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c43XL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43Pl::P64;
           _s43Pg::P64 = P64[_s43Pl::P64 + 16];
           _s43Ph::P64 = P64[_s43Pl::P64 + 24];
           I64[Hp - 16] = sat_s43Pi_info;
           P64[Hp] = _s43Ph::P64;
           I64[Sp - 24] = block_c43XF_info;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = Hp - 16;
           R3 = _s43Ph::P64;
           R2 = _s43Pg::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wreadIntP'_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _c43XF() //  [R1]
         { info_tbl: [(c43XF,
                       label: block_c43XF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43XF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c43XP; else goto c43XO;
       c43XP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c43XO: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.readDec_entry() //  [R2, R3]
         { info_tbl: [(c43XQ,
                       label: Numeric.readDec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43XQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c43XU; else goto c43XT;
       c43XU: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readDec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c43XT: // global
           I64[Hp - 24] = sat_s43Pl_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.011788574 UTC

[section ""data" . Numeric.readHex_closure" {
     Numeric.readHex_closure:
         const Numeric.readHex_info;
         const 0;
 },
 sat_s43Po_entry() //  [R1]
         { info_tbl: [(c43Y7,
                       label: sat_s43Po_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43Y7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c43Y8; else goto c43Y9;
       c43Y8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c43Y9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.Read.Lex.readDecP3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43Pr_entry() //  [R1]
         { info_tbl: [(c43Yd,
                       label: sat_s43Pr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43Yd: // global
           _s43Pr::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c43Ye; else goto c43Yf;
       c43Yf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c43Yh; else goto c43Yg;
       c43Yh: // global
           HpAlloc = 24;
           goto c43Ye;
       c43Ye: // global
           R1 = _s43Pr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c43Yg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43Pr::P64;
           _s43Pm::P64 = P64[_s43Pr::P64 + 16];
           _s43Pn::P64 = P64[_s43Pr::P64 + 24];
           I64[Hp - 16] = sat_s43Po_info;
           P64[Hp] = _s43Pn::P64;
           I64[Sp - 24] = block_c43Ya_info;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = Hp - 16;
           R3 = _s43Pn::P64;
           R2 = _s43Pm::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wreadIntP'_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _c43Ya() //  [R1]
         { info_tbl: [(c43Ya,
                       label: block_c43Ya_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43Ya: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c43Yk; else goto c43Yj;
       c43Yk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c43Yj: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.readHex_entry() //  [R2, R3]
         { info_tbl: [(c43Yl,
                       label: Numeric.readHex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43Yl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c43Yp; else goto c43Yo;
       c43Yp: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readHex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c43Yo: // global
           I64[Hp - 24] = sat_s43Pr_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.013891252 UTC

[section ""data" . Numeric.readFloat2_closure" {
     Numeric.readFloat2_closure:
         const Numeric.readFloat2_info;
 },
 Numeric.readFloat2_entry() //  [R2]
         { info_tbl: [(c43Yx,
                       label: Numeric.readFloat2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43Yx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c43Yy; else goto c43Yz;
       c43Yy: // global
           R2 = R2;
           R1 = Numeric.readFloat2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c43Yz: // global
           I64[Sp - 8] = block_c43Yu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u43YD; else goto c43Yv;
       u43YD: // global
           call _c43Yu() args: 0, res: 0, upd: 0;
       c43Yv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c43Yu() //  []
         { info_tbl: [(c43Yu,
                       label: block_c43Yu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43Yu: // global
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.014866103 UTC

[section ""data" . Numeric.readFloat1_closure" {
     Numeric.readFloat1_closure:
         const Text.ParserCombinators.ReadP.Look_con_info;
         const Numeric.readFloat2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.017003539 UTC

[section ""data" . Numeric.readFloat_closure" {
     Numeric.readFloat_closure:
         const Numeric.readFloat_info;
         const 0;
 },
 $dFractional_s43Pw_entry() //  [R1]
         { info_tbl: [(c43YU,
                       label: $dFractional_s43Pw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43YU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c43YV; else goto c43YW;
       c43YV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c43YW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43PD_entry() //  [R1]
         { info_tbl: [(c43Zj,
                       label: sat_s43PD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43Zj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c43Zk; else goto c43Zl;
       c43Zk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c43Zl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c43Zg_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Text.Read.Lex.$wnumberToRational_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c43Zg() //  [R1, R2]
         { info_tbl: [(c43Zg,
                       label: block_c43Zg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43Zg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c43Zo; else goto c43Zn;
       c43Zo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c43Zn: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43PE_entry() //  [R1]
         { info_tbl: [(c43Zp,
                       label: sat_s43PE_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43Zp: // global
           _s43PE::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c43Zq; else goto c43Zr;
       c43Zr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c43Zt; else goto c43Zs;
       c43Zt: // global
           HpAlloc = 24;
           goto c43Zq;
       c43Zq: // global
           R1 = _s43PE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c43Zs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43PE::P64;
           _s43Pw::P64 = P64[_s43PE::P64 + 16];
           _s43Pz::P64 = P64[_s43PE::P64 + 24];
           I64[Hp - 16] = sat_s43PD_info;
           P64[Hp] = _s43Pz::P64;
           R2 = _s43Pw::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Real.fromRational_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43PF_entry() //  [R1, R2]
         { info_tbl: [(c43Zy,
                       label: sat_s43PF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43Zy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c43Zz; else goto c43ZA;
       c43Zz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c43ZA: // global
           I64[Sp - 16] = block_c43Z2_info;
           _s43Pw::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s43Pw::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u43ZH; else goto c43Z3;
       u43ZH: // global
           call _c43Z2(R1) args: 0, res: 0, upd: 0;
       c43Z3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c43Z2() //  [R1]
         { info_tbl: [(c43Z2,
                       label: block_c43Z2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43Z2: // global
           if (R1 & 7 == 6) goto c43Zw; else goto c43Zv;
       c43Zw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c43ZG; else goto c43ZF;
       c43ZG: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c43ZF: // global
           _s43Pz::P64 = P64[R1 + 2];
           I64[Hp - 48] = sat_s43PE_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s43Pz::P64;
           I64[Hp - 16] = Text.ParserCombinators.ReadP.Result_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Text.ParserCombinators.ReadP.Fail_closure+3;
           R1 = Hp - 12;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c43Zv: // global
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43PG_entry() //  [R1]
         { info_tbl: [(c43ZI,
                       label: sat_s43PG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43ZI: // global
           _s43PG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c43ZJ; else goto c43ZK;
       c43ZK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c43ZM; else goto c43ZL;
       c43ZM: // global
           HpAlloc = 40;
           goto c43ZJ;
       c43ZJ: // global
           R1 = _s43PG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c43ZL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43PG::P64;
           _s43Pu::P64 = P64[_s43PG::P64 + 16];
           I64[Hp - 32] = $dFractional_s43Pw_info;
           P64[Hp - 16] = _s43Pu::P64;
           I64[Hp - 8] = sat_s43PF_info;
           P64[Hp] = Hp - 32;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Text.Read.Lex.expect2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl116_s43Pv_entry() //  [R1]
         { info_tbl: [(c43ZN,
                       label: lvl116_s43Pv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43ZN: // global
           _s43Pv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c43ZO; else goto c43ZP;
       c43ZP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c43ZR; else goto c43ZQ;
       c43ZR: // global
           HpAlloc = 24;
           goto c43ZO;
       c43ZO: // global
           R1 = _s43Pv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c43ZQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43Pv::P64;
           _s43Pu::P64 = P64[_s43Pv::P64 + 16];
           I64[Hp - 16] = sat_s43PG_info;
           P64[Hp] = _s43Pu::P64;
           R3 = Hp - 16;
           R2 = Numeric.readFloat1_closure+2;
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 k_s43PH_entry() //  [R1]
         { info_tbl: [(c43ZX,
                       label: k_s43PH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c43ZX: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43PK_entry() //  [R1, R2]
         { info_tbl: [(c4405,
                       label: sat_s43PK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4405: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           call Text.ParserCombinators.ReadP.skipSpaces2_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 Numeric.readFloat_entry() //  [R2]
         { info_tbl: [(c4409,
                       label: Numeric.readFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4409: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c440d; else goto c440c;
       c440d: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Numeric.readFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c440c: // global
           I64[Hp - 64] = lvl116_s43Pv_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = k_s43PH_info;
           P64[Hp - 32] = Hp - 64;
           I64[Hp - 24] = sat_s43PK_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.026750958 UTC

[section ""data" . Numeric.readSigned_closure" {
     Numeric.readSigned_closure:
         const Numeric.readSigned_info;
         const 0;
 },
 $dNum_s43PP_entry() //  [R1]
         { info_tbl: [(c440m,
                       label: $dNum_s43PP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c440m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c440n; else goto c440o;
       c440n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c440o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go1_s43PZ_entry() //  [R1, R2]
         { info_tbl: [(c440S,
                       label: go1_s43PZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c440S: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c440T; else goto u441p;
       c440T: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u441p: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _c440I() args: 0, res: 0, upd: 0;
     }
 },
 _c440I() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c440I: // global
           I64[Sp - 16] = block_c440L_info;
           R1 = P64[Sp + 8];
           _s43PZ::P64 = P64[Sp];
           P64[Sp - 8] = P64[_s43PZ::P64 + 15];
           P64[Sp + 8] = P64[_s43PZ::P64 + 7];
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u441r; else goto c440M;
       u441r: // global
           call _c440L(R1) args: 0, res: 0, upd: 0;
       c440M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c440L() //  [R1]
         { info_tbl: [(c440L,
                       label: block_c440L_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c440L: // global
           if (R1 & 7 == 1) goto c440P; else goto c440Q;
       c440P: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c440Q: // global
           I64[Sp] = block_c4410_info;
           _s43Q3::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 8] = _s43Q3::P64;
           if (R1 & 7 != 0) goto u441s; else goto c4412;
       u441s: // global
           call _c4410(R1) args: 0, res: 0, upd: 0;
       c4412: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4410() //  [R1]
         { info_tbl: [(c4410,
                       label: block_c4410_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4410: // global
           I64[Sp - 8] = block_c4416_info;
           _s43Q5::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s43Q5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u441u; else goto c4418;
       u441u: // global
           call _c4416(R1) args: 0, res: 0, upd: 0;
       c4418: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4416() //  [R1]
         { info_tbl: [(c4416,
                       label: block_c4416_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4416: // global
           _s43Q3::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c441g; else goto c441n;
       c441g: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c441j; else goto c441i;
       c441j: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c441i: // global
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _s43Q3::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 32];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c441n: // global
           P64[Sp + 32] = _s43Q3::P64;
           Sp = Sp + 24;
           call _c440I() args: 0, res: 0, upd: 0;
     }
 },
 go_s43PQ_entry() //  [R1, R2]
         { info_tbl: [(c441A,
                       label: go_s43PQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c441A: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c441B; else goto c441C;
       c441B: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c441C: // global
           I64[Sp - 24] = block_c440u_info;
           _s43PQ::P64 = R1;
           _s43PN::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s43PN::P64;
           P64[Sp - 8] = _s43PQ::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u441P; else goto c440v;
       u441P: // global
           call _c440u(R1) args: 0, res: 0, upd: 0;
       c440v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c440u() //  [R1]
         { info_tbl: [(c440u,
                       label: block_c440u_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c440u: // global
           if (R1 & 7 == 1) goto c441x; else goto c441y;
       c441x: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c441y: // global
           I64[Sp - 8] = block_c440A_info;
           _s43PU::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s43PU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u441O; else goto c440B;
       u441O: // global
           call _c440A(R1) args: 0, res: 0, upd: 0;
       c440B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c440A() //  [R1]
         { info_tbl: [(c440A,
                       label: block_c440A_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c440A: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c441J; else goto c441I;
       c441J: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c441I: // global
           _s43PW::P64 = P64[R1 + 7];
           _s43PX::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = go1_s43PZ_info;
           P64[Hp - 8] = _s43PX::P64;
           P64[Hp] = Hp - 48;
           _s43PN::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c441F_info;
           R2 = _s43PW::P64;
           R1 = _s43PN::P64;
           P64[Sp + 24] = Hp - 15;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c441F() //  [R1]
         { info_tbl: [(c441F,
                       label: block_c441F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c441F: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_s43PZ_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43QB_entry() //  [R1]
         { info_tbl: [(c442L,
                       label: sat_s43QB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c442L: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c442M; else goto c442N;
       c442M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c442N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go2_s43Qt_entry() //  [R1, R2]
         { info_tbl: [(c442S,
                       label: go2_s43Qt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c442S: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c442T; else goto c442U;
       c442T: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c442U: // global
           I64[Sp - 32] = block_c442v_info;
           _s43Qt::P64 = R1;
           _s43PP::P64 = P64[R1 + 7];
           _s43Qs::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s43PP::P64;
           P64[Sp - 16] = _s43Qs::P64;
           P64[Sp - 8] = _s43Qt::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4434; else goto c442w;
       u4434: // global
           call _c442v(R1) args: 0, res: 0, upd: 0;
       c442w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c442v() //  [R1]
         { info_tbl: [(c442v,
                       label: block_c442v_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c442v: // global
           if (R1 & 7 == 1) goto c442P; else goto c442Q;
       c442P: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c442Q: // global
           I64[Sp] = block_c442B_info;
           _s43Qx::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _s43Qx::P64;
           if (R1 & 7 != 0) goto u4433; else goto c442C;
       u4433: // global
           call _c442B(R1) args: 0, res: 0, upd: 0;
       c442C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c442B() //  [R1]
         { info_tbl: [(c442B,
                       label: block_c442B_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c442B: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c4432; else goto c4431;
       c4432: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4431: // global
           _s43Qz::P64 = P64[R1 + 7];
           _s43QA::P64 = P64[R1 + 15];
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 16];
           I64[Hp - 72] = sat_s43QB_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _s43Qz::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _s43QA::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 104;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go1_s43Qd_entry() //  [R1, R2]
         { info_tbl: [(c4439,
                       label: go1_s43Qd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4439: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c443a; else goto u443L;
       c443a: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u443L: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _c441S() args: 0, res: 0, upd: 0;
     }
 },
 _c441S() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c441S: // global
           I64[Sp - 16] = block_c441V_info;
           R1 = P64[Sp + 8];
           _s43Qd::P64 = P64[Sp];
           P64[Sp - 8] = P64[_s43Qd::P64 + 15];
           P64[Sp + 8] = P64[_s43Qd::P64 + 7];
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u443Q; else goto c441W;
       u443Q: // global
           call _c441V(R1) args: 0, res: 0, upd: 0;
       c441W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c441V() //  [R1]
         { info_tbl: [(c441V,
                       label: block_c441V_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c441V: // global
           if (R1 & 7 == 1) goto c4436; else goto c4437;
       c4436: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4437: // global
           I64[Sp - 8] = block_c4421_info;
           _s43Qh::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s43Qh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u443R; else goto c4422;
       u443R: // global
           call _c4421(R1) args: 0, res: 0, upd: 0;
       c4422: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4421() //  [R1]
         { info_tbl: [(c4421,
                       label: block_c4421_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4421: // global
           I64[Sp - 8] = block_c4426_info;
           _s43Qk::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s43Qk::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u443S; else goto c4427;
       u443S: // global
           call _c4426(R1) args: 0, res: 0, upd: 0;
       c4427: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4426() //  [R1]
         { info_tbl: [(c4426,
                       label: block_c4426_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4426: // global
           if (R1 & 7 == 1) goto u443M; else goto c443l;
       u443M: // global
           Sp = Sp + 16;
           call _c443I() args: 0, res: 0, upd: 0;
       c443l: // global
           I64[Sp - 8] = block_c442c_info;
           _s43Qn::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s43Qn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u443T; else goto c442d;
       u443T: // global
           call _c442c(R1) args: 0, res: 0, upd: 0;
       c442d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c442c() //  [R1]
         { info_tbl: [(c442c,
                       label: block_c442c_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c442c: // global
           if (I64[R1 + 7] == 45) goto c443p; else goto u443N;
       c443p: // global
           _s43Qn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c442k_info;
           R1 = _s43Qn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u443V; else goto c442l;
       u443V: // global
           call _c442k(R1) args: 0, res: 0, upd: 0;
       c442l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u443N: // global
           Sp = Sp + 24;
           call _c443I() args: 0, res: 0, upd: 0;
     }
 },
 _c442k() //  [R1]
         { info_tbl: [(c442k,
                       label: block_c442k_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c442k: // global
           if (R1 & 7 == 1) goto c443w; else goto u443O;
       c443w: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c443z; else goto c443y;
       c443z: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c443y: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = go2_s43Qt_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = Hp - 48;
           I64[Sp + 16] = block_c443q_info;
           R3 = P64[Sp + 8];
           R2 = GHC.Read.lex1_closure;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u443O: // global
           Sp = Sp + 16;
           call _c443I() args: 0, res: 0, upd: 0;
     }
 },
 _c443q() //  [R1]
         { info_tbl: [(c443q,
                       label: block_c443q_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c443q: // global
           I64[Sp + 16] = block_c443u_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s43PQ_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c443u() //  [R1]
         { info_tbl: [(c443u,
                       label: block_c443u_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c443u: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go2_s43Qt_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c443I() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c443I: // global
           P64[Sp + 24] = P64[Sp];
           Sp = Sp + 16;
           call _c441S() args: 0, res: 0, upd: 0;
     }
 },
 sat_s43QM_entry() //  [R1]
         { info_tbl: [(c444b,
                       label: sat_s43QM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c444b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c444c; else goto c444d;
       c444c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c444d: // global
           I64[Sp - 16] = block_c4449_info;
           R3 = P64[R1 + 24];
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 8] = P64[R1 + 16];
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4449() //  [R1]
         { info_tbl: [(c4449,
                       label: block_c4449_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4449: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_s43Qd_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43QN_entry() //  [R1, R2]
         { info_tbl: [(c444j,
                       label: sat_s43QN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c444j: // global
           _s43QI::P64 = R2;
           _s43QN::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c444n; else goto c444o;
       c444o: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c444q; else goto c444p;
       c444q: // global
           HpAlloc = 32;
           goto c444n;
       c444n: // global
           R2 = _s43QI::P64;
           R1 = _s43QN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c444p: // global
           _s43PQ::P64 = P64[_s43QN::P64 + 7];
           _s43Qd::P64 = P64[_s43QN::P64 + 15];
           I64[Hp - 24] = sat_s43QM_info;
           P64[Hp - 8] = _s43Qd::P64;
           P64[Hp] = _s43QI::P64;
           I64[Sp - 24] = block_c444h_info;
           R3 = _s43QI::P64;
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _s43PQ::P64;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c444h() //  [R1]
         { info_tbl: [(c444h,
                       label: block_c444h_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c444h: // global
           I64[Sp] = block_c444m_info;
           R2 = R1;
           R1 = P64[Sp + 16];
           call go_s43PQ_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c444m() //  [R1]
         { info_tbl: [(c444m,
                       label: block_c444m_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c444m: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Numeric.readSigned_entry() //  [R2, R3, R4]
         { info_tbl: [(c444w,
                       label: Numeric.readSigned_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c444w: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c444A; else goto c444z;
       c444A: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readSigned_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c444z: // global
           I64[Hp - 80] = $dNum_s43PP_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = go_s43PQ_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = go1_s43Qd_info;
           P64[Hp - 32] = Hp - 80;
           _c440p::P64 = Hp - 55;
           P64[Hp - 24] = _c440p::P64;
           I64[Hp - 16] = sat_s43QN_info;
           P64[Hp - 8] = _c440p::P64;
           P64[Hp] = Hp - 39;
           R4 = R4;
           R3 = Hp - 15;
           R2 = GHC.Types.False_closure+1;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.035340263 UTC

[section ""data" . sat_s43QO_closure" {
     sat_s43QO_closure:
         const GHC.Types.I#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.03594486 UTC

[section ""data" . sat_s43QP_closure" {
     sat_s43QP_closure:
         const :_con_info;
         const sat_s43QO_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.036795385 UTC

[section ""data" . Numeric.showInt2_closure" {
     Numeric.showInt2_closure:
         const Numeric.showInt2_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showInt2_entry() //  [R1]
         { info_tbl: [(c444H,
                       label: Numeric.showInt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c444H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c444I; else goto c444J;
       c444I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c444J: // global
           (_c444E::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c444E::I64 == 0) goto c444G; else goto c444F;
       c444G: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c444F: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c444E::I64;
           R3 = sat_s43QP_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.037798015 UTC

[section ""cstring" . lvl_r43OH_bytes" {
     lvl_r43OH_bytes:
         I8[] [78,117,109,101,114,105,99,46,115,104,111,119,73,110,116,58,32,99,97,110,39,116,32,115,104,111,119,32,110,101,103,97,116,105,118,101,32,110,117,109,98,101,114,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.038574043 UTC

[section ""data" . Numeric.showInt1_closure" {
     Numeric.showInt1_closure:
         const Numeric.showInt1_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showInt1_entry() //  [R1]
         { info_tbl: [(c444S,
                       label: Numeric.showInt1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c444S: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c444T; else goto c444U;
       c444T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c444U: // global
           (_c444N::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c444N::I64 == 0) goto c444P; else goto c444O;
       c444P: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c444O: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c444N::I64;
           I64[Sp - 24] = block_c444Q_info;
           R2 = lvl_r43OH_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c444Q() //  [R1]
         { info_tbl: [(c444Q,
                       label: block_c444Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c444Q: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.039765951 UTC

[section ""data" . Numeric.showHFloat16_closure" {
     Numeric.showHFloat16_closure:
         const Numeric.showHFloat16_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat16_entry() //  [R1]
         { info_tbl: [(c4454,
                       label: Numeric.showHFloat16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4454: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4455; else goto c4456;
       c4455: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4456: // global
           (_c4451::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4451::I64 == 0) goto c4453; else goto c4452;
       c4453: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4452: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4451::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.042871652 UTC

[section ""data" . Numeric.showInt_closure" {
     Numeric.showInt_closure:
         const Numeric.showInt_info;
         const 0;
 },
 sat_s43QX_entry() //  [R1]
         { info_tbl: [(c4464,
                       label: sat_s43QX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4464: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4465; else goto c4466;
       c4465: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4466: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4462_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4462() //  [R1]
         { info_tbl: [(c4462,
                       label: block_c4462_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4462: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showHFloat16_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl5_s43QZ_entry() //  [R1]
         { info_tbl: [(c446e,
                       label: lvl5_s43QZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c446e: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c446f; else goto c446g;
       c446f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c446g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c446c_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c446c() //  [R1]
         { info_tbl: [(c446c,
                       label: block_c446c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c446c: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showInt2_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s43Re_entry() //  [R1]
         { info_tbl: [(c446m,
                       label: ds_s43Re_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c446m: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c446n; else goto c446o;
       c446n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c446o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quotRem_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Numeric.showInt_entry() //  [R2, R3, R4]
         { info_tbl: [(c446p,
                       label: Numeric.showInt_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c446p: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c446q; else goto c446r;
       c446q: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showInt_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c446r: // global
           I64[Sp - 32] = block_c445b_info;
           _s43QR::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s43QR::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c445b() //  [R1]
         { info_tbl: [(c445b,
                       label: block_c445b_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c445b: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c446u; else goto c446t;
       c446u: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c446t: // global
           I64[Hp - 16] = sat_s43QX_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c445h_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c445h() //  [R1]
         { info_tbl: [(c445h,
                       label: block_c445h_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c445h: // global
           I64[Sp] = block_c445l_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c445l() //  [R1]
         { info_tbl: [(c445l,
                       label: block_c445l_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c445l: // global
           if (R1 & 7 == 1) goto c446x; else goto c447h;
       c446x: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c446A; else goto c446z;
       c446A: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c446z: // global
           I64[Hp - 16] = lvl5_s43QZ_info;
           _s43QU::P64 = P64[Sp + 8];
           P64[Hp] = _s43QU::P64;
           I64[Sp + 8] = block_c445r_info;
           R2 = _s43QU::P64;
           P64[Sp + 16] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
       c447h: // global
           R1 = Numeric.showInt1_closure;
           Sp = Sp + 48;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c445r() //  [R1]
         { info_tbl: [(c445r,
                       label: block_c445r_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c445r: // global
           P64[Sp] = P64[Sp + 32];
           P64[Sp + 24] = P64[Sp + 24];
           P64[Sp + 32] = R1;
           call _c445A() args: 0, res: 0, upd: 0;
     }
 },
 _c445A() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c445A: // global
           I64[Sp - 8] = block_c445C_info;
           R2 = P64[Sp + 32];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 24];
           P64[Sp - 16] = P64[Sp + 8];
           Sp = Sp - 32;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c445C() //  [R1]
         { info_tbl: [(c445C,
                       label: block_c445C_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c445C: // global
           _s43QR::P64 = P64[Sp + 24];
           _s43Rb::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c4472; else goto c447d;
       c4472: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c4475; else goto c4474;
       c4475: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4474: // global
           I64[Hp - 56] = ds_s43Re_info;
           P64[Hp - 40] = _s43QR::P64;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s43Rb::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           _c445G::P64 = Hp - 56;
           P64[Hp] = _c445G::P64;
           I64[Sp] = block_c445J_info;
           R2 = _s43QR::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           P64[Sp + 32] = _c445G::P64;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
       c447d: // global
           I64[Sp + 32] = block_c446F_info;
           R2 = _s43QR::P64;
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = _s43Rb::P64;
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c445J() //  [R1]
         { info_tbl: [(c445J,
                       label: block_c445J_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c445J: // global
           I64[Sp] = block_c445N_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c445N() //  [R1]
         { info_tbl: [(c445N,
                       label: block_c445N_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c445N: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c4479; else goto c4478;
       c4479: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4478: // global
           I64[Hp - 56] = GHC.Types.C#_con_info;
           I64[Hp - 48] = R1 + 48;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 55;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = P64[Sp + 32];
           P64[Sp + 32] = Hp - 16;
           P64[Sp + 8] = Hp - 38;
           Sp = Sp + 8;
           call _c445A() args: 0, res: 0, upd: 0;
     }
 },
 _c446F() //  [R1]
         { info_tbl: [(c446F,
                       label: block_c446F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c446F: // global
           I64[Sp] = block_c446J_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c446J() //  [R1]
         { info_tbl: [(c446J,
                       label: block_c446J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c446J: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c446Z; else goto c446Y;
       c446Z: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c446Y: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = R1 + 48;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.047757155 UTC

[section ""data" . Numeric.showFFloatAlt_closure" {
     Numeric.showFFloatAlt_closure:
         const Numeric.showFFloatAlt_info;
         const 0;
 },
 sat_s43Rw_entry() //  [R1]
         { info_tbl: [(c447w,
                       label: sat_s43Rw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c447w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c447x; else goto c447y;
       c447x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c447y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.True_closure+2;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFFixed_closure+2;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showFFloatAlt_entry() //  [R2, R3, R4]
         { info_tbl: [(c447z,
                       label: Numeric.showFFloatAlt_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c447z: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c447D; else goto c447C;
       c447D: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showFFloatAlt_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c447C: // global
           I64[Hp - 32] = sat_s43Rw_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.049400077 UTC

[section ""data" . Numeric.showGFloatAlt_closure" {
     Numeric.showGFloatAlt_closure:
         const Numeric.showGFloatAlt_info;
         const 0;
 },
 sat_s43RA_entry() //  [R1]
         { info_tbl: [(c447M,
                       label: sat_s43RA_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c447M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c447N; else goto c447O;
       c447N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c447O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.True_closure+2;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFGeneric_closure+3;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showGFloatAlt_entry() //  [R2, R3, R4]
         { info_tbl: [(c447P,
                       label: Numeric.showGFloatAlt_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c447P: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c447T; else goto c447S;
       c447T: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showGFloatAlt_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c447S: // global
           I64[Hp - 32] = sat_s43RA_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.0505693 UTC

[section ""cstring" . lvl1_r43OI_bytes" {
     lvl1_r43OI_bytes:
         I8[] [78,117,109,101,114,105,99,46,115,104,111,119,73,110,116,65,116,66,97,115,101,58,32,97,112,112,108,105,101,100,32,116,111,32,110,101,103,97,116,105,118,101,32,110,117,109,98,101,114,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.051691862 UTC

[section ""data" . Numeric.$wlvl_closure" {
     Numeric.$wlvl_closure:
         const Numeric.$wlvl_info;
         const 0;
 },
 sat_s43RF_entry() //  [R1]
         { info_tbl: [(c4485,
                       label: sat_s43RF_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4485: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4486; else goto c4487;
       c4486: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4487: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4482_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4482() //  [R1, R2]
         { info_tbl: [(c4482,
                       label: block_c4482_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4482: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c448a; else goto c4489;
       c448a: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4489: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.$wlvl_entry() //  [R2]
         { info_tbl: [(c448d,
                       label: Numeric.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c448d: // global
           _s43RB::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c448e; else goto c448f;
       c448f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c448h; else goto c448g;
       c448h: // global
           HpAlloc = 24;
           goto c448e;
       c448e: // global
           R2 = _s43RB::I64;
           R1 = Numeric.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c448g: // global
           I64[Hp - 16] = sat_s43RF_info;
           I64[Hp] = _s43RB::I64;
           I64[Sp - 8] = block_c448b_info;
           R3 = Hp - 16;
           R2 = lvl1_r43OI_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c448b() //  [R1]
         { info_tbl: [(c448b,
                       label: block_c448b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c448b: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.053314967 UTC

[section ""cstring" . lvl2_r43OJ_bytes" {
     lvl2_r43OJ_bytes:
         I8[] [78,117,109,101,114,105,99,46,115,104,111,119,73,110,116,65,116,66,97,115,101,58,32,97,112,112,108,105,101,100,32,116,111,32,117,110,115,117,112,112,111,114,116,101,100,32,98,97,115,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.054370009 UTC

[section ""data" . Numeric.showIntAtBase2_closure" {
     Numeric.showIntAtBase2_closure:
         const Numeric.showIntAtBase2_info;
         const 0;
 },
 sat_s43RJ_entry() //  [R1]
         { info_tbl: [(c448t,
                       label: sat_s43RJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c448t: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c448u; else goto c448v;
       c448u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c448v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Numeric.showIntAtBase2_entry() //  [R2, R3]
         { info_tbl: [(c448y,
                       label: Numeric.showIntAtBase2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c448y: // global
           _s43RI::P64 = R3;
           _s43RH::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c448z; else goto c448A;
       c448A: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c448C; else goto c448B;
       c448C: // global
           HpAlloc = 32;
           goto c448z;
       c448z: // global
           R3 = _s43RI::P64;
           R2 = _s43RH::P64;
           R1 = Numeric.showIntAtBase2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c448B: // global
           I64[Hp - 24] = sat_s43RJ_info;
           P64[Hp - 8] = _s43RH::P64;
           P64[Hp] = _s43RI::P64;
           I64[Sp - 8] = block_c448w_info;
           R3 = Hp - 24;
           R2 = lvl1_r43OI_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c448w() //  [R1]
         { info_tbl: [(c448w,
                       label: block_c448w_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c448w: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.056156805 UTC

[section ""data" . Numeric.showIntAtBase1_closure" {
     Numeric.showIntAtBase1_closure:
         const Numeric.showIntAtBase1_info;
         const 0;
 },
 sat_s43RN_entry() //  [R1]
         { info_tbl: [(c448O,
                       label: sat_s43RN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c448O: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c448P; else goto c448Q;
       c448P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c448Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Numeric.showIntAtBase1_entry() //  [R2, R3]
         { info_tbl: [(c448T,
                       label: Numeric.showIntAtBase1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c448T: // global
           _s43RM::P64 = R3;
           _s43RL::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c448U; else goto c448V;
       c448V: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c448X; else goto c448W;
       c448X: // global
           HpAlloc = 32;
           goto c448U;
       c448U: // global
           R3 = _s43RM::P64;
           R2 = _s43RL::P64;
           R1 = Numeric.showIntAtBase1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c448W: // global
           I64[Hp - 24] = sat_s43RN_info;
           P64[Hp - 8] = _s43RL::P64;
           P64[Hp] = _s43RM::P64;
           I64[Sp - 8] = block_c448R_info;
           R3 = Hp - 24;
           R2 = lvl2_r43OJ_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c448R() //  [R1]
         { info_tbl: [(c448R,
                       label: block_c448R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c448R: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.05752947 UTC

[section ""data" . sat_s43RP_closure" {
     sat_s43RP_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.05813685 UTC

[section ""data" . sat_s43RQ_closure" {
     sat_s43RQ_closure:
         const :_con_info;
         const sat_s43RP_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.058958632 UTC

[section ""data" . Numeric.showIntAtBase3_closure" {
     Numeric.showIntAtBase3_closure:
         const Numeric.showIntAtBase3_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showIntAtBase3_entry() //  [R1]
         { info_tbl: [(c4497,
                       label: Numeric.showIntAtBase3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4497: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4498; else goto c4499;
       c4498: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4499: // global
           (_c4494::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4494::I64 == 0) goto c4496; else goto c4495;
       c4496: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4495: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4494::I64;
           R3 = sat_s43RQ_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.062456802 UTC

[section ""data" . Numeric.showIntAtBase_closure" {
     Numeric.showIntAtBase_closure:
         const Numeric.showIntAtBase_info;
         const 0;
 },
 $dNum_s43RY_entry() //  [R1]
         { info_tbl: [(c44a6,
                       label: $dNum_s43RY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44a6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44a7; else goto c44a8;
       c44a7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44a8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43S0_entry() //  [R1]
         { info_tbl: [(c44ab,
                       label: sat_s43S0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44ab: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44ac; else goto c44ad;
       c44ac: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44ad: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showIntAtBase3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43S2_entry() //  [R1]
         { info_tbl: [(c44ag,
                       label: sat_s43S2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44ag: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44ah; else goto c44ai;
       c44ah: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44ai: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showHFloat16_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl5_s43S7_entry() //  [R1]
         { info_tbl: [(c44al,
                       label: lvl5_s43S7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44al: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44am; else goto c44an;
       c44am: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44an: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showHFloat16_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43Sf_entry() //  [R1]
         { info_tbl: [(c44as,
                       label: sat_s43Sf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44as: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c44aA; else goto c44aB;
       c44aA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44aB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c44aq_info;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c44aq() //  [R1]
         { info_tbl: [(c44aq,
                       label: block_c44aq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44aq: // global
           I64[Sp] = block_c44av_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44av() //  [R1]
         { info_tbl: [(c44av,
                       label: block_c44av_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44av: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c44aF; else goto c44aE;
       c44aF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c44aE: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showIntAtBase_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c44aG,
                       label: Numeric.showIntAtBase_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44aG: // global
           if ((Sp + -88) < SpLim) (likely: False) goto c44aH; else goto c44aI;
       c44aH: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showIntAtBase_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c44aI: // global
           I64[Sp - 48] = block_c449e_info;
           _s43RR::P64 = R2;
           R2 = R2;
           P64[Sp - 40] = _s43RR::P64;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c449e() //  [R1]
         { info_tbl: [(c449e,
                       label: block_c449e_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c449e: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44aL; else goto c44aK;
       c44aL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44aK: // global
           I64[Hp - 16] = $dNum_s43RY_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c449k_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c449k() //  [R1]
         { info_tbl: [(c449k,
                       label: block_c449k_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c449k: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44aO; else goto c44aN;
       c44aO: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44aN: // global
           I64[Hp - 16] = sat_s43S0_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c449q_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 32];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c449q() //  [R1]
         { info_tbl: [(c449q,
                       label: block_c449q_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c449q: // global
           if (R1 & 7 == 1) goto c44aQ; else goto c44bp;
       c44aQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44aT; else goto c44aS;
       c44aT: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44aS: // global
           I64[Hp - 16] = sat_s43S2_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp] = block_c449w_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 56];
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
       c44bp: // global
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           Sp = Sp + 72;
           call Numeric.showIntAtBase1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c449w() //  [R1]
         { info_tbl: [(c449w,
                       label: block_c449w_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c449w: // global
           _s43RV::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto c44aW; else goto c44bl;
       c44aW: // global
           I64[Sp] = block_c449A_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s43RV::P64;
           P64[Sp - 8] = P64[Sp + 40];
           Sp = Sp - 24;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 8;
       c44bl: // global
           R3 = _s43RV::P64;
           R2 = P64[Sp + 32];
           Sp = Sp + 72;
           call Numeric.showIntAtBase2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c449A() //  [R1]
         { info_tbl: [(c449A,
                       label: block_c449A_info
                       rep:StackRep [False, False, False, True, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c449A: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44aZ; else goto c44aY;
       c44aZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44aY: // global
           _s43S5::P64 = P64[R1 + 7];
           _s43S6::P64 = P64[R1 + 15];
           I64[Hp - 16] = lvl5_s43S7_info;
           P64[Hp] = P64[Sp + 16];
           _s43RZ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c449G_info;
           R2 = _s43RZ::P64;
           P64[Sp + 16] = _s43S6::P64;
           P64[Sp + 32] = _s43S5::P64;
           P64[Sp + 56] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c449G() //  [R1]
         { info_tbl: [(c449G,
                       label: block_c449G_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c449G: // global
           P64[Sp] = P64[Sp + 56];
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 24] = P64[Sp + 24];
           P64[Sp + 56] = R1;
           call _c449N() args: 0, res: 0, upd: 0;
     }
 },
 _c449N() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c449N: // global
           Hp = Hp + 32;
           _s43Sb::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c44b3; else goto c44b2;
       c44b3: // global
           HpAlloc = 32;
           I64[Sp + 8] = block_c449M_info;
           R3 = P64[Sp];
           R2 = _s43Sb::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 8;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       c44b2: // global
           I64[Hp - 24] = sat_s43Sf_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s43Sb::P64;
           I64[Sp - 8] = block_c449R_info;
           R2 = Hp - 24;
           R1 = P64[Sp + 40];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c449M() //  [R1, R2, R3]
         { info_tbl: [(c449M,
                       label: block_c449M_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c449M: // global
           P64[Sp + 16] = R1;
           P64[Sp] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 8;
           call _c449N() args: 0, res: 0, upd: 0;
     }
 },
 _c449R() //  [R1]
         { info_tbl: [(c449R,
                       label: block_c449R_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c449R: // global
           I64[Sp] = block_c449V_info;
           R2 = P64[Sp + 64];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 56];
           P64[Sp + 16] = R1;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c449V() //  [R1]
         { info_tbl: [(c449V,
                       label: block_c449V_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c449V: // global
           if (R1 & 7 == 1) goto c44b7; else goto c44be;
       c44b7: // global
           I64[Sp] = block_c449Z_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 40];
           Sp = Sp - 24;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 8;
       c44be: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44bh; else goto c44bg;
       c44bh: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44bg: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 14;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c449Z() //  [R1]
         { info_tbl: [(c449Z,
                       label: block_c449Z_info
                       rep:StackRep [False, False, False, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c449Z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44ba; else goto c44b9;
       c44ba: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44b9: // global
           _s43Sk::P64 = P64[R1 + 7];
           _s43Sl::P64 = P64[R1 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           P64[Sp + 32] = _s43Sk::P64;
           P64[Sp + 16] = _s43Sl::P64;
           P64[Sp + 8] = Hp - 14;
           Sp = Sp + 8;
           call _c449N() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.069907794 UTC

[section ""data" . sat_s43Sn_closure" {
     sat_s43Sn_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.070553781 UTC

[section ""data" . sat_s43So_closure" {
     sat_s43So_closure:
         const :_con_info;
         const sat_s43Sn_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.071524686 UTC

[section ""data" . Numeric.showHex1_closure" {
     Numeric.showHex1_closure:
         const Numeric.showHex1_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHex1_entry() //  [R1]
         { info_tbl: [(c44bF,
                       label: Numeric.showHex1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44bF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44bG; else goto c44bH;
       c44bG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44bH: // global
           (_c44bC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44bC::I64 == 0) goto c44bE; else goto c44bD;
       c44bE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44bD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44bC::I64;
           R3 = sat_s43So_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.072957424 UTC

[section ""data" . Numeric.showHex_closure" {
     Numeric.showHex_closure:
         const Numeric.showHex_info;
         const 0;
 },
 sat_s43St_entry() //  [R1]
         { info_tbl: [(c44bS,
                       label: sat_s43St_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44bS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44bW; else goto c44bX;
       c44bW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44bX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c44bQ_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44bQ() //  [R1]
         { info_tbl: [(c44bQ,
                       label: block_c44bQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44bQ: // global
           I64[Sp] = block_c44bV_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44bV() //  [R1]
         { info_tbl: [(c44bV,
                       label: block_c44bV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44bV: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showHex1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Numeric.showHex_entry() //  [R2, R3]
         { info_tbl: [(c44c3,
                       label: Numeric.showHex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44c3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44c7; else goto c44c6;
       c44c7: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showHex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44c6: // global
           I64[Hp - 16] = sat_s43St_info;
           P64[Hp] = R2;
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showIntAtBase_closure+6;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.074653537 UTC

[section ""cstring" . Numeric.$trModule4_bytes" {
     Numeric.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.075455615 UTC

[section ""data" . loc_r43OK_closure" {
     loc_r43OK_closure:
         const loc_r43OK_info;
         const 0;
         const 0;
         const 0;
 },
 loc_r43OK_entry() //  [R1]
         { info_tbl: [(c44ce,
                       label: loc_r43OK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44ce: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44cf; else goto c44cg;
       c44cf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44cg: // global
           (_c44cb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44cb::I64 == 0) goto c44cd; else goto c44cc;
       c44cd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44cc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44cb::I64;
           R2 = Numeric.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.076385017 UTC

[section ""cstring" . Numeric.$trModule2_bytes" {
     Numeric.$trModule2_bytes:
         I8[] [78,117,109,101,114,105,99]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.077094292 UTC

[section ""data" . loc1_r43OL_closure" {
     loc1_r43OL_closure:
         const loc1_r43OL_info;
         const 0;
         const 0;
         const 0;
 },
 loc1_r43OL_entry() //  [R1]
         { info_tbl: [(c44cn,
                       label: loc1_r43OL_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44cn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44co; else goto c44cp;
       c44co: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44cp: // global
           (_c44ck::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44ck::I64 == 0) goto c44cm; else goto c44cl;
       c44cm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44cl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44ck::I64;
           R2 = Numeric.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.07804003 UTC

[section ""cstring" . loc2_r43OM_bytes" {
     loc2_r43OM_bytes:
         I8[] [78,117,109,101,114,105,99,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.078762156 UTC

[section ""data" . loc3_r43ON_closure" {
     loc3_r43ON_closure:
         const loc3_r43ON_info;
         const 0;
         const 0;
         const 0;
 },
 loc3_r43ON_entry() //  [R1]
         { info_tbl: [(c44cw,
                       label: loc3_r43ON_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44cw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44cx; else goto c44cy;
       c44cx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44cy: // global
           (_c44ct::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44ct::I64 == 0) goto c44cv; else goto c44cu;
       c44cv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44cu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44ct::I64;
           R2 = loc2_r43OM_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.079633519 UTC

[section ""data" . loc4_r43OO_closure" {
     loc4_r43OO_closure:
         const GHC.Types.I#_con_info;
         const 241;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.080165344 UTC

[section ""data" . loc5_r43OP_closure" {
     loc5_r43OP_closure:
         const GHC.Types.I#_con_info;
         const 22;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.080695358 UTC

[section ""data" . loc6_r43OQ_closure" {
     loc6_r43OQ_closure:
         const GHC.Types.I#_con_info;
         const 75;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.081367356 UTC

[section ""cstring" . $dIP_r43OR_bytes" {
     $dIP_r43OR_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.082156787 UTC

[section ""data" . $dIP1_r43OS_closure" {
     $dIP1_r43OS_closure:
         const $dIP1_r43OS_info;
         const 0;
         const 0;
         const 0;
 },
 $dIP1_r43OS_entry() //  [R1]
         { info_tbl: [(c44cF,
                       label: $dIP1_r43OS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44cF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44cG; else goto c44cH;
       c44cG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44cH: // global
           (_c44cC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44cC::I64 == 0) goto c44cE; else goto c44cD;
       c44cE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44cD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44cC::I64;
           R2 = $dIP_r43OR_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.083106984 UTC

[section ""data" . $dIP2_r43OT_closure" {
     $dIP2_r43OT_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const loc_r43OK_closure;
         const loc1_r43OL_closure;
         const loc3_r43ON_closure;
         const loc4_r43OO_closure+1;
         const loc5_r43OP_closure+1;
         const loc4_r43OO_closure+1;
         const loc6_r43OQ_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.083682829 UTC

[section ""data" . $dIP3_r43OU_closure" {
     $dIP3_r43OU_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const $dIP1_r43OS_closure;
         const $dIP2_r43OT_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.084239413 UTC

[section ""cstring" . lvl3_r43OV_bytes" {
     lvl3_r43OV_bytes:
         I8[] [73,109,112,111,115,115,105,98,108,101,32,104,97,112,112,101,110,101,100,58,32,115,104,111,119,72,70,108,111,97,116,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.084769519 UTC

[section ""data" . lvl4_r43OW_closure" {
     lvl4_r43OW_closure:
         const :_con_info;
         const GHC.Show.$fShow(,)2_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.086381265 UTC

[section ""data" . $wlvl2_r43OX_closure" {
     $wlvl2_r43OX_closure:
         const $wlvl2_r43OX_info;
         const 0;
 },
 sat_s43SB_entry() //  [R1, R2]
         { info_tbl: [(c44cY,
                       label: sat_s43SB_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44cY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c44cZ; else goto c44d0;
       c44cZ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c44d0: // global
           I64[Sp - 8] = block_c44cV_info;
           R4 = R2;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44cV() //  [R1, R2]
         { info_tbl: [(c44cV,
                       label: block_c44cV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44cV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44d3; else goto c44d2;
       c44d3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c44d2: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43Sw_entry() //  [R1, R2]
         { info_tbl: [(c44da,
                       label: sat_s43Sw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44da: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Show.$fShowInt_$cshowList_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43SE_entry() //  [R1]
         { info_tbl: [(c44de,
                       label: sat_s43SE_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44de: // global
           _s43SE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c44df; else goto c44dg;
       c44dg: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c44di; else goto c44dh;
       c44di: // global
           HpAlloc = 80;
           goto c44df;
       c44df: // global
           R1 = _s43SE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44dh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43SE::P64;
           _s43Su::P64 = P64[_s43SE::P64 + 16];
           _s43Sv::I64 = I64[_s43SE::P64 + 24];
           I64[Hp - 72] = sat_s43SB_info;
           I64[Hp - 64] = _s43Sv::I64;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           I64[Hp - 32] = sat_s43Sw_info;
           P64[Hp - 24] = _s43Su::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 54;
           R3 = lvl4_r43OW_closure+2;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Show.$fShow(,)_go1_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl2_r43OX_entry() //  [R2, R3]
         { info_tbl: [(c44dm,
                       label: $wlvl2_r43OX_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44dm: // global
           _s43Sv::I64 = R3;
           _s43Su::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c44dn; else goto c44do;
       c44do: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c44dq; else goto c44dp;
       c44dq: // global
           HpAlloc = 56;
           goto c44dn;
       c44dn: // global
           R3 = _s43Sv::I64;
           R2 = _s43Su::P64;
           R1 = $wlvl2_r43OX_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44dp: // global
           I64[Hp - 48] = sat_s43SE_info;
           P64[Hp - 32] = _s43Su::P64;
           I64[Hp - 24] = _s43Sv::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           I64[Sp - 8] = block_c44dk_info;
           R3 = Hp - 14;
           R2 = lvl3_r43OV_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44dk() //  [R1]
         { info_tbl: [(c44dk,
                       label: block_c44dk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44dk: // global
           R3 = R1;
           R2 = $dIP3_r43OU_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.089348021 UTC

[section ""data" . Numeric.showHFloat_allZ_closure" {
     Numeric.showHFloat_allZ_closure:
         const Numeric.showHFloat_allZ_info;
 },
 Numeric.showHFloat_allZ_entry() //  [R2]
         { info_tbl: [(c44dF,
                       label: Numeric.showHFloat_allZ_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44dF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44dG; else goto u44dY;
       c44dG: // global
           R2 = R2;
           R1 = Numeric.showHFloat_allZ_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u44dY: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c44dv() args: 0, res: 0, upd: 0;
     }
 },
 _c44dv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44dv: // global
           _s43SH::P64 = P64[Sp];
           I64[Sp] = block_c44dy_info;
           R1 = _s43SH::P64;
           if (R1 & 7 != 0) goto u44e0; else goto c44dz;
       u44e0: // global
           call _c44dy(R1) args: 0, res: 0, upd: 0;
       c44dz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44dy() //  [R1]
         { info_tbl: [(c44dy,
                       label: block_c44dy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44dy: // global
           if (R1 & 7 == 1) goto c44dC; else goto c44dD;
       c44dC: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c44dD: // global
           I64[Sp - 8] = block_c44dN_info;
           _s43SK::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s43SK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44e1; else goto c44dP;
       u44e1: // global
           call _c44dN(R1) args: 0, res: 0, upd: 0;
       c44dP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44dN() //  [R1]
         { info_tbl: [(c44dN,
                       label: block_c44dN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44dN: // global
           if (I64[R1 + 7] == 0) goto c44dX; else goto c44dW;
       c44dX: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c44dv() args: 0, res: 0, upd: 0;
       c44dW: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.091621412 UTC

[section ""data" . $wshowIt1_r43OY_closure" {
     $wshowIt1_r43OY_closure:
         const $wshowIt1_r43OY_info;
         const 0;
 },
 $wshowIt1_r43OY_entry() //  [R2, R3, R4]
         { info_tbl: [(c44em,
                       label: $wshowIt1_r43OY_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44em: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44en; else goto u44ez;
       c44en: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wshowIt1_r43OY_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u44ez: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c44e5() args: 0, res: 0, upd: 0;
     }
 },
 _c44e5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44e5: // global
           I64[Sp - 8] = block_c44e8_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44eB; else goto c44e9;
       u44eB: // global
           call _c44e8(R1) args: 0, res: 0, upd: 0;
       c44e9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44e8() //  [R1]
         { info_tbl: [(c44e8,
                       label: block_c44e8_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44e8: // global
           I64[Sp] = block_c44ed_info;
           R2 = I64[R1 + 7];
           call GHC.Show.$wintToDigit_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44ed() //  [R1]
         { info_tbl: [(c44ed,
                       label: block_c44ed_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44ed: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c44es; else goto c44er;
       c44es: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c44er: // global
           _s43SQ::P64 = P64[Sp + 24];
           _s43SU::I64 = I64[Sp + 8];
           if (_s43SU::I64 == 0) goto c44ey; else goto c44eu;
       c44ey: // global
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43SQ::P64;
           _c44ex::P64 = Hp - 30;
           Hp = Hp - 16;
           R1 = _c44ex::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c44eu: // global
           (_s43SW::I64, _s43SX::I64) = call MO_S_QuotRem W64(_s43SU::I64, 16);
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43SQ::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43SX::I64;
           I64[Sp + 8] = _s43SW::I64;
           P64[Sp + 16] = Hp - 7;
           P64[Sp + 24] = Hp - 30;
           Sp = Sp + 8;
           call _c44e5() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.094189617 UTC

[section ""data" . $wshowIt2_r43OZ_closure" {
     $wshowIt2_r43OZ_closure:
         const $wshowIt2_r43OZ_info;
         const 0;
 },
 $wshowIt2_r43OZ_entry() //  [R2, R3, R4]
         { info_tbl: [(c44eW,
                       label: $wshowIt2_r43OZ_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44eW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44eX; else goto u44f9;
       c44eX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wshowIt2_r43OZ_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u44f9: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c44eF() args: 0, res: 0, upd: 0;
     }
 },
 _c44eF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44eF: // global
           I64[Sp - 8] = block_c44eI_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44fb; else goto c44eJ;
       u44fb: // global
           call _c44eI(R1) args: 0, res: 0, upd: 0;
       c44eJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44eI() //  [R1]
         { info_tbl: [(c44eI,
                       label: block_c44eI_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44eI: // global
           I64[Sp] = block_c44eN_info;
           R2 = I64[R1 + 7];
           call GHC.Show.$wintToDigit_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44eN() //  [R1]
         { info_tbl: [(c44eN,
                       label: block_c44eN_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44eN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c44f2; else goto c44f1;
       c44f2: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c44f1: // global
           _s43T4::P64 = P64[Sp + 24];
           _s43T8::I64 = I64[Sp + 8];
           if (_s43T8::I64 == 0) goto c44f8; else goto c44f4;
       c44f8: // global
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43T4::P64;
           _c44f7::P64 = Hp - 30;
           Hp = Hp - 16;
           R1 = _c44f7::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c44f4: // global
           (_s43Ta::I64, _s43Tb::I64) = call MO_S_QuotRem W64(_s43T8::I64, 16);
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43T4::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43Tb::I64;
           I64[Sp + 8] = _s43Ta::I64;
           P64[Sp + 16] = Hp - 7;
           P64[Sp + 24] = Hp - 30;
           Sp = Sp + 8;
           call _c44eF() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.096506356 UTC

[section ""data" . $wshowIt3_r43P0_closure" {
     $wshowIt3_r43P0_closure:
         const $wshowIt3_r43P0_info;
         const 0;
 },
 $wshowIt3_r43P0_entry() //  [R2, R3, R4]
         { info_tbl: [(c44fw,
                       label: $wshowIt3_r43P0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44fw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44fx; else goto u44fJ;
       c44fx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wshowIt3_r43P0_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u44fJ: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c44ff() args: 0, res: 0, upd: 0;
     }
 },
 _c44ff() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44ff: // global
           I64[Sp - 8] = block_c44fi_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44fL; else goto c44fj;
       u44fL: // global
           call _c44fi(R1) args: 0, res: 0, upd: 0;
       c44fj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44fi() //  [R1]
         { info_tbl: [(c44fi,
                       label: block_c44fi_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44fi: // global
           I64[Sp] = block_c44fn_info;
           R2 = I64[R1 + 7];
           call GHC.Show.$wintToDigit_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44fn() //  [R1]
         { info_tbl: [(c44fn,
                       label: block_c44fn_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44fn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c44fC; else goto c44fB;
       c44fC: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c44fB: // global
           _s43Ti::P64 = P64[Sp + 24];
           _s43Tm::I64 = I64[Sp + 8];
           if (_s43Tm::I64 == 0) goto c44fI; else goto c44fE;
       c44fI: // global
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43Ti::P64;
           _c44fH::P64 = Hp - 30;
           Hp = Hp - 16;
           R1 = _c44fH::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c44fE: // global
           (_s43To::I64, _s43Tp::I64) = call MO_S_QuotRem W64(_s43Tm::I64, 16);
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43Ti::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43Tp::I64;
           I64[Sp + 8] = _s43To::I64;
           P64[Sp + 16] = Hp - 7;
           P64[Sp + 24] = Hp - 30;
           Sp = Sp + 8;
           call _c44ff() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.099002594 UTC

[section ""data" . $wshowIt4_r43P1_closure" {
     $wshowIt4_r43P1_closure:
         const $wshowIt4_r43P1_info;
         const 0;
 },
 $wshowIt4_r43P1_entry() //  [R2, R3, R4]
         { info_tbl: [(c44g6,
                       label: $wshowIt4_r43P1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44g6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44g7; else goto u44gj;
       c44g7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wshowIt4_r43P1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u44gj: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c44fP() args: 0, res: 0, upd: 0;
     }
 },
 _c44fP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44fP: // global
           I64[Sp - 8] = block_c44fS_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44gl; else goto c44fT;
       u44gl: // global
           call _c44fS(R1) args: 0, res: 0, upd: 0;
       c44fT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44fS() //  [R1]
         { info_tbl: [(c44fS,
                       label: block_c44fS_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44fS: // global
           I64[Sp] = block_c44fX_info;
           R2 = I64[R1 + 7];
           call GHC.Show.$wintToDigit_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44fX() //  [R1]
         { info_tbl: [(c44fX,
                       label: block_c44fX_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44fX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c44gc; else goto c44gb;
       c44gc: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c44gb: // global
           _s43Tw::P64 = P64[Sp + 24];
           _s43TA::I64 = I64[Sp + 8];
           if (_s43TA::I64 == 0) goto c44gi; else goto c44ge;
       c44gi: // global
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43Tw::P64;
           _c44gh::P64 = Hp - 30;
           Hp = Hp - 16;
           R1 = _c44gh::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c44ge: // global
           (_s43TC::I64, _s43TD::I64) = call MO_S_QuotRem W64(_s43TA::I64, 16);
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43Tw::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43TD::I64;
           I64[Sp + 8] = _s43TC::I64;
           P64[Sp + 16] = Hp - 7;
           P64[Sp + 24] = Hp - 30;
           Sp = Sp + 8;
           call _c44fP() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.103275772 UTC

[section ""data" . Numeric.showHFloat_hex_closure" {
     Numeric.showHFloat_hex_closure:
         const Numeric.showHFloat_hex_info;
         const 0;
 },
 sat_s43UO_entry() //  [R1]
         { info_tbl: [(c44hz,
                       label: sat_s43UO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44hz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44hA; else goto c44hB;
       c44hA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44hB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Numeric.showHFloat_hex_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showHFloat_hex_entry() //  [R2]
         { info_tbl: [(c44hG,
                       label: Numeric.showHFloat_hex_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44hG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c44hH; else goto c44hI;
       c44hH: // global
           R2 = R2;
           R1 = Numeric.showHFloat_hex_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c44hI: // global
           I64[Sp - 8] = block_c44gs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44jT; else goto c44gt;
       u44jT: // global
           call _c44gs(R1) args: 0, res: 0, upd: 0;
       c44gt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44gs() //  [R1]
         { info_tbl: [(c44gs,
                       label: block_c44gs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44gs: // global
           if (R1 & 7 == 1) goto c44hD; else goto c44hE;
       c44hD: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c44hE: // global
           I64[Sp - 8] = block_c44gy_info;
           _s43TK::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _s43TK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44jJ; else goto c44gz;
       u44jJ: // global
           call _c44gy(R1) args: 0, res: 0, upd: 0;
       c44gz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44gy() //  [R1]
         { info_tbl: [(c44gy,
                       label: block_c44gy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44gy: // global
           if (R1 & 7 == 1) goto c44hQ; else goto c44i9;
       c44hQ: // global
           _s43TK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c44hN_info;
           R1 = _s43TK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u44jK; else goto c44hR;
       u44jK: // global
           call _c44hN(R1) args: 0, res: 0, upd: 0;
       c44hR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c44i9: // global
           I64[Sp - 8] = block_c44gE_info;
           _s43TV::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _s43TV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44jL; else goto c44gF;
       u44jL: // global
           call _c44gE(R1) args: 0, res: 0, upd: 0;
       c44gF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44hN() //  [R1]
         { info_tbl: [(c44hN,
                       label: block_c44hN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44hN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c44hX; else goto c44hW;
       c44hX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44hW: // global
           _s43TP::I64 = I64[R1 + 7] << 3;
           if (%MO_S_Ge_W64(_s43TP::I64, 0)) goto c44i6; else goto c44i7;
       c44i6: // global
           (_s43TS::I64, _s43TT::I64) = call MO_S_QuotRem W64(_s43TP::I64, 16);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43TT::I64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 7;
           R2 = _s43TS::I64;
           Sp = Sp + 8;
           call $wshowIt4_r43P1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c44i7: // global
           Hp = Hp - 16;
           R2 = _s43TP::I64;
           Sp = Sp + 8;
           call Numeric.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c44gE() //  [R1]
         { info_tbl: [(c44gE,
                       label: block_c44gE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44gE: // global
           if (R1 & 7 == 1) goto c44ij; else goto c44iJ;
       c44ij: // global
           I64[Sp] = block_c44ib_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u44jM; else goto c44ic;
       u44jM: // global
           call _c44ib(R1) args: 0, res: 0, upd: 0;
       c44ic: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c44iJ: // global
           I64[Sp - 8] = block_c44gK_info;
           _s43Ua::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _s43Ua::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44jN; else goto c44gL;
       u44jN: // global
           call _c44gK(R1) args: 0, res: 0, upd: 0;
       c44gL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44ib() //  [R1]
         { info_tbl: [(c44ib,
                       label: block_c44ib_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44ib: // global
           _s43TV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c44ig_info;
           _s43TZ::I64 = I64[R1 + 7];
           R1 = _s43TV::P64;
           I64[Sp + 16] = _s43TZ::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u44jU; else goto c44il;
       u44jU: // global
           call _c44ig(R1) args: 0, res: 0, upd: 0;
       c44il: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44ig() //  [R1]
         { info_tbl: [(c44ig,
                       label: block_c44ig_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44ig: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c44ir; else goto c44iq;
       c44ir: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44iq: // global
           _s43U2::I64 = (I64[Sp + 8] << 3) + (I64[R1 + 7] << 2);
           if (%MO_S_Ge_W64(_s43U2::I64, 0)) goto c44iG; else goto c44iH;
       c44iG: // global
           (_s43U7::I64, _s43U8::I64) = call MO_S_QuotRem W64(_s43U2::I64, 16);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43U8::I64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 7;
           R2 = _s43U7::I64;
           Sp = Sp + 16;
           call $wshowIt3_r43P0_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c44iH: // global
           Hp = Hp - 16;
           R2 = _s43U2::I64;
           Sp = Sp + 16;
           call Numeric.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c44gK() //  [R1]
         { info_tbl: [(c44gK,
                       label: block_c44gK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44gK: // global
           _s43TK::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c44iY; else goto c44jv;
       c44iY: // global
           I64[Sp] = block_c44iL_info;
           R1 = _s43TK::P64;
           if (R1 & 7 != 0) goto u44jO; else goto c44iM;
       u44jO: // global
           call _c44iL(R1) args: 0, res: 0, upd: 0;
       c44iM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c44jv: // global
           I64[Sp - 8] = block_c44gQ_info;
           _s43Ut::P64 = P64[R1 + 6];
           _s43Uu::P64 = P64[R1 + 14];
           R1 = _s43TK::P64;
           P64[Sp] = _s43Uu::P64;
           P64[Sp + 24] = _s43Ut::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44jP; else goto c44gR;
       u44jP: // global
           call _c44gQ(R1) args: 0, res: 0, upd: 0;
       c44gR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44iL() //  [R1]
         { info_tbl: [(c44iL,
                       label: block_c44iL_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44iL: // global
           I64[Sp] = block_c44iQ_info;
           _s43Ue::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 24] = _s43Ue::I64;
           if (R1 & 7 != 0) goto u44jV; else goto c44iR;
       u44jV: // global
           call _c44iQ(R1) args: 0, res: 0, upd: 0;
       c44iR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44iQ() //  [R1]
         { info_tbl: [(c44iQ,
                       label: block_c44iQ_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44iQ: // global
           _s43Ua::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c44iV_info;
           _s43Ug::I64 = I64[R1 + 7];
           R1 = _s43Ua::P64;
           I64[Sp + 16] = _s43Ug::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u44jW; else goto c44j1;
       u44jW: // global
           call _c44iV(R1) args: 0, res: 0, upd: 0;
       c44j1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44iV() //  [R1]
         { info_tbl: [(c44iV,
                       label: block_c44iV_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44iV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c44j7; else goto c44j6;
       c44j7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44j6: // global
           _s43Uj::I64 = (I64[Sp + 16] << 3) + ((I64[Sp + 8] << 2) + (I64[R1 + 7] << 1));
           if (%MO_S_Ge_W64(_s43Uj::I64, 0)) goto c44js; else goto c44jt;
       c44js: // global
           (_s43Uq::I64, _s43Ur::I64) = call MO_S_QuotRem W64(_s43Uj::I64, 16);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43Ur::I64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 7;
           R2 = _s43Uq::I64;
           Sp = Sp + 24;
           call $wshowIt2_r43OZ_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c44jt: // global
           Hp = Hp - 16;
           R2 = _s43Uj::I64;
           Sp = Sp + 24;
           call Numeric.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c44gQ() //  [R1]
         { info_tbl: [(c44gQ,
                       label: block_c44gQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44gQ: // global
           I64[Sp] = block_c44gV_info;
           _s43Uw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s43Uw::I64;
           if (R1 & 7 != 0) goto u44jQ; else goto c44gW;
       u44jQ: // global
           call _c44gV(R1) args: 0, res: 0, upd: 0;
       c44gW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44gV() //  [R1]
         { info_tbl: [(c44gV,
                       label: block_c44gV_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44gV: // global
           I64[Sp] = block_c44h0_info;
           _s43Uy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s43Uy::I64;
           if (R1 & 7 != 0) goto u44jR; else goto c44h1;
       u44jR: // global
           call _c44h0(R1) args: 0, res: 0, upd: 0;
       c44h1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44h0() //  [R1]
         { info_tbl: [(c44h0,
                       label: block_c44h0_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44h0: // global
           I64[Sp] = block_c44h5_info;
           _s43UA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _s43UA::I64;
           if (R1 & 7 != 0) goto u44jS; else goto c44h6;
       u44jS: // global
           call _c44h5(R1) args: 0, res: 0, upd: 0;
       c44h6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44h5() //  [R1]
         { info_tbl: [(c44h5,
                       label: block_c44h5_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44h5: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c44jB; else goto c44jA;
       c44jB: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44jA: // global
           _s43UD::I64 = (I64[Sp + 24] << 3) + ((I64[Sp + 16] << 2) + ((I64[Sp + 32] << 1) + I64[R1 + 7]));
           if (%MO_S_Ge_W64(_s43UD::I64, 0)) goto c44jE; else goto c44jF;
       c44jE: // global
           _s43Uu::P64 = P64[Sp + 8];
           (_s43UL::I64, _s43UM::I64) = call MO_S_QuotRem W64(_s43UD::I64, 16);
           I64[Hp - 32] = sat_s43UO_info;
           P64[Hp - 16] = _s43Uu::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43UM::I64;
           R4 = Hp - 32;
           R3 = Hp - 7;
           R2 = _s43UL::I64;
           Sp = Sp + 40;
           call $wshowIt1_r43OY_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c44jF: // global
           Hp = Hp - 40;
           R2 = _s43UD::I64;
           Sp = Sp + 40;
           call Numeric.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.10923098 UTC

[section ""data" . sat_s43UP_closure" {
     sat_s43UP_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.110201204 UTC

[section ""data" . sat_s43UQ_closure" {
     sat_s43UQ_closure:
         const :_con_info;
         const sat_s43UP_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.111498628 UTC

[section ""data" . Numeric.showHFloat15_closure" {
     Numeric.showHFloat15_closure:
         const Numeric.showHFloat15_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat15_entry() //  [R1]
         { info_tbl: [(c44k3,
                       label: Numeric.showHFloat15_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44k3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44k4; else goto c44k5;
       c44k4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44k5: // global
           (_c44k0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44k0::I64 == 0) goto c44k2; else goto c44k1;
       c44k2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44k1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44k0::I64;
           R3 = sat_s43UQ_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.11307427 UTC

[section ""cstring" . Numeric.showHFloat10_bytes" {
     Numeric.showHFloat10_bytes:
         I8[] [48,120,48,112,43,48]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.114325815 UTC

[section ""data" . Numeric.showHFloat9_closure" {
     Numeric.showHFloat9_closure:
         const Numeric.showHFloat9_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat9_entry() //  [R1]
         { info_tbl: [(c44kc,
                       label: Numeric.showHFloat9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44kc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44kd; else goto c44ke;
       c44kd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44ke: // global
           (_c44k9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44k9::I64 == 0) goto c44kb; else goto c44ka;
       c44kb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44ka: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44k9::I64;
           R2 = Numeric.showHFloat10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.117313769 UTC

[section ""data" . Numeric.showHFloat14_closure" {
     Numeric.showHFloat14_closure:
         const Numeric.showHFloat14_info;
         const 0;
 },
 Numeric.showHFloat14_entry() //  [R2]
         { info_tbl: [(c44kj,
                       label: Numeric.showHFloat14_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44kj: // global
           R3 = R2;
           R2 = GHC.Types.[]_closure+1;
           call $wlvl2_r43OX_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.118452974 UTC

[section ""cstring" . Numeric.showHFloat13_bytes" {
     Numeric.showHFloat13_bytes:
         I8[] [48,120]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.119305922 UTC

[section ""cstring" . Numeric.showHFloat12_bytes" {
     Numeric.showHFloat12_bytes:
         I8[] [112]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.120063581 UTC

[section ""cstring" . Numeric.showHFloat11_bytes" {
     Numeric.showHFloat11_bytes:
         I8[] [46]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.125371489 UTC

[section ""data" . Numeric.showHFloat_cvt_closure" {
     Numeric.showHFloat_cvt_closure:
         const Numeric.showHFloat_cvt_info;
         const 0;
 },
 sat_s43UZ_entry() //  [R1]
         { info_tbl: [(c44kE,
                       label: sat_s43UZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44kE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44kF; else goto c44kG;
       c44kF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44kG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c44kC_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44kC() //  [R1]
         { info_tbl: [(c44kC,
                       label: block_c44kC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44kC: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showHFloat16_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43Vm_entry() //  [R1]
         { info_tbl: [(c44lu,
                       label: sat_s43Vm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44lu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c44lD; else goto c44lE;
       c44lD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44lE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c44lr_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u44lJ; else goto c44ls;
       u44lJ: // global
           call _c44lr(R1) args: 0, res: 0, upd: 0;
       c44ls: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c44lr() //  [R1]
         { info_tbl: [(c44lr,
                       label: block_c44lr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44lr: // global
           I64[Sp] = block_c44lA_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7] - 1;
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44lA() //  [R1, R2]
         { info_tbl: [(c44lA,
                       label: block_c44lA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44lA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44lI; else goto c44lH;
       c44lI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c44lH: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 n_s43Vf_entry() //  [R1]
         { info_tbl: [(c44lK,
                       label: n_s43Vf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44lK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44lO; else goto c44lN;
       c44lO: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44lN: // global
           _s43V3::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s43Vm_info;
           P64[Hp] = _s43V3::P64;
           R3 = Hp - 16;
           R2 = Numeric.showHFloat12_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43Vp_entry() //  [R1]
         { info_tbl: [(c44lZ,
                       label: sat_s43Vp_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44lZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44m0; else goto c44m1;
       c44m0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44m1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c44lX_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Numeric.showHFloat_hex_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44lX() //  [R1]
         { info_tbl: [(c44lX,
                       label: block_c44lX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44lX: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43Vq_entry() //  [R1]
         { info_tbl: [(c44m9,
                       label: sat_s43Vq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44m9: // global
           _s43Vq::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c44ma; else goto c44mb;
       c44mb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44md; else goto c44mc;
       c44md: // global
           HpAlloc = 24;
           goto c44ma;
       c44ma: // global
           R1 = _s43Vq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44mc: // global
           _s43V3::P64 = P64[_s43Vq::P64 + 16];
           _s43V8::P64 = P64[_s43Vq::P64 + 24];
           I64[Hp - 16] = n_s43Vf_info;
           P64[Hp] = _s43V3::P64;
           I64[Sp - 24] = block_c44lP_info;
           R2 = _s43V8::P64;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _s43V8::P64;
           Sp = Sp - 24;
           call Numeric.showHFloat_allZ_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44lP() //  [R1]
         { info_tbl: [(c44lP,
                       label: block_c44lP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44lP: // global
           _c44lj::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c44m6; else goto c44m7;
       c44m6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44mg; else goto c44mf;
       c44mg: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44mf: // global
           I64[Hp - 24] = sat_s43Vp_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _c44lj::P64;
           R3 = Hp - 24;
           R2 = Numeric.showHFloat11_bytes;
           Sp = Sp + 24;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c44m7: // global
           R1 = _c44lj::P64;
           Sp = Sp + 24;
           call n_s43Vf_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43Vr_entry() //  [R1]
         { info_tbl: [(c44mk,
                       label: sat_s43Vr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44mk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c44mm; else goto c44mn;
       c44mm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44mn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c44l8_info;
           _s43V3::P64 = P64[R1 + 16];
           _s43V8::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s43V3::P64;
           P64[Sp - 24] = _s43V8::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u44ms; else goto c44l9;
       u44ms: // global
           call _c44l8(R1) args: 0, res: 0, upd: 0;
       c44l9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c44l8() //  [R1]
         { info_tbl: [(c44l8,
                       label: block_c44l8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44l8: // global
           I64[Sp] = block_c44ld_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44ld() //  [R1, R2]
         { info_tbl: [(c44ld,
                       label: block_c44ld_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44ld: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c44mr; else goto c44mq;
       c44mr: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c44mq: // global
           I64[Hp - 48] = sat_s43Vq_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 48;
           R2 = Hp - 14;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u44n2_srtd" {
     u44n2_srtd:
         const S43WU_srt+144;
         const 33;
         const 8388608001;
 },
 Numeric.showHFloat_cvt_entry() //  [R2, R3]
         { info_tbl: [(c44mt,
                       label: Numeric.showHFloat_cvt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44mt: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c44mu; else goto c44mv;
       c44mu: // global
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showHFloat_cvt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44mv: // global
           I64[Sp - 24] = block_c44kq_info;
           _s43US::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s43US::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Float.$p1RealFloat_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u44n3_srtd" {
     u44n3_srtd:
         const S43WU_srt+144;
         const 33;
         const 7851737089;
 },
 _c44kq() //  [R1]
         { info_tbl: [(c44kq,
                       label: block_c44kq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44kq: // global
           I64[Sp] = block_c44ku_info;
           R2 = R1;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u44n4_srtd" {
     u44n4_srtd:
         const S43WU_srt+144;
         const 33;
         const 7851737089;
 },
 _c44ku() //  [R1]
         { info_tbl: [(c44ku,
                       label: block_c44ku_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44ku: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44mz; else goto c44my;
       c44mz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44my: // global
           I64[Hp - 16] = sat_s43UZ_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c44kK_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44kK() //  [R1]
         { info_tbl: [(c44kK,
                       label: block_c44kK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44kK: // global
           I64[Sp] = block_c44kO_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44kO() //  [R1]
         { info_tbl: [(c44kO,
                       label: block_c44kO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44kO: // global
           _c44ky::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c44kS_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp] = _c44ky::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c44kS() //  [R1]
         { info_tbl: [(c44kS,
                       label: block_c44kS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44kS: // global
           if (R1 & 7 == 1) goto c44mE; else goto c44mX;
       c44mE: // global
           _s43UT::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c44kW_info;
           R4 = _s43UT::P64;
           R3 = Numeric.showHFloat15_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Float.$wfloatToDigits_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
       c44mX: // global
           R1 = Numeric.showHFloat9_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c44kW() //  [R1, R2]
         { info_tbl: [(c44kW,
                       label: block_c44kW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44kW: // global
           I64[Sp - 8] = block_c44kY_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44n0; else goto c44kZ;
       u44n0: // global
           call _c44kY(R1) args: 0, res: 0, upd: 0;
       c44kZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44kY() //  [R1]
         { info_tbl: [(c44kY,
                       label: block_c44kY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44kY: // global
           _s43V3::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c44mK; else goto c44mQ;
       c44mK: // global
           I64[Sp + 8] = block_c44mH_info;
           R1 = _s43V3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u44n1; else goto c44mL;
       u44n1: // global
           call _c44mH(R1) args: 0, res: 0, upd: 0;
       c44mL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c44mQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c44mT; else goto c44mS;
       c44mT: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44mS: // global
           _s43V7::P64 = P64[R1 + 6];
           _s43V8::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_s43Vr_info;
           P64[Hp - 16] = _s43V3::P64;
           P64[Hp - 8] = _s43V7::P64;
           P64[Hp] = _s43V8::P64;
           R3 = Hp - 32;
           R2 = Numeric.showHFloat13_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _c44mH() //  [R1]
         { info_tbl: [(c44mH,
                       label: block_c44mH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44mH: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call Numeric.showHFloat14_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.134662629 UTC

[section ""data" . Numeric.showHFloat8_closure" {
     Numeric.showHFloat8_closure:
         const GHC.Types.C#_con_info;
         const 45;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.135258446 UTC

[section ""cstring" . Numeric.showHFloat5_bytes" {
     Numeric.showHFloat5_bytes:
         I8[] [73,110,102,105,110,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.135777836 UTC

[section ""cstring" . Numeric.showHFloat7_bytes" {
     Numeric.showHFloat7_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.136679807 UTC

[section ""data" . Numeric.showHFloat6_closure" {
     Numeric.showHFloat6_closure:
         const Numeric.showHFloat6_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat6_entry() //  [R1]
         { info_tbl: [(c44nb,
                       label: Numeric.showHFloat6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44nb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44nc; else goto c44nd;
       c44nc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44nd: // global
           (_c44n8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44n8::I64 == 0) goto c44na; else goto c44n9;
       c44na: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44n9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44n8::I64;
           R2 = Numeric.showHFloat7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.138212245 UTC

[section ""cstring" . Numeric.showHFloat2_bytes" {
     Numeric.showHFloat2_bytes:
         I8[] [78,97,78]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.139324229 UTC

[section ""data" . Numeric.showHFloat1_closure" {
     Numeric.showHFloat1_closure:
         const Numeric.showHFloat1_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat1_entry() //  [R1]
         { info_tbl: [(c44nk,
                       label: Numeric.showHFloat1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44nk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44nl; else goto c44nm;
       c44nl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44nm: // global
           (_c44nh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44nh::I64 == 0) goto c44nj; else goto c44ni;
       c44nj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44ni: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44nh::I64;
           R2 = Numeric.showHFloat2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.140403745 UTC

[section ""data" . Numeric.showHFloat4_closure" {
     Numeric.showHFloat4_closure:
         const Numeric.showHFloat4_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat4_entry() //  [R1]
         { info_tbl: [(c44nt,
                       label: Numeric.showHFloat4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44nt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44nu; else goto c44nv;
       c44nu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44nv: // global
           (_c44nq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44nq::I64 == 0) goto c44ns; else goto c44nr;
       c44ns: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44nr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44nq::I64;
           R2 = Numeric.showHFloat5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.14177513 UTC

[section ""data" . Numeric.showHFloat3_closure" {
     Numeric.showHFloat3_closure:
         const Numeric.showHFloat3_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat3_entry() //  [R1]
         { info_tbl: [(c44nC,
                       label: Numeric.showHFloat3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44nC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44nD; else goto c44nE;
       c44nD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44nE: // global
           (_c44nz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44nz::I64 == 0) goto c44nB; else goto c44nA;
       c44nB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44nA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44nz::I64;
           R3 = Numeric.showHFloat4_closure;
           R2 = Numeric.showHFloat6_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.145137892 UTC

[section ""data" . Numeric.showHFloat_closure" {
     Numeric.showHFloat_closure:
         const Numeric.showHFloat_info;
         const 0;
 },
 $dNum_s43Vx_entry() //  [R1]
         { info_tbl: [(c44o3,
                       label: $dNum_s43Vx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44o3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44o4; else goto c44o5;
       c44o4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44o5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43VA_entry() //  [R1]
         { info_tbl: [(c44oe,
                       label: sat_s43VA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44oe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44of; else goto c44og;
       c44of: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44og: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showHFloat16_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43VD_entry() //  [R1]
         { info_tbl: [(c44oC,
                       label: sat_s43VD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44oC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44oD; else goto c44oE;
       c44oD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44oE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43VE_entry() //  [R1]
         { info_tbl: [(c44oF,
                       label: sat_s43VE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44oF: // global
           _s43VE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c44oG; else goto c44oH;
       c44oH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44oJ; else goto c44oI;
       c44oJ: // global
           HpAlloc = 32;
           goto c44oG;
       c44oG: // global
           R1 = _s43VE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44oI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43VE::P64;
           _s43Vs::P64 = P64[_s43VE::P64 + 16];
           _s43Vt::P64 = P64[_s43VE::P64 + 24];
           _s43Vx::P64 = P64[_s43VE::P64 + 32];
           I64[Hp - 24] = sat_s43VD_info;
           P64[Hp - 8] = _s43Vt::P64;
           P64[Hp] = _s43Vx::P64;
           R3 = Hp - 24;
           R2 = _s43Vs::P64;
           Sp = Sp - 16;
           call Numeric.showHFloat_cvt_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43VF_entry() //  [R1]
         { info_tbl: [(c44oU,
                       label: sat_s43VF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44oU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44oV; else goto c44oW;
       c44oV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44oW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43VG_entry() //  [R1]
         { info_tbl: [(c44oX,
                       label: sat_s43VG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44oX: // global
           _s43VG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c44oY; else goto c44oZ;
       c44oZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44p1; else goto c44p0;
       c44p1: // global
           HpAlloc = 32;
           goto c44oY;
       c44oY: // global
           R1 = _s43VG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44p0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43VG::P64;
           _s43Vs::P64 = P64[_s43VG::P64 + 16];
           _s43Vt::P64 = P64[_s43VG::P64 + 24];
           _s43Vx::P64 = P64[_s43VG::P64 + 32];
           I64[Hp - 24] = sat_s43VF_info;
           P64[Hp - 8] = _s43Vt::P64;
           P64[Hp] = _s43Vx::P64;
           R3 = Hp - 24;
           R2 = _s43Vs::P64;
           Sp = Sp - 16;
           call Numeric.showHFloat_cvt_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43VI_entry() //  [R1]
         { info_tbl: [(c44p8,
                       label: sat_s43VI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44p8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44p9; else goto c44pa;
       c44p9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44pa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showHFloat16_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43VK_entry() //  [R1]
         { info_tbl: [(c44pf,
                       label: sat_s43VK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44pf: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c44pg; else goto c44ph;
       c44pg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44ph: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c44nN_info;
           _s43Vs::P64 = P64[R1 + 16];
           R2 = _s43Vs::P64;
           I64[Sp - 56] = stg_ap_p_info;
           _s43Vt::P64 = P64[R1 + 24];
           P64[Sp - 48] = _s43Vt::P64;
           P64[Sp - 32] = _s43Vs::P64;
           P64[Sp - 24] = _s43Vt::P64;
           Sp = Sp - 56;
           call GHC.Float.isNaN_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c44nN() //  [R1]
         { info_tbl: [(c44nN,
                       label: block_c44nN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44nN: // global
           if (R1 & 7 == 1) goto c44pc; else goto c44pd;
       c44pc: // global
           I64[Sp] = block_c44nR_info;
           R2 = P64[Sp + 8];
           call GHC.Float.$p1RealFloat_entry(R2) args: 8, res: 8, upd: 24;
       c44pd: // global
           R1 = Numeric.showHFloat1_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c44nR() //  [R1]
         { info_tbl: [(c44nR,
                       label: block_c44nR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44nR: // global
           I64[Sp] = block_c44nV_info;
           R2 = R1;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44nV() //  [R1]
         { info_tbl: [(c44nV,
                       label: block_c44nV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44nV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44pm; else goto c44pl;
       c44pm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c44pl: // global
           I64[Hp - 16] = $dNum_s43Vx_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c44o6_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Float.isInfinite_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c44o6() //  [R1]
         { info_tbl: [(c44o6,
                       label: block_c44o6_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44o6: // global
           _c44nZ::P64 = P64[Sp + 16];
           _s43Vw::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c44po; else goto c44pL;
       c44po: // global
           Hp = Hp + 24;
           _s43Vy::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c44pO; else goto c44pq;
       c44pq: // global
           I64[Hp - 16] = sat_s43VA_info;
           P64[Hp] = _c44nZ::P64;
           I64[Sp] = block_c44oh_info;
           R2 = _s43Vw::P64;
           P64[Sp + 8] = Hp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 24;
       c44pL: // global
           Hp = Hp + 24;
           _s43Vy::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c44pO; else goto c44pN;
       c44pO: // global
           HpAlloc = 24;
           R1 = _s43Vy::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c44pN: // global
           I64[Hp - 16] = sat_s43VI_info;
           P64[Hp] = _c44nZ::P64;
           I64[Sp + 16] = block_c44pK_info;
           R2 = _s43Vw::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44oh() //  [R1]
         { info_tbl: [(c44oh,
                       label: block_c44oh_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44oh: // global
           _c44oa::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c44ol_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = _c44oa::P64;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c44ol() //  [R1]
         { info_tbl: [(c44ol,
                       label: block_c44ol_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44ol: // global
           _s43Vs::P64 = P64[Sp + 16];
           _s43Vt::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c44pv; else goto c44pG;
       c44pv: // global
           I64[Sp] = block_c44op_info;
           R2 = _s43Vs::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s43Vt::P64;
           Sp = Sp - 16;
           call GHC.Float.isNegativeZero_entry(R2) args: 24, res: 8, upd: 24;
       c44pG: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c44pJ; else goto c44pI;
       c44pJ: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c44pI: // global
           I64[Hp - 56] = sat_s43VG_info;
           P64[Hp - 40] = _s43Vs::P64;
           P64[Hp - 32] = _s43Vt::P64;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Numeric.showHFloat8_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c44op() //  [R1]
         { info_tbl: [(c44op,
                       label: block_c44op_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44op: // global
           _s43Vs::P64 = P64[Sp + 16];
           _s43Vt::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c44pz; else goto c44pB;
       c44pz: // global
           R3 = _s43Vt::P64;
           R2 = _s43Vs::P64;
           Sp = Sp + 32;
           call Numeric.showHFloat_cvt_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
       c44pB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c44pE; else goto c44pD;
       c44pE: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c44pD: // global
           I64[Hp - 56] = sat_s43VE_info;
           P64[Hp - 40] = _s43Vs::P64;
           P64[Hp - 32] = _s43Vt::P64;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Numeric.showHFloat8_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c44pK() //  [R1]
         { info_tbl: [(c44pK,
                       label: block_c44pK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44pK: // global
           _s43Vt::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c44pS_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s43Vt::P64;
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c44pS() //  [R1]
         { info_tbl: [(c44pS,
                       label: block_c44pS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44pS: // global
           if (R1 & 7 == 1) goto c44pZ; else goto c44q3;
       c44pZ: // global
           R1 = Numeric.showHFloat4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c44q3: // global
           R1 = Numeric.showHFloat3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showHFloat_entry() //  [R2, R3]
         { info_tbl: [(c44qb,
                       label: Numeric.showHFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44qb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44qf; else goto c44qe;
       c44qf: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showHFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44qe: // global
           I64[Hp - 24] = sat_s43VK_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.154843937 UTC

[section ""data" . sat_s43VL_closure" {
     sat_s43VL_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.155769538 UTC

[section ""data" . sat_s43VM_closure" {
     sat_s43VM_closure:
         const :_con_info;
         const sat_s43VL_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.157098794 UTC

[section ""data" . Numeric.showOct1_closure" {
     Numeric.showOct1_closure:
         const Numeric.showOct1_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showOct1_entry() //  [R1]
         { info_tbl: [(c44qm,
                       label: Numeric.showOct1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44qm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44qn; else goto c44qo;
       c44qn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44qo: // global
           (_c44qj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44qj::I64 == 0) goto c44ql; else goto c44qk;
       c44ql: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44qk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44qj::I64;
           R3 = sat_s43VM_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.159330363 UTC

[section ""data" . Numeric.showOct_closure" {
     Numeric.showOct_closure:
         const Numeric.showOct_info;
         const 0;
 },
 sat_s43VR_entry() //  [R1]
         { info_tbl: [(c44qz,
                       label: sat_s43VR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44qz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44qD; else goto c44qE;
       c44qD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44qE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c44qx_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44qx() //  [R1]
         { info_tbl: [(c44qx,
                       label: block_c44qx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44qx: // global
           I64[Sp] = block_c44qC_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44qC() //  [R1]
         { info_tbl: [(c44qC,
                       label: block_c44qC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44qC: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showOct1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Numeric.showOct_entry() //  [R2, R3]
         { info_tbl: [(c44qK,
                       label: Numeric.showOct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44qK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44qO; else goto c44qN;
       c44qO: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showOct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44qN: // global
           I64[Hp - 16] = sat_s43VR_info;
           P64[Hp] = R2;
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showIntAtBase_closure+6;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.161687449 UTC

[section ""data" . Numeric.$trModule3_closure" {
     Numeric.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Numeric.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.162599966 UTC

[section ""data" . Numeric.$trModule1_closure" {
     Numeric.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Numeric.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.163420613 UTC

[section ""data" . Numeric.$trModule_closure" {
     Numeric.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Numeric.$trModule3_closure+1;
         const Numeric.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.165100116 UTC

[section ""data" . Numeric.showGFloat_$sshowGFloat_closure" {
     Numeric.showGFloat_$sshowGFloat_closure:
         const Numeric.showGFloat_$sshowGFloat_info;
         const 0;
 },
 sat_s43VW_entry() //  [R1]
         { info_tbl: [(c44r0,
                       label: sat_s43VW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44r0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44r1; else goto c44r2;
       c44r1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44r2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c44qX_info;
           _s43VS::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s43VS::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u44r6; else goto c44qY;
       u44r6: // global
           call _c44qX(R1) args: 0, res: 0, upd: 0;
       c44qY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c44qX() //  [R1]
         { info_tbl: [(c44qX,
                       label: block_c44qX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44qX: // global
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showGFloat_$sshowGFloat_entry() //  [R2, R3]
         { info_tbl: [(c44r7,
                       label: Numeric.showGFloat_$sshowGFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44r7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44rb; else goto c44ra;
       c44rb: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showGFloat_$sshowGFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44ra: // global
           I64[Hp - 24] = sat_s43VW_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.167795818 UTC

[section ""data" . Numeric.showFFloat_$sshowFFloat_closure" {
     Numeric.showFFloat_$sshowFFloat_closure:
         const Numeric.showFFloat_$sshowFFloat_info;
         const 0;
 },
 sat_s43W1_entry() //  [R1]
         { info_tbl: [(c44rn,
                       label: sat_s43W1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44rn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44ro; else goto c44rp;
       c44ro: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44rp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c44rk_info;
           _s43VX::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s43VX::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u44rt; else goto c44rl;
       u44rt: // global
           call _c44rk(R1) args: 0, res: 0, upd: 0;
       c44rl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c44rk() //  [R1]
         { info_tbl: [(c44rk,
                       label: block_c44rk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44rk: // global
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showFFloat_$sshowFFloat_entry() //  [R2, R3]
         { info_tbl: [(c44ru,
                       label: Numeric.showFFloat_$sshowFFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44ru: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44ry; else goto c44rx;
       c44ry: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showFFloat_$sshowFFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44rx: // global
           I64[Hp - 24] = sat_s43W1_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.170110773 UTC

[section ""data" . Numeric.showEFloat_$sshowEFloat_closure" {
     Numeric.showEFloat_$sshowEFloat_closure:
         const Numeric.showEFloat_$sshowEFloat_info;
         const 0;
 },
 sat_s43W6_entry() //  [R1]
         { info_tbl: [(c44rK,
                       label: sat_s43W6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44rK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44rL; else goto c44rM;
       c44rL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44rM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c44rH_info;
           _s43W2::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s43W2::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u44rQ; else goto c44rI;
       u44rQ: // global
           call _c44rH(R1) args: 0, res: 0, upd: 0;
       c44rI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c44rH() //  [R1]
         { info_tbl: [(c44rH,
                       label: block_c44rH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44rH: // global
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFExponent_closure+1;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showEFloat_$sshowEFloat_entry() //  [R2, R3]
         { info_tbl: [(c44rR,
                       label: Numeric.showEFloat_$sshowEFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44rR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44rV; else goto c44rU;
       c44rV: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showEFloat_$sshowEFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44rU: // global
           I64[Hp - 24] = sat_s43W6_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.172139322 UTC

[section ""data" . Numeric.showGFloat_$sshowGFloat1_closure" {
     Numeric.showGFloat_$sshowGFloat1_closure:
         const Numeric.showGFloat_$sshowGFloat1_info;
         const 0;
 },
 sat_s43Wb_entry() //  [R1]
         { info_tbl: [(c44s7,
                       label: sat_s43Wb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44s7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44s8; else goto c44s9;
       c44s8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44s9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c44s4_info;
           _s43W7::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s43W7::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u44sd; else goto c44s5;
       u44sd: // global
           call _c44s4(R1) args: 0, res: 0, upd: 0;
       c44s5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c44s4() //  [R1]
         { info_tbl: [(c44s4,
                       label: block_c44s4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44s4: // global
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showGFloat_$sshowGFloat1_entry() //  [R2, R3]
         { info_tbl: [(c44se,
                       label: Numeric.showGFloat_$sshowGFloat1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44se: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44si; else goto c44sh;
       c44si: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showGFloat_$sshowGFloat1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44sh: // global
           I64[Hp - 24] = sat_s43Wb_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.174938392 UTC

[section ""data" . Numeric.showGFloat_closure" {
     Numeric.showGFloat_closure:
         const Numeric.showGFloat_info;
         const 0;
 },
 sat_s43Wf_entry() //  [R1]
         { info_tbl: [(c44sr,
                       label: sat_s43Wf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44sr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44ss; else goto c44st;
       c44ss: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44st: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.False_closure+1;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFGeneric_closure+3;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showGFloat_entry() //  [R2, R3, R4]
         { info_tbl: [(c44su,
                       label: Numeric.showGFloat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44su: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c44sy; else goto c44sx;
       c44sy: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showGFloat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c44sx: // global
           I64[Hp - 32] = sat_s43Wf_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.180259463 UTC

[section ""data" . Numeric.showFFloat_$sshowFFloat1_closure" {
     Numeric.showFFloat_$sshowFFloat1_closure:
         const Numeric.showFFloat_$sshowFFloat1_info;
         const 0;
 },
 sat_s43Wk_entry() //  [R1]
         { info_tbl: [(c44sK,
                       label: sat_s43Wk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44sK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44sL; else goto c44sM;
       c44sL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44sM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c44sH_info;
           _s43Wg::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s43Wg::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u44sQ; else goto c44sI;
       u44sQ: // global
           call _c44sH(R1) args: 0, res: 0, upd: 0;
       c44sI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c44sH() //  [R1]
         { info_tbl: [(c44sH,
                       label: block_c44sH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44sH: // global
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showFFloat_$sshowFFloat1_entry() //  [R2, R3]
         { info_tbl: [(c44sR,
                       label: Numeric.showFFloat_$sshowFFloat1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44sR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44sV; else goto c44sU;
       c44sV: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showFFloat_$sshowFFloat1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44sU: // global
           I64[Hp - 24] = sat_s43Wk_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.182565971 UTC

[section ""data" . Numeric.showFFloat_closure" {
     Numeric.showFFloat_closure:
         const Numeric.showFFloat_info;
         const 0;
 },
 sat_s43Wo_entry() //  [R1]
         { info_tbl: [(c44t4,
                       label: sat_s43Wo_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44t4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44t5; else goto c44t6;
       c44t5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44t6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.False_closure+1;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFFixed_closure+2;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showFFloat_entry() //  [R2, R3, R4]
         { info_tbl: [(c44t7,
                       label: Numeric.showFFloat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44t7: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c44tb; else goto c44ta;
       c44tb: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showFFloat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c44ta: // global
           I64[Hp - 32] = sat_s43Wo_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.184295301 UTC

[section ""data" . Numeric.showEFloat_$sshowEFloat1_closure" {
     Numeric.showEFloat_$sshowEFloat1_closure:
         const Numeric.showEFloat_$sshowEFloat1_info;
         const 0;
 },
 sat_s43Wt_entry() //  [R1]
         { info_tbl: [(c44tn,
                       label: sat_s43Wt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44tn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44to; else goto c44tp;
       c44to: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44tp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c44tk_info;
           _s43Wp::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s43Wp::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u44tt; else goto c44tl;
       u44tt: // global
           call _c44tk(R1) args: 0, res: 0, upd: 0;
       c44tl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c44tk() //  [R1]
         { info_tbl: [(c44tk,
                       label: block_c44tk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44tk: // global
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFExponent_closure+1;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showEFloat_$sshowEFloat1_entry() //  [R2, R3]
         { info_tbl: [(c44tu,
                       label: Numeric.showEFloat_$sshowEFloat1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44tu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44ty; else goto c44tx;
       c44ty: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showEFloat_$sshowEFloat1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44tx: // global
           I64[Hp - 24] = sat_s43Wt_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.186203813 UTC

[section ""data" . Numeric.showEFloat_closure" {
     Numeric.showEFloat_closure:
         const Numeric.showEFloat_info;
         const 0;
 },
 sat_s43Wx_entry() //  [R1]
         { info_tbl: [(c44tH,
                       label: sat_s43Wx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44tH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44tI; else goto c44tJ;
       c44tI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44tJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.False_closure+1;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFExponent_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showEFloat_entry() //  [R2, R3, R4]
         { info_tbl: [(c44tK,
                       label: Numeric.showEFloat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44tK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c44tO; else goto c44tN;
       c44tO: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showEFloat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c44tN: // global
           I64[Hp - 32] = sat_s43Wx_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.187462754 UTC

[section ""relreadonly" . S43WU_srt" {
     S43WU_srt:
         const Text.Read.Lex.$wreadIntP_closure;
         const Numeric.readInt_closure;
         const Text.Read.Lex.readDecP4_closure;
         const Text.Read.Lex.$wreadIntP'_closure;
         const Numeric.readOct_closure;
         const Text.Read.Lex.numberToFixed1_closure;
         const Numeric.readDec_closure;
         const Text.Read.Lex.readDecP3_closure;
         const Numeric.readHex_closure;
         const Text.Read.Lex.$wnumberToRational_closure;
         const Text.Read.Lex.expect2_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const Numeric.readFloat_closure;
         const GHC.Read.lex1_closure;
         const GHC.Read.readParen_closure;
         const Numeric.readSigned_closure;
         const sat_s43QP_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Numeric.showHFloat16_closure;
         const Numeric.showInt2_closure;
         const Numeric.showInt_closure;
         const Numeric.showInt1_closure;
         const GHC.Float.formatRealFloatAlt_closure;
         const Numeric.showFFloatAlt_closure;
         const Numeric.showGFloatAlt_closure;
         const Numeric.$wlvl_closure;
         const Numeric.showIntAtBase2_closure;
         const Numeric.showIntAtBase1_closure;
         const sat_s43RQ_closure;
         const Numeric.showIntAtBase3_closure;
         const Numeric.showIntAtBase_closure;
         const sat_s43So_closure;
         const Numeric.showHex1_closure;
         const GHC.Show.intToDigit_closure;
         const Numeric.showHex_closure;
         const GHC.Show.$fShow(,)_go1_closure;
         const GHC.Err.error_closure;
         const $dIP3_r43OU_closure;
         const $wlvl2_r43OX_closure;
         const GHC.Show.$wintToDigit_closure;
         const $wshowIt1_r43OY_closure;
         const $wshowIt2_r43OZ_closure;
         const $wshowIt3_r43P0_closure;
         const $wshowIt4_r43P1_closure;
         const Numeric.showHFloat_hex_closure;
         const sat_s43UQ_closure;
         const GHC.Float.$wfloatToDigits_closure;
         const Numeric.showHFloat_cvt_closure;
         const Numeric.showHFloat9_closure;
         const Numeric.showHFloat14_closure;
         const Numeric.showHFloat15_closure;
         const Numeric.showHFloat4_closure;
         const Numeric.showHFloat6_closure;
         const Numeric.showHFloat16_closure;
         const Numeric.showHFloat1_closure;
         const Numeric.showHFloat3_closure;
         const Numeric.showHFloat_closure;
         const sat_s43VM_closure;
         const Numeric.showOct1_closure;
         const Numeric.showOct_closure;
         const GHC.Float.$w$sformatRealFloatAlt1_closure;
         const Numeric.showGFloat_$sshowGFloat_closure;
         const Numeric.showFFloat_$sshowFFloat_closure;
         const Numeric.showEFloat_$sshowEFloat_closure;
         const GHC.Float.$w$sformatRealFloatAlt_closure;
         const Numeric.showGFloat_$sshowGFloat1_closure;
         const GHC.Float.formatRealFloatAlt_closure;
         const Numeric.showGFloat_closure;
         const Numeric.showFFloat_$sshowFFloat1_closure;
         const Numeric.showFFloat_closure;
         const Numeric.showEFloat_$sshowEFloat1_closure;
         const Numeric.showEFloat_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.188454565 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:58:56.189682578 UTC

[section ""data" . Numeric.readInt_closure" {
     Numeric.readInt_closure:
         const Numeric.readInt_info;
         const 0;
 },
 sat_s43P9_entry() //  [R1]
         { info_tbl: [(c44u0,
                       label: sat_s43P9_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44u0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c44u1; else goto c44u2;
       c44u1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44u2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c44tX_info;
           R6 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Text.Read.Lex.$wreadIntP_entry(R6,
                                               R5,
                                               R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44tX() //  [R1]
         { info_tbl: [(c44tX,
                       label: block_c44tX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44tX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c44u5; else goto c44u4;
       c44u5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c44u4: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.readInt_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c44u6,
                       label: Numeric.readInt_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44u6: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c44ua; else goto c44u9;
       c44ua: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readInt_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c44u9: // global
           I64[Hp - 40] = sat_s43P9_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 40;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.192037964 UTC

[section ""data" . Numeric.readOct_closure" {
     Numeric.readOct_closure:
         const Numeric.readOct_info;
         const 0;
 },
 sat_s43Pc_entry() //  [R1]
         { info_tbl: [(c44un,
                       label: sat_s43Pc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44un: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44uo; else goto c44up;
       c44uo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44up: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.Read.Lex.readDecP4_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43Pf_entry() //  [R1]
         { info_tbl: [(c44ut,
                       label: sat_s43Pf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44ut: // global
           _s43Pf::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c44uu; else goto c44uv;
       c44uv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44ux; else goto c44uw;
       c44ux: // global
           HpAlloc = 24;
           goto c44uu;
       c44uu: // global
           R1 = _s43Pf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44uw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43Pf::P64;
           _s43Pa::P64 = P64[_s43Pf::P64 + 16];
           _s43Pb::P64 = P64[_s43Pf::P64 + 24];
           I64[Hp - 16] = sat_s43Pc_info;
           P64[Hp] = _s43Pb::P64;
           I64[Sp - 24] = block_c44uq_info;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = Hp - 16;
           R3 = _s43Pb::P64;
           R2 = _s43Pa::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wreadIntP'_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44uq() //  [R1]
         { info_tbl: [(c44uq,
                       label: block_c44uq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44uq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c44uA; else goto c44uz;
       c44uA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c44uz: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.readOct_entry() //  [R2, R3]
         { info_tbl: [(c44uB,
                       label: Numeric.readOct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44uB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44uF; else goto c44uE;
       c44uF: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readOct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44uE: // global
           I64[Hp - 24] = sat_s43Pf_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.194599994 UTC

[section ""data" . Numeric.readDec_closure" {
     Numeric.readDec_closure:
         const Numeric.readDec_info;
         const 0;
 },
 sat_s43Pi_entry() //  [R1]
         { info_tbl: [(c44uS,
                       label: sat_s43Pi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44uS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44uT; else goto c44uU;
       c44uT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44uU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.Read.Lex.numberToFixed1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43Pl_entry() //  [R1]
         { info_tbl: [(c44uY,
                       label: sat_s43Pl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44uY: // global
           _s43Pl::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c44uZ; else goto c44v0;
       c44v0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44v2; else goto c44v1;
       c44v2: // global
           HpAlloc = 24;
           goto c44uZ;
       c44uZ: // global
           R1 = _s43Pl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44v1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43Pl::P64;
           _s43Pg::P64 = P64[_s43Pl::P64 + 16];
           _s43Ph::P64 = P64[_s43Pl::P64 + 24];
           I64[Hp - 16] = sat_s43Pi_info;
           P64[Hp] = _s43Ph::P64;
           I64[Sp - 24] = block_c44uV_info;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = Hp - 16;
           R3 = _s43Ph::P64;
           R2 = _s43Pg::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wreadIntP'_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44uV() //  [R1]
         { info_tbl: [(c44uV,
                       label: block_c44uV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44uV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c44v5; else goto c44v4;
       c44v5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c44v4: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.readDec_entry() //  [R2, R3]
         { info_tbl: [(c44v6,
                       label: Numeric.readDec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44v6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44va; else goto c44v9;
       c44va: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readDec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44v9: // global
           I64[Hp - 24] = sat_s43Pl_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.197088761 UTC

[section ""data" . Numeric.readHex_closure" {
     Numeric.readHex_closure:
         const Numeric.readHex_info;
         const 0;
 },
 sat_s43Po_entry() //  [R1]
         { info_tbl: [(c44vn,
                       label: sat_s43Po_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44vn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44vo; else goto c44vp;
       c44vo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44vp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.Read.Lex.readDecP3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43Pr_entry() //  [R1]
         { info_tbl: [(c44vt,
                       label: sat_s43Pr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44vt: // global
           _s43Pr::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c44vu; else goto c44vv;
       c44vv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44vx; else goto c44vw;
       c44vx: // global
           HpAlloc = 24;
           goto c44vu;
       c44vu: // global
           R1 = _s43Pr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44vw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43Pr::P64;
           _s43Pm::P64 = P64[_s43Pr::P64 + 16];
           _s43Pn::P64 = P64[_s43Pr::P64 + 24];
           I64[Hp - 16] = sat_s43Po_info;
           P64[Hp] = _s43Pn::P64;
           I64[Sp - 24] = block_c44vq_info;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = Hp - 16;
           R3 = _s43Pn::P64;
           R2 = _s43Pm::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wreadIntP'_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44vq() //  [R1]
         { info_tbl: [(c44vq,
                       label: block_c44vq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44vq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c44vA; else goto c44vz;
       c44vA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c44vz: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.readHex_entry() //  [R2, R3]
         { info_tbl: [(c44vB,
                       label: Numeric.readHex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44vB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44vF; else goto c44vE;
       c44vF: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readHex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44vE: // global
           I64[Hp - 24] = sat_s43Pr_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.199218418 UTC

[section ""data" . Numeric.readFloat2_closure" {
     Numeric.readFloat2_closure:
         const Numeric.readFloat2_info;
 },
 Numeric.readFloat2_entry() //  [R2]
         { info_tbl: [(c44vN,
                       label: Numeric.readFloat2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44vN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c44vO; else goto c44vP;
       c44vO: // global
           R2 = R2;
           R1 = Numeric.readFloat2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c44vP: // global
           I64[Sp - 8] = block_c44vK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44vT; else goto c44vL;
       u44vT: // global
           call _c44vK() args: 0, res: 0, upd: 0;
       c44vL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44vK() //  []
         { info_tbl: [(c44vK,
                       label: block_c44vK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44vK: // global
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.200203026 UTC

[section ""data" . Numeric.readFloat1_closure" {
     Numeric.readFloat1_closure:
         const Text.ParserCombinators.ReadP.Look_con_info;
         const Numeric.readFloat2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.202590066 UTC

[section ""data" . Numeric.readFloat_closure" {
     Numeric.readFloat_closure:
         const Numeric.readFloat_info;
         const 0;
 },
 $dFractional_s43Pw_entry() //  [R1]
         { info_tbl: [(c44wa,
                       label: $dFractional_s43Pw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44wa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44wb; else goto c44wc;
       c44wb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44wc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43PD_entry() //  [R1]
         { info_tbl: [(c44wz,
                       label: sat_s43PD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44wz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c44wA; else goto c44wB;
       c44wA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44wB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c44ww_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Text.Read.Lex.$wnumberToRational_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44ww() //  [R1, R2]
         { info_tbl: [(c44ww,
                       label: block_c44ww_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44ww: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44wE; else goto c44wD;
       c44wE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c44wD: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43PE_entry() //  [R1]
         { info_tbl: [(c44wF,
                       label: sat_s43PE_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44wF: // global
           _s43PE::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c44wG; else goto c44wH;
       c44wH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44wJ; else goto c44wI;
       c44wJ: // global
           HpAlloc = 24;
           goto c44wG;
       c44wG: // global
           R1 = _s43PE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44wI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43PE::P64;
           _s43Pw::P64 = P64[_s43PE::P64 + 16];
           _s43Pz::P64 = P64[_s43PE::P64 + 24];
           I64[Hp - 16] = sat_s43PD_info;
           P64[Hp] = _s43Pz::P64;
           R2 = _s43Pw::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Real.fromRational_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43PF_entry() //  [R1, R2]
         { info_tbl: [(c44wO,
                       label: sat_s43PF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44wO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44wP; else goto c44wQ;
       c44wP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c44wQ: // global
           I64[Sp - 16] = block_c44wi_info;
           _s43Pw::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s43Pw::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u44wX; else goto c44wj;
       u44wX: // global
           call _c44wi(R1) args: 0, res: 0, upd: 0;
       c44wj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44wi() //  [R1]
         { info_tbl: [(c44wi,
                       label: block_c44wi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44wi: // global
           if (R1 & 7 == 6) goto c44wM; else goto c44wL;
       c44wM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c44wW; else goto c44wV;
       c44wW: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44wV: // global
           _s43Pz::P64 = P64[R1 + 2];
           I64[Hp - 48] = sat_s43PE_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s43Pz::P64;
           I64[Hp - 16] = Text.ParserCombinators.ReadP.Result_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Text.ParserCombinators.ReadP.Fail_closure+3;
           R1 = Hp - 12;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c44wL: // global
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43PG_entry() //  [R1]
         { info_tbl: [(c44wY,
                       label: sat_s43PG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44wY: // global
           _s43PG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c44wZ; else goto c44x0;
       c44x0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c44x2; else goto c44x1;
       c44x2: // global
           HpAlloc = 40;
           goto c44wZ;
       c44wZ: // global
           R1 = _s43PG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44x1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43PG::P64;
           _s43Pu::P64 = P64[_s43PG::P64 + 16];
           I64[Hp - 32] = $dFractional_s43Pw_info;
           P64[Hp - 16] = _s43Pu::P64;
           I64[Hp - 8] = sat_s43PF_info;
           P64[Hp] = Hp - 32;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Text.Read.Lex.expect2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl116_s43Pv_entry() //  [R1]
         { info_tbl: [(c44x3,
                       label: lvl116_s43Pv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44x3: // global
           _s43Pv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c44x4; else goto c44x5;
       c44x5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44x7; else goto c44x6;
       c44x7: // global
           HpAlloc = 24;
           goto c44x4;
       c44x4: // global
           R1 = _s43Pv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44x6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43Pv::P64;
           _s43Pu::P64 = P64[_s43Pv::P64 + 16];
           I64[Hp - 16] = sat_s43PG_info;
           P64[Hp] = _s43Pu::P64;
           R3 = Hp - 16;
           R2 = Numeric.readFloat1_closure+2;
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 k_s43PH_entry() //  [R1]
         { info_tbl: [(c44xd,
                       label: k_s43PH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44xd: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43PK_entry() //  [R1, R2]
         { info_tbl: [(c44xl,
                       label: sat_s43PK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44xl: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           call Text.ParserCombinators.ReadP.skipSpaces2_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 Numeric.readFloat_entry() //  [R2]
         { info_tbl: [(c44xp,
                       label: Numeric.readFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44xp: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c44xt; else goto c44xs;
       c44xt: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Numeric.readFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c44xs: // global
           I64[Hp - 64] = lvl116_s43Pv_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = k_s43PH_info;
           P64[Hp - 32] = Hp - 64;
           I64[Hp - 24] = sat_s43PK_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.210572625 UTC

[section ""data" . Numeric.readSigned_closure" {
     Numeric.readSigned_closure:
         const Numeric.readSigned_info;
         const 0;
 },
 $dNum_s43PP_entry() //  [R1]
         { info_tbl: [(c44xC,
                       label: $dNum_s43PP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44xC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44xD; else goto c44xE;
       c44xD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44xE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go1_s43PZ_entry() //  [R1, R2]
         { info_tbl: [(c44y8,
                       label: go1_s43PZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44y8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c44y9; else goto u44yF;
       c44y9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u44yF: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _c44xY() args: 0, res: 0, upd: 0;
     }
 },
 _c44xY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44xY: // global
           I64[Sp - 16] = block_c44y1_info;
           R1 = P64[Sp + 8];
           _s43PZ::P64 = P64[Sp];
           P64[Sp - 8] = P64[_s43PZ::P64 + 15];
           P64[Sp + 8] = P64[_s43PZ::P64 + 7];
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u44yH; else goto c44y2;
       u44yH: // global
           call _c44y1(R1) args: 0, res: 0, upd: 0;
       c44y2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44y1() //  [R1]
         { info_tbl: [(c44y1,
                       label: block_c44y1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44y1: // global
           if (R1 & 7 == 1) goto c44y5; else goto c44y6;
       c44y5: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c44y6: // global
           I64[Sp] = block_c44yg_info;
           _s43Q3::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 8] = _s43Q3::P64;
           if (R1 & 7 != 0) goto u44yI; else goto c44yi;
       u44yI: // global
           call _c44yg(R1) args: 0, res: 0, upd: 0;
       c44yi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44yg() //  [R1]
         { info_tbl: [(c44yg,
                       label: block_c44yg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44yg: // global
           I64[Sp - 8] = block_c44ym_info;
           _s43Q5::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s43Q5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44yK; else goto c44yo;
       u44yK: // global
           call _c44ym(R1) args: 0, res: 0, upd: 0;
       c44yo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44ym() //  [R1]
         { info_tbl: [(c44ym,
                       label: block_c44ym_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44ym: // global
           _s43Q3::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c44yw; else goto c44yD;
       c44yw: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c44yz; else goto c44yy;
       c44yz: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44yy: // global
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _s43Q3::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 32];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c44yD: // global
           P64[Sp + 32] = _s43Q3::P64;
           Sp = Sp + 24;
           call _c44xY() args: 0, res: 0, upd: 0;
     }
 },
 go_s43PQ_entry() //  [R1, R2]
         { info_tbl: [(c44yQ,
                       label: go_s43PQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44yQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44yR; else goto c44yS;
       c44yR: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c44yS: // global
           I64[Sp - 24] = block_c44xK_info;
           _s43PQ::P64 = R1;
           _s43PN::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s43PN::P64;
           P64[Sp - 8] = _s43PQ::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u44z5; else goto c44xL;
       u44z5: // global
           call _c44xK(R1) args: 0, res: 0, upd: 0;
       c44xL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44xK() //  [R1]
         { info_tbl: [(c44xK,
                       label: block_c44xK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44xK: // global
           if (R1 & 7 == 1) goto c44yN; else goto c44yO;
       c44yN: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c44yO: // global
           I64[Sp - 8] = block_c44xQ_info;
           _s43PU::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s43PU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44z4; else goto c44xR;
       u44z4: // global
           call _c44xQ(R1) args: 0, res: 0, upd: 0;
       c44xR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44xQ() //  [R1]
         { info_tbl: [(c44xQ,
                       label: block_c44xQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44xQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c44yZ; else goto c44yY;
       c44yZ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44yY: // global
           _s43PW::P64 = P64[R1 + 7];
           _s43PX::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = go1_s43PZ_info;
           P64[Hp - 8] = _s43PX::P64;
           P64[Hp] = Hp - 48;
           _s43PN::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c44yV_info;
           R2 = _s43PW::P64;
           R1 = _s43PN::P64;
           P64[Sp + 24] = Hp - 15;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44yV() //  [R1]
         { info_tbl: [(c44yV,
                       label: block_c44yV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44yV: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_s43PZ_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43QB_entry() //  [R1]
         { info_tbl: [(c44A1,
                       label: sat_s43QB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44A1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44A2; else goto c44A3;
       c44A2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44A3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go2_s43Qt_entry() //  [R1, R2]
         { info_tbl: [(c44A8,
                       label: go2_s43Qt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44A8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44A9; else goto c44Aa;
       c44A9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c44Aa: // global
           I64[Sp - 32] = block_c44zL_info;
           _s43Qt::P64 = R1;
           _s43PP::P64 = P64[R1 + 7];
           _s43Qs::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s43PP::P64;
           P64[Sp - 16] = _s43Qs::P64;
           P64[Sp - 8] = _s43Qt::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u44Ak; else goto c44zM;
       u44Ak: // global
           call _c44zL(R1) args: 0, res: 0, upd: 0;
       c44zM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44zL() //  [R1]
         { info_tbl: [(c44zL,
                       label: block_c44zL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44zL: // global
           if (R1 & 7 == 1) goto c44A5; else goto c44A6;
       c44A5: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c44A6: // global
           I64[Sp] = block_c44zR_info;
           _s43Qx::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _s43Qx::P64;
           if (R1 & 7 != 0) goto u44Aj; else goto c44zS;
       u44Aj: // global
           call _c44zR(R1) args: 0, res: 0, upd: 0;
       c44zS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44zR() //  [R1]
         { info_tbl: [(c44zR,
                       label: block_c44zR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44zR: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c44Ai; else goto c44Ah;
       c44Ai: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44Ah: // global
           _s43Qz::P64 = P64[R1 + 7];
           _s43QA::P64 = P64[R1 + 15];
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 16];
           I64[Hp - 72] = sat_s43QB_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _s43Qz::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _s43QA::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 104;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go1_s43Qd_entry() //  [R1, R2]
         { info_tbl: [(c44Ap,
                       label: go1_s43Qd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Ap: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c44Aq; else goto u44B1;
       c44Aq: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u44B1: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _c44z8() args: 0, res: 0, upd: 0;
     }
 },
 _c44z8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44z8: // global
           I64[Sp - 16] = block_c44zb_info;
           R1 = P64[Sp + 8];
           _s43Qd::P64 = P64[Sp];
           P64[Sp - 8] = P64[_s43Qd::P64 + 15];
           P64[Sp + 8] = P64[_s43Qd::P64 + 7];
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u44B6; else goto c44zc;
       u44B6: // global
           call _c44zb(R1) args: 0, res: 0, upd: 0;
       c44zc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44zb() //  [R1]
         { info_tbl: [(c44zb,
                       label: block_c44zb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44zb: // global
           if (R1 & 7 == 1) goto c44Am; else goto c44An;
       c44Am: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c44An: // global
           I64[Sp - 8] = block_c44zh_info;
           _s43Qh::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s43Qh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44B7; else goto c44zi;
       u44B7: // global
           call _c44zh(R1) args: 0, res: 0, upd: 0;
       c44zi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44zh() //  [R1]
         { info_tbl: [(c44zh,
                       label: block_c44zh_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44zh: // global
           I64[Sp - 8] = block_c44zm_info;
           _s43Qk::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s43Qk::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44B8; else goto c44zn;
       u44B8: // global
           call _c44zm(R1) args: 0, res: 0, upd: 0;
       c44zn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44zm() //  [R1]
         { info_tbl: [(c44zm,
                       label: block_c44zm_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44zm: // global
           if (R1 & 7 == 1) goto u44B2; else goto c44AB;
       u44B2: // global
           Sp = Sp + 16;
           call _c44AY() args: 0, res: 0, upd: 0;
       c44AB: // global
           I64[Sp - 8] = block_c44zs_info;
           _s43Qn::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s43Qn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44B9; else goto c44zt;
       u44B9: // global
           call _c44zs(R1) args: 0, res: 0, upd: 0;
       c44zt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44zs() //  [R1]
         { info_tbl: [(c44zs,
                       label: block_c44zs_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44zs: // global
           if (I64[R1 + 7] == 45) goto c44AF; else goto u44B3;
       c44AF: // global
           _s43Qn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c44zA_info;
           R1 = _s43Qn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u44Bb; else goto c44zB;
       u44Bb: // global
           call _c44zA(R1) args: 0, res: 0, upd: 0;
       c44zB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u44B3: // global
           Sp = Sp + 24;
           call _c44AY() args: 0, res: 0, upd: 0;
     }
 },
 _c44zA() //  [R1]
         { info_tbl: [(c44zA,
                       label: block_c44zA_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44zA: // global
           if (R1 & 7 == 1) goto c44AM; else goto u44B4;
       c44AM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c44AP; else goto c44AO;
       c44AP: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44AO: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = go2_s43Qt_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = Hp - 48;
           I64[Sp + 16] = block_c44AG_info;
           R3 = P64[Sp + 8];
           R2 = GHC.Read.lex1_closure;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u44B4: // global
           Sp = Sp + 16;
           call _c44AY() args: 0, res: 0, upd: 0;
     }
 },
 _c44AG() //  [R1]
         { info_tbl: [(c44AG,
                       label: block_c44AG_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44AG: // global
           I64[Sp + 16] = block_c44AK_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s43PQ_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44AK() //  [R1]
         { info_tbl: [(c44AK,
                       label: block_c44AK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44AK: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go2_s43Qt_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c44AY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44AY: // global
           P64[Sp + 24] = P64[Sp];
           Sp = Sp + 16;
           call _c44z8() args: 0, res: 0, upd: 0;
     }
 },
 sat_s43QM_entry() //  [R1]
         { info_tbl: [(c44Br,
                       label: sat_s43QM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Br: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44Bs; else goto c44Bt;
       c44Bs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Bt: // global
           I64[Sp - 16] = block_c44Bp_info;
           R3 = P64[R1 + 24];
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 8] = P64[R1 + 16];
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44Bp() //  [R1]
         { info_tbl: [(c44Bp,
                       label: block_c44Bp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Bp: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_s43Qd_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43QN_entry() //  [R1, R2]
         { info_tbl: [(c44Bz,
                       label: sat_s43QN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Bz: // global
           _s43QI::P64 = R2;
           _s43QN::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c44BD; else goto c44BE;
       c44BE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44BG; else goto c44BF;
       c44BG: // global
           HpAlloc = 32;
           goto c44BD;
       c44BD: // global
           R2 = _s43QI::P64;
           R1 = _s43QN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c44BF: // global
           _s43PQ::P64 = P64[_s43QN::P64 + 7];
           _s43Qd::P64 = P64[_s43QN::P64 + 15];
           I64[Hp - 24] = sat_s43QM_info;
           P64[Hp - 8] = _s43Qd::P64;
           P64[Hp] = _s43QI::P64;
           I64[Sp - 24] = block_c44Bx_info;
           R3 = _s43QI::P64;
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _s43PQ::P64;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44Bx() //  [R1]
         { info_tbl: [(c44Bx,
                       label: block_c44Bx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Bx: // global
           I64[Sp] = block_c44BC_info;
           R2 = R1;
           R1 = P64[Sp + 16];
           call go_s43PQ_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44BC() //  [R1]
         { info_tbl: [(c44BC,
                       label: block_c44BC_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44BC: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Numeric.readSigned_entry() //  [R2, R3, R4]
         { info_tbl: [(c44BM,
                       label: Numeric.readSigned_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44BM: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c44BQ; else goto c44BP;
       c44BQ: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readSigned_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c44BP: // global
           I64[Hp - 80] = $dNum_s43PP_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = go_s43PQ_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = go1_s43Qd_info;
           P64[Hp - 32] = Hp - 80;
           _c44xF::P64 = Hp - 55;
           P64[Hp - 24] = _c44xF::P64;
           I64[Hp - 16] = sat_s43QN_info;
           P64[Hp - 8] = _c44xF::P64;
           P64[Hp] = Hp - 39;
           R4 = R4;
           R3 = Hp - 15;
           R2 = GHC.Types.False_closure+1;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.219302696 UTC

[section ""data" . sat_s43QO_closure" {
     sat_s43QO_closure:
         const GHC.Types.I#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.219921054 UTC

[section ""data" . sat_s43QP_closure" {
     sat_s43QP_closure:
         const :_con_info;
         const sat_s43QO_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.220881394 UTC

[section ""data" . Numeric.showInt2_closure" {
     Numeric.showInt2_closure:
         const Numeric.showInt2_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showInt2_entry() //  [R1]
         { info_tbl: [(c44BX,
                       label: Numeric.showInt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44BX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44BY; else goto c44BZ;
       c44BY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44BZ: // global
           (_c44BU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44BU::I64 == 0) goto c44BW; else goto c44BV;
       c44BW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44BV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44BU::I64;
           R3 = sat_s43QP_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.222839504 UTC

[section ""cstring" . lvl_r43OH_bytes" {
     lvl_r43OH_bytes:
         I8[] [78,117,109,101,114,105,99,46,115,104,111,119,73,110,116,58,32,99,97,110,39,116,32,115,104,111,119,32,110,101,103,97,116,105,118,101,32,110,117,109,98,101,114,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.224242373 UTC

[section ""data" . Numeric.showInt1_closure" {
     Numeric.showInt1_closure:
         const Numeric.showInt1_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showInt1_entry() //  [R1]
         { info_tbl: [(c44C8,
                       label: Numeric.showInt1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44C8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c44C9; else goto c44Ca;
       c44C9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Ca: // global
           (_c44C3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44C3::I64 == 0) goto c44C5; else goto c44C4;
       c44C5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44C4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44C3::I64;
           I64[Sp - 24] = block_c44C6_info;
           R2 = lvl_r43OH_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44C6() //  [R1]
         { info_tbl: [(c44C6,
                       label: block_c44C6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44C6: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.226149436 UTC

[section ""data" . Numeric.showHFloat16_closure" {
     Numeric.showHFloat16_closure:
         const Numeric.showHFloat16_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat16_entry() //  [R1]
         { info_tbl: [(c44Ck,
                       label: Numeric.showHFloat16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Ck: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44Cl; else goto c44Cm;
       c44Cl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Cm: // global
           (_c44Ch::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44Ch::I64 == 0) goto c44Cj; else goto c44Ci;
       c44Cj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44Ci: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44Ch::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.231415478 UTC

[section ""data" . Numeric.showInt_closure" {
     Numeric.showInt_closure:
         const Numeric.showInt_info;
         const 0;
 },
 sat_s43QX_entry() //  [R1]
         { info_tbl: [(c44Dk,
                       label: sat_s43QX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Dk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44Dl; else goto c44Dm;
       c44Dl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Dm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c44Di_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44Di() //  [R1]
         { info_tbl: [(c44Di,
                       label: block_c44Di_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Di: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showHFloat16_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl5_s43QZ_entry() //  [R1]
         { info_tbl: [(c44Du,
                       label: lvl5_s43QZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Du: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44Dv; else goto c44Dw;
       c44Dv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Dw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c44Ds_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44Ds() //  [R1]
         { info_tbl: [(c44Ds,
                       label: block_c44Ds_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Ds: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showInt2_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s43Re_entry() //  [R1]
         { info_tbl: [(c44DC,
                       label: ds_s43Re_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44DC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c44DD; else goto c44DE;
       c44DD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44DE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quotRem_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Numeric.showInt_entry() //  [R2, R3, R4]
         { info_tbl: [(c44DF,
                       label: Numeric.showInt_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44DF: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c44DG; else goto c44DH;
       c44DG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showInt_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c44DH: // global
           I64[Sp - 32] = block_c44Cr_info;
           _s43QR::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s43QR::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44Cr() //  [R1]
         { info_tbl: [(c44Cr,
                       label: block_c44Cr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Cr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44DK; else goto c44DJ;
       c44DK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44DJ: // global
           I64[Hp - 16] = sat_s43QX_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c44Cx_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44Cx() //  [R1]
         { info_tbl: [(c44Cx,
                       label: block_c44Cx_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Cx: // global
           I64[Sp] = block_c44CB_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c44CB() //  [R1]
         { info_tbl: [(c44CB,
                       label: block_c44CB_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44CB: // global
           if (R1 & 7 == 1) goto c44DN; else goto c44Ex;
       c44DN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44DQ; else goto c44DP;
       c44DQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44DP: // global
           I64[Hp - 16] = lvl5_s43QZ_info;
           _s43QU::P64 = P64[Sp + 8];
           P64[Hp] = _s43QU::P64;
           I64[Sp + 8] = block_c44CH_info;
           R2 = _s43QU::P64;
           P64[Sp + 16] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
       c44Ex: // global
           R1 = Numeric.showInt1_closure;
           Sp = Sp + 48;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c44CH() //  [R1]
         { info_tbl: [(c44CH,
                       label: block_c44CH_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44CH: // global
           P64[Sp] = P64[Sp + 32];
           P64[Sp + 24] = P64[Sp + 24];
           P64[Sp + 32] = R1;
           call _c44CQ() args: 0, res: 0, upd: 0;
     }
 },
 _c44CQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44CQ: // global
           I64[Sp - 8] = block_c44CS_info;
           R2 = P64[Sp + 32];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 24];
           P64[Sp - 16] = P64[Sp + 8];
           Sp = Sp - 32;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c44CS() //  [R1]
         { info_tbl: [(c44CS,
                       label: block_c44CS_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44CS: // global
           _s43QR::P64 = P64[Sp + 24];
           _s43Rb::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c44Ei; else goto c44Et;
       c44Ei: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c44El; else goto c44Ek;
       c44El: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44Ek: // global
           I64[Hp - 56] = ds_s43Re_info;
           P64[Hp - 40] = _s43QR::P64;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s43Rb::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           _c44CW::P64 = Hp - 56;
           P64[Hp] = _c44CW::P64;
           I64[Sp] = block_c44CZ_info;
           R2 = _s43QR::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           P64[Sp + 32] = _c44CW::P64;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
       c44Et: // global
           I64[Sp + 32] = block_c44DV_info;
           R2 = _s43QR::P64;
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = _s43Rb::P64;
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c44CZ() //  [R1]
         { info_tbl: [(c44CZ,
                       label: block_c44CZ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44CZ: // global
           I64[Sp] = block_c44D3_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44D3() //  [R1]
         { info_tbl: [(c44D3,
                       label: block_c44D3_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44D3: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c44Ep; else goto c44Eo;
       c44Ep: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c44Eo: // global
           I64[Hp - 56] = GHC.Types.C#_con_info;
           I64[Hp - 48] = R1 + 48;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 55;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = P64[Sp + 32];
           P64[Sp + 32] = Hp - 16;
           P64[Sp + 8] = Hp - 38;
           Sp = Sp + 8;
           call _c44CQ() args: 0, res: 0, upd: 0;
     }
 },
 _c44DV() //  [R1]
         { info_tbl: [(c44DV,
                       label: block_c44DV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44DV: // global
           I64[Sp] = block_c44DZ_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44DZ() //  [R1]
         { info_tbl: [(c44DZ,
                       label: block_c44DZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44DZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c44Ef; else goto c44Ee;
       c44Ef: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c44Ee: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = R1 + 48;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.236386388 UTC

[section ""data" . Numeric.showFFloatAlt_closure" {
     Numeric.showFFloatAlt_closure:
         const Numeric.showFFloatAlt_info;
         const 0;
 },
 sat_s43Rw_entry() //  [R1]
         { info_tbl: [(c44EM,
                       label: sat_s43Rw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44EM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44EN; else goto c44EO;
       c44EN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44EO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.True_closure+2;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFFixed_closure+2;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showFFloatAlt_entry() //  [R2, R3, R4]
         { info_tbl: [(c44EP,
                       label: Numeric.showFFloatAlt_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44EP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c44ET; else goto c44ES;
       c44ET: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showFFloatAlt_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c44ES: // global
           I64[Hp - 32] = sat_s43Rw_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.238159697 UTC

[section ""data" . Numeric.showGFloatAlt_closure" {
     Numeric.showGFloatAlt_closure:
         const Numeric.showGFloatAlt_info;
         const 0;
 },
 sat_s43RA_entry() //  [R1]
         { info_tbl: [(c44F2,
                       label: sat_s43RA_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44F2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44F3; else goto c44F4;
       c44F3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44F4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.True_closure+2;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFGeneric_closure+3;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showGFloatAlt_entry() //  [R2, R3, R4]
         { info_tbl: [(c44F5,
                       label: Numeric.showGFloatAlt_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44F5: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c44F9; else goto c44F8;
       c44F9: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showGFloatAlt_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c44F8: // global
           I64[Hp - 32] = sat_s43RA_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.239334976 UTC

[section ""cstring" . lvl1_r43OI_bytes" {
     lvl1_r43OI_bytes:
         I8[] [78,117,109,101,114,105,99,46,115,104,111,119,73,110,116,65,116,66,97,115,101,58,32,97,112,112,108,105,101,100,32,116,111,32,110,101,103,97,116,105,118,101,32,110,117,109,98,101,114,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.240458191 UTC

[section ""data" . Numeric.$wlvl_closure" {
     Numeric.$wlvl_closure:
         const Numeric.$wlvl_info;
         const 0;
 },
 sat_s43RF_entry() //  [R1]
         { info_tbl: [(c44Fl,
                       label: sat_s43RF_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Fl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c44Fm; else goto c44Fn;
       c44Fm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Fn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c44Fi_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44Fi() //  [R1, R2]
         { info_tbl: [(c44Fi,
                       label: block_c44Fi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Fi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44Fq; else goto c44Fp;
       c44Fq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c44Fp: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.$wlvl_entry() //  [R2]
         { info_tbl: [(c44Ft,
                       label: Numeric.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Ft: // global
           _s43RB::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c44Fu; else goto c44Fv;
       c44Fv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44Fx; else goto c44Fw;
       c44Fx: // global
           HpAlloc = 24;
           goto c44Fu;
       c44Fu: // global
           R2 = _s43RB::I64;
           R1 = Numeric.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c44Fw: // global
           I64[Hp - 16] = sat_s43RF_info;
           I64[Hp] = _s43RB::I64;
           I64[Sp - 8] = block_c44Fr_info;
           R3 = Hp - 16;
           R2 = lvl1_r43OI_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44Fr() //  [R1]
         { info_tbl: [(c44Fr,
                       label: block_c44Fr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Fr: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.242190125 UTC

[section ""cstring" . lvl2_r43OJ_bytes" {
     lvl2_r43OJ_bytes:
         I8[] [78,117,109,101,114,105,99,46,115,104,111,119,73,110,116,65,116,66,97,115,101,58,32,97,112,112,108,105,101,100,32,116,111,32,117,110,115,117,112,112,111,114,116,101,100,32,98,97,115,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.243211514 UTC

[section ""data" . Numeric.showIntAtBase2_closure" {
     Numeric.showIntAtBase2_closure:
         const Numeric.showIntAtBase2_info;
         const 0;
 },
 sat_s43RJ_entry() //  [R1]
         { info_tbl: [(c44FJ,
                       label: sat_s43RJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44FJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44FK; else goto c44FL;
       c44FK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44FL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Numeric.showIntAtBase2_entry() //  [R2, R3]
         { info_tbl: [(c44FO,
                       label: Numeric.showIntAtBase2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44FO: // global
           _s43RI::P64 = R3;
           _s43RH::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c44FP; else goto c44FQ;
       c44FQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44FS; else goto c44FR;
       c44FS: // global
           HpAlloc = 32;
           goto c44FP;
       c44FP: // global
           R3 = _s43RI::P64;
           R2 = _s43RH::P64;
           R1 = Numeric.showIntAtBase2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44FR: // global
           I64[Hp - 24] = sat_s43RJ_info;
           P64[Hp - 8] = _s43RH::P64;
           P64[Hp] = _s43RI::P64;
           I64[Sp - 8] = block_c44FM_info;
           R3 = Hp - 24;
           R2 = lvl1_r43OI_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44FM() //  [R1]
         { info_tbl: [(c44FM,
                       label: block_c44FM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44FM: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.245083214 UTC

[section ""data" . Numeric.showIntAtBase1_closure" {
     Numeric.showIntAtBase1_closure:
         const Numeric.showIntAtBase1_info;
         const 0;
 },
 sat_s43RN_entry() //  [R1]
         { info_tbl: [(c44G4,
                       label: sat_s43RN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44G4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44G5; else goto c44G6;
       c44G5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44G6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Numeric.showIntAtBase1_entry() //  [R2, R3]
         { info_tbl: [(c44G9,
                       label: Numeric.showIntAtBase1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44G9: // global
           _s43RM::P64 = R3;
           _s43RL::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c44Ga; else goto c44Gb;
       c44Gb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44Gd; else goto c44Gc;
       c44Gd: // global
           HpAlloc = 32;
           goto c44Ga;
       c44Ga: // global
           R3 = _s43RM::P64;
           R2 = _s43RL::P64;
           R1 = Numeric.showIntAtBase1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44Gc: // global
           I64[Hp - 24] = sat_s43RN_info;
           P64[Hp - 8] = _s43RL::P64;
           P64[Hp] = _s43RM::P64;
           I64[Sp - 8] = block_c44G7_info;
           R3 = Hp - 24;
           R2 = lvl2_r43OJ_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44G7() //  [R1]
         { info_tbl: [(c44G7,
                       label: block_c44G7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44G7: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.246518074 UTC

[section ""data" . sat_s43RP_closure" {
     sat_s43RP_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.247064935 UTC

[section ""data" . sat_s43RQ_closure" {
     sat_s43RQ_closure:
         const :_con_info;
         const sat_s43RP_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.247905679 UTC

[section ""data" . Numeric.showIntAtBase3_closure" {
     Numeric.showIntAtBase3_closure:
         const Numeric.showIntAtBase3_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showIntAtBase3_entry() //  [R1]
         { info_tbl: [(c44Gn,
                       label: Numeric.showIntAtBase3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Gn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44Go; else goto c44Gp;
       c44Go: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Gp: // global
           (_c44Gk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44Gk::I64 == 0) goto c44Gm; else goto c44Gl;
       c44Gm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44Gl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44Gk::I64;
           R3 = sat_s43RQ_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.25144338 UTC

[section ""data" . Numeric.showIntAtBase_closure" {
     Numeric.showIntAtBase_closure:
         const Numeric.showIntAtBase_info;
         const 0;
 },
 $dNum_s43RY_entry() //  [R1]
         { info_tbl: [(c44Hm,
                       label: $dNum_s43RY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Hm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44Hn; else goto c44Ho;
       c44Hn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Ho: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43S0_entry() //  [R1]
         { info_tbl: [(c44Hr,
                       label: sat_s43S0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Hr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44Hs; else goto c44Ht;
       c44Hs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Ht: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showIntAtBase3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43S2_entry() //  [R1]
         { info_tbl: [(c44Hw,
                       label: sat_s43S2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Hw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44Hx; else goto c44Hy;
       c44Hx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Hy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showHFloat16_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl5_s43S7_entry() //  [R1]
         { info_tbl: [(c44HB,
                       label: lvl5_s43S7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44HB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44HC; else goto c44HD;
       c44HC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44HD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showHFloat16_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43Sf_entry() //  [R1]
         { info_tbl: [(c44HI,
                       label: sat_s43Sf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44HI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c44HQ; else goto c44HR;
       c44HQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44HR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c44HG_info;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c44HG() //  [R1]
         { info_tbl: [(c44HG,
                       label: block_c44HG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44HG: // global
           I64[Sp] = block_c44HL_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44HL() //  [R1]
         { info_tbl: [(c44HL,
                       label: block_c44HL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44HL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c44HV; else goto c44HU;
       c44HV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c44HU: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showIntAtBase_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c44HW,
                       label: Numeric.showIntAtBase_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44HW: // global
           if ((Sp + -88) < SpLim) (likely: False) goto c44HX; else goto c44HY;
       c44HX: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showIntAtBase_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c44HY: // global
           I64[Sp - 48] = block_c44Gu_info;
           _s43RR::P64 = R2;
           R2 = R2;
           P64[Sp - 40] = _s43RR::P64;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44Gu() //  [R1]
         { info_tbl: [(c44Gu,
                       label: block_c44Gu_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Gu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44I1; else goto c44I0;
       c44I1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44I0: // global
           I64[Hp - 16] = $dNum_s43RY_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c44GA_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44GA() //  [R1]
         { info_tbl: [(c44GA,
                       label: block_c44GA_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44GA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44I4; else goto c44I3;
       c44I4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44I3: // global
           I64[Hp - 16] = sat_s43S0_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c44GG_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 32];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c44GG() //  [R1]
         { info_tbl: [(c44GG,
                       label: block_c44GG_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44GG: // global
           if (R1 & 7 == 1) goto c44I6; else goto c44IF;
       c44I6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44I9; else goto c44I8;
       c44I9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44I8: // global
           I64[Hp - 16] = sat_s43S2_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp] = block_c44GM_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 56];
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
       c44IF: // global
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           Sp = Sp + 72;
           call Numeric.showIntAtBase1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c44GM() //  [R1]
         { info_tbl: [(c44GM,
                       label: block_c44GM_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44GM: // global
           _s43RV::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto c44Ic; else goto c44IB;
       c44Ic: // global
           I64[Sp] = block_c44GQ_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s43RV::P64;
           P64[Sp - 8] = P64[Sp + 40];
           Sp = Sp - 24;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 8;
       c44IB: // global
           R3 = _s43RV::P64;
           R2 = P64[Sp + 32];
           Sp = Sp + 72;
           call Numeric.showIntAtBase2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c44GQ() //  [R1]
         { info_tbl: [(c44GQ,
                       label: block_c44GQ_info
                       rep:StackRep [False, False, False, True, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44GQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44If; else goto c44Ie;
       c44If: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44Ie: // global
           _s43S5::P64 = P64[R1 + 7];
           _s43S6::P64 = P64[R1 + 15];
           I64[Hp - 16] = lvl5_s43S7_info;
           P64[Hp] = P64[Sp + 16];
           _s43RZ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c44GW_info;
           R2 = _s43RZ::P64;
           P64[Sp + 16] = _s43S6::P64;
           P64[Sp + 32] = _s43S5::P64;
           P64[Sp + 56] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44GW() //  [R1]
         { info_tbl: [(c44GW,
                       label: block_c44GW_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44GW: // global
           P64[Sp] = P64[Sp + 56];
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 24] = P64[Sp + 24];
           P64[Sp + 56] = R1;
           call _c44H3() args: 0, res: 0, upd: 0;
     }
 },
 _c44H3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44H3: // global
           Hp = Hp + 32;
           _s43Sb::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c44Ij; else goto c44Ii;
       c44Ij: // global
           HpAlloc = 32;
           I64[Sp + 8] = block_c44H2_info;
           R3 = P64[Sp];
           R2 = _s43Sb::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 8;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       c44Ii: // global
           I64[Hp - 24] = sat_s43Sf_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s43Sb::P64;
           I64[Sp - 8] = block_c44H7_info;
           R2 = Hp - 24;
           R1 = P64[Sp + 40];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44H2() //  [R1, R2, R3]
         { info_tbl: [(c44H2,
                       label: block_c44H2_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44H2: // global
           P64[Sp + 16] = R1;
           P64[Sp] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 8;
           call _c44H3() args: 0, res: 0, upd: 0;
     }
 },
 _c44H7() //  [R1]
         { info_tbl: [(c44H7,
                       label: block_c44H7_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44H7: // global
           I64[Sp] = block_c44Hb_info;
           R2 = P64[Sp + 64];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 56];
           P64[Sp + 16] = R1;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c44Hb() //  [R1]
         { info_tbl: [(c44Hb,
                       label: block_c44Hb_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Hb: // global
           if (R1 & 7 == 1) goto c44In; else goto c44Iu;
       c44In: // global
           I64[Sp] = block_c44Hf_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 40];
           Sp = Sp - 24;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 8;
       c44Iu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44Ix; else goto c44Iw;
       c44Ix: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44Iw: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 14;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c44Hf() //  [R1]
         { info_tbl: [(c44Hf,
                       label: block_c44Hf_info
                       rep:StackRep [False, False, False, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Hf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44Iq; else goto c44Ip;
       c44Iq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44Ip: // global
           _s43Sk::P64 = P64[R1 + 7];
           _s43Sl::P64 = P64[R1 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           P64[Sp + 32] = _s43Sk::P64;
           P64[Sp + 16] = _s43Sl::P64;
           P64[Sp + 8] = Hp - 14;
           Sp = Sp + 8;
           call _c44H3() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.257228465 UTC

[section ""data" . sat_s43Sn_closure" {
     sat_s43Sn_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.257918606 UTC

[section ""data" . sat_s43So_closure" {
     sat_s43So_closure:
         const :_con_info;
         const sat_s43Sn_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.258791553 UTC

[section ""data" . Numeric.showHex1_closure" {
     Numeric.showHex1_closure:
         const Numeric.showHex1_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHex1_entry() //  [R1]
         { info_tbl: [(c44IV,
                       label: Numeric.showHex1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44IV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44IW; else goto c44IX;
       c44IW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44IX: // global
           (_c44IS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44IS::I64 == 0) goto c44IU; else goto c44IT;
       c44IU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44IT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44IS::I64;
           R3 = sat_s43So_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.260292612 UTC

[section ""data" . Numeric.showHex_closure" {
     Numeric.showHex_closure:
         const Numeric.showHex_info;
         const 0;
 },
 sat_s43St_entry() //  [R1]
         { info_tbl: [(c44J8,
                       label: sat_s43St_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44J8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44Jc; else goto c44Jd;
       c44Jc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Jd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c44J6_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44J6() //  [R1]
         { info_tbl: [(c44J6,
                       label: block_c44J6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44J6: // global
           I64[Sp] = block_c44Jb_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44Jb() //  [R1]
         { info_tbl: [(c44Jb,
                       label: block_c44Jb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Jb: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showHex1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Numeric.showHex_entry() //  [R2, R3]
         { info_tbl: [(c44Jj,
                       label: Numeric.showHex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Jj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44Jn; else goto c44Jm;
       c44Jn: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showHex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44Jm: // global
           I64[Hp - 16] = sat_s43St_info;
           P64[Hp] = R2;
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showIntAtBase_closure+6;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.261925396 UTC

[section ""cstring" . Numeric.$trModule4_bytes" {
     Numeric.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.2626851 UTC

[section ""data" . loc_r43OK_closure" {
     loc_r43OK_closure:
         const loc_r43OK_info;
         const 0;
         const 0;
         const 0;
 },
 loc_r43OK_entry() //  [R1]
         { info_tbl: [(c44Ju,
                       label: loc_r43OK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Ju: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44Jv; else goto c44Jw;
       c44Jv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Jw: // global
           (_c44Jr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44Jr::I64 == 0) goto c44Jt; else goto c44Js;
       c44Jt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44Js: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44Jr::I64;
           R2 = Numeric.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.263596162 UTC

[section ""cstring" . Numeric.$trModule2_bytes" {
     Numeric.$trModule2_bytes:
         I8[] [78,117,109,101,114,105,99]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.264339349 UTC

[section ""data" . loc1_r43OL_closure" {
     loc1_r43OL_closure:
         const loc1_r43OL_info;
         const 0;
         const 0;
         const 0;
 },
 loc1_r43OL_entry() //  [R1]
         { info_tbl: [(c44JD,
                       label: loc1_r43OL_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44JD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44JE; else goto c44JF;
       c44JE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44JF: // global
           (_c44JA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44JA::I64 == 0) goto c44JC; else goto c44JB;
       c44JC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44JB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44JA::I64;
           R2 = Numeric.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.265437758 UTC

[section ""cstring" . loc2_r43OM_bytes" {
     loc2_r43OM_bytes:
         I8[] [78,117,109,101,114,105,99,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.266215507 UTC

[section ""data" . loc3_r43ON_closure" {
     loc3_r43ON_closure:
         const loc3_r43ON_info;
         const 0;
         const 0;
         const 0;
 },
 loc3_r43ON_entry() //  [R1]
         { info_tbl: [(c44JM,
                       label: loc3_r43ON_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44JM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44JN; else goto c44JO;
       c44JN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44JO: // global
           (_c44JJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44JJ::I64 == 0) goto c44JL; else goto c44JK;
       c44JL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44JK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44JJ::I64;
           R2 = loc2_r43OM_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.267148782 UTC

[section ""data" . loc4_r43OO_closure" {
     loc4_r43OO_closure:
         const GHC.Types.I#_con_info;
         const 241;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.267695505 UTC

[section ""data" . loc5_r43OP_closure" {
     loc5_r43OP_closure:
         const GHC.Types.I#_con_info;
         const 22;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.268267179 UTC

[section ""data" . loc6_r43OQ_closure" {
     loc6_r43OQ_closure:
         const GHC.Types.I#_con_info;
         const 75;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.268837652 UTC

[section ""cstring" . $dIP_r43OR_bytes" {
     $dIP_r43OR_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.269721515 UTC

[section ""data" . $dIP1_r43OS_closure" {
     $dIP1_r43OS_closure:
         const $dIP1_r43OS_info;
         const 0;
         const 0;
         const 0;
 },
 $dIP1_r43OS_entry() //  [R1]
         { info_tbl: [(c44JV,
                       label: $dIP1_r43OS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44JV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44JW; else goto c44JX;
       c44JW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44JX: // global
           (_c44JS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44JS::I64 == 0) goto c44JU; else goto c44JT;
       c44JU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44JT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44JS::I64;
           R2 = $dIP_r43OR_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.270714698 UTC

[section ""data" . $dIP2_r43OT_closure" {
     $dIP2_r43OT_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const loc_r43OK_closure;
         const loc1_r43OL_closure;
         const loc3_r43ON_closure;
         const loc4_r43OO_closure+1;
         const loc5_r43OP_closure+1;
         const loc4_r43OO_closure+1;
         const loc6_r43OQ_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.27313535 UTC

[section ""data" . $dIP3_r43OU_closure" {
     $dIP3_r43OU_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const $dIP1_r43OS_closure;
         const $dIP2_r43OT_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.273807799 UTC

[section ""cstring" . lvl3_r43OV_bytes" {
     lvl3_r43OV_bytes:
         I8[] [73,109,112,111,115,115,105,98,108,101,32,104,97,112,112,101,110,101,100,58,32,115,104,111,119,72,70,108,111,97,116,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.274364828 UTC

[section ""data" . lvl4_r43OW_closure" {
     lvl4_r43OW_closure:
         const :_con_info;
         const GHC.Show.$fShow(,)2_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.275904797 UTC

[section ""data" . $wlvl2_r43OX_closure" {
     $wlvl2_r43OX_closure:
         const $wlvl2_r43OX_info;
         const 0;
 },
 sat_s43SB_entry() //  [R1, R2]
         { info_tbl: [(c44Ke,
                       label: sat_s43SB_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Ke: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c44Kf; else goto c44Kg;
       c44Kf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c44Kg: // global
           I64[Sp - 8] = block_c44Kb_info;
           R4 = R2;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44Kb() //  [R1, R2]
         { info_tbl: [(c44Kb,
                       label: block_c44Kb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Kb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44Kj; else goto c44Ki;
       c44Kj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c44Ki: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43Sw_entry() //  [R1, R2]
         { info_tbl: [(c44Kq,
                       label: sat_s43Sw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Kq: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Show.$fShowInt_$cshowList_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43SE_entry() //  [R1]
         { info_tbl: [(c44Ku,
                       label: sat_s43SE_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Ku: // global
           _s43SE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c44Kv; else goto c44Kw;
       c44Kw: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c44Ky; else goto c44Kx;
       c44Ky: // global
           HpAlloc = 80;
           goto c44Kv;
       c44Kv: // global
           R1 = _s43SE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Kx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43SE::P64;
           _s43Su::P64 = P64[_s43SE::P64 + 16];
           _s43Sv::I64 = I64[_s43SE::P64 + 24];
           I64[Hp - 72] = sat_s43SB_info;
           I64[Hp - 64] = _s43Sv::I64;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           I64[Hp - 32] = sat_s43Sw_info;
           P64[Hp - 24] = _s43Su::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 54;
           R3 = lvl4_r43OW_closure+2;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Show.$fShow(,)_go1_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl2_r43OX_entry() //  [R2, R3]
         { info_tbl: [(c44KC,
                       label: $wlvl2_r43OX_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44KC: // global
           _s43Sv::I64 = R3;
           _s43Su::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c44KD; else goto c44KE;
       c44KE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c44KG; else goto c44KF;
       c44KG: // global
           HpAlloc = 56;
           goto c44KD;
       c44KD: // global
           R3 = _s43Sv::I64;
           R2 = _s43Su::P64;
           R1 = $wlvl2_r43OX_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44KF: // global
           I64[Hp - 48] = sat_s43SE_info;
           P64[Hp - 32] = _s43Su::P64;
           I64[Hp - 24] = _s43Sv::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           I64[Sp - 8] = block_c44KA_info;
           R3 = Hp - 14;
           R2 = lvl3_r43OV_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44KA() //  [R1]
         { info_tbl: [(c44KA,
                       label: block_c44KA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44KA: // global
           R3 = R1;
           R2 = $dIP3_r43OU_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.278834209 UTC

[section ""data" . Numeric.showHFloat_allZ_closure" {
     Numeric.showHFloat_allZ_closure:
         const Numeric.showHFloat_allZ_info;
 },
 Numeric.showHFloat_allZ_entry() //  [R2]
         { info_tbl: [(c44KV,
                       label: Numeric.showHFloat_allZ_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44KV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44KW; else goto u44Le;
       c44KW: // global
           R2 = R2;
           R1 = Numeric.showHFloat_allZ_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u44Le: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c44KL() args: 0, res: 0, upd: 0;
     }
 },
 _c44KL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44KL: // global
           _s43SH::P64 = P64[Sp];
           I64[Sp] = block_c44KO_info;
           R1 = _s43SH::P64;
           if (R1 & 7 != 0) goto u44Lg; else goto c44KP;
       u44Lg: // global
           call _c44KO(R1) args: 0, res: 0, upd: 0;
       c44KP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44KO() //  [R1]
         { info_tbl: [(c44KO,
                       label: block_c44KO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44KO: // global
           if (R1 & 7 == 1) goto c44KS; else goto c44KT;
       c44KS: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c44KT: // global
           I64[Sp - 8] = block_c44L3_info;
           _s43SK::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s43SK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44Lh; else goto c44L5;
       u44Lh: // global
           call _c44L3(R1) args: 0, res: 0, upd: 0;
       c44L5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44L3() //  [R1]
         { info_tbl: [(c44L3,
                       label: block_c44L3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44L3: // global
           if (I64[R1 + 7] == 0) goto c44Ld; else goto c44Lc;
       c44Ld: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c44KL() args: 0, res: 0, upd: 0;
       c44Lc: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.28117492 UTC

[section ""data" . $wshowIt1_r43OY_closure" {
     $wshowIt1_r43OY_closure:
         const $wshowIt1_r43OY_info;
         const 0;
 },
 $wshowIt1_r43OY_entry() //  [R2, R3, R4]
         { info_tbl: [(c44LC,
                       label: $wshowIt1_r43OY_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44LC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44LD; else goto u44LP;
       c44LD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wshowIt1_r43OY_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u44LP: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c44Ll() args: 0, res: 0, upd: 0;
     }
 },
 _c44Ll() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Ll: // global
           I64[Sp - 8] = block_c44Lo_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44LR; else goto c44Lp;
       u44LR: // global
           call _c44Lo(R1) args: 0, res: 0, upd: 0;
       c44Lp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44Lo() //  [R1]
         { info_tbl: [(c44Lo,
                       label: block_c44Lo_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Lo: // global
           I64[Sp] = block_c44Lt_info;
           R2 = I64[R1 + 7];
           call GHC.Show.$wintToDigit_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44Lt() //  [R1]
         { info_tbl: [(c44Lt,
                       label: block_c44Lt_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Lt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c44LI; else goto c44LH;
       c44LI: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c44LH: // global
           _s43SQ::P64 = P64[Sp + 24];
           _s43SU::I64 = I64[Sp + 8];
           if (_s43SU::I64 == 0) goto c44LO; else goto c44LK;
       c44LO: // global
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43SQ::P64;
           _c44LN::P64 = Hp - 30;
           Hp = Hp - 16;
           R1 = _c44LN::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c44LK: // global
           (_s43SW::I64, _s43SX::I64) = call MO_S_QuotRem W64(_s43SU::I64, 16);
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43SQ::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43SX::I64;
           I64[Sp + 8] = _s43SW::I64;
           P64[Sp + 16] = Hp - 7;
           P64[Sp + 24] = Hp - 30;
           Sp = Sp + 8;
           call _c44Ll() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.283653651 UTC

[section ""data" . $wshowIt2_r43OZ_closure" {
     $wshowIt2_r43OZ_closure:
         const $wshowIt2_r43OZ_info;
         const 0;
 },
 $wshowIt2_r43OZ_entry() //  [R2, R3, R4]
         { info_tbl: [(c44Mc,
                       label: $wshowIt2_r43OZ_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Mc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44Md; else goto u44Mp;
       c44Md: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wshowIt2_r43OZ_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u44Mp: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c44LV() args: 0, res: 0, upd: 0;
     }
 },
 _c44LV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44LV: // global
           I64[Sp - 8] = block_c44LY_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44Mr; else goto c44LZ;
       u44Mr: // global
           call _c44LY(R1) args: 0, res: 0, upd: 0;
       c44LZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44LY() //  [R1]
         { info_tbl: [(c44LY,
                       label: block_c44LY_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44LY: // global
           I64[Sp] = block_c44M3_info;
           R2 = I64[R1 + 7];
           call GHC.Show.$wintToDigit_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44M3() //  [R1]
         { info_tbl: [(c44M3,
                       label: block_c44M3_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44M3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c44Mi; else goto c44Mh;
       c44Mi: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c44Mh: // global
           _s43T4::P64 = P64[Sp + 24];
           _s43T8::I64 = I64[Sp + 8];
           if (_s43T8::I64 == 0) goto c44Mo; else goto c44Mk;
       c44Mo: // global
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43T4::P64;
           _c44Mn::P64 = Hp - 30;
           Hp = Hp - 16;
           R1 = _c44Mn::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c44Mk: // global
           (_s43Ta::I64, _s43Tb::I64) = call MO_S_QuotRem W64(_s43T8::I64, 16);
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43T4::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43Tb::I64;
           I64[Sp + 8] = _s43Ta::I64;
           P64[Sp + 16] = Hp - 7;
           P64[Sp + 24] = Hp - 30;
           Sp = Sp + 8;
           call _c44LV() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.286409627 UTC

[section ""data" . $wshowIt3_r43P0_closure" {
     $wshowIt3_r43P0_closure:
         const $wshowIt3_r43P0_info;
         const 0;
 },
 $wshowIt3_r43P0_entry() //  [R2, R3, R4]
         { info_tbl: [(c44MM,
                       label: $wshowIt3_r43P0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44MM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44MN; else goto u44MZ;
       c44MN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wshowIt3_r43P0_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u44MZ: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c44Mv() args: 0, res: 0, upd: 0;
     }
 },
 _c44Mv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Mv: // global
           I64[Sp - 8] = block_c44My_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44N1; else goto c44Mz;
       u44N1: // global
           call _c44My(R1) args: 0, res: 0, upd: 0;
       c44Mz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44My() //  [R1]
         { info_tbl: [(c44My,
                       label: block_c44My_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44My: // global
           I64[Sp] = block_c44MD_info;
           R2 = I64[R1 + 7];
           call GHC.Show.$wintToDigit_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44MD() //  [R1]
         { info_tbl: [(c44MD,
                       label: block_c44MD_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44MD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c44MS; else goto c44MR;
       c44MS: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c44MR: // global
           _s43Ti::P64 = P64[Sp + 24];
           _s43Tm::I64 = I64[Sp + 8];
           if (_s43Tm::I64 == 0) goto c44MY; else goto c44MU;
       c44MY: // global
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43Ti::P64;
           _c44MX::P64 = Hp - 30;
           Hp = Hp - 16;
           R1 = _c44MX::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c44MU: // global
           (_s43To::I64, _s43Tp::I64) = call MO_S_QuotRem W64(_s43Tm::I64, 16);
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43Ti::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43Tp::I64;
           I64[Sp + 8] = _s43To::I64;
           P64[Sp + 16] = Hp - 7;
           P64[Sp + 24] = Hp - 30;
           Sp = Sp + 8;
           call _c44Mv() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.288884437 UTC

[section ""data" . $wshowIt4_r43P1_closure" {
     $wshowIt4_r43P1_closure:
         const $wshowIt4_r43P1_info;
         const 0;
 },
 $wshowIt4_r43P1_entry() //  [R2, R3, R4]
         { info_tbl: [(c44Nm,
                       label: $wshowIt4_r43P1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Nm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44Nn; else goto u44Nz;
       c44Nn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wshowIt4_r43P1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u44Nz: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c44N5() args: 0, res: 0, upd: 0;
     }
 },
 _c44N5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44N5: // global
           I64[Sp - 8] = block_c44N8_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44NB; else goto c44N9;
       u44NB: // global
           call _c44N8(R1) args: 0, res: 0, upd: 0;
       c44N9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44N8() //  [R1]
         { info_tbl: [(c44N8,
                       label: block_c44N8_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44N8: // global
           I64[Sp] = block_c44Nd_info;
           R2 = I64[R1 + 7];
           call GHC.Show.$wintToDigit_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44Nd() //  [R1]
         { info_tbl: [(c44Nd,
                       label: block_c44Nd_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Nd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c44Ns; else goto c44Nr;
       c44Ns: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c44Nr: // global
           _s43Tw::P64 = P64[Sp + 24];
           _s43TA::I64 = I64[Sp + 8];
           if (_s43TA::I64 == 0) goto c44Ny; else goto c44Nu;
       c44Ny: // global
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43Tw::P64;
           _c44Nx::P64 = Hp - 30;
           Hp = Hp - 16;
           R1 = _c44Nx::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c44Nu: // global
           (_s43TC::I64, _s43TD::I64) = call MO_S_QuotRem W64(_s43TA::I64, 16);
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43Tw::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43TD::I64;
           I64[Sp + 8] = _s43TC::I64;
           P64[Sp + 16] = Hp - 7;
           P64[Sp + 24] = Hp - 30;
           Sp = Sp + 8;
           call _c44N5() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.293978248 UTC

[section ""data" . Numeric.showHFloat_hex_closure" {
     Numeric.showHFloat_hex_closure:
         const Numeric.showHFloat_hex_info;
         const 0;
 },
 sat_s43UO_entry() //  [R1]
         { info_tbl: [(c44OP,
                       label: sat_s43UO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44OP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44OQ; else goto c44OR;
       c44OQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44OR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Numeric.showHFloat_hex_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showHFloat_hex_entry() //  [R2]
         { info_tbl: [(c44OW,
                       label: Numeric.showHFloat_hex_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44OW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c44OX; else goto c44OY;
       c44OX: // global
           R2 = R2;
           R1 = Numeric.showHFloat_hex_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c44OY: // global
           I64[Sp - 8] = block_c44NI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44R9; else goto c44NJ;
       u44R9: // global
           call _c44NI(R1) args: 0, res: 0, upd: 0;
       c44NJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44NI() //  [R1]
         { info_tbl: [(c44NI,
                       label: block_c44NI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44NI: // global
           if (R1 & 7 == 1) goto c44OT; else goto c44OU;
       c44OT: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c44OU: // global
           I64[Sp - 8] = block_c44NO_info;
           _s43TK::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _s43TK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44QZ; else goto c44NP;
       u44QZ: // global
           call _c44NO(R1) args: 0, res: 0, upd: 0;
       c44NP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44NO() //  [R1]
         { info_tbl: [(c44NO,
                       label: block_c44NO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44NO: // global
           if (R1 & 7 == 1) goto c44P6; else goto c44Pp;
       c44P6: // global
           _s43TK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c44P3_info;
           R1 = _s43TK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u44R0; else goto c44P7;
       u44R0: // global
           call _c44P3(R1) args: 0, res: 0, upd: 0;
       c44P7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c44Pp: // global
           I64[Sp - 8] = block_c44NU_info;
           _s43TV::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _s43TV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44R1; else goto c44NV;
       u44R1: // global
           call _c44NU(R1) args: 0, res: 0, upd: 0;
       c44NV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44P3() //  [R1]
         { info_tbl: [(c44P3,
                       label: block_c44P3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44P3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c44Pd; else goto c44Pc;
       c44Pd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44Pc: // global
           _s43TP::I64 = I64[R1 + 7] << 3;
           if (%MO_S_Ge_W64(_s43TP::I64, 0)) goto c44Pm; else goto c44Pn;
       c44Pm: // global
           (_s43TS::I64, _s43TT::I64) = call MO_S_QuotRem W64(_s43TP::I64, 16);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43TT::I64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 7;
           R2 = _s43TS::I64;
           Sp = Sp + 8;
           call $wshowIt4_r43P1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c44Pn: // global
           Hp = Hp - 16;
           R2 = _s43TP::I64;
           Sp = Sp + 8;
           call Numeric.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c44NU() //  [R1]
         { info_tbl: [(c44NU,
                       label: block_c44NU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44NU: // global
           if (R1 & 7 == 1) goto c44Pz; else goto c44PZ;
       c44Pz: // global
           I64[Sp] = block_c44Pr_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u44R2; else goto c44Ps;
       u44R2: // global
           call _c44Pr(R1) args: 0, res: 0, upd: 0;
       c44Ps: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c44PZ: // global
           I64[Sp - 8] = block_c44O0_info;
           _s43Ua::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _s43Ua::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44R3; else goto c44O1;
       u44R3: // global
           call _c44O0(R1) args: 0, res: 0, upd: 0;
       c44O1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44Pr() //  [R1]
         { info_tbl: [(c44Pr,
                       label: block_c44Pr_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Pr: // global
           _s43TV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c44Pw_info;
           _s43TZ::I64 = I64[R1 + 7];
           R1 = _s43TV::P64;
           I64[Sp + 16] = _s43TZ::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u44Ra; else goto c44PB;
       u44Ra: // global
           call _c44Pw(R1) args: 0, res: 0, upd: 0;
       c44PB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44Pw() //  [R1]
         { info_tbl: [(c44Pw,
                       label: block_c44Pw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Pw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c44PH; else goto c44PG;
       c44PH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44PG: // global
           _s43U2::I64 = (I64[Sp + 8] << 3) + (I64[R1 + 7] << 2);
           if (%MO_S_Ge_W64(_s43U2::I64, 0)) goto c44PW; else goto c44PX;
       c44PW: // global
           (_s43U7::I64, _s43U8::I64) = call MO_S_QuotRem W64(_s43U2::I64, 16);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43U8::I64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 7;
           R2 = _s43U7::I64;
           Sp = Sp + 16;
           call $wshowIt3_r43P0_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c44PX: // global
           Hp = Hp - 16;
           R2 = _s43U2::I64;
           Sp = Sp + 16;
           call Numeric.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c44O0() //  [R1]
         { info_tbl: [(c44O0,
                       label: block_c44O0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44O0: // global
           _s43TK::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c44Qe; else goto c44QL;
       c44Qe: // global
           I64[Sp] = block_c44Q1_info;
           R1 = _s43TK::P64;
           if (R1 & 7 != 0) goto u44R4; else goto c44Q2;
       u44R4: // global
           call _c44Q1(R1) args: 0, res: 0, upd: 0;
       c44Q2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c44QL: // global
           I64[Sp - 8] = block_c44O6_info;
           _s43Ut::P64 = P64[R1 + 6];
           _s43Uu::P64 = P64[R1 + 14];
           R1 = _s43TK::P64;
           P64[Sp] = _s43Uu::P64;
           P64[Sp + 24] = _s43Ut::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44R5; else goto c44O7;
       u44R5: // global
           call _c44O6(R1) args: 0, res: 0, upd: 0;
       c44O7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44Q1() //  [R1]
         { info_tbl: [(c44Q1,
                       label: block_c44Q1_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Q1: // global
           I64[Sp] = block_c44Q6_info;
           _s43Ue::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 24] = _s43Ue::I64;
           if (R1 & 7 != 0) goto u44Rb; else goto c44Q7;
       u44Rb: // global
           call _c44Q6(R1) args: 0, res: 0, upd: 0;
       c44Q7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44Q6() //  [R1]
         { info_tbl: [(c44Q6,
                       label: block_c44Q6_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Q6: // global
           _s43Ua::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c44Qb_info;
           _s43Ug::I64 = I64[R1 + 7];
           R1 = _s43Ua::P64;
           I64[Sp + 16] = _s43Ug::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u44Rc; else goto c44Qh;
       u44Rc: // global
           call _c44Qb(R1) args: 0, res: 0, upd: 0;
       c44Qh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44Qb() //  [R1]
         { info_tbl: [(c44Qb,
                       label: block_c44Qb_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Qb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c44Qn; else goto c44Qm;
       c44Qn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44Qm: // global
           _s43Uj::I64 = (I64[Sp + 16] << 3) + ((I64[Sp + 8] << 2) + (I64[R1 + 7] << 1));
           if (%MO_S_Ge_W64(_s43Uj::I64, 0)) goto c44QI; else goto c44QJ;
       c44QI: // global
           (_s43Uq::I64, _s43Ur::I64) = call MO_S_QuotRem W64(_s43Uj::I64, 16);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43Ur::I64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 7;
           R2 = _s43Uq::I64;
           Sp = Sp + 24;
           call $wshowIt2_r43OZ_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c44QJ: // global
           Hp = Hp - 16;
           R2 = _s43Uj::I64;
           Sp = Sp + 24;
           call Numeric.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c44O6() //  [R1]
         { info_tbl: [(c44O6,
                       label: block_c44O6_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44O6: // global
           I64[Sp] = block_c44Ob_info;
           _s43Uw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s43Uw::I64;
           if (R1 & 7 != 0) goto u44R6; else goto c44Oc;
       u44R6: // global
           call _c44Ob(R1) args: 0, res: 0, upd: 0;
       c44Oc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44Ob() //  [R1]
         { info_tbl: [(c44Ob,
                       label: block_c44Ob_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Ob: // global
           I64[Sp] = block_c44Og_info;
           _s43Uy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s43Uy::I64;
           if (R1 & 7 != 0) goto u44R7; else goto c44Oh;
       u44R7: // global
           call _c44Og(R1) args: 0, res: 0, upd: 0;
       c44Oh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44Og() //  [R1]
         { info_tbl: [(c44Og,
                       label: block_c44Og_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Og: // global
           I64[Sp] = block_c44Ol_info;
           _s43UA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _s43UA::I64;
           if (R1 & 7 != 0) goto u44R8; else goto c44Om;
       u44R8: // global
           call _c44Ol(R1) args: 0, res: 0, upd: 0;
       c44Om: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44Ol() //  [R1]
         { info_tbl: [(c44Ol,
                       label: block_c44Ol_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Ol: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c44QR; else goto c44QQ;
       c44QR: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44QQ: // global
           _s43UD::I64 = (I64[Sp + 24] << 3) + ((I64[Sp + 16] << 2) + ((I64[Sp + 32] << 1) + I64[R1 + 7]));
           if (%MO_S_Ge_W64(_s43UD::I64, 0)) goto c44QU; else goto c44QV;
       c44QU: // global
           _s43Uu::P64 = P64[Sp + 8];
           (_s43UL::I64, _s43UM::I64) = call MO_S_QuotRem W64(_s43UD::I64, 16);
           I64[Hp - 32] = sat_s43UO_info;
           P64[Hp - 16] = _s43Uu::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43UM::I64;
           R4 = Hp - 32;
           R3 = Hp - 7;
           R2 = _s43UL::I64;
           Sp = Sp + 40;
           call $wshowIt1_r43OY_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c44QV: // global
           Hp = Hp - 40;
           R2 = _s43UD::I64;
           Sp = Sp + 40;
           call Numeric.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.304025716 UTC

[section ""data" . sat_s43UP_closure" {
     sat_s43UP_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.304900021 UTC

[section ""data" . sat_s43UQ_closure" {
     sat_s43UQ_closure:
         const :_con_info;
         const sat_s43UP_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.306288446 UTC

[section ""data" . Numeric.showHFloat15_closure" {
     Numeric.showHFloat15_closure:
         const Numeric.showHFloat15_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat15_entry() //  [R1]
         { info_tbl: [(c44Rj,
                       label: Numeric.showHFloat15_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Rj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44Rk; else goto c44Rl;
       c44Rk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Rl: // global
           (_c44Rg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44Rg::I64 == 0) goto c44Ri; else goto c44Rh;
       c44Ri: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44Rh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44Rg::I64;
           R3 = sat_s43UQ_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.307937452 UTC

[section ""cstring" . Numeric.showHFloat10_bytes" {
     Numeric.showHFloat10_bytes:
         I8[] [48,120,48,112,43,48]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.30910666 UTC

[section ""data" . Numeric.showHFloat9_closure" {
     Numeric.showHFloat9_closure:
         const Numeric.showHFloat9_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat9_entry() //  [R1]
         { info_tbl: [(c44Rs,
                       label: Numeric.showHFloat9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Rs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44Rt; else goto c44Ru;
       c44Rt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Ru: // global
           (_c44Rp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44Rp::I64 == 0) goto c44Rr; else goto c44Rq;
       c44Rr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44Rq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44Rp::I64;
           R2 = Numeric.showHFloat10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.310840861 UTC

[section ""data" . Numeric.showHFloat14_closure" {
     Numeric.showHFloat14_closure:
         const Numeric.showHFloat14_info;
         const 0;
 },
 Numeric.showHFloat14_entry() //  [R2]
         { info_tbl: [(c44Rz,
                       label: Numeric.showHFloat14_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Rz: // global
           R3 = R2;
           R2 = GHC.Types.[]_closure+1;
           call $wlvl2_r43OX_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.312004181 UTC

[section ""cstring" . Numeric.showHFloat13_bytes" {
     Numeric.showHFloat13_bytes:
         I8[] [48,120]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.312836449 UTC

[section ""cstring" . Numeric.showHFloat12_bytes" {
     Numeric.showHFloat12_bytes:
         I8[] [112]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.313701472 UTC

[section ""cstring" . Numeric.showHFloat11_bytes" {
     Numeric.showHFloat11_bytes:
         I8[] [46]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.318916838 UTC

[section ""data" . Numeric.showHFloat_cvt_closure" {
     Numeric.showHFloat_cvt_closure:
         const Numeric.showHFloat_cvt_info;
         const 0;
 },
 sat_s43UZ_entry() //  [R1]
         { info_tbl: [(c44RU,
                       label: sat_s43UZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44RU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44RV; else goto c44RW;
       c44RV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44RW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c44RS_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44RS() //  [R1]
         { info_tbl: [(c44RS,
                       label: block_c44RS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44RS: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showHFloat16_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43Vm_entry() //  [R1]
         { info_tbl: [(c44SK,
                       label: sat_s43Vm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44SK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c44ST; else goto c44SU;
       c44ST: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44SU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c44SH_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u44SZ; else goto c44SI;
       u44SZ: // global
           call _c44SH(R1) args: 0, res: 0, upd: 0;
       c44SI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c44SH() //  [R1]
         { info_tbl: [(c44SH,
                       label: block_c44SH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44SH: // global
           I64[Sp] = block_c44SQ_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7] - 1;
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44SQ() //  [R1, R2]
         { info_tbl: [(c44SQ,
                       label: block_c44SQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44SQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44SY; else goto c44SX;
       c44SY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c44SX: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 n_s43Vf_entry() //  [R1]
         { info_tbl: [(c44T0,
                       label: n_s43Vf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44T0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44T4; else goto c44T3;
       c44T4: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44T3: // global
           _s43V3::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s43Vm_info;
           P64[Hp] = _s43V3::P64;
           R3 = Hp - 16;
           R2 = Numeric.showHFloat12_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43Vp_entry() //  [R1]
         { info_tbl: [(c44Tf,
                       label: sat_s43Vp_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Tf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44Tg; else goto c44Th;
       c44Tg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Th: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c44Td_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Numeric.showHFloat_hex_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44Td() //  [R1]
         { info_tbl: [(c44Td,
                       label: block_c44Td_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Td: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43Vq_entry() //  [R1]
         { info_tbl: [(c44Tp,
                       label: sat_s43Vq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Tp: // global
           _s43Vq::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c44Tq; else goto c44Tr;
       c44Tr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44Tt; else goto c44Ts;
       c44Tt: // global
           HpAlloc = 24;
           goto c44Tq;
       c44Tq: // global
           R1 = _s43Vq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Ts: // global
           _s43V3::P64 = P64[_s43Vq::P64 + 16];
           _s43V8::P64 = P64[_s43Vq::P64 + 24];
           I64[Hp - 16] = n_s43Vf_info;
           P64[Hp] = _s43V3::P64;
           I64[Sp - 24] = block_c44T5_info;
           R2 = _s43V8::P64;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _s43V8::P64;
           Sp = Sp - 24;
           call Numeric.showHFloat_allZ_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44T5() //  [R1]
         { info_tbl: [(c44T5,
                       label: block_c44T5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44T5: // global
           _c44Sz::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c44Tm; else goto c44Tn;
       c44Tm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44Tw; else goto c44Tv;
       c44Tw: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44Tv: // global
           I64[Hp - 24] = sat_s43Vp_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _c44Sz::P64;
           R3 = Hp - 24;
           R2 = Numeric.showHFloat11_bytes;
           Sp = Sp + 24;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c44Tn: // global
           R1 = _c44Sz::P64;
           Sp = Sp + 24;
           call n_s43Vf_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43Vr_entry() //  [R1]
         { info_tbl: [(c44TA,
                       label: sat_s43Vr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44TA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c44TC; else goto c44TD;
       c44TC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44TD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c44So_info;
           _s43V3::P64 = P64[R1 + 16];
           _s43V8::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s43V3::P64;
           P64[Sp - 24] = _s43V8::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u44TI; else goto c44Sp;
       u44TI: // global
           call _c44So(R1) args: 0, res: 0, upd: 0;
       c44Sp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c44So() //  [R1]
         { info_tbl: [(c44So,
                       label: block_c44So_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44So: // global
           I64[Sp] = block_c44St_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44St() //  [R1, R2]
         { info_tbl: [(c44St,
                       label: block_c44St_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44St: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c44TH; else goto c44TG;
       c44TH: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c44TG: // global
           I64[Hp - 48] = sat_s43Vq_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 48;
           R2 = Hp - 14;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u44Ui_srtd" {
     u44Ui_srtd:
         const S43WU_srt+144;
         const 33;
         const 8388608001;
 },
 Numeric.showHFloat_cvt_entry() //  [R2, R3]
         { info_tbl: [(c44TJ,
                       label: Numeric.showHFloat_cvt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44TJ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c44TK; else goto c44TL;
       c44TK: // global
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showHFloat_cvt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44TL: // global
           I64[Sp - 24] = block_c44RG_info;
           _s43US::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s43US::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Float.$p1RealFloat_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u44Uj_srtd" {
     u44Uj_srtd:
         const S43WU_srt+144;
         const 33;
         const 7851737089;
 },
 _c44RG() //  [R1]
         { info_tbl: [(c44RG,
                       label: block_c44RG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44RG: // global
           I64[Sp] = block_c44RK_info;
           R2 = R1;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u44Uk_srtd" {
     u44Uk_srtd:
         const S43WU_srt+144;
         const 33;
         const 7851737089;
 },
 _c44RK() //  [R1]
         { info_tbl: [(c44RK,
                       label: block_c44RK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44RK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44TP; else goto c44TO;
       c44TP: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44TO: // global
           I64[Hp - 16] = sat_s43UZ_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c44S0_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44S0() //  [R1]
         { info_tbl: [(c44S0,
                       label: block_c44S0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44S0: // global
           I64[Sp] = block_c44S4_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c44S4() //  [R1]
         { info_tbl: [(c44S4,
                       label: block_c44S4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44S4: // global
           _c44RO::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c44S8_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp] = _c44RO::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c44S8() //  [R1]
         { info_tbl: [(c44S8,
                       label: block_c44S8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44S8: // global
           if (R1 & 7 == 1) goto c44TU; else goto c44Ud;
       c44TU: // global
           _s43UT::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c44Sc_info;
           R4 = _s43UT::P64;
           R3 = Numeric.showHFloat15_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Float.$wfloatToDigits_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
       c44Ud: // global
           R1 = Numeric.showHFloat9_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c44Sc() //  [R1, R2]
         { info_tbl: [(c44Sc,
                       label: block_c44Sc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Sc: // global
           I64[Sp - 8] = block_c44Se_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u44Ug; else goto c44Sf;
       u44Ug: // global
           call _c44Se(R1) args: 0, res: 0, upd: 0;
       c44Sf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c44Se() //  [R1]
         { info_tbl: [(c44Se,
                       label: block_c44Se_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Se: // global
           _s43V3::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c44U0; else goto c44U6;
       c44U0: // global
           I64[Sp + 8] = block_c44TX_info;
           R1 = _s43V3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u44Uh; else goto c44U1;
       u44Uh: // global
           call _c44TX(R1) args: 0, res: 0, upd: 0;
       c44U1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c44U6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c44U9; else goto c44U8;
       c44U9: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c44U8: // global
           _s43V7::P64 = P64[R1 + 6];
           _s43V8::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_s43Vr_info;
           P64[Hp - 16] = _s43V3::P64;
           P64[Hp - 8] = _s43V7::P64;
           P64[Hp] = _s43V8::P64;
           R3 = Hp - 32;
           R2 = Numeric.showHFloat13_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _c44TX() //  [R1]
         { info_tbl: [(c44TX,
                       label: block_c44TX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44TX: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call Numeric.showHFloat14_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.329604595 UTC

[section ""data" . Numeric.showHFloat8_closure" {
     Numeric.showHFloat8_closure:
         const GHC.Types.C#_con_info;
         const 45;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.330559651 UTC

[section ""cstring" . Numeric.showHFloat5_bytes" {
     Numeric.showHFloat5_bytes:
         I8[] [73,110,102,105,110,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.331420772 UTC

[section ""cstring" . Numeric.showHFloat7_bytes" {
     Numeric.showHFloat7_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.335431869 UTC

[section ""data" . Numeric.showHFloat6_closure" {
     Numeric.showHFloat6_closure:
         const Numeric.showHFloat6_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat6_entry() //  [R1]
         { info_tbl: [(c44Ur,
                       label: Numeric.showHFloat6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Ur: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44Us; else goto c44Ut;
       c44Us: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Ut: // global
           (_c44Uo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44Uo::I64 == 0) goto c44Uq; else goto c44Up;
       c44Uq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44Up: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44Uo::I64;
           R2 = Numeric.showHFloat7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.337022316 UTC

[section ""cstring" . Numeric.showHFloat2_bytes" {
     Numeric.showHFloat2_bytes:
         I8[] [78,97,78]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.338560553 UTC

[section ""data" . Numeric.showHFloat1_closure" {
     Numeric.showHFloat1_closure:
         const Numeric.showHFloat1_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat1_entry() //  [R1]
         { info_tbl: [(c44UA,
                       label: Numeric.showHFloat1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44UA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44UB; else goto c44UC;
       c44UB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44UC: // global
           (_c44Ux::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44Ux::I64 == 0) goto c44Uz; else goto c44Uy;
       c44Uz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44Uy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44Ux::I64;
           R2 = Numeric.showHFloat2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.340338363 UTC

[section ""data" . Numeric.showHFloat4_closure" {
     Numeric.showHFloat4_closure:
         const Numeric.showHFloat4_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat4_entry() //  [R1]
         { info_tbl: [(c44UJ,
                       label: Numeric.showHFloat4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44UJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44UK; else goto c44UL;
       c44UK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44UL: // global
           (_c44UG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44UG::I64 == 0) goto c44UI; else goto c44UH;
       c44UI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44UH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44UG::I64;
           R2 = Numeric.showHFloat5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.342118883 UTC

[section ""data" . Numeric.showHFloat3_closure" {
     Numeric.showHFloat3_closure:
         const Numeric.showHFloat3_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat3_entry() //  [R1]
         { info_tbl: [(c44US,
                       label: Numeric.showHFloat3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44US: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44UT; else goto c44UU;
       c44UT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44UU: // global
           (_c44UP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44UP::I64 == 0) goto c44UR; else goto c44UQ;
       c44UR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44UQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44UP::I64;
           R3 = Numeric.showHFloat4_closure;
           R2 = Numeric.showHFloat6_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.347317159 UTC

[section ""data" . Numeric.showHFloat_closure" {
     Numeric.showHFloat_closure:
         const Numeric.showHFloat_info;
         const 0;
 },
 $dNum_s43Vx_entry() //  [R1]
         { info_tbl: [(c44Vj,
                       label: $dNum_s43Vx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Vj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44Vk; else goto c44Vl;
       c44Vk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Vl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43VA_entry() //  [R1]
         { info_tbl: [(c44Vu,
                       label: sat_s43VA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Vu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44Vv; else goto c44Vw;
       c44Vv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Vw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showHFloat16_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43VD_entry() //  [R1]
         { info_tbl: [(c44VS,
                       label: sat_s43VD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44VS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44VT; else goto c44VU;
       c44VT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44VU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43VE_entry() //  [R1]
         { info_tbl: [(c44VV,
                       label: sat_s43VE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44VV: // global
           _s43VE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c44VW; else goto c44VX;
       c44VX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44VZ; else goto c44VY;
       c44VZ: // global
           HpAlloc = 32;
           goto c44VW;
       c44VW: // global
           R1 = _s43VE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44VY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43VE::P64;
           _s43Vs::P64 = P64[_s43VE::P64 + 16];
           _s43Vt::P64 = P64[_s43VE::P64 + 24];
           _s43Vx::P64 = P64[_s43VE::P64 + 32];
           I64[Hp - 24] = sat_s43VD_info;
           P64[Hp - 8] = _s43Vt::P64;
           P64[Hp] = _s43Vx::P64;
           R3 = Hp - 24;
           R2 = _s43Vs::P64;
           Sp = Sp - 16;
           call Numeric.showHFloat_cvt_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43VF_entry() //  [R1]
         { info_tbl: [(c44Wa,
                       label: sat_s43VF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Wa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44Wb; else goto c44Wc;
       c44Wb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Wc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43VG_entry() //  [R1]
         { info_tbl: [(c44Wd,
                       label: sat_s43VG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Wd: // global
           _s43VG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c44We; else goto c44Wf;
       c44Wf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44Wh; else goto c44Wg;
       c44Wh: // global
           HpAlloc = 32;
           goto c44We;
       c44We: // global
           R1 = _s43VG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Wg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43VG::P64;
           _s43Vs::P64 = P64[_s43VG::P64 + 16];
           _s43Vt::P64 = P64[_s43VG::P64 + 24];
           _s43Vx::P64 = P64[_s43VG::P64 + 32];
           I64[Hp - 24] = sat_s43VF_info;
           P64[Hp - 8] = _s43Vt::P64;
           P64[Hp] = _s43Vx::P64;
           R3 = Hp - 24;
           R2 = _s43Vs::P64;
           Sp = Sp - 16;
           call Numeric.showHFloat_cvt_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43VI_entry() //  [R1]
         { info_tbl: [(c44Wo,
                       label: sat_s43VI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Wo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44Wp; else goto c44Wq;
       c44Wp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Wq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showHFloat16_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43VK_entry() //  [R1]
         { info_tbl: [(c44Wv,
                       label: sat_s43VK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Wv: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c44Ww; else goto c44Wx;
       c44Ww: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Wx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c44V3_info;
           _s43Vs::P64 = P64[R1 + 16];
           R2 = _s43Vs::P64;
           I64[Sp - 56] = stg_ap_p_info;
           _s43Vt::P64 = P64[R1 + 24];
           P64[Sp - 48] = _s43Vt::P64;
           P64[Sp - 32] = _s43Vs::P64;
           P64[Sp - 24] = _s43Vt::P64;
           Sp = Sp - 56;
           call GHC.Float.isNaN_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c44V3() //  [R1]
         { info_tbl: [(c44V3,
                       label: block_c44V3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44V3: // global
           if (R1 & 7 == 1) goto c44Ws; else goto c44Wt;
       c44Ws: // global
           I64[Sp] = block_c44V7_info;
           R2 = P64[Sp + 8];
           call GHC.Float.$p1RealFloat_entry(R2) args: 8, res: 8, upd: 24;
       c44Wt: // global
           R1 = Numeric.showHFloat1_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c44V7() //  [R1]
         { info_tbl: [(c44V7,
                       label: block_c44V7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44V7: // global
           I64[Sp] = block_c44Vb_info;
           R2 = R1;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44Vb() //  [R1]
         { info_tbl: [(c44Vb,
                       label: block_c44Vb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Vb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44WC; else goto c44WB;
       c44WC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c44WB: // global
           I64[Hp - 16] = $dNum_s43Vx_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c44Vm_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Float.isInfinite_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c44Vm() //  [R1]
         { info_tbl: [(c44Vm,
                       label: block_c44Vm_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Vm: // global
           _c44Vf::P64 = P64[Sp + 16];
           _s43Vw::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c44WE; else goto c44X1;
       c44WE: // global
           Hp = Hp + 24;
           _s43Vy::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c44X4; else goto c44WG;
       c44WG: // global
           I64[Hp - 16] = sat_s43VA_info;
           P64[Hp] = _c44Vf::P64;
           I64[Sp] = block_c44Vx_info;
           R2 = _s43Vw::P64;
           P64[Sp + 8] = Hp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 24;
       c44X1: // global
           Hp = Hp + 24;
           _s43Vy::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c44X4; else goto c44X3;
       c44X4: // global
           HpAlloc = 24;
           R1 = _s43Vy::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c44X3: // global
           I64[Hp - 16] = sat_s43VI_info;
           P64[Hp] = _c44Vf::P64;
           I64[Sp + 16] = block_c44X0_info;
           R2 = _s43Vw::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44Vx() //  [R1]
         { info_tbl: [(c44Vx,
                       label: block_c44Vx_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Vx: // global
           _c44Vq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c44VB_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = _c44Vq::P64;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c44VB() //  [R1]
         { info_tbl: [(c44VB,
                       label: block_c44VB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44VB: // global
           _s43Vs::P64 = P64[Sp + 16];
           _s43Vt::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c44WL; else goto c44WW;
       c44WL: // global
           I64[Sp] = block_c44VF_info;
           R2 = _s43Vs::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s43Vt::P64;
           Sp = Sp - 16;
           call GHC.Float.isNegativeZero_entry(R2) args: 24, res: 8, upd: 24;
       c44WW: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c44WZ; else goto c44WY;
       c44WZ: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c44WY: // global
           I64[Hp - 56] = sat_s43VG_info;
           P64[Hp - 40] = _s43Vs::P64;
           P64[Hp - 32] = _s43Vt::P64;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Numeric.showHFloat8_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c44VF() //  [R1]
         { info_tbl: [(c44VF,
                       label: block_c44VF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44VF: // global
           _s43Vs::P64 = P64[Sp + 16];
           _s43Vt::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c44WP; else goto c44WR;
       c44WP: // global
           R3 = _s43Vt::P64;
           R2 = _s43Vs::P64;
           Sp = Sp + 32;
           call Numeric.showHFloat_cvt_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
       c44WR: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c44WU; else goto c44WT;
       c44WU: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c44WT: // global
           I64[Hp - 56] = sat_s43VE_info;
           P64[Hp - 40] = _s43Vs::P64;
           P64[Hp - 32] = _s43Vt::P64;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Numeric.showHFloat8_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c44X0() //  [R1]
         { info_tbl: [(c44X0,
                       label: block_c44X0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44X0: // global
           _s43Vt::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c44X8_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s43Vt::P64;
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c44X8() //  [R1]
         { info_tbl: [(c44X8,
                       label: block_c44X8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44X8: // global
           if (R1 & 7 == 1) goto c44Xf; else goto c44Xj;
       c44Xf: // global
           R1 = Numeric.showHFloat4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c44Xj: // global
           R1 = Numeric.showHFloat3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showHFloat_entry() //  [R2, R3]
         { info_tbl: [(c44Xr,
                       label: Numeric.showHFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Xr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44Xv; else goto c44Xu;
       c44Xv: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showHFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44Xu: // global
           I64[Hp - 24] = sat_s43VK_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.357164572 UTC

[section ""data" . sat_s43VL_closure" {
     sat_s43VL_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.358079089 UTC

[section ""data" . sat_s43VM_closure" {
     sat_s43VM_closure:
         const :_con_info;
         const sat_s43VL_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.359331751 UTC

[section ""data" . Numeric.showOct1_closure" {
     Numeric.showOct1_closure:
         const Numeric.showOct1_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showOct1_entry() //  [R1]
         { info_tbl: [(c44XC,
                       label: Numeric.showOct1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44XC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44XD; else goto c44XE;
       c44XD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44XE: // global
           (_c44Xz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c44Xz::I64 == 0) goto c44XB; else goto c44XA;
       c44XB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c44XA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c44Xz::I64;
           R3 = sat_s43VM_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.361667039 UTC

[section ""data" . Numeric.showOct_closure" {
     Numeric.showOct_closure:
         const Numeric.showOct_info;
         const 0;
 },
 sat_s43VR_entry() //  [R1]
         { info_tbl: [(c44XP,
                       label: sat_s43VR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44XP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44XT; else goto c44XU;
       c44XT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44XU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c44XN_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44XN() //  [R1]
         { info_tbl: [(c44XN,
                       label: block_c44XN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44XN: // global
           I64[Sp] = block_c44XS_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c44XS() //  [R1]
         { info_tbl: [(c44XS,
                       label: block_c44XS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44XS: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showOct1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Numeric.showOct_entry() //  [R2, R3]
         { info_tbl: [(c44Y0,
                       label: Numeric.showOct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Y0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c44Y4; else goto c44Y3;
       c44Y4: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showOct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44Y3: // global
           I64[Hp - 16] = sat_s43VR_info;
           P64[Hp] = R2;
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showIntAtBase_closure+6;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.363811325 UTC

[section ""data" . Numeric.$trModule3_closure" {
     Numeric.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Numeric.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.364590117 UTC

[section ""data" . Numeric.$trModule1_closure" {
     Numeric.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Numeric.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.365444652 UTC

[section ""data" . Numeric.$trModule_closure" {
     Numeric.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Numeric.$trModule3_closure+1;
         const Numeric.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.36717238 UTC

[section ""data" . Numeric.showGFloat_$sshowGFloat_closure" {
     Numeric.showGFloat_$sshowGFloat_closure:
         const Numeric.showGFloat_$sshowGFloat_info;
         const 0;
 },
 sat_s43VW_entry() //  [R1]
         { info_tbl: [(c44Yg,
                       label: sat_s43VW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Yg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44Yh; else goto c44Yi;
       c44Yh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Yi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c44Yd_info;
           _s43VS::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s43VS::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u44Ym; else goto c44Ye;
       u44Ym: // global
           call _c44Yd(R1) args: 0, res: 0, upd: 0;
       c44Ye: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c44Yd() //  [R1]
         { info_tbl: [(c44Yd,
                       label: block_c44Yd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Yd: // global
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showGFloat_$sshowGFloat_entry() //  [R2, R3]
         { info_tbl: [(c44Yn,
                       label: Numeric.showGFloat_$sshowGFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Yn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44Yr; else goto c44Yq;
       c44Yr: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showGFloat_$sshowGFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44Yq: // global
           I64[Hp - 24] = sat_s43VW_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.370101022 UTC

[section ""data" . Numeric.showFFloat_$sshowFFloat_closure" {
     Numeric.showFFloat_$sshowFFloat_closure:
         const Numeric.showFFloat_$sshowFFloat_info;
         const 0;
 },
 sat_s43W1_entry() //  [R1]
         { info_tbl: [(c44YD,
                       label: sat_s43W1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44YD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44YE; else goto c44YF;
       c44YE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44YF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c44YA_info;
           _s43VX::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s43VX::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u44YJ; else goto c44YB;
       u44YJ: // global
           call _c44YA(R1) args: 0, res: 0, upd: 0;
       c44YB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c44YA() //  [R1]
         { info_tbl: [(c44YA,
                       label: block_c44YA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44YA: // global
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showFFloat_$sshowFFloat_entry() //  [R2, R3]
         { info_tbl: [(c44YK,
                       label: Numeric.showFFloat_$sshowFFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44YK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44YO; else goto c44YN;
       c44YO: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showFFloat_$sshowFFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44YN: // global
           I64[Hp - 24] = sat_s43W1_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.372931121 UTC

[section ""data" . Numeric.showEFloat_$sshowEFloat_closure" {
     Numeric.showEFloat_$sshowEFloat_closure:
         const Numeric.showEFloat_$sshowEFloat_info;
         const 0;
 },
 sat_s43W6_entry() //  [R1]
         { info_tbl: [(c44Z0,
                       label: sat_s43W6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Z0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44Z1; else goto c44Z2;
       c44Z1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Z2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c44YX_info;
           _s43W2::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s43W2::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u44Z6; else goto c44YY;
       u44Z6: // global
           call _c44YX(R1) args: 0, res: 0, upd: 0;
       c44YY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c44YX() //  [R1]
         { info_tbl: [(c44YX,
                       label: block_c44YX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44YX: // global
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFExponent_closure+1;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showEFloat_$sshowEFloat_entry() //  [R2, R3]
         { info_tbl: [(c44Z7,
                       label: Numeric.showEFloat_$sshowEFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Z7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44Zb; else goto c44Za;
       c44Zb: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showEFloat_$sshowEFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44Za: // global
           I64[Hp - 24] = sat_s43W6_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.375255108 UTC

[section ""data" . Numeric.showGFloat_$sshowGFloat1_closure" {
     Numeric.showGFloat_$sshowGFloat1_closure:
         const Numeric.showGFloat_$sshowGFloat1_info;
         const 0;
 },
 sat_s43Wb_entry() //  [R1]
         { info_tbl: [(c44Zn,
                       label: sat_s43Wb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Zn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c44Zo; else goto c44Zp;
       c44Zo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44Zp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c44Zk_info;
           _s43W7::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s43W7::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u44Zt; else goto c44Zl;
       u44Zt: // global
           call _c44Zk(R1) args: 0, res: 0, upd: 0;
       c44Zl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c44Zk() //  [R1]
         { info_tbl: [(c44Zk,
                       label: block_c44Zk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Zk: // global
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showGFloat_$sshowGFloat1_entry() //  [R2, R3]
         { info_tbl: [(c44Zu,
                       label: Numeric.showGFloat_$sshowGFloat1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44Zu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c44Zy; else goto c44Zx;
       c44Zy: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showGFloat_$sshowGFloat1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c44Zx: // global
           I64[Hp - 24] = sat_s43Wb_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.3770366 UTC

[section ""data" . Numeric.showGFloat_closure" {
     Numeric.showGFloat_closure:
         const Numeric.showGFloat_info;
         const 0;
 },
 sat_s43Wf_entry() //  [R1]
         { info_tbl: [(c44ZH,
                       label: sat_s43Wf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44ZH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c44ZI; else goto c44ZJ;
       c44ZI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c44ZJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.False_closure+1;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFGeneric_closure+3;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showGFloat_entry() //  [R2, R3, R4]
         { info_tbl: [(c44ZK,
                       label: Numeric.showGFloat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44ZK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c44ZO; else goto c44ZN;
       c44ZO: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showGFloat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c44ZN: // global
           I64[Hp - 32] = sat_s43Wf_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.378847771 UTC

[section ""data" . Numeric.showFFloat_$sshowFFloat1_closure" {
     Numeric.showFFloat_$sshowFFloat1_closure:
         const Numeric.showFFloat_$sshowFFloat1_info;
         const 0;
 },
 sat_s43Wk_entry() //  [R1]
         { info_tbl: [(c4500,
                       label: sat_s43Wk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4500: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4501; else goto c4502;
       c4501: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4502: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c44ZX_info;
           _s43Wg::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s43Wg::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4506; else goto c44ZY;
       u4506: // global
           call _c44ZX(R1) args: 0, res: 0, upd: 0;
       c44ZY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c44ZX() //  [R1]
         { info_tbl: [(c44ZX,
                       label: block_c44ZX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c44ZX: // global
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showFFloat_$sshowFFloat1_entry() //  [R2, R3]
         { info_tbl: [(c4507,
                       label: Numeric.showFFloat_$sshowFFloat1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4507: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c450b; else goto c450a;
       c450b: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showFFloat_$sshowFFloat1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c450a: // global
           I64[Hp - 24] = sat_s43Wk_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.380700115 UTC

[section ""data" . Numeric.showFFloat_closure" {
     Numeric.showFFloat_closure:
         const Numeric.showFFloat_info;
         const 0;
 },
 sat_s43Wo_entry() //  [R1]
         { info_tbl: [(c450k,
                       label: sat_s43Wo_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c450k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c450l; else goto c450m;
       c450l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c450m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.False_closure+1;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFFixed_closure+2;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showFFloat_entry() //  [R2, R3, R4]
         { info_tbl: [(c450n,
                       label: Numeric.showFFloat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c450n: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c450r; else goto c450q;
       c450r: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showFFloat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c450q: // global
           I64[Hp - 32] = sat_s43Wo_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.38249988 UTC

[section ""data" . Numeric.showEFloat_$sshowEFloat1_closure" {
     Numeric.showEFloat_$sshowEFloat1_closure:
         const Numeric.showEFloat_$sshowEFloat1_info;
         const 0;
 },
 sat_s43Wt_entry() //  [R1]
         { info_tbl: [(c450D,
                       label: sat_s43Wt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c450D: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c450E; else goto c450F;
       c450E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c450F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c450A_info;
           _s43Wp::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s43Wp::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u450J; else goto c450B;
       u450J: // global
           call _c450A(R1) args: 0, res: 0, upd: 0;
       c450B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c450A() //  [R1]
         { info_tbl: [(c450A,
                       label: block_c450A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c450A: // global
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFExponent_closure+1;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showEFloat_$sshowEFloat1_entry() //  [R2, R3]
         { info_tbl: [(c450K,
                       label: Numeric.showEFloat_$sshowEFloat1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c450K: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c450O; else goto c450N;
       c450O: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showEFloat_$sshowEFloat1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c450N: // global
           I64[Hp - 24] = sat_s43Wt_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.384293002 UTC

[section ""data" . Numeric.showEFloat_closure" {
     Numeric.showEFloat_closure:
         const Numeric.showEFloat_info;
         const 0;
 },
 sat_s43Wx_entry() //  [R1]
         { info_tbl: [(c450X,
                       label: sat_s43Wx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c450X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c450Y; else goto c450Z;
       c450Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c450Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.False_closure+1;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFExponent_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showEFloat_entry() //  [R2, R3, R4]
         { info_tbl: [(c4510,
                       label: Numeric.showEFloat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4510: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4514; else goto c4513;
       c4514: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showEFloat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4513: // global
           I64[Hp - 32] = sat_s43Wx_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.385581526 UTC

[section ""relreadonly" . S43WU_srt" {
     S43WU_srt:
         const Text.Read.Lex.$wreadIntP_closure;
         const Numeric.readInt_closure;
         const Text.Read.Lex.readDecP4_closure;
         const Text.Read.Lex.$wreadIntP'_closure;
         const Numeric.readOct_closure;
         const Text.Read.Lex.numberToFixed1_closure;
         const Numeric.readDec_closure;
         const Text.Read.Lex.readDecP3_closure;
         const Numeric.readHex_closure;
         const Text.Read.Lex.$wnumberToRational_closure;
         const Text.Read.Lex.expect2_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const Numeric.readFloat_closure;
         const GHC.Read.lex1_closure;
         const GHC.Read.readParen_closure;
         const Numeric.readSigned_closure;
         const sat_s43QP_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Numeric.showHFloat16_closure;
         const Numeric.showInt2_closure;
         const Numeric.showInt_closure;
         const Numeric.showInt1_closure;
         const GHC.Float.formatRealFloatAlt_closure;
         const Numeric.showFFloatAlt_closure;
         const Numeric.showGFloatAlt_closure;
         const Numeric.$wlvl_closure;
         const Numeric.showIntAtBase2_closure;
         const Numeric.showIntAtBase1_closure;
         const sat_s43RQ_closure;
         const Numeric.showIntAtBase3_closure;
         const Numeric.showIntAtBase_closure;
         const sat_s43So_closure;
         const Numeric.showHex1_closure;
         const GHC.Show.intToDigit_closure;
         const Numeric.showHex_closure;
         const GHC.Show.$fShow(,)_go1_closure;
         const GHC.Err.error_closure;
         const $dIP3_r43OU_closure;
         const $wlvl2_r43OX_closure;
         const GHC.Show.$wintToDigit_closure;
         const $wshowIt1_r43OY_closure;
         const $wshowIt2_r43OZ_closure;
         const $wshowIt3_r43P0_closure;
         const $wshowIt4_r43P1_closure;
         const Numeric.showHFloat_hex_closure;
         const sat_s43UQ_closure;
         const GHC.Float.$wfloatToDigits_closure;
         const Numeric.showHFloat_cvt_closure;
         const Numeric.showHFloat9_closure;
         const Numeric.showHFloat14_closure;
         const Numeric.showHFloat15_closure;
         const Numeric.showHFloat4_closure;
         const Numeric.showHFloat6_closure;
         const Numeric.showHFloat16_closure;
         const Numeric.showHFloat1_closure;
         const Numeric.showHFloat3_closure;
         const Numeric.showHFloat_closure;
         const sat_s43VM_closure;
         const Numeric.showOct1_closure;
         const Numeric.showOct_closure;
         const GHC.Float.$w$sformatRealFloatAlt1_closure;
         const Numeric.showGFloat_$sshowGFloat_closure;
         const Numeric.showFFloat_$sshowFFloat_closure;
         const Numeric.showEFloat_$sshowEFloat_closure;
         const GHC.Float.$w$sformatRealFloatAlt_closure;
         const Numeric.showGFloat_$sshowGFloat1_closure;
         const GHC.Float.formatRealFloatAlt_closure;
         const Numeric.showGFloat_closure;
         const Numeric.showFFloat_$sshowFFloat1_closure;
         const Numeric.showFFloat_closure;
         const Numeric.showEFloat_$sshowEFloat1_closure;
         const Numeric.showEFloat_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.386835641 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:58:56.388596312 UTC

[section ""data" . Numeric.readInt_closure" {
     Numeric.readInt_closure:
         const Numeric.readInt_info;
         const 0;
 },
 sat_s43P9_entry() //  [R1]
         { info_tbl: [(c451g,
                       label: sat_s43P9_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c451g: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c451h; else goto c451i;
       c451h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c451i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c451d_info;
           R6 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Text.Read.Lex.$wreadIntP_entry(R6,
                                               R5,
                                               R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c451d() //  [R1]
         { info_tbl: [(c451d,
                       label: block_c451d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c451d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c451l; else goto c451k;
       c451l: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c451k: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.readInt_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c451m,
                       label: Numeric.readInt_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c451m: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c451q; else goto c451p;
       c451q: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readInt_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c451p: // global
           I64[Hp - 40] = sat_s43P9_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 40;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.400326098 UTC

[section ""data" . Numeric.readOct_closure" {
     Numeric.readOct_closure:
         const Numeric.readOct_info;
         const 0;
 },
 sat_s43Pc_entry() //  [R1]
         { info_tbl: [(c451P,
                       label: sat_s43Pc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c451P: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c451Q; else goto c451R;
       c451Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c451R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.Read.Lex.readDecP4_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43Pf_entry() //  [R1]
         { info_tbl: [(c451V,
                       label: sat_s43Pf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c451V: // global
           _s43Pf::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c451W; else goto c451X;
       c451X: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c451Z; else goto c451Y;
       c451Z: // global
           HpAlloc = 24;
           goto c451W;
       c451W: // global
           R1 = _s43Pf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c451Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43Pf::P64;
           _s43Pa::P64 = P64[_s43Pf::P64 + 16];
           _s43Pb::P64 = P64[_s43Pf::P64 + 24];
           I64[Hp - 16] = sat_s43Pc_info;
           P64[Hp] = _s43Pb::P64;
           I64[Sp - 24] = block_c451S_info;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = Hp - 16;
           R3 = _s43Pb::P64;
           R2 = _s43Pa::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wreadIntP'_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _c451S() //  [R1]
         { info_tbl: [(c451S,
                       label: block_c451S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c451S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4522; else goto c4521;
       c4522: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4521: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.readOct_entry() //  [R2, R3]
         { info_tbl: [(c4523,
                       label: Numeric.readOct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4523: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4527; else goto c4526;
       c4527: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readOct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4526: // global
           I64[Hp - 24] = sat_s43Pf_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.410958243 UTC

[section ""data" . Numeric.readDec_closure" {
     Numeric.readDec_closure:
         const Numeric.readDec_info;
         const 0;
 },
 sat_s43Pi_entry() //  [R1]
         { info_tbl: [(c452A,
                       label: sat_s43Pi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c452A: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c452B; else goto c452C;
       c452B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c452C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.Read.Lex.numberToFixed1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43Pl_entry() //  [R1]
         { info_tbl: [(c452G,
                       label: sat_s43Pl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c452G: // global
           _s43Pl::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c452H; else goto c452I;
       c452I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c452K; else goto c452J;
       c452K: // global
           HpAlloc = 24;
           goto c452H;
       c452H: // global
           R1 = _s43Pl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c452J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43Pl::P64;
           _s43Pg::P64 = P64[_s43Pl::P64 + 16];
           _s43Ph::P64 = P64[_s43Pl::P64 + 24];
           I64[Hp - 16] = sat_s43Pi_info;
           P64[Hp] = _s43Ph::P64;
           I64[Sp - 24] = block_c452D_info;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = Hp - 16;
           R3 = _s43Ph::P64;
           R2 = _s43Pg::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wreadIntP'_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _c452D() //  [R1]
         { info_tbl: [(c452D,
                       label: block_c452D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c452D: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c452N; else goto c452M;
       c452N: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c452M: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.readDec_entry() //  [R2, R3]
         { info_tbl: [(c452O,
                       label: Numeric.readDec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c452O: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c452S; else goto c452R;
       c452S: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readDec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c452R: // global
           I64[Hp - 24] = sat_s43Pl_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.422822009 UTC

[section ""data" . Numeric.readHex_closure" {
     Numeric.readHex_closure:
         const Numeric.readHex_info;
         const 0;
 },
 sat_s43Po_entry() //  [R1]
         { info_tbl: [(c453l,
                       label: sat_s43Po_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c453l: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c453m; else goto c453n;
       c453m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c453n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.Read.Lex.readDecP3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43Pr_entry() //  [R1]
         { info_tbl: [(c453r,
                       label: sat_s43Pr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c453r: // global
           _s43Pr::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c453s; else goto c453t;
       c453t: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c453v; else goto c453u;
       c453v: // global
           HpAlloc = 24;
           goto c453s;
       c453s: // global
           R1 = _s43Pr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c453u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43Pr::P64;
           _s43Pm::P64 = P64[_s43Pr::P64 + 16];
           _s43Pn::P64 = P64[_s43Pr::P64 + 24];
           I64[Hp - 16] = sat_s43Po_info;
           P64[Hp] = _s43Pn::P64;
           I64[Sp - 24] = block_c453o_info;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = Hp - 16;
           R3 = _s43Pn::P64;
           R2 = _s43Pm::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wreadIntP'_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _c453o() //  [R1]
         { info_tbl: [(c453o,
                       label: block_c453o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c453o: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c453y; else goto c453x;
       c453y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c453x: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.readHex_entry() //  [R2, R3]
         { info_tbl: [(c453z,
                       label: Numeric.readHex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c453z: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c453D; else goto c453C;
       c453D: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readHex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c453C: // global
           I64[Hp - 24] = sat_s43Pr_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.434963536 UTC

[section ""data" . Numeric.readFloat2_closure" {
     Numeric.readFloat2_closure:
         const Numeric.readFloat2_info;
 },
 Numeric.readFloat2_entry() //  [R2]
         { info_tbl: [(c4541,
                       label: Numeric.readFloat2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4541: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4542; else goto c4543;
       c4542: // global
           R2 = R2;
           R1 = Numeric.readFloat2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4543: // global
           I64[Sp - 8] = block_c453Y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4547; else goto c453Z;
       u4547: // global
           call _c453Y() args: 0, res: 0, upd: 0;
       c453Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c453Y() //  []
         { info_tbl: [(c453Y,
                       label: block_c453Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c453Y: // global
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.440631709 UTC

[section ""data" . Numeric.readFloat1_closure" {
     Numeric.readFloat1_closure:
         const Text.ParserCombinators.ReadP.Look_con_info;
         const Numeric.readFloat2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.445359528 UTC

[section ""data" . Numeric.readFloat_closure" {
     Numeric.readFloat_closure:
         const Numeric.readFloat_info;
         const 0;
 },
 $dFractional_s43Pw_entry() //  [R1]
         { info_tbl: [(c454z,
                       label: $dFractional_s43Pw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c454z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c454A; else goto c454B;
       c454A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c454B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43PD_entry() //  [R1]
         { info_tbl: [(c454Y,
                       label: sat_s43PD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c454Y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c454Z; else goto c4550;
       c454Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4550: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c454V_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Text.Read.Lex.$wnumberToRational_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c454V() //  [R1, R2]
         { info_tbl: [(c454V,
                       label: block_c454V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c454V: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4553; else goto c4552;
       c4553: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4552: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43PE_entry() //  [R1]
         { info_tbl: [(c4554,
                       label: sat_s43PE_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4554: // global
           _s43PE::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c4555; else goto c4556;
       c4556: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4558; else goto c4557;
       c4558: // global
           HpAlloc = 24;
           goto c4555;
       c4555: // global
           R1 = _s43PE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4557: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43PE::P64;
           _s43Pw::P64 = P64[_s43PE::P64 + 16];
           _s43Pz::P64 = P64[_s43PE::P64 + 24];
           I64[Hp - 16] = sat_s43PD_info;
           P64[Hp] = _s43Pz::P64;
           R2 = _s43Pw::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Real.fromRational_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43PF_entry() //  [R1, R2]
         { info_tbl: [(c455d,
                       label: sat_s43PF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c455d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c455e; else goto c455f;
       c455e: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c455f: // global
           I64[Sp - 16] = block_c454H_info;
           _s43Pw::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s43Pw::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u455m; else goto c454I;
       u455m: // global
           call _c454H(R1) args: 0, res: 0, upd: 0;
       c454I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c454H() //  [R1]
         { info_tbl: [(c454H,
                       label: block_c454H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c454H: // global
           if (R1 & 7 == 6) goto c455b; else goto c455a;
       c455b: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c455l; else goto c455k;
       c455l: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c455k: // global
           _s43Pz::P64 = P64[R1 + 2];
           I64[Hp - 48] = sat_s43PE_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s43Pz::P64;
           I64[Hp - 16] = Text.ParserCombinators.ReadP.Result_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Text.ParserCombinators.ReadP.Fail_closure+3;
           R1 = Hp - 12;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c455a: // global
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43PG_entry() //  [R1]
         { info_tbl: [(c455n,
                       label: sat_s43PG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c455n: // global
           _s43PG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c455o; else goto c455p;
       c455p: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c455r; else goto c455q;
       c455r: // global
           HpAlloc = 40;
           goto c455o;
       c455o: // global
           R1 = _s43PG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c455q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43PG::P64;
           _s43Pu::P64 = P64[_s43PG::P64 + 16];
           I64[Hp - 32] = $dFractional_s43Pw_info;
           P64[Hp - 16] = _s43Pu::P64;
           I64[Hp - 8] = sat_s43PF_info;
           P64[Hp] = Hp - 32;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Text.Read.Lex.expect2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl116_s43Pv_entry() //  [R1]
         { info_tbl: [(c455s,
                       label: lvl116_s43Pv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c455s: // global
           _s43Pv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c455t; else goto c455u;
       c455u: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c455w; else goto c455v;
       c455w: // global
           HpAlloc = 24;
           goto c455t;
       c455t: // global
           R1 = _s43Pv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c455v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43Pv::P64;
           _s43Pu::P64 = P64[_s43Pv::P64 + 16];
           I64[Hp - 16] = sat_s43PG_info;
           P64[Hp] = _s43Pu::P64;
           R3 = Hp - 16;
           R2 = Numeric.readFloat1_closure+2;
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 k_s43PH_entry() //  [R1]
         { info_tbl: [(c455C,
                       label: k_s43PH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c455C: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43PK_entry() //  [R1, R2]
         { info_tbl: [(c455K,
                       label: sat_s43PK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c455K: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           call Text.ParserCombinators.ReadP.skipSpaces2_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 Numeric.readFloat_entry() //  [R2]
         { info_tbl: [(c455O,
                       label: Numeric.readFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c455O: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c455S; else goto c455R;
       c455S: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Numeric.readFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c455R: // global
           I64[Hp - 64] = lvl116_s43Pv_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = k_s43PH_info;
           P64[Hp - 32] = Hp - 64;
           I64[Hp - 24] = sat_s43PK_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.475615775 UTC

[section ""data" . Numeric.readSigned_closure" {
     Numeric.readSigned_closure:
         const Numeric.readSigned_info;
         const 0;
 },
 $dNum_s43PP_entry() //  [R1]
         { info_tbl: [(c456U,
                       label: $dNum_s43PP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c456U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c456V; else goto c456W;
       c456V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c456W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go1_s43PZ_entry() //  [R1, R2]
         { info_tbl: [(c457q,
                       label: go1_s43PZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c457q: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c457r; else goto u457X;
       c457r: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u457X: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _c457g() args: 0, res: 0, upd: 0;
     }
 },
 _c457g() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c457g: // global
           I64[Sp - 16] = block_c457j_info;
           R1 = P64[Sp + 8];
           _s43PZ::P64 = P64[Sp];
           P64[Sp - 8] = P64[_s43PZ::P64 + 15];
           P64[Sp + 8] = P64[_s43PZ::P64 + 7];
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u457Z; else goto c457k;
       u457Z: // global
           call _c457j(R1) args: 0, res: 0, upd: 0;
       c457k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c457j() //  [R1]
         { info_tbl: [(c457j,
                       label: block_c457j_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c457j: // global
           if (R1 & 7 == 1) goto c457n; else goto c457o;
       c457n: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c457o: // global
           I64[Sp] = block_c457y_info;
           _s43Q3::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 8] = _s43Q3::P64;
           if (R1 & 7 != 0) goto u4580; else goto c457A;
       u4580: // global
           call _c457y(R1) args: 0, res: 0, upd: 0;
       c457A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c457y() //  [R1]
         { info_tbl: [(c457y,
                       label: block_c457y_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c457y: // global
           I64[Sp - 8] = block_c457E_info;
           _s43Q5::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s43Q5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4582; else goto c457G;
       u4582: // global
           call _c457E(R1) args: 0, res: 0, upd: 0;
       c457G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c457E() //  [R1]
         { info_tbl: [(c457E,
                       label: block_c457E_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c457E: // global
           _s43Q3::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c457O; else goto c457V;
       c457O: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c457R; else goto c457Q;
       c457R: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c457Q: // global
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _s43Q3::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 32];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c457V: // global
           P64[Sp + 32] = _s43Q3::P64;
           Sp = Sp + 24;
           call _c457g() args: 0, res: 0, upd: 0;
     }
 },
 go_s43PQ_entry() //  [R1, R2]
         { info_tbl: [(c4588,
                       label: go_s43PQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4588: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4589; else goto c458a;
       c4589: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c458a: // global
           I64[Sp - 24] = block_c4572_info;
           _s43PQ::P64 = R1;
           _s43PN::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s43PN::P64;
           P64[Sp - 8] = _s43PQ::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u458n; else goto c4573;
       u458n: // global
           call _c4572(R1) args: 0, res: 0, upd: 0;
       c4573: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4572() //  [R1]
         { info_tbl: [(c4572,
                       label: block_c4572_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4572: // global
           if (R1 & 7 == 1) goto c4585; else goto c4586;
       c4585: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4586: // global
           I64[Sp - 8] = block_c4578_info;
           _s43PU::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s43PU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u458m; else goto c4579;
       u458m: // global
           call _c4578(R1) args: 0, res: 0, upd: 0;
       c4579: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4578() //  [R1]
         { info_tbl: [(c4578,
                       label: block_c4578_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4578: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c458h; else goto c458g;
       c458h: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c458g: // global
           _s43PW::P64 = P64[R1 + 7];
           _s43PX::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = go1_s43PZ_info;
           P64[Hp - 8] = _s43PX::P64;
           P64[Hp] = Hp - 48;
           _s43PN::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c458d_info;
           R2 = _s43PW::P64;
           R1 = _s43PN::P64;
           P64[Sp + 24] = Hp - 15;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c458d() //  [R1]
         { info_tbl: [(c458d,
                       label: block_c458d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c458d: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_s43PZ_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43QB_entry() //  [R1]
         { info_tbl: [(c459j,
                       label: sat_s43QB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c459j: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c459k; else goto c459l;
       c459k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c459l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go2_s43Qt_entry() //  [R1, R2]
         { info_tbl: [(c459q,
                       label: go2_s43Qt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c459q: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c459r; else goto c459s;
       c459r: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c459s: // global
           I64[Sp - 32] = block_c4593_info;
           _s43Qt::P64 = R1;
           _s43PP::P64 = P64[R1 + 7];
           _s43Qs::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s43PP::P64;
           P64[Sp - 16] = _s43Qs::P64;
           P64[Sp - 8] = _s43Qt::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u459C; else goto c4594;
       u459C: // global
           call _c4593(R1) args: 0, res: 0, upd: 0;
       c4594: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4593() //  [R1]
         { info_tbl: [(c4593,
                       label: block_c4593_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4593: // global
           if (R1 & 7 == 1) goto c459n; else goto c459o;
       c459n: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c459o: // global
           I64[Sp] = block_c4599_info;
           _s43Qx::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _s43Qx::P64;
           if (R1 & 7 != 0) goto u459B; else goto c459a;
       u459B: // global
           call _c4599(R1) args: 0, res: 0, upd: 0;
       c459a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4599() //  [R1]
         { info_tbl: [(c4599,
                       label: block_c4599_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4599: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c459A; else goto c459z;
       c459A: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c459z: // global
           _s43Qz::P64 = P64[R1 + 7];
           _s43QA::P64 = P64[R1 + 15];
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 16];
           I64[Hp - 72] = sat_s43QB_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _s43Qz::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _s43QA::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 104;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go1_s43Qd_entry() //  [R1, R2]
         { info_tbl: [(c459H,
                       label: go1_s43Qd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c459H: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c459I; else goto u45aj;
       c459I: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u45aj: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _c458q() args: 0, res: 0, upd: 0;
     }
 },
 _c458q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c458q: // global
           I64[Sp - 16] = block_c458t_info;
           R1 = P64[Sp + 8];
           _s43Qd::P64 = P64[Sp];
           P64[Sp - 8] = P64[_s43Qd::P64 + 15];
           P64[Sp + 8] = P64[_s43Qd::P64 + 7];
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u45ao; else goto c458u;
       u45ao: // global
           call _c458t(R1) args: 0, res: 0, upd: 0;
       c458u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c458t() //  [R1]
         { info_tbl: [(c458t,
                       label: block_c458t_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c458t: // global
           if (R1 & 7 == 1) goto c459E; else goto c459F;
       c459E: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c459F: // global
           I64[Sp - 8] = block_c458z_info;
           _s43Qh::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s43Qh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u45ap; else goto c458A;
       u45ap: // global
           call _c458z(R1) args: 0, res: 0, upd: 0;
       c458A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c458z() //  [R1]
         { info_tbl: [(c458z,
                       label: block_c458z_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c458z: // global
           I64[Sp - 8] = block_c458E_info;
           _s43Qk::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s43Qk::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u45aq; else goto c458F;
       u45aq: // global
           call _c458E(R1) args: 0, res: 0, upd: 0;
       c458F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c458E() //  [R1]
         { info_tbl: [(c458E,
                       label: block_c458E_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c458E: // global
           if (R1 & 7 == 1) goto u45ak; else goto c459T;
       u45ak: // global
           Sp = Sp + 16;
           call _c45ag() args: 0, res: 0, upd: 0;
       c459T: // global
           I64[Sp - 8] = block_c458K_info;
           _s43Qn::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s43Qn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u45ar; else goto c458L;
       u45ar: // global
           call _c458K(R1) args: 0, res: 0, upd: 0;
       c458L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c458K() //  [R1]
         { info_tbl: [(c458K,
                       label: block_c458K_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c458K: // global
           if (I64[R1 + 7] == 45) goto c459X; else goto u45al;
       c459X: // global
           _s43Qn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c458S_info;
           R1 = _s43Qn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u45at; else goto c458T;
       u45at: // global
           call _c458S(R1) args: 0, res: 0, upd: 0;
       c458T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u45al: // global
           Sp = Sp + 24;
           call _c45ag() args: 0, res: 0, upd: 0;
     }
 },
 _c458S() //  [R1]
         { info_tbl: [(c458S,
                       label: block_c458S_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c458S: // global
           if (R1 & 7 == 1) goto c45a4; else goto u45am;
       c45a4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c45a7; else goto c45a6;
       c45a7: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45a6: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = go2_s43Qt_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = Hp - 48;
           I64[Sp + 16] = block_c459Y_info;
           R3 = P64[Sp + 8];
           R2 = GHC.Read.lex1_closure;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u45am: // global
           Sp = Sp + 16;
           call _c45ag() args: 0, res: 0, upd: 0;
     }
 },
 _c459Y() //  [R1]
         { info_tbl: [(c459Y,
                       label: block_c459Y_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c459Y: // global
           I64[Sp + 16] = block_c45a2_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s43PQ_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45a2() //  [R1]
         { info_tbl: [(c45a2,
                       label: block_c45a2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45a2: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go2_s43Qt_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c45ag() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45ag: // global
           P64[Sp + 24] = P64[Sp];
           Sp = Sp + 16;
           call _c458q() args: 0, res: 0, upd: 0;
     }
 },
 sat_s43QM_entry() //  [R1]
         { info_tbl: [(c45aJ,
                       label: sat_s43QM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45aJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45aK; else goto c45aL;
       c45aK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45aL: // global
           I64[Sp - 16] = block_c45aH_info;
           R3 = P64[R1 + 24];
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 8] = P64[R1 + 16];
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45aH() //  [R1]
         { info_tbl: [(c45aH,
                       label: block_c45aH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45aH: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_s43Qd_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43QN_entry() //  [R1, R2]
         { info_tbl: [(c45aR,
                       label: sat_s43QN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45aR: // global
           _s43QI::P64 = R2;
           _s43QN::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c45aV; else goto c45aW;
       c45aW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c45aY; else goto c45aX;
       c45aY: // global
           HpAlloc = 32;
           goto c45aV;
       c45aV: // global
           R2 = _s43QI::P64;
           R1 = _s43QN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c45aX: // global
           _s43PQ::P64 = P64[_s43QN::P64 + 7];
           _s43Qd::P64 = P64[_s43QN::P64 + 15];
           I64[Hp - 24] = sat_s43QM_info;
           P64[Hp - 8] = _s43Qd::P64;
           P64[Hp] = _s43QI::P64;
           I64[Sp - 24] = block_c45aP_info;
           R3 = _s43QI::P64;
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _s43PQ::P64;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45aP() //  [R1]
         { info_tbl: [(c45aP,
                       label: block_c45aP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45aP: // global
           I64[Sp] = block_c45aU_info;
           R2 = R1;
           R1 = P64[Sp + 16];
           call go_s43PQ_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45aU() //  [R1]
         { info_tbl: [(c45aU,
                       label: block_c45aU_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45aU: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Numeric.readSigned_entry() //  [R2, R3, R4]
         { info_tbl: [(c45b4,
                       label: Numeric.readSigned_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45b4: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c45b8; else goto c45b7;
       c45b8: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readSigned_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c45b7: // global
           I64[Hp - 80] = $dNum_s43PP_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = go_s43PQ_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = go1_s43Qd_info;
           P64[Hp - 32] = Hp - 80;
           _c456X::P64 = Hp - 55;
           P64[Hp - 24] = _c456X::P64;
           I64[Hp - 16] = sat_s43QN_info;
           P64[Hp - 8] = _c456X::P64;
           P64[Hp] = Hp - 39;
           R4 = R4;
           R3 = Hp - 15;
           R2 = GHC.Types.False_closure+1;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.534703246 UTC

[section ""data" . sat_s43QO_closure" {
     sat_s43QO_closure:
         const GHC.Types.I#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.536842167 UTC

[section ""data" . sat_s43QP_closure" {
     sat_s43QP_closure:
         const :_con_info;
         const sat_s43QO_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.539326919 UTC

[section ""data" . Numeric.showInt2_closure" {
     Numeric.showInt2_closure:
         const Numeric.showInt2_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showInt2_entry() //  [R1]
         { info_tbl: [(c45dR,
                       label: Numeric.showInt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45dR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45dS; else goto c45dT;
       c45dS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45dT: // global
           (_c45dO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c45dO::I64 == 0) goto c45dQ; else goto c45dP;
       c45dQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c45dP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c45dO::I64;
           R3 = sat_s43QP_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.54566703 UTC

[section ""cstring" . lvl_r43OH_bytes" {
     lvl_r43OH_bytes:
         I8[] [78,117,109,101,114,105,99,46,115,104,111,119,73,110,116,58,32,99,97,110,39,116,32,115,104,111,119,32,110,101,103,97,116,105,118,101,32,110,117,109,98,101,114,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.548784043 UTC

[section ""data" . Numeric.showInt1_closure" {
     Numeric.showInt1_closure:
         const Numeric.showInt1_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showInt1_entry() //  [R1]
         { info_tbl: [(c45ea,
                       label: Numeric.showInt1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45ea: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c45eb; else goto c45ec;
       c45eb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45ec: // global
           (_c45e5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c45e5::I64 == 0) goto c45e7; else goto c45e6;
       c45e7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c45e6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c45e5::I64;
           I64[Sp - 24] = block_c45e8_info;
           R2 = lvl_r43OH_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c45e8() //  [R1]
         { info_tbl: [(c45e8,
                       label: block_c45e8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45e8: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.556535932 UTC

[section ""data" . Numeric.showHFloat16_closure" {
     Numeric.showHFloat16_closure:
         const Numeric.showHFloat16_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat16_entry() //  [R1]
         { info_tbl: [(c45ew,
                       label: Numeric.showHFloat16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45ew: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45ex; else goto c45ey;
       c45ex: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45ey: // global
           (_c45et::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c45et::I64 == 0) goto c45ev; else goto c45eu;
       c45ev: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c45eu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c45et::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.563887707 UTC

[section ""data" . Numeric.showInt_closure" {
     Numeric.showInt_closure:
         const Numeric.showInt_info;
         const 0;
 },
 sat_s43QX_entry() //  [R1]
         { info_tbl: [(c45fD,
                       label: sat_s43QX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45fD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45fE; else goto c45fF;
       c45fE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45fF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c45fB_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c45fB() //  [R1]
         { info_tbl: [(c45fB,
                       label: block_c45fB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45fB: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showHFloat16_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl5_s43QZ_entry() //  [R1]
         { info_tbl: [(c45fN,
                       label: lvl5_s43QZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45fN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45fO; else goto c45fP;
       c45fO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45fP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c45fL_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c45fL() //  [R1]
         { info_tbl: [(c45fL,
                       label: block_c45fL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45fL: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showInt2_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s43Re_entry() //  [R1]
         { info_tbl: [(c45fV,
                       label: ds_s43Re_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45fV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c45fW; else goto c45fX;
       c45fW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45fX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quotRem_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Numeric.showInt_entry() //  [R2, R3, R4]
         { info_tbl: [(c45fY,
                       label: Numeric.showInt_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45fY: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c45fZ; else goto c45g0;
       c45fZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showInt_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c45g0: // global
           I64[Sp - 32] = block_c45eK_info;
           _s43QR::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s43QR::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45eK() //  [R1]
         { info_tbl: [(c45eK,
                       label: block_c45eK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45eK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c45g3; else goto c45g2;
       c45g3: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45g2: // global
           I64[Hp - 16] = sat_s43QX_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c45eQ_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45eQ() //  [R1]
         { info_tbl: [(c45eQ,
                       label: block_c45eQ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45eQ: // global
           I64[Sp] = block_c45eU_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c45eU() //  [R1]
         { info_tbl: [(c45eU,
                       label: block_c45eU_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45eU: // global
           if (R1 & 7 == 1) goto c45g6; else goto c45gQ;
       c45g6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c45g9; else goto c45g8;
       c45g9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45g8: // global
           I64[Hp - 16] = lvl5_s43QZ_info;
           _s43QU::P64 = P64[Sp + 8];
           P64[Hp] = _s43QU::P64;
           I64[Sp + 8] = block_c45f0_info;
           R2 = _s43QU::P64;
           P64[Sp + 16] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
       c45gQ: // global
           R1 = Numeric.showInt1_closure;
           Sp = Sp + 48;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c45f0() //  [R1]
         { info_tbl: [(c45f0,
                       label: block_c45f0_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45f0: // global
           P64[Sp] = P64[Sp + 32];
           P64[Sp + 24] = P64[Sp + 24];
           P64[Sp + 32] = R1;
           call _c45f9() args: 0, res: 0, upd: 0;
     }
 },
 _c45f9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45f9: // global
           I64[Sp - 8] = block_c45fb_info;
           R2 = P64[Sp + 32];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 24];
           P64[Sp - 16] = P64[Sp + 8];
           Sp = Sp - 32;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c45fb() //  [R1]
         { info_tbl: [(c45fb,
                       label: block_c45fb_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45fb: // global
           _s43QR::P64 = P64[Sp + 24];
           _s43Rb::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c45gB; else goto c45gM;
       c45gB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c45gE; else goto c45gD;
       c45gE: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45gD: // global
           I64[Hp - 56] = ds_s43Re_info;
           P64[Hp - 40] = _s43QR::P64;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s43Rb::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           _c45ff::P64 = Hp - 56;
           P64[Hp] = _c45ff::P64;
           I64[Sp] = block_c45fi_info;
           R2 = _s43QR::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           P64[Sp + 32] = _c45ff::P64;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
       c45gM: // global
           I64[Sp + 32] = block_c45ge_info;
           R2 = _s43QR::P64;
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = _s43Rb::P64;
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c45fi() //  [R1]
         { info_tbl: [(c45fi,
                       label: block_c45fi_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45fi: // global
           I64[Sp] = block_c45fm_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45fm() //  [R1]
         { info_tbl: [(c45fm,
                       label: block_c45fm_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45fm: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c45gI; else goto c45gH;
       c45gI: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c45gH: // global
           I64[Hp - 56] = GHC.Types.C#_con_info;
           I64[Hp - 48] = R1 + 48;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 55;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = P64[Sp + 32];
           P64[Sp + 32] = Hp - 16;
           P64[Sp + 8] = Hp - 38;
           Sp = Sp + 8;
           call _c45f9() args: 0, res: 0, upd: 0;
     }
 },
 _c45ge() //  [R1]
         { info_tbl: [(c45ge,
                       label: block_c45ge_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45ge: // global
           I64[Sp] = block_c45gi_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45gi() //  [R1]
         { info_tbl: [(c45gi,
                       label: block_c45gi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45gi: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c45gy; else goto c45gx;
       c45gy: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c45gx: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = R1 + 48;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.607085453 UTC

[section ""data" . Numeric.showFFloatAlt_closure" {
     Numeric.showFFloatAlt_closure:
         const Numeric.showFFloatAlt_info;
         const 0;
 },
 sat_s43Rw_entry() //  [R1]
         { info_tbl: [(c45in,
                       label: sat_s43Rw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45in: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45io; else goto c45ip;
       c45io: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45ip: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.True_closure+2;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFFixed_closure+2;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showFFloatAlt_entry() //  [R2, R3, R4]
         { info_tbl: [(c45iq,
                       label: Numeric.showFFloatAlt_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45iq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c45iu; else goto c45it;
       c45iu: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showFFloatAlt_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c45it: // global
           I64[Hp - 32] = sat_s43Rw_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.613583092 UTC

[section ""data" . Numeric.showGFloatAlt_closure" {
     Numeric.showGFloatAlt_closure:
         const Numeric.showGFloatAlt_info;
         const 0;
 },
 sat_s43RA_entry() //  [R1]
         { info_tbl: [(c45iL,
                       label: sat_s43RA_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45iL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45iM; else goto c45iN;
       c45iM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45iN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.True_closure+2;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFGeneric_closure+3;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showGFloatAlt_entry() //  [R2, R3, R4]
         { info_tbl: [(c45iO,
                       label: Numeric.showGFloatAlt_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45iO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c45iS; else goto c45iR;
       c45iS: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showGFloatAlt_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c45iR: // global
           I64[Hp - 32] = sat_s43RA_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.619945833 UTC

[section ""cstring" . lvl1_r43OI_bytes" {
     lvl1_r43OI_bytes:
         I8[] [78,117,109,101,114,105,99,46,115,104,111,119,73,110,116,65,116,66,97,115,101,58,32,97,112,112,108,105,101,100,32,116,111,32,110,101,103,97,116,105,118,101,32,110,117,109,98,101,114,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.622382436 UTC

[section ""data" . Numeric.$wlvl_closure" {
     Numeric.$wlvl_closure:
         const Numeric.$wlvl_info;
         const 0;
 },
 sat_s43RF_entry() //  [R1]
         { info_tbl: [(c45jd,
                       label: sat_s43RF_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45jd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c45je; else goto c45jf;
       c45je: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45jf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c45ja_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c45ja() //  [R1, R2]
         { info_tbl: [(c45ja,
                       label: block_c45ja_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45ja: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c45ji; else goto c45jh;
       c45ji: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c45jh: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.$wlvl_entry() //  [R2]
         { info_tbl: [(c45jl,
                       label: Numeric.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45jl: // global
           _s43RB::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c45jm; else goto c45jn;
       c45jn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c45jp; else goto c45jo;
       c45jp: // global
           HpAlloc = 24;
           goto c45jm;
       c45jm: // global
           R2 = _s43RB::I64;
           R1 = Numeric.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c45jo: // global
           I64[Hp - 16] = sat_s43RF_info;
           I64[Hp] = _s43RB::I64;
           I64[Sp - 8] = block_c45jj_info;
           R3 = Hp - 16;
           R2 = lvl1_r43OI_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45jj() //  [R1]
         { info_tbl: [(c45jj,
                       label: block_c45jj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45jj: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.631767216 UTC

[section ""cstring" . lvl2_r43OJ_bytes" {
     lvl2_r43OJ_bytes:
         I8[] [78,117,109,101,114,105,99,46,115,104,111,119,73,110,116,65,116,66,97,115,101,58,32,97,112,112,108,105,101,100,32,116,111,32,117,110,115,117,112,112,111,114,116,101,100,32,98,97,115,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.634048012 UTC

[section ""data" . Numeric.showIntAtBase2_closure" {
     Numeric.showIntAtBase2_closure:
         const Numeric.showIntAtBase2_info;
         const 0;
 },
 sat_s43RJ_entry() //  [R1]
         { info_tbl: [(c45jS,
                       label: sat_s43RJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45jS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45jT; else goto c45jU;
       c45jT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45jU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Numeric.showIntAtBase2_entry() //  [R2, R3]
         { info_tbl: [(c45jX,
                       label: Numeric.showIntAtBase2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45jX: // global
           _s43RI::P64 = R3;
           _s43RH::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c45jY; else goto c45jZ;
       c45jZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c45k1; else goto c45k0;
       c45k1: // global
           HpAlloc = 32;
           goto c45jY;
       c45jY: // global
           R3 = _s43RI::P64;
           R2 = _s43RH::P64;
           R1 = Numeric.showIntAtBase2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c45k0: // global
           I64[Hp - 24] = sat_s43RJ_info;
           P64[Hp - 8] = _s43RH::P64;
           P64[Hp] = _s43RI::P64;
           I64[Sp - 8] = block_c45jV_info;
           R3 = Hp - 24;
           R2 = lvl1_r43OI_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45jV() //  [R1]
         { info_tbl: [(c45jV,
                       label: block_c45jV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45jV: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.642894518 UTC

[section ""data" . Numeric.showIntAtBase1_closure" {
     Numeric.showIntAtBase1_closure:
         const Numeric.showIntAtBase1_info;
         const 0;
 },
 sat_s43RN_entry() //  [R1]
         { info_tbl: [(c45kq,
                       label: sat_s43RN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45kq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45kr; else goto c45ks;
       c45kr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45ks: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Numeric.showIntAtBase1_entry() //  [R2, R3]
         { info_tbl: [(c45kv,
                       label: Numeric.showIntAtBase1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45kv: // global
           _s43RM::P64 = R3;
           _s43RL::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c45kw; else goto c45kx;
       c45kx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c45kz; else goto c45ky;
       c45kz: // global
           HpAlloc = 32;
           goto c45kw;
       c45kw: // global
           R3 = _s43RM::P64;
           R2 = _s43RL::P64;
           R1 = Numeric.showIntAtBase1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c45ky: // global
           I64[Hp - 24] = sat_s43RN_info;
           P64[Hp - 8] = _s43RL::P64;
           P64[Hp] = _s43RM::P64;
           I64[Sp - 8] = block_c45kt_info;
           R3 = Hp - 24;
           R2 = lvl2_r43OJ_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45kt() //  [R1]
         { info_tbl: [(c45kt,
                       label: block_c45kt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45kt: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.650427707 UTC

[section ""data" . sat_s43RP_closure" {
     sat_s43RP_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.65217989 UTC

[section ""data" . sat_s43RQ_closure" {
     sat_s43RQ_closure:
         const :_con_info;
         const sat_s43RP_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.654279513 UTC

[section ""data" . Numeric.showIntAtBase3_closure" {
     Numeric.showIntAtBase3_closure:
         const Numeric.showIntAtBase3_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showIntAtBase3_entry() //  [R1]
         { info_tbl: [(c45kY,
                       label: Numeric.showIntAtBase3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45kY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45kZ; else goto c45l0;
       c45kZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45l0: // global
           (_c45kV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c45kV::I64 == 0) goto c45kX; else goto c45kW;
       c45kX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c45kW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c45kV::I64;
           R3 = sat_s43RQ_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.660957386 UTC

[section ""data" . Numeric.showIntAtBase_closure" {
     Numeric.showIntAtBase_closure:
         const Numeric.showIntAtBase_info;
         const 0;
 },
 $dNum_s43RY_entry() //  [R1]
         { info_tbl: [(c45m4,
                       label: $dNum_s43RY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45m4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45m5; else goto c45m6;
       c45m5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45m6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43S0_entry() //  [R1]
         { info_tbl: [(c45m9,
                       label: sat_s43S0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45m9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45ma; else goto c45mb;
       c45ma: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45mb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showIntAtBase3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43S2_entry() //  [R1]
         { info_tbl: [(c45me,
                       label: sat_s43S2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45me: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45mf; else goto c45mg;
       c45mf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45mg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showHFloat16_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl5_s43S7_entry() //  [R1]
         { info_tbl: [(c45mj,
                       label: lvl5_s43S7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45mj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45mk; else goto c45ml;
       c45mk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45ml: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showHFloat16_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43Sf_entry() //  [R1]
         { info_tbl: [(c45mq,
                       label: sat_s43Sf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45mq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c45my; else goto c45mz;
       c45my: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45mz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c45mo_info;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c45mo() //  [R1]
         { info_tbl: [(c45mo,
                       label: block_c45mo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45mo: // global
           I64[Sp] = block_c45mt_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c45mt() //  [R1]
         { info_tbl: [(c45mt,
                       label: block_c45mt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45mt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c45mD; else goto c45mC;
       c45mD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c45mC: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showIntAtBase_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c45mE,
                       label: Numeric.showIntAtBase_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45mE: // global
           if ((Sp + -88) < SpLim) (likely: False) goto c45mF; else goto c45mG;
       c45mF: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showIntAtBase_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c45mG: // global
           I64[Sp - 48] = block_c45lc_info;
           _s43RR::P64 = R2;
           R2 = R2;
           P64[Sp - 40] = _s43RR::P64;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45lc() //  [R1]
         { info_tbl: [(c45lc,
                       label: block_c45lc_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45lc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c45mJ; else goto c45mI;
       c45mJ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45mI: // global
           I64[Hp - 16] = $dNum_s43RY_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c45li_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45li() //  [R1]
         { info_tbl: [(c45li,
                       label: block_c45li_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45li: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c45mM; else goto c45mL;
       c45mM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45mL: // global
           I64[Hp - 16] = sat_s43S0_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c45lo_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 32];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c45lo() //  [R1]
         { info_tbl: [(c45lo,
                       label: block_c45lo_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45lo: // global
           if (R1 & 7 == 1) goto c45mO; else goto c45nn;
       c45mO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c45mR; else goto c45mQ;
       c45mR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45mQ: // global
           I64[Hp - 16] = sat_s43S2_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp] = block_c45lu_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 56];
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
       c45nn: // global
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           Sp = Sp + 72;
           call Numeric.showIntAtBase1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c45lu() //  [R1]
         { info_tbl: [(c45lu,
                       label: block_c45lu_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45lu: // global
           _s43RV::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto c45mU; else goto c45nj;
       c45mU: // global
           I64[Sp] = block_c45ly_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s43RV::P64;
           P64[Sp - 8] = P64[Sp + 40];
           Sp = Sp - 24;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 8;
       c45nj: // global
           R3 = _s43RV::P64;
           R2 = P64[Sp + 32];
           Sp = Sp + 72;
           call Numeric.showIntAtBase2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c45ly() //  [R1]
         { info_tbl: [(c45ly,
                       label: block_c45ly_info
                       rep:StackRep [False, False, False, True, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45ly: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c45mX; else goto c45mW;
       c45mX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45mW: // global
           _s43S5::P64 = P64[R1 + 7];
           _s43S6::P64 = P64[R1 + 15];
           I64[Hp - 16] = lvl5_s43S7_info;
           P64[Hp] = P64[Sp + 16];
           _s43RZ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c45lE_info;
           R2 = _s43RZ::P64;
           P64[Sp + 16] = _s43S6::P64;
           P64[Sp + 32] = _s43S5::P64;
           P64[Sp + 56] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45lE() //  [R1]
         { info_tbl: [(c45lE,
                       label: block_c45lE_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45lE: // global
           P64[Sp] = P64[Sp + 56];
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 24] = P64[Sp + 24];
           P64[Sp + 56] = R1;
           call _c45lL() args: 0, res: 0, upd: 0;
     }
 },
 _c45lL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45lL: // global
           Hp = Hp + 32;
           _s43Sb::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c45n1; else goto c45n0;
       c45n1: // global
           HpAlloc = 32;
           I64[Sp + 8] = block_c45lK_info;
           R3 = P64[Sp];
           R2 = _s43Sb::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 8;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       c45n0: // global
           I64[Hp - 24] = sat_s43Sf_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s43Sb::P64;
           I64[Sp - 8] = block_c45lP_info;
           R2 = Hp - 24;
           R1 = P64[Sp + 40];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45lK() //  [R1, R2, R3]
         { info_tbl: [(c45lK,
                       label: block_c45lK_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45lK: // global
           P64[Sp + 16] = R1;
           P64[Sp] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 8;
           call _c45lL() args: 0, res: 0, upd: 0;
     }
 },
 _c45lP() //  [R1]
         { info_tbl: [(c45lP,
                       label: block_c45lP_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45lP: // global
           I64[Sp] = block_c45lT_info;
           R2 = P64[Sp + 64];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 56];
           P64[Sp + 16] = R1;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c45lT() //  [R1]
         { info_tbl: [(c45lT,
                       label: block_c45lT_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45lT: // global
           if (R1 & 7 == 1) goto c45n5; else goto c45nc;
       c45n5: // global
           I64[Sp] = block_c45lX_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 40];
           Sp = Sp - 24;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 8;
       c45nc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c45nf; else goto c45ne;
       c45nf: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45ne: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 14;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c45lX() //  [R1]
         { info_tbl: [(c45lX,
                       label: block_c45lX_info
                       rep:StackRep [False, False, False, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45lX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c45n8; else goto c45n7;
       c45n8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45n7: // global
           _s43Sk::P64 = P64[R1 + 7];
           _s43Sl::P64 = P64[R1 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           P64[Sp + 32] = _s43Sk::P64;
           P64[Sp + 16] = _s43Sl::P64;
           P64[Sp + 8] = Hp - 14;
           Sp = Sp + 8;
           call _c45lL() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.699711362 UTC

[section ""data" . sat_s43Sn_closure" {
     sat_s43Sn_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.701837541 UTC

[section ""data" . sat_s43So_closure" {
     sat_s43So_closure:
         const :_con_info;
         const sat_s43Sn_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.703900604 UTC

[section ""data" . Numeric.showHex1_closure" {
     Numeric.showHex1_closure:
         const Numeric.showHex1_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHex1_entry() //  [R1]
         { info_tbl: [(c45pc,
                       label: Numeric.showHex1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45pc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45pd; else goto c45pe;
       c45pd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45pe: // global
           (_c45p9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c45p9::I64 == 0) goto c45pb; else goto c45pa;
       c45pb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c45pa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c45p9::I64;
           R3 = sat_s43So_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.70873271 UTC

[section ""data" . Numeric.showHex_closure" {
     Numeric.showHex_closure:
         const Numeric.showHex_info;
         const 0;
 },
 sat_s43St_entry() //  [R1]
         { info_tbl: [(c45pw,
                       label: sat_s43St_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45pw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45pA; else goto c45pB;
       c45pA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45pB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c45pu_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c45pu() //  [R1]
         { info_tbl: [(c45pu,
                       label: block_c45pu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45pu: // global
           I64[Sp] = block_c45pz_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c45pz() //  [R1]
         { info_tbl: [(c45pz,
                       label: block_c45pz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45pz: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showHex1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Numeric.showHex_entry() //  [R2, R3]
         { info_tbl: [(c45pH,
                       label: Numeric.showHex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45pH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c45pL; else goto c45pK;
       c45pL: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showHex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c45pK: // global
           I64[Hp - 16] = sat_s43St_info;
           P64[Hp] = R2;
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showIntAtBase_closure+6;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.721605375 UTC

[section ""cstring" . Numeric.$trModule4_bytes" {
     Numeric.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.724837538 UTC

[section ""data" . loc_r43OK_closure" {
     loc_r43OK_closure:
         const loc_r43OK_info;
         const 0;
         const 0;
         const 0;
 },
 loc_r43OK_entry() //  [R1]
         { info_tbl: [(c45q7,
                       label: loc_r43OK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45q7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45q8; else goto c45q9;
       c45q8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45q9: // global
           (_c45q4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c45q4::I64 == 0) goto c45q6; else goto c45q5;
       c45q6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c45q5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c45q4::I64;
           R2 = Numeric.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.730534769 UTC

[section ""cstring" . Numeric.$trModule2_bytes" {
     Numeric.$trModule2_bytes:
         I8[] [78,117,109,101,114,105,99]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.733388596 UTC

[section ""data" . loc1_r43OL_closure" {
     loc1_r43OL_closure:
         const loc1_r43OL_info;
         const 0;
         const 0;
         const 0;
 },
 loc1_r43OL_entry() //  [R1]
         { info_tbl: [(c45qo,
                       label: loc1_r43OL_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45qo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45qp; else goto c45qq;
       c45qp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45qq: // global
           (_c45ql::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c45ql::I64 == 0) goto c45qn; else goto c45qm;
       c45qn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c45qm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c45ql::I64;
           R2 = Numeric.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.73992478 UTC

[section ""cstring" . loc2_r43OM_bytes" {
     loc2_r43OM_bytes:
         I8[] [78,117,109,101,114,105,99,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.742885313 UTC

[section ""data" . loc3_r43ON_closure" {
     loc3_r43ON_closure:
         const loc3_r43ON_info;
         const 0;
         const 0;
         const 0;
 },
 loc3_r43ON_entry() //  [R1]
         { info_tbl: [(c45qF,
                       label: loc3_r43ON_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45qF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45qG; else goto c45qH;
       c45qG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45qH: // global
           (_c45qC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c45qC::I64 == 0) goto c45qE; else goto c45qD;
       c45qE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c45qD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c45qC::I64;
           R2 = loc2_r43OM_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.749501729 UTC

[section ""data" . loc4_r43OO_closure" {
     loc4_r43OO_closure:
         const GHC.Types.I#_con_info;
         const 241;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.752013839 UTC

[section ""data" . loc5_r43OP_closure" {
     loc5_r43OP_closure:
         const GHC.Types.I#_con_info;
         const 22;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.754866946 UTC

[section ""data" . loc6_r43OQ_closure" {
     loc6_r43OQ_closure:
         const GHC.Types.I#_con_info;
         const 75;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.757488217 UTC

[section ""cstring" . $dIP_r43OR_bytes" {
     $dIP_r43OR_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.761198124 UTC

[section ""data" . $dIP1_r43OS_closure" {
     $dIP1_r43OS_closure:
         const $dIP1_r43OS_info;
         const 0;
         const 0;
         const 0;
 },
 $dIP1_r43OS_entry() //  [R1]
         { info_tbl: [(c45qZ,
                       label: $dIP1_r43OS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45qZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45r0; else goto c45r1;
       c45r0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45r1: // global
           (_c45qW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c45qW::I64 == 0) goto c45qY; else goto c45qX;
       c45qY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c45qX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c45qW::I64;
           R2 = $dIP_r43OR_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.767492656 UTC

[section ""data" . $dIP2_r43OT_closure" {
     $dIP2_r43OT_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const loc_r43OK_closure;
         const loc1_r43OL_closure;
         const loc3_r43ON_closure;
         const loc4_r43OO_closure+1;
         const loc5_r43OP_closure+1;
         const loc4_r43OO_closure+1;
         const loc6_r43OQ_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.770361898 UTC

[section ""data" . $dIP3_r43OU_closure" {
     $dIP3_r43OU_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const $dIP1_r43OS_closure;
         const $dIP2_r43OT_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.77297598 UTC

[section ""cstring" . lvl3_r43OV_bytes" {
     lvl3_r43OV_bytes:
         I8[] [73,109,112,111,115,115,105,98,108,101,32,104,97,112,112,101,110,101,100,58,32,115,104,111,119,72,70,108,111,97,116,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.775473177 UTC

[section ""data" . lvl4_r43OW_closure" {
     lvl4_r43OW_closure:
         const :_con_info;
         const GHC.Show.$fShow(,)2_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.779604526 UTC

[section ""data" . $wlvl2_r43OX_closure" {
     $wlvl2_r43OX_closure:
         const $wlvl2_r43OX_info;
         const 0;
 },
 sat_s43SB_entry() //  [R1, R2]
         { info_tbl: [(c45rt,
                       label: sat_s43SB_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45rt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c45ru; else goto c45rv;
       c45ru: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c45rv: // global
           I64[Sp - 8] = block_c45rq_info;
           R4 = R2;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45rq() //  [R1, R2]
         { info_tbl: [(c45rq,
                       label: block_c45rq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45rq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c45ry; else goto c45rx;
       c45ry: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c45rx: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43Sw_entry() //  [R1, R2]
         { info_tbl: [(c45rF,
                       label: sat_s43Sw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45rF: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Show.$fShowInt_$cshowList_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43SE_entry() //  [R1]
         { info_tbl: [(c45rJ,
                       label: sat_s43SE_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45rJ: // global
           _s43SE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c45rK; else goto c45rL;
       c45rL: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c45rN; else goto c45rM;
       c45rN: // global
           HpAlloc = 80;
           goto c45rK;
       c45rK: // global
           R1 = _s43SE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45rM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43SE::P64;
           _s43Su::P64 = P64[_s43SE::P64 + 16];
           _s43Sv::I64 = I64[_s43SE::P64 + 24];
           I64[Hp - 72] = sat_s43SB_info;
           I64[Hp - 64] = _s43Sv::I64;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           I64[Hp - 32] = sat_s43Sw_info;
           P64[Hp - 24] = _s43Su::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 54;
           R3 = lvl4_r43OW_closure+2;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Show.$fShow(,)_go1_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl2_r43OX_entry() //  [R2, R3]
         { info_tbl: [(c45rR,
                       label: $wlvl2_r43OX_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45rR: // global
           _s43Sv::I64 = R3;
           _s43Su::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c45rS; else goto c45rT;
       c45rT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c45rV; else goto c45rU;
       c45rV: // global
           HpAlloc = 56;
           goto c45rS;
       c45rS: // global
           R3 = _s43Sv::I64;
           R2 = _s43Su::P64;
           R1 = $wlvl2_r43OX_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c45rU: // global
           I64[Hp - 48] = sat_s43SE_info;
           P64[Hp - 32] = _s43Su::P64;
           I64[Hp - 24] = _s43Sv::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           I64[Sp - 8] = block_c45rP_info;
           R3 = Hp - 14;
           R2 = lvl3_r43OV_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45rP() //  [R1]
         { info_tbl: [(c45rP,
                       label: block_c45rP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45rP: // global
           R3 = R1;
           R2 = $dIP3_r43OU_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.798634351 UTC

[section ""data" . Numeric.showHFloat_allZ_closure" {
     Numeric.showHFloat_allZ_closure:
         const Numeric.showHFloat_allZ_info;
 },
 Numeric.showHFloat_allZ_entry() //  [R2]
         { info_tbl: [(c45sB,
                       label: Numeric.showHFloat_allZ_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45sB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45sC; else goto u45sU;
       c45sC: // global
           R2 = R2;
           R1 = Numeric.showHFloat_allZ_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u45sU: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c45sr() args: 0, res: 0, upd: 0;
     }
 },
 _c45sr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45sr: // global
           _s43SH::P64 = P64[Sp];
           I64[Sp] = block_c45su_info;
           R1 = _s43SH::P64;
           if (R1 & 7 != 0) goto u45sW; else goto c45sv;
       u45sW: // global
           call _c45su(R1) args: 0, res: 0, upd: 0;
       c45sv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45su() //  [R1]
         { info_tbl: [(c45su,
                       label: block_c45su_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45su: // global
           if (R1 & 7 == 1) goto c45sy; else goto c45sz;
       c45sy: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c45sz: // global
           I64[Sp - 8] = block_c45sJ_info;
           _s43SK::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s43SK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u45sX; else goto c45sL;
       u45sX: // global
           call _c45sJ(R1) args: 0, res: 0, upd: 0;
       c45sL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45sJ() //  [R1]
         { info_tbl: [(c45sJ,
                       label: block_c45sJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45sJ: // global
           if (I64[R1 + 7] == 0) goto c45sT; else goto c45sS;
       c45sT: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c45sr() args: 0, res: 0, upd: 0;
       c45sS: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.808571067 UTC

[section ""data" . $wshowIt1_r43OY_closure" {
     $wshowIt1_r43OY_closure:
         const $wshowIt1_r43OY_info;
         const 0;
 },
 $wshowIt1_r43OY_entry() //  [R2, R3, R4]
         { info_tbl: [(c45tC,
                       label: $wshowIt1_r43OY_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45tC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45tD; else goto u45tP;
       c45tD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wshowIt1_r43OY_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u45tP: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c45tl() args: 0, res: 0, upd: 0;
     }
 },
 _c45tl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45tl: // global
           I64[Sp - 8] = block_c45to_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u45tR; else goto c45tp;
       u45tR: // global
           call _c45to(R1) args: 0, res: 0, upd: 0;
       c45tp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45to() //  [R1]
         { info_tbl: [(c45to,
                       label: block_c45to_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45to: // global
           I64[Sp] = block_c45tt_info;
           R2 = I64[R1 + 7];
           call GHC.Show.$wintToDigit_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45tt() //  [R1]
         { info_tbl: [(c45tt,
                       label: block_c45tt_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45tt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c45tI; else goto c45tH;
       c45tI: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c45tH: // global
           _s43SQ::P64 = P64[Sp + 24];
           _s43SU::I64 = I64[Sp + 8];
           if (_s43SU::I64 == 0) goto c45tO; else goto c45tK;
       c45tO: // global
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43SQ::P64;
           _c45tN::P64 = Hp - 30;
           Hp = Hp - 16;
           R1 = _c45tN::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c45tK: // global
           (_s43SW::I64, _s43SX::I64) = call MO_S_QuotRem W64(_s43SU::I64, 16);
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43SQ::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43SX::I64;
           I64[Sp + 8] = _s43SW::I64;
           P64[Sp + 16] = Hp - 7;
           P64[Sp + 24] = Hp - 30;
           Sp = Sp + 8;
           call _c45tl() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.820258042 UTC

[section ""data" . $wshowIt2_r43OZ_closure" {
     $wshowIt2_r43OZ_closure:
         const $wshowIt2_r43OZ_info;
         const 0;
 },
 $wshowIt2_r43OZ_entry() //  [R2, R3, R4]
         { info_tbl: [(c45uw,
                       label: $wshowIt2_r43OZ_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45uw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45ux; else goto u45uJ;
       c45ux: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wshowIt2_r43OZ_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u45uJ: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c45uf() args: 0, res: 0, upd: 0;
     }
 },
 _c45uf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45uf: // global
           I64[Sp - 8] = block_c45ui_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u45uL; else goto c45uj;
       u45uL: // global
           call _c45ui(R1) args: 0, res: 0, upd: 0;
       c45uj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45ui() //  [R1]
         { info_tbl: [(c45ui,
                       label: block_c45ui_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45ui: // global
           I64[Sp] = block_c45un_info;
           R2 = I64[R1 + 7];
           call GHC.Show.$wintToDigit_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45un() //  [R1]
         { info_tbl: [(c45un,
                       label: block_c45un_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45un: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c45uC; else goto c45uB;
       c45uC: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c45uB: // global
           _s43T4::P64 = P64[Sp + 24];
           _s43T8::I64 = I64[Sp + 8];
           if (_s43T8::I64 == 0) goto c45uI; else goto c45uE;
       c45uI: // global
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43T4::P64;
           _c45uH::P64 = Hp - 30;
           Hp = Hp - 16;
           R1 = _c45uH::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c45uE: // global
           (_s43Ta::I64, _s43Tb::I64) = call MO_S_QuotRem W64(_s43T8::I64, 16);
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43T4::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43Tb::I64;
           I64[Sp + 8] = _s43Ta::I64;
           P64[Sp + 16] = Hp - 7;
           P64[Sp + 24] = Hp - 30;
           Sp = Sp + 8;
           call _c45uf() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.833994348 UTC

[section ""data" . $wshowIt3_r43P0_closure" {
     $wshowIt3_r43P0_closure:
         const $wshowIt3_r43P0_info;
         const 0;
 },
 $wshowIt3_r43P0_entry() //  [R2, R3, R4]
         { info_tbl: [(c45vq,
                       label: $wshowIt3_r43P0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45vq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45vr; else goto u45vD;
       c45vr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wshowIt3_r43P0_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u45vD: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c45v9() args: 0, res: 0, upd: 0;
     }
 },
 _c45v9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45v9: // global
           I64[Sp - 8] = block_c45vc_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u45vF; else goto c45vd;
       u45vF: // global
           call _c45vc(R1) args: 0, res: 0, upd: 0;
       c45vd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45vc() //  [R1]
         { info_tbl: [(c45vc,
                       label: block_c45vc_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45vc: // global
           I64[Sp] = block_c45vh_info;
           R2 = I64[R1 + 7];
           call GHC.Show.$wintToDigit_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45vh() //  [R1]
         { info_tbl: [(c45vh,
                       label: block_c45vh_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45vh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c45vw; else goto c45vv;
       c45vw: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c45vv: // global
           _s43Ti::P64 = P64[Sp + 24];
           _s43Tm::I64 = I64[Sp + 8];
           if (_s43Tm::I64 == 0) goto c45vC; else goto c45vy;
       c45vC: // global
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43Ti::P64;
           _c45vB::P64 = Hp - 30;
           Hp = Hp - 16;
           R1 = _c45vB::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c45vy: // global
           (_s43To::I64, _s43Tp::I64) = call MO_S_QuotRem W64(_s43Tm::I64, 16);
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43Ti::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43Tp::I64;
           I64[Sp + 8] = _s43To::I64;
           P64[Sp + 16] = Hp - 7;
           P64[Sp + 24] = Hp - 30;
           Sp = Sp + 8;
           call _c45v9() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.849944382 UTC

[section ""data" . $wshowIt4_r43P1_closure" {
     $wshowIt4_r43P1_closure:
         const $wshowIt4_r43P1_info;
         const 0;
 },
 $wshowIt4_r43P1_entry() //  [R2, R3, R4]
         { info_tbl: [(c45wk,
                       label: $wshowIt4_r43P1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45wk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45wl; else goto u45wx;
       c45wl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wshowIt4_r43P1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u45wx: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c45w3() args: 0, res: 0, upd: 0;
     }
 },
 _c45w3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45w3: // global
           I64[Sp - 8] = block_c45w6_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u45wz; else goto c45w7;
       u45wz: // global
           call _c45w6(R1) args: 0, res: 0, upd: 0;
       c45w7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45w6() //  [R1]
         { info_tbl: [(c45w6,
                       label: block_c45w6_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45w6: // global
           I64[Sp] = block_c45wb_info;
           R2 = I64[R1 + 7];
           call GHC.Show.$wintToDigit_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45wb() //  [R1]
         { info_tbl: [(c45wb,
                       label: block_c45wb_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45wb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c45wq; else goto c45wp;
       c45wq: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c45wp: // global
           _s43Tw::P64 = P64[Sp + 24];
           _s43TA::I64 = I64[Sp + 8];
           if (_s43TA::I64 == 0) goto c45ww; else goto c45ws;
       c45ww: // global
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43Tw::P64;
           _c45wv::P64 = Hp - 30;
           Hp = Hp - 16;
           R1 = _c45wv::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c45ws: // global
           (_s43TC::I64, _s43TD::I64) = call MO_S_QuotRem W64(_s43TA::I64, 16);
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s43Tw::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43TD::I64;
           I64[Sp + 8] = _s43TC::I64;
           P64[Sp + 16] = Hp - 7;
           P64[Sp + 24] = Hp - 30;
           Sp = Sp + 8;
           call _c45w3() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.863893599 UTC

[section ""data" . Numeric.showHFloat_hex_closure" {
     Numeric.showHFloat_hex_closure:
         const Numeric.showHFloat_hex_info;
         const 0;
 },
 sat_s43UO_entry() //  [R1]
         { info_tbl: [(c45y7,
                       label: sat_s43UO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45y7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45y8; else goto c45y9;
       c45y8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45y9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Numeric.showHFloat_hex_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showHFloat_hex_entry() //  [R2]
         { info_tbl: [(c45ye,
                       label: Numeric.showHFloat_hex_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45ye: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c45yf; else goto c45yg;
       c45yf: // global
           R2 = R2;
           R1 = Numeric.showHFloat_hex_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c45yg: // global
           I64[Sp - 8] = block_c45x0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u45Ar; else goto c45x1;
       u45Ar: // global
           call _c45x0(R1) args: 0, res: 0, upd: 0;
       c45x1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45x0() //  [R1]
         { info_tbl: [(c45x0,
                       label: block_c45x0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45x0: // global
           if (R1 & 7 == 1) goto c45yb; else goto c45yc;
       c45yb: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c45yc: // global
           I64[Sp - 8] = block_c45x6_info;
           _s43TK::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _s43TK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u45Ah; else goto c45x7;
       u45Ah: // global
           call _c45x6(R1) args: 0, res: 0, upd: 0;
       c45x7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45x6() //  [R1]
         { info_tbl: [(c45x6,
                       label: block_c45x6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45x6: // global
           if (R1 & 7 == 1) goto c45yo; else goto c45yH;
       c45yo: // global
           _s43TK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c45yl_info;
           R1 = _s43TK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u45Ai; else goto c45yp;
       u45Ai: // global
           call _c45yl(R1) args: 0, res: 0, upd: 0;
       c45yp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c45yH: // global
           I64[Sp - 8] = block_c45xc_info;
           _s43TV::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _s43TV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u45Aj; else goto c45xd;
       u45Aj: // global
           call _c45xc(R1) args: 0, res: 0, upd: 0;
       c45xd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45yl() //  [R1]
         { info_tbl: [(c45yl,
                       label: block_c45yl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45yl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c45yv; else goto c45yu;
       c45yv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45yu: // global
           _s43TP::I64 = I64[R1 + 7] << 3;
           if (%MO_S_Ge_W64(_s43TP::I64, 0)) goto c45yE; else goto c45yF;
       c45yE: // global
           (_s43TS::I64, _s43TT::I64) = call MO_S_QuotRem W64(_s43TP::I64, 16);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43TT::I64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 7;
           R2 = _s43TS::I64;
           Sp = Sp + 8;
           call $wshowIt4_r43P1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c45yF: // global
           Hp = Hp - 16;
           R2 = _s43TP::I64;
           Sp = Sp + 8;
           call Numeric.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c45xc() //  [R1]
         { info_tbl: [(c45xc,
                       label: block_c45xc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45xc: // global
           if (R1 & 7 == 1) goto c45yR; else goto c45zh;
       c45yR: // global
           I64[Sp] = block_c45yJ_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u45Ak; else goto c45yK;
       u45Ak: // global
           call _c45yJ(R1) args: 0, res: 0, upd: 0;
       c45yK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c45zh: // global
           I64[Sp - 8] = block_c45xi_info;
           _s43Ua::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _s43Ua::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u45Al; else goto c45xj;
       u45Al: // global
           call _c45xi(R1) args: 0, res: 0, upd: 0;
       c45xj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45yJ() //  [R1]
         { info_tbl: [(c45yJ,
                       label: block_c45yJ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45yJ: // global
           _s43TV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c45yO_info;
           _s43TZ::I64 = I64[R1 + 7];
           R1 = _s43TV::P64;
           I64[Sp + 16] = _s43TZ::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u45As; else goto c45yT;
       u45As: // global
           call _c45yO(R1) args: 0, res: 0, upd: 0;
       c45yT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45yO() //  [R1]
         { info_tbl: [(c45yO,
                       label: block_c45yO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45yO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c45yZ; else goto c45yY;
       c45yZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45yY: // global
           _s43U2::I64 = (I64[Sp + 8] << 3) + (I64[R1 + 7] << 2);
           if (%MO_S_Ge_W64(_s43U2::I64, 0)) goto c45ze; else goto c45zf;
       c45ze: // global
           (_s43U7::I64, _s43U8::I64) = call MO_S_QuotRem W64(_s43U2::I64, 16);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43U8::I64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 7;
           R2 = _s43U7::I64;
           Sp = Sp + 16;
           call $wshowIt3_r43P0_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c45zf: // global
           Hp = Hp - 16;
           R2 = _s43U2::I64;
           Sp = Sp + 16;
           call Numeric.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c45xi() //  [R1]
         { info_tbl: [(c45xi,
                       label: block_c45xi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45xi: // global
           _s43TK::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c45zw; else goto c45A3;
       c45zw: // global
           I64[Sp] = block_c45zj_info;
           R1 = _s43TK::P64;
           if (R1 & 7 != 0) goto u45Am; else goto c45zk;
       u45Am: // global
           call _c45zj(R1) args: 0, res: 0, upd: 0;
       c45zk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c45A3: // global
           I64[Sp - 8] = block_c45xo_info;
           _s43Ut::P64 = P64[R1 + 6];
           _s43Uu::P64 = P64[R1 + 14];
           R1 = _s43TK::P64;
           P64[Sp] = _s43Uu::P64;
           P64[Sp + 24] = _s43Ut::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u45An; else goto c45xp;
       u45An: // global
           call _c45xo(R1) args: 0, res: 0, upd: 0;
       c45xp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45zj() //  [R1]
         { info_tbl: [(c45zj,
                       label: block_c45zj_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45zj: // global
           I64[Sp] = block_c45zo_info;
           _s43Ue::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 24] = _s43Ue::I64;
           if (R1 & 7 != 0) goto u45At; else goto c45zp;
       u45At: // global
           call _c45zo(R1) args: 0, res: 0, upd: 0;
       c45zp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45zo() //  [R1]
         { info_tbl: [(c45zo,
                       label: block_c45zo_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45zo: // global
           _s43Ua::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c45zt_info;
           _s43Ug::I64 = I64[R1 + 7];
           R1 = _s43Ua::P64;
           I64[Sp + 16] = _s43Ug::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u45Au; else goto c45zz;
       u45Au: // global
           call _c45zt(R1) args: 0, res: 0, upd: 0;
       c45zz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45zt() //  [R1]
         { info_tbl: [(c45zt,
                       label: block_c45zt_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45zt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c45zF; else goto c45zE;
       c45zF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45zE: // global
           _s43Uj::I64 = (I64[Sp + 16] << 3) + ((I64[Sp + 8] << 2) + (I64[R1 + 7] << 1));
           if (%MO_S_Ge_W64(_s43Uj::I64, 0)) goto c45A0; else goto c45A1;
       c45A0: // global
           (_s43Uq::I64, _s43Ur::I64) = call MO_S_QuotRem W64(_s43Uj::I64, 16);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43Ur::I64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 7;
           R2 = _s43Uq::I64;
           Sp = Sp + 24;
           call $wshowIt2_r43OZ_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c45A1: // global
           Hp = Hp - 16;
           R2 = _s43Uj::I64;
           Sp = Sp + 24;
           call Numeric.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c45xo() //  [R1]
         { info_tbl: [(c45xo,
                       label: block_c45xo_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45xo: // global
           I64[Sp] = block_c45xt_info;
           _s43Uw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s43Uw::I64;
           if (R1 & 7 != 0) goto u45Ao; else goto c45xu;
       u45Ao: // global
           call _c45xt(R1) args: 0, res: 0, upd: 0;
       c45xu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45xt() //  [R1]
         { info_tbl: [(c45xt,
                       label: block_c45xt_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45xt: // global
           I64[Sp] = block_c45xy_info;
           _s43Uy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s43Uy::I64;
           if (R1 & 7 != 0) goto u45Ap; else goto c45xz;
       u45Ap: // global
           call _c45xy(R1) args: 0, res: 0, upd: 0;
       c45xz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45xy() //  [R1]
         { info_tbl: [(c45xy,
                       label: block_c45xy_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45xy: // global
           I64[Sp] = block_c45xD_info;
           _s43UA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _s43UA::I64;
           if (R1 & 7 != 0) goto u45Aq; else goto c45xE;
       u45Aq: // global
           call _c45xD(R1) args: 0, res: 0, upd: 0;
       c45xE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45xD() //  [R1]
         { info_tbl: [(c45xD,
                       label: block_c45xD_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45xD: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c45A9; else goto c45A8;
       c45A9: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45A8: // global
           _s43UD::I64 = (I64[Sp + 24] << 3) + ((I64[Sp + 16] << 2) + ((I64[Sp + 32] << 1) + I64[R1 + 7]));
           if (%MO_S_Ge_W64(_s43UD::I64, 0)) goto c45Ac; else goto c45Ad;
       c45Ac: // global
           _s43Uu::P64 = P64[Sp + 8];
           (_s43UL::I64, _s43UM::I64) = call MO_S_QuotRem W64(_s43UD::I64, 16);
           I64[Hp - 32] = sat_s43UO_info;
           P64[Hp - 16] = _s43Uu::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s43UM::I64;
           R4 = Hp - 32;
           R3 = Hp - 7;
           R2 = _s43UL::I64;
           Sp = Sp + 40;
           call $wshowIt1_r43OY_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c45Ad: // global
           Hp = Hp - 40;
           R2 = _s43UD::I64;
           Sp = Sp + 40;
           call Numeric.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.901881329 UTC

[section ""data" . sat_s43UP_closure" {
     sat_s43UP_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.904131794 UTC

[section ""data" . sat_s43UQ_closure" {
     sat_s43UQ_closure:
         const :_con_info;
         const sat_s43UP_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.906628319 UTC

[section ""data" . Numeric.showHFloat15_closure" {
     Numeric.showHFloat15_closure:
         const Numeric.showHFloat15_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat15_entry() //  [R1]
         { info_tbl: [(c45C5,
                       label: Numeric.showHFloat15_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45C5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45C6; else goto c45C7;
       c45C6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45C7: // global
           (_c45C2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c45C2::I64 == 0) goto c45C4; else goto c45C3;
       c45C4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c45C3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c45C2::I64;
           R3 = sat_s43UQ_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.912373463 UTC

[section ""cstring" . Numeric.showHFloat10_bytes" {
     Numeric.showHFloat10_bytes:
         I8[] [48,120,48,112,43,48]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.915128489 UTC

[section ""data" . Numeric.showHFloat9_closure" {
     Numeric.showHFloat9_closure:
         const Numeric.showHFloat9_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat9_entry() //  [R1]
         { info_tbl: [(c45Cm,
                       label: Numeric.showHFloat9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Cm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45Cn; else goto c45Co;
       c45Cn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45Co: // global
           (_c45Cj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c45Cj::I64 == 0) goto c45Cl; else goto c45Ck;
       c45Cl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c45Ck: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c45Cj::I64;
           R2 = Numeric.showHFloat10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.921114703 UTC

[section ""data" . Numeric.showHFloat14_closure" {
     Numeric.showHFloat14_closure:
         const Numeric.showHFloat14_info;
         const 0;
 },
 Numeric.showHFloat14_entry() //  [R2]
         { info_tbl: [(c45CA,
                       label: Numeric.showHFloat14_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45CA: // global
           R3 = R2;
           R2 = GHC.Types.[]_closure+1;
           call $wlvl2_r43OX_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.92577558 UTC

[section ""cstring" . Numeric.showHFloat13_bytes" {
     Numeric.showHFloat13_bytes:
         I8[] [48,120]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.927381079 UTC

[section ""cstring" . Numeric.showHFloat12_bytes" {
     Numeric.showHFloat12_bytes:
         I8[] [112]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.92899837 UTC

[section ""cstring" . Numeric.showHFloat11_bytes" {
     Numeric.showHFloat11_bytes:
         I8[] [46]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.933680635 UTC

[section ""data" . Numeric.showHFloat_cvt_closure" {
     Numeric.showHFloat_cvt_closure:
         const Numeric.showHFloat_cvt_info;
         const 0;
 },
 sat_s43UZ_entry() //  [R1]
         { info_tbl: [(c45D2,
                       label: sat_s43UZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45D2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45D3; else goto c45D4;
       c45D3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45D4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c45D0_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c45D0() //  [R1]
         { info_tbl: [(c45D0,
                       label: block_c45D0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45D0: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showHFloat16_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43Vm_entry() //  [R1]
         { info_tbl: [(c45DS,
                       label: sat_s43Vm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45DS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c45E1; else goto c45E2;
       c45E1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45E2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c45DP_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u45E7; else goto c45DQ;
       u45E7: // global
           call _c45DP(R1) args: 0, res: 0, upd: 0;
       c45DQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c45DP() //  [R1]
         { info_tbl: [(c45DP,
                       label: block_c45DP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45DP: // global
           I64[Sp] = block_c45DY_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7] - 1;
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c45DY() //  [R1, R2]
         { info_tbl: [(c45DY,
                       label: block_c45DY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45DY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c45E6; else goto c45E5;
       c45E6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c45E5: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 n_s43Vf_entry() //  [R1]
         { info_tbl: [(c45E8,
                       label: n_s43Vf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45E8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c45Ec; else goto c45Eb;
       c45Ec: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45Eb: // global
           _s43V3::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s43Vm_info;
           P64[Hp] = _s43V3::P64;
           R3 = Hp - 16;
           R2 = Numeric.showHFloat12_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43Vp_entry() //  [R1]
         { info_tbl: [(c45En,
                       label: sat_s43Vp_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45En: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45Eo; else goto c45Ep;
       c45Eo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45Ep: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c45El_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Numeric.showHFloat_hex_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c45El() //  [R1]
         { info_tbl: [(c45El,
                       label: block_c45El_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45El: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43Vq_entry() //  [R1]
         { info_tbl: [(c45Ex,
                       label: sat_s43Vq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Ex: // global
           _s43Vq::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c45Ey; else goto c45Ez;
       c45Ez: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c45EB; else goto c45EA;
       c45EB: // global
           HpAlloc = 24;
           goto c45Ey;
       c45Ey: // global
           R1 = _s43Vq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45EA: // global
           _s43V3::P64 = P64[_s43Vq::P64 + 16];
           _s43V8::P64 = P64[_s43Vq::P64 + 24];
           I64[Hp - 16] = n_s43Vf_info;
           P64[Hp] = _s43V3::P64;
           I64[Sp - 24] = block_c45Ed_info;
           R2 = _s43V8::P64;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _s43V8::P64;
           Sp = Sp - 24;
           call Numeric.showHFloat_allZ_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45Ed() //  [R1]
         { info_tbl: [(c45Ed,
                       label: block_c45Ed_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Ed: // global
           _c45DH::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c45Eu; else goto c45Ev;
       c45Eu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c45EE; else goto c45ED;
       c45EE: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45ED: // global
           I64[Hp - 24] = sat_s43Vp_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _c45DH::P64;
           R3 = Hp - 24;
           R2 = Numeric.showHFloat11_bytes;
           Sp = Sp + 24;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c45Ev: // global
           R1 = _c45DH::P64;
           Sp = Sp + 24;
           call n_s43Vf_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s43Vr_entry() //  [R1]
         { info_tbl: [(c45EI,
                       label: sat_s43Vr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45EI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c45EK; else goto c45EL;
       c45EK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45EL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c45Dw_info;
           _s43V3::P64 = P64[R1 + 16];
           _s43V8::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s43V3::P64;
           P64[Sp - 24] = _s43V8::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u45EQ; else goto c45Dx;
       u45EQ: // global
           call _c45Dw(R1) args: 0, res: 0, upd: 0;
       c45Dx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c45Dw() //  [R1]
         { info_tbl: [(c45Dw,
                       label: block_c45Dw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Dw: // global
           I64[Sp] = block_c45DB_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c45DB() //  [R1, R2]
         { info_tbl: [(c45DB,
                       label: block_c45DB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45DB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c45EP; else goto c45EO;
       c45EP: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c45EO: // global
           I64[Hp - 48] = sat_s43Vq_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 48;
           R2 = Hp - 14;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u45Fq_srtd" {
     u45Fq_srtd:
         const S43WU_srt+144;
         const 33;
         const 8388608001;
 },
 Numeric.showHFloat_cvt_entry() //  [R2, R3]
         { info_tbl: [(c45ER,
                       label: Numeric.showHFloat_cvt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45ER: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c45ES; else goto c45ET;
       c45ES: // global
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showHFloat_cvt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c45ET: // global
           I64[Sp - 24] = block_c45CO_info;
           _s43US::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s43US::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Float.$p1RealFloat_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u45Fr_srtd" {
     u45Fr_srtd:
         const S43WU_srt+144;
         const 33;
         const 7851737089;
 },
 _c45CO() //  [R1]
         { info_tbl: [(c45CO,
                       label: block_c45CO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45CO: // global
           I64[Sp] = block_c45CS_info;
           R2 = R1;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u45Fs_srtd" {
     u45Fs_srtd:
         const S43WU_srt+144;
         const 33;
         const 7851737089;
 },
 _c45CS() //  [R1]
         { info_tbl: [(c45CS,
                       label: block_c45CS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45CS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c45EX; else goto c45EW;
       c45EX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45EW: // global
           I64[Hp - 16] = sat_s43UZ_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c45D8_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45D8() //  [R1]
         { info_tbl: [(c45D8,
                       label: block_c45D8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45D8: // global
           I64[Sp] = block_c45Dc_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c45Dc() //  [R1]
         { info_tbl: [(c45Dc,
                       label: block_c45Dc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Dc: // global
           _c45CW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c45Dg_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp] = _c45CW::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c45Dg() //  [R1]
         { info_tbl: [(c45Dg,
                       label: block_c45Dg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Dg: // global
           if (R1 & 7 == 1) goto c45F2; else goto c45Fl;
       c45F2: // global
           _s43UT::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c45Dk_info;
           R4 = _s43UT::P64;
           R3 = Numeric.showHFloat15_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Float.$wfloatToDigits_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
       c45Fl: // global
           R1 = Numeric.showHFloat9_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c45Dk() //  [R1, R2]
         { info_tbl: [(c45Dk,
                       label: block_c45Dk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Dk: // global
           I64[Sp - 8] = block_c45Dm_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u45Fo; else goto c45Dn;
       u45Fo: // global
           call _c45Dm(R1) args: 0, res: 0, upd: 0;
       c45Dn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c45Dm() //  [R1]
         { info_tbl: [(c45Dm,
                       label: block_c45Dm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Dm: // global
           _s43V3::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c45F8; else goto c45Fe;
       c45F8: // global
           I64[Sp + 8] = block_c45F5_info;
           R1 = _s43V3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u45Fp; else goto c45F9;
       u45Fp: // global
           call _c45F5(R1) args: 0, res: 0, upd: 0;
       c45F9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c45Fe: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c45Fh; else goto c45Fg;
       c45Fh: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c45Fg: // global
           _s43V7::P64 = P64[R1 + 6];
           _s43V8::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_s43Vr_info;
           P64[Hp - 16] = _s43V3::P64;
           P64[Hp - 8] = _s43V7::P64;
           P64[Hp] = _s43V8::P64;
           R3 = Hp - 32;
           R2 = Numeric.showHFloat13_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _c45F5() //  [R1]
         { info_tbl: [(c45F5,
                       label: block_c45F5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45F5: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call Numeric.showHFloat14_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.981749409 UTC

[section ""data" . Numeric.showHFloat8_closure" {
     Numeric.showHFloat8_closure:
         const GHC.Types.C#_con_info;
         const 45;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.983386792 UTC

[section ""cstring" . Numeric.showHFloat5_bytes" {
     Numeric.showHFloat5_bytes:
         I8[] [73,110,102,105,110,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.984937468 UTC

[section ""cstring" . Numeric.showHFloat7_bytes" {
     Numeric.showHFloat7_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.986946285 UTC

[section ""data" . Numeric.showHFloat6_closure" {
     Numeric.showHFloat6_closure:
         const Numeric.showHFloat6_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat6_entry() //  [R1]
         { info_tbl: [(c45Ha,
                       label: Numeric.showHFloat6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Ha: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45Hb; else goto c45Hc;
       c45Hb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45Hc: // global
           (_c45H7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c45H7::I64 == 0) goto c45H9; else goto c45H8;
       c45H9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c45H8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c45H7::I64;
           R2 = Numeric.showHFloat7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.990985864 UTC

[section ""cstring" . Numeric.showHFloat2_bytes" {
     Numeric.showHFloat2_bytes:
         I8[] [78,97,78]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.99295316 UTC

[section ""data" . Numeric.showHFloat1_closure" {
     Numeric.showHFloat1_closure:
         const Numeric.showHFloat1_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat1_entry() //  [R1]
         { info_tbl: [(c45Hr,
                       label: Numeric.showHFloat1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Hr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45Hs; else goto c45Ht;
       c45Hs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45Ht: // global
           (_c45Ho::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c45Ho::I64 == 0) goto c45Hq; else goto c45Hp;
       c45Hq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c45Hp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c45Ho::I64;
           R2 = Numeric.showHFloat2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:56.997742295 UTC

[section ""data" . Numeric.showHFloat4_closure" {
     Numeric.showHFloat4_closure:
         const Numeric.showHFloat4_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat4_entry() //  [R1]
         { info_tbl: [(c45HH,
                       label: Numeric.showHFloat4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45HH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45HI; else goto c45HJ;
       c45HI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45HJ: // global
           (_c45HE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c45HE::I64 == 0) goto c45HG; else goto c45HF;
       c45HG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c45HF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c45HE::I64;
           R2 = Numeric.showHFloat5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:57.002407864 UTC

[section ""data" . Numeric.showHFloat3_closure" {
     Numeric.showHFloat3_closure:
         const Numeric.showHFloat3_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat3_entry() //  [R1]
         { info_tbl: [(c45HX,
                       label: Numeric.showHFloat3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45HX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45HY; else goto c45HZ;
       c45HY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45HZ: // global
           (_c45HU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c45HU::I64 == 0) goto c45HW; else goto c45HV;
       c45HW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c45HV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c45HU::I64;
           R3 = Numeric.showHFloat4_closure;
           R2 = Numeric.showHFloat6_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:57.009397944 UTC

[section ""data" . Numeric.showHFloat_closure" {
     Numeric.showHFloat_closure:
         const Numeric.showHFloat_info;
         const 0;
 },
 $dNum_s43Vx_entry() //  [R1]
         { info_tbl: [(c45Iv,
                       label: $dNum_s43Vx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Iv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45Iw; else goto c45Ix;
       c45Iw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45Ix: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43VA_entry() //  [R1]
         { info_tbl: [(c45IG,
                       label: sat_s43VA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45IG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45IH; else goto c45II;
       c45IH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45II: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showHFloat16_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43VD_entry() //  [R1]
         { info_tbl: [(c45J4,
                       label: sat_s43VD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45J4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45J5; else goto c45J6;
       c45J5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45J6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43VE_entry() //  [R1]
         { info_tbl: [(c45J7,
                       label: sat_s43VE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45J7: // global
           _s43VE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c45J8; else goto c45J9;
       c45J9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c45Jb; else goto c45Ja;
       c45Jb: // global
           HpAlloc = 32;
           goto c45J8;
       c45J8: // global
           R1 = _s43VE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45Ja: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43VE::P64;
           _s43Vs::P64 = P64[_s43VE::P64 + 16];
           _s43Vt::P64 = P64[_s43VE::P64 + 24];
           _s43Vx::P64 = P64[_s43VE::P64 + 32];
           I64[Hp - 24] = sat_s43VD_info;
           P64[Hp - 8] = _s43Vt::P64;
           P64[Hp] = _s43Vx::P64;
           R3 = Hp - 24;
           R2 = _s43Vs::P64;
           Sp = Sp - 16;
           call Numeric.showHFloat_cvt_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43VF_entry() //  [R1]
         { info_tbl: [(c45Jm,
                       label: sat_s43VF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Jm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45Jn; else goto c45Jo;
       c45Jn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45Jo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43VG_entry() //  [R1]
         { info_tbl: [(c45Jp,
                       label: sat_s43VG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Jp: // global
           _s43VG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c45Jq; else goto c45Jr;
       c45Jr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c45Jt; else goto c45Js;
       c45Jt: // global
           HpAlloc = 32;
           goto c45Jq;
       c45Jq: // global
           R1 = _s43VG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45Js: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s43VG::P64;
           _s43Vs::P64 = P64[_s43VG::P64 + 16];
           _s43Vt::P64 = P64[_s43VG::P64 + 24];
           _s43Vx::P64 = P64[_s43VG::P64 + 32];
           I64[Hp - 24] = sat_s43VF_info;
           P64[Hp - 8] = _s43Vt::P64;
           P64[Hp] = _s43Vx::P64;
           R3 = Hp - 24;
           R2 = _s43Vs::P64;
           Sp = Sp - 16;
           call Numeric.showHFloat_cvt_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s43VI_entry() //  [R1]
         { info_tbl: [(c45JA,
                       label: sat_s43VI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45JA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45JB; else goto c45JC;
       c45JB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45JC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showHFloat16_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s43VK_entry() //  [R1]
         { info_tbl: [(c45JH,
                       label: sat_s43VK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45JH: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c45JI; else goto c45JJ;
       c45JI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45JJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c45If_info;
           _s43Vs::P64 = P64[R1 + 16];
           R2 = _s43Vs::P64;
           I64[Sp - 56] = stg_ap_p_info;
           _s43Vt::P64 = P64[R1 + 24];
           P64[Sp - 48] = _s43Vt::P64;
           P64[Sp - 32] = _s43Vs::P64;
           P64[Sp - 24] = _s43Vt::P64;
           Sp = Sp - 56;
           call GHC.Float.isNaN_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c45If() //  [R1]
         { info_tbl: [(c45If,
                       label: block_c45If_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45If: // global
           if (R1 & 7 == 1) goto c45JE; else goto c45JF;
       c45JE: // global
           I64[Sp] = block_c45Ij_info;
           R2 = P64[Sp + 8];
           call GHC.Float.$p1RealFloat_entry(R2) args: 8, res: 8, upd: 24;
       c45JF: // global
           R1 = Numeric.showHFloat1_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c45Ij() //  [R1]
         { info_tbl: [(c45Ij,
                       label: block_c45Ij_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Ij: // global
           I64[Sp] = block_c45In_info;
           R2 = R1;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c45In() //  [R1]
         { info_tbl: [(c45In,
                       label: block_c45In_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45In: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c45JO; else goto c45JN;
       c45JO: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c45JN: // global
           I64[Hp - 16] = $dNum_s43Vx_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c45Iy_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Float.isInfinite_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c45Iy() //  [R1]
         { info_tbl: [(c45Iy,
                       label: block_c45Iy_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Iy: // global
           _c45Ir::P64 = P64[Sp + 16];
           _s43Vw::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c45JQ; else goto c45Kd;
       c45JQ: // global
           Hp = Hp + 24;
           _s43Vy::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c45Kg; else goto c45JS;
       c45JS: // global
           I64[Hp - 16] = sat_s43VA_info;
           P64[Hp] = _c45Ir::P64;
           I64[Sp] = block_c45IJ_info;
           R2 = _s43Vw::P64;
           P64[Sp + 8] = Hp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 24;
       c45Kd: // global
           Hp = Hp + 24;
           _s43Vy::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c45Kg; else goto c45Kf;
       c45Kg: // global
           HpAlloc = 24;
           R1 = _s43Vy::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c45Kf: // global
           I64[Hp - 16] = sat_s43VI_info;
           P64[Hp] = _c45Ir::P64;
           I64[Sp + 16] = block_c45Kc_info;
           R2 = _s43Vw::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c45IJ() //  [R1]
         { info_tbl: [(c45IJ,
                       label: block_c45IJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45IJ: // global
           _c45IC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c45IN_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = _c45IC::P64;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c45IN() //  [R1]
         { info_tbl: [(c45IN,
                       label: block_c45IN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45IN: // global
           _s43Vs::P64 = P64[Sp + 16];
           _s43Vt::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c45JX; else goto c45K8;
       c45JX: // global
           I64[Sp] = block_c45IR_info;
           R2 = _s43Vs::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s43Vt::P64;
           Sp = Sp - 16;
           call GHC.Float.isNegativeZero_entry(R2) args: 24, res: 8, upd: 24;
       c45K8: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c45Kb; else goto c45Ka;
       c45Kb: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c45Ka: // global
           I64[Hp - 56] = sat_s43VG_info;
           P64[Hp - 40] = _s43Vs::P64;
           P64[Hp - 32] = _s43Vt::P64;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Numeric.showHFloat8_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c45IR() //  [R1]
         { info_tbl: [(c45IR,
                       label: block_c45IR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45IR: // global
           _s43Vs::P64 = P64[Sp + 16];
           _s43Vt::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c45K1; else goto c45K3;
       c45K1: // global
           R3 = _s43Vt::P64;
           R2 = _s43Vs::P64;
           Sp = Sp + 32;
           call Numeric.showHFloat_cvt_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
       c45K3: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c45K6; else goto c45K5;
       c45K6: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c45K5: // global
           I64[Hp - 56] = sat_s43VE_info;
           P64[Hp - 40] = _s43Vs::P64;
           P64[Hp - 32] = _s43Vt::P64;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Numeric.showHFloat8_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c45Kc() //  [R1]
         { info_tbl: [(c45Kc,
                       label: block_c45Kc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Kc: // global
           _s43Vt::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c45Kk_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s43Vt::P64;
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c45Kk() //  [R1]
         { info_tbl: [(c45Kk,
                       label: block_c45Kk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Kk: // global
           if (R1 & 7 == 1) goto c45Kr; else goto c45Kv;
       c45Kr: // global
           R1 = Numeric.showHFloat4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c45Kv: // global
           R1 = Numeric.showHFloat3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showHFloat_entry() //  [R2, R3]
         { info_tbl: [(c45KD,
                       label: Numeric.showHFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45KD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c45KH; else goto c45KG;
       c45KH: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showHFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c45KG: // global
           I64[Hp - 24] = sat_s43VK_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:57.049431234 UTC

[section ""data" . sat_s43VL_closure" {
     sat_s43VL_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:57.051018246 UTC

[section ""data" . sat_s43VM_closure" {
     sat_s43VM_closure:
         const :_con_info;
         const sat_s43VL_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:57.053677643 UTC

[section ""data" . Numeric.showOct1_closure" {
     Numeric.showOct1_closure:
         const Numeric.showOct1_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showOct1_entry() //  [R1]
         { info_tbl: [(c45Mh,
                       label: Numeric.showOct1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Mh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45Mi; else goto c45Mj;
       c45Mi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45Mj: // global
           (_c45Me::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c45Me::I64 == 0) goto c45Mg; else goto c45Mf;
       c45Mg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c45Mf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c45Me::I64;
           R3 = sat_s43VM_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:57.060279204 UTC

[section ""data" . Numeric.showOct_closure" {
     Numeric.showOct_closure:
         const Numeric.showOct_info;
         const 0;
 },
 sat_s43VR_entry() //  [R1]
         { info_tbl: [(c45MB,
                       label: sat_s43VR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45MB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45MF; else goto c45MG;
       c45MF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45MG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c45Mz_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c45Mz() //  [R1]
         { info_tbl: [(c45Mz,
                       label: block_c45Mz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Mz: // global
           I64[Sp] = block_c45ME_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c45ME() //  [R1]
         { info_tbl: [(c45ME,
                       label: block_c45ME_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45ME: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showOct1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Numeric.showOct_entry() //  [R2, R3]
         { info_tbl: [(c45MM,
                       label: Numeric.showOct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45MM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c45MQ; else goto c45MP;
       c45MQ: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showOct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c45MP: // global
           I64[Hp - 16] = sat_s43VR_info;
           P64[Hp] = R2;
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showIntAtBase_closure+6;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:57.072851103 UTC

[section ""data" . Numeric.$trModule3_closure" {
     Numeric.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Numeric.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:57.07509643 UTC

[section ""data" . Numeric.$trModule1_closure" {
     Numeric.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Numeric.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:57.077434557 UTC

[section ""data" . Numeric.$trModule_closure" {
     Numeric.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Numeric.$trModule3_closure+1;
         const Numeric.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:57.080603578 UTC

[section ""data" . Numeric.showGFloat_$sshowGFloat_closure" {
     Numeric.showGFloat_$sshowGFloat_closure:
         const Numeric.showGFloat_$sshowGFloat_info;
         const 0;
 },
 sat_s43VW_entry() //  [R1]
         { info_tbl: [(c45Nj,
                       label: sat_s43VW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Nj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45Nk; else goto c45Nl;
       c45Nk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45Nl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c45Ng_info;
           _s43VS::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s43VS::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u45Np; else goto c45Nh;
       u45Np: // global
           call _c45Ng(R1) args: 0, res: 0, upd: 0;
       c45Nh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c45Ng() //  [R1]
         { info_tbl: [(c45Ng,
                       label: block_c45Ng_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Ng: // global
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showGFloat_$sshowGFloat_entry() //  [R2, R3]
         { info_tbl: [(c45Nq,
                       label: Numeric.showGFloat_$sshowGFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Nq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c45Nu; else goto c45Nt;
       c45Nu: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showGFloat_$sshowGFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c45Nt: // global
           I64[Hp - 24] = sat_s43VW_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:57.092151329 UTC

[section ""data" . Numeric.showFFloat_$sshowFFloat_closure" {
     Numeric.showFFloat_$sshowFFloat_closure:
         const Numeric.showFFloat_$sshowFFloat_info;
         const 0;
 },
 sat_s43W1_entry() //  [R1]
         { info_tbl: [(c45NS,
                       label: sat_s43W1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45NS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45NT; else goto c45NU;
       c45NT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45NU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c45NP_info;
           _s43VX::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s43VX::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u45NY; else goto c45NQ;
       u45NY: // global
           call _c45NP(R1) args: 0, res: 0, upd: 0;
       c45NQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c45NP() //  [R1]
         { info_tbl: [(c45NP,
                       label: block_c45NP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45NP: // global
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showFFloat_$sshowFFloat_entry() //  [R2, R3]
         { info_tbl: [(c45NZ,
                       label: Numeric.showFFloat_$sshowFFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45NZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c45O3; else goto c45O2;
       c45O3: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showFFloat_$sshowFFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c45O2: // global
           I64[Hp - 24] = sat_s43W1_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:57.104862588 UTC

[section ""data" . Numeric.showEFloat_$sshowEFloat_closure" {
     Numeric.showEFloat_$sshowEFloat_closure:
         const Numeric.showEFloat_$sshowEFloat_info;
         const 0;
 },
 sat_s43W6_entry() //  [R1]
         { info_tbl: [(c45Or,
                       label: sat_s43W6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Or: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45Os; else goto c45Ot;
       c45Os: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45Ot: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c45Oo_info;
           _s43W2::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s43W2::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u45Ox; else goto c45Op;
       u45Ox: // global
           call _c45Oo(R1) args: 0, res: 0, upd: 0;
       c45Op: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c45Oo() //  [R1]
         { info_tbl: [(c45Oo,
                       label: block_c45Oo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Oo: // global
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFExponent_closure+1;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showEFloat_$sshowEFloat_entry() //  [R2, R3]
         { info_tbl: [(c45Oy,
                       label: Numeric.showEFloat_$sshowEFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Oy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c45OC; else goto c45OB;
       c45OC: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showEFloat_$sshowEFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c45OB: // global
           I64[Hp - 24] = sat_s43W6_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:57.116869699 UTC

[section ""data" . Numeric.showGFloat_$sshowGFloat1_closure" {
     Numeric.showGFloat_$sshowGFloat1_closure:
         const Numeric.showGFloat_$sshowGFloat1_info;
         const 0;
 },
 sat_s43Wb_entry() //  [R1]
         { info_tbl: [(c45P0,
                       label: sat_s43Wb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45P0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45P1; else goto c45P2;
       c45P1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45P2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c45OX_info;
           _s43W7::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s43W7::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u45P6; else goto c45OY;
       u45P6: // global
           call _c45OX(R1) args: 0, res: 0, upd: 0;
       c45OY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c45OX() //  [R1]
         { info_tbl: [(c45OX,
                       label: block_c45OX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45OX: // global
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showGFloat_$sshowGFloat1_entry() //  [R2, R3]
         { info_tbl: [(c45P7,
                       label: Numeric.showGFloat_$sshowGFloat1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45P7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c45Pb; else goto c45Pa;
       c45Pb: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showGFloat_$sshowGFloat1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c45Pa: // global
           I64[Hp - 24] = sat_s43Wb_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:57.126430559 UTC

[section ""data" . Numeric.showGFloat_closure" {
     Numeric.showGFloat_closure:
         const Numeric.showGFloat_info;
         const 0;
 },
 sat_s43Wf_entry() //  [R1]
         { info_tbl: [(c45Pw,
                       label: sat_s43Wf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Pw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45Px; else goto c45Py;
       c45Px: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45Py: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.False_closure+1;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFGeneric_closure+3;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showGFloat_entry() //  [R2, R3, R4]
         { info_tbl: [(c45Pz,
                       label: Numeric.showGFloat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Pz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c45PD; else goto c45PC;
       c45PD: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showGFloat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c45PC: // global
           I64[Hp - 32] = sat_s43Wf_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:57.133990195 UTC

[section ""data" . Numeric.showFFloat_$sshowFFloat1_closure" {
     Numeric.showFFloat_$sshowFFloat1_closure:
         const Numeric.showFFloat_$sshowFFloat1_info;
         const 0;
 },
 sat_s43Wk_entry() //  [R1]
         { info_tbl: [(c45PX,
                       label: sat_s43Wk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45PX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45PY; else goto c45PZ;
       c45PY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45PZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c45PU_info;
           _s43Wg::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s43Wg::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u45Q3; else goto c45PV;
       u45Q3: // global
           call _c45PU(R1) args: 0, res: 0, upd: 0;
       c45PV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c45PU() //  [R1]
         { info_tbl: [(c45PU,
                       label: block_c45PU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45PU: // global
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showFFloat_$sshowFFloat1_entry() //  [R2, R3]
         { info_tbl: [(c45Q4,
                       label: Numeric.showFFloat_$sshowFFloat1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Q4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c45Q8; else goto c45Q7;
       c45Q8: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showFFloat_$sshowFFloat1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c45Q7: // global
           I64[Hp - 24] = sat_s43Wk_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:57.146014274 UTC

[section ""data" . Numeric.showFFloat_closure" {
     Numeric.showFFloat_closure:
         const Numeric.showFFloat_info;
         const 0;
 },
 sat_s43Wo_entry() //  [R1]
         { info_tbl: [(c45Qt,
                       label: sat_s43Wo_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Qt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45Qu; else goto c45Qv;
       c45Qu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45Qv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.False_closure+1;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFFixed_closure+2;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showFFloat_entry() //  [R2, R3, R4]
         { info_tbl: [(c45Qw,
                       label: Numeric.showFFloat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Qw: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c45QA; else goto c45Qz;
       c45QA: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showFFloat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c45Qz: // global
           I64[Hp - 32] = sat_s43Wo_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:57.157223136 UTC

[section ""data" . Numeric.showEFloat_$sshowEFloat1_closure" {
     Numeric.showEFloat_$sshowEFloat1_closure:
         const Numeric.showEFloat_$sshowEFloat1_info;
         const 0;
 },
 sat_s43Wt_entry() //  [R1]
         { info_tbl: [(c45QU,
                       label: sat_s43Wt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45QU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c45QV; else goto c45QW;
       c45QV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45QW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c45QR_info;
           _s43Wp::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s43Wp::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u45R0; else goto c45QS;
       u45R0: // global
           call _c45QR(R1) args: 0, res: 0, upd: 0;
       c45QS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c45QR() //  [R1]
         { info_tbl: [(c45QR,
                       label: block_c45QR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45QR: // global
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFExponent_closure+1;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showEFloat_$sshowEFloat1_entry() //  [R2, R3]
         { info_tbl: [(c45R1,
                       label: Numeric.showEFloat_$sshowEFloat1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45R1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c45R5; else goto c45R4;
       c45R5: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showEFloat_$sshowEFloat1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c45R4: // global
           I64[Hp - 24] = sat_s43Wt_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:57.175065092 UTC

[section ""data" . Numeric.showEFloat_closure" {
     Numeric.showEFloat_closure:
         const Numeric.showEFloat_info;
         const 0;
 },
 sat_s43Wx_entry() //  [R1]
         { info_tbl: [(c45Rq,
                       label: sat_s43Wx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Rq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c45Rr; else goto c45Rs;
       c45Rr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45Rs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.False_closure+1;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFExponent_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showEFloat_entry() //  [R2, R3, R4]
         { info_tbl: [(c45Rt,
                       label: Numeric.showEFloat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Rt: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c45Rx; else goto c45Rw;
       c45Rx: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showEFloat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c45Rw: // global
           I64[Hp - 32] = sat_s43Wx_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:57.182413102 UTC

[section ""relreadonly" . S43WU_srt" {
     S43WU_srt:
         const Text.Read.Lex.$wreadIntP_closure;
         const Numeric.readInt_closure;
         const Text.Read.Lex.readDecP4_closure;
         const Text.Read.Lex.$wreadIntP'_closure;
         const Numeric.readOct_closure;
         const Text.Read.Lex.numberToFixed1_closure;
         const Numeric.readDec_closure;
         const Text.Read.Lex.readDecP3_closure;
         const Numeric.readHex_closure;
         const Text.Read.Lex.$wnumberToRational_closure;
         const Text.Read.Lex.expect2_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const Numeric.readFloat_closure;
         const GHC.Read.lex1_closure;
         const GHC.Read.readParen_closure;
         const Numeric.readSigned_closure;
         const sat_s43QP_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Numeric.showHFloat16_closure;
         const Numeric.showInt2_closure;
         const Numeric.showInt_closure;
         const Numeric.showInt1_closure;
         const GHC.Float.formatRealFloatAlt_closure;
         const Numeric.showFFloatAlt_closure;
         const Numeric.showGFloatAlt_closure;
         const Numeric.$wlvl_closure;
         const Numeric.showIntAtBase2_closure;
         const Numeric.showIntAtBase1_closure;
         const sat_s43RQ_closure;
         const Numeric.showIntAtBase3_closure;
         const Numeric.showIntAtBase_closure;
         const sat_s43So_closure;
         const Numeric.showHex1_closure;
         const GHC.Show.intToDigit_closure;
         const Numeric.showHex_closure;
         const GHC.Show.$fShow(,)_go1_closure;
         const GHC.Err.error_closure;
         const $dIP3_r43OU_closure;
         const $wlvl2_r43OX_closure;
         const GHC.Show.$wintToDigit_closure;
         const $wshowIt1_r43OY_closure;
         const $wshowIt2_r43OZ_closure;
         const $wshowIt3_r43P0_closure;
         const $wshowIt4_r43P1_closure;
         const Numeric.showHFloat_hex_closure;
         const sat_s43UQ_closure;
         const GHC.Float.$wfloatToDigits_closure;
         const Numeric.showHFloat_cvt_closure;
         const Numeric.showHFloat9_closure;
         const Numeric.showHFloat14_closure;
         const Numeric.showHFloat15_closure;
         const Numeric.showHFloat4_closure;
         const Numeric.showHFloat6_closure;
         const Numeric.showHFloat16_closure;
         const Numeric.showHFloat1_closure;
         const Numeric.showHFloat3_closure;
         const Numeric.showHFloat_closure;
         const sat_s43VM_closure;
         const Numeric.showOct1_closure;
         const Numeric.showOct_closure;
         const GHC.Float.$w$sformatRealFloatAlt1_closure;
         const Numeric.showGFloat_$sshowGFloat_closure;
         const Numeric.showFFloat_$sshowFFloat_closure;
         const Numeric.showEFloat_$sshowEFloat_closure;
         const GHC.Float.$w$sformatRealFloatAlt_closure;
         const Numeric.showGFloat_$sshowGFloat1_closure;
         const GHC.Float.formatRealFloatAlt_closure;
         const Numeric.showGFloat_closure;
         const Numeric.showFFloat_$sshowFFloat1_closure;
         const Numeric.showFFloat_closure;
         const Numeric.showEFloat_$sshowEFloat1_closure;
         const Numeric.showEFloat_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.21311827 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:58:59.215729263 UTC

[section ""data" . Numeric.readInt_closure" {
     Numeric.readInt_closure:
         const Numeric.readInt_info;
         const 0;
 },
 sat_s45RN_entry() //  [R1]
         { info_tbl: [(c45Zn,
                       label: sat_s45RN_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Zn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c45Zo; else goto c45Zp;
       c45Zo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c45Zp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c45Zk_info;
           R6 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Text.Read.Lex.$wreadIntP_entry(R6,
                                               R5,
                                               R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c45Zk() //  [R1]
         { info_tbl: [(c45Zk,
                       label: block_c45Zk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Zk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c45Zs; else goto c45Zr;
       c45Zs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c45Zr: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.readInt_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c45Zt,
                       label: Numeric.readInt_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c45Zt: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c45Zx; else goto c45Zw;
       c45Zx: // global
           HpAlloc = 48;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readInt_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c45Zw: // global
           I64[Hp - 40] = sat_s45RN_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R2 = Hp - 40;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.224335418 UTC

[section ""data" . Numeric.readOct_closure" {
     Numeric.readOct_closure:
         const Numeric.readOct_info;
         const 0;
 },
 sat_s45RQ_entry() //  [R1]
         { info_tbl: [(c4603,
                       label: sat_s45RQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4603: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4604; else goto c4605;
       c4604: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4605: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.Read.Lex.readDecP4_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s45RT_entry() //  [R1]
         { info_tbl: [(c4609,
                       label: sat_s45RT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4609: // global
           _s45RT::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c460a; else goto c460b;
       c460b: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c460d; else goto c460c;
       c460d: // global
           HpAlloc = 24;
           goto c460a;
       c460a: // global
           R1 = _s45RT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c460c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s45RT::P64;
           _s45RO::P64 = P64[_s45RT::P64 + 16];
           _s45RP::P64 = P64[_s45RT::P64 + 24];
           I64[Hp - 16] = sat_s45RQ_info;
           P64[Hp] = _s45RP::P64;
           I64[Sp - 24] = block_c4606_info;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = Hp - 16;
           R3 = _s45RP::P64;
           R2 = _s45RO::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wreadIntP'_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4606() //  [R1]
         { info_tbl: [(c4606,
                       label: block_c4606_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4606: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c460g; else goto c460f;
       c460g: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c460f: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.readOct_entry() //  [R2, R3]
         { info_tbl: [(c460h,
                       label: Numeric.readOct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c460h: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c460l; else goto c460k;
       c460l: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readOct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c460k: // global
           I64[Hp - 24] = sat_s45RT_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.234929263 UTC

[section ""data" . Numeric.readDec_closure" {
     Numeric.readDec_closure:
         const Numeric.readDec_info;
         const 0;
 },
 sat_s45RW_entry() //  [R1]
         { info_tbl: [(c460Y,
                       label: sat_s45RW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c460Y: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c460Z; else goto c4610;
       c460Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4610: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.Read.Lex.numberToFixed1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s45RZ_entry() //  [R1]
         { info_tbl: [(c4614,
                       label: sat_s45RZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4614: // global
           _s45RZ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c4615; else goto c4616;
       c4616: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4618; else goto c4617;
       c4618: // global
           HpAlloc = 24;
           goto c4615;
       c4615: // global
           R1 = _s45RZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4617: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s45RZ::P64;
           _s45RU::P64 = P64[_s45RZ::P64 + 16];
           _s45RV::P64 = P64[_s45RZ::P64 + 24];
           I64[Hp - 16] = sat_s45RW_info;
           P64[Hp] = _s45RV::P64;
           I64[Sp - 24] = block_c4611_info;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = Hp - 16;
           R3 = _s45RV::P64;
           R2 = _s45RU::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wreadIntP'_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4611() //  [R1]
         { info_tbl: [(c4611,
                       label: block_c4611_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4611: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c461b; else goto c461a;
       c461b: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c461a: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.readDec_entry() //  [R2, R3]
         { info_tbl: [(c461c,
                       label: Numeric.readDec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c461c: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c461g; else goto c461f;
       c461g: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readDec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c461f: // global
           I64[Hp - 24] = sat_s45RZ_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.245761399 UTC

[section ""data" . Numeric.readHex_closure" {
     Numeric.readHex_closure:
         const Numeric.readHex_info;
         const 0;
 },
 sat_s45S2_entry() //  [R1]
         { info_tbl: [(c461T,
                       label: sat_s45S2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c461T: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c461U; else goto c461V;
       c461U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c461V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.Read.Lex.readDecP3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s45S5_entry() //  [R1]
         { info_tbl: [(c461Z,
                       label: sat_s45S5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c461Z: // global
           _s45S5::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c4620; else goto c4621;
       c4621: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4623; else goto c4622;
       c4623: // global
           HpAlloc = 24;
           goto c4620;
       c4620: // global
           R1 = _s45S5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4622: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s45S5::P64;
           _s45S0::P64 = P64[_s45S5::P64 + 16];
           _s45S1::P64 = P64[_s45S5::P64 + 24];
           I64[Hp - 16] = sat_s45S2_info;
           P64[Hp] = _s45S1::P64;
           I64[Sp - 24] = block_c461W_info;
           R5 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R4 = Hp - 16;
           R3 = _s45S1::P64;
           R2 = _s45S0::P64;
           Sp = Sp - 24;
           call Text.Read.Lex.$wreadIntP'_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _c461W() //  [R1]
         { info_tbl: [(c461W,
                       label: block_c461W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c461W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4626; else goto c4625;
       c4626: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4625: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.readHex_entry() //  [R2, R3]
         { info_tbl: [(c4627,
                       label: Numeric.readHex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4627: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c462b; else goto c462a;
       c462b: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readHex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c462a: // global
           I64[Hp - 24] = sat_s45S5_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.255845706 UTC

[section ""data" . Numeric.readFloat2_closure" {
     Numeric.readFloat2_closure:
         const Numeric.readFloat2_info;
 },
 Numeric.readFloat2_entry() //  [R2]
         { info_tbl: [(c462J,
                       label: Numeric.readFloat2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c462J: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c462K; else goto c462L;
       c462K: // global
           R2 = R2;
           R1 = Numeric.readFloat2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c462L: // global
           I64[Sp - 8] = block_c462G_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u462P; else goto c462H;
       u462P: // global
           call _c462G() args: 0, res: 0, upd: 0;
       c462H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c462G() //  []
         { info_tbl: [(c462G,
                       label: block_c462G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c462G: // global
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.261716284 UTC

[section ""data" . Numeric.readFloat1_closure" {
     Numeric.readFloat1_closure:
         const Text.ParserCombinators.ReadP.Look_con_info;
         const Numeric.readFloat2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.265277362 UTC

[section ""data" . Numeric.readFloat_closure" {
     Numeric.readFloat_closure:
         const Numeric.readFloat_info;
         const 0;
 },
 $dFractional_s45Sa_entry() //  [R1]
         { info_tbl: [(c463j,
                       label: $dFractional_s45Sa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c463j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c463k; else goto c463l;
       c463k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c463l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2RealFrac_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s45Sh_entry() //  [R1]
         { info_tbl: [(c463I,
                       label: sat_s45Sh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c463I: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c463J; else goto c463K;
       c463J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c463K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c463F_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Text.Read.Lex.$wnumberToRational_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c463F() //  [R1, R2]
         { info_tbl: [(c463F,
                       label: block_c463F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c463F: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c463N; else goto c463M;
       c463N: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c463M: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s45Si_entry() //  [R1]
         { info_tbl: [(c463O,
                       label: sat_s45Si_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c463O: // global
           _s45Si::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c463P; else goto c463Q;
       c463Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c463S; else goto c463R;
       c463S: // global
           HpAlloc = 24;
           goto c463P;
       c463P: // global
           R1 = _s45Si::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c463R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s45Si::P64;
           _s45Sa::P64 = P64[_s45Si::P64 + 16];
           _s45Sd::P64 = P64[_s45Si::P64 + 24];
           I64[Hp - 16] = sat_s45Sh_info;
           P64[Hp] = _s45Sd::P64;
           R2 = _s45Sa::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Real.fromRational_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s45Sj_entry() //  [R1, R2]
         { info_tbl: [(c463X,
                       label: sat_s45Sj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c463X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c463Y; else goto c463Z;
       c463Y: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c463Z: // global
           I64[Sp - 16] = block_c463r_info;
           _s45Sa::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s45Sa::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4646; else goto c463s;
       u4646: // global
           call _c463r(R1) args: 0, res: 0, upd: 0;
       c463s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c463r() //  [R1]
         { info_tbl: [(c463r,
                       label: block_c463r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c463r: // global
           if (R1 & 7 == 6) goto c463V; else goto c463U;
       c463V: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4645; else goto c4644;
       c4645: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4644: // global
           _s45Sd::P64 = P64[R1 + 2];
           I64[Hp - 48] = sat_s45Si_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s45Sd::P64;
           I64[Hp - 16] = Text.ParserCombinators.ReadP.Result_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Text.ParserCombinators.ReadP.Fail_closure+3;
           R1 = Hp - 12;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c463U: // global
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s45Sk_entry() //  [R1]
         { info_tbl: [(c4647,
                       label: sat_s45Sk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4647: // global
           _s45Sk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4648; else goto c4649;
       c4649: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c464b; else goto c464a;
       c464b: // global
           HpAlloc = 40;
           goto c4648;
       c4648: // global
           R1 = _s45Sk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c464a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s45Sk::P64;
           _s45S8::P64 = P64[_s45Sk::P64 + 16];
           I64[Hp - 32] = $dFractional_s45Sa_info;
           P64[Hp - 16] = _s45S8::P64;
           I64[Hp - 8] = sat_s45Sj_info;
           P64[Hp] = Hp - 32;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Text.Read.Lex.expect2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl116_s45S9_entry() //  [R1]
         { info_tbl: [(c464c,
                       label: lvl116_s45S9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c464c: // global
           _s45S9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c464d; else goto c464e;
       c464e: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c464g; else goto c464f;
       c464g: // global
           HpAlloc = 24;
           goto c464d;
       c464d: // global
           R1 = _s45S9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c464f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s45S9::P64;
           _s45S8::P64 = P64[_s45S9::P64 + 16];
           I64[Hp - 16] = sat_s45Sk_info;
           P64[Hp] = _s45S8::P64;
           R3 = Hp - 16;
           R2 = Numeric.readFloat1_closure+2;
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 k_s45Sl_entry() //  [R1]
         { info_tbl: [(c464m,
                       label: k_s45Sl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c464m: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s45So_entry() //  [R1, R2]
         { info_tbl: [(c464u,
                       label: sat_s45So_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c464u: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           call Text.ParserCombinators.ReadP.skipSpaces2_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 Numeric.readFloat_entry() //  [R2]
         { info_tbl: [(c464y,
                       label: Numeric.readFloat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c464y: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c464C; else goto c464B;
       c464C: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Numeric.readFloat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c464B: // global
           I64[Hp - 64] = lvl116_s45S9_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = k_s45Sl_info;
           P64[Hp - 32] = Hp - 64;
           I64[Hp - 24] = sat_s45So_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.292105731 UTC

[section ""data" . Numeric.readSigned_closure" {
     Numeric.readSigned_closure:
         const Numeric.readSigned_info;
         const 0;
 },
 $dNum_s45St_entry() //  [R1]
         { info_tbl: [(c4661,
                       label: $dNum_s45St_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4661: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4662; else goto c4663;
       c4662: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4663: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go1_s45SD_entry() //  [R1, R2]
         { info_tbl: [(c466x,
                       label: go1_s45SD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c466x: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c466y; else goto u4674;
       c466y: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u4674: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _c466n() args: 0, res: 0, upd: 0;
     }
 },
 _c466n() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c466n: // global
           I64[Sp - 16] = block_c466q_info;
           R1 = P64[Sp + 8];
           _s45SD::P64 = P64[Sp];
           P64[Sp - 8] = P64[_s45SD::P64 + 15];
           P64[Sp + 8] = P64[_s45SD::P64 + 7];
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4676; else goto c466r;
       u4676: // global
           call _c466q(R1) args: 0, res: 0, upd: 0;
       c466r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c466q() //  [R1]
         { info_tbl: [(c466q,
                       label: block_c466q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c466q: // global
           if (R1 & 7 == 1) goto c466u; else goto c466v;
       c466u: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c466v: // global
           I64[Sp] = block_c466F_info;
           _s45SH::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 8] = _s45SH::P64;
           if (R1 & 7 != 0) goto u4677; else goto c466H;
       u4677: // global
           call _c466F(R1) args: 0, res: 0, upd: 0;
       c466H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c466F() //  [R1]
         { info_tbl: [(c466F,
                       label: block_c466F_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c466F: // global
           I64[Sp - 8] = block_c466L_info;
           _s45SJ::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s45SJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4679; else goto c466N;
       u4679: // global
           call _c466L(R1) args: 0, res: 0, upd: 0;
       c466N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c466L() //  [R1]
         { info_tbl: [(c466L,
                       label: block_c466L_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c466L: // global
           _s45SH::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c466V; else goto c4672;
       c466V: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c466Y; else goto c466X;
       c466Y: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c466X: // global
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _s45SH::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 32];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4672: // global
           P64[Sp + 32] = _s45SH::P64;
           Sp = Sp + 24;
           call _c466n() args: 0, res: 0, upd: 0;
     }
 },
 go_s45Su_entry() //  [R1, R2]
         { info_tbl: [(c467f,
                       label: go_s45Su_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c467f: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c467g; else goto c467h;
       c467g: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c467h: // global
           I64[Sp - 24] = block_c4669_info;
           _s45Su::P64 = R1;
           _s45Sr::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s45Sr::P64;
           P64[Sp - 8] = _s45Su::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u467u; else goto c466a;
       u467u: // global
           call _c4669(R1) args: 0, res: 0, upd: 0;
       c466a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4669() //  [R1]
         { info_tbl: [(c4669,
                       label: block_c4669_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4669: // global
           if (R1 & 7 == 1) goto c467c; else goto c467d;
       c467c: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c467d: // global
           I64[Sp - 8] = block_c466f_info;
           _s45Sy::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s45Sy::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u467t; else goto c466g;
       u467t: // global
           call _c466f(R1) args: 0, res: 0, upd: 0;
       c466g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c466f() //  [R1]
         { info_tbl: [(c466f,
                       label: block_c466f_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c466f: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c467o; else goto c467n;
       c467o: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c467n: // global
           _s45SA::P64 = P64[R1 + 7];
           _s45SB::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = go1_s45SD_info;
           P64[Hp - 8] = _s45SB::P64;
           P64[Hp] = Hp - 48;
           _s45Sr::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c467k_info;
           R2 = _s45SA::P64;
           R1 = _s45Sr::P64;
           P64[Sp + 24] = Hp - 15;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c467k() //  [R1]
         { info_tbl: [(c467k,
                       label: block_c467k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c467k: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_s45SD_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s45Tf_entry() //  [R1]
         { info_tbl: [(c468q,
                       label: sat_s45Tf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c468q: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c468r; else goto c468s;
       c468r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c468s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go2_s45T7_entry() //  [R1, R2]
         { info_tbl: [(c468x,
                       label: go2_s45T7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c468x: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c468y; else goto c468z;
       c468y: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c468z: // global
           I64[Sp - 32] = block_c468a_info;
           _s45T7::P64 = R1;
           _s45St::P64 = P64[R1 + 7];
           _s45T6::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s45St::P64;
           P64[Sp - 16] = _s45T6::P64;
           P64[Sp - 8] = _s45T7::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u468J; else goto c468b;
       u468J: // global
           call _c468a(R1) args: 0, res: 0, upd: 0;
       c468b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c468a() //  [R1]
         { info_tbl: [(c468a,
                       label: block_c468a_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c468a: // global
           if (R1 & 7 == 1) goto c468u; else goto c468v;
       c468u: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c468v: // global
           I64[Sp] = block_c468g_info;
           _s45Tb::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _s45Tb::P64;
           if (R1 & 7 != 0) goto u468I; else goto c468h;
       u468I: // global
           call _c468g(R1) args: 0, res: 0, upd: 0;
       c468h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c468g() //  [R1]
         { info_tbl: [(c468g,
                       label: block_c468g_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c468g: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c468H; else goto c468G;
       c468H: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c468G: // global
           _s45Td::P64 = P64[R1 + 7];
           _s45Te::P64 = P64[R1 + 15];
           I64[Hp - 104] = stg_ap_2_upd_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 16];
           I64[Hp - 72] = sat_s45Tf_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _s45Td::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = _s45Te::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 104;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go1_s45SR_entry() //  [R1, R2]
         { info_tbl: [(c468O,
                       label: go1_s45SR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c468O: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c468P; else goto u469q;
       c468P: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u469q: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _c467x() args: 0, res: 0, upd: 0;
     }
 },
 _c467x() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c467x: // global
           I64[Sp - 16] = block_c467A_info;
           R1 = P64[Sp + 8];
           _s45SR::P64 = P64[Sp];
           P64[Sp - 8] = P64[_s45SR::P64 + 15];
           P64[Sp + 8] = P64[_s45SR::P64 + 7];
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u469v; else goto c467B;
       u469v: // global
           call _c467A(R1) args: 0, res: 0, upd: 0;
       c467B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c467A() //  [R1]
         { info_tbl: [(c467A,
                       label: block_c467A_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c467A: // global
           if (R1 & 7 == 1) goto c468L; else goto c468M;
       c468L: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c468M: // global
           I64[Sp - 8] = block_c467G_info;
           _s45SV::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s45SV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u469w; else goto c467H;
       u469w: // global
           call _c467G(R1) args: 0, res: 0, upd: 0;
       c467H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c467G() //  [R1]
         { info_tbl: [(c467G,
                       label: block_c467G_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c467G: // global
           I64[Sp - 8] = block_c467L_info;
           _s45SY::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s45SY::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u469x; else goto c467M;
       u469x: // global
           call _c467L(R1) args: 0, res: 0, upd: 0;
       c467M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c467L() //  [R1]
         { info_tbl: [(c467L,
                       label: block_c467L_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c467L: // global
           if (R1 & 7 == 1) goto u469r; else goto c4690;
       u469r: // global
           Sp = Sp + 16;
           call _c469n() args: 0, res: 0, upd: 0;
       c4690: // global
           I64[Sp - 8] = block_c467R_info;
           _s45T1::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s45T1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u469y; else goto c467S;
       u469y: // global
           call _c467R(R1) args: 0, res: 0, upd: 0;
       c467S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c467R() //  [R1]
         { info_tbl: [(c467R,
                       label: block_c467R_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c467R: // global
           if (I64[R1 + 7] == 45) goto c4694; else goto u469s;
       c4694: // global
           _s45T1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c467Z_info;
           R1 = _s45T1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u469A; else goto c4680;
       u469A: // global
           call _c467Z(R1) args: 0, res: 0, upd: 0;
       c4680: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u469s: // global
           Sp = Sp + 24;
           call _c469n() args: 0, res: 0, upd: 0;
     }
 },
 _c467Z() //  [R1]
         { info_tbl: [(c467Z,
                       label: block_c467Z_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c467Z: // global
           if (R1 & 7 == 1) goto c469b; else goto u469t;
       c469b: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c469e; else goto c469d;
       c469e: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c469d: // global
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = go2_s45T7_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = Hp - 48;
           I64[Sp + 16] = block_c4695_info;
           R3 = P64[Sp + 8];
           R2 = GHC.Read.lex1_closure;
           P64[Sp + 40] = Hp - 15;
           Sp = Sp + 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       u469t: // global
           Sp = Sp + 16;
           call _c469n() args: 0, res: 0, upd: 0;
     }
 },
 _c4695() //  [R1]
         { info_tbl: [(c4695,
                       label: block_c4695_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4695: // global
           I64[Sp + 16] = block_c4699_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_s45Su_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4699() //  [R1]
         { info_tbl: [(c4699,
                       label: block_c4699_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4699: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go2_s45T7_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c469n() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c469n: // global
           P64[Sp + 24] = P64[Sp];
           Sp = Sp + 16;
           call _c467x() args: 0, res: 0, upd: 0;
     }
 },
 sat_s45Tq_entry() //  [R1]
         { info_tbl: [(c469Q,
                       label: sat_s45Tq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c469Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c469R; else goto c469S;
       c469R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c469S: // global
           I64[Sp - 16] = block_c469O_info;
           R3 = P64[R1 + 24];
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 8] = P64[R1 + 16];
           Sp = Sp - 16;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c469O() //  [R1]
         { info_tbl: [(c469O,
                       label: block_c469O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c469O: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_s45SR_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s45Tr_entry() //  [R1, R2]
         { info_tbl: [(c469Y,
                       label: sat_s45Tr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c469Y: // global
           _s45Tm::P64 = R2;
           _s45Tr::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c46a2; else goto c46a3;
       c46a3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c46a5; else goto c46a4;
       c46a5: // global
           HpAlloc = 32;
           goto c46a2;
       c46a2: // global
           R2 = _s45Tm::P64;
           R1 = _s45Tr::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c46a4: // global
           _s45Su::P64 = P64[_s45Tr::P64 + 7];
           _s45SR::P64 = P64[_s45Tr::P64 + 15];
           I64[Hp - 24] = sat_s45Tq_info;
           P64[Hp - 8] = _s45SR::P64;
           P64[Hp] = _s45Tm::P64;
           I64[Sp - 24] = block_c469W_info;
           R3 = _s45Tm::P64;
           R2 = GHC.Read.lex1_closure;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _s45Su::P64;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c469W() //  [R1]
         { info_tbl: [(c469W,
                       label: block_c469W_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c469W: // global
           I64[Sp] = block_c46a1_info;
           R2 = R1;
           R1 = P64[Sp + 16];
           call go_s45Su_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46a1() //  [R1]
         { info_tbl: [(c46a1,
                       label: block_c46a1_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46a1: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Numeric.readSigned_entry() //  [R2, R3, R4]
         { info_tbl: [(c46ab,
                       label: Numeric.readSigned_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46ab: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c46af; else goto c46ae;
       c46af: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.readSigned_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c46ae: // global
           I64[Hp - 80] = $dNum_s45St_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = go_s45Su_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = go1_s45SR_info;
           P64[Hp - 32] = Hp - 80;
           _c4664::P64 = Hp - 55;
           P64[Hp - 24] = _c4664::P64;
           I64[Hp - 16] = sat_s45Tr_info;
           P64[Hp - 8] = _c4664::P64;
           P64[Hp] = Hp - 39;
           R4 = R4;
           R3 = Hp - 15;
           R2 = GHC.Types.False_closure+1;
           call GHC.Read.readParen_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.352559477 UTC

[section ""data" . sat_s45Ts_closure" {
     sat_s45Ts_closure:
         const GHC.Types.I#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.354368814 UTC

[section ""data" . sat_s45Tt_closure" {
     sat_s45Tt_closure:
         const :_con_info;
         const sat_s45Ts_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.356228007 UTC

[section ""data" . Numeric.showInt2_closure" {
     Numeric.showInt2_closure:
         const Numeric.showInt2_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showInt2_entry() //  [R1]
         { info_tbl: [(c46dC,
                       label: Numeric.showInt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46dC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46dD; else goto c46dE;
       c46dD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46dE: // global
           (_c46dz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c46dz::I64 == 0) goto c46dB; else goto c46dA;
       c46dB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c46dA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c46dz::I64;
           R3 = sat_s45Tt_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.360868805 UTC

[section ""cstring" . lvl_r43OH_bytes" {
     lvl_r43OH_bytes:
         I8[] [78,117,109,101,114,105,99,46,115,104,111,119,73,110,116,58,32,99,97,110,39,116,32,115,104,111,119,32,110,101,103,97,116,105,118,101,32,110,117,109,98,101,114,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.362889466 UTC

[section ""data" . Numeric.showInt1_closure" {
     Numeric.showInt1_closure:
         const Numeric.showInt1_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showInt1_entry() //  [R1]
         { info_tbl: [(c46dX,
                       label: Numeric.showInt1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46dX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c46dY; else goto c46dZ;
       c46dY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46dZ: // global
           (_c46dS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c46dS::I64 == 0) goto c46dU; else goto c46dT;
       c46dU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c46dT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c46dS::I64;
           I64[Sp - 24] = block_c46dV_info;
           R2 = lvl_r43OH_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c46dV() //  [R1]
         { info_tbl: [(c46dV,
                       label: block_c46dV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46dV: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.368903302 UTC

[section ""data" . Numeric.showHFloat16_closure" {
     Numeric.showHFloat16_closure:
         const Numeric.showHFloat16_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat16_entry() //  [R1]
         { info_tbl: [(c46el,
                       label: Numeric.showHFloat16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46el: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46em; else goto c46en;
       c46em: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46en: // global
           (_c46ei::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c46ei::I64 == 0) goto c46ek; else goto c46ej;
       c46ek: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c46ej: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c46ei::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.375315416 UTC

[section ""data" . Numeric.showInt_closure" {
     Numeric.showInt_closure:
         const Numeric.showInt_info;
         const 0;
 },
 sat_s45TB_entry() //  [R1]
         { info_tbl: [(c46fv,
                       label: sat_s45TB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46fv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46fw; else goto c46fx;
       c46fw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46fx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c46ft_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c46ft() //  [R1]
         { info_tbl: [(c46ft,
                       label: block_c46ft_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46ft: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showHFloat16_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl5_s45TD_entry() //  [R1]
         { info_tbl: [(c46fF,
                       label: lvl5_s45TD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46fF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46fG; else goto c46fH;
       c46fG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46fH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c46fD_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c46fD() //  [R1]
         { info_tbl: [(c46fD,
                       label: block_c46fD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46fD: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showInt2_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s45TS_entry() //  [R1]
         { info_tbl: [(c46fN,
                       label: ds_s45TS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46fN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c46fO; else goto c46fP;
       c46fO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46fP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quotRem_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Numeric.showInt_entry() //  [R2, R3, R4]
         { info_tbl: [(c46fQ,
                       label: Numeric.showInt_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46fQ: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c46fR; else goto c46fS;
       c46fR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showInt_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c46fS: // global
           I64[Sp - 32] = block_c46eC_info;
           _s45Tv::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _s45Tv::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c46eC() //  [R1]
         { info_tbl: [(c46eC,
                       label: block_c46eC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46eC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c46fV; else goto c46fU;
       c46fV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c46fU: // global
           I64[Hp - 16] = sat_s45TB_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c46eI_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c46eI() //  [R1]
         { info_tbl: [(c46eI,
                       label: block_c46eI_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46eI: // global
           I64[Sp] = block_c46eM_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c46eM() //  [R1]
         { info_tbl: [(c46eM,
                       label: block_c46eM_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46eM: // global
           if (R1 & 7 == 1) goto c46fY; else goto c46gI;
       c46fY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c46g1; else goto c46g0;
       c46g1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c46g0: // global
           I64[Hp - 16] = lvl5_s45TD_info;
           _s45Ty::P64 = P64[Sp + 8];
           P64[Hp] = _s45Ty::P64;
           I64[Sp + 8] = block_c46eS_info;
           R2 = _s45Ty::P64;
           P64[Sp + 16] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
       c46gI: // global
           R1 = Numeric.showInt1_closure;
           Sp = Sp + 48;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c46eS() //  [R1]
         { info_tbl: [(c46eS,
                       label: block_c46eS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46eS: // global
           P64[Sp] = P64[Sp + 32];
           P64[Sp + 24] = P64[Sp + 24];
           P64[Sp + 32] = R1;
           call _c46f1() args: 0, res: 0, upd: 0;
     }
 },
 _c46f1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46f1: // global
           I64[Sp - 8] = block_c46f3_info;
           R2 = P64[Sp + 32];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 24];
           P64[Sp - 16] = P64[Sp + 8];
           Sp = Sp - 32;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c46f3() //  [R1]
         { info_tbl: [(c46f3,
                       label: block_c46f3_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46f3: // global
           _s45Tv::P64 = P64[Sp + 24];
           _s45TP::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c46gt; else goto c46gE;
       c46gt: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c46gw; else goto c46gv;
       c46gw: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c46gv: // global
           I64[Hp - 56] = ds_s45TS_info;
           P64[Hp - 40] = _s45Tv::P64;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s45TP::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           _c46f7::P64 = Hp - 56;
           P64[Hp] = _c46f7::P64;
           I64[Sp] = block_c46fa_info;
           R2 = _s45Tv::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           P64[Sp + 32] = _c46f7::P64;
           Sp = Sp - 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
       c46gE: // global
           I64[Sp + 32] = block_c46g6_info;
           R2 = _s45Tv::P64;
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = _s45TP::P64;
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c46fa() //  [R1]
         { info_tbl: [(c46fa,
                       label: block_c46fa_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46fa: // global
           I64[Sp] = block_c46fe_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c46fe() //  [R1]
         { info_tbl: [(c46fe,
                       label: block_c46fe_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46fe: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c46gA; else goto c46gz;
       c46gA: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c46gz: // global
           I64[Hp - 56] = GHC.Types.C#_con_info;
           I64[Hp - 48] = R1 + 48;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 55;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = P64[Sp + 32];
           P64[Sp + 32] = Hp - 16;
           P64[Sp + 8] = Hp - 38;
           Sp = Sp + 8;
           call _c46f1() args: 0, res: 0, upd: 0;
     }
 },
 _c46g6() //  [R1]
         { info_tbl: [(c46g6,
                       label: block_c46g6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46g6: // global
           I64[Sp] = block_c46ga_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c46ga() //  [R1]
         { info_tbl: [(c46ga,
                       label: block_c46ga_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46ga: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c46gq; else goto c46gp;
       c46gq: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c46gp: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = R1 + 48;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.40791005 UTC

[section ""data" . Numeric.showFFloatAlt_closure" {
     Numeric.showFFloatAlt_closure:
         const Numeric.showFFloatAlt_info;
         const 0;
 },
 sat_s45Ua_entry() //  [R1]
         { info_tbl: [(c46iL,
                       label: sat_s45Ua_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46iL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46iM; else goto c46iN;
       c46iM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46iN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.True_closure+2;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFFixed_closure+2;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showFFloatAlt_entry() //  [R2, R3, R4]
         { info_tbl: [(c46iO,
                       label: Numeric.showFFloatAlt_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46iO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c46iS; else goto c46iR;
       c46iS: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showFFloatAlt_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c46iR: // global
           I64[Hp - 32] = sat_s45Ua_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.414385605 UTC

[section ""data" . Numeric.showGFloatAlt_closure" {
     Numeric.showGFloatAlt_closure:
         const Numeric.showGFloatAlt_info;
         const 0;
 },
 sat_s45Ue_entry() //  [R1]
         { info_tbl: [(c46je,
                       label: sat_s45Ue_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46je: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46jf; else goto c46jg;
       c46jf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46jg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.True_closure+2;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFGeneric_closure+3;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showGFloatAlt_entry() //  [R2, R3, R4]
         { info_tbl: [(c46jh,
                       label: Numeric.showGFloatAlt_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46jh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c46jl; else goto c46jk;
       c46jl: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showGFloatAlt_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c46jk: // global
           I64[Hp - 32] = sat_s45Ue_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.420192275 UTC

[section ""cstring" . lvl1_r43OI_bytes" {
     lvl1_r43OI_bytes:
         I8[] [78,117,109,101,114,105,99,46,115,104,111,119,73,110,116,65,116,66,97,115,101,58,32,97,112,112,108,105,101,100,32,116,111,32,110,101,103,97,116,105,118,101,32,110,117,109,98,101,114,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.422484014 UTC

[section ""data" . Numeric.$wlvl_closure" {
     Numeric.$wlvl_closure:
         const Numeric.$wlvl_info;
         const 0;
 },
 sat_s45Uj_entry() //  [R1]
         { info_tbl: [(c46jL,
                       label: sat_s45Uj_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46jL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c46jM; else goto c46jN;
       c46jM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46jN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c46jI_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c46jI() //  [R1, R2]
         { info_tbl: [(c46jI,
                       label: block_c46jI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46jI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c46jQ; else goto c46jP;
       c46jQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c46jP: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.$wlvl_entry() //  [R2]
         { info_tbl: [(c46jT,
                       label: Numeric.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46jT: // global
           _s45Uf::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c46jU; else goto c46jV;
       c46jV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c46jX; else goto c46jW;
       c46jX: // global
           HpAlloc = 24;
           goto c46jU;
       c46jU: // global
           R2 = _s45Uf::I64;
           R1 = Numeric.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c46jW: // global
           I64[Hp - 16] = sat_s45Uj_info;
           I64[Hp] = _s45Uf::I64;
           I64[Sp - 8] = block_c46jR_info;
           R3 = Hp - 16;
           R2 = lvl1_r43OI_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c46jR() //  [R1]
         { info_tbl: [(c46jR,
                       label: block_c46jR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46jR: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.431654213 UTC

[section ""cstring" . lvl2_r43OJ_bytes" {
     lvl2_r43OJ_bytes:
         I8[] [78,117,109,101,114,105,99,46,115,104,111,119,73,110,116,65,116,66,97,115,101,58,32,97,112,112,108,105,101,100,32,116,111,32,117,110,115,117,112,112,111,114,116,101,100,32,98,97,115,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.433936351 UTC

[section ""data" . Numeric.showIntAtBase2_closure" {
     Numeric.showIntAtBase2_closure:
         const Numeric.showIntAtBase2_info;
         const 0;
 },
 sat_s45Un_entry() //  [R1]
         { info_tbl: [(c46kw,
                       label: sat_s45Un_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46kw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46kx; else goto c46ky;
       c46kx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46ky: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Numeric.showIntAtBase2_entry() //  [R2, R3]
         { info_tbl: [(c46kB,
                       label: Numeric.showIntAtBase2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46kB: // global
           _s45Um::P64 = R3;
           _s45Ul::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c46kC; else goto c46kD;
       c46kD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c46kF; else goto c46kE;
       c46kF: // global
           HpAlloc = 32;
           goto c46kC;
       c46kC: // global
           R3 = _s45Um::P64;
           R2 = _s45Ul::P64;
           R1 = Numeric.showIntAtBase2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c46kE: // global
           I64[Hp - 24] = sat_s45Un_info;
           P64[Hp - 8] = _s45Ul::P64;
           P64[Hp] = _s45Um::P64;
           I64[Sp - 8] = block_c46kz_info;
           R3 = Hp - 24;
           R2 = lvl1_r43OI_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c46kz() //  [R1]
         { info_tbl: [(c46kz,
                       label: block_c46kz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46kz: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.442038611 UTC

[section ""data" . Numeric.showIntAtBase1_closure" {
     Numeric.showIntAtBase1_closure:
         const Numeric.showIntAtBase1_info;
         const 0;
 },
 sat_s45Ur_entry() //  [R1]
         { info_tbl: [(c46l8,
                       label: sat_s45Ur_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46l8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46l9; else goto c46la;
       c46l9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46la: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Numeric.showIntAtBase1_entry() //  [R2, R3]
         { info_tbl: [(c46ld,
                       label: Numeric.showIntAtBase1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46ld: // global
           _s45Uq::P64 = R3;
           _s45Up::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c46le; else goto c46lf;
       c46lf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c46lh; else goto c46lg;
       c46lh: // global
           HpAlloc = 32;
           goto c46le;
       c46le: // global
           R3 = _s45Uq::P64;
           R2 = _s45Up::P64;
           R1 = Numeric.showIntAtBase1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c46lg: // global
           I64[Hp - 24] = sat_s45Ur_info;
           P64[Hp - 8] = _s45Up::P64;
           P64[Hp] = _s45Uq::P64;
           I64[Sp - 8] = block_c46lb_info;
           R3 = Hp - 24;
           R2 = lvl2_r43OJ_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c46lb() //  [R1]
         { info_tbl: [(c46lb,
                       label: block_c46lb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46lb: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.449116649 UTC

[section ""data" . sat_s45Ut_closure" {
     sat_s45Ut_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.450821265 UTC

[section ""data" . sat_s45Uu_closure" {
     sat_s45Uu_closure:
         const :_con_info;
         const sat_s45Ut_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.452770403 UTC

[section ""data" . Numeric.showIntAtBase3_closure" {
     Numeric.showIntAtBase3_closure:
         const Numeric.showIntAtBase3_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showIntAtBase3_entry() //  [R1]
         { info_tbl: [(c46lK,
                       label: Numeric.showIntAtBase3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46lK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46lL; else goto c46lM;
       c46lL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46lM: // global
           (_c46lH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c46lH::I64 == 0) goto c46lJ; else goto c46lI;
       c46lJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c46lI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c46lH::I64;
           R3 = sat_s45Uu_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.460121372 UTC

[section ""data" . Numeric.showIntAtBase_closure" {
     Numeric.showIntAtBase_closure:
         const Numeric.showIntAtBase_info;
         const 0;
 },
 $dNum_s45UC_entry() //  [R1]
         { info_tbl: [(c46mS,
                       label: $dNum_s45UC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46mS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46mT; else goto c46mU;
       c46mT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46mU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s45UE_entry() //  [R1]
         { info_tbl: [(c46mX,
                       label: sat_s45UE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46mX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46mY; else goto c46mZ;
       c46mY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46mZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showIntAtBase3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s45UG_entry() //  [R1]
         { info_tbl: [(c46n2,
                       label: sat_s45UG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46n2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46n3; else goto c46n4;
       c46n3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46n4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showHFloat16_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl5_s45UL_entry() //  [R1]
         { info_tbl: [(c46n7,
                       label: lvl5_s45UL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46n7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46n8; else goto c46n9;
       c46n8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46n9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showHFloat16_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s45UT_entry() //  [R1]
         { info_tbl: [(c46ne,
                       label: sat_s45UT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46ne: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c46nm; else goto c46nn;
       c46nm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46nn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c46nc_info;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c46nc() //  [R1]
         { info_tbl: [(c46nc,
                       label: block_c46nc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46nc: // global
           I64[Sp] = block_c46nh_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c46nh() //  [R1]
         { info_tbl: [(c46nh,
                       label: block_c46nh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46nh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c46nr; else goto c46nq;
       c46nr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c46nq: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showIntAtBase_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c46ns,
                       label: Numeric.showIntAtBase_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46ns: // global
           if ((Sp + -88) < SpLim) (likely: False) goto c46nt; else goto c46nu;
       c46nt: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showIntAtBase_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c46nu: // global
           I64[Sp - 48] = block_c46m0_info;
           _s45Uv::P64 = R2;
           R2 = R2;
           P64[Sp - 40] = _s45Uv::P64;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c46m0() //  [R1]
         { info_tbl: [(c46m0,
                       label: block_c46m0_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46m0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c46nx; else goto c46nw;
       c46nx: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c46nw: // global
           I64[Hp - 16] = $dNum_s45UC_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c46m6_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c46m6() //  [R1]
         { info_tbl: [(c46m6,
                       label: block_c46m6_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46m6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c46nA; else goto c46nz;
       c46nA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c46nz: // global
           I64[Hp - 16] = sat_s45UE_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c46mc_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 32];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c46mc() //  [R1]
         { info_tbl: [(c46mc,
                       label: block_c46mc_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46mc: // global
           if (R1 & 7 == 1) goto c46nC; else goto c46ob;
       c46nC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c46nF; else goto c46nE;
       c46nF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c46nE: // global
           I64[Hp - 16] = sat_s45UG_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp] = block_c46mi_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 56];
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
       c46ob: // global
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           Sp = Sp + 72;
           call Numeric.showIntAtBase1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c46mi() //  [R1]
         { info_tbl: [(c46mi,
                       label: block_c46mi_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46mi: // global
           _s45Uz::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto c46nI; else goto c46o7;
       c46nI: // global
           I64[Sp] = block_c46mm_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s45Uz::P64;
           P64[Sp - 8] = P64[Sp + 40];
           Sp = Sp - 24;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 8;
       c46o7: // global
           R3 = _s45Uz::P64;
           R2 = P64[Sp + 32];
           Sp = Sp + 72;
           call Numeric.showIntAtBase2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c46mm() //  [R1]
         { info_tbl: [(c46mm,
                       label: block_c46mm_info
                       rep:StackRep [False, False, False, True, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46mm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c46nL; else goto c46nK;
       c46nL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c46nK: // global
           _s45UJ::P64 = P64[R1 + 7];
           _s45UK::P64 = P64[R1 + 15];
           I64[Hp - 16] = lvl5_s45UL_info;
           P64[Hp] = P64[Sp + 16];
           _s45UD::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c46ms_info;
           R2 = _s45UD::P64;
           P64[Sp + 16] = _s45UK::P64;
           P64[Sp + 32] = _s45UJ::P64;
           P64[Sp + 56] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c46ms() //  [R1]
         { info_tbl: [(c46ms,
                       label: block_c46ms_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46ms: // global
           P64[Sp] = P64[Sp + 56];
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 24] = P64[Sp + 24];
           P64[Sp + 56] = R1;
           call _c46mz() args: 0, res: 0, upd: 0;
     }
 },
 _c46mz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46mz: // global
           Hp = Hp + 32;
           _s45UP::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c46nP; else goto c46nO;
       c46nP: // global
           HpAlloc = 32;
           I64[Sp + 8] = block_c46my_info;
           R3 = P64[Sp];
           R2 = _s45UP::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 8;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       c46nO: // global
           I64[Hp - 24] = sat_s45UT_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s45UP::P64;
           I64[Sp - 8] = block_c46mD_info;
           R2 = Hp - 24;
           R1 = P64[Sp + 40];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46my() //  [R1, R2, R3]
         { info_tbl: [(c46my,
                       label: block_c46my_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46my: // global
           P64[Sp + 16] = R1;
           P64[Sp] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 8;
           call _c46mz() args: 0, res: 0, upd: 0;
     }
 },
 _c46mD() //  [R1]
         { info_tbl: [(c46mD,
                       label: block_c46mD_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46mD: // global
           I64[Sp] = block_c46mH_info;
           R2 = P64[Sp + 64];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 56];
           P64[Sp + 16] = R1;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c46mH() //  [R1]
         { info_tbl: [(c46mH,
                       label: block_c46mH_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46mH: // global
           if (R1 & 7 == 1) goto c46nT; else goto c46o0;
       c46nT: // global
           I64[Sp] = block_c46mL_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 40];
           Sp = Sp - 24;
           call GHC.Real.quotRem_entry(R2) args: 32, res: 8, upd: 8;
       c46o0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c46o3; else goto c46o2;
       c46o3: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c46o2: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 14;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c46mL() //  [R1]
         { info_tbl: [(c46mL,
                       label: block_c46mL_info
                       rep:StackRep [False, False, False, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46mL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c46nW; else goto c46nV;
       c46nW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c46nV: // global
           _s45UY::P64 = P64[R1 + 7];
           _s45UZ::P64 = P64[R1 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           P64[Sp + 32] = _s45UY::P64;
           P64[Sp + 16] = _s45UZ::P64;
           P64[Sp + 8] = Hp - 14;
           Sp = Sp + 8;
           call _c46mz() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.497234004 UTC

[section ""data" . sat_s45V1_closure" {
     sat_s45V1_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.498925538 UTC

[section ""data" . sat_s45V2_closure" {
     sat_s45V2_closure:
         const :_con_info;
         const sat_s45V1_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.500855814 UTC

[section ""data" . Numeric.showHex1_closure" {
     Numeric.showHex1_closure:
         const Numeric.showHex1_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHex1_entry() //  [R1]
         { info_tbl: [(c46qB,
                       label: Numeric.showHex1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46qB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46qC; else goto c46qD;
       c46qC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46qD: // global
           (_c46qy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c46qy::I64 == 0) goto c46qA; else goto c46qz;
       c46qA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c46qz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c46qy::I64;
           R3 = sat_s45V2_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.505415755 UTC

[section ""data" . Numeric.showHex_closure" {
     Numeric.showHex_closure:
         const Numeric.showHex_info;
         const 0;
 },
 sat_s45V7_entry() //  [R1]
         { info_tbl: [(c46qX,
                       label: sat_s45V7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46qX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46r1; else goto c46r2;
       c46r1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46r2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c46qV_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c46qV() //  [R1]
         { info_tbl: [(c46qV,
                       label: block_c46qV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46qV: // global
           I64[Sp] = block_c46r0_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c46r0() //  [R1]
         { info_tbl: [(c46r0,
                       label: block_c46r0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46r0: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showHex1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Numeric.showHex_entry() //  [R2, R3]
         { info_tbl: [(c46r8,
                       label: Numeric.showHex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46r8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c46rc; else goto c46rb;
       c46rc: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showHex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c46rb: // global
           I64[Hp - 16] = sat_s45V7_info;
           P64[Hp] = R2;
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showIntAtBase_closure+6;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.514688073 UTC

[section ""cstring" . Numeric.$trModule4_bytes" {
     Numeric.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.516618771 UTC

[section ""data" . loc_r43OK_closure" {
     loc_r43OK_closure:
         const loc_r43OK_info;
         const 0;
         const 0;
         const 0;
 },
 loc_r43OK_entry() //  [R1]
         { info_tbl: [(c46rF,
                       label: loc_r43OK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46rF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46rG; else goto c46rH;
       c46rG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46rH: // global
           (_c46rC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c46rC::I64 == 0) goto c46rE; else goto c46rD;
       c46rE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c46rD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c46rC::I64;
           R2 = Numeric.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.520447 UTC

[section ""cstring" . Numeric.$trModule2_bytes" {
     Numeric.$trModule2_bytes:
         I8[] [78,117,109,101,114,105,99]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.522259529 UTC

[section ""data" . loc1_r43OL_closure" {
     loc1_r43OL_closure:
         const loc1_r43OL_info;
         const 0;
         const 0;
         const 0;
 },
 loc1_r43OL_entry() //  [R1]
         { info_tbl: [(c46rX,
                       label: loc1_r43OL_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46rX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46rY; else goto c46rZ;
       c46rY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46rZ: // global
           (_c46rU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c46rU::I64 == 0) goto c46rW; else goto c46rV;
       c46rW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c46rV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c46rU::I64;
           R2 = Numeric.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.526309365 UTC

[section ""cstring" . loc2_r43OM_bytes" {
     loc2_r43OM_bytes:
         I8[] [78,117,109,101,114,105,99,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.528061941 UTC

[section ""data" . loc3_r43ON_closure" {
     loc3_r43ON_closure:
         const loc3_r43ON_info;
         const 0;
         const 0;
         const 0;
 },
 loc3_r43ON_entry() //  [R1]
         { info_tbl: [(c46sf,
                       label: loc3_r43ON_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46sf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46sg; else goto c46sh;
       c46sg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46sh: // global
           (_c46sc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c46sc::I64 == 0) goto c46se; else goto c46sd;
       c46se: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c46sd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c46sc::I64;
           R2 = loc2_r43OM_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.531841944 UTC

[section ""data" . loc4_r43OO_closure" {
     loc4_r43OO_closure:
         const GHC.Types.I#_con_info;
         const 241;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.533521988 UTC

[section ""data" . loc5_r43OP_closure" {
     loc5_r43OP_closure:
         const GHC.Types.I#_con_info;
         const 22;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.535153916 UTC

[section ""data" . loc6_r43OQ_closure" {
     loc6_r43OQ_closure:
         const GHC.Types.I#_con_info;
         const 75;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.53675213 UTC

[section ""cstring" . $dIP_r43OR_bytes" {
     $dIP_r43OR_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.53859359 UTC

[section ""data" . $dIP1_r43OS_closure" {
     $dIP1_r43OS_closure:
         const $dIP1_r43OS_info;
         const 0;
         const 0;
         const 0;
 },
 $dIP1_r43OS_entry() //  [R1]
         { info_tbl: [(c46sA,
                       label: $dIP1_r43OS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46sA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46sB; else goto c46sC;
       c46sB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46sC: // global
           (_c46sx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c46sx::I64 == 0) goto c46sz; else goto c46sy;
       c46sz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c46sy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c46sx::I64;
           R2 = $dIP_r43OR_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.542441854 UTC

[section ""data" . $dIP2_r43OT_closure" {
     $dIP2_r43OT_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const loc_r43OK_closure;
         const loc1_r43OL_closure;
         const loc3_r43ON_closure;
         const loc4_r43OO_closure+1;
         const loc5_r43OP_closure+1;
         const loc4_r43OO_closure+1;
         const loc6_r43OQ_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.544194764 UTC

[section ""data" . $dIP3_r43OU_closure" {
     $dIP3_r43OU_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const $dIP1_r43OS_closure;
         const $dIP2_r43OT_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.545886317 UTC

[section ""cstring" . lvl3_r43OV_bytes" {
     lvl3_r43OV_bytes:
         I8[] [73,109,112,111,115,115,105,98,108,101,32,104,97,112,112,101,110,101,100,58,32,115,104,111,119,72,70,108,111,97,116,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.547479286 UTC

[section ""data" . lvl4_r43OW_closure" {
     lvl4_r43OW_closure:
         const :_con_info;
         const GHC.Show.$fShow(,)2_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.550092297 UTC

[section ""data" . $wlvl2_r43OX_closure" {
     $wlvl2_r43OX_closure:
         const $wlvl2_r43OX_info;
         const 0;
 },
 sat_s45Vf_entry() //  [R1, R2]
         { info_tbl: [(c46t5,
                       label: sat_s45Vf_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46t5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c46t6; else goto c46t7;
       c46t6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c46t7: // global
           I64[Sp - 8] = block_c46t2_info;
           R4 = R2;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c46t2() //  [R1, R2]
         { info_tbl: [(c46t2,
                       label: block_c46t2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46t2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c46ta; else goto c46t9;
       c46ta: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c46t9: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s45Va_entry() //  [R1, R2]
         { info_tbl: [(c46th,
                       label: sat_s45Va_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46th: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Show.$fShowInt_$cshowList_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s45Vi_entry() //  [R1]
         { info_tbl: [(c46tl,
                       label: sat_s45Vi_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46tl: // global
           _s45Vi::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c46tm; else goto c46tn;
       c46tn: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c46tp; else goto c46to;
       c46tp: // global
           HpAlloc = 80;
           goto c46tm;
       c46tm: // global
           R1 = _s45Vi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46to: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s45Vi::P64;
           _s45V8::P64 = P64[_s45Vi::P64 + 16];
           _s45V9::I64 = I64[_s45Vi::P64 + 24];
           I64[Hp - 72] = sat_s45Vf_info;
           I64[Hp - 64] = _s45V9::I64;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           I64[Hp - 32] = sat_s45Va_info;
           P64[Hp - 24] = _s45V8::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 54;
           R3 = lvl4_r43OW_closure+2;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Show.$fShow(,)_go1_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl2_r43OX_entry() //  [R2, R3]
         { info_tbl: [(c46tt,
                       label: $wlvl2_r43OX_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46tt: // global
           _s45V9::I64 = R3;
           _s45V8::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c46tu; else goto c46tv;
       c46tv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c46tx; else goto c46tw;
       c46tx: // global
           HpAlloc = 56;
           goto c46tu;
       c46tu: // global
           R3 = _s45V9::I64;
           R2 = _s45V8::P64;
           R1 = $wlvl2_r43OX_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c46tw: // global
           I64[Hp - 48] = sat_s45Vi_info;
           P64[Hp - 32] = _s45V8::P64;
           I64[Hp - 24] = _s45V9::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           I64[Sp - 8] = block_c46tr_info;
           R3 = Hp - 14;
           R2 = lvl3_r43OV_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c46tr() //  [R1]
         { info_tbl: [(c46tr,
                       label: block_c46tr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46tr: // global
           R3 = R1;
           R2 = $dIP3_r43OU_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.56452187 UTC

[section ""data" . Numeric.showHFloat_allZ_closure" {
     Numeric.showHFloat_allZ_closure:
         const Numeric.showHFloat_allZ_info;
 },
 Numeric.showHFloat_allZ_entry() //  [R2]
         { info_tbl: [(c46uq,
                       label: Numeric.showHFloat_allZ_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46uq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46ur; else goto u46uJ;
       c46ur: // global
           R2 = R2;
           R1 = Numeric.showHFloat_allZ_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u46uJ: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c46ug() args: 0, res: 0, upd: 0;
     }
 },
 _c46ug() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46ug: // global
           _s45Vl::P64 = P64[Sp];
           I64[Sp] = block_c46uj_info;
           R1 = _s45Vl::P64;
           if (R1 & 7 != 0) goto u46uL; else goto c46uk;
       u46uL: // global
           call _c46uj(R1) args: 0, res: 0, upd: 0;
       c46uk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46uj() //  [R1]
         { info_tbl: [(c46uj,
                       label: block_c46uj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46uj: // global
           if (R1 & 7 == 1) goto c46un; else goto c46uo;
       c46un: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c46uo: // global
           I64[Sp - 8] = block_c46uy_info;
           _s45Vo::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s45Vo::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u46uM; else goto c46uA;
       u46uM: // global
           call _c46uy(R1) args: 0, res: 0, upd: 0;
       c46uA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46uy() //  [R1]
         { info_tbl: [(c46uy,
                       label: block_c46uy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46uy: // global
           if (I64[R1 + 7] == 0) goto c46uI; else goto c46uH;
       c46uI: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c46ug() args: 0, res: 0, upd: 0;
       c46uH: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.5738156 UTC

[section ""data" . $wshowIt1_r43OY_closure" {
     $wshowIt1_r43OY_closure:
         const $wshowIt1_r43OY_info;
         const 0;
 },
 $wshowIt1_r43OY_entry() //  [R2, R3, R4]
         { info_tbl: [(c46vv,
                       label: $wshowIt1_r43OY_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46vv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46vw; else goto u46vI;
       c46vw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wshowIt1_r43OY_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u46vI: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c46ve() args: 0, res: 0, upd: 0;
     }
 },
 _c46ve() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46ve: // global
           I64[Sp - 8] = block_c46vh_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u46vK; else goto c46vi;
       u46vK: // global
           call _c46vh(R1) args: 0, res: 0, upd: 0;
       c46vi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46vh() //  [R1]
         { info_tbl: [(c46vh,
                       label: block_c46vh_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46vh: // global
           I64[Sp] = block_c46vm_info;
           R2 = I64[R1 + 7];
           call GHC.Show.$wintToDigit_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c46vm() //  [R1]
         { info_tbl: [(c46vm,
                       label: block_c46vm_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46vm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c46vB; else goto c46vA;
       c46vB: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c46vA: // global
           _s45Vu::P64 = P64[Sp + 24];
           _s45Vy::I64 = I64[Sp + 8];
           if (_s45Vy::I64 == 0) goto c46vH; else goto c46vD;
       c46vH: // global
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s45Vu::P64;
           _c46vG::P64 = Hp - 30;
           Hp = Hp - 16;
           R1 = _c46vG::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c46vD: // global
           (_s45VA::I64, _s45VB::I64) = call MO_S_QuotRem W64(_s45Vy::I64, 16);
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s45Vu::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s45VB::I64;
           I64[Sp + 8] = _s45VA::I64;
           P64[Sp + 16] = Hp - 7;
           P64[Sp + 24] = Hp - 30;
           Sp = Sp + 8;
           call _c46ve() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.583744667 UTC

[section ""data" . $wshowIt2_r43OZ_closure" {
     $wshowIt2_r43OZ_closure:
         const $wshowIt2_r43OZ_info;
         const 0;
 },
 $wshowIt2_r43OZ_entry() //  [R2, R3, R4]
         { info_tbl: [(c46ww,
                       label: $wshowIt2_r43OZ_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46ww: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46wx; else goto u46wJ;
       c46wx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wshowIt2_r43OZ_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u46wJ: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c46wf() args: 0, res: 0, upd: 0;
     }
 },
 _c46wf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46wf: // global
           I64[Sp - 8] = block_c46wi_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u46wL; else goto c46wj;
       u46wL: // global
           call _c46wi(R1) args: 0, res: 0, upd: 0;
       c46wj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46wi() //  [R1]
         { info_tbl: [(c46wi,
                       label: block_c46wi_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46wi: // global
           I64[Sp] = block_c46wn_info;
           R2 = I64[R1 + 7];
           call GHC.Show.$wintToDigit_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c46wn() //  [R1]
         { info_tbl: [(c46wn,
                       label: block_c46wn_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46wn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c46wC; else goto c46wB;
       c46wC: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c46wB: // global
           _s45VI::P64 = P64[Sp + 24];
           _s45VM::I64 = I64[Sp + 8];
           if (_s45VM::I64 == 0) goto c46wI; else goto c46wE;
       c46wI: // global
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s45VI::P64;
           _c46wH::P64 = Hp - 30;
           Hp = Hp - 16;
           R1 = _c46wH::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c46wE: // global
           (_s45VO::I64, _s45VP::I64) = call MO_S_QuotRem W64(_s45VM::I64, 16);
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s45VI::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s45VP::I64;
           I64[Sp + 8] = _s45VO::I64;
           P64[Sp + 16] = Hp - 7;
           P64[Sp + 24] = Hp - 30;
           Sp = Sp + 8;
           call _c46wf() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.592999144 UTC

[section ""data" . $wshowIt3_r43P0_closure" {
     $wshowIt3_r43P0_closure:
         const $wshowIt3_r43P0_info;
         const 0;
 },
 $wshowIt3_r43P0_entry() //  [R2, R3, R4]
         { info_tbl: [(c46xx,
                       label: $wshowIt3_r43P0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46xx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46xy; else goto u46xK;
       c46xy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wshowIt3_r43P0_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u46xK: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c46xg() args: 0, res: 0, upd: 0;
     }
 },
 _c46xg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46xg: // global
           I64[Sp - 8] = block_c46xj_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u46xM; else goto c46xk;
       u46xM: // global
           call _c46xj(R1) args: 0, res: 0, upd: 0;
       c46xk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46xj() //  [R1]
         { info_tbl: [(c46xj,
                       label: block_c46xj_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46xj: // global
           I64[Sp] = block_c46xo_info;
           R2 = I64[R1 + 7];
           call GHC.Show.$wintToDigit_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c46xo() //  [R1]
         { info_tbl: [(c46xo,
                       label: block_c46xo_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46xo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c46xD; else goto c46xC;
       c46xD: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c46xC: // global
           _s45VW::P64 = P64[Sp + 24];
           _s45W0::I64 = I64[Sp + 8];
           if (_s45W0::I64 == 0) goto c46xJ; else goto c46xF;
       c46xJ: // global
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s45VW::P64;
           _c46xI::P64 = Hp - 30;
           Hp = Hp - 16;
           R1 = _c46xI::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c46xF: // global
           (_s45W2::I64, _s45W3::I64) = call MO_S_QuotRem W64(_s45W0::I64, 16);
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s45VW::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s45W3::I64;
           I64[Sp + 8] = _s45W2::I64;
           P64[Sp + 16] = Hp - 7;
           P64[Sp + 24] = Hp - 30;
           Sp = Sp + 8;
           call _c46xg() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.602620803 UTC

[section ""data" . $wshowIt4_r43P1_closure" {
     $wshowIt4_r43P1_closure:
         const $wshowIt4_r43P1_info;
         const 0;
 },
 $wshowIt4_r43P1_entry() //  [R2, R3, R4]
         { info_tbl: [(c46yy,
                       label: $wshowIt4_r43P1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46yy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46yz; else goto u46yL;
       c46yz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wshowIt4_r43P1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u46yL: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c46yh() args: 0, res: 0, upd: 0;
     }
 },
 _c46yh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46yh: // global
           I64[Sp - 8] = block_c46yk_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u46yN; else goto c46yl;
       u46yN: // global
           call _c46yk(R1) args: 0, res: 0, upd: 0;
       c46yl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46yk() //  [R1]
         { info_tbl: [(c46yk,
                       label: block_c46yk_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46yk: // global
           I64[Sp] = block_c46yp_info;
           R2 = I64[R1 + 7];
           call GHC.Show.$wintToDigit_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c46yp() //  [R1]
         { info_tbl: [(c46yp,
                       label: block_c46yp_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46yp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c46yE; else goto c46yD;
       c46yE: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c46yD: // global
           _s45Wa::P64 = P64[Sp + 24];
           _s45We::I64 = I64[Sp + 8];
           if (_s45We::I64 == 0) goto c46yK; else goto c46yG;
       c46yK: // global
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s45Wa::P64;
           _c46yJ::P64 = Hp - 30;
           Hp = Hp - 16;
           R1 = _c46yJ::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c46yG: // global
           (_s45Wg::I64, _s45Wh::I64) = call MO_S_QuotRem W64(_s45We::I64, 16);
           I64[Hp - 48] = GHC.Types.C#_con_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = _s45Wa::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s45Wh::I64;
           I64[Sp + 8] = _s45Wg::I64;
           P64[Sp + 16] = Hp - 7;
           P64[Sp + 24] = Hp - 30;
           Sp = Sp + 8;
           call _c46yh() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.614118986 UTC

[section ""data" . Numeric.showHFloat_hex_closure" {
     Numeric.showHFloat_hex_closure:
         const Numeric.showHFloat_hex_info;
         const 0;
 },
 sat_s45Xs_entry() //  [R1]
         { info_tbl: [(c46As,
                       label: sat_s45Xs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46As: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46At; else goto c46Au;
       c46At: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46Au: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Numeric.showHFloat_hex_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showHFloat_hex_entry() //  [R2]
         { info_tbl: [(c46Az,
                       label: Numeric.showHFloat_hex_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Az: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c46AA; else goto c46AB;
       c46AA: // global
           R2 = R2;
           R1 = Numeric.showHFloat_hex_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c46AB: // global
           I64[Sp - 8] = block_c46zl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u46CM; else goto c46zm;
       u46CM: // global
           call _c46zl(R1) args: 0, res: 0, upd: 0;
       c46zm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46zl() //  [R1]
         { info_tbl: [(c46zl,
                       label: block_c46zl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46zl: // global
           if (R1 & 7 == 1) goto c46Aw; else goto c46Ax;
       c46Aw: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c46Ax: // global
           I64[Sp - 8] = block_c46zr_info;
           _s45Wo::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _s45Wo::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u46CC; else goto c46zs;
       u46CC: // global
           call _c46zr(R1) args: 0, res: 0, upd: 0;
       c46zs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46zr() //  [R1]
         { info_tbl: [(c46zr,
                       label: block_c46zr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46zr: // global
           if (R1 & 7 == 1) goto c46AJ; else goto c46B2;
       c46AJ: // global
           _s45Wo::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c46AG_info;
           R1 = _s45Wo::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u46CD; else goto c46AK;
       u46CD: // global
           call _c46AG(R1) args: 0, res: 0, upd: 0;
       c46AK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c46B2: // global
           I64[Sp - 8] = block_c46zx_info;
           _s45Wz::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _s45Wz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u46CE; else goto c46zy;
       u46CE: // global
           call _c46zx(R1) args: 0, res: 0, upd: 0;
       c46zy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46AG() //  [R1]
         { info_tbl: [(c46AG,
                       label: block_c46AG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46AG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c46AQ; else goto c46AP;
       c46AQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c46AP: // global
           _s45Wt::I64 = I64[R1 + 7] << 3;
           if (%MO_S_Ge_W64(_s45Wt::I64, 0)) goto c46AZ; else goto c46B0;
       c46AZ: // global
           (_s45Ww::I64, _s45Wx::I64) = call MO_S_QuotRem W64(_s45Wt::I64, 16);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s45Wx::I64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 7;
           R2 = _s45Ww::I64;
           Sp = Sp + 8;
           call $wshowIt4_r43P1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c46B0: // global
           Hp = Hp - 16;
           R2 = _s45Wt::I64;
           Sp = Sp + 8;
           call Numeric.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c46zx() //  [R1]
         { info_tbl: [(c46zx,
                       label: block_c46zx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46zx: // global
           if (R1 & 7 == 1) goto c46Bc; else goto c46BC;
       c46Bc: // global
           I64[Sp] = block_c46B4_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u46CF; else goto c46B5;
       u46CF: // global
           call _c46B4(R1) args: 0, res: 0, upd: 0;
       c46B5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c46BC: // global
           I64[Sp - 8] = block_c46zD_info;
           _s45WO::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _s45WO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u46CG; else goto c46zE;
       u46CG: // global
           call _c46zD(R1) args: 0, res: 0, upd: 0;
       c46zE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46B4() //  [R1]
         { info_tbl: [(c46B4,
                       label: block_c46B4_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46B4: // global
           _s45Wz::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c46B9_info;
           _s45WD::I64 = I64[R1 + 7];
           R1 = _s45Wz::P64;
           I64[Sp + 16] = _s45WD::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u46CN; else goto c46Be;
       u46CN: // global
           call _c46B9(R1) args: 0, res: 0, upd: 0;
       c46Be: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46B9() //  [R1]
         { info_tbl: [(c46B9,
                       label: block_c46B9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46B9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c46Bk; else goto c46Bj;
       c46Bk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c46Bj: // global
           _s45WG::I64 = (I64[Sp + 8] << 3) + (I64[R1 + 7] << 2);
           if (%MO_S_Ge_W64(_s45WG::I64, 0)) goto c46Bz; else goto c46BA;
       c46Bz: // global
           (_s45WL::I64, _s45WM::I64) = call MO_S_QuotRem W64(_s45WG::I64, 16);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s45WM::I64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 7;
           R2 = _s45WL::I64;
           Sp = Sp + 16;
           call $wshowIt3_r43P0_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c46BA: // global
           Hp = Hp - 16;
           R2 = _s45WG::I64;
           Sp = Sp + 16;
           call Numeric.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c46zD() //  [R1]
         { info_tbl: [(c46zD,
                       label: block_c46zD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46zD: // global
           _s45Wo::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c46BR; else goto c46Co;
       c46BR: // global
           I64[Sp] = block_c46BE_info;
           R1 = _s45Wo::P64;
           if (R1 & 7 != 0) goto u46CH; else goto c46BF;
       u46CH: // global
           call _c46BE(R1) args: 0, res: 0, upd: 0;
       c46BF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c46Co: // global
           I64[Sp - 8] = block_c46zJ_info;
           _s45X7::P64 = P64[R1 + 6];
           _s45X8::P64 = P64[R1 + 14];
           R1 = _s45Wo::P64;
           P64[Sp] = _s45X8::P64;
           P64[Sp + 24] = _s45X7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u46CI; else goto c46zK;
       u46CI: // global
           call _c46zJ(R1) args: 0, res: 0, upd: 0;
       c46zK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46BE() //  [R1]
         { info_tbl: [(c46BE,
                       label: block_c46BE_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46BE: // global
           I64[Sp] = block_c46BJ_info;
           _s45WS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 24] = _s45WS::I64;
           if (R1 & 7 != 0) goto u46CO; else goto c46BK;
       u46CO: // global
           call _c46BJ(R1) args: 0, res: 0, upd: 0;
       c46BK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46BJ() //  [R1]
         { info_tbl: [(c46BJ,
                       label: block_c46BJ_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46BJ: // global
           _s45WO::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c46BO_info;
           _s45WU::I64 = I64[R1 + 7];
           R1 = _s45WO::P64;
           I64[Sp + 16] = _s45WU::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u46CP; else goto c46BU;
       u46CP: // global
           call _c46BO(R1) args: 0, res: 0, upd: 0;
       c46BU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46BO() //  [R1]
         { info_tbl: [(c46BO,
                       label: block_c46BO_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46BO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c46C0; else goto c46BZ;
       c46C0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c46BZ: // global
           _s45WX::I64 = (I64[Sp + 16] << 3) + ((I64[Sp + 8] << 2) + (I64[R1 + 7] << 1));
           if (%MO_S_Ge_W64(_s45WX::I64, 0)) goto c46Cl; else goto c46Cm;
       c46Cl: // global
           (_s45X4::I64, _s45X5::I64) = call MO_S_QuotRem W64(_s45WX::I64, 16);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s45X5::I64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 7;
           R2 = _s45X4::I64;
           Sp = Sp + 24;
           call $wshowIt2_r43OZ_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c46Cm: // global
           Hp = Hp - 16;
           R2 = _s45WX::I64;
           Sp = Sp + 24;
           call Numeric.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c46zJ() //  [R1]
         { info_tbl: [(c46zJ,
                       label: block_c46zJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46zJ: // global
           I64[Sp] = block_c46zO_info;
           _s45Xa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s45Xa::I64;
           if (R1 & 7 != 0) goto u46CJ; else goto c46zP;
       u46CJ: // global
           call _c46zO(R1) args: 0, res: 0, upd: 0;
       c46zP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46zO() //  [R1]
         { info_tbl: [(c46zO,
                       label: block_c46zO_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46zO: // global
           I64[Sp] = block_c46zT_info;
           _s45Xc::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s45Xc::I64;
           if (R1 & 7 != 0) goto u46CK; else goto c46zU;
       u46CK: // global
           call _c46zT(R1) args: 0, res: 0, upd: 0;
       c46zU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46zT() //  [R1]
         { info_tbl: [(c46zT,
                       label: block_c46zT_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46zT: // global
           I64[Sp] = block_c46zY_info;
           _s45Xe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _s45Xe::I64;
           if (R1 & 7 != 0) goto u46CL; else goto c46zZ;
       u46CL: // global
           call _c46zY(R1) args: 0, res: 0, upd: 0;
       c46zZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46zY() //  [R1]
         { info_tbl: [(c46zY,
                       label: block_c46zY_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46zY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c46Cu; else goto c46Ct;
       c46Cu: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c46Ct: // global
           _s45Xh::I64 = (I64[Sp + 24] << 3) + ((I64[Sp + 16] << 2) + ((I64[Sp + 32] << 1) + I64[R1 + 7]));
           if (%MO_S_Ge_W64(_s45Xh::I64, 0)) goto c46Cx; else goto c46Cy;
       c46Cx: // global
           _s45X8::P64 = P64[Sp + 8];
           (_s45Xp::I64, _s45Xq::I64) = call MO_S_QuotRem W64(_s45Xh::I64, 16);
           I64[Hp - 32] = sat_s45Xs_info;
           P64[Hp - 16] = _s45X8::P64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s45Xq::I64;
           R4 = Hp - 32;
           R3 = Hp - 7;
           R2 = _s45Xp::I64;
           Sp = Sp + 40;
           call $wshowIt1_r43OY_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c46Cy: // global
           Hp = Hp - 40;
           R2 = _s45Xh::I64;
           Sp = Sp + 40;
           call Numeric.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.648915296 UTC

[section ""data" . sat_s45Xt_closure" {
     sat_s45Xt_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.650625693 UTC

[section ""data" . sat_s45Xu_closure" {
     sat_s45Xu_closure:
         const :_con_info;
         const sat_s45Xt_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.65257185 UTC

[section ""data" . Numeric.showHFloat15_closure" {
     Numeric.showHFloat15_closure:
         const Numeric.showHFloat15_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat15_entry() //  [R1]
         { info_tbl: [(c46EO,
                       label: Numeric.showHFloat15_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46EO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46EP; else goto c46EQ;
       c46EP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46EQ: // global
           (_c46EL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c46EL::I64 == 0) goto c46EN; else goto c46EM;
       c46EN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c46EM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c46EL::I64;
           R3 = sat_s45Xu_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.656825473 UTC

[section ""cstring" . Numeric.showHFloat10_bytes" {
     Numeric.showHFloat10_bytes:
         I8[] [48,120,48,112,43,48]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.65869799 UTC

[section ""data" . Numeric.showHFloat9_closure" {
     Numeric.showHFloat9_closure:
         const Numeric.showHFloat9_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat9_entry() //  [R1]
         { info_tbl: [(c46F7,
                       label: Numeric.showHFloat9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46F7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46F8; else goto c46F9;
       c46F8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46F9: // global
           (_c46F4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c46F4::I64 == 0) goto c46F6; else goto c46F5;
       c46F6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c46F5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c46F4::I64;
           R2 = Numeric.showHFloat10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.662767132 UTC

[section ""data" . Numeric.showHFloat14_closure" {
     Numeric.showHFloat14_closure:
         const Numeric.showHFloat14_info;
         const 0;
 },
 Numeric.showHFloat14_entry() //  [R2]
         { info_tbl: [(c46Fm,
                       label: Numeric.showHFloat14_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Fm: // global
           R3 = R2;
           R2 = GHC.Types.[]_closure+1;
           call $wlvl2_r43OX_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.665968283 UTC

[section ""cstring" . Numeric.showHFloat13_bytes" {
     Numeric.showHFloat13_bytes:
         I8[] [48,120]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.667567432 UTC

[section ""cstring" . Numeric.showHFloat12_bytes" {
     Numeric.showHFloat12_bytes:
         I8[] [112]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.669283199 UTC

[section ""cstring" . Numeric.showHFloat11_bytes" {
     Numeric.showHFloat11_bytes:
         I8[] [46]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.673521177 UTC

[section ""data" . Numeric.showHFloat_cvt_closure" {
     Numeric.showHFloat_cvt_closure:
         const Numeric.showHFloat_cvt_info;
         const 0;
 },
 sat_s45XD_entry() //  [R1]
         { info_tbl: [(c46FP,
                       label: sat_s45XD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46FP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46FQ; else goto c46FR;
       c46FQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46FR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c46FN_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c46FN() //  [R1]
         { info_tbl: [(c46FN,
                       label: block_c46FN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46FN: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showHFloat16_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s45Y0_entry() //  [R1]
         { info_tbl: [(c46GF,
                       label: sat_s45Y0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46GF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c46GO; else goto c46GP;
       c46GO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46GP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c46GC_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u46GU; else goto c46GD;
       u46GU: // global
           call _c46GC(R1) args: 0, res: 0, upd: 0;
       c46GD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c46GC() //  [R1]
         { info_tbl: [(c46GC,
                       label: block_c46GC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46GC: // global
           I64[Sp] = block_c46GL_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7] - 1;
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c46GL() //  [R1, R2]
         { info_tbl: [(c46GL,
                       label: block_c46GL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46GL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c46GT; else goto c46GS;
       c46GT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c46GS: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 n_s45XT_entry() //  [R1]
         { info_tbl: [(c46GV,
                       label: n_s45XT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46GV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c46GZ; else goto c46GY;
       c46GZ: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46GY: // global
           _s45XH::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s45Y0_info;
           P64[Hp] = _s45XH::P64;
           R3 = Hp - 16;
           R2 = Numeric.showHFloat12_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s45Y3_entry() //  [R1]
         { info_tbl: [(c46Ha,
                       label: sat_s45Y3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Ha: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46Hb; else goto c46Hc;
       c46Hb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46Hc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c46H8_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Numeric.showHFloat_hex_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c46H8() //  [R1]
         { info_tbl: [(c46H8,
                       label: block_c46H8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46H8: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s45Y4_entry() //  [R1]
         { info_tbl: [(c46Hk,
                       label: sat_s45Y4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Hk: // global
           _s45Y4::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c46Hl; else goto c46Hm;
       c46Hm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c46Ho; else goto c46Hn;
       c46Ho: // global
           HpAlloc = 24;
           goto c46Hl;
       c46Hl: // global
           R1 = _s45Y4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46Hn: // global
           _s45XH::P64 = P64[_s45Y4::P64 + 16];
           _s45XM::P64 = P64[_s45Y4::P64 + 24];
           I64[Hp - 16] = n_s45XT_info;
           P64[Hp] = _s45XH::P64;
           I64[Sp - 24] = block_c46H0_info;
           R2 = _s45XM::P64;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _s45XM::P64;
           Sp = Sp - 24;
           call Numeric.showHFloat_allZ_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c46H0() //  [R1]
         { info_tbl: [(c46H0,
                       label: block_c46H0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46H0: // global
           _c46Gu::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c46Hh; else goto c46Hi;
       c46Hh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c46Hr; else goto c46Hq;
       c46Hr: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c46Hq: // global
           I64[Hp - 24] = sat_s45Y3_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _c46Gu::P64;
           R3 = Hp - 24;
           R2 = Numeric.showHFloat11_bytes;
           Sp = Sp + 24;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c46Hi: // global
           R1 = _c46Gu::P64;
           Sp = Sp + 24;
           call n_s45XT_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s45Y5_entry() //  [R1]
         { info_tbl: [(c46Hv,
                       label: sat_s45Y5_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Hv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c46Hx; else goto c46Hy;
       c46Hx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46Hy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c46Gj_info;
           _s45XH::P64 = P64[R1 + 16];
           _s45XM::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s45XH::P64;
           P64[Sp - 24] = _s45XM::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u46HD; else goto c46Gk;
       u46HD: // global
           call _c46Gj(R1) args: 0, res: 0, upd: 0;
       c46Gk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c46Gj() //  [R1]
         { info_tbl: [(c46Gj,
                       label: block_c46Gj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Gj: // global
           I64[Sp] = block_c46Go_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c46Go() //  [R1, R2]
         { info_tbl: [(c46Go,
                       label: block_c46Go_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Go: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c46HC; else goto c46HB;
       c46HC: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c46HB: // global
           I64[Hp - 48] = sat_s45Y4_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 48;
           R2 = Hp - 14;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u46Id_srtd" {
     u46Id_srtd:
         const S45Zy_srt+144;
         const 33;
         const 8388608001;
 },
 Numeric.showHFloat_cvt_entry() //  [R2, R3]
         { info_tbl: [(c46HE,
                       label: Numeric.showHFloat_cvt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46HE: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c46HF; else goto c46HG;
       c46HF: // global
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showHFloat_cvt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c46HG: // global
           I64[Sp - 24] = block_c46FB_info;
           _s45Xw::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s45Xw::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Float.$p1RealFloat_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u46Ie_srtd" {
     u46Ie_srtd:
         const S45Zy_srt+144;
         const 33;
         const 7851737089;
 },
 _c46FB() //  [R1]
         { info_tbl: [(c46FB,
                       label: block_c46FB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46FB: // global
           I64[Sp] = block_c46FF_info;
           R2 = R1;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u46If_srtd" {
     u46If_srtd:
         const S45Zy_srt+144;
         const 33;
         const 7851737089;
 },
 _c46FF() //  [R1]
         { info_tbl: [(c46FF,
                       label: block_c46FF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46FF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c46HK; else goto c46HJ;
       c46HK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c46HJ: // global
           I64[Hp - 16] = sat_s45XD_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c46FV_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c46FV() //  [R1]
         { info_tbl: [(c46FV,
                       label: block_c46FV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46FV: // global
           I64[Sp] = block_c46FZ_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c46FZ() //  [R1]
         { info_tbl: [(c46FZ,
                       label: block_c46FZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46FZ: // global
           _c46FJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c46G3_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp] = _c46FJ::P64;
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c46G3() //  [R1]
         { info_tbl: [(c46G3,
                       label: block_c46G3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46G3: // global
           if (R1 & 7 == 1) goto c46HP; else goto c46I8;
       c46HP: // global
           _s45Xx::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c46G7_info;
           R4 = _s45Xx::P64;
           R3 = Numeric.showHFloat15_closure;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Float.$wfloatToDigits_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
       c46I8: // global
           R1 = Numeric.showHFloat9_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c46G7() //  [R1, R2]
         { info_tbl: [(c46G7,
                       label: block_c46G7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46G7: // global
           I64[Sp - 8] = block_c46G9_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u46Ib; else goto c46Ga;
       u46Ib: // global
           call _c46G9(R1) args: 0, res: 0, upd: 0;
       c46Ga: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c46G9() //  [R1]
         { info_tbl: [(c46G9,
                       label: block_c46G9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46G9: // global
           _s45XH::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c46HV; else goto c46I1;
       c46HV: // global
           I64[Sp + 8] = block_c46HS_info;
           R1 = _s45XH::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u46Ic; else goto c46HW;
       u46Ic: // global
           call _c46HS(R1) args: 0, res: 0, upd: 0;
       c46HW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c46I1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c46I4; else goto c46I3;
       c46I4: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c46I3: // global
           _s45XL::P64 = P64[R1 + 6];
           _s45XM::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_s45Y5_info;
           P64[Hp - 16] = _s45XH::P64;
           P64[Hp - 8] = _s45XL::P64;
           P64[Hp] = _s45XM::P64;
           R3 = Hp - 32;
           R2 = Numeric.showHFloat13_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _c46HS() //  [R1]
         { info_tbl: [(c46HS,
                       label: block_c46HS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46HS: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call Numeric.showHFloat14_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.718080217 UTC

[section ""data" . Numeric.showHFloat8_closure" {
     Numeric.showHFloat8_closure:
         const GHC.Types.C#_con_info;
         const 45;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.719841342 UTC

[section ""cstring" . Numeric.showHFloat5_bytes" {
     Numeric.showHFloat5_bytes:
         I8[] [73,110,102,105,110,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.721793609 UTC

[section ""cstring" . Numeric.showHFloat7_bytes" {
     Numeric.showHFloat7_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.72378116 UTC

[section ""data" . Numeric.showHFloat6_closure" {
     Numeric.showHFloat6_closure:
         const Numeric.showHFloat6_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat6_entry() //  [R1]
         { info_tbl: [(c46Kt,
                       label: Numeric.showHFloat6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Kt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46Ku; else goto c46Kv;
       c46Ku: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46Kv: // global
           (_c46Kq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c46Kq::I64 == 0) goto c46Ks; else goto c46Kr;
       c46Ks: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c46Kr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c46Kq::I64;
           R2 = Numeric.showHFloat7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.727819186 UTC

[section ""cstring" . Numeric.showHFloat2_bytes" {
     Numeric.showHFloat2_bytes:
         I8[] [78,97,78]
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.72955674 UTC

[section ""data" . Numeric.showHFloat1_closure" {
     Numeric.showHFloat1_closure:
         const Numeric.showHFloat1_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat1_entry() //  [R1]
         { info_tbl: [(c46KL,
                       label: Numeric.showHFloat1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46KL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46KM; else goto c46KN;
       c46KM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46KN: // global
           (_c46KI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c46KI::I64 == 0) goto c46KK; else goto c46KJ;
       c46KK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c46KJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c46KI::I64;
           R2 = Numeric.showHFloat2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.733760547 UTC

[section ""data" . Numeric.showHFloat4_closure" {
     Numeric.showHFloat4_closure:
         const Numeric.showHFloat4_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat4_entry() //  [R1]
         { info_tbl: [(c46L2,
                       label: Numeric.showHFloat4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46L2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46L3; else goto c46L4;
       c46L3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46L4: // global
           (_c46KZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c46KZ::I64 == 0) goto c46L1; else goto c46L0;
       c46L1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c46L0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c46KZ::I64;
           R2 = Numeric.showHFloat5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.737708466 UTC

[section ""data" . Numeric.showHFloat3_closure" {
     Numeric.showHFloat3_closure:
         const Numeric.showHFloat3_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showHFloat3_entry() //  [R1]
         { info_tbl: [(c46Lj,
                       label: Numeric.showHFloat3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Lj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46Lk; else goto c46Ll;
       c46Lk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46Ll: // global
           (_c46Lg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c46Lg::I64 == 0) goto c46Li; else goto c46Lh;
       c46Li: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c46Lh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c46Lg::I64;
           R3 = Numeric.showHFloat4_closure;
           R2 = Numeric.showHFloat6_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.744399257 UTC

[section ""data" . Numeric.showHFloat_closure" {
     Numeric.showHFloat_closure:
         const Numeric.showHFloat_info;
         const 0;
 },
 $dNum_s45Yb_entry() //  [R1]
         { info_tbl: [(c46LS,
                       label: $dNum_s45Yb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46LS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46LT; else goto c46LU;
       c46LT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46LU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s45Ye_entry() //  [R1]
         { info_tbl: [(c46M3,
                       label: sat_s45Ye_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46M3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46M4; else goto c46M5;
       c46M4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46M5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showHFloat16_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s45Yh_entry() //  [R1]
         { info_tbl: [(c46Mr,
                       label: sat_s45Yh_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Mr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46Ms; else goto c46Mt;
       c46Ms: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46Mt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s45Yi_entry() //  [R1]
         { info_tbl: [(c46Mu,
                       label: sat_s45Yi_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Mu: // global
           _s45Yi::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c46Mv; else goto c46Mw;
       c46Mw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c46My; else goto c46Mx;
       c46My: // global
           HpAlloc = 32;
           goto c46Mv;
       c46Mv: // global
           R1 = _s45Yi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46Mx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s45Yi::P64;
           _s45Y6::P64 = P64[_s45Yi::P64 + 16];
           _s45Y7::P64 = P64[_s45Yi::P64 + 24];
           _s45Yb::P64 = P64[_s45Yi::P64 + 32];
           I64[Hp - 24] = sat_s45Yh_info;
           P64[Hp - 8] = _s45Y7::P64;
           P64[Hp] = _s45Yb::P64;
           R3 = Hp - 24;
           R2 = _s45Y6::P64;
           Sp = Sp - 16;
           call Numeric.showHFloat_cvt_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s45Yj_entry() //  [R1]
         { info_tbl: [(c46MJ,
                       label: sat_s45Yj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46MJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46MK; else goto c46ML;
       c46MK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46ML: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s45Yk_entry() //  [R1]
         { info_tbl: [(c46MM,
                       label: sat_s45Yk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46MM: // global
           _s45Yk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c46MN; else goto c46MO;
       c46MO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c46MQ; else goto c46MP;
       c46MQ: // global
           HpAlloc = 32;
           goto c46MN;
       c46MN: // global
           R1 = _s45Yk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46MP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s45Yk::P64;
           _s45Y6::P64 = P64[_s45Yk::P64 + 16];
           _s45Y7::P64 = P64[_s45Yk::P64 + 24];
           _s45Yb::P64 = P64[_s45Yk::P64 + 32];
           I64[Hp - 24] = sat_s45Yj_info;
           P64[Hp - 8] = _s45Y7::P64;
           P64[Hp] = _s45Yb::P64;
           R3 = Hp - 24;
           R2 = _s45Y6::P64;
           Sp = Sp - 16;
           call Numeric.showHFloat_cvt_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s45Ym_entry() //  [R1]
         { info_tbl: [(c46MX,
                       label: sat_s45Ym_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46MX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46MY; else goto c46MZ;
       c46MY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46MZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Numeric.showHFloat16_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s45Yo_entry() //  [R1]
         { info_tbl: [(c46N4,
                       label: sat_s45Yo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46N4: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c46N5; else goto c46N6;
       c46N5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46N6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c46LC_info;
           _s45Y6::P64 = P64[R1 + 16];
           R2 = _s45Y6::P64;
           I64[Sp - 56] = stg_ap_p_info;
           _s45Y7::P64 = P64[R1 + 24];
           P64[Sp - 48] = _s45Y7::P64;
           P64[Sp - 32] = _s45Y6::P64;
           P64[Sp - 24] = _s45Y7::P64;
           Sp = Sp - 56;
           call GHC.Float.isNaN_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c46LC() //  [R1]
         { info_tbl: [(c46LC,
                       label: block_c46LC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46LC: // global
           if (R1 & 7 == 1) goto c46N1; else goto c46N2;
       c46N1: // global
           I64[Sp] = block_c46LG_info;
           R2 = P64[Sp + 8];
           call GHC.Float.$p1RealFloat_entry(R2) args: 8, res: 8, upd: 24;
       c46N2: // global
           R1 = Numeric.showHFloat1_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c46LG() //  [R1]
         { info_tbl: [(c46LG,
                       label: block_c46LG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46LG: // global
           I64[Sp] = block_c46LK_info;
           R2 = R1;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c46LK() //  [R1]
         { info_tbl: [(c46LK,
                       label: block_c46LK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46LK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c46Nb; else goto c46Na;
       c46Nb: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c46Na: // global
           I64[Hp - 16] = $dNum_s45Yb_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c46LV_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Float.isInfinite_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c46LV() //  [R1]
         { info_tbl: [(c46LV,
                       label: block_c46LV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46LV: // global
           _c46LO::P64 = P64[Sp + 16];
           _s45Ya::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c46Nd; else goto c46NA;
       c46Nd: // global
           Hp = Hp + 24;
           _s45Yc::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c46ND; else goto c46Nf;
       c46Nf: // global
           I64[Hp - 16] = sat_s45Ye_info;
           P64[Hp] = _c46LO::P64;
           I64[Sp] = block_c46M6_info;
           R2 = _s45Ya::P64;
           P64[Sp + 8] = Hp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 24;
       c46NA: // global
           Hp = Hp + 24;
           _s45Yc::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c46ND; else goto c46NC;
       c46ND: // global
           HpAlloc = 24;
           R1 = _s45Yc::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c46NC: // global
           I64[Hp - 16] = sat_s45Ym_info;
           P64[Hp] = _c46LO::P64;
           I64[Sp + 16] = block_c46Nz_info;
           R2 = _s45Ya::P64;
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c46M6() //  [R1]
         { info_tbl: [(c46M6,
                       label: block_c46M6_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46M6: // global
           _c46LZ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c46Ma_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = _c46LZ::P64;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c46Ma() //  [R1]
         { info_tbl: [(c46Ma,
                       label: block_c46Ma_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Ma: // global
           _s45Y6::P64 = P64[Sp + 16];
           _s45Y7::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c46Nk; else goto c46Nv;
       c46Nk: // global
           I64[Sp] = block_c46Me_info;
           R2 = _s45Y6::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _s45Y7::P64;
           Sp = Sp - 16;
           call GHC.Float.isNegativeZero_entry(R2) args: 24, res: 8, upd: 24;
       c46Nv: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c46Ny; else goto c46Nx;
       c46Ny: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c46Nx: // global
           I64[Hp - 56] = sat_s45Yk_info;
           P64[Hp - 40] = _s45Y6::P64;
           P64[Hp - 32] = _s45Y7::P64;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Numeric.showHFloat8_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c46Me() //  [R1]
         { info_tbl: [(c46Me,
                       label: block_c46Me_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Me: // global
           _s45Y6::P64 = P64[Sp + 16];
           _s45Y7::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c46No; else goto c46Nq;
       c46No: // global
           R3 = _s45Y7::P64;
           R2 = _s45Y6::P64;
           Sp = Sp + 32;
           call Numeric.showHFloat_cvt_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
       c46Nq: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c46Nt; else goto c46Ns;
       c46Nt: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c46Ns: // global
           I64[Hp - 56] = sat_s45Yi_info;
           P64[Hp - 40] = _s45Y6::P64;
           P64[Hp - 32] = _s45Y7::P64;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Numeric.showHFloat8_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c46Nz() //  [R1]
         { info_tbl: [(c46Nz,
                       label: block_c46Nz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Nz: // global
           _s45Y7::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c46NH_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s45Y7::P64;
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 24;
     }
 },
 _c46NH() //  [R1]
         { info_tbl: [(c46NH,
                       label: block_c46NH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46NH: // global
           if (R1 & 7 == 1) goto c46NO; else goto c46NS;
       c46NO: // global
           R1 = Numeric.showHFloat4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c46NS: // global
           R1 = Numeric.showHFloat3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showHFloat_entry() //  [R2, R3]
         { info_tbl: [(c46O0,
                       label: Numeric.showHFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46O0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c46O4; else goto c46O3;
       c46O4: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showHFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c46O3: // global
           I64[Hp - 24] = sat_s45Yo_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.782515706 UTC

[section ""data" . sat_s45Yp_closure" {
     sat_s45Yp_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.784171554 UTC

[section ""data" . sat_s45Yq_closure" {
     sat_s45Yq_closure:
         const :_con_info;
         const sat_s45Yp_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.786254854 UTC

[section ""data" . Numeric.showOct1_closure" {
     Numeric.showOct1_closure:
         const Numeric.showOct1_info;
         const 0;
         const 0;
         const 0;
 },
 Numeric.showOct1_entry() //  [R1]
         { info_tbl: [(c46Qj,
                       label: Numeric.showOct1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Qj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46Qk; else goto c46Ql;
       c46Qk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46Ql: // global
           (_c46Qg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c46Qg::I64 == 0) goto c46Qi; else goto c46Qh;
       c46Qi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c46Qh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c46Qg::I64;
           R3 = sat_s45Yq_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.790844801 UTC

[section ""data" . Numeric.showOct_closure" {
     Numeric.showOct_closure:
         const Numeric.showOct_info;
         const 0;
 },
 sat_s45Yv_entry() //  [R1]
         { info_tbl: [(c46QF,
                       label: sat_s45Yv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46QF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46QJ; else goto c46QK;
       c46QJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46QK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c46QD_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c46QD() //  [R1]
         { info_tbl: [(c46QD,
                       label: block_c46QD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46QD: // global
           I64[Sp] = block_c46QI_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c46QI() //  [R1]
         { info_tbl: [(c46QI,
                       label: block_c46QI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46QI: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Numeric.showOct1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Numeric.showOct_entry() //  [R2, R3]
         { info_tbl: [(c46QQ,
                       label: Numeric.showOct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46QQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c46QU; else goto c46QT;
       c46QU: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showOct_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c46QT: // global
           I64[Hp - 16] = sat_s45Yv_info;
           P64[Hp] = R2;
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = Hp - 16;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showIntAtBase_closure+6;
           call stg_ap_pppp_fast(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.799928271 UTC

[section ""data" . Numeric.$trModule3_closure" {
     Numeric.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Numeric.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.801510427 UTC

[section ""data" . Numeric.$trModule1_closure" {
     Numeric.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Numeric.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.803077003 UTC

[section ""data" . Numeric.$trModule_closure" {
     Numeric.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Numeric.$trModule3_closure+1;
         const Numeric.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.805430224 UTC

[section ""data" . Numeric.showGFloat_$sshowGFloat_closure" {
     Numeric.showGFloat_$sshowGFloat_closure:
         const Numeric.showGFloat_$sshowGFloat_info;
         const 0;
 },
 sat_s45YA_entry() //  [R1]
         { info_tbl: [(c46Ru,
                       label: sat_s45YA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Ru: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46Rv; else goto c46Rw;
       c46Rv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46Rw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c46Rr_info;
           _s45Yw::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s45Yw::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u46RA; else goto c46Rs;
       u46RA: // global
           call _c46Rr(R1) args: 0, res: 0, upd: 0;
       c46Rs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c46Rr() //  [R1]
         { info_tbl: [(c46Rr,
                       label: block_c46Rr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Rr: // global
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showGFloat_$sshowGFloat_entry() //  [R2, R3]
         { info_tbl: [(c46RB,
                       label: Numeric.showGFloat_$sshowGFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46RB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c46RF; else goto c46RE;
       c46RF: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showGFloat_$sshowGFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c46RE: // global
           I64[Hp - 24] = sat_s45YA_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.813812421 UTC

[section ""data" . Numeric.showFFloat_$sshowFFloat_closure" {
     Numeric.showFFloat_$sshowFFloat_closure:
         const Numeric.showFFloat_$sshowFFloat_info;
         const 0;
 },
 sat_s45YF_entry() //  [R1]
         { info_tbl: [(c46S9,
                       label: sat_s45YF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46S9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46Sa; else goto c46Sb;
       c46Sa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46Sb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c46S6_info;
           _s45YB::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s45YB::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u46Sf; else goto c46S7;
       u46Sf: // global
           call _c46S6(R1) args: 0, res: 0, upd: 0;
       c46S7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c46S6() //  [R1]
         { info_tbl: [(c46S6,
                       label: block_c46S6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46S6: // global
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showFFloat_$sshowFFloat_entry() //  [R2, R3]
         { info_tbl: [(c46Sg,
                       label: Numeric.showFFloat_$sshowFFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Sg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c46Sk; else goto c46Sj;
       c46Sk: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showFFloat_$sshowFFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c46Sj: // global
           I64[Hp - 24] = sat_s45YF_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.821915012 UTC

[section ""data" . Numeric.showEFloat_$sshowEFloat_closure" {
     Numeric.showEFloat_$sshowEFloat_closure:
         const Numeric.showEFloat_$sshowEFloat_info;
         const 0;
 },
 sat_s45YK_entry() //  [R1]
         { info_tbl: [(c46SO,
                       label: sat_s45YK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46SO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46SP; else goto c46SQ;
       c46SP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46SQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c46SL_info;
           _s45YG::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s45YG::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u46SU; else goto c46SM;
       u46SU: // global
           call _c46SL(R1) args: 0, res: 0, upd: 0;
       c46SM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c46SL() //  [R1]
         { info_tbl: [(c46SL,
                       label: block_c46SL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46SL: // global
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFExponent_closure+1;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showEFloat_$sshowEFloat_entry() //  [R2, R3]
         { info_tbl: [(c46SV,
                       label: Numeric.showEFloat_$sshowEFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46SV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c46SZ; else goto c46SY;
       c46SZ: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showEFloat_$sshowEFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c46SY: // global
           I64[Hp - 24] = sat_s45YK_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.834051233 UTC

[section ""data" . Numeric.showGFloat_$sshowGFloat1_closure" {
     Numeric.showGFloat_$sshowGFloat1_closure:
         const Numeric.showGFloat_$sshowGFloat1_info;
         const 0;
 },
 sat_s45YP_entry() //  [R1]
         { info_tbl: [(c46Tt,
                       label: sat_s45YP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Tt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46Tu; else goto c46Tv;
       c46Tu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46Tv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c46Tq_info;
           _s45YL::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s45YL::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u46Tz; else goto c46Tr;
       u46Tz: // global
           call _c46Tq(R1) args: 0, res: 0, upd: 0;
       c46Tr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c46Tq() //  [R1]
         { info_tbl: [(c46Tq,
                       label: block_c46Tq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Tq: // global
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showGFloat_$sshowGFloat1_entry() //  [R2, R3]
         { info_tbl: [(c46TA,
                       label: Numeric.showGFloat_$sshowGFloat1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46TA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c46TE; else goto c46TD;
       c46TE: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showGFloat_$sshowGFloat1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c46TD: // global
           I64[Hp - 24] = sat_s45YP_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.843979328 UTC

[section ""data" . Numeric.showGFloat_closure" {
     Numeric.showGFloat_closure:
         const Numeric.showGFloat_info;
         const 0;
 },
 sat_s45YT_entry() //  [R1]
         { info_tbl: [(c46U5,
                       label: sat_s45YT_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46U5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46U6; else goto c46U7;
       c46U6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46U7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.False_closure+1;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFGeneric_closure+3;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showGFloat_entry() //  [R2, R3, R4]
         { info_tbl: [(c46U8,
                       label: Numeric.showGFloat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46U8: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c46Uc; else goto c46Ub;
       c46Uc: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showGFloat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c46Ub: // global
           I64[Hp - 32] = sat_s45YT_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.85314989 UTC

[section ""data" . Numeric.showFFloat_$sshowFFloat1_closure" {
     Numeric.showFFloat_$sshowFFloat1_closure:
         const Numeric.showFFloat_$sshowFFloat1_info;
         const 0;
 },
 sat_s45YY_entry() //  [R1]
         { info_tbl: [(c46UB,
                       label: sat_s45YY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46UB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46UC; else goto c46UD;
       c46UC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46UD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c46Uy_info;
           _s45YU::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s45YU::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u46UH; else goto c46Uz;
       u46UH: // global
           call _c46Uy(R1) args: 0, res: 0, upd: 0;
       c46Uz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c46Uy() //  [R1]
         { info_tbl: [(c46Uy,
                       label: block_c46Uy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Uy: // global
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showFFloat_$sshowFFloat1_entry() //  [R2, R3]
         { info_tbl: [(c46UI,
                       label: Numeric.showFFloat_$sshowFFloat1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46UI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c46UM; else goto c46UL;
       c46UM: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showFFloat_$sshowFFloat1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c46UL: // global
           I64[Hp - 24] = sat_s45YY_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.862666251 UTC

[section ""data" . Numeric.showFFloat_closure" {
     Numeric.showFFloat_closure:
         const Numeric.showFFloat_info;
         const 0;
 },
 sat_s45Z2_entry() //  [R1]
         { info_tbl: [(c46Vd,
                       label: sat_s45Z2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Vd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46Ve; else goto c46Vf;
       c46Ve: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46Vf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.False_closure+1;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFFixed_closure+2;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showFFloat_entry() //  [R2, R3, R4]
         { info_tbl: [(c46Vg,
                       label: Numeric.showFFloat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Vg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c46Vk; else goto c46Vj;
       c46Vk: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showFFloat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c46Vj: // global
           I64[Hp - 32] = sat_s45Z2_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.8690605 UTC

[section ""data" . Numeric.showEFloat_$sshowEFloat1_closure" {
     Numeric.showEFloat_$sshowEFloat1_closure:
         const Numeric.showEFloat_$sshowEFloat1_info;
         const 0;
 },
 sat_s45Z7_entry() //  [R1]
         { info_tbl: [(c46VJ,
                       label: sat_s45Z7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46VJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c46VK; else goto c46VL;
       c46VK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46VL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c46VG_info;
           _s45Z3::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s45Z3::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u46VP; else goto c46VH;
       u46VP: // global
           call _c46VG(R1) args: 0, res: 0, upd: 0;
       c46VH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c46VG() //  [R1]
         { info_tbl: [(c46VG,
                       label: block_c46VG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46VG: // global
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFExponent_closure+1;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showEFloat_$sshowEFloat1_entry() //  [R2, R3]
         { info_tbl: [(c46VQ,
                       label: Numeric.showEFloat_$sshowEFloat1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46VQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c46VU; else goto c46VT;
       c46VU: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showEFloat_$sshowEFloat1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c46VT: // global
           I64[Hp - 24] = sat_s45Z7_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.877185888 UTC

[section ""data" . Numeric.showEFloat_closure" {
     Numeric.showEFloat_closure:
         const Numeric.showEFloat_info;
         const 0;
 },
 sat_s45Zb_entry() //  [R1]
         { info_tbl: [(c46Wl,
                       label: sat_s45Zb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Wl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c46Wm; else goto c46Wn;
       c46Wm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c46Wn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 32];
           R5 = GHC.Types.False_closure+1;
           R4 = P64[R1 + 24];
           R3 = GHC.Float.FFExponent_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Numeric.showEFloat_entry() //  [R2, R3, R4]
         { info_tbl: [(c46Wo,
                       label: Numeric.showEFloat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c46Wo: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c46Ws; else goto c46Wr;
       c46Ws: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Numeric.showEFloat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c46Wr: // global
           I64[Hp - 32] = sat_s45Zb_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = GHC.Base.++_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:58:59.883166006 UTC

[section ""relreadonly" . S45Zy_srt" {
     S45Zy_srt:
         const Text.Read.Lex.$wreadIntP_closure;
         const Numeric.readInt_closure;
         const Text.Read.Lex.readDecP4_closure;
         const Text.Read.Lex.$wreadIntP'_closure;
         const Numeric.readOct_closure;
         const Text.Read.Lex.numberToFixed1_closure;
         const Numeric.readDec_closure;
         const Text.Read.Lex.readDecP3_closure;
         const Numeric.readHex_closure;
         const Text.Read.Lex.$wnumberToRational_closure;
         const Text.Read.Lex.expect2_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const Numeric.readFloat_closure;
         const GHC.Read.lex1_closure;
         const GHC.Read.readParen_closure;
         const Numeric.readSigned_closure;
         const sat_s45Tt_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Numeric.showHFloat16_closure;
         const Numeric.showInt2_closure;
         const Numeric.showInt_closure;
         const Numeric.showInt1_closure;
         const GHC.Float.formatRealFloatAlt_closure;
         const Numeric.showFFloatAlt_closure;
         const Numeric.showGFloatAlt_closure;
         const Numeric.$wlvl_closure;
         const Numeric.showIntAtBase2_closure;
         const Numeric.showIntAtBase1_closure;
         const sat_s45Uu_closure;
         const Numeric.showIntAtBase3_closure;
         const Numeric.showIntAtBase_closure;
         const sat_s45V2_closure;
         const Numeric.showHex1_closure;
         const GHC.Show.intToDigit_closure;
         const Numeric.showHex_closure;
         const GHC.Show.$fShow(,)_go1_closure;
         const GHC.Err.error_closure;
         const $dIP3_r43OU_closure;
         const $wlvl2_r43OX_closure;
         const GHC.Show.$wintToDigit_closure;
         const $wshowIt1_r43OY_closure;
         const $wshowIt2_r43OZ_closure;
         const $wshowIt3_r43P0_closure;
         const $wshowIt4_r43P1_closure;
         const Numeric.showHFloat_hex_closure;
         const sat_s45Xu_closure;
         const GHC.Float.$wfloatToDigits_closure;
         const Numeric.showHFloat_cvt_closure;
         const Numeric.showHFloat9_closure;
         const Numeric.showHFloat14_closure;
         const Numeric.showHFloat15_closure;
         const Numeric.showHFloat4_closure;
         const Numeric.showHFloat6_closure;
         const Numeric.showHFloat16_closure;
         const Numeric.showHFloat1_closure;
         const Numeric.showHFloat3_closure;
         const Numeric.showHFloat_closure;
         const sat_s45Yq_closure;
         const Numeric.showOct1_closure;
         const Numeric.showOct_closure;
         const GHC.Float.$w$sformatRealFloatAlt1_closure;
         const Numeric.showGFloat_$sshowGFloat_closure;
         const Numeric.showFFloat_$sshowFFloat_closure;
         const Numeric.showEFloat_$sshowEFloat_closure;
         const GHC.Float.$w$sformatRealFloatAlt_closure;
         const Numeric.showGFloat_$sshowGFloat1_closure;
         const GHC.Float.formatRealFloatAlt_closure;
         const Numeric.showGFloat_closure;
         const Numeric.showFFloat_$sshowFFloat1_closure;
         const Numeric.showFFloat_closure;
         const Numeric.showEFloat_$sshowEFloat1_closure;
         const Numeric.showEFloat_closure;
 }]

