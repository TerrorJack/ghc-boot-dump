
==================== Output Cmm ====================
2018-03-16 16:06:40.010970215 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:40.011957483 UTC

[section ""data" . Control.Arrow.$p1ArrowLoop_closure" {
     Control.Arrow.$p1ArrowLoop_closure:
         const Control.Arrow.$p1ArrowLoop_info;
 },
 Control.Arrow.$p1ArrowLoop_entry() //  [R2]
         { info_tbl: [(cbNM5,
                       label: Control.Arrow.$p1ArrowLoop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNM5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNM6; else goto cbNM7;
       cbNM6: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowLoop_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNM7: // global
           I64[Sp - 8] = block_cbNM2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNMb; else goto cbNM3;
       ubNMb: // global
           call _cbNM2(R1) args: 0, res: 0, upd: 0;
       cbNM3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNM2() //  [R1]
         { info_tbl: [(cbNM2,
                       label: block_cbNM2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNM2: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.013198445 UTC

[section ""data" . Control.Arrow.loop_closure" {
     Control.Arrow.loop_closure:
         const Control.Arrow.loop_info;
 },
 Control.Arrow.loop_entry() //  [R2]
         { info_tbl: [(cbNMj,
                       label: Control.Arrow.loop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNMj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNMk; else goto cbNMl;
       cbNMk: // global
           R2 = R2;
           R1 = Control.Arrow.loop_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNMl: // global
           I64[Sp - 8] = block_cbNMg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNMp; else goto cbNMh;
       ubNMp: // global
           call _cbNMg(R1) args: 0, res: 0, upd: 0;
       cbNMh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNMg() //  [R1]
         { info_tbl: [(cbNMg,
                       label: block_cbNMg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNMg: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.014421444 UTC

[section ""data" . Control.Arrow.$p1ArrowApply_closure" {
     Control.Arrow.$p1ArrowApply_closure:
         const Control.Arrow.$p1ArrowApply_info;
 },
 Control.Arrow.$p1ArrowApply_entry() //  [R2]
         { info_tbl: [(cbNMx,
                       label: Control.Arrow.$p1ArrowApply_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNMx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNMy; else goto cbNMz;
       cbNMy: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowApply_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNMz: // global
           I64[Sp - 8] = block_cbNMu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNMD; else goto cbNMv;
       ubNMD: // global
           call _cbNMu(R1) args: 0, res: 0, upd: 0;
       cbNMv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNMu() //  [R1]
         { info_tbl: [(cbNMu,
                       label: block_cbNMu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNMu: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.015575624 UTC

[section ""data" . Control.Arrow.app_closure" {
     Control.Arrow.app_closure:
         const Control.Arrow.app_info;
 },
 Control.Arrow.app_entry() //  [R2]
         { info_tbl: [(cbNML,
                       label: Control.Arrow.app_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNML: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNMM; else goto cbNMN;
       cbNMM: // global
           R2 = R2;
           R1 = Control.Arrow.app_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNMN: // global
           I64[Sp - 8] = block_cbNMI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNMR; else goto cbNMJ;
       ubNMR: // global
           call _cbNMI(R1) args: 0, res: 0, upd: 0;
       cbNMJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNMI() //  [R1]
         { info_tbl: [(cbNMI,
                       label: block_cbNMI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNMI: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.016734483 UTC

[section ""data" . Control.Arrow.$p1ArrowChoice_closure" {
     Control.Arrow.$p1ArrowChoice_closure:
         const Control.Arrow.$p1ArrowChoice_info;
 },
 Control.Arrow.$p1ArrowChoice_entry() //  [R2]
         { info_tbl: [(cbNMZ,
                       label: Control.Arrow.$p1ArrowChoice_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNMZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNN0; else goto cbNN1;
       cbNN0: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowChoice_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNN1: // global
           I64[Sp - 8] = block_cbNMW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNN5; else goto cbNMX;
       ubNN5: // global
           call _cbNMW(R1) args: 0, res: 0, upd: 0;
       cbNMX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNMW() //  [R1]
         { info_tbl: [(cbNMW,
                       label: block_cbNMW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNMW: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.019569688 UTC

[section ""data" . Control.Arrow.left_closure" {
     Control.Arrow.left_closure:
         const Control.Arrow.left_info;
 },
 Control.Arrow.left_entry() //  [R2]
         { info_tbl: [(cbNNd,
                       label: Control.Arrow.left_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNNd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNNe; else goto cbNNf;
       cbNNe: // global
           R2 = R2;
           R1 = Control.Arrow.left_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNNf: // global
           I64[Sp - 8] = block_cbNNa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNNj; else goto cbNNb;
       ubNNj: // global
           call _cbNNa(R1) args: 0, res: 0, upd: 0;
       cbNNb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNNa() //  [R1]
         { info_tbl: [(cbNNa,
                       label: block_cbNNa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNNa: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.020641488 UTC

[section ""data" . Control.Arrow.right_closure" {
     Control.Arrow.right_closure:
         const Control.Arrow.right_info;
 },
 Control.Arrow.right_entry() //  [R2]
         { info_tbl: [(cbNNr,
                       label: Control.Arrow.right_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNNr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNNs; else goto cbNNt;
       cbNNs: // global
           R2 = R2;
           R1 = Control.Arrow.right_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNNt: // global
           I64[Sp - 8] = block_cbNNo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNNx; else goto cbNNp;
       ubNNx: // global
           call _cbNNo(R1) args: 0, res: 0, upd: 0;
       cbNNp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNNo() //  [R1]
         { info_tbl: [(cbNNo,
                       label: block_cbNNo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNNo: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.021752798 UTC

[section ""data" . Control.Arrow.+++_closure" {
     Control.Arrow.+++_closure:
         const Control.Arrow.+++_info;
 },
 Control.Arrow.+++_entry() //  [R2]
         { info_tbl: [(cbNNF,
                       label: Control.Arrow.+++_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNNF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNNG; else goto cbNNH;
       cbNNG: // global
           R2 = R2;
           R1 = Control.Arrow.+++_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNNH: // global
           I64[Sp - 8] = block_cbNNC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNNL; else goto cbNND;
       ubNNL: // global
           call _cbNNC(R1) args: 0, res: 0, upd: 0;
       cbNND: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNNC() //  [R1]
         { info_tbl: [(cbNNC,
                       label: block_cbNNC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNNC: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.02280785 UTC

[section ""data" . Control.Arrow.|||_closure" {
     Control.Arrow.|||_closure:
         const Control.Arrow.|||_info;
 },
 Control.Arrow.|||_entry() //  [R2]
         { info_tbl: [(cbNNT,
                       label: Control.Arrow.|||_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNNT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNNU; else goto cbNNV;
       cbNNU: // global
           R2 = R2;
           R1 = Control.Arrow.|||_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNNV: // global
           I64[Sp - 8] = block_cbNNQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNNZ; else goto cbNNR;
       ubNNZ: // global
           call _cbNNQ(R1) args: 0, res: 0, upd: 0;
       cbNNR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNNQ() //  [R1]
         { info_tbl: [(cbNNQ,
                       label: block_cbNNQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNNQ: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.023908235 UTC

[section ""data" . Control.Arrow.$p1ArrowPlus_closure" {
     Control.Arrow.$p1ArrowPlus_closure:
         const Control.Arrow.$p1ArrowPlus_info;
 },
 Control.Arrow.$p1ArrowPlus_entry() //  [R2]
         { info_tbl: [(cbNO7,
                       label: Control.Arrow.$p1ArrowPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNO7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNO8; else goto cbNO9;
       cbNO8: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNO9: // global
           I64[Sp - 8] = block_cbNO4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNOd; else goto cbNO5;
       ubNOd: // global
           call _cbNO4(R1) args: 0, res: 0, upd: 0;
       cbNO5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNO4() //  [R1]
         { info_tbl: [(cbNO4,
                       label: block_cbNO4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNO4: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.025003784 UTC

[section ""data" . Control.Arrow.<+>_closure" {
     Control.Arrow.<+>_closure:
         const Control.Arrow.<+>_info;
 },
 Control.Arrow.<+>_entry() //  [R2]
         { info_tbl: [(cbNOl,
                       label: Control.Arrow.<+>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNOl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNOm; else goto cbNOn;
       cbNOm: // global
           R2 = R2;
           R1 = Control.Arrow.<+>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNOn: // global
           I64[Sp - 8] = block_cbNOi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNOr; else goto cbNOj;
       ubNOr: // global
           call _cbNOi(R1) args: 0, res: 0, upd: 0;
       cbNOj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNOi() //  [R1]
         { info_tbl: [(cbNOi,
                       label: block_cbNOi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNOi: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.026138096 UTC

[section ""data" . Control.Arrow.$p1ArrowZero_closure" {
     Control.Arrow.$p1ArrowZero_closure:
         const Control.Arrow.$p1ArrowZero_info;
 },
 Control.Arrow.$p1ArrowZero_entry() //  [R2]
         { info_tbl: [(cbNOz,
                       label: Control.Arrow.$p1ArrowZero_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNOz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNOA; else goto cbNOB;
       cbNOA: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowZero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNOB: // global
           I64[Sp - 8] = block_cbNOw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNOF; else goto cbNOx;
       ubNOF: // global
           call _cbNOw(R1) args: 0, res: 0, upd: 0;
       cbNOx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNOw() //  [R1]
         { info_tbl: [(cbNOw,
                       label: block_cbNOw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNOw: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.027228685 UTC

[section ""data" . Control.Arrow.zeroArrow_closure" {
     Control.Arrow.zeroArrow_closure:
         const Control.Arrow.zeroArrow_info;
 },
 Control.Arrow.zeroArrow_entry() //  [R2]
         { info_tbl: [(cbNON,
                       label: Control.Arrow.zeroArrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNON: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNOO; else goto cbNOP;
       cbNOO: // global
           R2 = R2;
           R1 = Control.Arrow.zeroArrow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNOP: // global
           I64[Sp - 8] = block_cbNOK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNOT; else goto cbNOL;
       ubNOT: // global
           call _cbNOK(R1) args: 0, res: 0, upd: 0;
       cbNOL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNOK() //  [R1]
         { info_tbl: [(cbNOK,
                       label: block_cbNOK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNOK: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.028368541 UTC

[section ""data" . Control.Arrow.$p1Arrow_closure" {
     Control.Arrow.$p1Arrow_closure:
         const Control.Arrow.$p1Arrow_info;
 },
 Control.Arrow.$p1Arrow_entry() //  [R2]
         { info_tbl: [(cbNP1,
                       label: Control.Arrow.$p1Arrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNP1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNP2; else goto cbNP3;
       cbNP2: // global
           R2 = R2;
           R1 = Control.Arrow.$p1Arrow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNP3: // global
           I64[Sp - 8] = block_cbNOY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNP7; else goto cbNOZ;
       ubNP7: // global
           call _cbNOY(R1) args: 0, res: 0, upd: 0;
       cbNOZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNOY() //  [R1]
         { info_tbl: [(cbNOY,
                       label: block_cbNOY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNOY: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.029488093 UTC

[section ""data" . Control.Arrow.arr_closure" {
     Control.Arrow.arr_closure:
         const Control.Arrow.arr_info;
 },
 Control.Arrow.arr_entry() //  [R2]
         { info_tbl: [(cbNPf,
                       label: Control.Arrow.arr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNPf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNPg; else goto cbNPh;
       cbNPg: // global
           R2 = R2;
           R1 = Control.Arrow.arr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNPh: // global
           I64[Sp - 8] = block_cbNPc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNPl; else goto cbNPd;
       ubNPl: // global
           call _cbNPc(R1) args: 0, res: 0, upd: 0;
       cbNPd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNPc() //  [R1]
         { info_tbl: [(cbNPc,
                       label: block_cbNPc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNPc: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.030607677 UTC

[section ""data" . Control.Arrow.first_closure" {
     Control.Arrow.first_closure:
         const Control.Arrow.first_info;
 },
 Control.Arrow.first_entry() //  [R2]
         { info_tbl: [(cbNPt,
                       label: Control.Arrow.first_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNPt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNPu; else goto cbNPv;
       cbNPu: // global
           R2 = R2;
           R1 = Control.Arrow.first_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNPv: // global
           I64[Sp - 8] = block_cbNPq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNPz; else goto cbNPr;
       ubNPz: // global
           call _cbNPq(R1) args: 0, res: 0, upd: 0;
       cbNPr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNPq() //  [R1]
         { info_tbl: [(cbNPq,
                       label: block_cbNPq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNPq: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.031711654 UTC

[section ""data" . Control.Arrow.second_closure" {
     Control.Arrow.second_closure:
         const Control.Arrow.second_info;
 },
 Control.Arrow.second_entry() //  [R2]
         { info_tbl: [(cbNPH,
                       label: Control.Arrow.second_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNPH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNPI; else goto cbNPJ;
       cbNPI: // global
           R2 = R2;
           R1 = Control.Arrow.second_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNPJ: // global
           I64[Sp - 8] = block_cbNPE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNPN; else goto cbNPF;
       ubNPN: // global
           call _cbNPE(R1) args: 0, res: 0, upd: 0;
       cbNPF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNPE() //  [R1]
         { info_tbl: [(cbNPE,
                       label: block_cbNPE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNPE: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.032849658 UTC

[section ""data" . Control.Arrow.***_closure" {
     Control.Arrow.***_closure:
         const Control.Arrow.***_info;
 },
 Control.Arrow.***_entry() //  [R2]
         { info_tbl: [(cbNPV,
                       label: Control.Arrow.***_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNPV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNPW; else goto cbNPX;
       cbNPW: // global
           R2 = R2;
           R1 = Control.Arrow.***_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNPX: // global
           I64[Sp - 8] = block_cbNPS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNQ1; else goto cbNPT;
       ubNQ1: // global
           call _cbNPS(R1) args: 0, res: 0, upd: 0;
       cbNPT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNPS() //  [R1]
         { info_tbl: [(cbNPS,
                       label: block_cbNPS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNPS: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.034011375 UTC

[section ""data" . Control.Arrow.&&&_closure" {
     Control.Arrow.&&&_closure:
         const Control.Arrow.&&&_info;
 },
 Control.Arrow.&&&_entry() //  [R2]
         { info_tbl: [(cbNQ9,
                       label: Control.Arrow.&&&_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNQ9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNQa; else goto cbNQb;
       cbNQa: // global
           R2 = R2;
           R1 = Control.Arrow.&&&_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNQb: // global
           I64[Sp - 8] = block_cbNQ6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNQf; else goto cbNQ7;
       ubNQf: // global
           call _cbNQ6(R1) args: 0, res: 0, upd: 0;
       cbNQ7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNQ6() //  [R1]
         { info_tbl: [(cbNQ6,
                       label: block_cbNQ6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNQ6: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.035442793 UTC

[section ""data" . Control.Arrow.$c***_closure" {
     Control.Arrow.$c***_closure:
         const Control.Arrow.$c***_info;
 },
 sat_sbNEx_entry() //  [R1]
         { info_tbl: [(cbNQp,
                       label: sat_sbNEx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNQp: // global
           _sbNEx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbNQq; else goto cbNQr;
       cbNQr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbNQt; else goto cbNQs;
       cbNQt: // global
           HpAlloc = 24;
           goto cbNQq;
       cbNQq: // global
           R1 = _sbNEx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNQs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNEx::P64;
           _sbNEm::P64 = P64[_sbNEx::P64 + 16];
           _sbNEn::P64 = P64[_sbNEx::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sbNEn::P64;
           R2 = Hp - 16;
           R1 = _sbNEm::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNEs_entry() //  [R1]
         { info_tbl: [(cbNQz,
                       label: sat_sbNEs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNQz: // global
           _sbNEs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbNQA; else goto cbNQB;
       cbNQB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbNQD; else goto cbNQC;
       cbNQD: // global
           HpAlloc = 24;
           goto cbNQA;
       cbNQA: // global
           R1 = _sbNEs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNQC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNEs::P64;
           _sbNEl::P64 = P64[_sbNEs::P64 + 16];
           _sbNEn::P64 = P64[_sbNEs::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbNEn::P64;
           R2 = Hp - 16;
           R1 = _sbNEl::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$c***_entry() //  [R2, R3, R4]
         { info_tbl: [(cbNQF,
                       label: Control.Arrow.$c***_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNQF: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbNQJ; else goto cbNQI;
       cbNQJ: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$c***_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbNQI: // global
           I64[Hp - 80] = sat_sbNEx_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sbNEs_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.037098705 UTC

[section ""data" . Control.Arrow.$fArrow(->)_$carr_closure" {
     Control.Arrow.$fArrow(->)_$carr_closure:
         const Control.Arrow.$fArrow(->)_$carr_info;
 },
 Control.Arrow.$fArrow(->)_$carr_entry() //  [R2]
         { info_tbl: [(cbNQO,
                       label: Control.Arrow.$fArrow(->)_$carr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNQO: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.038002028 UTC

[section ""data" . Control.Arrow.$fCategoryTYPEKleisli1_closure" {
     Control.Arrow.$fCategoryTYPEKleisli1_closure:
         const Control.Arrow.$fCategoryTYPEKleisli1_info;
 },
 Control.Arrow.$fCategoryTYPEKleisli1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbNQW,
                       label: Control.Arrow.$fCategoryTYPEKleisli1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNQW: // global
           _sbNEC::P64 = R5;
           _sbNEB::P64 = R4;
           _sbNEA::P64 = R3;
           _sbNEz::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbNQX; else goto cbNQY;
       cbNQY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbNR0; else goto cbNQZ;
       cbNR0: // global
           HpAlloc = 32;
           goto cbNQX;
       cbNQX: // global
           R5 = _sbNEC::P64;
           R4 = _sbNEB::P64;
           R3 = _sbNEA::P64;
           R2 = _sbNEz::P64;
           R1 = Control.Arrow.$fCategoryTYPEKleisli1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbNQZ: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbNEB::P64;
           P64[Hp] = _sbNEC::P64;
           R2 = _sbNEz::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNEA::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.039354232 UTC

[section ""data" . Control.Arrow.$fCategoryTYPEKleisli_closure" {
     Control.Arrow.$fCategoryTYPEKleisli_closure:
         const Control.Arrow.$fCategoryTYPEKleisli_info;
 },
 sat_sbNEG_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbNRa,
                       label: sat_sbNEG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNRa: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fCategoryTYPEKleisli1_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNEF_entry() //  [R1]
         { info_tbl: [(cbNRh,
                       label: sat_sbNEF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNRh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbNRi; else goto cbNRj;
       cbNRi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNRj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fCategoryTYPEKleisli_entry() //  [R2]
         { info_tbl: [(cbNRl,
                       label: Control.Arrow.$fCategoryTYPEKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNRl: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbNRp; else goto cbNRo;
       cbNRp: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Arrow.$fCategoryTYPEKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNRo: // global
           I64[Hp - 56] = sat_sbNEG_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbNEF_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Category.C:Category_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 53;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.041118739 UTC

[section ""data" . Control.Arrow.$fArrowKleisli4_closure" {
     Control.Arrow.$fArrowKleisli4_closure:
         const Control.Arrow.$fArrowKleisli4_info;
 },
 sat_sbNEV_entry() //  [R1, R2]
         { info_tbl: [(cbNRB,
                       label: sat_sbNEV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNRB: // global
           _sbNET::P64 = R2;
           _sbNEV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbNRC; else goto cbNRD;
       cbNRD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbNRF; else goto cbNRE;
       cbNRF: // global
           HpAlloc = 24;
           goto cbNRC;
       cbNRC: // global
           R2 = _sbNET::P64;
           R1 = _sbNEV::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNRE: // global
           _sbNEH::P64 = P64[_sbNEV::P64 + 7];
           _sbNEK::P64 = P64[_sbNEV::P64 + 15];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbNEK::P64;
           P64[Hp] = _sbNET::P64;
           R2 = _sbNEH::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbNES_entry() //  [R1]
         { info_tbl: [(cbNRL,
                       label: sat_sbNES_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNRL: // global
           _sbNES::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbNRM; else goto cbNRN;
       cbNRN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbNRP; else goto cbNRO;
       cbNRP: // global
           HpAlloc = 24;
           goto cbNRM;
       cbNRM: // global
           R1 = _sbNES::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNRO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNES::P64;
           _sbNEI::P64 = P64[_sbNES::P64 + 16];
           _sbNEJ::P64 = P64[_sbNES::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sbNEJ::P64;
           R2 = Hp - 16;
           R1 = _sbNEI::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli4_entry() //  [R2, R3, R4]
         { info_tbl: [(cbNRQ,
                       label: Control.Arrow.$fArrowKleisli4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNRQ: // global
           _sbNEJ::P64 = R4;
           _sbNEI::P64 = R3;
           _sbNEH::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbNRR; else goto cbNRS;
       cbNRS: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbNRU; else goto cbNRT;
       cbNRU: // global
           HpAlloc = 80;
           goto cbNRR;
       cbNRR: // global
           R4 = _sbNEJ::P64;
           R3 = _sbNEI::P64;
           R2 = _sbNEH::P64;
           R1 = Control.Arrow.$fArrowKleisli4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbNRT: // global
           I64[Hp - 72] = stg_sel_0_upd_info;
           P64[Hp - 56] = _sbNEJ::P64;
           I64[Hp - 48] = sat_sbNEV_info;
           P64[Hp - 40] = _sbNEH::P64;
           P64[Hp - 32] = Hp - 72;
           I64[Hp - 24] = sat_sbNES_info;
           P64[Hp - 8] = _sbNEI::P64;
           P64[Hp] = _sbNEJ::P64;
           R2 = _sbNEH::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.04333761 UTC

[section ""data" . Control.Arrow.$fArrowKleisli3_closure" {
     Control.Arrow.$fArrowKleisli3_closure:
         const Control.Arrow.$fArrowKleisli3_info;
 },
 sat_sbNFa_entry() //  [R1, R2]
         { info_tbl: [(cbNS6,
                       label: sat_sbNFa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNS6: // global
           _sbNF8::P64 = R2;
           _sbNFa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbNS7; else goto cbNS8;
       cbNS8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbNSa; else goto cbNS9;
       cbNSa: // global
           HpAlloc = 24;
           goto cbNS7;
       cbNS7: // global
           R2 = _sbNF8::P64;
           R1 = _sbNFa::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNS9: // global
           _sbNEW::P64 = P64[_sbNFa::P64 + 7];
           _sbNEZ::P64 = P64[_sbNFa::P64 + 15];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbNF8::P64;
           P64[Hp] = _sbNEZ::P64;
           R2 = _sbNEW::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbNF7_entry() //  [R1]
         { info_tbl: [(cbNSg,
                       label: sat_sbNF7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNSg: // global
           _sbNF7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbNSh; else goto cbNSi;
       cbNSi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbNSk; else goto cbNSj;
       cbNSk: // global
           HpAlloc = 24;
           goto cbNSh;
       cbNSh: // global
           R1 = _sbNF7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNSj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNF7::P64;
           _sbNEX::P64 = P64[_sbNF7::P64 + 16];
           _sbNEY::P64 = P64[_sbNF7::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbNEY::P64;
           R2 = Hp - 16;
           R1 = _sbNEX::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli3_entry() //  [R2, R3, R4]
         { info_tbl: [(cbNSl,
                       label: Control.Arrow.$fArrowKleisli3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNSl: // global
           _sbNEY::P64 = R4;
           _sbNEX::P64 = R3;
           _sbNEW::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbNSm; else goto cbNSn;
       cbNSn: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbNSp; else goto cbNSo;
       cbNSp: // global
           HpAlloc = 80;
           goto cbNSm;
       cbNSm: // global
           R4 = _sbNEY::P64;
           R3 = _sbNEX::P64;
           R2 = _sbNEW::P64;
           R1 = Control.Arrow.$fArrowKleisli3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbNSo: // global
           I64[Hp - 72] = stg_sel_1_upd_info;
           P64[Hp - 56] = _sbNEY::P64;
           I64[Hp - 48] = sat_sbNFa_info;
           P64[Hp - 40] = _sbNEW::P64;
           P64[Hp - 32] = Hp - 72;
           I64[Hp - 24] = sat_sbNF7_info;
           P64[Hp - 8] = _sbNEX::P64;
           P64[Hp] = _sbNEY::P64;
           R2 = _sbNEW::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.045151335 UTC

[section ""data" . Control.Arrow.$fArrowKleisli5_closure" {
     Control.Arrow.$fArrowKleisli5_closure:
         const Control.Arrow.$fArrowKleisli5_info;
 },
 Control.Arrow.$fArrowKleisli5_entry() //  [R2, R3, R4]
         { info_tbl: [(cbNSv,
                       label: Control.Arrow.$fArrowKleisli5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNSv: // global
           _sbNFd::P64 = R4;
           _sbNFc::P64 = R3;
           _sbNFb::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbNSw; else goto cbNSx;
       cbNSx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbNSz; else goto cbNSy;
       cbNSz: // global
           HpAlloc = 32;
           goto cbNSw;
       cbNSw: // global
           R4 = _sbNFd::P64;
           R3 = _sbNFc::P64;
           R2 = _sbNFb::P64;
           R1 = Control.Arrow.$fArrowKleisli5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbNSy: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbNFc::P64;
           P64[Hp] = _sbNFd::P64;
           R2 = _sbNFb::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.046303574 UTC

[section ""data" . Control.Arrow.$fArrowPlusKleisli1_closure" {
     Control.Arrow.$fArrowPlusKleisli1_closure:
         const Control.Arrow.$fArrowPlusKleisli1_info;
 },
 Control.Arrow.$fArrowPlusKleisli1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbNSG,
                       label: Control.Arrow.$fArrowPlusKleisli1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNSG: // global
           _sbNFi::P64 = R5;
           _sbNFh::P64 = R4;
           _sbNFg::P64 = R3;
           _sbNFf::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbNSH; else goto cbNSI;
       cbNSI: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbNSK; else goto cbNSJ;
       cbNSK: // global
           HpAlloc = 64;
           goto cbNSH;
       cbNSH: // global
           R5 = _sbNFi::P64;
           R4 = _sbNFh::P64;
           R3 = _sbNFg::P64;
           R2 = _sbNFf::P64;
           R1 = Control.Arrow.$fArrowPlusKleisli1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbNSJ: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sbNFh::P64;
           P64[Hp - 32] = _sbNFi::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbNFg::P64;
           P64[Hp] = _sbNFi::P64;
           R2 = _sbNFf::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.047517486 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_$capp_closure" {
     Control.Arrow.$fAlternativeArrowMonad_$capp_closure:
         const Control.Arrow.$fAlternativeArrowMonad_$capp_info;
 },
 Control.Arrow.$fAlternativeArrowMonad_$capp_entry() //  [R2]
         { info_tbl: [(cbNSS,
                       label: Control.Arrow.$fAlternativeArrowMonad_$capp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNSS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNST; else goto cbNSU;
       cbNST: // global
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_$capp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNSU: // global
           I64[Sp - 8] = block_cbNSP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNSY; else goto cbNSQ;
       ubNSY: // global
           call _cbNSP(R1) args: 0, res: 0, upd: 0;
       cbNSQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNSP() //  [R1]
         { info_tbl: [(cbNSP,
                       label: block_cbNSP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNSP: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.048834975 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad5_closure" {
     Control.Arrow.$fApplicativeArrowMonad5_closure:
         const Control.Arrow.$fApplicativeArrowMonad5_info;
 },
 sat_sbNFt_entry() //  [R1]
         { info_tbl: [(cbNT7,
                       label: sat_sbNFt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNT7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbNT8; else goto cbNT9;
       cbNT8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNT9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad5_entry() //  [R2, R3, R4]
         { info_tbl: [(cbNTc,
                       label: Control.Arrow.$fApplicativeArrowMonad5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNTc: // global
           _sbNFr::P64 = R4;
           _sbNFq::P64 = R3;
           _sbNFp::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbNTd; else goto cbNTe;
       cbNTe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbNTg; else goto cbNTf;
       cbNTg: // global
           HpAlloc = 32;
           goto cbNTd;
       cbNTd: // global
           R4 = _sbNFr::P64;
           R3 = _sbNFq::P64;
           R2 = _sbNFp::P64;
           R1 = Control.Arrow.$fApplicativeArrowMonad5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbNTf: // global
           I64[Hp - 24] = sat_sbNFt_info;
           P64[Hp - 8] = _sbNFp::P64;
           P64[Hp] = _sbNFq::P64;
           I64[Sp - 24] = block_cbNTa_info;
           R2 = _sbNFp::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNFr::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbNTa() //  [R1]
         { info_tbl: [(cbNTa,
                       label: block_cbNTa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNTa: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.050593623 UTC

[section ""data" . Control.Arrow.$fFunctorArrowMonad1_closure" {
     Control.Arrow.$fFunctorArrowMonad1_closure:
         const Control.Arrow.$fFunctorArrowMonad1_info;
 },
 sat_sbNFz_entry() //  [R1]
         { info_tbl: [(cbNTx,
                       label: sat_sbNFz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNTx: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNFA_entry() //  [R1]
         { info_tbl: [(cbNTA,
                       label: sat_sbNFA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNTA: // global
           _sbNFA::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbNTB; else goto cbNTC;
       cbNTC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbNTE; else goto cbNTD;
       cbNTE: // global
           HpAlloc = 16;
           goto cbNTB;
       cbNTB: // global
           R1 = _sbNFA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNTD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNFA::P64;
           _sbNFu::P64 = P64[_sbNFA::P64 + 16];
           _sbNFv::P64 = P64[_sbNFA::P64 + 24];
           I64[Hp - 8] = sat_sbNFz_info;
           P64[Hp] = _sbNFv::P64;
           R2 = _sbNFu::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fFunctorArrowMonad1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbNTH,
                       label: Control.Arrow.$fFunctorArrowMonad1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNTH: // global
           _sbNFw::P64 = R4;
           _sbNFv::P64 = R3;
           _sbNFu::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbNTI; else goto cbNTJ;
       cbNTJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbNTL; else goto cbNTK;
       cbNTL: // global
           HpAlloc = 32;
           goto cbNTI;
       cbNTI: // global
           R4 = _sbNFw::P64;
           R3 = _sbNFv::P64;
           R2 = _sbNFu::P64;
           R1 = Control.Arrow.$fFunctorArrowMonad1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbNTK: // global
           I64[Hp - 24] = sat_sbNFA_info;
           P64[Hp - 8] = _sbNFu::P64;
           P64[Hp] = _sbNFv::P64;
           I64[Sp - 24] = block_cbNTF_info;
           R2 = _sbNFu::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNFw::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbNTF() //  [R1]
         { info_tbl: [(cbNTF,
                       label: block_cbNTF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNTF: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.052564578 UTC

[section ""data" . Control.Arrow.$fFunctorArrowMonad_closure" {
     Control.Arrow.$fFunctorArrowMonad_closure:
         const Control.Arrow.$fFunctorArrowMonad_info;
 },
 sat_sbNFD_entry() //  [R1, R2, R3]
         { info_tbl: [(cbNTY,
                       label: sat_sbNFD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNTY: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fFunctorArrowMonad1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNFC_entry() //  [R1, R2, R3]
         { info_tbl: [(cbNU6,
                       label: sat_sbNFC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNU6: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fApplicativeArrowMonad5_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fFunctorArrowMonad_entry() //  [R2]
         { info_tbl: [(cbNUa,
                       label: Control.Arrow.$fFunctorArrowMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNUa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbNUe; else goto cbNUd;
       cbNUe: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Arrow.$fFunctorArrowMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNUd: // global
           I64[Hp - 48] = sat_sbNFD_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sbNFC_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.05430199 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad2_closure" {
     Control.Arrow.$fAlternativeArrowMonad2_closure:
         const Control.Arrow.$fAlternativeArrowMonad2_info;
 },
 sat_sbNFJ_entry() //  [R1]
         { info_tbl: [(cbNUn,
                       label: sat_sbNFJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNUn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbNUo; else goto cbNUp;
       cbNUo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNUp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Arrow.&&&_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNFI_entry() //  [R1]
         { info_tbl: [(cbNUu,
                       label: sat_sbNFI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNUu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbNUv; else goto cbNUw;
       cbNUv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNUw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fAlternativeArrowMonad_$capp_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbNUz,
                       label: Control.Arrow.$fAlternativeArrowMonad2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNUz: // global
           _sbNFG::P64 = R4;
           _sbNFF::P64 = R3;
           _sbNFE::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbNUA; else goto cbNUB;
       cbNUB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbNUD; else goto cbNUC;
       cbNUD: // global
           HpAlloc = 64;
           goto cbNUA;
       cbNUA: // global
           R4 = _sbNFG::P64;
           R3 = _sbNFF::P64;
           R2 = _sbNFE::P64;
           R1 = Control.Arrow.$fAlternativeArrowMonad2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbNUC: // global
           I64[Hp - 56] = sat_sbNFJ_info;
           P64[Hp - 40] = _sbNFE::P64;
           P64[Hp - 32] = _sbNFF::P64;
           P64[Hp - 24] = _sbNFG::P64;
           I64[Hp - 16] = sat_sbNFI_info;
           P64[Hp] = _sbNFE::P64;
           I64[Sp - 24] = block_cbNUx_info;
           R2 = _sbNFE::P64;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbNUx() //  [R1]
         { info_tbl: [(cbNUx,
                       label: block_cbNUx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNUx: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbNUj::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbNUj::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.056200651 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad6_closure" {
     Control.Arrow.$fApplicativeArrowMonad6_closure:
         const Control.Arrow.$fApplicativeArrowMonad6_info;
 },
 sat_sbNFN_entry() //  [R1]
         { info_tbl: [(cbNUQ,
                       label: sat_sbNFN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNUQ: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad6_entry() //  [R2, R3]
         { info_tbl: [(cbNUT,
                       label: Control.Arrow.$fApplicativeArrowMonad6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNUT: // global
           _sbNFL::P64 = R3;
           _sbNFK::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbNUU; else goto cbNUV;
       cbNUV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbNUX; else goto cbNUW;
       cbNUX: // global
           HpAlloc = 16;
           goto cbNUU;
       cbNUU: // global
           R3 = _sbNFL::P64;
           R2 = _sbNFK::P64;
           R1 = Control.Arrow.$fApplicativeArrowMonad6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbNUW: // global
           I64[Hp - 8] = sat_sbNFN_info;
           P64[Hp] = _sbNFL::P64;
           R2 = _sbNFK::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Arrow.arr_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.057562657 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad4_closure" {
     Control.Arrow.$fApplicativeArrowMonad4_closure:
         const Control.Arrow.$fApplicativeArrowMonad4_info;
 },
 sat_sbNFR_entry() //  [R1]
         { info_tbl: [(cbNV6,
                       label: sat_sbNFR_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNV6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbNV7; else goto cbNV8;
       cbNV7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNV8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fApplicativeArrowMonad5_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad4_entry() //  [R2, R3, R4]
         { info_tbl: [(cbNV9,
                       label: Control.Arrow.$fApplicativeArrowMonad4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNV9: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbNVd; else goto cbNVc;
       cbNVd: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fApplicativeArrowMonad4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbNVc: // global
           I64[Hp - 32] = sat_sbNFR_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = Hp - 32;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad2_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.058774415 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad3_closure" {
     Control.Arrow.$fApplicativeArrowMonad3_closure:
         const Control.Arrow.$fApplicativeArrowMonad3_info;
 },
 Control.Arrow.$fApplicativeArrowMonad3_entry() //  [R3]
         { info_tbl: [(cbNVi,
                       label: Control.Arrow.$fApplicativeArrowMonad3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNVi: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.059946812 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad2_closure" {
     Control.Arrow.$fApplicativeArrowMonad2_closure:
         const Control.Arrow.$fApplicativeArrowMonad2_info;
 },
 sat_sbNFY_entry() //  [R1]
         { info_tbl: [(cbNVx,
                       label: sat_sbNFY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNVx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbNVy; else goto cbNVz;
       cbNVy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNVz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fApplicativeArrowMonad3_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNFZ_entry() //  [R1]
         { info_tbl: [(cbNVC,
                       label: sat_sbNFZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNVC: // global
           _sbNFZ::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbNVD; else goto cbNVE;
       cbNVE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbNVG; else goto cbNVF;
       cbNVG: // global
           HpAlloc = 24;
           goto cbNVD;
       cbNVD: // global
           R1 = _sbNFZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNVF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNFZ::P64;
           _sbNFU::P64 = P64[_sbNFZ::P64 + 16];
           _sbNFV::P64 = P64[_sbNFZ::P64 + 24];
           I64[Hp - 16] = sat_sbNFY_info;
           P64[Hp] = _sbNFU::P64;
           I64[Sp - 40] = block_cbNVA_info;
           R2 = _sbNFU::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbNFV::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbNVA() //  [R1]
         { info_tbl: [(cbNVA,
                       label: block_cbNVA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNVA: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbNVK,
                       label: Control.Arrow.$fApplicativeArrowMonad2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNVK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbNVO; else goto cbNVN;
       cbNVO: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fApplicativeArrowMonad2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbNVN: // global
           I64[Hp - 24] = sat_sbNFZ_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R4 = R4;
           R3 = Hp - 24;
           R2 = R2;
           call Control.Arrow.$fAlternativeArrowMonad2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.062682052 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad1_closure" {
     Control.Arrow.$fApplicativeArrowMonad1_closure:
         const Control.Arrow.$fApplicativeArrowMonad1_info;
 },
 sat_sbNG3_entry() //  [R1]
         { info_tbl: [(cbNW1,
                       label: sat_sbNG3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNW1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbNW2; else goto cbNW3;
       cbNW2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNW3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Base.const_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNG4_entry() //  [R1]
         { info_tbl: [(cbNW6,
                       label: sat_sbNG4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNW6: // global
           _sbNG4::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbNW7; else goto cbNW8;
       cbNW8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbNWa; else goto cbNW9;
       cbNWa: // global
           HpAlloc = 24;
           goto cbNW7;
       cbNW7: // global
           R1 = _sbNG4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNW9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNG4::P64;
           _sbNG0::P64 = P64[_sbNG4::P64 + 16];
           _sbNG1::P64 = P64[_sbNG4::P64 + 24];
           I64[Hp - 16] = sat_sbNG3_info;
           P64[Hp] = _sbNG0::P64;
           I64[Sp - 40] = block_cbNW4_info;
           R2 = _sbNG0::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbNG1::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbNW4() //  [R1]
         { info_tbl: [(cbNW4,
                       label: block_cbNW4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNW4: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad1_entry() //  [R2, R3]
         { info_tbl: [(cbNWe,
                       label: Control.Arrow.$fApplicativeArrowMonad1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNWe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbNWi; else goto cbNWh;
       cbNWi: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fApplicativeArrowMonad1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbNWh: // global
           I64[Hp - 24] = sat_sbNG4_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad2_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.065058292 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad_closure" {
     Control.Arrow.$fApplicativeArrowMonad_closure:
         const Control.Arrow.$fApplicativeArrowMonad_info;
 },
 sat_sbNGb_entry() //  [R1, R2]
         { info_tbl: [(cbNWs,
                       label: sat_sbNGb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNWs: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fApplicativeArrowMonad1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNGa_entry() //  [R1, R2, R3]
         { info_tbl: [(cbNWA,
                       label: sat_sbNGa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNWA: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fApplicativeArrowMonad2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNG9_entry() //  [R1, R2, R3]
         { info_tbl: [(cbNWI,
                       label: sat_sbNG9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNWI: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fApplicativeArrowMonad4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNG8_entry() //  [R1, R2, R3]
         { info_tbl: [(cbNWQ,
                       label: sat_sbNG8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNWQ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fAlternativeArrowMonad2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNG7_entry() //  [R1, R2]
         { info_tbl: [(cbNWY,
                       label: sat_sbNG7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNWY: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fApplicativeArrowMonad6_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNG6_entry() //  [R1]
         { info_tbl: [(cbNX5,
                       label: sat_sbNG6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNX5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbNX6; else goto cbNX7;
       cbNX6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNX7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fFunctorArrowMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad_entry() //  [R2]
         { info_tbl: [(cbNX9,
                       label: Control.Arrow.$fApplicativeArrowMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNX9: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cbNXd; else goto cbNXc;
       cbNXd: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = Control.Arrow.$fApplicativeArrowMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNXc: // global
           I64[Hp - 152] = sat_sbNGb_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbNGa_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbNG9_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbNG8_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbNG7_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbNG6_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 87;
           P64[Hp - 24] = Hp - 102;
           P64[Hp - 16] = Hp - 118;
           P64[Hp - 8] = Hp - 134;
           P64[Hp] = Hp - 151;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.068021062 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad_$c>>=_closure" {
     Control.Arrow.$fMonadArrowMonad_$c>>=_closure:
         const Control.Arrow.$fMonadArrowMonad_$c>>=_info;
 },
 sat_sbNGk_entry() //  [R1, R2]
         { info_tbl: [(cbNXF,
                       label: sat_sbNGk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNXF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbNXJ; else goto cbNXI;
       cbNXJ: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNXI: // global
           _sbNGe::P64 = P64[R1 + 7];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sbNGe::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Tuple.()_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNGl_entry() //  [R1]
         { info_tbl: [(cbNXK,
                       label: sat_sbNGl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNXK: // global
           _sbNGl::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbNXL; else goto cbNXM;
       cbNXM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbNXO; else goto cbNXN;
       cbNXO: // global
           HpAlloc = 16;
           goto cbNXL;
       cbNXL: // global
           R1 = _sbNGl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNXN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNGl::P64;
           _sbNGe::P64 = P64[_sbNGl::P64 + 16];
           _sbNGf::P64 = P64[_sbNGl::P64 + 24];
           I64[Hp - 8] = sat_sbNGk_info;
           P64[Hp] = _sbNGe::P64;
           R2 = _sbNGf::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNGm_entry() //  [R1]
         { info_tbl: [(cbNXP,
                       label: sat_sbNGm_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNXP: // global
           _sbNGm::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbNXQ; else goto cbNXR;
       cbNXR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbNXT; else goto cbNXS;
       cbNXT: // global
           HpAlloc = 32;
           goto cbNXQ;
       cbNXQ: // global
           R1 = _sbNGm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNXS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNGm::P64;
           _sbNGd::P64 = P64[_sbNGm::P64 + 16];
           _sbNGe::P64 = P64[_sbNGm::P64 + 24];
           _sbNGf::P64 = P64[_sbNGm::P64 + 32];
           _sbNGg::P64 = P64[_sbNGm::P64 + 40];
           I64[Hp - 24] = sat_sbNGl_info;
           P64[Hp - 8] = _sbNGe::P64;
           P64[Hp] = _sbNGf::P64;
           R2 = _sbNGg::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sbNGd::P64;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNGh_entry() //  [R1]
         { info_tbl: [(cbNXY,
                       label: sat_sbNGh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNXY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbNXZ; else goto cbNY0;
       cbNXZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNY0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.app_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fMonadArrowMonad_$c>>=_entry() //  [R2, R3, R4]
         { info_tbl: [(cbNY1,
                       label: Control.Arrow.$fMonadArrowMonad_$c>>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNY1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbNY2; else goto cbNY3;
       cbNY2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fMonadArrowMonad_$c>>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbNY3: // global
           I64[Sp - 32] = block_cbNXi_info;
           _sbNGc::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbNGc::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Arrow.$p1ArrowApply_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbNXi() //  [R1]
         { info_tbl: [(cbNXi,
                       label: block_cbNXi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNXi: // global
           I64[Sp - 8] = block_cbNXm_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbNXm() //  [R1]
         { info_tbl: [(cbNXm,
                       label: block_cbNXm_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNXm: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbNY7; else goto cbNY6;
       cbNY7: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbNY6: // global
           I64[Hp - 64] = sat_sbNGm_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbNGh_info;
           P64[Hp] = P64[Sp + 16];
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 16;
           P64[Sp + 32] = Hp - 64;
           Sp = Sp + 16;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.070877583 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad_$cp1Monad_closure" {
     Control.Arrow.$fMonadArrowMonad_$cp1Monad_closure:
         const Control.Arrow.$fMonadArrowMonad_$cp1Monad_info;
 },
 sat_sbNGo_entry() //  [R1]
         { info_tbl: [(cbNYg,
                       label: sat_sbNGo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNYg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbNYh; else goto cbNYi;
       cbNYh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNYi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowApply_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fMonadArrowMonad_$cp1Monad_entry() //  [R2]
         { info_tbl: [(cbNYj,
                       label: Control.Arrow.$fMonadArrowMonad_$cp1Monad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNYj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbNYn; else goto cbNYm;
       cbNYn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Arrow.$fMonadArrowMonad_$cp1Monad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNYm: // global
           I64[Hp - 16] = sat_sbNGo_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Arrow.$fApplicativeArrowMonad_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.072219138 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad1_closure" {
     Control.Arrow.$fMonadArrowMonad1_closure:
         const Control.Arrow.$fMonadArrowMonad1_info;
 },
 sat_sbNGt_entry() //  [R1]
         { info_tbl: [(cbNYx,
                       label: sat_sbNGt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNYx: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fMonadArrowMonad1_entry() //  [R2, R3]
         { info_tbl: [(cbNYC,
                       label: Control.Arrow.$fMonadArrowMonad1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNYC: // global
           _sbNGq::P64 = R3;
           _sbNGp::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbNYD; else goto cbNYE;
       cbNYE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbNYG; else goto cbNYF;
       cbNYG: // global
           HpAlloc = 16;
           goto cbNYD;
       cbNYD: // global
           R3 = _sbNGq::P64;
           R2 = _sbNGp::P64;
           R1 = Control.Arrow.$fMonadArrowMonad1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbNYF: // global
           I64[Hp - 8] = sat_sbNGt_info;
           P64[Hp] = _sbNGq::P64;
           I64[Sp - 16] = block_cbNYA_info;
           R2 = _sbNGp::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowApply_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbNYA() //  [R1]
         { info_tbl: [(cbNYA,
                       label: block_cbNYA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNYA: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call Control.Arrow.arr_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.073677865 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad_$c>>_closure" {
     Control.Arrow.$fMonadArrowMonad_$c>>_closure:
         const Control.Arrow.$fMonadArrowMonad_$c>>_info;
 },
 sat_sbNGy_entry() //  [R1]
         { info_tbl: [(cbNYT,
                       label: sat_sbNGy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNYT: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fMonadArrowMonad_$c>>_entry() //  [R2, R3, R4]
         { info_tbl: [(cbNYW,
                       label: Control.Arrow.$fMonadArrowMonad_$c>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNYW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbNZ0; else goto cbNYZ;
       cbNZ0: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fMonadArrowMonad_$c>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbNYZ: // global
           I64[Hp - 8] = sat_sbNGy_info;
           P64[Hp] = R4;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Control.Arrow.$fMonadArrowMonad_$c>>=_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.074727108 UTC

[section ""data" . lvl_rbNC6_closure" {
     lvl_rbNC6_closure:
         const lvl_rbNC6_info;
         const 0;
 },
 lvl_rbNC6_entry() //  [R2]
         { info_tbl: [(cbNZ5,
                       label: lvl_rbNC6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNZ5: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.076065208 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad_closure" {
     Control.Arrow.$fMonadArrowMonad_closure:
         const Control.Arrow.$fMonadArrowMonad_info;
         const 0;
 },
 sat_sbNGE_entry() //  [R1, R2]
         { info_tbl: [(cbNZi,
                       label: sat_sbNGE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNZi: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fMonadArrowMonad1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNGD_entry() //  [R1, R2, R3]
         { info_tbl: [(cbNZq,
                       label: sat_sbNGD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNZq: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fMonadArrowMonad_$c>>_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNGC_entry() //  [R1, R2, R3]
         { info_tbl: [(cbNZy,
                       label: sat_sbNGC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNZy: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fMonadArrowMonad_$c>>=_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNGB_entry() //  [R1]
         { info_tbl: [(cbNZF,
                       label: sat_sbNGB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNZF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbNZG; else goto cbNZH;
       cbNZG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNZH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fMonadArrowMonad_$cp1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fMonadArrowMonad_entry() //  [R2]
         { info_tbl: [(cbNZJ,
                       label: Control.Arrow.$fMonadArrowMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNZJ: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cbNZN; else goto cbNZM;
       cbNZN: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Control.Arrow.$fMonadArrowMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNZM: // global
           I64[Hp - 112] = sat_sbNGE_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbNGD_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbNGC_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbNGB_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 94;
           P64[Hp - 8] = Hp - 111;
           P64[Hp] = lvl_rbNC6_closure+1;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.078067069 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad3_closure" {
     Control.Arrow.$fAlternativeArrowMonad3_closure:
         const Control.Arrow.$fAlternativeArrowMonad3_info;
 },
 Control.Arrow.$fAlternativeArrowMonad3_entry() //  [R2]
         { info_tbl: [(cbNZU,
                       label: Control.Arrow.$fAlternativeArrowMonad3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNZU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbNZV; else goto cbNZW;
       cbNZV: // global
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbNZW: // global
           I64[Sp - 8] = block_cbNZS_info;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Arrow.$p1ArrowPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbNZS() //  [R1]
         { info_tbl: [(cbNZS,
                       label: block_cbNZS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNZS: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Arrow.zeroArrow_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.079255073 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_closure" {
     Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_closure:
         const Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_info;
 },
 sat_sbNGJ_entry() //  [R1]
         { info_tbl: [(cbO0a,
                       label: sat_sbNGJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO0a: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbO0b; else goto cbO0c;
       cbO0b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO0c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbO08_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1ArrowPlus_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbO08() //  [R1]
         { info_tbl: [(cbO08,
                       label: block_cbO08_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO08: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_entry() //  [R2]
         { info_tbl: [(cbO0g,
                       label: Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO0g: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbO0k; else goto cbO0j;
       cbO0k: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbO0j: // global
           I64[Hp - 16] = sat_sbNGJ_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Arrow.$fApplicativeArrowMonad_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.080518404 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad1_closure" {
     Control.Arrow.$fAlternativeArrowMonad1_closure:
         const Control.Arrow.$fAlternativeArrowMonad1_info;
 },
 Control.Arrow.$fAlternativeArrowMonad1_entry() //  []
         { info_tbl: [(cbO0p,
                       label: Control.Arrow.$fAlternativeArrowMonad1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO0p: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.084923149 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_$csome_closure" {
     Control.Arrow.$fAlternativeArrowMonad_$csome_closure:
         const Control.Arrow.$fAlternativeArrowMonad_$csome_info;
 },
 sat_sbNGV_entry() //  [R1]
         { info_tbl: [(cbO0U,
                       label: sat_sbNGV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO0U: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbO0V; else goto cbO0W;
       cbO0V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO0W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fAlternativeArrowMonad1_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNGW_entry() //  [R1]
         { info_tbl: [(cbO0X,
                       label: sat_sbNGW_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO0X: // global
           _sbNGW::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbO0Y; else goto cbO0Z;
       cbO0Z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbO11; else goto cbO10;
       cbO11: // global
           HpAlloc = 24;
           goto cbO0Y;
       cbO0Y: // global
           R1 = _sbNGW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO10: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNGW::P64;
           _sbNGL::P64 = P64[_sbNGW::P64 + 16];
           _sbNGN::P64 = P64[_sbNGW::P64 + 24];
           _sbNGP::P64 = P64[_sbNGW::P64 + 32];
           I64[Hp - 16] = sat_sbNGV_info;
           P64[Hp] = _sbNGP::P64;
           R2 = _sbNGL::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbNGN::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call Control.Arrow.<+>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNGT_entry() //  [R1]
         { info_tbl: [(cbO1a,
                       label: sat_sbNGT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO1a: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbO1b; else goto cbO1c;
       cbO1b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO1c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNGU_entry() //  [R1]
         { info_tbl: [(cbO1f,
                       label: sat_sbNGU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO1f: // global
           _sbNGU::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbO1g; else goto cbO1h;
       cbO1h: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbO1j; else goto cbO1i;
       cbO1j: // global
           HpAlloc = 24;
           goto cbO1g;
       cbO1g: // global
           R1 = _sbNGU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO1i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNGU::P64;
           _sbNGM::P64 = P64[_sbNGU::P64 + 16];
           _sbNGP::P64 = P64[_sbNGU::P64 + 24];
           I64[Hp - 16] = sat_sbNGT_info;
           P64[Hp] = _sbNGP::P64;
           I64[Sp - 40] = block_cbO1d_info;
           R2 = _sbNGP::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbNGM::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbO1d() //  [R1]
         { info_tbl: [(cbO1d,
                       label: block_cbO1d_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO1d: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNGX_entry() //  [R1]
         { info_tbl: [(cbO1n,
                       label: sat_sbNGX_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO1n: // global
           _sbNGX::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbO1o; else goto cbO1p;
       cbO1p: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbO1r; else goto cbO1q;
       cbO1r: // global
           HpAlloc = 72;
           goto cbO1o;
       cbO1o: // global
           R1 = _sbNGX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO1q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNGX::P64;
           _sbNGL::P64 = P64[_sbNGX::P64 + 16];
           _sbNGM::P64 = P64[_sbNGX::P64 + 24];
           _sbNGN::P64 = P64[_sbNGX::P64 + 32];
           _sbNGP::P64 = P64[_sbNGX::P64 + 40];
           I64[Hp - 64] = sat_sbNGW_info;
           P64[Hp - 48] = _sbNGL::P64;
           P64[Hp - 40] = _sbNGN::P64;
           P64[Hp - 32] = _sbNGP::P64;
           I64[Hp - 24] = sat_sbNGU_info;
           P64[Hp - 8] = _sbNGM::P64;
           P64[Hp] = _sbNGP::P64;
           R2 = _sbNGP::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 64;
           Sp = Sp - 40;
           call Control.Arrow.&&&_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNGR_entry() //  [R1]
         { info_tbl: [(cbO1w,
                       label: sat_sbNGR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO1w: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbO1x; else goto cbO1y;
       cbO1x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO1y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fAlternativeArrowMonad_$capp_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 some_v_sbNGN_entry() //  [R1]
         { info_tbl: [(cbO1z,
                       label: some_v_sbNGN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO1z: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbO1B; else goto cbO1C;
       cbO1B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO1C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cbO0A_info;
           _sbNGL::P64 = P64[R1 + 16];
           R2 = _sbNGL::P64;
           P64[Sp - 40] = _sbNGL::P64;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = R1;
           Sp = Sp - 48;
           call Control.Arrow.$p1ArrowPlus_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbO0A() //  [R1]
         { info_tbl: [(cbO0A,
                       label: block_cbO0A_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO0A: // global
           I64[Sp] = block_cbO0E_info;
           R2 = R1;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbO0E() //  [R1]
         { info_tbl: [(cbO0E,
                       label: block_cbO0E_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO0E: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbO1G; else goto cbO1F;
       cbO1G: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbO1F: // global
           I64[Hp - 64] = sat_sbNGX_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbNGR_info;
           P64[Hp] = R1;
           I64[Sp + 8] = block_cbO1A_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 24] = Hp - 64;
           Sp = Sp + 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbO1A() //  [R1]
         { info_tbl: [(cbO1A,
                       label: block_cbO1A_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO1A: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad_$csome_entry() //  [R2, R3]
         { info_tbl: [(cbO1L,
                       label: Control.Arrow.$fAlternativeArrowMonad_$csome_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO1L: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbO1P; else goto cbO1O;
       cbO1P: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_$csome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbO1O: // global
           I64[Hp - 24] = some_v_sbNGN_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.089755517 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_$cmany_closure" {
     Control.Arrow.$fAlternativeArrowMonad_$cmany_closure:
         const Control.Arrow.$fAlternativeArrowMonad_$cmany_info;
 },
 $dApplicative_sbNH1_entry() //  [R1]
         { info_tbl: [(cbO22,
                       label: $dApplicative_sbNH1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO22: // global
           R2 = P64[R1 + 16];
           call Control.Arrow.$p1ArrowPlus_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dApplicative1_sbNH2_entry() //  [R1]
         { info_tbl: [(cbO29,
                       label: $dApplicative1_sbNH2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO29: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbO2a; else goto cbO2b;
       cbO2a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO2b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNH7_entry() //  [R1]
         { info_tbl: [(cbO2g,
                       label: sat_sbNH7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO2g: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbO2h; else goto cbO2i;
       cbO2h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO2i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fAlternativeArrowMonad1_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNH4_entry() //  [R1]
         { info_tbl: [(cbO2v,
                       label: sat_sbNH4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO2v: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbO2w; else goto cbO2x;
       cbO2w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO2x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNH5_entry() //  [R1]
         { info_tbl: [(cbO2A,
                       label: sat_sbNH5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO2A: // global
           _sbNH5::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbO2B; else goto cbO2C;
       cbO2C: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbO2E; else goto cbO2D;
       cbO2E: // global
           HpAlloc = 24;
           goto cbO2B;
       cbO2B: // global
           R1 = _sbNH5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO2D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNH5::P64;
           _sbNGZ::P64 = P64[_sbNH5::P64 + 16];
           _sbNH2::P64 = P64[_sbNH5::P64 + 24];
           I64[Hp - 16] = sat_sbNH4_info;
           P64[Hp] = _sbNH2::P64;
           I64[Sp - 40] = block_cbO2y_info;
           R2 = _sbNH2::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbNGZ::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbO2y() //  [R1]
         { info_tbl: [(cbO2y,
                       label: block_cbO2y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO2y: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNH6_entry() //  [R1]
         { info_tbl: [(cbO2I,
                       label: sat_sbNH6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO2I: // global
           _sbNH6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbO2J; else goto cbO2K;
       cbO2K: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbO2M; else goto cbO2L;
       cbO2M: // global
           HpAlloc = 32;
           goto cbO2J;
       cbO2J: // global
           R1 = _sbNH6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO2L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNH6::P64;
           _sbNGZ::P64 = P64[_sbNH6::P64 + 16];
           _sbNH0::P64 = P64[_sbNH6::P64 + 24];
           _sbNH2::P64 = P64[_sbNH6::P64 + 32];
           I64[Hp - 24] = sat_sbNH5_info;
           P64[Hp - 8] = _sbNGZ::P64;
           P64[Hp] = _sbNH2::P64;
           R4 = _sbNH0::P64;
           R3 = Hp - 24;
           R2 = _sbNH2::P64;
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad2_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 many_v_sbNH0_entry() //  [R1]
         { info_tbl: [(cbO2N,
                       label: many_v_sbNH0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO2N: // global
           _sbNH0::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbO2O; else goto cbO2P;
       cbO2P: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cbO2R; else goto cbO2Q;
       cbO2R: // global
           HpAlloc = 112;
           goto cbO2O;
       cbO2O: // global
           R1 = _sbNH0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO2Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNH0::P64;
           _sbNGY::P64 = P64[_sbNH0::P64 + 16];
           _sbNGZ::P64 = P64[_sbNH0::P64 + 24];
           I64[Hp - 104] = $dApplicative_sbNH1_info;
           P64[Hp - 88] = _sbNGY::P64;
           I64[Hp - 80] = $dApplicative1_sbNH2_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = sat_sbNH7_info;
           _cbO25::P64 = Hp - 80;
           P64[Hp - 40] = _cbO25::P64;
           I64[Hp - 32] = sat_sbNH6_info;
           P64[Hp - 16] = _sbNGZ::P64;
           P64[Hp - 8] = _sbNH0::P64;
           P64[Hp] = _cbO25::P64;
           R2 = _sbNGY::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call Control.Arrow.<+>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad_$cmany_entry() //  [R2, R3]
         { info_tbl: [(cbO2S,
                       label: Control.Arrow.$fAlternativeArrowMonad_$cmany_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO2S: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbO2W; else goto cbO2V;
       cbO2W: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_$cmany_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbO2V: // global
           I64[Hp - 24] = many_v_sbNH0_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.093442304 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_closure" {
     Control.Arrow.$fAlternativeArrowMonad_closure:
         const Control.Arrow.$fAlternativeArrowMonad_info;
 },
 sat_sbNHf_entry() //  [R1, R2]
         { info_tbl: [(cbO36,
                       label: sat_sbNHf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO36: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fAlternativeArrowMonad_$cmany_entry(R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNHe_entry() //  [R1, R2]
         { info_tbl: [(cbO3e,
                       label: sat_sbNHe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO3e: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fAlternativeArrowMonad_$csome_entry(R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNHd_entry() //  [R1, R2, R3]
         { info_tbl: [(cbO3m,
                       label: sat_sbNHd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO3m: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbO3n; else goto cbO3o;
       cbO3n: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbO3o: // global
           _sbNHb::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbNHb::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Control.Arrow.<+>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbNHa_entry() //  [R1]
         { info_tbl: [(cbO3t,
                       label: sat_sbNHa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO3t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbO3u; else goto cbO3v;
       cbO3u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO3v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad3_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNH9_entry() //  [R1]
         { info_tbl: [(cbO3A,
                       label: sat_sbNH9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO3A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbO3B; else goto cbO3C;
       cbO3B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO3C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad_entry() //  [R2]
         { info_tbl: [(cbO3E,
                       label: Control.Arrow.$fAlternativeArrowMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO3E: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cbO3I; else goto cbO3H;
       cbO3I: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbO3H: // global
           I64[Hp - 136] = sat_sbNHf_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbNHe_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbNHd_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbNHa_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbNH9_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 102;
           P64[Hp - 8] = Hp - 119;
           P64[Hp] = Hp - 135;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.095981243 UTC

[section ""data" . Control.Arrow.$fMonadPlusArrowMonad_closure" {
     Control.Arrow.$fMonadPlusArrowMonad_closure:
         const Control.Arrow.$fMonadPlusArrowMonad_info;
         const 0;
 },
 sat_sbNHn_entry() //  [R1, R2, R3]
         { info_tbl: [(cbO3S,
                       label: sat_sbNHn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO3S: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbO3T; else goto cbO3U;
       cbO3T: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbO3U: // global
           _sbNHl::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbNHl::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Control.Arrow.<+>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbNHk_entry() //  [R1]
         { info_tbl: [(cbO3Z,
                       label: sat_sbNHk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO3Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbO40; else goto cbO41;
       cbO40: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO41: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad3_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNHj_entry() //  [R1]
         { info_tbl: [(cbO46,
                       label: sat_sbNHj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO46: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbO47; else goto cbO48;
       cbO47: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO48: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fMonadArrowMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNHi_entry() //  [R1]
         { info_tbl: [(cbO4d,
                       label: sat_sbNHi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO4d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbO4e; else goto cbO4f;
       cbO4e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO4f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fMonadPlusArrowMonad_entry() //  [R2, R3]
         { info_tbl: [(cbO4h,
                       label: Control.Arrow.$fMonadPlusArrowMonad_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO4h: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cbO4l; else goto cbO4k;
       cbO4l: // global
           HpAlloc = 128;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fMonadPlusArrowMonad_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbO4k: // global
           I64[Hp - 120] = sat_sbNHn_info;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = sat_sbNHk_info;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sbNHj_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbNHi_info;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = GHC.Base.C:MonadPlus_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 118;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.098498709 UTC

[section ""data" . Control.Arrow.$fArrowLoop(->)_$cloop_closure" {
     Control.Arrow.$fArrowLoop(->)_$cloop_closure:
         const Control.Arrow.$fArrowLoop(->)_$cloop_info;
 },
 ds_sbNHq_entry() //  [R1]
         { info_tbl: [(cbO4w,
                       label: ds_sbNHq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO4w: // global
           _sbNHq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbO4x; else goto cbO4y;
       cbO4y: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbO4A; else goto cbO4z;
       cbO4A: // global
           HpAlloc = 48;
           goto cbO4x;
       cbO4x: // global
           R1 = _sbNHq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO4z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNHq::P64;
           _sbNHo::P64 = P64[_sbNHq::P64 + 16];
           _sbNHp::P64 = P64[_sbNHq::P64 + 24];
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sbNHq::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbNHp::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 15;
           R1 = _sbNHo::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowLoop(->)_$cloop_entry() //  [R2, R3]
         { info_tbl: [(cbO4E,
                       label: Control.Arrow.$fArrowLoop(->)_$cloop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO4E: // global
           _sbNHp::P64 = R3;
           _sbNHo::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cbO4F; else goto cbO4G;
       cbO4G: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbO4I; else goto cbO4H;
       cbO4I: // global
           HpAlloc = 32;
           goto cbO4F;
       cbO4F: // global
           R3 = _sbNHp::P64;
           R2 = _sbNHo::P64;
           R1 = Control.Arrow.$fArrowLoop(->)_$cloop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbO4H: // global
           I64[Hp - 24] = ds_sbNHq_info;
           P64[Hp - 8] = _sbNHo::P64;
           P64[Hp] = _sbNHp::P64;
           I64[Sp - 8] = block_cbO4B_info;
           R1 = Hp - 24;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubO4M; else goto cbO4C;
       ubO4M: // global
           call _cbO4B(R1) args: 0, res: 0, upd: 0;
       cbO4C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbO4B() //  [R1]
         { info_tbl: [(cbO4B,
                       label: block_cbO4B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO4B: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.100901906 UTC

[section ""data" . Control.Arrow.$fArrowLoopKleisli1_closure" {
     Control.Arrow.$fArrowLoopKleisli1_closure:
         const Control.Arrow.$fArrowLoopKleisli1_info;
 },
 sat_sbNHN_entry() //  [R1, R2]
         { info_tbl: [(cbO51,
                       label: sat_sbNHN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO51: // global
           _sbNHI::P64 = R2;
           _sbNHN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbO52; else goto cbO53;
       cbO53: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbO55; else goto cbO54;
       cbO55: // global
           HpAlloc = 24;
           goto cbO52;
       cbO52: // global
           R2 = _sbNHI::P64;
           R1 = _sbNHN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbO54: // global
           _sbNHC::P64 = P64[_sbNHN::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbNHI::P64;
           R2 = _sbNHC::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbNHE_entry() //  [R1]
         { info_tbl: [(cbO5j,
                       label: sat_sbNHE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO5j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbO5k; else goto cbO5l;
       cbO5k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO5l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Tuple.snd_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNHG_entry() //  [R1, R2]
         { info_tbl: [(cbO5n,
                       label: sat_sbNHG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO5n: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbO5r; else goto cbO5q;
       cbO5r: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbO5q: // global
           _sbNHA::P64 = P64[R1 + 7];
           _sbNHB::P64 = P64[R1 + 15];
           I64[Hp - 40] = sat_sbNHE_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbNHB::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 15;
           R1 = _sbNHA::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNHH_entry() //  [R1]
         { info_tbl: [(cbO5s,
                       label: sat_sbNHH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO5s: // global
           _sbNHH::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbO5t; else goto cbO5u;
       cbO5u: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbO5w; else goto cbO5v;
       cbO5w: // global
           HpAlloc = 24;
           goto cbO5t;
       cbO5t: // global
           R1 = _sbNHH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO5v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNHH::P64;
           _sbNHz::P64 = P64[_sbNHH::P64 + 16];
           _sbNHA::P64 = P64[_sbNHH::P64 + 24];
           _sbNHB::P64 = P64[_sbNHH::P64 + 32];
           I64[Hp - 16] = sat_sbNHG_info;
           P64[Hp - 8] = _sbNHA::P64;
           P64[Hp] = _sbNHB::P64;
           R2 = _sbNHz::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowLoopKleisli1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbO5x,
                       label: Control.Arrow.$fArrowLoopKleisli1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO5x: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbO5y; else goto cbO5z;
       cbO5y: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fArrowLoopKleisli1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbO5z: // global
           I64[Sp - 32] = block_cbO4R_info;
           _sbNHz::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbNHz::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbO4R() //  [R1]
         { info_tbl: [(cbO4R,
                       label: block_cbO4R_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO4R: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbO5C; else goto cbO5B;
       cbO5C: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbO5B: // global
           I64[Hp - 48] = sat_sbNHN_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sbNHH_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 32;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp + 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.103538505 UTC

[section ""data" . lvl1_rbNC7_closure" {
     lvl1_rbNC7_closure:
         const lvl1_rbNC7_info;
 },
 lvl1_rbNC7_entry() //  [R2]
         { info_tbl: [(cbO5O,
                       label: lvl1_rbNC7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO5O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbO5P; else goto cbO5Q;
       cbO5P: // global
           R2 = R2;
           R1 = lvl1_rbNC7_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbO5Q: // global
           I64[Sp - 8] = block_cbO5H_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubO5X; else goto cbO5I;
       ubO5X: // global
           call _cbO5H(R1) args: 0, res: 0, upd: 0;
       cbO5I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbO5H() //  [R1]
         { info_tbl: [(cbO5H,
                       label: block_cbO5H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO5H: // global
           if (R1 & 7 == 1) goto cbO5L; else goto cbO5M;
       cbO5L: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbO5M: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.1051118 UTC

[section ""data" . Control.Arrow.$dm|||_closure" {
     Control.Arrow.$dm|||_closure:
         const Control.Arrow.$dm|||_info;
 },
 sat_sbNHY_entry() //  [R1]
         { info_tbl: [(cbO6a,
                       label: sat_sbNHY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO6a: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbO6b; else goto cbO6c;
       cbO6b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO6c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Arrow.+++_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNHX_entry() //  [R1]
         { info_tbl: [(cbO6h,
                       label: sat_sbNHX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO6h: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbO6i; else goto cbO6j;
       cbO6i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO6j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl1_rbNC7_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dm|||_entry() //  [R2, R3, R4]
         { info_tbl: [(cbO6k,
                       label: Control.Arrow.$dm|||_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO6k: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbO6m; else goto cbO6n;
       cbO6m: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$dm|||_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbO6n: // global
           I64[Sp - 32] = block_cbO62_info;
           _sbNHS::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbNHS::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Arrow.$p1ArrowChoice_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbO62() //  [R1]
         { info_tbl: [(cbO62,
                       label: block_cbO62_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO62: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbO6q; else goto cbO6p;
       cbO6q: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbO6p: // global
           I64[Hp - 56] = sat_sbNHY_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           I64[Hp - 16] = sat_sbNHX_info;
           P64[Hp] = R1;
           I64[Sp + 8] = block_cbO6l_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 24] = Hp - 56;
           Sp = Sp + 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbO6l() //  [R1]
         { info_tbl: [(cbO6l,
                       label: block_cbO6l_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO6l: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.107221649 UTC

[section ""data" . mirror_rbNC8_closure" {
     mirror_rbNC8_closure:
         const mirror_rbNC8_info;
 },
 mirror_rbNC8_entry() //  [R2]
         { info_tbl: [(cbO6G,
                       label: mirror_rbNC8_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO6G: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbO6H; else goto cbO6I;
       cbO6H: // global
           R2 = R2;
           R1 = mirror_rbNC8_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbO6I: // global
           I64[Sp - 8] = block_cbO6z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubO6V; else goto cbO6A;
       ubO6V: // global
           call _cbO6z(R1) args: 0, res: 0, upd: 0;
       cbO6A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbO6z() //  [R1]
         { info_tbl: [(cbO6z,
                       label: block_cbO6z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO6z: // global
           if (R1 & 7 == 1) goto cbO6D; else goto cbO6E;
       cbO6D: // global
           Hp = Hp + 16;
           _sbNI0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbO6U; else goto cbO6N;
       cbO6N: // global
           _sbNI1::P64 = P64[_sbNI0::P64 + 7];
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = _sbNI1::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbO6E: // global
           Hp = Hp + 16;
           _sbNI0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbO6U; else goto cbO6T;
       cbO6U: // global
           HpAlloc = 16;
           R1 = _sbNI0::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbO6T: // global
           _sbNI2::P64 = P64[_sbNI0::P64 + 6];
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = _sbNI2::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.109581189 UTC

[section ""data" . Control.Arrow.$dm+++_closure" {
     Control.Arrow.$dm+++_closure:
         const Control.Arrow.$dm+++_info;
 },
 sat_sbNIb_entry() //  [R1]
         { info_tbl: [(cbO7k,
                       label: sat_sbNIb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO7k: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbO7l; else goto cbO7m;
       cbO7l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO7m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.left_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNIa_entry() //  [R1]
         { info_tbl: [(cbO7r,
                       label: sat_sbNIa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO7r: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbO7s; else goto cbO7t;
       cbO7s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO7t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = mirror_rbNC8_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNIc_entry() //  [R1]
         { info_tbl: [(cbO7u,
                       label: sat_sbNIc_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO7u: // global
           _sbNIc::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbO7v; else goto cbO7w;
       cbO7w: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbO7y; else goto cbO7x;
       cbO7y: // global
           HpAlloc = 56;
           goto cbO7v;
       cbO7v: // global
           R1 = _sbNIc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO7x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNIc::P64;
           _sbNI3::P64 = P64[_sbNIc::P64 + 16];
           _sbNI4::P64 = P64[_sbNIc::P64 + 24];
           _sbNI6::P64 = P64[_sbNIc::P64 + 32];
           _sbNI7::P64 = P64[_sbNIc::P64 + 40];
           I64[Hp - 48] = sat_sbNIb_info;
           P64[Hp - 32] = _sbNI3::P64;
           P64[Hp - 24] = _sbNI4::P64;
           I64[Hp - 16] = sat_sbNIa_info;
           P64[Hp] = _sbNI6::P64;
           R2 = _sbNI7::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNI9_entry() //  [R1]
         { info_tbl: [(cbO7D,
                       label: sat_sbNI9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO7D: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbO7E; else goto cbO7F;
       cbO7E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO7F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.left_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNId_entry() //  [R1]
         { info_tbl: [(cbO7G,
                       label: sat_sbNId_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO7G: // global
           _sbNId::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbO7H; else goto cbO7I;
       cbO7I: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbO7K; else goto cbO7J;
       cbO7K: // global
           HpAlloc = 80;
           goto cbO7H;
       cbO7H: // global
           R1 = _sbNId::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO7J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNId::P64;
           _sbNI3::P64 = P64[_sbNId::P64 + 16];
           _sbNI4::P64 = P64[_sbNId::P64 + 24];
           _sbNI5::P64 = P64[_sbNId::P64 + 32];
           _sbNI6::P64 = P64[_sbNId::P64 + 40];
           _sbNI7::P64 = P64[_sbNId::P64 + 48];
           I64[Hp - 72] = sat_sbNIc_info;
           P64[Hp - 56] = _sbNI3::P64;
           P64[Hp - 48] = _sbNI4::P64;
           P64[Hp - 40] = _sbNI6::P64;
           P64[Hp - 32] = _sbNI7::P64;
           I64[Hp - 24] = sat_sbNI9_info;
           P64[Hp - 8] = _sbNI3::P64;
           P64[Hp] = _sbNI5::P64;
           R2 = _sbNI7::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNI8_entry() //  [R1]
         { info_tbl: [(cbO7P,
                       label: sat_sbNI8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO7P: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbO7Q; else goto cbO7R;
       cbO7Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO7R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = mirror_rbNC8_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dm+++_entry() //  [R2, R3, R4]
         { info_tbl: [(cbO7S,
                       label: Control.Arrow.$dm+++_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO7S: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbO7T; else goto cbO7U;
       cbO7T: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$dm+++_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbO7U: // global
           I64[Sp - 32] = block_cbO70_info;
           _sbNI3::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbNI3::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Arrow.$p1ArrowChoice_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbO70() //  [R1]
         { info_tbl: [(cbO70,
                       label: block_cbO70_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO70: // global
           I64[Sp - 8] = block_cbO74_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbO74() //  [R1]
         { info_tbl: [(cbO74,
                       label: block_cbO74_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO74: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbO7Y; else goto cbO7X;
       cbO7Y: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbO7X: // global
           I64[Hp - 72] = sat_sbNId_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 32];
           _sbNI6::P64 = P64[Sp + 8];
           P64[Hp - 32] = _sbNI6::P64;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbNI8_info;
           P64[Hp] = _sbNI6::P64;
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 16;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.112984387 UTC

[section ""data" . Control.Arrow.$dmright_closure" {
     Control.Arrow.$dmright_closure:
         const Control.Arrow.$dmright_info;
 },
 sat_sbNIh_entry() //  [R1]
         { info_tbl: [(cbO89,
                       label: sat_sbNIh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO89: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbO8d; else goto cbO8e;
       cbO8d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO8e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbO87_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1ArrowChoice_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbO87() //  [R1]
         { info_tbl: [(cbO87,
                       label: block_cbO87_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO87: // global
           I64[Sp] = block_cbO8c_info;
           R2 = R1;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbO8c() //  [R1]
         { info_tbl: [(cbO8c,
                       label: block_cbO8c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO8c: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Category.id_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dmright_entry() //  [R2]
         { info_tbl: [(cbO8k,
                       label: Control.Arrow.$dmright_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO8k: // global
           _sbNIe::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbO8l; else goto cbO8m;
       cbO8m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbO8o; else goto cbO8n;
       cbO8o: // global
           HpAlloc = 24;
           goto cbO8l;
       cbO8l: // global
           R2 = _sbNIe::P64;
           R1 = Control.Arrow.$dmright_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbO8n: // global
           I64[Hp - 16] = sat_sbNIh_info;
           P64[Hp] = _sbNIe::P64;
           R2 = _sbNIe::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Control.Arrow.+++_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.114860521 UTC

[section ""data" . Control.Arrow.$dmleft_closure" {
     Control.Arrow.$dmleft_closure:
         const Control.Arrow.$dmleft_info;
 },
 sat_sbNIm_entry() //  [R1]
         { info_tbl: [(cbO8z,
                       label: sat_sbNIm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO8z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbO8D; else goto cbO8E;
       cbO8D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO8E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbO8x_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1ArrowChoice_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbO8x() //  [R1]
         { info_tbl: [(cbO8x,
                       label: block_cbO8x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO8x: // global
           I64[Sp] = block_cbO8C_info;
           R2 = R1;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbO8C() //  [R1]
         { info_tbl: [(cbO8C,
                       label: block_cbO8C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO8C: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Category.id_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dmleft_entry() //  [R2, R3]
         { info_tbl: [(cbO8K,
                       label: Control.Arrow.$dmleft_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO8K: // global
           _sbNIj::P64 = R3;
           _sbNIi::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbO8L; else goto cbO8M;
       cbO8M: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbO8O; else goto cbO8N;
       cbO8O: // global
           HpAlloc = 24;
           goto cbO8L;
       cbO8L: // global
           R3 = _sbNIj::P64;
           R2 = _sbNIi::P64;
           R1 = Control.Arrow.$dmleft_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbO8N: // global
           I64[Hp - 16] = sat_sbNIm_info;
           P64[Hp] = _sbNIi::P64;
           R2 = _sbNIi::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbNIj::P64;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Control.Arrow.+++_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.116361062 UTC

[section ""data" . lvl2_rbNC9_closure" {
     lvl2_rbNC9_closure:
         const lvl2_rbNC9_info;
 },
 lvl2_rbNC9_entry() //  [R2]
         { info_tbl: [(cbO8U,
                       label: lvl2_rbNC9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO8U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbO8Y; else goto cbO8X;
       cbO8Y: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = lvl2_rbNC9_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbO8X: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.117652007 UTC

[section ""data" . Control.Arrow.$dm&&&_closure" {
     Control.Arrow.$dm&&&_closure:
         const Control.Arrow.$dm&&&_info;
 },
 sat_sbNIt_entry() //  [R1]
         { info_tbl: [(cbO97,
                       label: sat_sbNIt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO97: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbO98; else goto cbO99;
       cbO98: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO99: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl2_rbNC9_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNIs_entry() //  [R1]
         { info_tbl: [(cbO9e,
                       label: sat_sbNIs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO9e: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbO9f; else goto cbO9g;
       cbO9f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO9g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Arrow.***_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dm&&&_entry() //  [R2, R3, R4]
         { info_tbl: [(cbO9j,
                       label: Control.Arrow.$dm&&&_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO9j: // global
           _sbNIq::P64 = R4;
           _sbNIp::P64 = R3;
           _sbNIo::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbO9k; else goto cbO9l;
       cbO9l: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbO9n; else goto cbO9m;
       cbO9n: // global
           HpAlloc = 64;
           goto cbO9k;
       cbO9k: // global
           R4 = _sbNIq::P64;
           R3 = _sbNIp::P64;
           R2 = _sbNIo::P64;
           R1 = Control.Arrow.$dm&&&_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbO9m: // global
           I64[Hp - 56] = sat_sbNIt_info;
           P64[Hp - 40] = _sbNIo::P64;
           I64[Hp - 32] = sat_sbNIs_info;
           P64[Hp - 16] = _sbNIo::P64;
           P64[Hp - 8] = _sbNIp::P64;
           P64[Hp] = _sbNIq::P64;
           I64[Sp - 24] = block_cbO9h_info;
           R2 = _sbNIo::P64;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbO9h() //  [R1]
         { info_tbl: [(cbO9h,
                       label: block_cbO9h_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO9h: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbO93::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbO93::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.119403349 UTC

[section ""data" . swap_rbNCa_closure" {
     swap_rbNCa_closure:
         const swap_rbNCa_info;
 },
 swap_rbNCa_entry() //  [R2]
         { info_tbl: [(cbO9y,
                       label: swap_rbNCa_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO9y: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbO9C; else goto cbO9B;
       cbO9C: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = swap_rbNCa_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbO9B: // global
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.121334843 UTC

[section ""data" . Control.Arrow.$dm***_closure" {
     Control.Arrow.$dm***_closure:
         const Control.Arrow.$dm***_info;
 },
 sat_sbNIK_entry() //  [R1]
         { info_tbl: [(cbO9X,
                       label: sat_sbNIK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO9X: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbO9Y; else goto cbO9Z;
       cbO9Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbO9Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.first_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNIJ_entry() //  [R1]
         { info_tbl: [(cbOa4,
                       label: sat_sbNIJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOa4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOa5; else goto cbOa6;
       cbOa5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOa6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = swap_rbNCa_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNIL_entry() //  [R1]
         { info_tbl: [(cbOa7,
                       label: sat_sbNIL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOa7: // global
           _sbNIL::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbOa8; else goto cbOa9;
       cbOa9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbOab; else goto cbOaa;
       cbOab: // global
           HpAlloc = 56;
           goto cbOa8;
       cbOa8: // global
           R1 = _sbNIL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOaa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNIL::P64;
           _sbNID::P64 = P64[_sbNIL::P64 + 16];
           _sbNIE::P64 = P64[_sbNIL::P64 + 24];
           _sbNIG::P64 = P64[_sbNIL::P64 + 32];
           I64[Hp - 48] = sat_sbNIK_info;
           P64[Hp - 32] = _sbNID::P64;
           P64[Hp - 24] = _sbNIE::P64;
           I64[Hp - 16] = sat_sbNIJ_info;
           P64[Hp] = _sbNID::P64;
           R2 = _sbNIG::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNII_entry() //  [R1]
         { info_tbl: [(cbOag,
                       label: sat_sbNII_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOag: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOah; else goto cbOai;
       cbOah: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOai: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.first_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNIM_entry() //  [R1]
         { info_tbl: [(cbOaj,
                       label: sat_sbNIM_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOaj: // global
           _sbNIM::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbOak; else goto cbOal;
       cbOal: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbOan; else goto cbOam;
       cbOan: // global
           HpAlloc = 72;
           goto cbOak;
       cbOak: // global
           R1 = _sbNIM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOam: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNIM::P64;
           _sbNID::P64 = P64[_sbNIM::P64 + 16];
           _sbNIE::P64 = P64[_sbNIM::P64 + 24];
           _sbNIF::P64 = P64[_sbNIM::P64 + 32];
           _sbNIG::P64 = P64[_sbNIM::P64 + 40];
           I64[Hp - 64] = sat_sbNIL_info;
           P64[Hp - 48] = _sbNID::P64;
           P64[Hp - 40] = _sbNIE::P64;
           P64[Hp - 32] = _sbNIG::P64;
           I64[Hp - 24] = sat_sbNII_info;
           P64[Hp - 8] = _sbNID::P64;
           P64[Hp] = _sbNIF::P64;
           R2 = _sbNIG::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 64;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNIH_entry() //  [R1]
         { info_tbl: [(cbOas,
                       label: sat_sbNIH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOas: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOat; else goto cbOau;
       cbOat: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOau: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = swap_rbNCa_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dm***_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOav,
                       label: Control.Arrow.$dm***_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOav: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOaw; else goto cbOax;
       cbOaw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$dm***_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOax: // global
           I64[Sp - 32] = block_cbO9H_info;
           _sbNID::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbNID::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbO9H() //  [R1]
         { info_tbl: [(cbO9H,
                       label: block_cbO9H_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO9H: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbOaA; else goto cbOaz;
       cbOaA: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOaz: // global
           I64[Hp - 64] = sat_sbNIM_info;
           _sbNID::P64 = P64[Sp + 8];
           P64[Hp - 48] = _sbNID::P64;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbNIH_info;
           P64[Hp] = _sbNID::P64;
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 24] = Hp - 64;
           Sp = Sp + 8;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.125574341 UTC

[section ""data" . Control.Arrow.$fArrowKleisli2_closure" {
     Control.Arrow.$fArrowKleisli2_closure:
         const Control.Arrow.$fArrowKleisli2_info;
 },
 sat_sbNJg_entry() //  [R1, R2]
         { info_tbl: [(cbOaN,
                       label: sat_sbNJg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOaN: // global
           _sbNJ6::P64 = R2;
           _sbNJg::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOaO; else goto cbOaP;
       cbOaP: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbOaR; else goto cbOaQ;
       cbOaR: // global
           HpAlloc = 72;
           goto cbOaO;
       cbOaO: // global
           R2 = _sbNJ6::P64;
           R1 = _sbNJg::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOaQ: // global
           _sbNIN::P64 = P64[_sbNJg::P64 + 7];
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sbNJ6::P64;
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sbNJ6::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = _sbNIN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbNJ4_entry() //  [R1, R2]
         { info_tbl: [(cbOb1,
                       label: sat_sbNJ4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOb1: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Arrow.$fArrowKleisli3_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJ2_entry() //  [R1, R2]
         { info_tbl: [(cbObg,
                       label: sat_sbNJ2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbObg: // global
           _sbNIS::P64 = R2;
           _sbNJ2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbObh; else goto cbObi;
       cbObi: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbObk; else goto cbObj;
       cbObk: // global
           HpAlloc = 72;
           goto cbObh;
       cbObh: // global
           R2 = _sbNIS::P64;
           R1 = _sbNJ2::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbObj: // global
           _sbNIN::P64 = P64[_sbNJ2::P64 + 7];
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sbNIS::P64;
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sbNIS::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = _sbNIN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbNIR_entry() //  [R1]
         { info_tbl: [(cbObp,
                       label: sat_sbNIR_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbObp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbObq; else goto cbObr;
       cbObq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbObr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowKleisli3_entry(R4,
                                                    R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNJ3_entry() //  [R1]
         { info_tbl: [(cbObs,
                       label: sat_sbNJ3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbObs: // global
           _sbNJ3::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbObt; else goto cbObu;
       cbObu: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbObw; else goto cbObv;
       cbObw: // global
           HpAlloc = 56;
           goto cbObt;
       cbObt: // global
           R1 = _sbNJ3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbObv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNJ3::P64;
           _sbNIN::P64 = P64[_sbNJ3::P64 + 16];
           _sbNIO::P64 = P64[_sbNJ3::P64 + 24];
           _sbNIQ::P64 = P64[_sbNJ3::P64 + 32];
           I64[Hp - 48] = sat_sbNJ2_info;
           P64[Hp - 40] = _sbNIN::P64;
           I64[Hp - 32] = sat_sbNIR_info;
           P64[Hp - 16] = _sbNIN::P64;
           P64[Hp - 8] = _sbNIO::P64;
           P64[Hp] = _sbNIQ::P64;
           R2 = _sbNIN::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 47;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNJ5_entry() //  [R1]
         { info_tbl: [(cbObx,
                       label: sat_sbNJ5_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbObx: // global
           _sbNJ5::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbOby; else goto cbObz;
       cbObz: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbObB; else goto cbObA;
       cbObB: // global
           HpAlloc = 64;
           goto cbOby;
       cbOby: // global
           R1 = _sbNJ5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbObA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNJ5::P64;
           _sbNIN::P64 = P64[_sbNJ5::P64 + 16];
           _sbNIO::P64 = P64[_sbNJ5::P64 + 24];
           _sbNIP::P64 = P64[_sbNJ5::P64 + 32];
           _sbNIQ::P64 = P64[_sbNJ5::P64 + 40];
           I64[Hp - 56] = sat_sbNJ4_info;
           P64[Hp - 48] = _sbNIN::P64;
           P64[Hp - 40] = _sbNIP::P64;
           I64[Hp - 32] = sat_sbNJ3_info;
           P64[Hp - 16] = _sbNIN::P64;
           P64[Hp - 8] = _sbNIO::P64;
           P64[Hp] = _sbNIQ::P64;
           R2 = _sbNIN::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbObC,
                       label: Control.Arrow.$fArrowKleisli2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbObC: // global
           _sbNIQ::P64 = R5;
           _sbNIP::P64 = R4;
           _sbNIO::P64 = R3;
           _sbNIN::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbObD; else goto cbObE;
       cbObE: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbObG; else goto cbObF;
       cbObG: // global
           HpAlloc = 64;
           goto cbObD;
       cbObD: // global
           R5 = _sbNIQ::P64;
           R4 = _sbNIP::P64;
           R3 = _sbNIO::P64;
           R2 = _sbNIN::P64;
           R1 = Control.Arrow.$fArrowKleisli2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbObF: // global
           I64[Hp - 56] = sat_sbNJg_info;
           P64[Hp - 48] = _sbNIN::P64;
           I64[Hp - 40] = sat_sbNJ5_info;
           P64[Hp - 24] = _sbNIN::P64;
           P64[Hp - 16] = _sbNIO::P64;
           P64[Hp - 8] = _sbNIP::P64;
           P64[Hp] = _sbNIQ::P64;
           R2 = _sbNIN::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 40;
           P64[Sp - 8] = Hp - 55;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.128984453 UTC

[section ""data" . Control.Arrow.$fArrowKleisli1_closure" {
     Control.Arrow.$fArrowKleisli1_closure:
         const Control.Arrow.$fArrowKleisli1_info;
 },
 sat_sbNJn_entry() //  [R1, R2]
         { info_tbl: [(cbObQ,
                       label: sat_sbNJn_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbObQ: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Arrow.$fArrowKleisli2_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJm_entry() //  [R1]
         { info_tbl: [(cbObY,
                       label: sat_sbNJm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbObY: // global
           _sbNJm::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbObZ; else goto cbOc0;
       cbOc0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOc2; else goto cbOc1;
       cbOc2: // global
           HpAlloc = 24;
           goto cbObZ;
       cbObZ: // global
           R1 = _sbNJm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOc1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNJm::P64;
           _sbNJh::P64 = P64[_sbNJm::P64 + 16];
           _sbNJk::P64 = P64[_sbNJm::P64 + 24];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbNJk::P64;
           P64[Hp] = _sbNJk::P64;
           R2 = _sbNJh::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbOc3,
                       label: Control.Arrow.$fArrowKleisli1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOc3: // global
           _sbNJk::P64 = R5;
           _sbNJj::P64 = R4;
           _sbNJi::P64 = R3;
           _sbNJh::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOc4; else goto cbOc5;
       cbOc5: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbOc7; else goto cbOc6;
       cbOc7: // global
           HpAlloc = 64;
           goto cbOc4;
       cbOc4: // global
           R5 = _sbNJk::P64;
           R4 = _sbNJj::P64;
           R3 = _sbNJi::P64;
           R2 = _sbNJh::P64;
           R1 = Control.Arrow.$fArrowKleisli1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOc6: // global
           I64[Hp - 56] = sat_sbNJn_info;
           P64[Hp - 48] = _sbNJh::P64;
           P64[Hp - 40] = _sbNJi::P64;
           P64[Hp - 32] = _sbNJj::P64;
           I64[Hp - 24] = sat_sbNJm_info;
           P64[Hp - 8] = _sbNJh::P64;
           P64[Hp] = _sbNJk::P64;
           R2 = _sbNJh::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 55;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.13141122 UTC

[section ""data" . Control.Arrow.$fArrowKleisli_closure" {
     Control.Arrow.$fArrowKleisli_closure:
         const Control.Arrow.$fArrowKleisli_info;
 },
 sat_sbNJu_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbOch,
                       label: sat_sbNJu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOch: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fArrowKleisli1_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJt_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbOcp,
                       label: sat_sbNJt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOcp: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fArrowKleisli2_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJs_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOcx,
                       label: sat_sbNJs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOcx: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowKleisli4_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJr_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOcF,
                       label: sat_sbNJr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOcF: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowKleisli3_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJq_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOcN,
                       label: sat_sbNJq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOcN: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowKleisli5_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJp_entry() //  [R1]
         { info_tbl: [(cbOcU,
                       label: sat_sbNJp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOcU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOcV; else goto cbOcW;
       cbOcV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOcW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fCategoryTYPEKleisli_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli_entry() //  [R2]
         { info_tbl: [(cbOcY,
                       label: Control.Arrow.$fArrowKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOcY: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cbOd2; else goto cbOd1;
       cbOd2: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = Control.Arrow.$fArrowKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOd1: // global
           I64[Hp - 152] = sat_sbNJu_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbNJt_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbNJs_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbNJr_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbNJq_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbNJp_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = Control.Arrow.C:Arrow_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 86;
           P64[Hp - 24] = Hp - 102;
           P64[Hp - 16] = Hp - 118;
           P64[Hp - 8] = Hp - 133;
           P64[Hp] = Hp - 149;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.133740691 UTC

[section ""data" . Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_closure" {
     Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_closure:
         const Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_info;
 },
 sat_sbNJw_entry() //  [R1]
         { info_tbl: [(cbOdb,
                       label: sat_sbNJw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOdb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOdc; else goto cbOdd;
       cbOdc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOdd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_entry() //  [R2]
         { info_tbl: [(cbOde,
                       label: Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOde: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOdi; else goto cbOdh;
       cbOdi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOdh: // global
           I64[Hp - 16] = sat_sbNJw_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Arrow.$fArrowKleisli_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.135140594 UTC

[section ""data" . Control.Arrow.$fArrowLoopKleisli_closure" {
     Control.Arrow.$fArrowLoopKleisli_closure:
         const Control.Arrow.$fArrowLoopKleisli_info;
 },
 sat_sbNJz_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOds,
                       label: sat_sbNJz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOds: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowLoopKleisli1_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJy_entry() //  [R1]
         { info_tbl: [(cbOdz,
                       label: sat_sbNJy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOdz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOdA; else goto cbOdB;
       cbOdA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOdB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowLoopKleisli_entry() //  [R2]
         { info_tbl: [(cbOdD,
                       label: Control.Arrow.$fArrowLoopKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOdD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbOdH; else goto cbOdG;
       cbOdH: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Arrow.$fArrowLoopKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOdG: // global
           I64[Hp - 56] = sat_sbNJz_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbNJy_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Arrow.C:ArrowLoop_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 54;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.13659264 UTC

[section ""data" . lvl3_rbNCb_closure" {
     lvl3_rbNCb_closure:
         const lvl3_rbNCb_info;
 },
 lvl3_rbNCb_entry() //  [R2]
         { info_tbl: [(cbOdP,
                       label: lvl3_rbNCb_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOdP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOdQ; else goto cbOdR;
       cbOdQ: // global
           R2 = R2;
           R1 = lvl3_rbNCb_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOdR: // global
           I64[Sp - 8] = block_cbOdM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOdV; else goto cbOdN;
       ubOdV: // global
           call _cbOdM(R1) args: 0, res: 0, upd: 0;
       cbOdN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOdM() //  [R1]
         { info_tbl: [(cbOdM,
                       label: block_cbOdM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOdM: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.137813413 UTC

[section ""data" . Control.Arrow.$fArrowApplyKleisli_closure" {
     Control.Arrow.$fArrowApplyKleisli_closure:
         const Control.Arrow.$fArrowApplyKleisli_info;
 },
 sat_sbNJF_entry() //  [R1]
         { info_tbl: [(cbOe4,
                       label: sat_sbNJF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOe4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOe5; else goto cbOe6;
       cbOe5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOe6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowKleisli_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowApplyKleisli_entry() //  [R2]
         { info_tbl: [(cbOe8,
                       label: Control.Arrow.$fArrowApplyKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOe8: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbOec; else goto cbOeb;
       cbOec: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Control.Arrow.$fArrowApplyKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOeb: // global
           I64[Hp - 40] = sat_sbNJF_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Arrow.C:ArrowApply_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = lvl3_rbNCb_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.139728097 UTC

[section ""data" . Control.Arrow.$fArrowChoiceKleisli1_closure" {
     Control.Arrow.$fArrowChoiceKleisli1_closure:
         const Control.Arrow.$fArrowChoiceKleisli1_info;
 },
 sat_sbNJP_entry() //  [R1, R2]
         { info_tbl: [(cbOes,
                       label: sat_sbNJP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOes: // global
           _sbNJN::P64 = R2;
           _sbNJP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOet; else goto cbOeu;
       cbOeu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbOew; else goto cbOev;
       cbOew: // global
           HpAlloc = 16;
           goto cbOet;
       cbOet: // global
           R2 = _sbNJN::P64;
           R1 = _sbNJP::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOev: // global
           _sbNJG::P64 = P64[_sbNJP::P64 + 7];
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = _sbNJN::P64;
           R2 = _sbNJG::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbNJU_entry() //  [R1, R2]
         { info_tbl: [(cbOeF,
                       label: sat_sbNJU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOeF: // global
           _sbNJS::P64 = R2;
           _sbNJU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOeG; else goto cbOeH;
       cbOeH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbOeJ; else goto cbOeI;
       cbOeJ: // global
           HpAlloc = 16;
           goto cbOeG;
       cbOeG: // global
           R2 = _sbNJS::P64;
           R1 = _sbNJU::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOeI: // global
           _sbNJG::P64 = P64[_sbNJU::P64 + 7];
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = _sbNJS::P64;
           R2 = _sbNJG::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 6;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fArrowChoiceKleisli1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbOeO,
                       label: Control.Arrow.$fArrowChoiceKleisli1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOeO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOeP; else goto cbOeQ;
       cbOeP: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fArrowChoiceKleisli1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOeQ: // global
           I64[Sp - 32] = block_cbOeh_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubOeZ; else goto cbOei;
       ubOeZ: // global
           call _cbOeh(R1) args: 0, res: 0, upd: 0;
       cbOei: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOeh() //  [R1]
         { info_tbl: [(cbOeh,
                       label: block_cbOeh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOeh: // global
           _sbNJG::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbOeL; else goto cbOeM;
       cbOeL: // global
           Hp = Hp + 48;
           _sbNJK::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbOeW; else goto cbOeS;
       cbOeS: // global
           _sbNJL::P64 = P64[_sbNJK::P64 + 7];
           I64[Hp - 40] = sat_sbNJP_info;
           P64[Hp - 32] = _sbNJG::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbNJL::P64;
           R2 = _sbNJG::P64;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 24;
           P64[Sp + 24] = Hp - 39;
           Sp = Sp + 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
       cbOeM: // global
           Hp = Hp + 48;
           _sbNJK::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbOeW; else goto cbOeV;
       cbOeW: // global
           HpAlloc = 48;
           R1 = _sbNJK::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOeV: // global
           _sbNJQ::P64 = P64[_sbNJK::P64 + 6];
           I64[Hp - 40] = sat_sbNJU_info;
           P64[Hp - 32] = _sbNJG::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sbNJQ::P64;
           R2 = _sbNJG::P64;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 24;
           P64[Sp + 24] = Hp - 39;
           Sp = Sp + 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.142291431 UTC

[section ""data" . Control.Arrow.$fArrowChoiceKleisli3_closure" {
     Control.Arrow.$fArrowChoiceKleisli3_closure:
         const Control.Arrow.$fArrowChoiceKleisli3_info;
 },
 sat_sbNJZ_entry() //  [R1, R2]
         { info_tbl: [(cbOf9,
                       label: sat_sbNJZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOf9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOfa; else goto cbOfb;
       cbOfa: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOfb: // global
           _sbNJY::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _sbNJY::P64;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fArrowChoiceKleisli3_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOfc,
                       label: Control.Arrow.$fArrowChoiceKleisli3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOfc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbOfg; else goto cbOff;
       cbOfg: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fArrowChoiceKleisli3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOff: // global
           I64[Hp - 8] = sat_sbNJZ_info;
           P64[Hp] = R2;
           R5 = R4;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Control.Arrow.$fArrowChoiceKleisli1_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.14369995 UTC

[section ""data" . Control.Arrow.$fArrowChoiceKleisli2_closure" {
     Control.Arrow.$fArrowChoiceKleisli2_closure:
         const Control.Arrow.$fArrowChoiceKleisli2_info;
 },
 sat_sbNK4_entry() //  [R1, R2]
         { info_tbl: [(cbOfq,
                       label: sat_sbNK4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOfq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOfr; else goto cbOfs;
       cbOfr: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOfs: // global
           _sbNK3::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _sbNK3::P64;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fArrowChoiceKleisli2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOft,
                       label: Control.Arrow.$fArrowChoiceKleisli2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOft: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbOfx; else goto cbOfw;
       cbOfx: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fArrowChoiceKleisli2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOfw: // global
           I64[Hp - 8] = sat_sbNK4_info;
           P64[Hp] = R2;
           R5 = R4;
           R4 = R3;
           R3 = Hp - 7;
           R2 = R2;
           call Control.Arrow.$fArrowChoiceKleisli1_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.14490026 UTC

[section ""data" . lvl4_rbNCc_closure" {
     lvl4_rbNCc_closure:
         const lvl4_rbNCc_info;
 },
 lvl4_rbNCc_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOfC,
                       label: lvl4_rbNCc_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOfC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Either.either_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.146220649 UTC

[section ""data" . Control.Arrow.$fArrowChoiceKleisli_closure" {
     Control.Arrow.$fArrowChoiceKleisli_closure:
         const Control.Arrow.$fArrowChoiceKleisli_info;
 },
 sat_sbNKc_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbOfO,
                       label: sat_sbNKc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOfO: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fArrowChoiceKleisli1_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNKb_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOfW,
                       label: sat_sbNKb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOfW: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowChoiceKleisli2_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNKa_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOg4,
                       label: sat_sbNKa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOg4: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowChoiceKleisli3_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNK9_entry() //  [R1]
         { info_tbl: [(cbOgb,
                       label: sat_sbNK9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOgb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOgc; else goto cbOgd;
       cbOgc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOgd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowKleisli_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowChoiceKleisli_entry() //  [R2]
         { info_tbl: [(cbOgf,
                       label: Control.Arrow.$fArrowChoiceKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOgf: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cbOgj; else goto cbOgi;
       cbOgj: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Control.Arrow.$fArrowChoiceKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOgi: // global
           I64[Hp - 112] = sat_sbNKc_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbNKb_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbNKa_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbNK9_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = Control.Arrow.C:ArrowChoice_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 94;
           P64[Hp - 8] = Hp - 109;
           P64[Hp] = lvl4_rbNCc_closure+3;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.148139948 UTC

[section ""data" . Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_closure" {
     Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_closure:
         const Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_info;
 },
 sat_sbNKe_entry() //  [R1]
         { info_tbl: [(cbOgs,
                       label: sat_sbNKe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOgs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOgt; else goto cbOgu;
       cbOgt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOgu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_entry() //  [R2]
         { info_tbl: [(cbOgv,
                       label: Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOgv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOgz; else goto cbOgy;
       cbOgz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOgy: // global
           I64[Hp - 16] = sat_sbNKe_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Arrow.$fArrowKleisli_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.14964707 UTC

[section ""data" . Control.Arrow.$fArrowZeroKleisli_closure" {
     Control.Arrow.$fArrowZeroKleisli_closure:
         const Control.Arrow.$fArrowZeroKleisli_info;
 },
 lvl5_sbNKg_entry() //  [R1]
         { info_tbl: [(cbOgI,
                       label: lvl5_sbNKg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOgI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOgJ; else goto cbOgK;
       cbOgJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOgK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNKj_entry() //  [R1]
         { info_tbl: [(cbOgQ,
                       label: sat_sbNKj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOgQ: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNKh_entry() //  [R1]
         { info_tbl: [(cbOgX,
                       label: sat_sbNKh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOgX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOgY; else goto cbOgZ;
       cbOgY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOgZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowZeroKleisli_entry() //  [R2]
         { info_tbl: [(cbOh1,
                       label: Control.Arrow.$fArrowZeroKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOh1: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbOh5; else goto cbOh4;
       cbOh5: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = Control.Arrow.$fArrowZeroKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOh4: // global
           I64[Hp - 80] = lvl5_sbNKg_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbNKj_info;
           P64[Hp - 48] = Hp - 80;
           I64[Hp - 40] = sat_sbNKh_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Arrow.C:ArrowZero_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.151473598 UTC

[section ""data" . Control.Arrow.$fArrowPlusKleisli_closure" {
     Control.Arrow.$fArrowPlusKleisli_closure:
         const Control.Arrow.$fArrowPlusKleisli_info;
 },
 sat_sbNKm_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbOhf,
                       label: sat_sbNKm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOhf: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fArrowPlusKleisli1_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNKl_entry() //  [R1]
         { info_tbl: [(cbOhm,
                       label: sat_sbNKl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOhm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOhn; else goto cbOho;
       cbOhn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOho: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowZeroKleisli_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowPlusKleisli_entry() //  [R2]
         { info_tbl: [(cbOhq,
                       label: Control.Arrow.$fArrowPlusKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOhq: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbOhu; else goto cbOht;
       cbOhu: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Arrow.$fArrowPlusKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOht: // global
           I64[Hp - 56] = sat_sbNKm_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbNKl_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Arrow.C:ArrowPlus_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 53;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.153067603 UTC

[section ""data" . Control.Arrow.$dmsecond_closure" {
     Control.Arrow.$dmsecond_closure:
         const Control.Arrow.$dmsecond_info;
 },
 sat_sbNKp_entry() //  [R1]
         { info_tbl: [(cbOhF,
                       label: sat_sbNKp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOhF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbOhG; else goto cbOhH;
       cbOhG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOhH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbOhD_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbOhD() //  [R1]
         { info_tbl: [(cbOhD,
                       label: block_cbOhD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOhD: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Category.id_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dmsecond_entry() //  [R2]
         { info_tbl: [(cbOhL,
                       label: Control.Arrow.$dmsecond_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOhL: // global
           _sbNKn::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOhM; else goto cbOhN;
       cbOhN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOhP; else goto cbOhO;
       cbOhP: // global
           HpAlloc = 24;
           goto cbOhM;
       cbOhM: // global
           R2 = _sbNKn::P64;
           R1 = Control.Arrow.$dmsecond_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOhO: // global
           I64[Hp - 16] = sat_sbNKp_info;
           P64[Hp] = _sbNKn::P64;
           R2 = _sbNKn::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Control.Arrow.***_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.154636981 UTC

[section ""data" . Control.Arrow.$dmfirst_closure" {
     Control.Arrow.$dmfirst_closure:
         const Control.Arrow.$dmfirst_info;
 },
 sat_sbNKt_entry() //  [R1]
         { info_tbl: [(cbOi0,
                       label: sat_sbNKt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOi0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbOi1; else goto cbOi2;
       cbOi1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOi2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbOhY_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbOhY() //  [R1]
         { info_tbl: [(cbOhY,
                       label: block_cbOhY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOhY: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Category.id_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dmfirst_entry() //  [R2, R3]
         { info_tbl: [(cbOi6,
                       label: Control.Arrow.$dmfirst_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOi6: // global
           _sbNKr::P64 = R3;
           _sbNKq::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOi7; else goto cbOi8;
       cbOi8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOia; else goto cbOi9;
       cbOia: // global
           HpAlloc = 24;
           goto cbOi7;
       cbOi7: // global
           R3 = _sbNKr::P64;
           R2 = _sbNKq::P64;
           R1 = Control.Arrow.$dmfirst_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOi9: // global
           I64[Hp - 16] = sat_sbNKt_info;
           P64[Hp] = _sbNKq::P64;
           R2 = _sbNKq::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbNKr::P64;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Control.Arrow.***_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.156237706 UTC

[section ""data" . Control.Arrow.$cfirst_closure" {
     Control.Arrow.$cfirst_closure:
         const Control.Arrow.$cfirst_info;
 },
 sat_sbNKA_entry() //  [R1]
         { info_tbl: [(cbOil,
                       label: sat_sbNKA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOil: // global
           _sbNKA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOim; else goto cbOin;
       cbOin: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOip; else goto cbOio;
       cbOip: // global
           HpAlloc = 24;
           goto cbOim;
       cbOim: // global
           R1 = _sbNKA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOio: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNKA::P64;
           _sbNKu::P64 = P64[_sbNKA::P64 + 16];
           _sbNKv::P64 = P64[_sbNKA::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbNKv::P64;
           R2 = Hp - 16;
           R1 = _sbNKu::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$cfirst_entry() //  [R2, R3]
         { info_tbl: [(cbOir,
                       label: Control.Arrow.$cfirst_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOir: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbOiv; else goto cbOiu;
       cbOiv: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$cfirst_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOiu: // global
           I64[Hp - 72] = stg_sel_1_upd_info;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sbNKA_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.158005905 UTC

[section ""data" . Control.Arrow.$csecond_closure" {
     Control.Arrow.$csecond_closure:
         const Control.Arrow.$csecond_info;
 },
 sat_sbNKP_entry() //  [R1]
         { info_tbl: [(cbOiF,
                       label: sat_sbNKP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOiF: // global
           _sbNKP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOiG; else goto cbOiH;
       cbOiH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOiJ; else goto cbOiI;
       cbOiJ: // global
           HpAlloc = 24;
           goto cbOiG;
       cbOiG: // global
           R1 = _sbNKP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOiI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNKP::P64;
           _sbNKF::P64 = P64[_sbNKP::P64 + 16];
           _sbNKG::P64 = P64[_sbNKP::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sbNKG::P64;
           R2 = Hp - 16;
           R1 = _sbNKF::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$csecond_entry() //  [R2, R3]
         { info_tbl: [(cbOiM,
                       label: Control.Arrow.$csecond_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOiM: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbOiQ; else goto cbOiP;
       cbOiQ: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$csecond_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOiP: // global
           I64[Hp - 72] = sat_sbNKP_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.159444551 UTC

[section ""data" . Control.Arrow.$c&&&_closure" {
     Control.Arrow.$c&&&_closure:
         const Control.Arrow.$c&&&_info;
 },
 Control.Arrow.$c&&&_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOiY,
                       label: Control.Arrow.$c&&&_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOiY: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbOj2; else goto cbOj1;
       cbOj2: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$c&&&_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOj1: // global
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.160374871 UTC

[section ""data" . Control.Arrow.$fArrow(->)_closure" {
     Control.Arrow.$fArrow(->)_closure:
         const Control.Arrow.C:Arrow_con_info;
         const Control.Category.$fCategoryTYPE(->)_closure;
         const Control.Arrow.$fArrow(->)_$carr_closure+1;
         const Control.Arrow.$cfirst_closure+2;
         const Control.Arrow.$csecond_closure+2;
         const Control.Arrow.$c***_closure+3;
         const Control.Arrow.$c&&&_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.160954427 UTC

[section ""data" . Control.Arrow.$fArrowLoop(->)_closure" {
     Control.Arrow.$fArrowLoop(->)_closure:
         const Control.Arrow.C:ArrowLoop_con_info;
         const Control.Arrow.$fArrow(->)_closure+1;
         const Control.Arrow.$fArrowLoop(->)_$cloop_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.161592769 UTC

[section ""data" . Control.Arrow.$fArrowApply(->)_closure" {
     Control.Arrow.$fArrowApply(->)_closure:
         const Control.Arrow.C:ArrowApply_con_info;
         const Control.Arrow.$fArrow(->)_closure+1;
         const Control.Arrow.$fAlternativeArrowMonad_$capp_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.162690721 UTC

[section ""data" . Control.Arrow.$c+++_closure" {
     Control.Arrow.$c+++_closure:
         const Control.Arrow.$c+++_info;
 },
 Control.Arrow.$c+++_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOje,
                       label: Control.Arrow.$c+++_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOje: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbOjf; else goto cbOjg;
       cbOjf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$c+++_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOjg: // global
           I64[Sp - 24] = block_cbOj7_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubOjv; else goto cbOj8;
       ubOjv: // global
           call _cbOj7(R1) args: 0, res: 0, upd: 0;
       cbOj8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOj7() //  [R1]
         { info_tbl: [(cbOj7,
                       label: block_cbOj7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOj7: // global
           if (R1 & 7 == 1) goto cbOjb; else goto cbOjc;
       cbOjb: // global
           Hp = Hp + 48;
           _sbNKY::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbOju; else goto cbOjm;
       cbOjm: // global
           _sbNKZ::P64 = P64[_sbNKY::P64 + 7];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sbNKZ::P64;
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbOjc: // global
           Hp = Hp + 48;
           _sbNKY::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbOju; else goto cbOjt;
       cbOju: // global
           HpAlloc = 48;
           R1 = _sbNKY::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOjt: // global
           _sbNL1::P64 = P64[_sbNKY::P64 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sbNL1::P64;
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.164474584 UTC

[section ""data" . Control.Arrow.$cright_closure" {
     Control.Arrow.$cright_closure:
         const Control.Arrow.$cright_info;
 },
 Control.Arrow.$cright_entry() //  [R2, R3]
         { info_tbl: [(cbOjH,
                       label: Control.Arrow.$cright_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOjH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOjI; else goto cbOjJ;
       cbOjI: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$cright_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOjJ: // global
           I64[Sp - 16] = block_cbOjA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubOjU; else goto cbOjB;
       ubOjU: // global
           call _cbOjA(R1) args: 0, res: 0, upd: 0;
       cbOjB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOjA() //  [R1]
         { info_tbl: [(cbOjA,
                       label: block_cbOjA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOjA: // global
           if (R1 & 7 == 1) goto cbOjE; else goto cbOjF;
       cbOjE: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbOjF: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbOjT; else goto cbOjS;
       cbOjT: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOjS: // global
           _sbNL7::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sbNL7::P64;
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.166028857 UTC

[section ""data" . Control.Arrow.$cleft_closure" {
     Control.Arrow.$cleft_closure:
         const Control.Arrow.$cleft_info;
 },
 Control.Arrow.$cleft_entry() //  [R2, R3]
         { info_tbl: [(cbOk6,
                       label: Control.Arrow.$cleft_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOk6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOk7; else goto cbOk8;
       cbOk7: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$cleft_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOk8: // global
           I64[Sp - 16] = block_cbOjZ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubOkj; else goto cbOk0;
       ubOkj: // global
           call _cbOjZ(R1) args: 0, res: 0, upd: 0;
       cbOk0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOjZ() //  [R1]
         { info_tbl: [(cbOjZ,
                       label: block_cbOjZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOjZ: // global
           if (R1 & 7 == 1) goto cbOk3; else goto cbOk4;
       cbOk3: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbOkf; else goto cbOke;
       cbOkf: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOke: // global
           _sbNLc::P64 = P64[R1 + 7];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sbNLc::P64;
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbOk4: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.167290376 UTC

[section ""data" . Control.Arrow.$fArrowChoice(->)_closure" {
     Control.Arrow.$fArrowChoice(->)_closure:
         const Control.Arrow.C:ArrowChoice_con_info;
         const Control.Arrow.$fArrow(->)_closure+1;
         const Control.Arrow.$cleft_closure+2;
         const Control.Arrow.$cright_closure+2;
         const Control.Arrow.$c+++_closure+3;
         const Data.Either.either_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.170670684 UTC

[section ""data" . Control.Arrow.runKleisli1_closure" {
     Control.Arrow.runKleisli1_closure:
         const Control.Arrow.runKleisli1_info;
 },
 Control.Arrow.runKleisli1_entry() //  [R2]
         { info_tbl: [(cbOko,
                       label: Control.Arrow.runKleisli1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOko: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.171494323 UTC

[section ""data" . Control.Arrow.runKleisli_closure" {
     Control.Arrow.runKleisli_closure:
         const Control.Arrow.runKleisli_info;
 },
 Control.Arrow.runKleisli_entry() //  [R2]
         { info_tbl: [(cbOkv,
                       label: Control.Arrow.runKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOkv: // global
           R2 = R2;
           call Control.Arrow.runKleisli1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.172325665 UTC

[section ""data" . Control.Arrow.returnA_closure" {
     Control.Arrow.returnA_closure:
         const Control.Arrow.returnA_info;
 },
 Control.Arrow.returnA_entry() //  [R2]
         { info_tbl: [(cbOkC,
                       label: Control.Arrow.returnA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOkC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOkD; else goto cbOkE;
       cbOkD: // global
           R2 = R2;
           R1 = Control.Arrow.returnA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOkE: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.id_closure+1;
           Sp = Sp - 16;
           call Control.Arrow.arr_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.173542755 UTC

[section ""data" . Control.Arrow.^>>_closure" {
     Control.Arrow.^>>_closure:
         const Control.Arrow.^>>_info;
 },
 sat_sbNLl_entry() //  [R1]
         { info_tbl: [(cbOkN,
                       label: sat_sbNLl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOkN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOkO; else goto cbOkP;
       cbOkO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOkP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.^>>_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOkS,
                       label: Control.Arrow.^>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOkS: // global
           _sbNLj::P64 = R4;
           _sbNLi::P64 = R3;
           _sbNLh::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOkT; else goto cbOkU;
       cbOkU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOkW; else goto cbOkV;
       cbOkW: // global
           HpAlloc = 32;
           goto cbOkT;
       cbOkT: // global
           R4 = _sbNLj::P64;
           R3 = _sbNLi::P64;
           R2 = _sbNLh::P64;
           R1 = Control.Arrow.^>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOkV: // global
           I64[Hp - 24] = sat_sbNLl_info;
           P64[Hp - 8] = _sbNLh::P64;
           P64[Hp] = _sbNLi::P64;
           I64[Sp - 24] = block_cbOkQ_info;
           R2 = _sbNLh::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNLj::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOkQ() //  [R1]
         { info_tbl: [(cbOkQ,
                       label: block_cbOkQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOkQ: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbOkJ::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbOkJ::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.175228231 UTC

[section ""data" . Control.Arrow.>>^_closure" {
     Control.Arrow.>>^_closure:
         const Control.Arrow.>>^_info;
 },
 sat_sbNLq_entry() //  [R1]
         { info_tbl: [(cbOl8,
                       label: sat_sbNLq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOl8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOl9; else goto cbOla;
       cbOl9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOla: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.>>^_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOld,
                       label: Control.Arrow.>>^_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOld: // global
           _sbNLo::P64 = R4;
           _sbNLn::P64 = R3;
           _sbNLm::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOle; else goto cbOlf;
       cbOlf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOlh; else goto cbOlg;
       cbOlh: // global
           HpAlloc = 32;
           goto cbOle;
       cbOle: // global
           R4 = _sbNLo::P64;
           R3 = _sbNLn::P64;
           R2 = _sbNLm::P64;
           R1 = Control.Arrow.>>^_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOlg: // global
           I64[Hp - 24] = sat_sbNLq_info;
           P64[Hp - 8] = _sbNLm::P64;
           P64[Hp] = _sbNLo::P64;
           I64[Sp - 24] = block_cbOlb_info;
           R2 = _sbNLm::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNLn::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOlb() //  [R1]
         { info_tbl: [(cbOlb,
                       label: block_cbOlb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOlb: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.176887778 UTC

[section ""data" . Control.Arrow.<<^_closure" {
     Control.Arrow.<<^_closure:
         const Control.Arrow.<<^_info;
 },
 sat_sbNLv_entry() //  [R1]
         { info_tbl: [(cbOlt,
                       label: sat_sbNLv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOlt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOlu; else goto cbOlv;
       cbOlu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOlv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.<<^_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOly,
                       label: Control.Arrow.<<^_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOly: // global
           _sbNLt::P64 = R4;
           _sbNLs::P64 = R3;
           _sbNLr::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOlz; else goto cbOlA;
       cbOlA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOlC; else goto cbOlB;
       cbOlC: // global
           HpAlloc = 32;
           goto cbOlz;
       cbOlz: // global
           R4 = _sbNLt::P64;
           R3 = _sbNLs::P64;
           R2 = _sbNLr::P64;
           R1 = Control.Arrow.<<^_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOlB: // global
           I64[Hp - 24] = sat_sbNLv_info;
           P64[Hp - 8] = _sbNLr::P64;
           P64[Hp] = _sbNLt::P64;
           I64[Sp - 24] = block_cbOlw_info;
           R2 = _sbNLr::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNLs::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOlw() //  [R1]
         { info_tbl: [(cbOlw,
                       label: block_cbOlw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOlw: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbOlp::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbOlp::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.178595767 UTC

[section ""data" . Control.Arrow.^<<_closure" {
     Control.Arrow.^<<_closure:
         const Control.Arrow.^<<_info;
 },
 sat_sbNLA_entry() //  [R1]
         { info_tbl: [(cbOlO,
                       label: sat_sbNLA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOlO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOlP; else goto cbOlQ;
       cbOlP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOlQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.^<<_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOlT,
                       label: Control.Arrow.^<<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOlT: // global
           _sbNLy::P64 = R4;
           _sbNLx::P64 = R3;
           _sbNLw::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOlU; else goto cbOlV;
       cbOlV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOlX; else goto cbOlW;
       cbOlX: // global
           HpAlloc = 32;
           goto cbOlU;
       cbOlU: // global
           R4 = _sbNLy::P64;
           R3 = _sbNLx::P64;
           R2 = _sbNLw::P64;
           R1 = Control.Arrow.^<<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOlW: // global
           I64[Hp - 24] = sat_sbNLA_info;
           P64[Hp - 8] = _sbNLw::P64;
           P64[Hp] = _sbNLx::P64;
           I64[Sp - 24] = block_cbOlR_info;
           R2 = _sbNLw::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNLy::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOlR() //  [R1]
         { info_tbl: [(cbOlR,
                       label: block_cbOlR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOlR: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.182444122 UTC

[section ""data" . Control.Arrow.leftApp_closure" {
     Control.Arrow.leftApp_closure:
         const Control.Arrow.leftApp_info;
 },
 lvl5_sbNLG_entry() //  [R1]
         { info_tbl: [(cbOml,
                       label: lvl5_sbNLG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOml: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOmm; else goto cbOmn;
       cbOmm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOmn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Either.Left_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNLM_entry() //  [R1, R2]
         { info_tbl: [(cbOmS,
                       label: sat_sbNLM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOmS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOmT; else goto cbOmU;
       cbOmT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOmU: // global
           I64[Sp - 16] = block_cbOmP_info;
           _sbNLJ::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sbNLJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubOmY; else goto cbOmQ;
       ubOmY: // global
           call _cbOmP() args: 0, res: 0, upd: 0;
       cbOmQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOmP() //  []
         { info_tbl: [(cbOmP,
                       label: block_cbOmP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOmP: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNLN_entry() //  [R1]
         { info_tbl: [(cbOmZ,
                       label: sat_sbNLN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOmZ: // global
           _sbNLN::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbOn0; else goto cbOn1;
       cbOn1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbOn3; else goto cbOn2;
       cbOn3: // global
           HpAlloc = 16;
           goto cbOn0;
       cbOn0: // global
           R1 = _sbNLN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOn2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNLN::P64;
           _sbNLD::P64 = P64[_sbNLN::P64 + 16];
           _sbNLJ::P64 = P64[_sbNLN::P64 + 24];
           I64[Hp - 8] = sat_sbNLM_info;
           P64[Hp] = _sbNLJ::P64;
           R2 = _sbNLD::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNLO_entry() //  [R1]
         { info_tbl: [(cbOn4,
                       label: sat_sbNLO_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOn4: // global
           _sbNLO::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbOn5; else goto cbOn6;
       cbOn6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOn8; else goto cbOn7;
       cbOn8: // global
           HpAlloc = 32;
           goto cbOn5;
       cbOn5: // global
           R1 = _sbNLO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOn7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNLO::P64;
           _sbNLC::P64 = P64[_sbNLO::P64 + 16];
           _sbNLD::P64 = P64[_sbNLO::P64 + 24];
           _sbNLE::P64 = P64[_sbNLO::P64 + 32];
           _sbNLJ::P64 = P64[_sbNLO::P64 + 40];
           I64[Hp - 24] = sat_sbNLN_info;
           P64[Hp - 8] = _sbNLD::P64;
           P64[Hp] = _sbNLJ::P64;
           R2 = _sbNLE::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbNLC::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNLP_entry() //  [R1]
         { info_tbl: [(cbOn9,
                       label: sat_sbNLP_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOn9: // global
           _sbNLP::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbOna; else goto cbOnb;
       cbOnb: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbOnd; else goto cbOnc;
       cbOnd: // global
           HpAlloc = 48;
           goto cbOna;
       cbOna: // global
           R1 = _sbNLP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOnc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNLP::P64;
           _sbNLC::P64 = P64[_sbNLP::P64 + 16];
           _sbNLD::P64 = P64[_sbNLP::P64 + 24];
           _sbNLE::P64 = P64[_sbNLP::P64 + 32];
           _sbNLG::P64 = P64[_sbNLP::P64 + 40];
           _sbNLJ::P64 = P64[_sbNLP::P64 + 48];
           I64[Hp - 40] = sat_sbNLO_info;
           P64[Hp - 24] = _sbNLC::P64;
           P64[Hp - 16] = _sbNLD::P64;
           P64[Hp - 8] = _sbNLE::P64;
           P64[Hp] = _sbNLJ::P64;
           R2 = _sbNLE::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbNLG::P64;
           P64[Sp - 24] = Hp - 40;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNLT_entry() //  [R1]
         { info_tbl: [(cbOnw,
                       label: sat_sbNLT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOnw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOnx; else goto cbOny;
       cbOnx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOny: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbOnt_info;
           _sbNLQ::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbNLQ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubOnC; else goto cbOnu;
       ubOnC: // global
           call _cbOnt() args: 0, res: 0, upd: 0;
       cbOnu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbOnt() //  []
         { info_tbl: [(cbOnt,
                       label: block_cbOnt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOnt: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNLU_entry() //  [R1, R2]
         { info_tbl: [(cbOnE,
                       label: sat_sbNLU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOnE: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbOnI; else goto cbOnH;
       cbOnI: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOnH: // global
           _sbNLQ::P64 = P64[R1 + 7];
           I64[Hp - 40] = sat_sbNLT_info;
           P64[Hp - 24] = _sbNLQ::P64;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNLV_entry() //  [R1]
         { info_tbl: [(cbOnJ,
                       label: sat_sbNLV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOnJ: // global
           _sbNLV::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbOnK; else goto cbOnL;
       cbOnL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbOnN; else goto cbOnM;
       cbOnN: // global
           HpAlloc = 16;
           goto cbOnK;
       cbOnK: // global
           R1 = _sbNLV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOnM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNLV::P64;
           _sbNLD::P64 = P64[_sbNLV::P64 + 16];
           _sbNLQ::P64 = P64[_sbNLV::P64 + 24];
           I64[Hp - 8] = sat_sbNLU_info;
           P64[Hp] = _sbNLQ::P64;
           R2 = _sbNLD::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNLW_entry() //  [R1, R2]
         { info_tbl: [(cbOnS,
                       label: sat_sbNLW_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOnS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbOnT; else goto cbOnU;
       cbOnT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOnU: // global
           I64[Sp - 40] = block_cbOmt_info;
           _sbNLC::P64 = P64[R1 + 7];
           _sbNLD::P64 = P64[R1 + 15];
           _sbNLE::P64 = P64[R1 + 23];
           _sbNLG::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sbNLC::P64;
           P64[Sp - 24] = _sbNLD::P64;
           P64[Sp - 16] = _sbNLE::P64;
           P64[Sp - 8] = _sbNLG::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubOo3; else goto cbOmu;
       ubOo3: // global
           call _cbOmt(R1) args: 0, res: 0, upd: 0;
       cbOmu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOmt() //  [R1]
         { info_tbl: [(cbOmt,
                       label: block_cbOmt_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOmt: // global
           _sbNLD::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbOnP; else goto cbOnQ;
       cbOnP: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbOnY; else goto cbOnX;
       cbOnY: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOnX: // global
           _sbNLJ::P64 = P64[R1 + 7];
           I64[Hp - 72] = sat_sbNLP_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _sbNLD::P64;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sbNLJ::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = GHC.Tuple.()_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbOnQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbOo2; else goto cbOo1;
       cbOo2: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOo1: // global
           _sbNLQ::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sbNLV_info;
           P64[Hp - 32] = _sbNLD::P64;
           P64[Hp - 24] = _sbNLQ::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Tuple.()_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNLX_entry() //  [R1]
         { info_tbl: [(cbOo4,
                       label: sat_sbNLX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOo4: // global
           _sbNLX::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbOo5; else goto cbOo6;
       cbOo6: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbOo8; else goto cbOo7;
       cbOo8: // global
           HpAlloc = 64;
           goto cbOo5;
       cbOo5: // global
           R1 = _sbNLX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOo7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNLX::P64;
           _sbNLC::P64 = P64[_sbNLX::P64 + 16];
           _sbNLD::P64 = P64[_sbNLX::P64 + 24];
           _sbNLE::P64 = P64[_sbNLX::P64 + 32];
           I64[Hp - 56] = lvl5_sbNLG_info;
           P64[Hp - 40] = _sbNLD::P64;
           I64[Hp - 32] = sat_sbNLW_info;
           P64[Hp - 24] = _sbNLC::P64;
           P64[Hp - 16] = _sbNLD::P64;
           P64[Hp - 8] = _sbNLE::P64;
           P64[Hp] = Hp - 56;
           R2 = _sbNLD::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 31;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNLF_entry() //  [R1]
         { info_tbl: [(cbOod,
                       label: sat_sbNLF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOod: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOoe; else goto cbOof;
       cbOoe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOof: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.app_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.leftApp_entry() //  [R2, R3]
         { info_tbl: [(cbOog,
                       label: Control.Arrow.leftApp_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOog: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOoh; else goto cbOoi;
       cbOoh: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.leftApp_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOoi: // global
           I64[Sp - 24] = block_cbOm5_info;
           _sbNLB::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _sbNLB::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Control.Arrow.$p1ArrowApply_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOm5() //  [R1]
         { info_tbl: [(cbOm5,
                       label: block_cbOm5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOm5: // global
           I64[Sp - 8] = block_cbOm9_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOm9() //  [R1]
         { info_tbl: [(cbOm9,
                       label: block_cbOm9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOm9: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbOom; else goto cbOol;
       cbOom: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOol: // global
           I64[Hp - 56] = sat_sbNLX_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbNLF_info;
           P64[Hp] = P64[Sp + 16];
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 24] = Hp - 56;
           Sp = Sp + 8;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.187854083 UTC

[section ""cstring" . Control.Arrow.$trModule4_bytes" {
     Control.Arrow.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.188417222 UTC

[section ""data" . Control.Arrow.$trModule3_closure" {
     Control.Arrow.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.18893623 UTC

[section ""cstring" . Control.Arrow.$trModule2_bytes" {
     Control.Arrow.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,65,114,114,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.189470785 UTC

[section ""data" . Control.Arrow.$trModule1_closure" {
     Control.Arrow.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.190016008 UTC

[section ""data" . Control.Arrow.$trModule_closure" {
     Control.Arrow.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Arrow.$trModule3_closure+1;
         const Control.Arrow.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.190568431 UTC

[section ""data" . $krep_rbNCd_closure" {
     $krep_rbNCd_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.191141011 UTC

[section ""data" . $krep1_rbNCe_closure" {
     $krep1_rbNCe_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.1917092 UTC

[section ""data" . Control.Arrow.$tcKleisli1_closure" {
     Control.Arrow.$tcKleisli1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const GHC.Types.krep$*->*->*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.192214711 UTC

[section ""data" . Control.Arrow.$tcArrow1_closure" {
     Control.Arrow.$tcArrow1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const $krep1_rbNCe_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.192783708 UTC

[section ""data" . Control.Arrow.$tcArrowMonad1_closure" {
     Control.Arrow.$tcArrowMonad1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const GHC.Types.krep$*Arr*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.193487987 UTC

[section ""data" . $krep2_rbNCf_closure" {
     $krep2_rbNCf_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.194018475 UTC

[section ""data" . $krep3_rbNCg_closure" {
     $krep3_rbNCg_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.194511438 UTC

[section ""data" . $krep4_rbNCh_closure" {
     $krep4_rbNCh_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.195078113 UTC

[section ""data" . $krep5_rbNCi_closure" {
     $krep5_rbNCi_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_rbNCh_closure+2;
         const $krep2_rbNCf_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.195615981 UTC

[section ""data" . $krep6_rbNCj_closure" {
     $krep6_rbNCj_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rbNCg_closure+2;
         const $krep5_rbNCi_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.196152188 UTC

[section ""data" . $krep7_rbNCk_closure" {
     $krep7_rbNCk_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_rbNCh_closure+2;
         const $krep_rbNCd_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.196689224 UTC

[section ""data" . $krep8_rbNCl_closure" {
     $krep8_rbNCl_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep7_rbNCk_closure+3;
         const $krep3_rbNCg_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.19726099 UTC

[section ""cstring" . Control.Arrow.$tcArrow3_bytes" {
     Control.Arrow.$tcArrow3_bytes:
         I8[] [65,114,114,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.197790766 UTC

[section ""data" . Control.Arrow.$tcArrow2_closure" {
     Control.Arrow.$tcArrow2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrow3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.198363705 UTC

[section ""data" . Control.Arrow.$tcArrow_closure" {
     Control.Arrow.$tcArrow_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrow2_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 12964584583212294992;
         const 10211991410748124746;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.198923343 UTC

[section ""cstring" . Control.Arrow.$tcKleisli3_bytes" {
     Control.Arrow.$tcKleisli3_bytes:
         I8[] [75,108,101,105,115,108,105]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.199456486 UTC

[section ""data" . Control.Arrow.$tcKleisli2_closure" {
     Control.Arrow.$tcKleisli2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcKleisli3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.199978085 UTC

[section ""data" . Control.Arrow.$tcKleisli_closure" {
     Control.Arrow.$tcKleisli_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcKleisli2_closure+1;
         const Control.Arrow.$tcKleisli1_closure+4;
         const 2023158159015915132;
         const 6143719008973118504;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.200521703 UTC

[section ""data" . $krep9_rbNCm_closure" {
     $krep9_rbNCm_closure:
         const :_con_info;
         const $krep2_rbNCf_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.201123777 UTC

[section ""data" . $krep10_rbNCn_closure" {
     $krep10_rbNCn_closure:
         const :_con_info;
         const $krep3_rbNCg_closure+2;
         const $krep9_rbNCm_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.201702089 UTC

[section ""data" . $krep11_rbNCo_closure" {
     $krep11_rbNCo_closure:
         const :_con_info;
         const $krep4_rbNCh_closure+2;
         const $krep10_rbNCn_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.202272909 UTC

[section ""data" . $krep12_rbNCp_closure" {
     $krep12_rbNCp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Arrow.$tcKleisli_closure+1;
         const $krep11_rbNCo_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.202823701 UTC

[section ""data" . Control.Arrow.$tc'Kleisli1_closure" {
     Control.Arrow.$tc'Kleisli1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rbNCj_closure+4;
         const $krep12_rbNCp_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.203369186 UTC

[section ""cstring" . Control.Arrow.$tc'Kleisli3_bytes" {
     Control.Arrow.$tc'Kleisli3_bytes:
         I8[] [39,75,108,101,105,115,108,105]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.203886676 UTC

[section ""data" . Control.Arrow.$tc'Kleisli2_closure" {
     Control.Arrow.$tc'Kleisli2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tc'Kleisli3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.204422317 UTC

[section ""data" . Control.Arrow.$tc'Kleisli_closure" {
     Control.Arrow.$tc'Kleisli_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tc'Kleisli2_closure+1;
         const Control.Arrow.$tc'Kleisli1_closure+4;
         const 793719726112502834;
         const 14919550952510816382;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.20499355 UTC

[section ""cstring" . Control.Arrow.$tcArrowZero2_bytes" {
     Control.Arrow.$tcArrowZero2_bytes:
         I8[] [65,114,114,111,119,90,101,114,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.205746597 UTC

[section ""data" . Control.Arrow.$tcArrowZero1_closure" {
     Control.Arrow.$tcArrowZero1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowZero2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.206268708 UTC

[section ""data" . Control.Arrow.$tcArrowZero_closure" {
     Control.Arrow.$tcArrowZero_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowZero1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 337582314637215801;
         const 485553589222180171;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.206822192 UTC

[section ""cstring" . Control.Arrow.$tcArrowPlus2_bytes" {
     Control.Arrow.$tcArrowPlus2_bytes:
         I8[] [65,114,114,111,119,80,108,117,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.208781174 UTC

[section ""data" . Control.Arrow.$tcArrowPlus1_closure" {
     Control.Arrow.$tcArrowPlus1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowPlus2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.209380068 UTC

[section ""data" . Control.Arrow.$tcArrowPlus_closure" {
     Control.Arrow.$tcArrowPlus_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowPlus1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 9089885184909062397;
         const 13092571182525076608;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.209933721 UTC

[section ""cstring" . Control.Arrow.$tcArrowChoice2_bytes" {
     Control.Arrow.$tcArrowChoice2_bytes:
         I8[] [65,114,114,111,119,67,104,111,105,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.210511431 UTC

[section ""data" . Control.Arrow.$tcArrowChoice1_closure" {
     Control.Arrow.$tcArrowChoice1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowChoice2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.211068472 UTC

[section ""data" . Control.Arrow.$tcArrowChoice_closure" {
     Control.Arrow.$tcArrowChoice_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowChoice1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 9045385674203608923;
         const 4474606397073518393;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.211662129 UTC

[section ""cstring" . Control.Arrow.$tcArrowApply2_bytes" {
     Control.Arrow.$tcArrowApply2_bytes:
         I8[] [65,114,114,111,119,65,112,112,108,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.212214197 UTC

[section ""data" . Control.Arrow.$tcArrowApply1_closure" {
     Control.Arrow.$tcArrowApply1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowApply2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.212785646 UTC

[section ""data" . Control.Arrow.$tcArrowApply_closure" {
     Control.Arrow.$tcArrowApply_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowApply1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 4969046276209689969;
         const 2697302259091605677;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.213375698 UTC

[section ""cstring" . Control.Arrow.$tcArrowMonad3_bytes" {
     Control.Arrow.$tcArrowMonad3_bytes:
         I8[] [65,114,114,111,119,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.213868897 UTC

[section ""data" . Control.Arrow.$tcArrowMonad2_closure" {
     Control.Arrow.$tcArrowMonad2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowMonad3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.214420407 UTC

[section ""data" . Control.Arrow.$tcArrowMonad_closure" {
     Control.Arrow.$tcArrowMonad_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowMonad2_closure+1;
         const Control.Arrow.$tcArrowMonad1_closure+4;
         const 2648525758856951758;
         const 13692351200590237690;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.215037688 UTC

[section ""data" . $krep13_rbNCq_closure" {
     $krep13_rbNCq_closure:
         const :_con_info;
         const $krep3_rbNCg_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.215599979 UTC

[section ""data" . $krep14_rbNCr_closure" {
     $krep14_rbNCr_closure:
         const :_con_info;
         const $krep4_rbNCh_closure+2;
         const $krep13_rbNCq_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.216134856 UTC

[section ""data" . $krep15_rbNCs_closure" {
     $krep15_rbNCs_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Arrow.$tcArrowMonad_closure+1;
         const $krep14_rbNCr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.216663343 UTC

[section ""data" . Control.Arrow.$tc'ArrowMonad1_closure" {
     Control.Arrow.$tc'ArrowMonad1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rbNCl_closure+3;
         const $krep15_rbNCs_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.217190467 UTC

[section ""cstring" . Control.Arrow.$tc'ArrowMonad3_bytes" {
     Control.Arrow.$tc'ArrowMonad3_bytes:
         I8[] [39,65,114,114,111,119,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.218263362 UTC

[section ""data" . Control.Arrow.$tc'ArrowMonad2_closure" {
     Control.Arrow.$tc'ArrowMonad2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tc'ArrowMonad3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.218818252 UTC

[section ""data" . Control.Arrow.$tc'ArrowMonad_closure" {
     Control.Arrow.$tc'ArrowMonad_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tc'ArrowMonad2_closure+1;
         const Control.Arrow.$tc'ArrowMonad1_closure+4;
         const 8781545391513276915;
         const 783725375361948493;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.219337713 UTC

[section ""cstring" . Control.Arrow.$tcArrowLoop2_bytes" {
     Control.Arrow.$tcArrowLoop2_bytes:
         I8[] [65,114,114,111,119,76,111,111,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.219900518 UTC

[section ""data" . Control.Arrow.$tcArrowLoop1_closure" {
     Control.Arrow.$tcArrowLoop1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowLoop2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.220445485 UTC

[section ""data" . Control.Arrow.$tcArrowLoop_closure" {
     Control.Arrow.$tcArrowLoop_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowLoop1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 15298492960828880948;
         const 13953070859738786616;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.221396752 UTC

[section ""data" . Control.Arrow.C:ArrowLoop_closure" {
     Control.Arrow.C:ArrowLoop_closure:
         const Control.Arrow.C:ArrowLoop_info;
 },
 Control.Arrow.C:ArrowLoop_entry() //  [R2, R3]
         { info_tbl: [(cbOos,
                       label: Control.Arrow.C:ArrowLoop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOos: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOow; else goto cbOov;
       cbOow: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowLoop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOov: // global
           I64[Hp - 16] = Control.Arrow.C:ArrowLoop_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.222388143 UTC

[section ""data" . Control.Arrow.C:ArrowApply_closure" {
     Control.Arrow.C:ArrowApply_closure:
         const Control.Arrow.C:ArrowApply_info;
 },
 Control.Arrow.C:ArrowApply_entry() //  [R2, R3]
         { info_tbl: [(cbOoC,
                       label: Control.Arrow.C:ArrowApply_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOoC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOoG; else goto cbOoF;
       cbOoG: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowApply_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOoF: // global
           I64[Hp - 16] = Control.Arrow.C:ArrowApply_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.223414879 UTC

[section ""data" . Control.Arrow.C:ArrowChoice_closure" {
     Control.Arrow.C:ArrowChoice_closure:
         const Control.Arrow.C:ArrowChoice_info;
 },
 Control.Arrow.C:ArrowChoice_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbOoM,
                       label: Control.Arrow.C:ArrowChoice_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOoM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbOoQ; else goto cbOoP;
       cbOoQ: // global
           HpAlloc = 48;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowChoice_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOoP: // global
           I64[Hp - 40] = Control.Arrow.C:ArrowChoice_con_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.224510057 UTC

[section ""data" . Control.Arrow.C:ArrowPlus_closure" {
     Control.Arrow.C:ArrowPlus_closure:
         const Control.Arrow.C:ArrowPlus_info;
 },
 Control.Arrow.C:ArrowPlus_entry() //  [R2, R3]
         { info_tbl: [(cbOoW,
                       label: Control.Arrow.C:ArrowPlus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOoW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOp0; else goto cbOoZ;
       cbOp0: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowPlus_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOoZ: // global
           I64[Hp - 16] = Control.Arrow.C:ArrowPlus_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.225510086 UTC

[section ""data" . Control.Arrow.C:ArrowZero_closure" {
     Control.Arrow.C:ArrowZero_closure:
         const Control.Arrow.C:ArrowZero_info;
 },
 Control.Arrow.C:ArrowZero_entry() //  [R2, R3]
         { info_tbl: [(cbOp6,
                       label: Control.Arrow.C:ArrowZero_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOp6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOpa; else goto cbOp9;
       cbOpa: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowZero_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOp9: // global
           I64[Hp - 16] = Control.Arrow.C:ArrowZero_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.226567247 UTC

[section ""data" . Control.Arrow.C:Arrow_closure" {
     Control.Arrow.C:Arrow_closure:
         const Control.Arrow.C:Arrow_info;
 },
 Control.Arrow.C:Arrow_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbOpg,
                       label: Control.Arrow.C:Arrow_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOpg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbOpk; else goto cbOpj;
       cbOpk: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:Arrow_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbOpj: // global
           I64[Hp - 48] = Control.Arrow.C:Arrow_con_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.227515553 UTC

[Control.Arrow.C:ArrowLoop_con_entry() //  [R1]
         { info_tbl: [(cbOpl,
                       label: Control.Arrow.C:ArrowLoop_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,76,111,111,112]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOpl: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.228221336 UTC

[Control.Arrow.C:ArrowApply_con_entry() //  [R1]
         { info_tbl: [(cbOpm,
                       label: Control.Arrow.C:ArrowApply_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,65,112,112,108,121]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOpm: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.228923943 UTC

[Control.Arrow.C:ArrowChoice_con_entry() //  [R1]
         { info_tbl: [(cbOpn,
                       label: Control.Arrow.C:ArrowChoice_con_info
                       rep:HeapRep 5 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,67,104,111,105,99,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOpn: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.230062093 UTC

[Control.Arrow.C:ArrowPlus_con_entry() //  [R1]
         { info_tbl: [(cbOpo,
                       label: Control.Arrow.C:ArrowPlus_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,80,108,117,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOpo: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.230763849 UTC

[Control.Arrow.C:ArrowZero_con_entry() //  [R1]
         { info_tbl: [(cbOpp,
                       label: Control.Arrow.C:ArrowZero_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,90,101,114,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOpp: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.231442921 UTC

[Control.Arrow.C:Arrow_con_entry() //  [R1]
         { info_tbl: [(cbOpq,
                       label: Control.Arrow.C:Arrow_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOpq: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.232124273 UTC

[section ""relreadonly" . SbNZ8_srt" {
     SbNZ8_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Control.Arrow.$fMonadArrowMonad_closure;
         const lvl_rbNC6_closure;
         const Control.Arrow.$fMonadPlusArrowMonad_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.232704571 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:40.233448016 UTC

[section ""data" . Control.Arrow.$p1ArrowLoop_closure" {
     Control.Arrow.$p1ArrowLoop_closure:
         const Control.Arrow.$p1ArrowLoop_info;
 },
 Control.Arrow.$p1ArrowLoop_entry() //  [R2]
         { info_tbl: [(cbOpy,
                       label: Control.Arrow.$p1ArrowLoop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOpy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOpz; else goto cbOpA;
       cbOpz: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowLoop_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOpA: // global
           I64[Sp - 8] = block_cbOpv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOpE; else goto cbOpw;
       ubOpE: // global
           call _cbOpv(R1) args: 0, res: 0, upd: 0;
       cbOpw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOpv() //  [R1]
         { info_tbl: [(cbOpv,
                       label: block_cbOpv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOpv: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.234591713 UTC

[section ""data" . Control.Arrow.loop_closure" {
     Control.Arrow.loop_closure:
         const Control.Arrow.loop_info;
 },
 Control.Arrow.loop_entry() //  [R2]
         { info_tbl: [(cbOpM,
                       label: Control.Arrow.loop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOpM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOpN; else goto cbOpO;
       cbOpN: // global
           R2 = R2;
           R1 = Control.Arrow.loop_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOpO: // global
           I64[Sp - 8] = block_cbOpJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOpS; else goto cbOpK;
       ubOpS: // global
           call _cbOpJ(R1) args: 0, res: 0, upd: 0;
       cbOpK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOpJ() //  [R1]
         { info_tbl: [(cbOpJ,
                       label: block_cbOpJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOpJ: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.235712833 UTC

[section ""data" . Control.Arrow.$p1ArrowApply_closure" {
     Control.Arrow.$p1ArrowApply_closure:
         const Control.Arrow.$p1ArrowApply_info;
 },
 Control.Arrow.$p1ArrowApply_entry() //  [R2]
         { info_tbl: [(cbOq0,
                       label: Control.Arrow.$p1ArrowApply_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOq0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOq1; else goto cbOq2;
       cbOq1: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowApply_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOq2: // global
           I64[Sp - 8] = block_cbOpX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOq6; else goto cbOpY;
       ubOq6: // global
           call _cbOpX(R1) args: 0, res: 0, upd: 0;
       cbOpY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOpX() //  [R1]
         { info_tbl: [(cbOpX,
                       label: block_cbOpX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOpX: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.236815371 UTC

[section ""data" . Control.Arrow.app_closure" {
     Control.Arrow.app_closure:
         const Control.Arrow.app_info;
 },
 Control.Arrow.app_entry() //  [R2]
         { info_tbl: [(cbOqe,
                       label: Control.Arrow.app_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOqe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOqf; else goto cbOqg;
       cbOqf: // global
           R2 = R2;
           R1 = Control.Arrow.app_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOqg: // global
           I64[Sp - 8] = block_cbOqb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOqk; else goto cbOqc;
       ubOqk: // global
           call _cbOqb(R1) args: 0, res: 0, upd: 0;
       cbOqc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOqb() //  [R1]
         { info_tbl: [(cbOqb,
                       label: block_cbOqb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOqb: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.237968167 UTC

[section ""data" . Control.Arrow.$p1ArrowChoice_closure" {
     Control.Arrow.$p1ArrowChoice_closure:
         const Control.Arrow.$p1ArrowChoice_info;
 },
 Control.Arrow.$p1ArrowChoice_entry() //  [R2]
         { info_tbl: [(cbOqs,
                       label: Control.Arrow.$p1ArrowChoice_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOqs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOqt; else goto cbOqu;
       cbOqt: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowChoice_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOqu: // global
           I64[Sp - 8] = block_cbOqp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOqy; else goto cbOqq;
       ubOqy: // global
           call _cbOqp(R1) args: 0, res: 0, upd: 0;
       cbOqq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOqp() //  [R1]
         { info_tbl: [(cbOqp,
                       label: block_cbOqp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOqp: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.239096191 UTC

[section ""data" . Control.Arrow.left_closure" {
     Control.Arrow.left_closure:
         const Control.Arrow.left_info;
 },
 Control.Arrow.left_entry() //  [R2]
         { info_tbl: [(cbOqG,
                       label: Control.Arrow.left_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOqG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOqH; else goto cbOqI;
       cbOqH: // global
           R2 = R2;
           R1 = Control.Arrow.left_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOqI: // global
           I64[Sp - 8] = block_cbOqD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOqM; else goto cbOqE;
       ubOqM: // global
           call _cbOqD(R1) args: 0, res: 0, upd: 0;
       cbOqE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOqD() //  [R1]
         { info_tbl: [(cbOqD,
                       label: block_cbOqD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOqD: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.240204198 UTC

[section ""data" . Control.Arrow.right_closure" {
     Control.Arrow.right_closure:
         const Control.Arrow.right_info;
 },
 Control.Arrow.right_entry() //  [R2]
         { info_tbl: [(cbOqU,
                       label: Control.Arrow.right_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOqU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOqV; else goto cbOqW;
       cbOqV: // global
           R2 = R2;
           R1 = Control.Arrow.right_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOqW: // global
           I64[Sp - 8] = block_cbOqR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOr0; else goto cbOqS;
       ubOr0: // global
           call _cbOqR(R1) args: 0, res: 0, upd: 0;
       cbOqS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOqR() //  [R1]
         { info_tbl: [(cbOqR,
                       label: block_cbOqR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOqR: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.242561815 UTC

[section ""data" . Control.Arrow.+++_closure" {
     Control.Arrow.+++_closure:
         const Control.Arrow.+++_info;
 },
 Control.Arrow.+++_entry() //  [R2]
         { info_tbl: [(cbOr8,
                       label: Control.Arrow.+++_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOr8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOr9; else goto cbOra;
       cbOr9: // global
           R2 = R2;
           R1 = Control.Arrow.+++_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOra: // global
           I64[Sp - 8] = block_cbOr5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOre; else goto cbOr6;
       ubOre: // global
           call _cbOr5(R1) args: 0, res: 0, upd: 0;
       cbOr6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOr5() //  [R1]
         { info_tbl: [(cbOr5,
                       label: block_cbOr5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOr5: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.243708052 UTC

[section ""data" . Control.Arrow.|||_closure" {
     Control.Arrow.|||_closure:
         const Control.Arrow.|||_info;
 },
 Control.Arrow.|||_entry() //  [R2]
         { info_tbl: [(cbOrm,
                       label: Control.Arrow.|||_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOrm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOrn; else goto cbOro;
       cbOrn: // global
           R2 = R2;
           R1 = Control.Arrow.|||_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOro: // global
           I64[Sp - 8] = block_cbOrj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOrs; else goto cbOrk;
       ubOrs: // global
           call _cbOrj(R1) args: 0, res: 0, upd: 0;
       cbOrk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOrj() //  [R1]
         { info_tbl: [(cbOrj,
                       label: block_cbOrj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOrj: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.244810139 UTC

[section ""data" . Control.Arrow.$p1ArrowPlus_closure" {
     Control.Arrow.$p1ArrowPlus_closure:
         const Control.Arrow.$p1ArrowPlus_info;
 },
 Control.Arrow.$p1ArrowPlus_entry() //  [R2]
         { info_tbl: [(cbOrA,
                       label: Control.Arrow.$p1ArrowPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOrA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOrB; else goto cbOrC;
       cbOrB: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOrC: // global
           I64[Sp - 8] = block_cbOrx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOrG; else goto cbOry;
       ubOrG: // global
           call _cbOrx(R1) args: 0, res: 0, upd: 0;
       cbOry: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOrx() //  [R1]
         { info_tbl: [(cbOrx,
                       label: block_cbOrx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOrx: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.24596497 UTC

[section ""data" . Control.Arrow.<+>_closure" {
     Control.Arrow.<+>_closure:
         const Control.Arrow.<+>_info;
 },
 Control.Arrow.<+>_entry() //  [R2]
         { info_tbl: [(cbOrO,
                       label: Control.Arrow.<+>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOrO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOrP; else goto cbOrQ;
       cbOrP: // global
           R2 = R2;
           R1 = Control.Arrow.<+>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOrQ: // global
           I64[Sp - 8] = block_cbOrL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOrU; else goto cbOrM;
       ubOrU: // global
           call _cbOrL(R1) args: 0, res: 0, upd: 0;
       cbOrM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOrL() //  [R1]
         { info_tbl: [(cbOrL,
                       label: block_cbOrL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOrL: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.247082819 UTC

[section ""data" . Control.Arrow.$p1ArrowZero_closure" {
     Control.Arrow.$p1ArrowZero_closure:
         const Control.Arrow.$p1ArrowZero_info;
 },
 Control.Arrow.$p1ArrowZero_entry() //  [R2]
         { info_tbl: [(cbOs2,
                       label: Control.Arrow.$p1ArrowZero_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOs2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOs3; else goto cbOs4;
       cbOs3: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowZero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOs4: // global
           I64[Sp - 8] = block_cbOrZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOs8; else goto cbOs0;
       ubOs8: // global
           call _cbOrZ(R1) args: 0, res: 0, upd: 0;
       cbOs0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOrZ() //  [R1]
         { info_tbl: [(cbOrZ,
                       label: block_cbOrZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOrZ: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.248206781 UTC

[section ""data" . Control.Arrow.zeroArrow_closure" {
     Control.Arrow.zeroArrow_closure:
         const Control.Arrow.zeroArrow_info;
 },
 Control.Arrow.zeroArrow_entry() //  [R2]
         { info_tbl: [(cbOsg,
                       label: Control.Arrow.zeroArrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOsg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOsh; else goto cbOsi;
       cbOsh: // global
           R2 = R2;
           R1 = Control.Arrow.zeroArrow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOsi: // global
           I64[Sp - 8] = block_cbOsd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOsm; else goto cbOse;
       ubOsm: // global
           call _cbOsd(R1) args: 0, res: 0, upd: 0;
       cbOse: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOsd() //  [R1]
         { info_tbl: [(cbOsd,
                       label: block_cbOsd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOsd: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.249324521 UTC

[section ""data" . Control.Arrow.$p1Arrow_closure" {
     Control.Arrow.$p1Arrow_closure:
         const Control.Arrow.$p1Arrow_info;
 },
 Control.Arrow.$p1Arrow_entry() //  [R2]
         { info_tbl: [(cbOsu,
                       label: Control.Arrow.$p1Arrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOsu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOsv; else goto cbOsw;
       cbOsv: // global
           R2 = R2;
           R1 = Control.Arrow.$p1Arrow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOsw: // global
           I64[Sp - 8] = block_cbOsr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOsA; else goto cbOss;
       ubOsA: // global
           call _cbOsr(R1) args: 0, res: 0, upd: 0;
       cbOss: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOsr() //  [R1]
         { info_tbl: [(cbOsr,
                       label: block_cbOsr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOsr: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.250482402 UTC

[section ""data" . Control.Arrow.arr_closure" {
     Control.Arrow.arr_closure:
         const Control.Arrow.arr_info;
 },
 Control.Arrow.arr_entry() //  [R2]
         { info_tbl: [(cbOsI,
                       label: Control.Arrow.arr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOsI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOsJ; else goto cbOsK;
       cbOsJ: // global
           R2 = R2;
           R1 = Control.Arrow.arr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOsK: // global
           I64[Sp - 8] = block_cbOsF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOsO; else goto cbOsG;
       ubOsO: // global
           call _cbOsF(R1) args: 0, res: 0, upd: 0;
       cbOsG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOsF() //  [R1]
         { info_tbl: [(cbOsF,
                       label: block_cbOsF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOsF: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.251581848 UTC

[section ""data" . Control.Arrow.first_closure" {
     Control.Arrow.first_closure:
         const Control.Arrow.first_info;
 },
 Control.Arrow.first_entry() //  [R2]
         { info_tbl: [(cbOsW,
                       label: Control.Arrow.first_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOsW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOsX; else goto cbOsY;
       cbOsX: // global
           R2 = R2;
           R1 = Control.Arrow.first_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOsY: // global
           I64[Sp - 8] = block_cbOsT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOt2; else goto cbOsU;
       ubOt2: // global
           call _cbOsT(R1) args: 0, res: 0, upd: 0;
       cbOsU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOsT() //  [R1]
         { info_tbl: [(cbOsT,
                       label: block_cbOsT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOsT: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.252700475 UTC

[section ""data" . Control.Arrow.second_closure" {
     Control.Arrow.second_closure:
         const Control.Arrow.second_info;
 },
 Control.Arrow.second_entry() //  [R2]
         { info_tbl: [(cbOta,
                       label: Control.Arrow.second_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOta: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOtb; else goto cbOtc;
       cbOtb: // global
           R2 = R2;
           R1 = Control.Arrow.second_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOtc: // global
           I64[Sp - 8] = block_cbOt7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOtg; else goto cbOt8;
       ubOtg: // global
           call _cbOt7(R1) args: 0, res: 0, upd: 0;
       cbOt8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOt7() //  [R1]
         { info_tbl: [(cbOt7,
                       label: block_cbOt7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOt7: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.254107635 UTC

[section ""data" . Control.Arrow.***_closure" {
     Control.Arrow.***_closure:
         const Control.Arrow.***_info;
 },
 Control.Arrow.***_entry() //  [R2]
         { info_tbl: [(cbOto,
                       label: Control.Arrow.***_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOto: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOtp; else goto cbOtq;
       cbOtp: // global
           R2 = R2;
           R1 = Control.Arrow.***_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOtq: // global
           I64[Sp - 8] = block_cbOtl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOtu; else goto cbOtm;
       ubOtu: // global
           call _cbOtl(R1) args: 0, res: 0, upd: 0;
       cbOtm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOtl() //  [R1]
         { info_tbl: [(cbOtl,
                       label: block_cbOtl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOtl: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.255211646 UTC

[section ""data" . Control.Arrow.&&&_closure" {
     Control.Arrow.&&&_closure:
         const Control.Arrow.&&&_info;
 },
 Control.Arrow.&&&_entry() //  [R2]
         { info_tbl: [(cbOtC,
                       label: Control.Arrow.&&&_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOtC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOtD; else goto cbOtE;
       cbOtD: // global
           R2 = R2;
           R1 = Control.Arrow.&&&_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOtE: // global
           I64[Sp - 8] = block_cbOtz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOtI; else goto cbOtA;
       ubOtI: // global
           call _cbOtz(R1) args: 0, res: 0, upd: 0;
       cbOtA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOtz() //  [R1]
         { info_tbl: [(cbOtz,
                       label: block_cbOtz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOtz: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.256681636 UTC

[section ""data" . Control.Arrow.$c***_closure" {
     Control.Arrow.$c***_closure:
         const Control.Arrow.$c***_info;
 },
 sat_sbNEx_entry() //  [R1]
         { info_tbl: [(cbOtS,
                       label: sat_sbNEx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOtS: // global
           _sbNEx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOtT; else goto cbOtU;
       cbOtU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOtW; else goto cbOtV;
       cbOtW: // global
           HpAlloc = 24;
           goto cbOtT;
       cbOtT: // global
           R1 = _sbNEx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOtV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNEx::P64;
           _sbNEm::P64 = P64[_sbNEx::P64 + 16];
           _sbNEn::P64 = P64[_sbNEx::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sbNEn::P64;
           R2 = Hp - 16;
           R1 = _sbNEm::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNEs_entry() //  [R1]
         { info_tbl: [(cbOu2,
                       label: sat_sbNEs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOu2: // global
           _sbNEs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOu3; else goto cbOu4;
       cbOu4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOu6; else goto cbOu5;
       cbOu6: // global
           HpAlloc = 24;
           goto cbOu3;
       cbOu3: // global
           R1 = _sbNEs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOu5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNEs::P64;
           _sbNEl::P64 = P64[_sbNEs::P64 + 16];
           _sbNEn::P64 = P64[_sbNEs::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbNEn::P64;
           R2 = Hp - 16;
           R1 = _sbNEl::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$c***_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOu8,
                       label: Control.Arrow.$c***_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOu8: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbOuc; else goto cbOub;
       cbOuc: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$c***_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOub: // global
           I64[Hp - 80] = sat_sbNEx_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sbNEs_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.258354973 UTC

[section ""data" . Control.Arrow.$fArrow(->)_$carr_closure" {
     Control.Arrow.$fArrow(->)_$carr_closure:
         const Control.Arrow.$fArrow(->)_$carr_info;
 },
 Control.Arrow.$fArrow(->)_$carr_entry() //  [R2]
         { info_tbl: [(cbOuh,
                       label: Control.Arrow.$fArrow(->)_$carr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOuh: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.259223222 UTC

[section ""data" . Control.Arrow.$fCategoryTYPEKleisli1_closure" {
     Control.Arrow.$fCategoryTYPEKleisli1_closure:
         const Control.Arrow.$fCategoryTYPEKleisli1_info;
 },
 Control.Arrow.$fCategoryTYPEKleisli1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbOup,
                       label: Control.Arrow.$fCategoryTYPEKleisli1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOup: // global
           _sbNEC::P64 = R5;
           _sbNEB::P64 = R4;
           _sbNEA::P64 = R3;
           _sbNEz::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOuq; else goto cbOur;
       cbOur: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOut; else goto cbOus;
       cbOut: // global
           HpAlloc = 32;
           goto cbOuq;
       cbOuq: // global
           R5 = _sbNEC::P64;
           R4 = _sbNEB::P64;
           R3 = _sbNEA::P64;
           R2 = _sbNEz::P64;
           R1 = Control.Arrow.$fCategoryTYPEKleisli1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOus: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbNEB::P64;
           P64[Hp] = _sbNEC::P64;
           R2 = _sbNEz::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNEA::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.26058875 UTC

[section ""data" . Control.Arrow.$fCategoryTYPEKleisli_closure" {
     Control.Arrow.$fCategoryTYPEKleisli_closure:
         const Control.Arrow.$fCategoryTYPEKleisli_info;
 },
 sat_sbNEG_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbOuD,
                       label: sat_sbNEG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOuD: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fCategoryTYPEKleisli1_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNEF_entry() //  [R1]
         { info_tbl: [(cbOuK,
                       label: sat_sbNEF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOuK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOuL; else goto cbOuM;
       cbOuL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOuM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fCategoryTYPEKleisli_entry() //  [R2]
         { info_tbl: [(cbOuO,
                       label: Control.Arrow.$fCategoryTYPEKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOuO: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbOuS; else goto cbOuR;
       cbOuS: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Arrow.$fCategoryTYPEKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOuR: // global
           I64[Hp - 56] = sat_sbNEG_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbNEF_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Category.C:Category_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 53;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.26235009 UTC

[section ""data" . Control.Arrow.$fArrowKleisli4_closure" {
     Control.Arrow.$fArrowKleisli4_closure:
         const Control.Arrow.$fArrowKleisli4_info;
 },
 sat_sbNEV_entry() //  [R1, R2]
         { info_tbl: [(cbOv4,
                       label: sat_sbNEV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOv4: // global
           _sbNET::P64 = R2;
           _sbNEV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOv5; else goto cbOv6;
       cbOv6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOv8; else goto cbOv7;
       cbOv8: // global
           HpAlloc = 24;
           goto cbOv5;
       cbOv5: // global
           R2 = _sbNET::P64;
           R1 = _sbNEV::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOv7: // global
           _sbNEH::P64 = P64[_sbNEV::P64 + 7];
           _sbNEK::P64 = P64[_sbNEV::P64 + 15];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbNEK::P64;
           P64[Hp] = _sbNET::P64;
           R2 = _sbNEH::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbNES_entry() //  [R1]
         { info_tbl: [(cbOve,
                       label: sat_sbNES_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOve: // global
           _sbNES::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOvf; else goto cbOvg;
       cbOvg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOvi; else goto cbOvh;
       cbOvi: // global
           HpAlloc = 24;
           goto cbOvf;
       cbOvf: // global
           R1 = _sbNES::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOvh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNES::P64;
           _sbNEI::P64 = P64[_sbNES::P64 + 16];
           _sbNEJ::P64 = P64[_sbNES::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sbNEJ::P64;
           R2 = Hp - 16;
           R1 = _sbNEI::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli4_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOvj,
                       label: Control.Arrow.$fArrowKleisli4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOvj: // global
           _sbNEJ::P64 = R4;
           _sbNEI::P64 = R3;
           _sbNEH::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOvk; else goto cbOvl;
       cbOvl: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbOvn; else goto cbOvm;
       cbOvn: // global
           HpAlloc = 80;
           goto cbOvk;
       cbOvk: // global
           R4 = _sbNEJ::P64;
           R3 = _sbNEI::P64;
           R2 = _sbNEH::P64;
           R1 = Control.Arrow.$fArrowKleisli4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOvm: // global
           I64[Hp - 72] = stg_sel_0_upd_info;
           P64[Hp - 56] = _sbNEJ::P64;
           I64[Hp - 48] = sat_sbNEV_info;
           P64[Hp - 40] = _sbNEH::P64;
           P64[Hp - 32] = Hp - 72;
           I64[Hp - 24] = sat_sbNES_info;
           P64[Hp - 8] = _sbNEI::P64;
           P64[Hp] = _sbNEJ::P64;
           R2 = _sbNEH::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.264519484 UTC

[section ""data" . Control.Arrow.$fArrowKleisli3_closure" {
     Control.Arrow.$fArrowKleisli3_closure:
         const Control.Arrow.$fArrowKleisli3_info;
 },
 sat_sbNFa_entry() //  [R1, R2]
         { info_tbl: [(cbOvz,
                       label: sat_sbNFa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOvz: // global
           _sbNF8::P64 = R2;
           _sbNFa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOvA; else goto cbOvB;
       cbOvB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOvD; else goto cbOvC;
       cbOvD: // global
           HpAlloc = 24;
           goto cbOvA;
       cbOvA: // global
           R2 = _sbNF8::P64;
           R1 = _sbNFa::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOvC: // global
           _sbNEW::P64 = P64[_sbNFa::P64 + 7];
           _sbNEZ::P64 = P64[_sbNFa::P64 + 15];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbNF8::P64;
           P64[Hp] = _sbNEZ::P64;
           R2 = _sbNEW::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbNF7_entry() //  [R1]
         { info_tbl: [(cbOvJ,
                       label: sat_sbNF7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOvJ: // global
           _sbNF7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOvK; else goto cbOvL;
       cbOvL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOvN; else goto cbOvM;
       cbOvN: // global
           HpAlloc = 24;
           goto cbOvK;
       cbOvK: // global
           R1 = _sbNF7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOvM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNF7::P64;
           _sbNEX::P64 = P64[_sbNF7::P64 + 16];
           _sbNEY::P64 = P64[_sbNF7::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbNEY::P64;
           R2 = Hp - 16;
           R1 = _sbNEX::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli3_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOvO,
                       label: Control.Arrow.$fArrowKleisli3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOvO: // global
           _sbNEY::P64 = R4;
           _sbNEX::P64 = R3;
           _sbNEW::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOvP; else goto cbOvQ;
       cbOvQ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbOvS; else goto cbOvR;
       cbOvS: // global
           HpAlloc = 80;
           goto cbOvP;
       cbOvP: // global
           R4 = _sbNEY::P64;
           R3 = _sbNEX::P64;
           R2 = _sbNEW::P64;
           R1 = Control.Arrow.$fArrowKleisli3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOvR: // global
           I64[Hp - 72] = stg_sel_1_upd_info;
           P64[Hp - 56] = _sbNEY::P64;
           I64[Hp - 48] = sat_sbNFa_info;
           P64[Hp - 40] = _sbNEW::P64;
           P64[Hp - 32] = Hp - 72;
           I64[Hp - 24] = sat_sbNF7_info;
           P64[Hp - 8] = _sbNEX::P64;
           P64[Hp] = _sbNEY::P64;
           R2 = _sbNEW::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.266628759 UTC

[section ""data" . Control.Arrow.$fArrowKleisli5_closure" {
     Control.Arrow.$fArrowKleisli5_closure:
         const Control.Arrow.$fArrowKleisli5_info;
 },
 Control.Arrow.$fArrowKleisli5_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOvY,
                       label: Control.Arrow.$fArrowKleisli5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOvY: // global
           _sbNFd::P64 = R4;
           _sbNFc::P64 = R3;
           _sbNFb::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOvZ; else goto cbOw0;
       cbOw0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOw2; else goto cbOw1;
       cbOw2: // global
           HpAlloc = 32;
           goto cbOvZ;
       cbOvZ: // global
           R4 = _sbNFd::P64;
           R3 = _sbNFc::P64;
           R2 = _sbNFb::P64;
           R1 = Control.Arrow.$fArrowKleisli5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOw1: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbNFc::P64;
           P64[Hp] = _sbNFd::P64;
           R2 = _sbNFb::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.267682581 UTC

[section ""data" . Control.Arrow.$fArrowPlusKleisli1_closure" {
     Control.Arrow.$fArrowPlusKleisli1_closure:
         const Control.Arrow.$fArrowPlusKleisli1_info;
 },
 Control.Arrow.$fArrowPlusKleisli1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbOw9,
                       label: Control.Arrow.$fArrowPlusKleisli1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOw9: // global
           _sbNFi::P64 = R5;
           _sbNFh::P64 = R4;
           _sbNFg::P64 = R3;
           _sbNFf::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOwa; else goto cbOwb;
       cbOwb: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbOwd; else goto cbOwc;
       cbOwd: // global
           HpAlloc = 64;
           goto cbOwa;
       cbOwa: // global
           R5 = _sbNFi::P64;
           R4 = _sbNFh::P64;
           R3 = _sbNFg::P64;
           R2 = _sbNFf::P64;
           R1 = Control.Arrow.$fArrowPlusKleisli1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOwc: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sbNFh::P64;
           P64[Hp - 32] = _sbNFi::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbNFg::P64;
           P64[Hp] = _sbNFi::P64;
           R2 = _sbNFf::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.268870961 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_$capp_closure" {
     Control.Arrow.$fAlternativeArrowMonad_$capp_closure:
         const Control.Arrow.$fAlternativeArrowMonad_$capp_info;
 },
 Control.Arrow.$fAlternativeArrowMonad_$capp_entry() //  [R2]
         { info_tbl: [(cbOwl,
                       label: Control.Arrow.$fAlternativeArrowMonad_$capp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOwl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOwm; else goto cbOwn;
       cbOwm: // global
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_$capp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOwn: // global
           I64[Sp - 8] = block_cbOwi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOwr; else goto cbOwj;
       ubOwr: // global
           call _cbOwi(R1) args: 0, res: 0, upd: 0;
       cbOwj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOwi() //  [R1]
         { info_tbl: [(cbOwi,
                       label: block_cbOwi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOwi: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.270217599 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad5_closure" {
     Control.Arrow.$fApplicativeArrowMonad5_closure:
         const Control.Arrow.$fApplicativeArrowMonad5_info;
 },
 sat_sbNFt_entry() //  [R1]
         { info_tbl: [(cbOwA,
                       label: sat_sbNFt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOwA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOwB; else goto cbOwC;
       cbOwB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOwC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad5_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOwF,
                       label: Control.Arrow.$fApplicativeArrowMonad5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOwF: // global
           _sbNFr::P64 = R4;
           _sbNFq::P64 = R3;
           _sbNFp::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOwG; else goto cbOwH;
       cbOwH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOwJ; else goto cbOwI;
       cbOwJ: // global
           HpAlloc = 32;
           goto cbOwG;
       cbOwG: // global
           R4 = _sbNFr::P64;
           R3 = _sbNFq::P64;
           R2 = _sbNFp::P64;
           R1 = Control.Arrow.$fApplicativeArrowMonad5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOwI: // global
           I64[Hp - 24] = sat_sbNFt_info;
           P64[Hp - 8] = _sbNFp::P64;
           P64[Hp] = _sbNFq::P64;
           I64[Sp - 24] = block_cbOwD_info;
           R2 = _sbNFp::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNFr::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOwD() //  [R1]
         { info_tbl: [(cbOwD,
                       label: block_cbOwD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOwD: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.271986925 UTC

[section ""data" . Control.Arrow.$fFunctorArrowMonad1_closure" {
     Control.Arrow.$fFunctorArrowMonad1_closure:
         const Control.Arrow.$fFunctorArrowMonad1_info;
 },
 sat_sbNFz_entry() //  [R1]
         { info_tbl: [(cbOx0,
                       label: sat_sbNFz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOx0: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNFA_entry() //  [R1]
         { info_tbl: [(cbOx3,
                       label: sat_sbNFA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOx3: // global
           _sbNFA::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbOx4; else goto cbOx5;
       cbOx5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbOx7; else goto cbOx6;
       cbOx7: // global
           HpAlloc = 16;
           goto cbOx4;
       cbOx4: // global
           R1 = _sbNFA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOx6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNFA::P64;
           _sbNFu::P64 = P64[_sbNFA::P64 + 16];
           _sbNFv::P64 = P64[_sbNFA::P64 + 24];
           I64[Hp - 8] = sat_sbNFz_info;
           P64[Hp] = _sbNFv::P64;
           R2 = _sbNFu::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fFunctorArrowMonad1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOxa,
                       label: Control.Arrow.$fFunctorArrowMonad1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOxa: // global
           _sbNFw::P64 = R4;
           _sbNFv::P64 = R3;
           _sbNFu::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOxb; else goto cbOxc;
       cbOxc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOxe; else goto cbOxd;
       cbOxe: // global
           HpAlloc = 32;
           goto cbOxb;
       cbOxb: // global
           R4 = _sbNFw::P64;
           R3 = _sbNFv::P64;
           R2 = _sbNFu::P64;
           R1 = Control.Arrow.$fFunctorArrowMonad1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOxd: // global
           I64[Hp - 24] = sat_sbNFA_info;
           P64[Hp - 8] = _sbNFu::P64;
           P64[Hp] = _sbNFv::P64;
           I64[Sp - 24] = block_cbOx8_info;
           R2 = _sbNFu::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNFw::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOx8() //  [R1]
         { info_tbl: [(cbOx8,
                       label: block_cbOx8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOx8: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.273882199 UTC

[section ""data" . Control.Arrow.$fFunctorArrowMonad_closure" {
     Control.Arrow.$fFunctorArrowMonad_closure:
         const Control.Arrow.$fFunctorArrowMonad_info;
 },
 sat_sbNFD_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOxr,
                       label: sat_sbNFD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOxr: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fFunctorArrowMonad1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNFC_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOxz,
                       label: sat_sbNFC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOxz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fApplicativeArrowMonad5_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fFunctorArrowMonad_entry() //  [R2]
         { info_tbl: [(cbOxD,
                       label: Control.Arrow.$fFunctorArrowMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOxD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbOxH; else goto cbOxG;
       cbOxH: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Arrow.$fFunctorArrowMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOxG: // global
           I64[Hp - 48] = sat_sbNFD_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sbNFC_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.275565589 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad2_closure" {
     Control.Arrow.$fAlternativeArrowMonad2_closure:
         const Control.Arrow.$fAlternativeArrowMonad2_info;
 },
 sat_sbNFJ_entry() //  [R1]
         { info_tbl: [(cbOxQ,
                       label: sat_sbNFJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOxQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbOxR; else goto cbOxS;
       cbOxR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOxS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Arrow.&&&_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNFI_entry() //  [R1]
         { info_tbl: [(cbOxX,
                       label: sat_sbNFI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOxX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOxY; else goto cbOxZ;
       cbOxY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOxZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fAlternativeArrowMonad_$capp_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOy2,
                       label: Control.Arrow.$fAlternativeArrowMonad2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOy2: // global
           _sbNFG::P64 = R4;
           _sbNFF::P64 = R3;
           _sbNFE::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOy3; else goto cbOy4;
       cbOy4: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbOy6; else goto cbOy5;
       cbOy6: // global
           HpAlloc = 64;
           goto cbOy3;
       cbOy3: // global
           R4 = _sbNFG::P64;
           R3 = _sbNFF::P64;
           R2 = _sbNFE::P64;
           R1 = Control.Arrow.$fAlternativeArrowMonad2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOy5: // global
           I64[Hp - 56] = sat_sbNFJ_info;
           P64[Hp - 40] = _sbNFE::P64;
           P64[Hp - 32] = _sbNFF::P64;
           P64[Hp - 24] = _sbNFG::P64;
           I64[Hp - 16] = sat_sbNFI_info;
           P64[Hp] = _sbNFE::P64;
           I64[Sp - 24] = block_cbOy0_info;
           R2 = _sbNFE::P64;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOy0() //  [R1]
         { info_tbl: [(cbOy0,
                       label: block_cbOy0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOy0: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbOxM::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbOxM::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.277433163 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad6_closure" {
     Control.Arrow.$fApplicativeArrowMonad6_closure:
         const Control.Arrow.$fApplicativeArrowMonad6_info;
 },
 sat_sbNFN_entry() //  [R1]
         { info_tbl: [(cbOyj,
                       label: sat_sbNFN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOyj: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad6_entry() //  [R2, R3]
         { info_tbl: [(cbOym,
                       label: Control.Arrow.$fApplicativeArrowMonad6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOym: // global
           _sbNFL::P64 = R3;
           _sbNFK::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOyn; else goto cbOyo;
       cbOyo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbOyq; else goto cbOyp;
       cbOyq: // global
           HpAlloc = 16;
           goto cbOyn;
       cbOyn: // global
           R3 = _sbNFL::P64;
           R2 = _sbNFK::P64;
           R1 = Control.Arrow.$fApplicativeArrowMonad6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOyp: // global
           I64[Hp - 8] = sat_sbNFN_info;
           P64[Hp] = _sbNFL::P64;
           R2 = _sbNFK::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Arrow.arr_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.278775797 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad4_closure" {
     Control.Arrow.$fApplicativeArrowMonad4_closure:
         const Control.Arrow.$fApplicativeArrowMonad4_info;
 },
 sat_sbNFR_entry() //  [R1]
         { info_tbl: [(cbOyz,
                       label: sat_sbNFR_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOyz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOyA; else goto cbOyB;
       cbOyA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOyB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fApplicativeArrowMonad5_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad4_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOyC,
                       label: Control.Arrow.$fApplicativeArrowMonad4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOyC: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbOyG; else goto cbOyF;
       cbOyG: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fApplicativeArrowMonad4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOyF: // global
           I64[Hp - 32] = sat_sbNFR_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = Hp - 32;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad2_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.280005845 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad3_closure" {
     Control.Arrow.$fApplicativeArrowMonad3_closure:
         const Control.Arrow.$fApplicativeArrowMonad3_info;
 },
 Control.Arrow.$fApplicativeArrowMonad3_entry() //  [R3]
         { info_tbl: [(cbOyL,
                       label: Control.Arrow.$fApplicativeArrowMonad3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOyL: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.281178021 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad2_closure" {
     Control.Arrow.$fApplicativeArrowMonad2_closure:
         const Control.Arrow.$fApplicativeArrowMonad2_info;
 },
 sat_sbNFY_entry() //  [R1]
         { info_tbl: [(cbOz0,
                       label: sat_sbNFY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOz0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOz1; else goto cbOz2;
       cbOz1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOz2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fApplicativeArrowMonad3_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNFZ_entry() //  [R1]
         { info_tbl: [(cbOz5,
                       label: sat_sbNFZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOz5: // global
           _sbNFZ::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbOz6; else goto cbOz7;
       cbOz7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOz9; else goto cbOz8;
       cbOz9: // global
           HpAlloc = 24;
           goto cbOz6;
       cbOz6: // global
           R1 = _sbNFZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOz8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNFZ::P64;
           _sbNFU::P64 = P64[_sbNFZ::P64 + 16];
           _sbNFV::P64 = P64[_sbNFZ::P64 + 24];
           I64[Hp - 16] = sat_sbNFY_info;
           P64[Hp] = _sbNFU::P64;
           I64[Sp - 40] = block_cbOz3_info;
           R2 = _sbNFU::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbNFV::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbOz3() //  [R1]
         { info_tbl: [(cbOz3,
                       label: block_cbOz3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOz3: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOzd,
                       label: Control.Arrow.$fApplicativeArrowMonad2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOzd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOzh; else goto cbOzg;
       cbOzh: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fApplicativeArrowMonad2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOzg: // global
           I64[Hp - 24] = sat_sbNFZ_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R4 = R4;
           R3 = Hp - 24;
           R2 = R2;
           call Control.Arrow.$fAlternativeArrowMonad2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.283276292 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad1_closure" {
     Control.Arrow.$fApplicativeArrowMonad1_closure:
         const Control.Arrow.$fApplicativeArrowMonad1_info;
 },
 sat_sbNG3_entry() //  [R1]
         { info_tbl: [(cbOzu,
                       label: sat_sbNG3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOzu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOzv; else goto cbOzw;
       cbOzv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOzw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Base.const_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNG4_entry() //  [R1]
         { info_tbl: [(cbOzz,
                       label: sat_sbNG4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOzz: // global
           _sbNG4::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbOzA; else goto cbOzB;
       cbOzB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOzD; else goto cbOzC;
       cbOzD: // global
           HpAlloc = 24;
           goto cbOzA;
       cbOzA: // global
           R1 = _sbNG4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOzC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNG4::P64;
           _sbNG0::P64 = P64[_sbNG4::P64 + 16];
           _sbNG1::P64 = P64[_sbNG4::P64 + 24];
           I64[Hp - 16] = sat_sbNG3_info;
           P64[Hp] = _sbNG0::P64;
           I64[Sp - 40] = block_cbOzx_info;
           R2 = _sbNG0::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbNG1::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbOzx() //  [R1]
         { info_tbl: [(cbOzx,
                       label: block_cbOzx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOzx: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad1_entry() //  [R2, R3]
         { info_tbl: [(cbOzH,
                       label: Control.Arrow.$fApplicativeArrowMonad1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOzH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOzL; else goto cbOzK;
       cbOzL: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fApplicativeArrowMonad1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOzK: // global
           I64[Hp - 24] = sat_sbNG4_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad2_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.285622178 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad_closure" {
     Control.Arrow.$fApplicativeArrowMonad_closure:
         const Control.Arrow.$fApplicativeArrowMonad_info;
 },
 sat_sbNGb_entry() //  [R1, R2]
         { info_tbl: [(cbOzV,
                       label: sat_sbNGb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOzV: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fApplicativeArrowMonad1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNGa_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOA3,
                       label: sat_sbNGa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOA3: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fApplicativeArrowMonad2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNG9_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOAb,
                       label: sat_sbNG9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOAb: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fApplicativeArrowMonad4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNG8_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOAj,
                       label: sat_sbNG8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOAj: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fAlternativeArrowMonad2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNG7_entry() //  [R1, R2]
         { info_tbl: [(cbOAr,
                       label: sat_sbNG7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOAr: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fApplicativeArrowMonad6_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNG6_entry() //  [R1]
         { info_tbl: [(cbOAy,
                       label: sat_sbNG6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOAy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOAz; else goto cbOAA;
       cbOAz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOAA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fFunctorArrowMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad_entry() //  [R2]
         { info_tbl: [(cbOAC,
                       label: Control.Arrow.$fApplicativeArrowMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOAC: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cbOAG; else goto cbOAF;
       cbOAG: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = Control.Arrow.$fApplicativeArrowMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOAF: // global
           I64[Hp - 152] = sat_sbNGb_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbNGa_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbNG9_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbNG8_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbNG7_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbNG6_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 87;
           P64[Hp - 24] = Hp - 102;
           P64[Hp - 16] = Hp - 118;
           P64[Hp - 8] = Hp - 134;
           P64[Hp] = Hp - 151;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.288458583 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad_$c>>=_closure" {
     Control.Arrow.$fMonadArrowMonad_$c>>=_closure:
         const Control.Arrow.$fMonadArrowMonad_$c>>=_info;
 },
 sat_sbNGk_entry() //  [R1, R2]
         { info_tbl: [(cbOB8,
                       label: sat_sbNGk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOB8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbOBc; else goto cbOBb;
       cbOBc: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOBb: // global
           _sbNGe::P64 = P64[R1 + 7];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sbNGe::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Tuple.()_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNGl_entry() //  [R1]
         { info_tbl: [(cbOBd,
                       label: sat_sbNGl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOBd: // global
           _sbNGl::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbOBe; else goto cbOBf;
       cbOBf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbOBh; else goto cbOBg;
       cbOBh: // global
           HpAlloc = 16;
           goto cbOBe;
       cbOBe: // global
           R1 = _sbNGl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOBg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNGl::P64;
           _sbNGe::P64 = P64[_sbNGl::P64 + 16];
           _sbNGf::P64 = P64[_sbNGl::P64 + 24];
           I64[Hp - 8] = sat_sbNGk_info;
           P64[Hp] = _sbNGe::P64;
           R2 = _sbNGf::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNGm_entry() //  [R1]
         { info_tbl: [(cbOBi,
                       label: sat_sbNGm_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOBi: // global
           _sbNGm::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbOBj; else goto cbOBk;
       cbOBk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOBm; else goto cbOBl;
       cbOBm: // global
           HpAlloc = 32;
           goto cbOBj;
       cbOBj: // global
           R1 = _sbNGm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOBl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNGm::P64;
           _sbNGd::P64 = P64[_sbNGm::P64 + 16];
           _sbNGe::P64 = P64[_sbNGm::P64 + 24];
           _sbNGf::P64 = P64[_sbNGm::P64 + 32];
           _sbNGg::P64 = P64[_sbNGm::P64 + 40];
           I64[Hp - 24] = sat_sbNGl_info;
           P64[Hp - 8] = _sbNGe::P64;
           P64[Hp] = _sbNGf::P64;
           R2 = _sbNGg::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sbNGd::P64;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNGh_entry() //  [R1]
         { info_tbl: [(cbOBr,
                       label: sat_sbNGh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOBr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOBs; else goto cbOBt;
       cbOBs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOBt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.app_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fMonadArrowMonad_$c>>=_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOBu,
                       label: Control.Arrow.$fMonadArrowMonad_$c>>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOBu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbOBv; else goto cbOBw;
       cbOBv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fMonadArrowMonad_$c>>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOBw: // global
           I64[Sp - 32] = block_cbOAL_info;
           _sbNGc::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbNGc::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Arrow.$p1ArrowApply_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOAL() //  [R1]
         { info_tbl: [(cbOAL,
                       label: block_cbOAL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOAL: // global
           I64[Sp - 8] = block_cbOAP_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOAP() //  [R1]
         { info_tbl: [(cbOAP,
                       label: block_cbOAP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOAP: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbOBA; else goto cbOBz;
       cbOBA: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOBz: // global
           I64[Hp - 64] = sat_sbNGm_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbNGh_info;
           P64[Hp] = P64[Sp + 16];
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 16;
           P64[Sp + 32] = Hp - 64;
           Sp = Sp + 16;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.291256177 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad_$cp1Monad_closure" {
     Control.Arrow.$fMonadArrowMonad_$cp1Monad_closure:
         const Control.Arrow.$fMonadArrowMonad_$cp1Monad_info;
 },
 sat_sbNGo_entry() //  [R1]
         { info_tbl: [(cbOBJ,
                       label: sat_sbNGo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOBJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOBK; else goto cbOBL;
       cbOBK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOBL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowApply_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fMonadArrowMonad_$cp1Monad_entry() //  [R2]
         { info_tbl: [(cbOBM,
                       label: Control.Arrow.$fMonadArrowMonad_$cp1Monad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOBM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOBQ; else goto cbOBP;
       cbOBQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Arrow.$fMonadArrowMonad_$cp1Monad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOBP: // global
           I64[Hp - 16] = sat_sbNGo_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Arrow.$fApplicativeArrowMonad_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.292577356 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad1_closure" {
     Control.Arrow.$fMonadArrowMonad1_closure:
         const Control.Arrow.$fMonadArrowMonad1_info;
 },
 sat_sbNGt_entry() //  [R1]
         { info_tbl: [(cbOC0,
                       label: sat_sbNGt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOC0: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fMonadArrowMonad1_entry() //  [R2, R3]
         { info_tbl: [(cbOC5,
                       label: Control.Arrow.$fMonadArrowMonad1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOC5: // global
           _sbNGq::P64 = R3;
           _sbNGp::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOC6; else goto cbOC7;
       cbOC7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbOC9; else goto cbOC8;
       cbOC9: // global
           HpAlloc = 16;
           goto cbOC6;
       cbOC6: // global
           R3 = _sbNGq::P64;
           R2 = _sbNGp::P64;
           R1 = Control.Arrow.$fMonadArrowMonad1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOC8: // global
           I64[Hp - 8] = sat_sbNGt_info;
           P64[Hp] = _sbNGq::P64;
           I64[Sp - 16] = block_cbOC3_info;
           R2 = _sbNGp::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowApply_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOC3() //  [R1]
         { info_tbl: [(cbOC3,
                       label: block_cbOC3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOC3: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call Control.Arrow.arr_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.294036408 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad_$c>>_closure" {
     Control.Arrow.$fMonadArrowMonad_$c>>_closure:
         const Control.Arrow.$fMonadArrowMonad_$c>>_info;
 },
 sat_sbNGy_entry() //  [R1]
         { info_tbl: [(cbOCm,
                       label: sat_sbNGy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOCm: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fMonadArrowMonad_$c>>_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOCp,
                       label: Control.Arrow.$fMonadArrowMonad_$c>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOCp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbOCt; else goto cbOCs;
       cbOCt: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fMonadArrowMonad_$c>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOCs: // global
           I64[Hp - 8] = sat_sbNGy_info;
           P64[Hp] = R4;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Control.Arrow.$fMonadArrowMonad_$c>>=_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.295074646 UTC

[section ""data" . lvl_rbNC6_closure" {
     lvl_rbNC6_closure:
         const lvl_rbNC6_info;
         const 0;
 },
 lvl_rbNC6_entry() //  [R2]
         { info_tbl: [(cbOCy,
                       label: lvl_rbNC6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOCy: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.29640318 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad_closure" {
     Control.Arrow.$fMonadArrowMonad_closure:
         const Control.Arrow.$fMonadArrowMonad_info;
         const 0;
 },
 sat_sbNGE_entry() //  [R1, R2]
         { info_tbl: [(cbOCK,
                       label: sat_sbNGE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOCK: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fMonadArrowMonad1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNGD_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOCS,
                       label: sat_sbNGD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOCS: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fMonadArrowMonad_$c>>_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNGC_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOD0,
                       label: sat_sbNGC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOD0: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fMonadArrowMonad_$c>>=_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNGB_entry() //  [R1]
         { info_tbl: [(cbOD7,
                       label: sat_sbNGB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOD7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOD8; else goto cbOD9;
       cbOD8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOD9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fMonadArrowMonad_$cp1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fMonadArrowMonad_entry() //  [R2]
         { info_tbl: [(cbODb,
                       label: Control.Arrow.$fMonadArrowMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbODb: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cbODf; else goto cbODe;
       cbODf: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Control.Arrow.$fMonadArrowMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbODe: // global
           I64[Hp - 112] = sat_sbNGE_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbNGD_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbNGC_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbNGB_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 94;
           P64[Hp - 8] = Hp - 111;
           P64[Hp] = lvl_rbNC6_closure+1;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.298179715 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad3_closure" {
     Control.Arrow.$fAlternativeArrowMonad3_closure:
         const Control.Arrow.$fAlternativeArrowMonad3_info;
 },
 Control.Arrow.$fAlternativeArrowMonad3_entry() //  [R2]
         { info_tbl: [(cbODm,
                       label: Control.Arrow.$fAlternativeArrowMonad3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbODm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbODn; else goto cbODo;
       cbODn: // global
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbODo: // global
           I64[Sp - 8] = block_cbODk_info;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Arrow.$p1ArrowPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbODk() //  [R1]
         { info_tbl: [(cbODk,
                       label: block_cbODk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbODk: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Arrow.zeroArrow_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.29934641 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_closure" {
     Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_closure:
         const Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_info;
 },
 sat_sbNGJ_entry() //  [R1]
         { info_tbl: [(cbODC,
                       label: sat_sbNGJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbODC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbODD; else goto cbODE;
       cbODD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbODE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbODA_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1ArrowPlus_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbODA() //  [R1]
         { info_tbl: [(cbODA,
                       label: block_cbODA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbODA: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_entry() //  [R2]
         { info_tbl: [(cbODI,
                       label: Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbODI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbODM; else goto cbODL;
       cbODM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbODL: // global
           I64[Hp - 16] = sat_sbNGJ_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Arrow.$fApplicativeArrowMonad_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.300532091 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad1_closure" {
     Control.Arrow.$fAlternativeArrowMonad1_closure:
         const Control.Arrow.$fAlternativeArrowMonad1_info;
 },
 Control.Arrow.$fAlternativeArrowMonad1_entry() //  []
         { info_tbl: [(cbODR,
                       label: Control.Arrow.$fAlternativeArrowMonad1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbODR: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.302613909 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_$csome_closure" {
     Control.Arrow.$fAlternativeArrowMonad_$csome_closure:
         const Control.Arrow.$fAlternativeArrowMonad_$csome_info;
 },
 sat_sbNGV_entry() //  [R1]
         { info_tbl: [(cbOEm,
                       label: sat_sbNGV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOEm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOEn; else goto cbOEo;
       cbOEn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOEo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fAlternativeArrowMonad1_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNGW_entry() //  [R1]
         { info_tbl: [(cbOEp,
                       label: sat_sbNGW_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOEp: // global
           _sbNGW::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbOEq; else goto cbOEr;
       cbOEr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOEt; else goto cbOEs;
       cbOEt: // global
           HpAlloc = 24;
           goto cbOEq;
       cbOEq: // global
           R1 = _sbNGW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOEs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNGW::P64;
           _sbNGL::P64 = P64[_sbNGW::P64 + 16];
           _sbNGN::P64 = P64[_sbNGW::P64 + 24];
           _sbNGP::P64 = P64[_sbNGW::P64 + 32];
           I64[Hp - 16] = sat_sbNGV_info;
           P64[Hp] = _sbNGP::P64;
           R2 = _sbNGL::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbNGN::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call Control.Arrow.<+>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNGT_entry() //  [R1]
         { info_tbl: [(cbOEC,
                       label: sat_sbNGT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOEC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOED; else goto cbOEE;
       cbOED: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOEE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNGU_entry() //  [R1]
         { info_tbl: [(cbOEH,
                       label: sat_sbNGU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOEH: // global
           _sbNGU::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbOEI; else goto cbOEJ;
       cbOEJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOEL; else goto cbOEK;
       cbOEL: // global
           HpAlloc = 24;
           goto cbOEI;
       cbOEI: // global
           R1 = _sbNGU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOEK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNGU::P64;
           _sbNGM::P64 = P64[_sbNGU::P64 + 16];
           _sbNGP::P64 = P64[_sbNGU::P64 + 24];
           I64[Hp - 16] = sat_sbNGT_info;
           P64[Hp] = _sbNGP::P64;
           I64[Sp - 40] = block_cbOEF_info;
           R2 = _sbNGP::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbNGM::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbOEF() //  [R1]
         { info_tbl: [(cbOEF,
                       label: block_cbOEF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOEF: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNGX_entry() //  [R1]
         { info_tbl: [(cbOEP,
                       label: sat_sbNGX_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOEP: // global
           _sbNGX::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbOEQ; else goto cbOER;
       cbOER: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbOET; else goto cbOES;
       cbOET: // global
           HpAlloc = 72;
           goto cbOEQ;
       cbOEQ: // global
           R1 = _sbNGX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOES: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNGX::P64;
           _sbNGL::P64 = P64[_sbNGX::P64 + 16];
           _sbNGM::P64 = P64[_sbNGX::P64 + 24];
           _sbNGN::P64 = P64[_sbNGX::P64 + 32];
           _sbNGP::P64 = P64[_sbNGX::P64 + 40];
           I64[Hp - 64] = sat_sbNGW_info;
           P64[Hp - 48] = _sbNGL::P64;
           P64[Hp - 40] = _sbNGN::P64;
           P64[Hp - 32] = _sbNGP::P64;
           I64[Hp - 24] = sat_sbNGU_info;
           P64[Hp - 8] = _sbNGM::P64;
           P64[Hp] = _sbNGP::P64;
           R2 = _sbNGP::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 64;
           Sp = Sp - 40;
           call Control.Arrow.&&&_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNGR_entry() //  [R1]
         { info_tbl: [(cbOEY,
                       label: sat_sbNGR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOEY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOEZ; else goto cbOF0;
       cbOEZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOF0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fAlternativeArrowMonad_$capp_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 some_v_sbNGN_entry() //  [R1]
         { info_tbl: [(cbOF1,
                       label: some_v_sbNGN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOF1: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbOF3; else goto cbOF4;
       cbOF3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOF4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cbOE2_info;
           _sbNGL::P64 = P64[R1 + 16];
           R2 = _sbNGL::P64;
           P64[Sp - 40] = _sbNGL::P64;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = R1;
           Sp = Sp - 48;
           call Control.Arrow.$p1ArrowPlus_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbOE2() //  [R1]
         { info_tbl: [(cbOE2,
                       label: block_cbOE2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOE2: // global
           I64[Sp] = block_cbOE6_info;
           R2 = R1;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbOE6() //  [R1]
         { info_tbl: [(cbOE6,
                       label: block_cbOE6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOE6: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbOF8; else goto cbOF7;
       cbOF8: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbOF7: // global
           I64[Hp - 64] = sat_sbNGX_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbNGR_info;
           P64[Hp] = R1;
           I64[Sp + 8] = block_cbOF2_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 24] = Hp - 64;
           Sp = Sp + 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbOF2() //  [R1]
         { info_tbl: [(cbOF2,
                       label: block_cbOF2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOF2: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad_$csome_entry() //  [R2, R3]
         { info_tbl: [(cbOFd,
                       label: Control.Arrow.$fAlternativeArrowMonad_$csome_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOFd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOFh; else goto cbOFg;
       cbOFh: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_$csome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOFg: // global
           I64[Hp - 24] = some_v_sbNGN_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.307534551 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_$cmany_closure" {
     Control.Arrow.$fAlternativeArrowMonad_$cmany_closure:
         const Control.Arrow.$fAlternativeArrowMonad_$cmany_info;
 },
 $dApplicative_sbNH1_entry() //  [R1]
         { info_tbl: [(cbOFu,
                       label: $dApplicative_sbNH1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOFu: // global
           R2 = P64[R1 + 16];
           call Control.Arrow.$p1ArrowPlus_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dApplicative1_sbNH2_entry() //  [R1]
         { info_tbl: [(cbOFB,
                       label: $dApplicative1_sbNH2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOFB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOFC; else goto cbOFD;
       cbOFC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOFD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNH7_entry() //  [R1]
         { info_tbl: [(cbOFI,
                       label: sat_sbNH7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOFI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOFJ; else goto cbOFK;
       cbOFJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOFK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fAlternativeArrowMonad1_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNH4_entry() //  [R1]
         { info_tbl: [(cbOFX,
                       label: sat_sbNH4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOFX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOFY; else goto cbOFZ;
       cbOFY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOFZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNH5_entry() //  [R1]
         { info_tbl: [(cbOG2,
                       label: sat_sbNH5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOG2: // global
           _sbNH5::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbOG3; else goto cbOG4;
       cbOG4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOG6; else goto cbOG5;
       cbOG6: // global
           HpAlloc = 24;
           goto cbOG3;
       cbOG3: // global
           R1 = _sbNH5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOG5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNH5::P64;
           _sbNGZ::P64 = P64[_sbNH5::P64 + 16];
           _sbNH2::P64 = P64[_sbNH5::P64 + 24];
           I64[Hp - 16] = sat_sbNH4_info;
           P64[Hp] = _sbNH2::P64;
           I64[Sp - 40] = block_cbOG0_info;
           R2 = _sbNH2::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbNGZ::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbOG0() //  [R1]
         { info_tbl: [(cbOG0,
                       label: block_cbOG0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOG0: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNH6_entry() //  [R1]
         { info_tbl: [(cbOGa,
                       label: sat_sbNH6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOGa: // global
           _sbNH6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOGb; else goto cbOGc;
       cbOGc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOGe; else goto cbOGd;
       cbOGe: // global
           HpAlloc = 32;
           goto cbOGb;
       cbOGb: // global
           R1 = _sbNH6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOGd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNH6::P64;
           _sbNGZ::P64 = P64[_sbNH6::P64 + 16];
           _sbNH0::P64 = P64[_sbNH6::P64 + 24];
           _sbNH2::P64 = P64[_sbNH6::P64 + 32];
           I64[Hp - 24] = sat_sbNH5_info;
           P64[Hp - 8] = _sbNGZ::P64;
           P64[Hp] = _sbNH2::P64;
           R4 = _sbNH0::P64;
           R3 = Hp - 24;
           R2 = _sbNH2::P64;
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad2_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 many_v_sbNH0_entry() //  [R1]
         { info_tbl: [(cbOGf,
                       label: many_v_sbNH0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOGf: // global
           _sbNH0::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbOGg; else goto cbOGh;
       cbOGh: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cbOGj; else goto cbOGi;
       cbOGj: // global
           HpAlloc = 112;
           goto cbOGg;
       cbOGg: // global
           R1 = _sbNH0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOGi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNH0::P64;
           _sbNGY::P64 = P64[_sbNH0::P64 + 16];
           _sbNGZ::P64 = P64[_sbNH0::P64 + 24];
           I64[Hp - 104] = $dApplicative_sbNH1_info;
           P64[Hp - 88] = _sbNGY::P64;
           I64[Hp - 80] = $dApplicative1_sbNH2_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = sat_sbNH7_info;
           _cbOFx::P64 = Hp - 80;
           P64[Hp - 40] = _cbOFx::P64;
           I64[Hp - 32] = sat_sbNH6_info;
           P64[Hp - 16] = _sbNGZ::P64;
           P64[Hp - 8] = _sbNH0::P64;
           P64[Hp] = _cbOFx::P64;
           R2 = _sbNGY::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call Control.Arrow.<+>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad_$cmany_entry() //  [R2, R3]
         { info_tbl: [(cbOGk,
                       label: Control.Arrow.$fAlternativeArrowMonad_$cmany_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOGk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOGo; else goto cbOGn;
       cbOGo: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_$cmany_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOGn: // global
           I64[Hp - 24] = many_v_sbNH0_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.311196844 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_closure" {
     Control.Arrow.$fAlternativeArrowMonad_closure:
         const Control.Arrow.$fAlternativeArrowMonad_info;
 },
 sat_sbNHf_entry() //  [R1, R2]
         { info_tbl: [(cbOGy,
                       label: sat_sbNHf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOGy: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fAlternativeArrowMonad_$cmany_entry(R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNHe_entry() //  [R1, R2]
         { info_tbl: [(cbOGG,
                       label: sat_sbNHe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOGG: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fAlternativeArrowMonad_$csome_entry(R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNHd_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOGO,
                       label: sat_sbNHd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOGO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbOGP; else goto cbOGQ;
       cbOGP: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOGQ: // global
           _sbNHb::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbNHb::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Control.Arrow.<+>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbNHa_entry() //  [R1]
         { info_tbl: [(cbOGV,
                       label: sat_sbNHa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOGV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOGW; else goto cbOGX;
       cbOGW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOGX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad3_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNH9_entry() //  [R1]
         { info_tbl: [(cbOH2,
                       label: sat_sbNH9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOH2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOH3; else goto cbOH4;
       cbOH3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOH4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad_entry() //  [R2]
         { info_tbl: [(cbOH6,
                       label: Control.Arrow.$fAlternativeArrowMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOH6: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cbOHa; else goto cbOH9;
       cbOHa: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOH9: // global
           I64[Hp - 136] = sat_sbNHf_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbNHe_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbNHd_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbNHa_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbNH9_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 102;
           P64[Hp - 8] = Hp - 119;
           P64[Hp] = Hp - 135;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.315830784 UTC

[section ""data" . Control.Arrow.$fMonadPlusArrowMonad_closure" {
     Control.Arrow.$fMonadPlusArrowMonad_closure:
         const Control.Arrow.$fMonadPlusArrowMonad_info;
         const 0;
 },
 sat_sbNHn_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOHk,
                       label: sat_sbNHn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOHk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbOHl; else goto cbOHm;
       cbOHl: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOHm: // global
           _sbNHl::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbNHl::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Control.Arrow.<+>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbNHk_entry() //  [R1]
         { info_tbl: [(cbOHr,
                       label: sat_sbNHk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOHr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOHs; else goto cbOHt;
       cbOHs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOHt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad3_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNHj_entry() //  [R1]
         { info_tbl: [(cbOHy,
                       label: sat_sbNHj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOHy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOHz; else goto cbOHA;
       cbOHz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOHA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fMonadArrowMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNHi_entry() //  [R1]
         { info_tbl: [(cbOHF,
                       label: sat_sbNHi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOHF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOHG; else goto cbOHH;
       cbOHG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOHH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fMonadPlusArrowMonad_entry() //  [R2, R3]
         { info_tbl: [(cbOHJ,
                       label: Control.Arrow.$fMonadPlusArrowMonad_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOHJ: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cbOHN; else goto cbOHM;
       cbOHN: // global
           HpAlloc = 128;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fMonadPlusArrowMonad_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOHM: // global
           I64[Hp - 120] = sat_sbNHn_info;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = sat_sbNHk_info;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sbNHj_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbNHi_info;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = GHC.Base.C:MonadPlus_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 118;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.318068288 UTC

[section ""data" . Control.Arrow.$fArrowLoop(->)_$cloop_closure" {
     Control.Arrow.$fArrowLoop(->)_$cloop_closure:
         const Control.Arrow.$fArrowLoop(->)_$cloop_info;
 },
 ds_sbNHq_entry() //  [R1]
         { info_tbl: [(cbOHY,
                       label: ds_sbNHq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOHY: // global
           _sbNHq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOHZ; else goto cbOI0;
       cbOI0: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbOI2; else goto cbOI1;
       cbOI2: // global
           HpAlloc = 48;
           goto cbOHZ;
       cbOHZ: // global
           R1 = _sbNHq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOI1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNHq::P64;
           _sbNHo::P64 = P64[_sbNHq::P64 + 16];
           _sbNHp::P64 = P64[_sbNHq::P64 + 24];
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sbNHq::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbNHp::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 15;
           R1 = _sbNHo::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowLoop(->)_$cloop_entry() //  [R2, R3]
         { info_tbl: [(cbOI6,
                       label: Control.Arrow.$fArrowLoop(->)_$cloop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOI6: // global
           _sbNHp::P64 = R3;
           _sbNHo::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cbOI7; else goto cbOI8;
       cbOI8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOIa; else goto cbOI9;
       cbOIa: // global
           HpAlloc = 32;
           goto cbOI7;
       cbOI7: // global
           R3 = _sbNHp::P64;
           R2 = _sbNHo::P64;
           R1 = Control.Arrow.$fArrowLoop(->)_$cloop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOI9: // global
           I64[Hp - 24] = ds_sbNHq_info;
           P64[Hp - 8] = _sbNHo::P64;
           P64[Hp] = _sbNHp::P64;
           I64[Sp - 8] = block_cbOI3_info;
           R1 = Hp - 24;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOIe; else goto cbOI4;
       ubOIe: // global
           call _cbOI3(R1) args: 0, res: 0, upd: 0;
       cbOI4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOI3() //  [R1]
         { info_tbl: [(cbOI3,
                       label: block_cbOI3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOI3: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.320371098 UTC

[section ""data" . Control.Arrow.$fArrowLoopKleisli1_closure" {
     Control.Arrow.$fArrowLoopKleisli1_closure:
         const Control.Arrow.$fArrowLoopKleisli1_info;
 },
 sat_sbNHN_entry() //  [R1, R2]
         { info_tbl: [(cbOIt,
                       label: sat_sbNHN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOIt: // global
           _sbNHI::P64 = R2;
           _sbNHN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOIu; else goto cbOIv;
       cbOIv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOIx; else goto cbOIw;
       cbOIx: // global
           HpAlloc = 24;
           goto cbOIu;
       cbOIu: // global
           R2 = _sbNHI::P64;
           R1 = _sbNHN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOIw: // global
           _sbNHC::P64 = P64[_sbNHN::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbNHI::P64;
           R2 = _sbNHC::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbNHE_entry() //  [R1]
         { info_tbl: [(cbOIL,
                       label: sat_sbNHE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOIL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOIM; else goto cbOIN;
       cbOIM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOIN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Tuple.snd_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNHG_entry() //  [R1, R2]
         { info_tbl: [(cbOIP,
                       label: sat_sbNHG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOIP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbOIT; else goto cbOIS;
       cbOIT: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOIS: // global
           _sbNHA::P64 = P64[R1 + 7];
           _sbNHB::P64 = P64[R1 + 15];
           I64[Hp - 40] = sat_sbNHE_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbNHB::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 15;
           R1 = _sbNHA::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNHH_entry() //  [R1]
         { info_tbl: [(cbOIU,
                       label: sat_sbNHH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOIU: // global
           _sbNHH::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbOIV; else goto cbOIW;
       cbOIW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOIY; else goto cbOIX;
       cbOIY: // global
           HpAlloc = 24;
           goto cbOIV;
       cbOIV: // global
           R1 = _sbNHH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOIX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNHH::P64;
           _sbNHz::P64 = P64[_sbNHH::P64 + 16];
           _sbNHA::P64 = P64[_sbNHH::P64 + 24];
           _sbNHB::P64 = P64[_sbNHH::P64 + 32];
           I64[Hp - 16] = sat_sbNHG_info;
           P64[Hp - 8] = _sbNHA::P64;
           P64[Hp] = _sbNHB::P64;
           R2 = _sbNHz::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowLoopKleisli1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOIZ,
                       label: Control.Arrow.$fArrowLoopKleisli1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOIZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOJ0; else goto cbOJ1;
       cbOJ0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fArrowLoopKleisli1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOJ1: // global
           I64[Sp - 32] = block_cbOIj_info;
           _sbNHz::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbNHz::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOIj() //  [R1]
         { info_tbl: [(cbOIj,
                       label: block_cbOIj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOIj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbOJ4; else goto cbOJ3;
       cbOJ4: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOJ3: // global
           I64[Hp - 48] = sat_sbNHN_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sbNHH_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 32;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp + 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.322957238 UTC

[section ""data" . lvl1_rbNC7_closure" {
     lvl1_rbNC7_closure:
         const lvl1_rbNC7_info;
 },
 lvl1_rbNC7_entry() //  [R2]
         { info_tbl: [(cbOJg,
                       label: lvl1_rbNC7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOJg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOJh; else goto cbOJi;
       cbOJh: // global
           R2 = R2;
           R1 = lvl1_rbNC7_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOJi: // global
           I64[Sp - 8] = block_cbOJ9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOJp; else goto cbOJa;
       ubOJp: // global
           call _cbOJ9(R1) args: 0, res: 0, upd: 0;
       cbOJa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOJ9() //  [R1]
         { info_tbl: [(cbOJ9,
                       label: block_cbOJ9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOJ9: // global
           if (R1 & 7 == 1) goto cbOJd; else goto cbOJe;
       cbOJd: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbOJe: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.324495662 UTC

[section ""data" . Control.Arrow.$dm|||_closure" {
     Control.Arrow.$dm|||_closure:
         const Control.Arrow.$dm|||_info;
 },
 sat_sbNHY_entry() //  [R1]
         { info_tbl: [(cbOJC,
                       label: sat_sbNHY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOJC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbOJD; else goto cbOJE;
       cbOJD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOJE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Arrow.+++_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNHX_entry() //  [R1]
         { info_tbl: [(cbOJJ,
                       label: sat_sbNHX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOJJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOJK; else goto cbOJL;
       cbOJK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOJL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl1_rbNC7_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dm|||_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOJM,
                       label: Control.Arrow.$dm|||_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOJM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOJO; else goto cbOJP;
       cbOJO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$dm|||_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOJP: // global
           I64[Sp - 32] = block_cbOJu_info;
           _sbNHS::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbNHS::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Arrow.$p1ArrowChoice_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOJu() //  [R1]
         { info_tbl: [(cbOJu,
                       label: block_cbOJu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOJu: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbOJS; else goto cbOJR;
       cbOJS: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOJR: // global
           I64[Hp - 56] = sat_sbNHY_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           I64[Hp - 16] = sat_sbNHX_info;
           P64[Hp] = R1;
           I64[Sp + 8] = block_cbOJN_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 24] = Hp - 56;
           Sp = Sp + 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOJN() //  [R1]
         { info_tbl: [(cbOJN,
                       label: block_cbOJN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOJN: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.326561531 UTC

[section ""data" . mirror_rbNC8_closure" {
     mirror_rbNC8_closure:
         const mirror_rbNC8_info;
 },
 mirror_rbNC8_entry() //  [R2]
         { info_tbl: [(cbOK8,
                       label: mirror_rbNC8_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOK8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOK9; else goto cbOKa;
       cbOK9: // global
           R2 = R2;
           R1 = mirror_rbNC8_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOKa: // global
           I64[Sp - 8] = block_cbOK1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubOKn; else goto cbOK2;
       ubOKn: // global
           call _cbOK1(R1) args: 0, res: 0, upd: 0;
       cbOK2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOK1() //  [R1]
         { info_tbl: [(cbOK1,
                       label: block_cbOK1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOK1: // global
           if (R1 & 7 == 1) goto cbOK5; else goto cbOK6;
       cbOK5: // global
           Hp = Hp + 16;
           _sbNI0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbOKm; else goto cbOKf;
       cbOKf: // global
           _sbNI1::P64 = P64[_sbNI0::P64 + 7];
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = _sbNI1::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbOK6: // global
           Hp = Hp + 16;
           _sbNI0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbOKm; else goto cbOKl;
       cbOKm: // global
           HpAlloc = 16;
           R1 = _sbNI0::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOKl: // global
           _sbNI2::P64 = P64[_sbNI0::P64 + 6];
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = _sbNI2::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.328862172 UTC

[section ""data" . Control.Arrow.$dm+++_closure" {
     Control.Arrow.$dm+++_closure:
         const Control.Arrow.$dm+++_info;
 },
 sat_sbNIb_entry() //  [R1]
         { info_tbl: [(cbOKM,
                       label: sat_sbNIb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOKM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOKN; else goto cbOKO;
       cbOKN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOKO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.left_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNIa_entry() //  [R1]
         { info_tbl: [(cbOKT,
                       label: sat_sbNIa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOKT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOKU; else goto cbOKV;
       cbOKU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOKV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = mirror_rbNC8_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNIc_entry() //  [R1]
         { info_tbl: [(cbOKW,
                       label: sat_sbNIc_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOKW: // global
           _sbNIc::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbOKX; else goto cbOKY;
       cbOKY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbOL0; else goto cbOKZ;
       cbOL0: // global
           HpAlloc = 56;
           goto cbOKX;
       cbOKX: // global
           R1 = _sbNIc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOKZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNIc::P64;
           _sbNI3::P64 = P64[_sbNIc::P64 + 16];
           _sbNI4::P64 = P64[_sbNIc::P64 + 24];
           _sbNI6::P64 = P64[_sbNIc::P64 + 32];
           _sbNI7::P64 = P64[_sbNIc::P64 + 40];
           I64[Hp - 48] = sat_sbNIb_info;
           P64[Hp - 32] = _sbNI3::P64;
           P64[Hp - 24] = _sbNI4::P64;
           I64[Hp - 16] = sat_sbNIa_info;
           P64[Hp] = _sbNI6::P64;
           R2 = _sbNI7::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNI9_entry() //  [R1]
         { info_tbl: [(cbOL5,
                       label: sat_sbNI9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOL5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOL6; else goto cbOL7;
       cbOL6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOL7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.left_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNId_entry() //  [R1]
         { info_tbl: [(cbOL8,
                       label: sat_sbNId_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOL8: // global
           _sbNId::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbOL9; else goto cbOLa;
       cbOLa: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbOLc; else goto cbOLb;
       cbOLc: // global
           HpAlloc = 80;
           goto cbOL9;
       cbOL9: // global
           R1 = _sbNId::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOLb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNId::P64;
           _sbNI3::P64 = P64[_sbNId::P64 + 16];
           _sbNI4::P64 = P64[_sbNId::P64 + 24];
           _sbNI5::P64 = P64[_sbNId::P64 + 32];
           _sbNI6::P64 = P64[_sbNId::P64 + 40];
           _sbNI7::P64 = P64[_sbNId::P64 + 48];
           I64[Hp - 72] = sat_sbNIc_info;
           P64[Hp - 56] = _sbNI3::P64;
           P64[Hp - 48] = _sbNI4::P64;
           P64[Hp - 40] = _sbNI6::P64;
           P64[Hp - 32] = _sbNI7::P64;
           I64[Hp - 24] = sat_sbNI9_info;
           P64[Hp - 8] = _sbNI3::P64;
           P64[Hp] = _sbNI5::P64;
           R2 = _sbNI7::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNI8_entry() //  [R1]
         { info_tbl: [(cbOLh,
                       label: sat_sbNI8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOLh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOLi; else goto cbOLj;
       cbOLi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOLj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = mirror_rbNC8_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dm+++_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOLk,
                       label: Control.Arrow.$dm+++_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOLk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbOLl; else goto cbOLm;
       cbOLl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$dm+++_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOLm: // global
           I64[Sp - 32] = block_cbOKs_info;
           _sbNI3::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbNI3::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Arrow.$p1ArrowChoice_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOKs() //  [R1]
         { info_tbl: [(cbOKs,
                       label: block_cbOKs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOKs: // global
           I64[Sp - 8] = block_cbOKw_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOKw() //  [R1]
         { info_tbl: [(cbOKw,
                       label: block_cbOKw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOKw: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbOLq; else goto cbOLp;
       cbOLq: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOLp: // global
           I64[Hp - 72] = sat_sbNId_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 32];
           _sbNI6::P64 = P64[Sp + 8];
           P64[Hp - 32] = _sbNI6::P64;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbNI8_info;
           P64[Hp] = _sbNI6::P64;
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 16;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.332618935 UTC

[section ""data" . Control.Arrow.$dmright_closure" {
     Control.Arrow.$dmright_closure:
         const Control.Arrow.$dmright_info;
 },
 sat_sbNIh_entry() //  [R1]
         { info_tbl: [(cbOLB,
                       label: sat_sbNIh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOLB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbOLF; else goto cbOLG;
       cbOLF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOLG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbOLz_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1ArrowChoice_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbOLz() //  [R1]
         { info_tbl: [(cbOLz,
                       label: block_cbOLz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOLz: // global
           I64[Sp] = block_cbOLE_info;
           R2 = R1;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbOLE() //  [R1]
         { info_tbl: [(cbOLE,
                       label: block_cbOLE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOLE: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Category.id_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dmright_entry() //  [R2]
         { info_tbl: [(cbOLM,
                       label: Control.Arrow.$dmright_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOLM: // global
           _sbNIe::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOLN; else goto cbOLO;
       cbOLO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOLQ; else goto cbOLP;
       cbOLQ: // global
           HpAlloc = 24;
           goto cbOLN;
       cbOLN: // global
           R2 = _sbNIe::P64;
           R1 = Control.Arrow.$dmright_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOLP: // global
           I64[Hp - 16] = sat_sbNIh_info;
           P64[Hp] = _sbNIe::P64;
           R2 = _sbNIe::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Control.Arrow.+++_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.334263349 UTC

[section ""data" . Control.Arrow.$dmleft_closure" {
     Control.Arrow.$dmleft_closure:
         const Control.Arrow.$dmleft_info;
 },
 sat_sbNIm_entry() //  [R1]
         { info_tbl: [(cbOM1,
                       label: sat_sbNIm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOM1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbOM5; else goto cbOM6;
       cbOM5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOM6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbOLZ_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1ArrowChoice_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbOLZ() //  [R1]
         { info_tbl: [(cbOLZ,
                       label: block_cbOLZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOLZ: // global
           I64[Sp] = block_cbOM4_info;
           R2 = R1;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbOM4() //  [R1]
         { info_tbl: [(cbOM4,
                       label: block_cbOM4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOM4: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Category.id_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dmleft_entry() //  [R2, R3]
         { info_tbl: [(cbOMc,
                       label: Control.Arrow.$dmleft_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOMc: // global
           _sbNIj::P64 = R3;
           _sbNIi::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOMd; else goto cbOMe;
       cbOMe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOMg; else goto cbOMf;
       cbOMg: // global
           HpAlloc = 24;
           goto cbOMd;
       cbOMd: // global
           R3 = _sbNIj::P64;
           R2 = _sbNIi::P64;
           R1 = Control.Arrow.$dmleft_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOMf: // global
           I64[Hp - 16] = sat_sbNIm_info;
           P64[Hp] = _sbNIi::P64;
           R2 = _sbNIi::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbNIj::P64;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Control.Arrow.+++_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.335742726 UTC

[section ""data" . lvl2_rbNC9_closure" {
     lvl2_rbNC9_closure:
         const lvl2_rbNC9_info;
 },
 lvl2_rbNC9_entry() //  [R2]
         { info_tbl: [(cbOMm,
                       label: lvl2_rbNC9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOMm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOMq; else goto cbOMp;
       cbOMq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = lvl2_rbNC9_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOMp: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.337011299 UTC

[section ""data" . Control.Arrow.$dm&&&_closure" {
     Control.Arrow.$dm&&&_closure:
         const Control.Arrow.$dm&&&_info;
 },
 sat_sbNIt_entry() //  [R1]
         { info_tbl: [(cbOMz,
                       label: sat_sbNIt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOMz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOMA; else goto cbOMB;
       cbOMA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOMB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl2_rbNC9_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNIs_entry() //  [R1]
         { info_tbl: [(cbOMG,
                       label: sat_sbNIs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOMG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbOMH; else goto cbOMI;
       cbOMH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOMI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Arrow.***_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dm&&&_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOML,
                       label: Control.Arrow.$dm&&&_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOML: // global
           _sbNIq::P64 = R4;
           _sbNIp::P64 = R3;
           _sbNIo::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOMM; else goto cbOMN;
       cbOMN: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbOMP; else goto cbOMO;
       cbOMP: // global
           HpAlloc = 64;
           goto cbOMM;
       cbOMM: // global
           R4 = _sbNIq::P64;
           R3 = _sbNIp::P64;
           R2 = _sbNIo::P64;
           R1 = Control.Arrow.$dm&&&_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOMO: // global
           I64[Hp - 56] = sat_sbNIt_info;
           P64[Hp - 40] = _sbNIo::P64;
           I64[Hp - 32] = sat_sbNIs_info;
           P64[Hp - 16] = _sbNIo::P64;
           P64[Hp - 8] = _sbNIp::P64;
           P64[Hp] = _sbNIq::P64;
           I64[Sp - 24] = block_cbOMJ_info;
           R2 = _sbNIo::P64;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOMJ() //  [R1]
         { info_tbl: [(cbOMJ,
                       label: block_cbOMJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOMJ: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbOMv::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbOMv::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.338840819 UTC

[section ""data" . swap_rbNCa_closure" {
     swap_rbNCa_closure:
         const swap_rbNCa_info;
 },
 swap_rbNCa_entry() //  [R2]
         { info_tbl: [(cbON0,
                       label: swap_rbNCa_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbON0: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbON4; else goto cbON3;
       cbON4: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = swap_rbNCa_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbON3: // global
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.340799836 UTC

[section ""data" . Control.Arrow.$dm***_closure" {
     Control.Arrow.$dm***_closure:
         const Control.Arrow.$dm***_info;
 },
 sat_sbNIK_entry() //  [R1]
         { info_tbl: [(cbONp,
                       label: sat_sbNIK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbONp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbONq; else goto cbONr;
       cbONq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbONr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.first_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNIJ_entry() //  [R1]
         { info_tbl: [(cbONw,
                       label: sat_sbNIJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbONw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbONx; else goto cbONy;
       cbONx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbONy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = swap_rbNCa_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNIL_entry() //  [R1]
         { info_tbl: [(cbONz,
                       label: sat_sbNIL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbONz: // global
           _sbNIL::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbONA; else goto cbONB;
       cbONB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbOND; else goto cbONC;
       cbOND: // global
           HpAlloc = 56;
           goto cbONA;
       cbONA: // global
           R1 = _sbNIL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbONC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNIL::P64;
           _sbNID::P64 = P64[_sbNIL::P64 + 16];
           _sbNIE::P64 = P64[_sbNIL::P64 + 24];
           _sbNIG::P64 = P64[_sbNIL::P64 + 32];
           I64[Hp - 48] = sat_sbNIK_info;
           P64[Hp - 32] = _sbNID::P64;
           P64[Hp - 24] = _sbNIE::P64;
           I64[Hp - 16] = sat_sbNIJ_info;
           P64[Hp] = _sbNID::P64;
           R2 = _sbNIG::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNII_entry() //  [R1]
         { info_tbl: [(cbONI,
                       label: sat_sbNII_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbONI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbONJ; else goto cbONK;
       cbONJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbONK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.first_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNIM_entry() //  [R1]
         { info_tbl: [(cbONL,
                       label: sat_sbNIM_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbONL: // global
           _sbNIM::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbONM; else goto cbONN;
       cbONN: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbONP; else goto cbONO;
       cbONP: // global
           HpAlloc = 72;
           goto cbONM;
       cbONM: // global
           R1 = _sbNIM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbONO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNIM::P64;
           _sbNID::P64 = P64[_sbNIM::P64 + 16];
           _sbNIE::P64 = P64[_sbNIM::P64 + 24];
           _sbNIF::P64 = P64[_sbNIM::P64 + 32];
           _sbNIG::P64 = P64[_sbNIM::P64 + 40];
           I64[Hp - 64] = sat_sbNIL_info;
           P64[Hp - 48] = _sbNID::P64;
           P64[Hp - 40] = _sbNIE::P64;
           P64[Hp - 32] = _sbNIG::P64;
           I64[Hp - 24] = sat_sbNII_info;
           P64[Hp - 8] = _sbNID::P64;
           P64[Hp] = _sbNIF::P64;
           R2 = _sbNIG::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 64;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNIH_entry() //  [R1]
         { info_tbl: [(cbONU,
                       label: sat_sbNIH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbONU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbONV; else goto cbONW;
       cbONV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbONW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = swap_rbNCa_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dm***_entry() //  [R2, R3, R4]
         { info_tbl: [(cbONX,
                       label: Control.Arrow.$dm***_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbONX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbONY; else goto cbONZ;
       cbONY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$dm***_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbONZ: // global
           I64[Sp - 32] = block_cbON9_info;
           _sbNID::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbNID::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbON9() //  [R1]
         { info_tbl: [(cbON9,
                       label: block_cbON9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbON9: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbOO2; else goto cbOO1;
       cbOO2: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOO1: // global
           I64[Hp - 64] = sat_sbNIM_info;
           _sbNID::P64 = P64[Sp + 8];
           P64[Hp - 48] = _sbNID::P64;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbNIH_info;
           P64[Hp] = _sbNID::P64;
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 24] = Hp - 64;
           Sp = Sp + 8;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.344839866 UTC

[section ""data" . Control.Arrow.$fArrowKleisli2_closure" {
     Control.Arrow.$fArrowKleisli2_closure:
         const Control.Arrow.$fArrowKleisli2_info;
 },
 sat_sbNJg_entry() //  [R1, R2]
         { info_tbl: [(cbOOf,
                       label: sat_sbNJg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOOf: // global
           _sbNJ6::P64 = R2;
           _sbNJg::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOOg; else goto cbOOh;
       cbOOh: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbOOj; else goto cbOOi;
       cbOOj: // global
           HpAlloc = 72;
           goto cbOOg;
       cbOOg: // global
           R2 = _sbNJ6::P64;
           R1 = _sbNJg::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOOi: // global
           _sbNIN::P64 = P64[_sbNJg::P64 + 7];
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sbNJ6::P64;
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sbNJ6::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = _sbNIN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbNJ4_entry() //  [R1, R2]
         { info_tbl: [(cbOOt,
                       label: sat_sbNJ4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOOt: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Arrow.$fArrowKleisli3_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJ2_entry() //  [R1, R2]
         { info_tbl: [(cbOOI,
                       label: sat_sbNJ2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOOI: // global
           _sbNIS::P64 = R2;
           _sbNJ2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOOJ; else goto cbOOK;
       cbOOK: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbOOM; else goto cbOOL;
       cbOOM: // global
           HpAlloc = 72;
           goto cbOOJ;
       cbOOJ: // global
           R2 = _sbNIS::P64;
           R1 = _sbNJ2::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOOL: // global
           _sbNIN::P64 = P64[_sbNJ2::P64 + 7];
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sbNIS::P64;
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sbNIS::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = _sbNIN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbNIR_entry() //  [R1]
         { info_tbl: [(cbOOR,
                       label: sat_sbNIR_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOOR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOOS; else goto cbOOT;
       cbOOS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOOT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowKleisli3_entry(R4,
                                                    R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNJ3_entry() //  [R1]
         { info_tbl: [(cbOOU,
                       label: sat_sbNJ3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOOU: // global
           _sbNJ3::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbOOV; else goto cbOOW;
       cbOOW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbOOY; else goto cbOOX;
       cbOOY: // global
           HpAlloc = 56;
           goto cbOOV;
       cbOOV: // global
           R1 = _sbNJ3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOOX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNJ3::P64;
           _sbNIN::P64 = P64[_sbNJ3::P64 + 16];
           _sbNIO::P64 = P64[_sbNJ3::P64 + 24];
           _sbNIQ::P64 = P64[_sbNJ3::P64 + 32];
           I64[Hp - 48] = sat_sbNJ2_info;
           P64[Hp - 40] = _sbNIN::P64;
           I64[Hp - 32] = sat_sbNIR_info;
           P64[Hp - 16] = _sbNIN::P64;
           P64[Hp - 8] = _sbNIO::P64;
           P64[Hp] = _sbNIQ::P64;
           R2 = _sbNIN::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 47;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNJ5_entry() //  [R1]
         { info_tbl: [(cbOOZ,
                       label: sat_sbNJ5_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOOZ: // global
           _sbNJ5::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbOP0; else goto cbOP1;
       cbOP1: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbOP3; else goto cbOP2;
       cbOP3: // global
           HpAlloc = 64;
           goto cbOP0;
       cbOP0: // global
           R1 = _sbNJ5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOP2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNJ5::P64;
           _sbNIN::P64 = P64[_sbNJ5::P64 + 16];
           _sbNIO::P64 = P64[_sbNJ5::P64 + 24];
           _sbNIP::P64 = P64[_sbNJ5::P64 + 32];
           _sbNIQ::P64 = P64[_sbNJ5::P64 + 40];
           I64[Hp - 56] = sat_sbNJ4_info;
           P64[Hp - 48] = _sbNIN::P64;
           P64[Hp - 40] = _sbNIP::P64;
           I64[Hp - 32] = sat_sbNJ3_info;
           P64[Hp - 16] = _sbNIN::P64;
           P64[Hp - 8] = _sbNIO::P64;
           P64[Hp] = _sbNIQ::P64;
           R2 = _sbNIN::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbOP4,
                       label: Control.Arrow.$fArrowKleisli2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOP4: // global
           _sbNIQ::P64 = R5;
           _sbNIP::P64 = R4;
           _sbNIO::P64 = R3;
           _sbNIN::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOP5; else goto cbOP6;
       cbOP6: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbOP8; else goto cbOP7;
       cbOP8: // global
           HpAlloc = 64;
           goto cbOP5;
       cbOP5: // global
           R5 = _sbNIQ::P64;
           R4 = _sbNIP::P64;
           R3 = _sbNIO::P64;
           R2 = _sbNIN::P64;
           R1 = Control.Arrow.$fArrowKleisli2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOP7: // global
           I64[Hp - 56] = sat_sbNJg_info;
           P64[Hp - 48] = _sbNIN::P64;
           I64[Hp - 40] = sat_sbNJ5_info;
           P64[Hp - 24] = _sbNIN::P64;
           P64[Hp - 16] = _sbNIO::P64;
           P64[Hp - 8] = _sbNIP::P64;
           P64[Hp] = _sbNIQ::P64;
           R2 = _sbNIN::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 40;
           P64[Sp - 8] = Hp - 55;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.348327853 UTC

[section ""data" . Control.Arrow.$fArrowKleisli1_closure" {
     Control.Arrow.$fArrowKleisli1_closure:
         const Control.Arrow.$fArrowKleisli1_info;
 },
 sat_sbNJn_entry() //  [R1, R2]
         { info_tbl: [(cbOPi,
                       label: sat_sbNJn_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOPi: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Arrow.$fArrowKleisli2_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJm_entry() //  [R1]
         { info_tbl: [(cbOPq,
                       label: sat_sbNJm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOPq: // global
           _sbNJm::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbOPr; else goto cbOPs;
       cbOPs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOPu; else goto cbOPt;
       cbOPu: // global
           HpAlloc = 24;
           goto cbOPr;
       cbOPr: // global
           R1 = _sbNJm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOPt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNJm::P64;
           _sbNJh::P64 = P64[_sbNJm::P64 + 16];
           _sbNJk::P64 = P64[_sbNJm::P64 + 24];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbNJk::P64;
           P64[Hp] = _sbNJk::P64;
           R2 = _sbNJh::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbOPv,
                       label: Control.Arrow.$fArrowKleisli1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOPv: // global
           _sbNJk::P64 = R5;
           _sbNJj::P64 = R4;
           _sbNJi::P64 = R3;
           _sbNJh::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOPw; else goto cbOPx;
       cbOPx: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbOPz; else goto cbOPy;
       cbOPz: // global
           HpAlloc = 64;
           goto cbOPw;
       cbOPw: // global
           R5 = _sbNJk::P64;
           R4 = _sbNJj::P64;
           R3 = _sbNJi::P64;
           R2 = _sbNJh::P64;
           R1 = Control.Arrow.$fArrowKleisli1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOPy: // global
           I64[Hp - 56] = sat_sbNJn_info;
           P64[Hp - 48] = _sbNJh::P64;
           P64[Hp - 40] = _sbNJi::P64;
           P64[Hp - 32] = _sbNJj::P64;
           I64[Hp - 24] = sat_sbNJm_info;
           P64[Hp - 8] = _sbNJh::P64;
           P64[Hp] = _sbNJk::P64;
           R2 = _sbNJh::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 55;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.350780514 UTC

[section ""data" . Control.Arrow.$fArrowKleisli_closure" {
     Control.Arrow.$fArrowKleisli_closure:
         const Control.Arrow.$fArrowKleisli_info;
 },
 sat_sbNJu_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbOPJ,
                       label: sat_sbNJu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOPJ: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fArrowKleisli1_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJt_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbOPR,
                       label: sat_sbNJt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOPR: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fArrowKleisli2_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJs_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOPZ,
                       label: sat_sbNJs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOPZ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowKleisli4_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJr_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOQ7,
                       label: sat_sbNJr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOQ7: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowKleisli3_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJq_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOQf,
                       label: sat_sbNJq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOQf: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowKleisli5_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJp_entry() //  [R1]
         { info_tbl: [(cbOQm,
                       label: sat_sbNJp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOQm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOQn; else goto cbOQo;
       cbOQn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOQo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fCategoryTYPEKleisli_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli_entry() //  [R2]
         { info_tbl: [(cbOQq,
                       label: Control.Arrow.$fArrowKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOQq: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cbOQu; else goto cbOQt;
       cbOQu: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = Control.Arrow.$fArrowKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOQt: // global
           I64[Hp - 152] = sat_sbNJu_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbNJt_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbNJs_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbNJr_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbNJq_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbNJp_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = Control.Arrow.C:Arrow_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 86;
           P64[Hp - 24] = Hp - 102;
           P64[Hp - 16] = Hp - 118;
           P64[Hp - 8] = Hp - 133;
           P64[Hp] = Hp - 149;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.353034105 UTC

[section ""data" . Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_closure" {
     Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_closure:
         const Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_info;
 },
 sat_sbNJw_entry() //  [R1]
         { info_tbl: [(cbOQD,
                       label: sat_sbNJw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOQD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOQE; else goto cbOQF;
       cbOQE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOQF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_entry() //  [R2]
         { info_tbl: [(cbOQG,
                       label: Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOQG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOQK; else goto cbOQJ;
       cbOQK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOQJ: // global
           I64[Hp - 16] = sat_sbNJw_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Arrow.$fArrowKleisli_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.354704132 UTC

[section ""data" . Control.Arrow.$fArrowLoopKleisli_closure" {
     Control.Arrow.$fArrowLoopKleisli_closure:
         const Control.Arrow.$fArrowLoopKleisli_info;
 },
 sat_sbNJz_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOQU,
                       label: sat_sbNJz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOQU: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowLoopKleisli1_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJy_entry() //  [R1]
         { info_tbl: [(cbOR1,
                       label: sat_sbNJy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOR1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOR2; else goto cbOR3;
       cbOR2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOR3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowLoopKleisli_entry() //  [R2]
         { info_tbl: [(cbOR5,
                       label: Control.Arrow.$fArrowLoopKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOR5: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbOR9; else goto cbOR8;
       cbOR9: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Arrow.$fArrowLoopKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOR8: // global
           I64[Hp - 56] = sat_sbNJz_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbNJy_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Arrow.C:ArrowLoop_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 54;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.356123187 UTC

[section ""data" . lvl3_rbNCb_closure" {
     lvl3_rbNCb_closure:
         const lvl3_rbNCb_info;
 },
 lvl3_rbNCb_entry() //  [R2]
         { info_tbl: [(cbORh,
                       label: lvl3_rbNCb_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbORh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbORi; else goto cbORj;
       cbORi: // global
           R2 = R2;
           R1 = lvl3_rbNCb_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbORj: // global
           I64[Sp - 8] = block_cbORe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubORn; else goto cbORf;
       ubORn: // global
           call _cbORe(R1) args: 0, res: 0, upd: 0;
       cbORf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbORe() //  [R1]
         { info_tbl: [(cbORe,
                       label: block_cbORe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbORe: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.357372432 UTC

[section ""data" . Control.Arrow.$fArrowApplyKleisli_closure" {
     Control.Arrow.$fArrowApplyKleisli_closure:
         const Control.Arrow.$fArrowApplyKleisli_info;
 },
 sat_sbNJF_entry() //  [R1]
         { info_tbl: [(cbORw,
                       label: sat_sbNJF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbORw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbORx; else goto cbORy;
       cbORx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbORy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowKleisli_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowApplyKleisli_entry() //  [R2]
         { info_tbl: [(cbORA,
                       label: Control.Arrow.$fArrowApplyKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbORA: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbORE; else goto cbORD;
       cbORE: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Control.Arrow.$fArrowApplyKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbORD: // global
           I64[Hp - 40] = sat_sbNJF_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Arrow.C:ArrowApply_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = lvl3_rbNCb_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.359272298 UTC

[section ""data" . Control.Arrow.$fArrowChoiceKleisli1_closure" {
     Control.Arrow.$fArrowChoiceKleisli1_closure:
         const Control.Arrow.$fArrowChoiceKleisli1_info;
 },
 sat_sbNJP_entry() //  [R1, R2]
         { info_tbl: [(cbORU,
                       label: sat_sbNJP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbORU: // global
           _sbNJN::P64 = R2;
           _sbNJP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbORV; else goto cbORW;
       cbORW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbORY; else goto cbORX;
       cbORY: // global
           HpAlloc = 16;
           goto cbORV;
       cbORV: // global
           R2 = _sbNJN::P64;
           R1 = _sbNJP::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbORX: // global
           _sbNJG::P64 = P64[_sbNJP::P64 + 7];
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = _sbNJN::P64;
           R2 = _sbNJG::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbNJU_entry() //  [R1, R2]
         { info_tbl: [(cbOS7,
                       label: sat_sbNJU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOS7: // global
           _sbNJS::P64 = R2;
           _sbNJU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOS8; else goto cbOS9;
       cbOS9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbOSb; else goto cbOSa;
       cbOSb: // global
           HpAlloc = 16;
           goto cbOS8;
       cbOS8: // global
           R2 = _sbNJS::P64;
           R1 = _sbNJU::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOSa: // global
           _sbNJG::P64 = P64[_sbNJU::P64 + 7];
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = _sbNJS::P64;
           R2 = _sbNJG::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 6;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fArrowChoiceKleisli1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbOSg,
                       label: Control.Arrow.$fArrowChoiceKleisli1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOSg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOSh; else goto cbOSi;
       cbOSh: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fArrowChoiceKleisli1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOSi: // global
           I64[Sp - 32] = block_cbORJ_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubOSr; else goto cbORK;
       ubOSr: // global
           call _cbORJ(R1) args: 0, res: 0, upd: 0;
       cbORK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbORJ() //  [R1]
         { info_tbl: [(cbORJ,
                       label: block_cbORJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbORJ: // global
           _sbNJG::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbOSd; else goto cbOSe;
       cbOSd: // global
           Hp = Hp + 48;
           _sbNJK::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbOSo; else goto cbOSk;
       cbOSk: // global
           _sbNJL::P64 = P64[_sbNJK::P64 + 7];
           I64[Hp - 40] = sat_sbNJP_info;
           P64[Hp - 32] = _sbNJG::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbNJL::P64;
           R2 = _sbNJG::P64;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 24;
           P64[Sp + 24] = Hp - 39;
           Sp = Sp + 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
       cbOSe: // global
           Hp = Hp + 48;
           _sbNJK::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbOSo; else goto cbOSn;
       cbOSo: // global
           HpAlloc = 48;
           R1 = _sbNJK::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOSn: // global
           _sbNJQ::P64 = P64[_sbNJK::P64 + 6];
           I64[Hp - 40] = sat_sbNJU_info;
           P64[Hp - 32] = _sbNJG::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sbNJQ::P64;
           R2 = _sbNJG::P64;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 24;
           P64[Sp + 24] = Hp - 39;
           Sp = Sp + 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.361803651 UTC

[section ""data" . Control.Arrow.$fArrowChoiceKleisli3_closure" {
     Control.Arrow.$fArrowChoiceKleisli3_closure:
         const Control.Arrow.$fArrowChoiceKleisli3_info;
 },
 sat_sbNJZ_entry() //  [R1, R2]
         { info_tbl: [(cbOSB,
                       label: sat_sbNJZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOSB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOSC; else goto cbOSD;
       cbOSC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOSD: // global
           _sbNJY::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _sbNJY::P64;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fArrowChoiceKleisli3_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOSE,
                       label: Control.Arrow.$fArrowChoiceKleisli3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOSE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbOSI; else goto cbOSH;
       cbOSI: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fArrowChoiceKleisli3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOSH: // global
           I64[Hp - 8] = sat_sbNJZ_info;
           P64[Hp] = R2;
           R5 = R4;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Control.Arrow.$fArrowChoiceKleisli1_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.363257029 UTC

[section ""data" . Control.Arrow.$fArrowChoiceKleisli2_closure" {
     Control.Arrow.$fArrowChoiceKleisli2_closure:
         const Control.Arrow.$fArrowChoiceKleisli2_info;
 },
 sat_sbNK4_entry() //  [R1, R2]
         { info_tbl: [(cbOSS,
                       label: sat_sbNK4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOSS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOST; else goto cbOSU;
       cbOST: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOSU: // global
           _sbNK3::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _sbNK3::P64;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fArrowChoiceKleisli2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOSV,
                       label: Control.Arrow.$fArrowChoiceKleisli2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOSV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbOSZ; else goto cbOSY;
       cbOSZ: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fArrowChoiceKleisli2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOSY: // global
           I64[Hp - 8] = sat_sbNK4_info;
           P64[Hp] = R2;
           R5 = R4;
           R4 = R3;
           R3 = Hp - 7;
           R2 = R2;
           call Control.Arrow.$fArrowChoiceKleisli1_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.364490484 UTC

[section ""data" . lvl4_rbNCc_closure" {
     lvl4_rbNCc_closure:
         const lvl4_rbNCc_info;
 },
 lvl4_rbNCc_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOT4,
                       label: lvl4_rbNCc_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOT4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Either.either_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.365855237 UTC

[section ""data" . Control.Arrow.$fArrowChoiceKleisli_closure" {
     Control.Arrow.$fArrowChoiceKleisli_closure:
         const Control.Arrow.$fArrowChoiceKleisli_info;
 },
 sat_sbNKc_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbOTg,
                       label: sat_sbNKc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOTg: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fArrowChoiceKleisli1_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNKb_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOTo,
                       label: sat_sbNKb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOTo: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowChoiceKleisli2_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNKa_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOTw,
                       label: sat_sbNKa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOTw: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowChoiceKleisli3_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNK9_entry() //  [R1]
         { info_tbl: [(cbOTD,
                       label: sat_sbNK9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOTD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOTE; else goto cbOTF;
       cbOTE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOTF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowKleisli_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowChoiceKleisli_entry() //  [R2]
         { info_tbl: [(cbOTH,
                       label: Control.Arrow.$fArrowChoiceKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOTH: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cbOTL; else goto cbOTK;
       cbOTL: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Control.Arrow.$fArrowChoiceKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOTK: // global
           I64[Hp - 112] = sat_sbNKc_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbNKb_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbNKa_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbNK9_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = Control.Arrow.C:ArrowChoice_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 94;
           P64[Hp - 8] = Hp - 109;
           P64[Hp] = lvl4_rbNCc_closure+3;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.367716024 UTC

[section ""data" . Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_closure" {
     Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_closure:
         const Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_info;
 },
 sat_sbNKe_entry() //  [R1]
         { info_tbl: [(cbOTU,
                       label: sat_sbNKe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOTU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOTV; else goto cbOTW;
       cbOTV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOTW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_entry() //  [R2]
         { info_tbl: [(cbOTX,
                       label: Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOTX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOU1; else goto cbOU0;
       cbOU1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOU0: // global
           I64[Hp - 16] = sat_sbNKe_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Arrow.$fArrowKleisli_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.369210241 UTC

[section ""data" . Control.Arrow.$fArrowZeroKleisli_closure" {
     Control.Arrow.$fArrowZeroKleisli_closure:
         const Control.Arrow.$fArrowZeroKleisli_info;
 },
 lvl5_sbNKg_entry() //  [R1]
         { info_tbl: [(cbOUa,
                       label: lvl5_sbNKg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOUa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOUb; else goto cbOUc;
       cbOUb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOUc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNKj_entry() //  [R1]
         { info_tbl: [(cbOUi,
                       label: sat_sbNKj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOUi: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNKh_entry() //  [R1]
         { info_tbl: [(cbOUp,
                       label: sat_sbNKh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOUp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOUq; else goto cbOUr;
       cbOUq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOUr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowZeroKleisli_entry() //  [R2]
         { info_tbl: [(cbOUt,
                       label: Control.Arrow.$fArrowZeroKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOUt: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbOUx; else goto cbOUw;
       cbOUx: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = Control.Arrow.$fArrowZeroKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOUw: // global
           I64[Hp - 80] = lvl5_sbNKg_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbNKj_info;
           P64[Hp - 48] = Hp - 80;
           I64[Hp - 40] = sat_sbNKh_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Arrow.C:ArrowZero_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.371165809 UTC

[section ""data" . Control.Arrow.$fArrowPlusKleisli_closure" {
     Control.Arrow.$fArrowPlusKleisli_closure:
         const Control.Arrow.$fArrowPlusKleisli_info;
 },
 sat_sbNKm_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbOUH,
                       label: sat_sbNKm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOUH: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fArrowPlusKleisli1_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNKl_entry() //  [R1]
         { info_tbl: [(cbOUO,
                       label: sat_sbNKl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOUO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOUP; else goto cbOUQ;
       cbOUP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOUQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowZeroKleisli_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowPlusKleisli_entry() //  [R2]
         { info_tbl: [(cbOUS,
                       label: Control.Arrow.$fArrowPlusKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOUS: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbOUW; else goto cbOUV;
       cbOUW: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Arrow.$fArrowPlusKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOUV: // global
           I64[Hp - 56] = sat_sbNKm_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbNKl_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Arrow.C:ArrowPlus_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 53;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.372766995 UTC

[section ""data" . Control.Arrow.$dmsecond_closure" {
     Control.Arrow.$dmsecond_closure:
         const Control.Arrow.$dmsecond_info;
 },
 sat_sbNKp_entry() //  [R1]
         { info_tbl: [(cbOV7,
                       label: sat_sbNKp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOV7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbOV8; else goto cbOV9;
       cbOV8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOV9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbOV5_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbOV5() //  [R1]
         { info_tbl: [(cbOV5,
                       label: block_cbOV5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOV5: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Category.id_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dmsecond_entry() //  [R2]
         { info_tbl: [(cbOVd,
                       label: Control.Arrow.$dmsecond_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOVd: // global
           _sbNKn::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOVe; else goto cbOVf;
       cbOVf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOVh; else goto cbOVg;
       cbOVh: // global
           HpAlloc = 24;
           goto cbOVe;
       cbOVe: // global
           R2 = _sbNKn::P64;
           R1 = Control.Arrow.$dmsecond_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOVg: // global
           I64[Hp - 16] = sat_sbNKp_info;
           P64[Hp] = _sbNKn::P64;
           R2 = _sbNKn::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Control.Arrow.***_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.374363147 UTC

[section ""data" . Control.Arrow.$dmfirst_closure" {
     Control.Arrow.$dmfirst_closure:
         const Control.Arrow.$dmfirst_info;
 },
 sat_sbNKt_entry() //  [R1]
         { info_tbl: [(cbOVs,
                       label: sat_sbNKt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOVs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbOVt; else goto cbOVu;
       cbOVt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOVu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbOVq_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbOVq() //  [R1]
         { info_tbl: [(cbOVq,
                       label: block_cbOVq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOVq: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Category.id_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dmfirst_entry() //  [R2, R3]
         { info_tbl: [(cbOVy,
                       label: Control.Arrow.$dmfirst_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOVy: // global
           _sbNKr::P64 = R3;
           _sbNKq::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOVz; else goto cbOVA;
       cbOVA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOVC; else goto cbOVB;
       cbOVC: // global
           HpAlloc = 24;
           goto cbOVz;
       cbOVz: // global
           R3 = _sbNKr::P64;
           R2 = _sbNKq::P64;
           R1 = Control.Arrow.$dmfirst_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOVB: // global
           I64[Hp - 16] = sat_sbNKt_info;
           P64[Hp] = _sbNKq::P64;
           R2 = _sbNKq::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbNKr::P64;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Control.Arrow.***_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.375958236 UTC

[section ""data" . Control.Arrow.$cfirst_closure" {
     Control.Arrow.$cfirst_closure:
         const Control.Arrow.$cfirst_info;
 },
 sat_sbNKA_entry() //  [R1]
         { info_tbl: [(cbOVN,
                       label: sat_sbNKA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOVN: // global
           _sbNKA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOVO; else goto cbOVP;
       cbOVP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOVR; else goto cbOVQ;
       cbOVR: // global
           HpAlloc = 24;
           goto cbOVO;
       cbOVO: // global
           R1 = _sbNKA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOVQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNKA::P64;
           _sbNKu::P64 = P64[_sbNKA::P64 + 16];
           _sbNKv::P64 = P64[_sbNKA::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbNKv::P64;
           R2 = Hp - 16;
           R1 = _sbNKu::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$cfirst_entry() //  [R2, R3]
         { info_tbl: [(cbOVT,
                       label: Control.Arrow.$cfirst_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOVT: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbOVX; else goto cbOVW;
       cbOVX: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$cfirst_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOVW: // global
           I64[Hp - 72] = stg_sel_1_upd_info;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sbNKA_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.377530581 UTC

[section ""data" . Control.Arrow.$csecond_closure" {
     Control.Arrow.$csecond_closure:
         const Control.Arrow.$csecond_info;
 },
 sat_sbNKP_entry() //  [R1]
         { info_tbl: [(cbOW7,
                       label: sat_sbNKP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOW7: // global
           _sbNKP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbOW8; else goto cbOW9;
       cbOW9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbOWb; else goto cbOWa;
       cbOWb: // global
           HpAlloc = 24;
           goto cbOW8;
       cbOW8: // global
           R1 = _sbNKP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOWa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNKP::P64;
           _sbNKF::P64 = P64[_sbNKP::P64 + 16];
           _sbNKG::P64 = P64[_sbNKP::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sbNKG::P64;
           R2 = Hp - 16;
           R1 = _sbNKF::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$csecond_entry() //  [R2, R3]
         { info_tbl: [(cbOWe,
                       label: Control.Arrow.$csecond_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOWe: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbOWi; else goto cbOWh;
       cbOWi: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$csecond_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOWh: // global
           I64[Hp - 72] = sat_sbNKP_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.378970758 UTC

[section ""data" . Control.Arrow.$c&&&_closure" {
     Control.Arrow.$c&&&_closure:
         const Control.Arrow.$c&&&_info;
 },
 Control.Arrow.$c&&&_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOWq,
                       label: Control.Arrow.$c&&&_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOWq: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbOWu; else goto cbOWt;
       cbOWu: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$c&&&_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOWt: // global
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.379892102 UTC

[section ""data" . Control.Arrow.$fArrow(->)_closure" {
     Control.Arrow.$fArrow(->)_closure:
         const Control.Arrow.C:Arrow_con_info;
         const Control.Category.$fCategoryTYPE(->)_closure;
         const Control.Arrow.$fArrow(->)_$carr_closure+1;
         const Control.Arrow.$cfirst_closure+2;
         const Control.Arrow.$csecond_closure+2;
         const Control.Arrow.$c***_closure+3;
         const Control.Arrow.$c&&&_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.380544836 UTC

[section ""data" . Control.Arrow.$fArrowLoop(->)_closure" {
     Control.Arrow.$fArrowLoop(->)_closure:
         const Control.Arrow.C:ArrowLoop_con_info;
         const Control.Arrow.$fArrow(->)_closure+1;
         const Control.Arrow.$fArrowLoop(->)_$cloop_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.381074141 UTC

[section ""data" . Control.Arrow.$fArrowApply(->)_closure" {
     Control.Arrow.$fArrowApply(->)_closure:
         const Control.Arrow.C:ArrowApply_con_info;
         const Control.Arrow.$fArrow(->)_closure+1;
         const Control.Arrow.$fAlternativeArrowMonad_$capp_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.382148603 UTC

[section ""data" . Control.Arrow.$c+++_closure" {
     Control.Arrow.$c+++_closure:
         const Control.Arrow.$c+++_info;
 },
 Control.Arrow.$c+++_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOWG,
                       label: Control.Arrow.$c+++_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOWG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbOWH; else goto cbOWI;
       cbOWH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$c+++_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOWI: // global
           I64[Sp - 24] = block_cbOWz_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubOWX; else goto cbOWA;
       ubOWX: // global
           call _cbOWz(R1) args: 0, res: 0, upd: 0;
       cbOWA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOWz() //  [R1]
         { info_tbl: [(cbOWz,
                       label: block_cbOWz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOWz: // global
           if (R1 & 7 == 1) goto cbOWD; else goto cbOWE;
       cbOWD: // global
           Hp = Hp + 48;
           _sbNKY::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbOWW; else goto cbOWO;
       cbOWO: // global
           _sbNKZ::P64 = P64[_sbNKY::P64 + 7];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sbNKZ::P64;
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbOWE: // global
           Hp = Hp + 48;
           _sbNKY::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbOWW; else goto cbOWV;
       cbOWW: // global
           HpAlloc = 48;
           R1 = _sbNKY::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOWV: // global
           _sbNL1::P64 = P64[_sbNKY::P64 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sbNL1::P64;
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.383865512 UTC

[section ""data" . Control.Arrow.$cright_closure" {
     Control.Arrow.$cright_closure:
         const Control.Arrow.$cright_info;
 },
 Control.Arrow.$cright_entry() //  [R2, R3]
         { info_tbl: [(cbOX9,
                       label: Control.Arrow.$cright_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOX9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOXa; else goto cbOXb;
       cbOXa: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$cright_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOXb: // global
           I64[Sp - 16] = block_cbOX2_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubOXm; else goto cbOX3;
       ubOXm: // global
           call _cbOX2(R1) args: 0, res: 0, upd: 0;
       cbOX3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOX2() //  [R1]
         { info_tbl: [(cbOX2,
                       label: block_cbOX2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOX2: // global
           if (R1 & 7 == 1) goto cbOX6; else goto cbOX7;
       cbOX6: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbOX7: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbOXl; else goto cbOXk;
       cbOXl: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOXk: // global
           _sbNL7::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sbNL7::P64;
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.38540338 UTC

[section ""data" . Control.Arrow.$cleft_closure" {
     Control.Arrow.$cleft_closure:
         const Control.Arrow.$cleft_info;
 },
 Control.Arrow.$cleft_entry() //  [R2, R3]
         { info_tbl: [(cbOXy,
                       label: Control.Arrow.$cleft_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOXy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOXz; else goto cbOXA;
       cbOXz: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$cleft_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOXA: // global
           I64[Sp - 16] = block_cbOXr_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubOXL; else goto cbOXs;
       ubOXL: // global
           call _cbOXr(R1) args: 0, res: 0, upd: 0;
       cbOXs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOXr() //  [R1]
         { info_tbl: [(cbOXr,
                       label: block_cbOXr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOXr: // global
           if (R1 & 7 == 1) goto cbOXv; else goto cbOXw;
       cbOXv: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbOXH; else goto cbOXG;
       cbOXH: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOXG: // global
           _sbNLc::P64 = P64[R1 + 7];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sbNLc::P64;
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbOXw: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.386597907 UTC

[section ""data" . Control.Arrow.$fArrowChoice(->)_closure" {
     Control.Arrow.$fArrowChoice(->)_closure:
         const Control.Arrow.C:ArrowChoice_con_info;
         const Control.Arrow.$fArrow(->)_closure+1;
         const Control.Arrow.$cleft_closure+2;
         const Control.Arrow.$cright_closure+2;
         const Control.Arrow.$c+++_closure+3;
         const Data.Either.either_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.387313973 UTC

[section ""data" . Control.Arrow.runKleisli1_closure" {
     Control.Arrow.runKleisli1_closure:
         const Control.Arrow.runKleisli1_info;
 },
 Control.Arrow.runKleisli1_entry() //  [R2]
         { info_tbl: [(cbOXQ,
                       label: Control.Arrow.runKleisli1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOXQ: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.388127129 UTC

[section ""data" . Control.Arrow.runKleisli_closure" {
     Control.Arrow.runKleisli_closure:
         const Control.Arrow.runKleisli_info;
 },
 Control.Arrow.runKleisli_entry() //  [R2]
         { info_tbl: [(cbOXX,
                       label: Control.Arrow.runKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOXX: // global
           R2 = R2;
           call Control.Arrow.runKleisli1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.388986538 UTC

[section ""data" . Control.Arrow.returnA_closure" {
     Control.Arrow.returnA_closure:
         const Control.Arrow.returnA_info;
 },
 Control.Arrow.returnA_entry() //  [R2]
         { info_tbl: [(cbOY4,
                       label: Control.Arrow.returnA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOY4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOY5; else goto cbOY6;
       cbOY5: // global
           R2 = R2;
           R1 = Control.Arrow.returnA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOY6: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.id_closure+1;
           Sp = Sp - 16;
           call Control.Arrow.arr_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.39291047 UTC

[section ""data" . Control.Arrow.^>>_closure" {
     Control.Arrow.^>>_closure:
         const Control.Arrow.^>>_info;
 },
 sat_sbNLl_entry() //  [R1]
         { info_tbl: [(cbOYf,
                       label: sat_sbNLl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOYf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOYg; else goto cbOYh;
       cbOYg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOYh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.^>>_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOYk,
                       label: Control.Arrow.^>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOYk: // global
           _sbNLj::P64 = R4;
           _sbNLi::P64 = R3;
           _sbNLh::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOYl; else goto cbOYm;
       cbOYm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOYo; else goto cbOYn;
       cbOYo: // global
           HpAlloc = 32;
           goto cbOYl;
       cbOYl: // global
           R4 = _sbNLj::P64;
           R3 = _sbNLi::P64;
           R2 = _sbNLh::P64;
           R1 = Control.Arrow.^>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOYn: // global
           I64[Hp - 24] = sat_sbNLl_info;
           P64[Hp - 8] = _sbNLh::P64;
           P64[Hp] = _sbNLi::P64;
           I64[Sp - 24] = block_cbOYi_info;
           R2 = _sbNLh::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNLj::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOYi() //  [R1]
         { info_tbl: [(cbOYi,
                       label: block_cbOYi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOYi: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbOYb::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbOYb::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.39464552 UTC

[section ""data" . Control.Arrow.>>^_closure" {
     Control.Arrow.>>^_closure:
         const Control.Arrow.>>^_info;
 },
 sat_sbNLq_entry() //  [R1]
         { info_tbl: [(cbOYA,
                       label: sat_sbNLq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOYA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOYB; else goto cbOYC;
       cbOYB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOYC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.>>^_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOYF,
                       label: Control.Arrow.>>^_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOYF: // global
           _sbNLo::P64 = R4;
           _sbNLn::P64 = R3;
           _sbNLm::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOYG; else goto cbOYH;
       cbOYH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOYJ; else goto cbOYI;
       cbOYJ: // global
           HpAlloc = 32;
           goto cbOYG;
       cbOYG: // global
           R4 = _sbNLo::P64;
           R3 = _sbNLn::P64;
           R2 = _sbNLm::P64;
           R1 = Control.Arrow.>>^_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOYI: // global
           I64[Hp - 24] = sat_sbNLq_info;
           P64[Hp - 8] = _sbNLm::P64;
           P64[Hp] = _sbNLo::P64;
           I64[Sp - 24] = block_cbOYD_info;
           R2 = _sbNLm::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNLn::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOYD() //  [R1]
         { info_tbl: [(cbOYD,
                       label: block_cbOYD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOYD: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.396251267 UTC

[section ""data" . Control.Arrow.<<^_closure" {
     Control.Arrow.<<^_closure:
         const Control.Arrow.<<^_info;
 },
 sat_sbNLv_entry() //  [R1]
         { info_tbl: [(cbOYV,
                       label: sat_sbNLv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOYV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOYW; else goto cbOYX;
       cbOYW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOYX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.<<^_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOZ0,
                       label: Control.Arrow.<<^_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOZ0: // global
           _sbNLt::P64 = R4;
           _sbNLs::P64 = R3;
           _sbNLr::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOZ1; else goto cbOZ2;
       cbOZ2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOZ4; else goto cbOZ3;
       cbOZ4: // global
           HpAlloc = 32;
           goto cbOZ1;
       cbOZ1: // global
           R4 = _sbNLt::P64;
           R3 = _sbNLs::P64;
           R2 = _sbNLr::P64;
           R1 = Control.Arrow.<<^_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOZ3: // global
           I64[Hp - 24] = sat_sbNLv_info;
           P64[Hp - 8] = _sbNLr::P64;
           P64[Hp] = _sbNLt::P64;
           I64[Sp - 24] = block_cbOYY_info;
           R2 = _sbNLr::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNLs::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOYY() //  [R1]
         { info_tbl: [(cbOYY,
                       label: block_cbOYY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOYY: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbOYR::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbOYR::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.397925575 UTC

[section ""data" . Control.Arrow.^<<_closure" {
     Control.Arrow.^<<_closure:
         const Control.Arrow.^<<_info;
 },
 sat_sbNLA_entry() //  [R1]
         { info_tbl: [(cbOZg,
                       label: sat_sbNLA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOZg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOZh; else goto cbOZi;
       cbOZh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOZi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.^<<_entry() //  [R2, R3, R4]
         { info_tbl: [(cbOZl,
                       label: Control.Arrow.^<<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOZl: // global
           _sbNLy::P64 = R4;
           _sbNLx::P64 = R3;
           _sbNLw::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbOZm; else goto cbOZn;
       cbOZn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbOZp; else goto cbOZo;
       cbOZp: // global
           HpAlloc = 32;
           goto cbOZm;
       cbOZm: // global
           R4 = _sbNLy::P64;
           R3 = _sbNLx::P64;
           R2 = _sbNLw::P64;
           R1 = Control.Arrow.^<<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOZo: // global
           I64[Hp - 24] = sat_sbNLA_info;
           P64[Hp - 8] = _sbNLw::P64;
           P64[Hp] = _sbNLx::P64;
           I64[Sp - 24] = block_cbOZj_info;
           R2 = _sbNLw::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNLy::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOZj() //  [R1]
         { info_tbl: [(cbOZj,
                       label: block_cbOZj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOZj: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.401829967 UTC

[section ""data" . Control.Arrow.leftApp_closure" {
     Control.Arrow.leftApp_closure:
         const Control.Arrow.leftApp_info;
 },
 lvl5_sbNLG_entry() //  [R1]
         { info_tbl: [(cbOZN,
                       label: lvl5_sbNLG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOZN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOZO; else goto cbOZP;
       cbOZO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbOZP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Either.Left_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNLM_entry() //  [R1, R2]
         { info_tbl: [(cbP0k,
                       label: sat_sbNLM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP0k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbP0l; else goto cbP0m;
       cbP0l: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP0m: // global
           I64[Sp - 16] = block_cbP0h_info;
           _sbNLJ::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sbNLJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubP0q; else goto cbP0i;
       ubP0q: // global
           call _cbP0h() args: 0, res: 0, upd: 0;
       cbP0i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP0h() //  []
         { info_tbl: [(cbP0h,
                       label: block_cbP0h_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP0h: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNLN_entry() //  [R1]
         { info_tbl: [(cbP0r,
                       label: sat_sbNLN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP0r: // global
           _sbNLN::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbP0s; else goto cbP0t;
       cbP0t: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbP0v; else goto cbP0u;
       cbP0v: // global
           HpAlloc = 16;
           goto cbP0s;
       cbP0s: // global
           R1 = _sbNLN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbP0u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNLN::P64;
           _sbNLD::P64 = P64[_sbNLN::P64 + 16];
           _sbNLJ::P64 = P64[_sbNLN::P64 + 24];
           I64[Hp - 8] = sat_sbNLM_info;
           P64[Hp] = _sbNLJ::P64;
           R2 = _sbNLD::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNLO_entry() //  [R1]
         { info_tbl: [(cbP0w,
                       label: sat_sbNLO_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP0w: // global
           _sbNLO::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbP0x; else goto cbP0y;
       cbP0y: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbP0A; else goto cbP0z;
       cbP0A: // global
           HpAlloc = 32;
           goto cbP0x;
       cbP0x: // global
           R1 = _sbNLO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbP0z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNLO::P64;
           _sbNLC::P64 = P64[_sbNLO::P64 + 16];
           _sbNLD::P64 = P64[_sbNLO::P64 + 24];
           _sbNLE::P64 = P64[_sbNLO::P64 + 32];
           _sbNLJ::P64 = P64[_sbNLO::P64 + 40];
           I64[Hp - 24] = sat_sbNLN_info;
           P64[Hp - 8] = _sbNLD::P64;
           P64[Hp] = _sbNLJ::P64;
           R2 = _sbNLE::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbNLC::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNLP_entry() //  [R1]
         { info_tbl: [(cbP0B,
                       label: sat_sbNLP_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP0B: // global
           _sbNLP::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbP0C; else goto cbP0D;
       cbP0D: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbP0F; else goto cbP0E;
       cbP0F: // global
           HpAlloc = 48;
           goto cbP0C;
       cbP0C: // global
           R1 = _sbNLP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbP0E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNLP::P64;
           _sbNLC::P64 = P64[_sbNLP::P64 + 16];
           _sbNLD::P64 = P64[_sbNLP::P64 + 24];
           _sbNLE::P64 = P64[_sbNLP::P64 + 32];
           _sbNLG::P64 = P64[_sbNLP::P64 + 40];
           _sbNLJ::P64 = P64[_sbNLP::P64 + 48];
           I64[Hp - 40] = sat_sbNLO_info;
           P64[Hp - 24] = _sbNLC::P64;
           P64[Hp - 16] = _sbNLD::P64;
           P64[Hp - 8] = _sbNLE::P64;
           P64[Hp] = _sbNLJ::P64;
           R2 = _sbNLE::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbNLG::P64;
           P64[Sp - 24] = Hp - 40;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNLT_entry() //  [R1]
         { info_tbl: [(cbP0Y,
                       label: sat_sbNLT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP0Y: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbP0Z; else goto cbP10;
       cbP0Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbP10: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbP0V_info;
           _sbNLQ::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbNLQ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubP14; else goto cbP0W;
       ubP14: // global
           call _cbP0V() args: 0, res: 0, upd: 0;
       cbP0W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbP0V() //  []
         { info_tbl: [(cbP0V,
                       label: block_cbP0V_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP0V: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNLU_entry() //  [R1, R2]
         { info_tbl: [(cbP16,
                       label: sat_sbNLU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP16: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbP1a; else goto cbP19;
       cbP1a: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP19: // global
           _sbNLQ::P64 = P64[R1 + 7];
           I64[Hp - 40] = sat_sbNLT_info;
           P64[Hp - 24] = _sbNLQ::P64;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNLV_entry() //  [R1]
         { info_tbl: [(cbP1b,
                       label: sat_sbNLV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP1b: // global
           _sbNLV::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbP1c; else goto cbP1d;
       cbP1d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbP1f; else goto cbP1e;
       cbP1f: // global
           HpAlloc = 16;
           goto cbP1c;
       cbP1c: // global
           R1 = _sbNLV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbP1e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNLV::P64;
           _sbNLD::P64 = P64[_sbNLV::P64 + 16];
           _sbNLQ::P64 = P64[_sbNLV::P64 + 24];
           I64[Hp - 8] = sat_sbNLU_info;
           P64[Hp] = _sbNLQ::P64;
           R2 = _sbNLD::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNLW_entry() //  [R1, R2]
         { info_tbl: [(cbP1k,
                       label: sat_sbNLW_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP1k: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbP1l; else goto cbP1m;
       cbP1l: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP1m: // global
           I64[Sp - 40] = block_cbOZV_info;
           _sbNLC::P64 = P64[R1 + 7];
           _sbNLD::P64 = P64[R1 + 15];
           _sbNLE::P64 = P64[R1 + 23];
           _sbNLG::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sbNLC::P64;
           P64[Sp - 24] = _sbNLD::P64;
           P64[Sp - 16] = _sbNLE::P64;
           P64[Sp - 8] = _sbNLG::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubP1v; else goto cbOZW;
       ubP1v: // global
           call _cbOZV(R1) args: 0, res: 0, upd: 0;
       cbOZW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOZV() //  [R1]
         { info_tbl: [(cbOZV,
                       label: block_cbOZV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOZV: // global
           _sbNLD::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbP1h; else goto cbP1i;
       cbP1h: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbP1q; else goto cbP1p;
       cbP1q: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbP1p: // global
           _sbNLJ::P64 = P64[R1 + 7];
           I64[Hp - 72] = sat_sbNLP_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _sbNLD::P64;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sbNLJ::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = GHC.Tuple.()_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbP1i: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbP1u; else goto cbP1t;
       cbP1u: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbP1t: // global
           _sbNLQ::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sbNLV_info;
           P64[Hp - 32] = _sbNLD::P64;
           P64[Hp - 24] = _sbNLQ::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Tuple.()_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNLX_entry() //  [R1]
         { info_tbl: [(cbP1w,
                       label: sat_sbNLX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP1w: // global
           _sbNLX::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbP1x; else goto cbP1y;
       cbP1y: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbP1A; else goto cbP1z;
       cbP1A: // global
           HpAlloc = 64;
           goto cbP1x;
       cbP1x: // global
           R1 = _sbNLX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbP1z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNLX::P64;
           _sbNLC::P64 = P64[_sbNLX::P64 + 16];
           _sbNLD::P64 = P64[_sbNLX::P64 + 24];
           _sbNLE::P64 = P64[_sbNLX::P64 + 32];
           I64[Hp - 56] = lvl5_sbNLG_info;
           P64[Hp - 40] = _sbNLD::P64;
           I64[Hp - 32] = sat_sbNLW_info;
           P64[Hp - 24] = _sbNLC::P64;
           P64[Hp - 16] = _sbNLD::P64;
           P64[Hp - 8] = _sbNLE::P64;
           P64[Hp] = Hp - 56;
           R2 = _sbNLD::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 31;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNLF_entry() //  [R1]
         { info_tbl: [(cbP1F,
                       label: sat_sbNLF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP1F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbP1G; else goto cbP1H;
       cbP1G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbP1H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.app_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.leftApp_entry() //  [R2, R3]
         { info_tbl: [(cbP1I,
                       label: Control.Arrow.leftApp_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP1I: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbP1J; else goto cbP1K;
       cbP1J: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.leftApp_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbP1K: // global
           I64[Sp - 24] = block_cbOZx_info;
           _sbNLB::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _sbNLB::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Control.Arrow.$p1ArrowApply_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOZx() //  [R1]
         { info_tbl: [(cbOZx,
                       label: block_cbOZx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOZx: // global
           I64[Sp - 8] = block_cbOZB_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOZB() //  [R1]
         { info_tbl: [(cbOZB,
                       label: block_cbOZB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOZB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbP1O; else goto cbP1N;
       cbP1O: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbP1N: // global
           I64[Hp - 56] = sat_sbNLX_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbNLF_info;
           P64[Hp] = P64[Sp + 16];
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 24] = Hp - 56;
           Sp = Sp + 8;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.407228005 UTC

[section ""cstring" . Control.Arrow.$trModule4_bytes" {
     Control.Arrow.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.407781314 UTC

[section ""data" . Control.Arrow.$trModule3_closure" {
     Control.Arrow.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.408323938 UTC

[section ""cstring" . Control.Arrow.$trModule2_bytes" {
     Control.Arrow.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,65,114,114,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.408828819 UTC

[section ""data" . Control.Arrow.$trModule1_closure" {
     Control.Arrow.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.409424536 UTC

[section ""data" . Control.Arrow.$trModule_closure" {
     Control.Arrow.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Arrow.$trModule3_closure+1;
         const Control.Arrow.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.409970187 UTC

[section ""data" . $krep_rbNCd_closure" {
     $krep_rbNCd_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.410554894 UTC

[section ""data" . $krep1_rbNCe_closure" {
     $krep1_rbNCe_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.411131977 UTC

[section ""data" . Control.Arrow.$tcKleisli1_closure" {
     Control.Arrow.$tcKleisli1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const GHC.Types.krep$*->*->*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.41172296 UTC

[section ""data" . Control.Arrow.$tcArrow1_closure" {
     Control.Arrow.$tcArrow1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const $krep1_rbNCe_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.412262216 UTC

[section ""data" . Control.Arrow.$tcArrowMonad1_closure" {
     Control.Arrow.$tcArrowMonad1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const GHC.Types.krep$*Arr*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.412816754 UTC

[section ""data" . $krep2_rbNCf_closure" {
     $krep2_rbNCf_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.413483436 UTC

[section ""data" . $krep3_rbNCg_closure" {
     $krep3_rbNCg_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.414030933 UTC

[section ""data" . $krep4_rbNCh_closure" {
     $krep4_rbNCh_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.41460566 UTC

[section ""data" . $krep5_rbNCi_closure" {
     $krep5_rbNCi_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_rbNCh_closure+2;
         const $krep2_rbNCf_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.415172148 UTC

[section ""data" . $krep6_rbNCj_closure" {
     $krep6_rbNCj_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rbNCg_closure+2;
         const $krep5_rbNCi_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.415720332 UTC

[section ""data" . $krep7_rbNCk_closure" {
     $krep7_rbNCk_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_rbNCh_closure+2;
         const $krep_rbNCd_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.416257192 UTC

[section ""data" . $krep8_rbNCl_closure" {
     $krep8_rbNCl_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep7_rbNCk_closure+3;
         const $krep3_rbNCg_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.416823339 UTC

[section ""cstring" . Control.Arrow.$tcArrow3_bytes" {
     Control.Arrow.$tcArrow3_bytes:
         I8[] [65,114,114,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.417426948 UTC

[section ""data" . Control.Arrow.$tcArrow2_closure" {
     Control.Arrow.$tcArrow2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrow3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.417990669 UTC

[section ""data" . Control.Arrow.$tcArrow_closure" {
     Control.Arrow.$tcArrow_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrow2_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 12964584583212294992;
         const 10211991410748124746;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.418598793 UTC

[section ""cstring" . Control.Arrow.$tcKleisli3_bytes" {
     Control.Arrow.$tcKleisli3_bytes:
         I8[] [75,108,101,105,115,108,105]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.41911907 UTC

[section ""data" . Control.Arrow.$tcKleisli2_closure" {
     Control.Arrow.$tcKleisli2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcKleisli3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.419668387 UTC

[section ""data" . Control.Arrow.$tcKleisli_closure" {
     Control.Arrow.$tcKleisli_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcKleisli2_closure+1;
         const Control.Arrow.$tcKleisli1_closure+4;
         const 2023158159015915132;
         const 6143719008973118504;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.420271234 UTC

[section ""data" . $krep9_rbNCm_closure" {
     $krep9_rbNCm_closure:
         const :_con_info;
         const $krep2_rbNCf_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.420861829 UTC

[section ""data" . $krep10_rbNCn_closure" {
     $krep10_rbNCn_closure:
         const :_con_info;
         const $krep3_rbNCg_closure+2;
         const $krep9_rbNCm_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.4214612 UTC

[section ""data" . $krep11_rbNCo_closure" {
     $krep11_rbNCo_closure:
         const :_con_info;
         const $krep4_rbNCh_closure+2;
         const $krep10_rbNCn_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.421990101 UTC

[section ""data" . $krep12_rbNCp_closure" {
     $krep12_rbNCp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Arrow.$tcKleisli_closure+1;
         const $krep11_rbNCo_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.42259475 UTC

[section ""data" . Control.Arrow.$tc'Kleisli1_closure" {
     Control.Arrow.$tc'Kleisli1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rbNCj_closure+4;
         const $krep12_rbNCp_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.423133248 UTC

[section ""cstring" . Control.Arrow.$tc'Kleisli3_bytes" {
     Control.Arrow.$tc'Kleisli3_bytes:
         I8[] [39,75,108,101,105,115,108,105]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.423633375 UTC

[section ""data" . Control.Arrow.$tc'Kleisli2_closure" {
     Control.Arrow.$tc'Kleisli2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tc'Kleisli3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.424178144 UTC

[section ""data" . Control.Arrow.$tc'Kleisli_closure" {
     Control.Arrow.$tc'Kleisli_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tc'Kleisli2_closure+1;
         const Control.Arrow.$tc'Kleisli1_closure+4;
         const 793719726112502834;
         const 14919550952510816382;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.424714669 UTC

[section ""cstring" . Control.Arrow.$tcArrowZero2_bytes" {
     Control.Arrow.$tcArrowZero2_bytes:
         I8[] [65,114,114,111,119,90,101,114,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.425551918 UTC

[section ""data" . Control.Arrow.$tcArrowZero1_closure" {
     Control.Arrow.$tcArrowZero1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowZero2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.426119845 UTC

[section ""data" . Control.Arrow.$tcArrowZero_closure" {
     Control.Arrow.$tcArrowZero_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowZero1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 337582314637215801;
         const 485553589222180171;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.426718647 UTC

[section ""cstring" . Control.Arrow.$tcArrowPlus2_bytes" {
     Control.Arrow.$tcArrowPlus2_bytes:
         I8[] [65,114,114,111,119,80,108,117,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.42727967 UTC

[section ""data" . Control.Arrow.$tcArrowPlus1_closure" {
     Control.Arrow.$tcArrowPlus1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowPlus2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.427818627 UTC

[section ""data" . Control.Arrow.$tcArrowPlus_closure" {
     Control.Arrow.$tcArrowPlus_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowPlus1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 9089885184909062397;
         const 13092571182525076608;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.429937287 UTC

[section ""cstring" . Control.Arrow.$tcArrowChoice2_bytes" {
     Control.Arrow.$tcArrowChoice2_bytes:
         I8[] [65,114,114,111,119,67,104,111,105,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.430544934 UTC

[section ""data" . Control.Arrow.$tcArrowChoice1_closure" {
     Control.Arrow.$tcArrowChoice1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowChoice2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.431103158 UTC

[section ""data" . Control.Arrow.$tcArrowChoice_closure" {
     Control.Arrow.$tcArrowChoice_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowChoice1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 9045385674203608923;
         const 4474606397073518393;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.431719968 UTC

[section ""cstring" . Control.Arrow.$tcArrowApply2_bytes" {
     Control.Arrow.$tcArrowApply2_bytes:
         I8[] [65,114,114,111,119,65,112,112,108,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.432219243 UTC

[section ""data" . Control.Arrow.$tcArrowApply1_closure" {
     Control.Arrow.$tcArrowApply1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowApply2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.432757693 UTC

[section ""data" . Control.Arrow.$tcArrowApply_closure" {
     Control.Arrow.$tcArrowApply_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowApply1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 4969046276209689969;
         const 2697302259091605677;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.433361886 UTC

[section ""cstring" . Control.Arrow.$tcArrowMonad3_bytes" {
     Control.Arrow.$tcArrowMonad3_bytes:
         I8[] [65,114,114,111,119,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.433900974 UTC

[section ""data" . Control.Arrow.$tcArrowMonad2_closure" {
     Control.Arrow.$tcArrowMonad2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowMonad3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.434441838 UTC

[section ""data" . Control.Arrow.$tcArrowMonad_closure" {
     Control.Arrow.$tcArrowMonad_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowMonad2_closure+1;
         const Control.Arrow.$tcArrowMonad1_closure+4;
         const 2648525758856951758;
         const 13692351200590237690;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.435004033 UTC

[section ""data" . $krep13_rbNCq_closure" {
     $krep13_rbNCq_closure:
         const :_con_info;
         const $krep3_rbNCg_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.435566753 UTC

[section ""data" . $krep14_rbNCr_closure" {
     $krep14_rbNCr_closure:
         const :_con_info;
         const $krep4_rbNCh_closure+2;
         const $krep13_rbNCq_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.436130808 UTC

[section ""data" . $krep15_rbNCs_closure" {
     $krep15_rbNCs_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Arrow.$tcArrowMonad_closure+1;
         const $krep14_rbNCr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.436675279 UTC

[section ""data" . Control.Arrow.$tc'ArrowMonad1_closure" {
     Control.Arrow.$tc'ArrowMonad1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rbNCl_closure+3;
         const $krep15_rbNCs_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.43720433 UTC

[section ""cstring" . Control.Arrow.$tc'ArrowMonad3_bytes" {
     Control.Arrow.$tc'ArrowMonad3_bytes:
         I8[] [39,65,114,114,111,119,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.438223094 UTC

[section ""data" . Control.Arrow.$tc'ArrowMonad2_closure" {
     Control.Arrow.$tc'ArrowMonad2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tc'ArrowMonad3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.438784127 UTC

[section ""data" . Control.Arrow.$tc'ArrowMonad_closure" {
     Control.Arrow.$tc'ArrowMonad_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tc'ArrowMonad2_closure+1;
         const Control.Arrow.$tc'ArrowMonad1_closure+4;
         const 8781545391513276915;
         const 783725375361948493;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.439370517 UTC

[section ""cstring" . Control.Arrow.$tcArrowLoop2_bytes" {
     Control.Arrow.$tcArrowLoop2_bytes:
         I8[] [65,114,114,111,119,76,111,111,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.439932938 UTC

[section ""data" . Control.Arrow.$tcArrowLoop1_closure" {
     Control.Arrow.$tcArrowLoop1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowLoop2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.440470312 UTC

[section ""data" . Control.Arrow.$tcArrowLoop_closure" {
     Control.Arrow.$tcArrowLoop_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowLoop1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 15298492960828880948;
         const 13953070859738786616;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.441405328 UTC

[section ""data" . Control.Arrow.C:ArrowLoop_closure" {
     Control.Arrow.C:ArrowLoop_closure:
         const Control.Arrow.C:ArrowLoop_info;
 },
 Control.Arrow.C:ArrowLoop_entry() //  [R2, R3]
         { info_tbl: [(cbP1U,
                       label: Control.Arrow.C:ArrowLoop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP1U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbP1Y; else goto cbP1X;
       cbP1Y: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowLoop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbP1X: // global
           I64[Hp - 16] = Control.Arrow.C:ArrowLoop_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.442469875 UTC

[section ""data" . Control.Arrow.C:ArrowApply_closure" {
     Control.Arrow.C:ArrowApply_closure:
         const Control.Arrow.C:ArrowApply_info;
 },
 Control.Arrow.C:ArrowApply_entry() //  [R2, R3]
         { info_tbl: [(cbP24,
                       label: Control.Arrow.C:ArrowApply_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP24: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbP28; else goto cbP27;
       cbP28: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowApply_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbP27: // global
           I64[Hp - 16] = Control.Arrow.C:ArrowApply_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.443474099 UTC

[section ""data" . Control.Arrow.C:ArrowChoice_closure" {
     Control.Arrow.C:ArrowChoice_closure:
         const Control.Arrow.C:ArrowChoice_info;
 },
 Control.Arrow.C:ArrowChoice_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbP2e,
                       label: Control.Arrow.C:ArrowChoice_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP2e: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbP2i; else goto cbP2h;
       cbP2i: // global
           HpAlloc = 48;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowChoice_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbP2h: // global
           I64[Hp - 40] = Control.Arrow.C:ArrowChoice_con_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.444508858 UTC

[section ""data" . Control.Arrow.C:ArrowPlus_closure" {
     Control.Arrow.C:ArrowPlus_closure:
         const Control.Arrow.C:ArrowPlus_info;
 },
 Control.Arrow.C:ArrowPlus_entry() //  [R2, R3]
         { info_tbl: [(cbP2o,
                       label: Control.Arrow.C:ArrowPlus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP2o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbP2s; else goto cbP2r;
       cbP2s: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowPlus_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbP2r: // global
           I64[Hp - 16] = Control.Arrow.C:ArrowPlus_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.445905435 UTC

[section ""data" . Control.Arrow.C:ArrowZero_closure" {
     Control.Arrow.C:ArrowZero_closure:
         const Control.Arrow.C:ArrowZero_info;
 },
 Control.Arrow.C:ArrowZero_entry() //  [R2, R3]
         { info_tbl: [(cbP2y,
                       label: Control.Arrow.C:ArrowZero_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP2y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbP2C; else goto cbP2B;
       cbP2C: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowZero_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbP2B: // global
           I64[Hp - 16] = Control.Arrow.C:ArrowZero_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.446961441 UTC

[section ""data" . Control.Arrow.C:Arrow_closure" {
     Control.Arrow.C:Arrow_closure:
         const Control.Arrow.C:Arrow_info;
 },
 Control.Arrow.C:Arrow_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbP2I,
                       label: Control.Arrow.C:Arrow_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP2I: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbP2M; else goto cbP2L;
       cbP2M: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:Arrow_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbP2L: // global
           I64[Hp - 48] = Control.Arrow.C:Arrow_con_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.44792523 UTC

[Control.Arrow.C:ArrowLoop_con_entry() //  [R1]
         { info_tbl: [(cbP2N,
                       label: Control.Arrow.C:ArrowLoop_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,76,111,111,112]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP2N: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.44864062 UTC

[Control.Arrow.C:ArrowApply_con_entry() //  [R1]
         { info_tbl: [(cbP2P,
                       label: Control.Arrow.C:ArrowApply_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,65,112,112,108,121]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP2P: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.449353633 UTC

[Control.Arrow.C:ArrowChoice_con_entry() //  [R1]
         { info_tbl: [(cbP2R,
                       label: Control.Arrow.C:ArrowChoice_con_info
                       rep:HeapRep 5 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,67,104,111,105,99,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP2R: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.45005616 UTC

[Control.Arrow.C:ArrowPlus_con_entry() //  [R1]
         { info_tbl: [(cbP2T,
                       label: Control.Arrow.C:ArrowPlus_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,80,108,117,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP2T: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.450711438 UTC

[Control.Arrow.C:ArrowZero_con_entry() //  [R1]
         { info_tbl: [(cbP2V,
                       label: Control.Arrow.C:ArrowZero_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,90,101,114,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP2V: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.451435361 UTC

[Control.Arrow.C:Arrow_con_entry() //  [R1]
         { info_tbl: [(cbP2X,
                       label: Control.Arrow.C:Arrow_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP2X: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.452125631 UTC

[section ""relreadonly" . SbNZ8_srt" {
     SbNZ8_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Control.Arrow.$fMonadArrowMonad_closure;
         const lvl_rbNC6_closure;
         const Control.Arrow.$fMonadPlusArrowMonad_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.452974949 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:40.454383284 UTC

[section ""data" . Control.Arrow.$p1ArrowLoop_closure" {
     Control.Arrow.$p1ArrowLoop_closure:
         const Control.Arrow.$p1ArrowLoop_info;
 },
 Control.Arrow.$p1ArrowLoop_entry() //  [R2]
         { info_tbl: [(cbP36,
                       label: Control.Arrow.$p1ArrowLoop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP36: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbP37; else goto cbP38;
       cbP37: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowLoop_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP38: // global
           I64[Sp - 8] = block_cbP33_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubP3c; else goto cbP34;
       ubP3c: // global
           call _cbP33(R1) args: 0, res: 0, upd: 0;
       cbP34: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP33() //  [R1]
         { info_tbl: [(cbP33,
                       label: block_cbP33_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP33: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.459745322 UTC

[section ""data" . Control.Arrow.loop_closure" {
     Control.Arrow.loop_closure:
         const Control.Arrow.loop_info;
 },
 Control.Arrow.loop_entry() //  [R2]
         { info_tbl: [(cbP3v,
                       label: Control.Arrow.loop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP3v: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbP3w; else goto cbP3x;
       cbP3w: // global
           R2 = R2;
           R1 = Control.Arrow.loop_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP3x: // global
           I64[Sp - 8] = block_cbP3s_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubP3B; else goto cbP3t;
       ubP3B: // global
           call _cbP3s(R1) args: 0, res: 0, upd: 0;
       cbP3t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP3s() //  [R1]
         { info_tbl: [(cbP3s,
                       label: block_cbP3s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP3s: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.465683571 UTC

[section ""data" . Control.Arrow.$p1ArrowApply_closure" {
     Control.Arrow.$p1ArrowApply_closure:
         const Control.Arrow.$p1ArrowApply_info;
 },
 Control.Arrow.$p1ArrowApply_entry() //  [R2]
         { info_tbl: [(cbP3S,
                       label: Control.Arrow.$p1ArrowApply_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP3S: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbP3T; else goto cbP3U;
       cbP3T: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowApply_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP3U: // global
           I64[Sp - 8] = block_cbP3P_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubP3Y; else goto cbP3Q;
       ubP3Y: // global
           call _cbP3P(R1) args: 0, res: 0, upd: 0;
       cbP3Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP3P() //  [R1]
         { info_tbl: [(cbP3P,
                       label: block_cbP3P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP3P: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.473325885 UTC

[section ""data" . Control.Arrow.app_closure" {
     Control.Arrow.app_closure:
         const Control.Arrow.app_info;
 },
 Control.Arrow.app_entry() //  [R2]
         { info_tbl: [(cbP4h,
                       label: Control.Arrow.app_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP4h: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbP4i; else goto cbP4j;
       cbP4i: // global
           R2 = R2;
           R1 = Control.Arrow.app_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP4j: // global
           I64[Sp - 8] = block_cbP4e_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubP4n; else goto cbP4f;
       ubP4n: // global
           call _cbP4e(R1) args: 0, res: 0, upd: 0;
       cbP4f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP4e() //  [R1]
         { info_tbl: [(cbP4e,
                       label: block_cbP4e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP4e: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.479456096 UTC

[section ""data" . Control.Arrow.$p1ArrowChoice_closure" {
     Control.Arrow.$p1ArrowChoice_closure:
         const Control.Arrow.$p1ArrowChoice_info;
 },
 Control.Arrow.$p1ArrowChoice_entry() //  [R2]
         { info_tbl: [(cbP4E,
                       label: Control.Arrow.$p1ArrowChoice_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP4E: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbP4F; else goto cbP4G;
       cbP4F: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowChoice_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP4G: // global
           I64[Sp - 8] = block_cbP4B_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubP4K; else goto cbP4C;
       ubP4K: // global
           call _cbP4B(R1) args: 0, res: 0, upd: 0;
       cbP4C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP4B() //  [R1]
         { info_tbl: [(cbP4B,
                       label: block_cbP4B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP4B: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.48588943 UTC

[section ""data" . Control.Arrow.left_closure" {
     Control.Arrow.left_closure:
         const Control.Arrow.left_info;
 },
 Control.Arrow.left_entry() //  [R2]
         { info_tbl: [(cbP53,
                       label: Control.Arrow.left_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP53: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbP54; else goto cbP55;
       cbP54: // global
           R2 = R2;
           R1 = Control.Arrow.left_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP55: // global
           I64[Sp - 8] = block_cbP50_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubP59; else goto cbP51;
       ubP59: // global
           call _cbP50(R1) args: 0, res: 0, upd: 0;
       cbP51: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP50() //  [R1]
         { info_tbl: [(cbP50,
                       label: block_cbP50_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP50: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.492316889 UTC

[section ""data" . Control.Arrow.right_closure" {
     Control.Arrow.right_closure:
         const Control.Arrow.right_info;
 },
 Control.Arrow.right_entry() //  [R2]
         { info_tbl: [(cbP5q,
                       label: Control.Arrow.right_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP5q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbP5r; else goto cbP5s;
       cbP5r: // global
           R2 = R2;
           R1 = Control.Arrow.right_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP5s: // global
           I64[Sp - 8] = block_cbP5n_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubP5w; else goto cbP5o;
       ubP5w: // global
           call _cbP5n(R1) args: 0, res: 0, upd: 0;
       cbP5o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP5n() //  [R1]
         { info_tbl: [(cbP5n,
                       label: block_cbP5n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP5n: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.498743512 UTC

[section ""data" . Control.Arrow.+++_closure" {
     Control.Arrow.+++_closure:
         const Control.Arrow.+++_info;
 },
 Control.Arrow.+++_entry() //  [R2]
         { info_tbl: [(cbP5N,
                       label: Control.Arrow.+++_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP5N: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbP5O; else goto cbP5P;
       cbP5O: // global
           R2 = R2;
           R1 = Control.Arrow.+++_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP5P: // global
           I64[Sp - 8] = block_cbP5K_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubP5T; else goto cbP5L;
       ubP5T: // global
           call _cbP5K(R1) args: 0, res: 0, upd: 0;
       cbP5L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP5K() //  [R1]
         { info_tbl: [(cbP5K,
                       label: block_cbP5K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP5K: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.505342313 UTC

[section ""data" . Control.Arrow.|||_closure" {
     Control.Arrow.|||_closure:
         const Control.Arrow.|||_info;
 },
 Control.Arrow.|||_entry() //  [R2]
         { info_tbl: [(cbP6a,
                       label: Control.Arrow.|||_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP6a: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbP6b; else goto cbP6c;
       cbP6b: // global
           R2 = R2;
           R1 = Control.Arrow.|||_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP6c: // global
           I64[Sp - 8] = block_cbP67_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubP6g; else goto cbP68;
       ubP6g: // global
           call _cbP67(R1) args: 0, res: 0, upd: 0;
       cbP68: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP67() //  [R1]
         { info_tbl: [(cbP67,
                       label: block_cbP67_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP67: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.511550776 UTC

[section ""data" . Control.Arrow.$p1ArrowPlus_closure" {
     Control.Arrow.$p1ArrowPlus_closure:
         const Control.Arrow.$p1ArrowPlus_info;
 },
 Control.Arrow.$p1ArrowPlus_entry() //  [R2]
         { info_tbl: [(cbP6x,
                       label: Control.Arrow.$p1ArrowPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP6x: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbP6y; else goto cbP6z;
       cbP6y: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP6z: // global
           I64[Sp - 8] = block_cbP6u_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubP6D; else goto cbP6v;
       ubP6D: // global
           call _cbP6u(R1) args: 0, res: 0, upd: 0;
       cbP6v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP6u() //  [R1]
         { info_tbl: [(cbP6u,
                       label: block_cbP6u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP6u: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.517132225 UTC

[section ""data" . Control.Arrow.<+>_closure" {
     Control.Arrow.<+>_closure:
         const Control.Arrow.<+>_info;
 },
 Control.Arrow.<+>_entry() //  [R2]
         { info_tbl: [(cbP6W,
                       label: Control.Arrow.<+>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP6W: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbP6X; else goto cbP6Y;
       cbP6X: // global
           R2 = R2;
           R1 = Control.Arrow.<+>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP6Y: // global
           I64[Sp - 8] = block_cbP6T_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubP72; else goto cbP6U;
       ubP72: // global
           call _cbP6T(R1) args: 0, res: 0, upd: 0;
       cbP6U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP6T() //  [R1]
         { info_tbl: [(cbP6T,
                       label: block_cbP6T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP6T: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.52239496 UTC

[section ""data" . Control.Arrow.$p1ArrowZero_closure" {
     Control.Arrow.$p1ArrowZero_closure:
         const Control.Arrow.$p1ArrowZero_info;
 },
 Control.Arrow.$p1ArrowZero_entry() //  [R2]
         { info_tbl: [(cbP7j,
                       label: Control.Arrow.$p1ArrowZero_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP7j: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbP7k; else goto cbP7l;
       cbP7k: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowZero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP7l: // global
           I64[Sp - 8] = block_cbP7g_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubP7p; else goto cbP7h;
       ubP7p: // global
           call _cbP7g(R1) args: 0, res: 0, upd: 0;
       cbP7h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP7g() //  [R1]
         { info_tbl: [(cbP7g,
                       label: block_cbP7g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP7g: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.527581129 UTC

[section ""data" . Control.Arrow.zeroArrow_closure" {
     Control.Arrow.zeroArrow_closure:
         const Control.Arrow.zeroArrow_info;
 },
 Control.Arrow.zeroArrow_entry() //  [R2]
         { info_tbl: [(cbP7I,
                       label: Control.Arrow.zeroArrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP7I: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbP7J; else goto cbP7K;
       cbP7J: // global
           R2 = R2;
           R1 = Control.Arrow.zeroArrow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP7K: // global
           I64[Sp - 8] = block_cbP7F_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubP7O; else goto cbP7G;
       ubP7O: // global
           call _cbP7F(R1) args: 0, res: 0, upd: 0;
       cbP7G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP7F() //  [R1]
         { info_tbl: [(cbP7F,
                       label: block_cbP7F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP7F: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.532813816 UTC

[section ""data" . Control.Arrow.$p1Arrow_closure" {
     Control.Arrow.$p1Arrow_closure:
         const Control.Arrow.$p1Arrow_info;
 },
 Control.Arrow.$p1Arrow_entry() //  [R2]
         { info_tbl: [(cbP85,
                       label: Control.Arrow.$p1Arrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP85: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbP86; else goto cbP87;
       cbP86: // global
           R2 = R2;
           R1 = Control.Arrow.$p1Arrow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP87: // global
           I64[Sp - 8] = block_cbP82_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubP8b; else goto cbP83;
       ubP8b: // global
           call _cbP82(R1) args: 0, res: 0, upd: 0;
       cbP83: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP82() //  [R1]
         { info_tbl: [(cbP82,
                       label: block_cbP82_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP82: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.539284219 UTC

[section ""data" . Control.Arrow.arr_closure" {
     Control.Arrow.arr_closure:
         const Control.Arrow.arr_info;
 },
 Control.Arrow.arr_entry() //  [R2]
         { info_tbl: [(cbP8u,
                       label: Control.Arrow.arr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP8u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbP8v; else goto cbP8w;
       cbP8v: // global
           R2 = R2;
           R1 = Control.Arrow.arr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP8w: // global
           I64[Sp - 8] = block_cbP8r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubP8A; else goto cbP8s;
       ubP8A: // global
           call _cbP8r(R1) args: 0, res: 0, upd: 0;
       cbP8s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP8r() //  [R1]
         { info_tbl: [(cbP8r,
                       label: block_cbP8r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP8r: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.54462766 UTC

[section ""data" . Control.Arrow.first_closure" {
     Control.Arrow.first_closure:
         const Control.Arrow.first_info;
 },
 Control.Arrow.first_entry() //  [R2]
         { info_tbl: [(cbP8R,
                       label: Control.Arrow.first_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP8R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbP8S; else goto cbP8T;
       cbP8S: // global
           R2 = R2;
           R1 = Control.Arrow.first_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP8T: // global
           I64[Sp - 8] = block_cbP8O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubP8X; else goto cbP8P;
       ubP8X: // global
           call _cbP8O(R1) args: 0, res: 0, upd: 0;
       cbP8P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP8O() //  [R1]
         { info_tbl: [(cbP8O,
                       label: block_cbP8O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP8O: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.549747628 UTC

[section ""data" . Control.Arrow.second_closure" {
     Control.Arrow.second_closure:
         const Control.Arrow.second_info;
 },
 Control.Arrow.second_entry() //  [R2]
         { info_tbl: [(cbP9e,
                       label: Control.Arrow.second_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP9e: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbP9f; else goto cbP9g;
       cbP9f: // global
           R2 = R2;
           R1 = Control.Arrow.second_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP9g: // global
           I64[Sp - 8] = block_cbP9b_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubP9k; else goto cbP9c;
       ubP9k: // global
           call _cbP9b(R1) args: 0, res: 0, upd: 0;
       cbP9c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP9b() //  [R1]
         { info_tbl: [(cbP9b,
                       label: block_cbP9b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP9b: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.555566117 UTC

[section ""data" . Control.Arrow.***_closure" {
     Control.Arrow.***_closure:
         const Control.Arrow.***_info;
 },
 Control.Arrow.***_entry() //  [R2]
         { info_tbl: [(cbP9B,
                       label: Control.Arrow.***_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP9B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbP9C; else goto cbP9D;
       cbP9C: // global
           R2 = R2;
           R1 = Control.Arrow.***_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbP9D: // global
           I64[Sp - 8] = block_cbP9y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubP9H; else goto cbP9z;
       ubP9H: // global
           call _cbP9y(R1) args: 0, res: 0, upd: 0;
       cbP9z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP9y() //  [R1]
         { info_tbl: [(cbP9y,
                       label: block_cbP9y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP9y: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.561350487 UTC

[section ""data" . Control.Arrow.&&&_closure" {
     Control.Arrow.&&&_closure:
         const Control.Arrow.&&&_info;
 },
 Control.Arrow.&&&_entry() //  [R2]
         { info_tbl: [(cbP9Y,
                       label: Control.Arrow.&&&_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP9Y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbP9Z; else goto cbPa0;
       cbP9Z: // global
           R2 = R2;
           R1 = Control.Arrow.&&&_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPa0: // global
           I64[Sp - 8] = block_cbP9V_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubPa4; else goto cbP9W;
       ubPa4: // global
           call _cbP9V(R1) args: 0, res: 0, upd: 0;
       cbP9W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbP9V() //  [R1]
         { info_tbl: [(cbP9V,
                       label: block_cbP9V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP9V: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.567309734 UTC

[section ""data" . Control.Arrow.$c***_closure" {
     Control.Arrow.$c***_closure:
         const Control.Arrow.$c***_info;
 },
 sat_sbNEx_entry() //  [R1]
         { info_tbl: [(cbPan,
                       label: sat_sbNEx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPan: // global
           _sbNEx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPao; else goto cbPap;
       cbPap: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPar; else goto cbPaq;
       cbPar: // global
           HpAlloc = 24;
           goto cbPao;
       cbPao: // global
           R1 = _sbNEx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPaq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNEx::P64;
           _sbNEm::P64 = P64[_sbNEx::P64 + 16];
           _sbNEn::P64 = P64[_sbNEx::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sbNEn::P64;
           R2 = Hp - 16;
           R1 = _sbNEm::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNEs_entry() //  [R1]
         { info_tbl: [(cbPax,
                       label: sat_sbNEs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPax: // global
           _sbNEs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPay; else goto cbPaz;
       cbPaz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPaB; else goto cbPaA;
       cbPaB: // global
           HpAlloc = 24;
           goto cbPay;
       cbPay: // global
           R1 = _sbNEs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPaA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNEs::P64;
           _sbNEl::P64 = P64[_sbNEs::P64 + 16];
           _sbNEn::P64 = P64[_sbNEs::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbNEn::P64;
           R2 = Hp - 16;
           R1 = _sbNEl::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$c***_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPaD,
                       label: Control.Arrow.$c***_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPaD: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbPaH; else goto cbPaG;
       cbPaH: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$c***_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPaG: // global
           I64[Hp - 80] = sat_sbNEx_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sbNEs_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.576981299 UTC

[section ""data" . Control.Arrow.$fArrow(->)_$carr_closure" {
     Control.Arrow.$fArrow(->)_$carr_closure:
         const Control.Arrow.$fArrow(->)_$carr_info;
 },
 Control.Arrow.$fArrow(->)_$carr_entry() //  [R2]
         { info_tbl: [(cbPb1,
                       label: Control.Arrow.$fArrow(->)_$carr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPb1: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.580305171 UTC

[section ""data" . Control.Arrow.$fCategoryTYPEKleisli1_closure" {
     Control.Arrow.$fCategoryTYPEKleisli1_closure:
         const Control.Arrow.$fCategoryTYPEKleisli1_info;
 },
 Control.Arrow.$fCategoryTYPEKleisli1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbPbd,
                       label: Control.Arrow.$fCategoryTYPEKleisli1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPbd: // global
           _sbNEC::P64 = R5;
           _sbNEB::P64 = R4;
           _sbNEA::P64 = R3;
           _sbNEz::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbPbe; else goto cbPbf;
       cbPbf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbPbh; else goto cbPbg;
       cbPbh: // global
           HpAlloc = 32;
           goto cbPbe;
       cbPbe: // global
           R5 = _sbNEC::P64;
           R4 = _sbNEB::P64;
           R3 = _sbNEA::P64;
           R2 = _sbNEz::P64;
           R1 = Control.Arrow.$fCategoryTYPEKleisli1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPbg: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbNEB::P64;
           P64[Hp] = _sbNEC::P64;
           R2 = _sbNEz::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNEA::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.584785862 UTC

[section ""data" . Control.Arrow.$fCategoryTYPEKleisli_closure" {
     Control.Arrow.$fCategoryTYPEKleisli_closure:
         const Control.Arrow.$fCategoryTYPEKleisli_info;
 },
 sat_sbNEG_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbPbx,
                       label: sat_sbNEG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPbx: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fCategoryTYPEKleisli1_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNEF_entry() //  [R1]
         { info_tbl: [(cbPbE,
                       label: sat_sbNEF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPbE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPbF; else goto cbPbG;
       cbPbF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPbG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fCategoryTYPEKleisli_entry() //  [R2]
         { info_tbl: [(cbPbI,
                       label: Control.Arrow.$fCategoryTYPEKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPbI: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbPbM; else goto cbPbL;
       cbPbM: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Arrow.$fCategoryTYPEKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPbL: // global
           I64[Hp - 56] = sat_sbNEG_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbNEF_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Category.C:Category_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 53;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.592241554 UTC

[section ""data" . Control.Arrow.$fArrowKleisli4_closure" {
     Control.Arrow.$fArrowKleisli4_closure:
         const Control.Arrow.$fArrowKleisli4_info;
 },
 sat_sbNEV_entry() //  [R1, R2]
         { info_tbl: [(cbPcc,
                       label: sat_sbNEV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPcc: // global
           _sbNET::P64 = R2;
           _sbNEV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPcd; else goto cbPce;
       cbPce: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPcg; else goto cbPcf;
       cbPcg: // global
           HpAlloc = 24;
           goto cbPcd;
       cbPcd: // global
           R2 = _sbNET::P64;
           R1 = _sbNEV::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPcf: // global
           _sbNEH::P64 = P64[_sbNEV::P64 + 7];
           _sbNEK::P64 = P64[_sbNEV::P64 + 15];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbNEK::P64;
           P64[Hp] = _sbNET::P64;
           R2 = _sbNEH::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbNES_entry() //  [R1]
         { info_tbl: [(cbPcm,
                       label: sat_sbNES_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPcm: // global
           _sbNES::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPcn; else goto cbPco;
       cbPco: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPcq; else goto cbPcp;
       cbPcq: // global
           HpAlloc = 24;
           goto cbPcn;
       cbPcn: // global
           R1 = _sbNES::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPcp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNES::P64;
           _sbNEI::P64 = P64[_sbNES::P64 + 16];
           _sbNEJ::P64 = P64[_sbNES::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sbNEJ::P64;
           R2 = Hp - 16;
           R1 = _sbNEI::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli4_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPcr,
                       label: Control.Arrow.$fArrowKleisli4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPcr: // global
           _sbNEJ::P64 = R4;
           _sbNEI::P64 = R3;
           _sbNEH::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbPcs; else goto cbPct;
       cbPct: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbPcv; else goto cbPcu;
       cbPcv: // global
           HpAlloc = 80;
           goto cbPcs;
       cbPcs: // global
           R4 = _sbNEJ::P64;
           R3 = _sbNEI::P64;
           R2 = _sbNEH::P64;
           R1 = Control.Arrow.$fArrowKleisli4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPcu: // global
           I64[Hp - 72] = stg_sel_0_upd_info;
           P64[Hp - 56] = _sbNEJ::P64;
           I64[Hp - 48] = sat_sbNEV_info;
           P64[Hp - 40] = _sbNEH::P64;
           P64[Hp - 32] = Hp - 72;
           I64[Hp - 24] = sat_sbNES_info;
           P64[Hp - 8] = _sbNEI::P64;
           P64[Hp] = _sbNEJ::P64;
           R2 = _sbNEH::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.601344658 UTC

[section ""data" . Control.Arrow.$fArrowKleisli3_closure" {
     Control.Arrow.$fArrowKleisli3_closure:
         const Control.Arrow.$fArrowKleisli3_info;
 },
 sat_sbNFa_entry() //  [R1, R2]
         { info_tbl: [(cbPcY,
                       label: sat_sbNFa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPcY: // global
           _sbNF8::P64 = R2;
           _sbNFa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPcZ; else goto cbPd0;
       cbPd0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPd2; else goto cbPd1;
       cbPd2: // global
           HpAlloc = 24;
           goto cbPcZ;
       cbPcZ: // global
           R2 = _sbNF8::P64;
           R1 = _sbNFa::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPd1: // global
           _sbNEW::P64 = P64[_sbNFa::P64 + 7];
           _sbNEZ::P64 = P64[_sbNFa::P64 + 15];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbNF8::P64;
           P64[Hp] = _sbNEZ::P64;
           R2 = _sbNEW::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbNF7_entry() //  [R1]
         { info_tbl: [(cbPd8,
                       label: sat_sbNF7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPd8: // global
           _sbNF7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPd9; else goto cbPda;
       cbPda: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPdc; else goto cbPdb;
       cbPdc: // global
           HpAlloc = 24;
           goto cbPd9;
       cbPd9: // global
           R1 = _sbNF7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPdb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNF7::P64;
           _sbNEX::P64 = P64[_sbNF7::P64 + 16];
           _sbNEY::P64 = P64[_sbNF7::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbNEY::P64;
           R2 = Hp - 16;
           R1 = _sbNEX::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli3_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPdd,
                       label: Control.Arrow.$fArrowKleisli3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPdd: // global
           _sbNEY::P64 = R4;
           _sbNEX::P64 = R3;
           _sbNEW::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbPde; else goto cbPdf;
       cbPdf: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbPdh; else goto cbPdg;
       cbPdh: // global
           HpAlloc = 80;
           goto cbPde;
       cbPde: // global
           R4 = _sbNEY::P64;
           R3 = _sbNEX::P64;
           R2 = _sbNEW::P64;
           R1 = Control.Arrow.$fArrowKleisli3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPdg: // global
           I64[Hp - 72] = stg_sel_1_upd_info;
           P64[Hp - 56] = _sbNEY::P64;
           I64[Hp - 48] = sat_sbNFa_info;
           P64[Hp - 40] = _sbNEW::P64;
           P64[Hp - 32] = Hp - 72;
           I64[Hp - 24] = sat_sbNF7_info;
           P64[Hp - 8] = _sbNEX::P64;
           P64[Hp] = _sbNEY::P64;
           R2 = _sbNEW::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.611809924 UTC

[section ""data" . Control.Arrow.$fArrowKleisli5_closure" {
     Control.Arrow.$fArrowKleisli5_closure:
         const Control.Arrow.$fArrowKleisli5_info;
 },
 Control.Arrow.$fArrowKleisli5_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPdE,
                       label: Control.Arrow.$fArrowKleisli5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPdE: // global
           _sbNFd::P64 = R4;
           _sbNFc::P64 = R3;
           _sbNFb::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPdF; else goto cbPdG;
       cbPdG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbPdI; else goto cbPdH;
       cbPdI: // global
           HpAlloc = 32;
           goto cbPdF;
       cbPdF: // global
           R4 = _sbNFd::P64;
           R3 = _sbNFc::P64;
           R2 = _sbNFb::P64;
           R1 = Control.Arrow.$fArrowKleisli5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPdH: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbNFc::P64;
           P64[Hp] = _sbNFd::P64;
           R2 = _sbNFb::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.616015082 UTC

[section ""data" . Control.Arrow.$fArrowPlusKleisli1_closure" {
     Control.Arrow.$fArrowPlusKleisli1_closure:
         const Control.Arrow.$fArrowPlusKleisli1_info;
 },
 Control.Arrow.$fArrowPlusKleisli1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbPdV,
                       label: Control.Arrow.$fArrowPlusKleisli1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPdV: // global
           _sbNFi::P64 = R5;
           _sbNFh::P64 = R4;
           _sbNFg::P64 = R3;
           _sbNFf::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbPdW; else goto cbPdX;
       cbPdX: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbPdZ; else goto cbPdY;
       cbPdZ: // global
           HpAlloc = 64;
           goto cbPdW;
       cbPdW: // global
           R5 = _sbNFi::P64;
           R4 = _sbNFh::P64;
           R3 = _sbNFg::P64;
           R2 = _sbNFf::P64;
           R1 = Control.Arrow.$fArrowPlusKleisli1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPdY: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sbNFh::P64;
           P64[Hp - 32] = _sbNFi::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbNFg::P64;
           P64[Hp] = _sbNFi::P64;
           R2 = _sbNFf::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.620306488 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_$capp_closure" {
     Control.Arrow.$fAlternativeArrowMonad_$capp_closure:
         const Control.Arrow.$fAlternativeArrowMonad_$capp_info;
 },
 Control.Arrow.$fAlternativeArrowMonad_$capp_entry() //  [R2]
         { info_tbl: [(cbPee,
                       label: Control.Arrow.$fAlternativeArrowMonad_$capp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPee: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbPef; else goto cbPeg;
       cbPef: // global
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_$capp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPeg: // global
           I64[Sp - 8] = block_cbPeb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubPek; else goto cbPec;
       ubPek: // global
           call _cbPeb(R1) args: 0, res: 0, upd: 0;
       cbPec: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbPeb() //  [R1]
         { info_tbl: [(cbPeb,
                       label: block_cbPeb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPeb: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.625988864 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad5_closure" {
     Control.Arrow.$fApplicativeArrowMonad5_closure:
         const Control.Arrow.$fApplicativeArrowMonad5_info;
 },
 sat_sbNFt_entry() //  [R1]
         { info_tbl: [(cbPeC,
                       label: sat_sbNFt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPeC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPeD; else goto cbPeE;
       cbPeD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPeE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad5_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPeH,
                       label: Control.Arrow.$fApplicativeArrowMonad5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPeH: // global
           _sbNFr::P64 = R4;
           _sbNFq::P64 = R3;
           _sbNFp::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbPeI; else goto cbPeJ;
       cbPeJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbPeL; else goto cbPeK;
       cbPeL: // global
           HpAlloc = 32;
           goto cbPeI;
       cbPeI: // global
           R4 = _sbNFr::P64;
           R3 = _sbNFq::P64;
           R2 = _sbNFp::P64;
           R1 = Control.Arrow.$fApplicativeArrowMonad5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPeK: // global
           I64[Hp - 24] = sat_sbNFt_info;
           P64[Hp - 8] = _sbNFp::P64;
           P64[Hp] = _sbNFq::P64;
           I64[Sp - 24] = block_cbPeF_info;
           R2 = _sbNFp::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNFr::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPeF() //  [R1]
         { info_tbl: [(cbPeF,
                       label: block_cbPeF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPeF: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.633938981 UTC

[section ""data" . Control.Arrow.$fFunctorArrowMonad1_closure" {
     Control.Arrow.$fFunctorArrowMonad1_closure:
         const Control.Arrow.$fFunctorArrowMonad1_info;
 },
 sat_sbNFz_entry() //  [R1]
         { info_tbl: [(cbPfg,
                       label: sat_sbNFz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPfg: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNFA_entry() //  [R1]
         { info_tbl: [(cbPfj,
                       label: sat_sbNFA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPfj: // global
           _sbNFA::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbPfk; else goto cbPfl;
       cbPfl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbPfn; else goto cbPfm;
       cbPfn: // global
           HpAlloc = 16;
           goto cbPfk;
       cbPfk: // global
           R1 = _sbNFA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPfm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNFA::P64;
           _sbNFu::P64 = P64[_sbNFA::P64 + 16];
           _sbNFv::P64 = P64[_sbNFA::P64 + 24];
           I64[Hp - 8] = sat_sbNFz_info;
           P64[Hp] = _sbNFv::P64;
           R2 = _sbNFu::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fFunctorArrowMonad1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPfq,
                       label: Control.Arrow.$fFunctorArrowMonad1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPfq: // global
           _sbNFw::P64 = R4;
           _sbNFv::P64 = R3;
           _sbNFu::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbPfr; else goto cbPfs;
       cbPfs: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbPfu; else goto cbPft;
       cbPfu: // global
           HpAlloc = 32;
           goto cbPfr;
       cbPfr: // global
           R4 = _sbNFw::P64;
           R3 = _sbNFv::P64;
           R2 = _sbNFu::P64;
           R1 = Control.Arrow.$fFunctorArrowMonad1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPft: // global
           I64[Hp - 24] = sat_sbNFA_info;
           P64[Hp - 8] = _sbNFu::P64;
           P64[Hp] = _sbNFv::P64;
           I64[Sp - 24] = block_cbPfo_info;
           R2 = _sbNFu::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNFw::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPfo() //  [R1]
         { info_tbl: [(cbPfo,
                       label: block_cbPfo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPfo: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.643244333 UTC

[section ""data" . Control.Arrow.$fFunctorArrowMonad_closure" {
     Control.Arrow.$fFunctorArrowMonad_closure:
         const Control.Arrow.$fFunctorArrowMonad_info;
 },
 sat_sbNFD_entry() //  [R1, R2, R3]
         { info_tbl: [(cbPfY,
                       label: sat_sbNFD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPfY: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fFunctorArrowMonad1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNFC_entry() //  [R1, R2, R3]
         { info_tbl: [(cbPg6,
                       label: sat_sbNFC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPg6: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fApplicativeArrowMonad5_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fFunctorArrowMonad_entry() //  [R2]
         { info_tbl: [(cbPga,
                       label: Control.Arrow.$fFunctorArrowMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPga: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbPge; else goto cbPgd;
       cbPge: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Arrow.$fFunctorArrowMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPgd: // global
           I64[Hp - 48] = sat_sbNFD_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sbNFC_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.651332438 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad2_closure" {
     Control.Arrow.$fAlternativeArrowMonad2_closure:
         const Control.Arrow.$fAlternativeArrowMonad2_info;
 },
 sat_sbNFJ_entry() //  [R1]
         { info_tbl: [(cbPgA,
                       label: sat_sbNFJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPgA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbPgB; else goto cbPgC;
       cbPgB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPgC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Arrow.&&&_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNFI_entry() //  [R1]
         { info_tbl: [(cbPgH,
                       label: sat_sbNFI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPgH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPgI; else goto cbPgJ;
       cbPgI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPgJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fAlternativeArrowMonad_$capp_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPgM,
                       label: Control.Arrow.$fAlternativeArrowMonad2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPgM: // global
           _sbNFG::P64 = R4;
           _sbNFF::P64 = R3;
           _sbNFE::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbPgN; else goto cbPgO;
       cbPgO: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbPgQ; else goto cbPgP;
       cbPgQ: // global
           HpAlloc = 64;
           goto cbPgN;
       cbPgN: // global
           R4 = _sbNFG::P64;
           R3 = _sbNFF::P64;
           R2 = _sbNFE::P64;
           R1 = Control.Arrow.$fAlternativeArrowMonad2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPgP: // global
           I64[Hp - 56] = sat_sbNFJ_info;
           P64[Hp - 40] = _sbNFE::P64;
           P64[Hp - 32] = _sbNFF::P64;
           P64[Hp - 24] = _sbNFG::P64;
           I64[Hp - 16] = sat_sbNFI_info;
           P64[Hp] = _sbNFE::P64;
           I64[Sp - 24] = block_cbPgK_info;
           R2 = _sbNFE::P64;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPgK() //  [R1]
         { info_tbl: [(cbPgK,
                       label: block_cbPgK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPgK: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbPgw::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbPgw::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.660925333 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad6_closure" {
     Control.Arrow.$fApplicativeArrowMonad6_closure:
         const Control.Arrow.$fApplicativeArrowMonad6_info;
 },
 sat_sbNFN_entry() //  [R1]
         { info_tbl: [(cbPho,
                       label: sat_sbNFN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPho: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad6_entry() //  [R2, R3]
         { info_tbl: [(cbPhr,
                       label: Control.Arrow.$fApplicativeArrowMonad6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPhr: // global
           _sbNFL::P64 = R3;
           _sbNFK::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPhs; else goto cbPht;
       cbPht: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbPhv; else goto cbPhu;
       cbPhv: // global
           HpAlloc = 16;
           goto cbPhs;
       cbPhs: // global
           R3 = _sbNFL::P64;
           R2 = _sbNFK::P64;
           R1 = Control.Arrow.$fApplicativeArrowMonad6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPhu: // global
           I64[Hp - 8] = sat_sbNFN_info;
           P64[Hp] = _sbNFL::P64;
           R2 = _sbNFK::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Arrow.arr_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.66655764 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad4_closure" {
     Control.Arrow.$fApplicativeArrowMonad4_closure:
         const Control.Arrow.$fApplicativeArrowMonad4_info;
 },
 sat_sbNFR_entry() //  [R1]
         { info_tbl: [(cbPhN,
                       label: sat_sbNFR_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPhN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPhO; else goto cbPhP;
       cbPhO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPhP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fApplicativeArrowMonad5_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad4_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPhQ,
                       label: Control.Arrow.$fApplicativeArrowMonad4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPhQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbPhU; else goto cbPhT;
       cbPhU: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fApplicativeArrowMonad4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPhT: // global
           I64[Hp - 32] = sat_sbNFR_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = Hp - 32;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad2_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.672591844 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad3_closure" {
     Control.Arrow.$fApplicativeArrowMonad3_closure:
         const Control.Arrow.$fApplicativeArrowMonad3_info;
 },
 Control.Arrow.$fApplicativeArrowMonad3_entry() //  [R3]
         { info_tbl: [(cbPi7,
                       label: Control.Arrow.$fApplicativeArrowMonad3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPi7: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.676413223 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad2_closure" {
     Control.Arrow.$fApplicativeArrowMonad2_closure:
         const Control.Arrow.$fApplicativeArrowMonad2_info;
 },
 sat_sbNFY_entry() //  [R1]
         { info_tbl: [(cbPiq,
                       label: sat_sbNFY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPiq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPir; else goto cbPis;
       cbPir: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPis: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fApplicativeArrowMonad3_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNFZ_entry() //  [R1]
         { info_tbl: [(cbPiv,
                       label: sat_sbNFZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPiv: // global
           _sbNFZ::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbPiw; else goto cbPix;
       cbPix: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPiz; else goto cbPiy;
       cbPiz: // global
           HpAlloc = 24;
           goto cbPiw;
       cbPiw: // global
           R1 = _sbNFZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPiy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNFZ::P64;
           _sbNFU::P64 = P64[_sbNFZ::P64 + 16];
           _sbNFV::P64 = P64[_sbNFZ::P64 + 24];
           I64[Hp - 16] = sat_sbNFY_info;
           P64[Hp] = _sbNFU::P64;
           I64[Sp - 40] = block_cbPit_info;
           R2 = _sbNFU::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbNFV::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbPit() //  [R1]
         { info_tbl: [(cbPit,
                       label: block_cbPit_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPit: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPiD,
                       label: Control.Arrow.$fApplicativeArrowMonad2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPiD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbPiH; else goto cbPiG;
       cbPiH: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fApplicativeArrowMonad2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPiG: // global
           I64[Hp - 24] = sat_sbNFZ_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R4 = R4;
           R3 = Hp - 24;
           R2 = R2;
           call Control.Arrow.$fAlternativeArrowMonad2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.687029949 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad1_closure" {
     Control.Arrow.$fApplicativeArrowMonad1_closure:
         const Control.Arrow.$fApplicativeArrowMonad1_info;
 },
 sat_sbNG3_entry() //  [R1]
         { info_tbl: [(cbPja,
                       label: sat_sbNG3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPja: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPjb; else goto cbPjc;
       cbPjb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPjc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Base.const_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNG4_entry() //  [R1]
         { info_tbl: [(cbPjf,
                       label: sat_sbNG4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPjf: // global
           _sbNG4::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbPjg; else goto cbPjh;
       cbPjh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPjj; else goto cbPji;
       cbPjj: // global
           HpAlloc = 24;
           goto cbPjg;
       cbPjg: // global
           R1 = _sbNG4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPji: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNG4::P64;
           _sbNG0::P64 = P64[_sbNG4::P64 + 16];
           _sbNG1::P64 = P64[_sbNG4::P64 + 24];
           I64[Hp - 16] = sat_sbNG3_info;
           P64[Hp] = _sbNG0::P64;
           I64[Sp - 40] = block_cbPjd_info;
           R2 = _sbNG0::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbNG1::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbPjd() //  [R1]
         { info_tbl: [(cbPjd,
                       label: block_cbPjd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPjd: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad1_entry() //  [R2, R3]
         { info_tbl: [(cbPjn,
                       label: Control.Arrow.$fApplicativeArrowMonad1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPjn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbPjr; else goto cbPjq;
       cbPjr: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fApplicativeArrowMonad1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPjq: // global
           I64[Hp - 24] = sat_sbNG4_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad2_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.6968691 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad_closure" {
     Control.Arrow.$fApplicativeArrowMonad_closure:
         const Control.Arrow.$fApplicativeArrowMonad_info;
 },
 sat_sbNGb_entry() //  [R1, R2]
         { info_tbl: [(cbPjR,
                       label: sat_sbNGb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPjR: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fApplicativeArrowMonad1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNGa_entry() //  [R1, R2, R3]
         { info_tbl: [(cbPjZ,
                       label: sat_sbNGa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPjZ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fApplicativeArrowMonad2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNG9_entry() //  [R1, R2, R3]
         { info_tbl: [(cbPk7,
                       label: sat_sbNG9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPk7: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fApplicativeArrowMonad4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNG8_entry() //  [R1, R2, R3]
         { info_tbl: [(cbPkf,
                       label: sat_sbNG8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPkf: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fAlternativeArrowMonad2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNG7_entry() //  [R1, R2]
         { info_tbl: [(cbPkn,
                       label: sat_sbNG7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPkn: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fApplicativeArrowMonad6_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNG6_entry() //  [R1]
         { info_tbl: [(cbPku,
                       label: sat_sbNG6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPku: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPkv; else goto cbPkw;
       cbPkv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPkw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fFunctorArrowMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad_entry() //  [R2]
         { info_tbl: [(cbPky,
                       label: Control.Arrow.$fApplicativeArrowMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPky: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cbPkC; else goto cbPkB;
       cbPkC: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = Control.Arrow.$fApplicativeArrowMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPkB: // global
           I64[Hp - 152] = sat_sbNGb_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbNGa_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbNG9_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbNG8_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbNG7_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbNG6_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 87;
           P64[Hp - 24] = Hp - 102;
           P64[Hp - 16] = Hp - 118;
           P64[Hp - 8] = Hp - 134;
           P64[Hp] = Hp - 151;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.711627947 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad_$c>>=_closure" {
     Control.Arrow.$fMonadArrowMonad_$c>>=_closure:
         const Control.Arrow.$fMonadArrowMonad_$c>>=_info;
 },
 sat_sbNGk_entry() //  [R1, R2]
         { info_tbl: [(cbPly,
                       label: sat_sbNGk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPly: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbPlC; else goto cbPlB;
       cbPlC: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPlB: // global
           _sbNGe::P64 = P64[R1 + 7];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sbNGe::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Tuple.()_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNGl_entry() //  [R1]
         { info_tbl: [(cbPlD,
                       label: sat_sbNGl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPlD: // global
           _sbNGl::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbPlE; else goto cbPlF;
       cbPlF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbPlH; else goto cbPlG;
       cbPlH: // global
           HpAlloc = 16;
           goto cbPlE;
       cbPlE: // global
           R1 = _sbNGl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPlG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNGl::P64;
           _sbNGe::P64 = P64[_sbNGl::P64 + 16];
           _sbNGf::P64 = P64[_sbNGl::P64 + 24];
           I64[Hp - 8] = sat_sbNGk_info;
           P64[Hp] = _sbNGe::P64;
           R2 = _sbNGf::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNGm_entry() //  [R1]
         { info_tbl: [(cbPlI,
                       label: sat_sbNGm_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPlI: // global
           _sbNGm::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbPlJ; else goto cbPlK;
       cbPlK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbPlM; else goto cbPlL;
       cbPlM: // global
           HpAlloc = 32;
           goto cbPlJ;
       cbPlJ: // global
           R1 = _sbNGm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPlL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNGm::P64;
           _sbNGd::P64 = P64[_sbNGm::P64 + 16];
           _sbNGe::P64 = P64[_sbNGm::P64 + 24];
           _sbNGf::P64 = P64[_sbNGm::P64 + 32];
           _sbNGg::P64 = P64[_sbNGm::P64 + 40];
           I64[Hp - 24] = sat_sbNGl_info;
           P64[Hp - 8] = _sbNGe::P64;
           P64[Hp] = _sbNGf::P64;
           R2 = _sbNGg::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sbNGd::P64;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNGh_entry() //  [R1]
         { info_tbl: [(cbPlR,
                       label: sat_sbNGh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPlR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPlS; else goto cbPlT;
       cbPlS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPlT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.app_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fMonadArrowMonad_$c>>=_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPlU,
                       label: Control.Arrow.$fMonadArrowMonad_$c>>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPlU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbPlV; else goto cbPlW;
       cbPlV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fMonadArrowMonad_$c>>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPlW: // global
           I64[Sp - 32] = block_cbPlb_info;
           _sbNGc::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbNGc::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Arrow.$p1ArrowApply_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPlb() //  [R1]
         { info_tbl: [(cbPlb,
                       label: block_cbPlb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPlb: // global
           I64[Sp - 8] = block_cbPlf_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPlf() //  [R1]
         { info_tbl: [(cbPlf,
                       label: block_cbPlf_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPlf: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbPm0; else goto cbPlZ;
       cbPm0: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbPlZ: // global
           I64[Hp - 64] = sat_sbNGm_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbNGh_info;
           P64[Hp] = P64[Sp + 16];
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 16;
           P64[Sp + 32] = Hp - 64;
           Sp = Sp + 16;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.728527701 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad_$cp1Monad_closure" {
     Control.Arrow.$fMonadArrowMonad_$cp1Monad_closure:
         const Control.Arrow.$fMonadArrowMonad_$cp1Monad_info;
 },
 sat_sbNGo_entry() //  [R1]
         { info_tbl: [(cbPmJ,
                       label: sat_sbNGo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPmJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPmK; else goto cbPmL;
       cbPmK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPmL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowApply_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fMonadArrowMonad_$cp1Monad_entry() //  [R2]
         { info_tbl: [(cbPmM,
                       label: Control.Arrow.$fMonadArrowMonad_$cp1Monad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPmM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPmQ; else goto cbPmP;
       cbPmQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Arrow.$fMonadArrowMonad_$cp1Monad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPmP: // global
           I64[Hp - 16] = sat_sbNGo_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Arrow.$fApplicativeArrowMonad_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.734553648 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad1_closure" {
     Control.Arrow.$fMonadArrowMonad1_closure:
         const Control.Arrow.$fMonadArrowMonad1_info;
 },
 sat_sbNGt_entry() //  [R1]
         { info_tbl: [(cbPn8,
                       label: sat_sbNGt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPn8: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fMonadArrowMonad1_entry() //  [R2, R3]
         { info_tbl: [(cbPnd,
                       label: Control.Arrow.$fMonadArrowMonad1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPnd: // global
           _sbNGq::P64 = R3;
           _sbNGp::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPne; else goto cbPnf;
       cbPnf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbPnh; else goto cbPng;
       cbPnh: // global
           HpAlloc = 16;
           goto cbPne;
       cbPne: // global
           R3 = _sbNGq::P64;
           R2 = _sbNGp::P64;
           R1 = Control.Arrow.$fMonadArrowMonad1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPng: // global
           I64[Hp - 8] = sat_sbNGt_info;
           P64[Hp] = _sbNGq::P64;
           I64[Sp - 16] = block_cbPnb_info;
           R2 = _sbNGp::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowApply_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPnb() //  [R1]
         { info_tbl: [(cbPnb,
                       label: block_cbPnb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPnb: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call Control.Arrow.arr_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.741970056 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad_$c>>_closure" {
     Control.Arrow.$fMonadArrowMonad_$c>>_closure:
         const Control.Arrow.$fMonadArrowMonad_$c>>_info;
 },
 sat_sbNGy_entry() //  [R1]
         { info_tbl: [(cbPnG,
                       label: sat_sbNGy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPnG: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fMonadArrowMonad_$c>>_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPnJ,
                       label: Control.Arrow.$fMonadArrowMonad_$c>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPnJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbPnN; else goto cbPnM;
       cbPnN: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fMonadArrowMonad_$c>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPnM: // global
           I64[Hp - 8] = sat_sbNGy_info;
           P64[Hp] = R4;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Control.Arrow.$fMonadArrowMonad_$c>>=_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.747237681 UTC

[section ""data" . lvl_rbNC6_closure" {
     lvl_rbNC6_closure:
         const lvl_rbNC6_info;
         const 0;
 },
 lvl_rbNC6_entry() //  [R2]
         { info_tbl: [(cbPnZ,
                       label: lvl_rbNC6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPnZ: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.751145549 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad_closure" {
     Control.Arrow.$fMonadArrowMonad_closure:
         const Control.Arrow.$fMonadArrowMonad_info;
         const 0;
 },
 sat_sbNGE_entry() //  [R1, R2]
         { info_tbl: [(cbPof,
                       label: sat_sbNGE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPof: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fMonadArrowMonad1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNGD_entry() //  [R1, R2, R3]
         { info_tbl: [(cbPon,
                       label: sat_sbNGD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPon: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fMonadArrowMonad_$c>>_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNGC_entry() //  [R1, R2, R3]
         { info_tbl: [(cbPov,
                       label: sat_sbNGC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPov: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fMonadArrowMonad_$c>>=_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNGB_entry() //  [R1]
         { info_tbl: [(cbPoC,
                       label: sat_sbNGB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPoC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPoD; else goto cbPoE;
       cbPoD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPoE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fMonadArrowMonad_$cp1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fMonadArrowMonad_entry() //  [R2]
         { info_tbl: [(cbPoG,
                       label: Control.Arrow.$fMonadArrowMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPoG: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cbPoK; else goto cbPoJ;
       cbPoK: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Control.Arrow.$fMonadArrowMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPoJ: // global
           I64[Hp - 112] = sat_sbNGE_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbNGD_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbNGC_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbNGB_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 94;
           P64[Hp - 8] = Hp - 111;
           P64[Hp] = lvl_rbNC6_closure+1;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.76370068 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad3_closure" {
     Control.Arrow.$fAlternativeArrowMonad3_closure:
         const Control.Arrow.$fAlternativeArrowMonad3_info;
 },
 Control.Arrow.$fAlternativeArrowMonad3_entry() //  [R2]
         { info_tbl: [(cbPpd,
                       label: Control.Arrow.$fAlternativeArrowMonad3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPpd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbPpe; else goto cbPpf;
       cbPpe: // global
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPpf: // global
           I64[Sp - 8] = block_cbPpb_info;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Arrow.$p1ArrowPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPpb() //  [R1]
         { info_tbl: [(cbPpb,
                       label: block_cbPpb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPpb: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Arrow.zeroArrow_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.769271217 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_closure" {
     Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_closure:
         const Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_info;
 },
 sat_sbNGJ_entry() //  [R1]
         { info_tbl: [(cbPpB,
                       label: sat_sbNGJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPpB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbPpC; else goto cbPpD;
       cbPpC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPpD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbPpz_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1ArrowPlus_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbPpz() //  [R1]
         { info_tbl: [(cbPpz,
                       label: block_cbPpz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPpz: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_entry() //  [R2]
         { info_tbl: [(cbPpH,
                       label: Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPpH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPpL; else goto cbPpK;
       cbPpL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPpK: // global
           I64[Hp - 16] = sat_sbNGJ_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Arrow.$fApplicativeArrowMonad_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.777093424 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad1_closure" {
     Control.Arrow.$fAlternativeArrowMonad1_closure:
         const Control.Arrow.$fAlternativeArrowMonad1_info;
 },
 Control.Arrow.$fAlternativeArrowMonad1_entry() //  []
         { info_tbl: [(cbPq1,
                       label: Control.Arrow.$fAlternativeArrowMonad1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPq1: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.782039941 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_$csome_closure" {
     Control.Arrow.$fAlternativeArrowMonad_$csome_closure:
         const Control.Arrow.$fAlternativeArrowMonad_$csome_info;
 },
 sat_sbNGV_entry() //  [R1]
         { info_tbl: [(cbPqB,
                       label: sat_sbNGV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPqB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPqC; else goto cbPqD;
       cbPqC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPqD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fAlternativeArrowMonad1_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNGW_entry() //  [R1]
         { info_tbl: [(cbPqE,
                       label: sat_sbNGW_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPqE: // global
           _sbNGW::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbPqF; else goto cbPqG;
       cbPqG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPqI; else goto cbPqH;
       cbPqI: // global
           HpAlloc = 24;
           goto cbPqF;
       cbPqF: // global
           R1 = _sbNGW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPqH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNGW::P64;
           _sbNGL::P64 = P64[_sbNGW::P64 + 16];
           _sbNGN::P64 = P64[_sbNGW::P64 + 24];
           _sbNGP::P64 = P64[_sbNGW::P64 + 32];
           I64[Hp - 16] = sat_sbNGV_info;
           P64[Hp] = _sbNGP::P64;
           R2 = _sbNGL::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbNGN::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call Control.Arrow.<+>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNGT_entry() //  [R1]
         { info_tbl: [(cbPqR,
                       label: sat_sbNGT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPqR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPqS; else goto cbPqT;
       cbPqS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPqT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNGU_entry() //  [R1]
         { info_tbl: [(cbPqW,
                       label: sat_sbNGU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPqW: // global
           _sbNGU::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbPqX; else goto cbPqY;
       cbPqY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPr0; else goto cbPqZ;
       cbPr0: // global
           HpAlloc = 24;
           goto cbPqX;
       cbPqX: // global
           R1 = _sbNGU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPqZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNGU::P64;
           _sbNGM::P64 = P64[_sbNGU::P64 + 16];
           _sbNGP::P64 = P64[_sbNGU::P64 + 24];
           I64[Hp - 16] = sat_sbNGT_info;
           P64[Hp] = _sbNGP::P64;
           I64[Sp - 40] = block_cbPqU_info;
           R2 = _sbNGP::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbNGM::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbPqU() //  [R1]
         { info_tbl: [(cbPqU,
                       label: block_cbPqU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPqU: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNGX_entry() //  [R1]
         { info_tbl: [(cbPr4,
                       label: sat_sbNGX_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPr4: // global
           _sbNGX::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbPr5; else goto cbPr6;
       cbPr6: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbPr8; else goto cbPr7;
       cbPr8: // global
           HpAlloc = 72;
           goto cbPr5;
       cbPr5: // global
           R1 = _sbNGX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPr7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNGX::P64;
           _sbNGL::P64 = P64[_sbNGX::P64 + 16];
           _sbNGM::P64 = P64[_sbNGX::P64 + 24];
           _sbNGN::P64 = P64[_sbNGX::P64 + 32];
           _sbNGP::P64 = P64[_sbNGX::P64 + 40];
           I64[Hp - 64] = sat_sbNGW_info;
           P64[Hp - 48] = _sbNGL::P64;
           P64[Hp - 40] = _sbNGN::P64;
           P64[Hp - 32] = _sbNGP::P64;
           I64[Hp - 24] = sat_sbNGU_info;
           P64[Hp - 8] = _sbNGM::P64;
           P64[Hp] = _sbNGP::P64;
           R2 = _sbNGP::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 64;
           Sp = Sp - 40;
           call Control.Arrow.&&&_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNGR_entry() //  [R1]
         { info_tbl: [(cbPrd,
                       label: sat_sbNGR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPrd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPre; else goto cbPrf;
       cbPre: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPrf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fAlternativeArrowMonad_$capp_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 some_v_sbNGN_entry() //  [R1]
         { info_tbl: [(cbPrg,
                       label: some_v_sbNGN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPrg: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbPri; else goto cbPrj;
       cbPri: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPrj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cbPqh_info;
           _sbNGL::P64 = P64[R1 + 16];
           R2 = _sbNGL::P64;
           P64[Sp - 40] = _sbNGL::P64;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = R1;
           Sp = Sp - 48;
           call Control.Arrow.$p1ArrowPlus_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbPqh() //  [R1]
         { info_tbl: [(cbPqh,
                       label: block_cbPqh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPqh: // global
           I64[Sp] = block_cbPql_info;
           R2 = R1;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbPql() //  [R1]
         { info_tbl: [(cbPql,
                       label: block_cbPql_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPql: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbPrn; else goto cbPrm;
       cbPrn: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbPrm: // global
           I64[Hp - 64] = sat_sbNGX_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbNGR_info;
           P64[Hp] = R1;
           I64[Sp + 8] = block_cbPrh_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 24] = Hp - 64;
           Sp = Sp + 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbPrh() //  [R1]
         { info_tbl: [(cbPrh,
                       label: block_cbPrh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPrh: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad_$csome_entry() //  [R2, R3]
         { info_tbl: [(cbPrs,
                       label: Control.Arrow.$fAlternativeArrowMonad_$csome_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPrs: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbPrw; else goto cbPrv;
       cbPrw: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_$csome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPrv: // global
           I64[Hp - 24] = some_v_sbNGN_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.809781638 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_$cmany_closure" {
     Control.Arrow.$fAlternativeArrowMonad_$cmany_closure:
         const Control.Arrow.$fAlternativeArrowMonad_$cmany_info;
 },
 $dApplicative_sbNH1_entry() //  [R1]
         { info_tbl: [(cbPsB,
                       label: $dApplicative_sbNH1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPsB: // global
           R2 = P64[R1 + 16];
           call Control.Arrow.$p1ArrowPlus_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dApplicative1_sbNH2_entry() //  [R1]
         { info_tbl: [(cbPsI,
                       label: $dApplicative1_sbNH2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPsI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPsJ; else goto cbPsK;
       cbPsJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPsK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNH7_entry() //  [R1]
         { info_tbl: [(cbPsP,
                       label: sat_sbNH7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPsP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPsQ; else goto cbPsR;
       cbPsQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPsR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fAlternativeArrowMonad1_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNH4_entry() //  [R1]
         { info_tbl: [(cbPt4,
                       label: sat_sbNH4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPt4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPt5; else goto cbPt6;
       cbPt5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPt6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNH5_entry() //  [R1]
         { info_tbl: [(cbPt9,
                       label: sat_sbNH5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPt9: // global
           _sbNH5::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbPta; else goto cbPtb;
       cbPtb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPtd; else goto cbPtc;
       cbPtd: // global
           HpAlloc = 24;
           goto cbPta;
       cbPta: // global
           R1 = _sbNH5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPtc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNH5::P64;
           _sbNGZ::P64 = P64[_sbNH5::P64 + 16];
           _sbNH2::P64 = P64[_sbNH5::P64 + 24];
           I64[Hp - 16] = sat_sbNH4_info;
           P64[Hp] = _sbNH2::P64;
           I64[Sp - 40] = block_cbPt7_info;
           R2 = _sbNH2::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbNGZ::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbPt7() //  [R1]
         { info_tbl: [(cbPt7,
                       label: block_cbPt7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPt7: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNH6_entry() //  [R1]
         { info_tbl: [(cbPth,
                       label: sat_sbNH6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPth: // global
           _sbNH6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPti; else goto cbPtj;
       cbPtj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbPtl; else goto cbPtk;
       cbPtl: // global
           HpAlloc = 32;
           goto cbPti;
       cbPti: // global
           R1 = _sbNH6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPtk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNH6::P64;
           _sbNGZ::P64 = P64[_sbNH6::P64 + 16];
           _sbNH0::P64 = P64[_sbNH6::P64 + 24];
           _sbNH2::P64 = P64[_sbNH6::P64 + 32];
           I64[Hp - 24] = sat_sbNH5_info;
           P64[Hp - 8] = _sbNGZ::P64;
           P64[Hp] = _sbNH2::P64;
           R4 = _sbNH0::P64;
           R3 = Hp - 24;
           R2 = _sbNH2::P64;
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad2_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 many_v_sbNH0_entry() //  [R1]
         { info_tbl: [(cbPtm,
                       label: many_v_sbNH0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPtm: // global
           _sbNH0::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbPtn; else goto cbPto;
       cbPto: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cbPtq; else goto cbPtp;
       cbPtq: // global
           HpAlloc = 112;
           goto cbPtn;
       cbPtn: // global
           R1 = _sbNH0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPtp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNH0::P64;
           _sbNGY::P64 = P64[_sbNH0::P64 + 16];
           _sbNGZ::P64 = P64[_sbNH0::P64 + 24];
           I64[Hp - 104] = $dApplicative_sbNH1_info;
           P64[Hp - 88] = _sbNGY::P64;
           I64[Hp - 80] = $dApplicative1_sbNH2_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = sat_sbNH7_info;
           _cbPsE::P64 = Hp - 80;
           P64[Hp - 40] = _cbPsE::P64;
           I64[Hp - 32] = sat_sbNH6_info;
           P64[Hp - 16] = _sbNGZ::P64;
           P64[Hp - 8] = _sbNH0::P64;
           P64[Hp] = _cbPsE::P64;
           R2 = _sbNGY::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call Control.Arrow.<+>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad_$cmany_entry() //  [R2, R3]
         { info_tbl: [(cbPtr,
                       label: Control.Arrow.$fAlternativeArrowMonad_$cmany_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPtr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbPtv; else goto cbPtu;
       cbPtv: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_$cmany_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPtu: // global
           I64[Hp - 24] = many_v_sbNH0_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.830063796 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_closure" {
     Control.Arrow.$fAlternativeArrowMonad_closure:
         const Control.Arrow.$fAlternativeArrowMonad_info;
 },
 sat_sbNHf_entry() //  [R1, R2]
         { info_tbl: [(cbPuh,
                       label: sat_sbNHf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPuh: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fAlternativeArrowMonad_$cmany_entry(R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNHe_entry() //  [R1, R2]
         { info_tbl: [(cbPup,
                       label: sat_sbNHe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPup: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fAlternativeArrowMonad_$csome_entry(R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNHd_entry() //  [R1, R2, R3]
         { info_tbl: [(cbPux,
                       label: sat_sbNHd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPux: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbPuy; else goto cbPuz;
       cbPuy: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPuz: // global
           _sbNHb::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbNHb::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Control.Arrow.<+>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbNHa_entry() //  [R1]
         { info_tbl: [(cbPuE,
                       label: sat_sbNHa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPuE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPuF; else goto cbPuG;
       cbPuF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPuG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad3_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNH9_entry() //  [R1]
         { info_tbl: [(cbPuL,
                       label: sat_sbNH9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPuL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPuM; else goto cbPuN;
       cbPuM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPuN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad_entry() //  [R2]
         { info_tbl: [(cbPuP,
                       label: Control.Arrow.$fAlternativeArrowMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPuP: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cbPuT; else goto cbPuS;
       cbPuT: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPuS: // global
           I64[Hp - 136] = sat_sbNHf_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbNHe_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbNHd_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbNHa_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbNH9_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 102;
           P64[Hp - 8] = Hp - 119;
           P64[Hp] = Hp - 135;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.844333314 UTC

[section ""data" . Control.Arrow.$fMonadPlusArrowMonad_closure" {
     Control.Arrow.$fMonadPlusArrowMonad_closure:
         const Control.Arrow.$fMonadPlusArrowMonad_info;
         const 0;
 },
 sat_sbNHn_entry() //  [R1, R2, R3]
         { info_tbl: [(cbPvv,
                       label: sat_sbNHn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPvv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbPvw; else goto cbPvx;
       cbPvw: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPvx: // global
           _sbNHl::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbNHl::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Control.Arrow.<+>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbNHk_entry() //  [R1]
         { info_tbl: [(cbPvC,
                       label: sat_sbNHk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPvC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPvD; else goto cbPvE;
       cbPvD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPvE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad3_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNHj_entry() //  [R1]
         { info_tbl: [(cbPvJ,
                       label: sat_sbNHj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPvJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPvK; else goto cbPvL;
       cbPvK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPvL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fMonadArrowMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNHi_entry() //  [R1]
         { info_tbl: [(cbPvQ,
                       label: sat_sbNHi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPvQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPvR; else goto cbPvS;
       cbPvR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPvS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fMonadPlusArrowMonad_entry() //  [R2, R3]
         { info_tbl: [(cbPvU,
                       label: Control.Arrow.$fMonadPlusArrowMonad_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPvU: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cbPvY; else goto cbPvX;
       cbPvY: // global
           HpAlloc = 128;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fMonadPlusArrowMonad_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPvX: // global
           I64[Hp - 120] = sat_sbNHn_info;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = sat_sbNHk_info;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sbNHj_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbNHi_info;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = GHC.Base.C:MonadPlus_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 118;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.856511367 UTC

[section ""data" . Control.Arrow.$fArrowLoop(->)_$cloop_closure" {
     Control.Arrow.$fArrowLoop(->)_$cloop_closure:
         const Control.Arrow.$fArrowLoop(->)_$cloop_info;
 },
 ds_sbNHq_entry() //  [R1]
         { info_tbl: [(cbPwy,
                       label: ds_sbNHq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPwy: // global
           _sbNHq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPwz; else goto cbPwA;
       cbPwA: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbPwC; else goto cbPwB;
       cbPwC: // global
           HpAlloc = 48;
           goto cbPwz;
       cbPwz: // global
           R1 = _sbNHq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPwB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNHq::P64;
           _sbNHo::P64 = P64[_sbNHq::P64 + 16];
           _sbNHp::P64 = P64[_sbNHq::P64 + 24];
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sbNHq::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbNHp::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 15;
           R1 = _sbNHo::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowLoop(->)_$cloop_entry() //  [R2, R3]
         { info_tbl: [(cbPwG,
                       label: Control.Arrow.$fArrowLoop(->)_$cloop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPwG: // global
           _sbNHp::P64 = R3;
           _sbNHo::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cbPwH; else goto cbPwI;
       cbPwI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbPwK; else goto cbPwJ;
       cbPwK: // global
           HpAlloc = 32;
           goto cbPwH;
       cbPwH: // global
           R3 = _sbNHp::P64;
           R2 = _sbNHo::P64;
           R1 = Control.Arrow.$fArrowLoop(->)_$cloop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPwJ: // global
           I64[Hp - 24] = ds_sbNHq_info;
           P64[Hp - 8] = _sbNHo::P64;
           P64[Hp] = _sbNHp::P64;
           I64[Sp - 8] = block_cbPwD_info;
           R1 = Hp - 24;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubPwO; else goto cbPwE;
       ubPwO: // global
           call _cbPwD(R1) args: 0, res: 0, upd: 0;
       cbPwE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbPwD() //  [R1]
         { info_tbl: [(cbPwD,
                       label: block_cbPwD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPwD: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.866858352 UTC

[section ""data" . Control.Arrow.$fArrowLoopKleisli1_closure" {
     Control.Arrow.$fArrowLoopKleisli1_closure:
         const Control.Arrow.$fArrowLoopKleisli1_info;
 },
 sat_sbNHN_entry() //  [R1, R2]
         { info_tbl: [(cbPxh,
                       label: sat_sbNHN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPxh: // global
           _sbNHI::P64 = R2;
           _sbNHN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPxi; else goto cbPxj;
       cbPxj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPxl; else goto cbPxk;
       cbPxl: // global
           HpAlloc = 24;
           goto cbPxi;
       cbPxi: // global
           R2 = _sbNHI::P64;
           R1 = _sbNHN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPxk: // global
           _sbNHC::P64 = P64[_sbNHN::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbNHI::P64;
           R2 = _sbNHC::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbNHE_entry() //  [R1]
         { info_tbl: [(cbPxz,
                       label: sat_sbNHE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPxz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPxA; else goto cbPxB;
       cbPxA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPxB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Tuple.snd_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNHG_entry() //  [R1, R2]
         { info_tbl: [(cbPxD,
                       label: sat_sbNHG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPxD: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbPxH; else goto cbPxG;
       cbPxH: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPxG: // global
           _sbNHA::P64 = P64[R1 + 7];
           _sbNHB::P64 = P64[R1 + 15];
           I64[Hp - 40] = sat_sbNHE_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbNHB::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 15;
           R1 = _sbNHA::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNHH_entry() //  [R1]
         { info_tbl: [(cbPxI,
                       label: sat_sbNHH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPxI: // global
           _sbNHH::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbPxJ; else goto cbPxK;
       cbPxK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPxM; else goto cbPxL;
       cbPxM: // global
           HpAlloc = 24;
           goto cbPxJ;
       cbPxJ: // global
           R1 = _sbNHH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPxL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNHH::P64;
           _sbNHz::P64 = P64[_sbNHH::P64 + 16];
           _sbNHA::P64 = P64[_sbNHH::P64 + 24];
           _sbNHB::P64 = P64[_sbNHH::P64 + 32];
           I64[Hp - 16] = sat_sbNHG_info;
           P64[Hp - 8] = _sbNHA::P64;
           P64[Hp] = _sbNHB::P64;
           R2 = _sbNHz::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowLoopKleisli1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPxN,
                       label: Control.Arrow.$fArrowLoopKleisli1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPxN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPxO; else goto cbPxP;
       cbPxO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fArrowLoopKleisli1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPxP: // global
           I64[Sp - 32] = block_cbPx7_info;
           _sbNHz::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbNHz::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPx7() //  [R1]
         { info_tbl: [(cbPx7,
                       label: block_cbPx7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPx7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbPxS; else goto cbPxR;
       cbPxS: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbPxR: // global
           I64[Hp - 48] = sat_sbNHN_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sbNHH_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 32;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp + 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.882003383 UTC

[section ""data" . lvl1_rbNC7_closure" {
     lvl1_rbNC7_closure:
         const lvl1_rbNC7_info;
 },
 lvl1_rbNC7_entry() //  [R2]
         { info_tbl: [(cbPyz,
                       label: lvl1_rbNC7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPyz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbPyA; else goto cbPyB;
       cbPyA: // global
           R2 = R2;
           R1 = lvl1_rbNC7_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPyB: // global
           I64[Sp - 8] = block_cbPys_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubPyI; else goto cbPyt;
       ubPyI: // global
           call _cbPys(R1) args: 0, res: 0, upd: 0;
       cbPyt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbPys() //  [R1]
         { info_tbl: [(cbPys,
                       label: block_cbPys_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPys: // global
           if (R1 & 7 == 1) goto cbPyw; else goto cbPyx;
       cbPyw: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbPyx: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.888998365 UTC

[section ""data" . Control.Arrow.$dm|||_closure" {
     Control.Arrow.$dm|||_closure:
         const Control.Arrow.$dm|||_info;
 },
 sat_sbNHY_entry() //  [R1]
         { info_tbl: [(cbPz6,
                       label: sat_sbNHY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPz6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbPz7; else goto cbPz8;
       cbPz7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPz8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Arrow.+++_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNHX_entry() //  [R1]
         { info_tbl: [(cbPzd,
                       label: sat_sbNHX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPzd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPze; else goto cbPzf;
       cbPze: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPzf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl1_rbNC7_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dm|||_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPzg,
                       label: Control.Arrow.$dm|||_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPzg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPzi; else goto cbPzj;
       cbPzi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$dm|||_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPzj: // global
           I64[Sp - 32] = block_cbPyY_info;
           _sbNHS::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbNHS::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Arrow.$p1ArrowChoice_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPyY() //  [R1]
         { info_tbl: [(cbPyY,
                       label: block_cbPyY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPyY: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbPzm; else goto cbPzl;
       cbPzm: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbPzl: // global
           I64[Hp - 56] = sat_sbNHY_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           I64[Hp - 16] = sat_sbNHX_info;
           P64[Hp] = R1;
           I64[Sp + 8] = block_cbPzh_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 24] = Hp - 56;
           Sp = Sp + 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPzh() //  [R1]
         { info_tbl: [(cbPzh,
                       label: block_cbPzh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPzh: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.901069301 UTC

[section ""data" . mirror_rbNC8_closure" {
     mirror_rbNC8_closure:
         const mirror_rbNC8_info;
 },
 mirror_rbNC8_entry() //  [R2]
         { info_tbl: [(cbPA2,
                       label: mirror_rbNC8_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPA2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbPA3; else goto cbPA4;
       cbPA3: // global
           R2 = R2;
           R1 = mirror_rbNC8_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPA4: // global
           I64[Sp - 8] = block_cbPzV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubPAh; else goto cbPzW;
       ubPAh: // global
           call _cbPzV(R1) args: 0, res: 0, upd: 0;
       cbPzW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbPzV() //  [R1]
         { info_tbl: [(cbPzV,
                       label: block_cbPzV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPzV: // global
           if (R1 & 7 == 1) goto cbPzZ; else goto cbPA0;
       cbPzZ: // global
           Hp = Hp + 16;
           _sbNI0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbPAg; else goto cbPA9;
       cbPA9: // global
           _sbNI1::P64 = P64[_sbNI0::P64 + 7];
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = _sbNI1::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbPA0: // global
           Hp = Hp + 16;
           _sbNI0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbPAg; else goto cbPAf;
       cbPAg: // global
           HpAlloc = 16;
           R1 = _sbNI0::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbPAf: // global
           _sbNI2::P64 = P64[_sbNI0::P64 + 6];
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = _sbNI2::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.908749605 UTC

[section ""data" . Control.Arrow.$dm+++_closure" {
     Control.Arrow.$dm+++_closure:
         const Control.Arrow.$dm+++_info;
 },
 sat_sbNIb_entry() //  [R1]
         { info_tbl: [(cbPAT,
                       label: sat_sbNIb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPAT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPAU; else goto cbPAV;
       cbPAU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPAV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.left_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNIa_entry() //  [R1]
         { info_tbl: [(cbPB0,
                       label: sat_sbNIa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPB0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPB1; else goto cbPB2;
       cbPB1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPB2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = mirror_rbNC8_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNIc_entry() //  [R1]
         { info_tbl: [(cbPB3,
                       label: sat_sbNIc_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPB3: // global
           _sbNIc::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbPB4; else goto cbPB5;
       cbPB5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbPB7; else goto cbPB6;
       cbPB7: // global
           HpAlloc = 56;
           goto cbPB4;
       cbPB4: // global
           R1 = _sbNIc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPB6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNIc::P64;
           _sbNI3::P64 = P64[_sbNIc::P64 + 16];
           _sbNI4::P64 = P64[_sbNIc::P64 + 24];
           _sbNI6::P64 = P64[_sbNIc::P64 + 32];
           _sbNI7::P64 = P64[_sbNIc::P64 + 40];
           I64[Hp - 48] = sat_sbNIb_info;
           P64[Hp - 32] = _sbNI3::P64;
           P64[Hp - 24] = _sbNI4::P64;
           I64[Hp - 16] = sat_sbNIa_info;
           P64[Hp] = _sbNI6::P64;
           R2 = _sbNI7::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNI9_entry() //  [R1]
         { info_tbl: [(cbPBc,
                       label: sat_sbNI9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPBc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPBd; else goto cbPBe;
       cbPBd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPBe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.left_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNId_entry() //  [R1]
         { info_tbl: [(cbPBf,
                       label: sat_sbNId_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPBf: // global
           _sbNId::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbPBg; else goto cbPBh;
       cbPBh: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbPBj; else goto cbPBi;
       cbPBj: // global
           HpAlloc = 80;
           goto cbPBg;
       cbPBg: // global
           R1 = _sbNId::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPBi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNId::P64;
           _sbNI3::P64 = P64[_sbNId::P64 + 16];
           _sbNI4::P64 = P64[_sbNId::P64 + 24];
           _sbNI5::P64 = P64[_sbNId::P64 + 32];
           _sbNI6::P64 = P64[_sbNId::P64 + 40];
           _sbNI7::P64 = P64[_sbNId::P64 + 48];
           I64[Hp - 72] = sat_sbNIc_info;
           P64[Hp - 56] = _sbNI3::P64;
           P64[Hp - 48] = _sbNI4::P64;
           P64[Hp - 40] = _sbNI6::P64;
           P64[Hp - 32] = _sbNI7::P64;
           I64[Hp - 24] = sat_sbNI9_info;
           P64[Hp - 8] = _sbNI3::P64;
           P64[Hp] = _sbNI5::P64;
           R2 = _sbNI7::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNI8_entry() //  [R1]
         { info_tbl: [(cbPBo,
                       label: sat_sbNI8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPBo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPBp; else goto cbPBq;
       cbPBp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPBq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = mirror_rbNC8_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dm+++_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPBr,
                       label: Control.Arrow.$dm+++_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPBr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbPBs; else goto cbPBt;
       cbPBs: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$dm+++_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPBt: // global
           I64[Sp - 32] = block_cbPAz_info;
           _sbNI3::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbNI3::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Arrow.$p1ArrowChoice_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPAz() //  [R1]
         { info_tbl: [(cbPAz,
                       label: block_cbPAz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPAz: // global
           I64[Sp - 8] = block_cbPAD_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPAD() //  [R1]
         { info_tbl: [(cbPAD,
                       label: block_cbPAD_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPAD: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbPBx; else goto cbPBw;
       cbPBx: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbPBw: // global
           I64[Hp - 72] = sat_sbNId_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 32];
           _sbNI6::P64 = P64[Sp + 8];
           P64[Hp - 32] = _sbNI6::P64;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbNI8_info;
           P64[Hp] = _sbNI6::P64;
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 16;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.9311506 UTC

[section ""data" . Control.Arrow.$dmright_closure" {
     Control.Arrow.$dmright_closure:
         const Control.Arrow.$dmright_info;
 },
 sat_sbNIh_entry() //  [R1]
         { info_tbl: [(cbPCs,
                       label: sat_sbNIh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPCs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbPCw; else goto cbPCx;
       cbPCw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPCx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbPCq_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1ArrowChoice_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbPCq() //  [R1]
         { info_tbl: [(cbPCq,
                       label: block_cbPCq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPCq: // global
           I64[Sp] = block_cbPCv_info;
           R2 = R1;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbPCv() //  [R1]
         { info_tbl: [(cbPCv,
                       label: block_cbPCv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPCv: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Category.id_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dmright_entry() //  [R2]
         { info_tbl: [(cbPCD,
                       label: Control.Arrow.$dmright_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPCD: // global
           _sbNIe::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPCE; else goto cbPCF;
       cbPCF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPCH; else goto cbPCG;
       cbPCH: // global
           HpAlloc = 24;
           goto cbPCE;
       cbPCE: // global
           R2 = _sbNIe::P64;
           R1 = Control.Arrow.$dmright_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPCG: // global
           I64[Hp - 16] = sat_sbNIh_info;
           P64[Hp] = _sbNIe::P64;
           R2 = _sbNIe::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Control.Arrow.+++_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.9405109 UTC

[section ""data" . Control.Arrow.$dmleft_closure" {
     Control.Arrow.$dmleft_closure:
         const Control.Arrow.$dmleft_info;
 },
 sat_sbNIm_entry() //  [R1]
         { info_tbl: [(cbPD8,
                       label: sat_sbNIm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPD8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbPDc; else goto cbPDd;
       cbPDc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPDd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbPD6_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1ArrowChoice_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbPD6() //  [R1]
         { info_tbl: [(cbPD6,
                       label: block_cbPD6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPD6: // global
           I64[Sp] = block_cbPDb_info;
           R2 = R1;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbPDb() //  [R1]
         { info_tbl: [(cbPDb,
                       label: block_cbPDb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPDb: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Category.id_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dmleft_entry() //  [R2, R3]
         { info_tbl: [(cbPDj,
                       label: Control.Arrow.$dmleft_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPDj: // global
           _sbNIj::P64 = R3;
           _sbNIi::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbPDk; else goto cbPDl;
       cbPDl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPDn; else goto cbPDm;
       cbPDn: // global
           HpAlloc = 24;
           goto cbPDk;
       cbPDk: // global
           R3 = _sbNIj::P64;
           R2 = _sbNIi::P64;
           R1 = Control.Arrow.$dmleft_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPDm: // global
           I64[Hp - 16] = sat_sbNIm_info;
           P64[Hp] = _sbNIi::P64;
           R2 = _sbNIi::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbNIj::P64;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Control.Arrow.+++_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.949461017 UTC

[section ""data" . lvl2_rbNC9_closure" {
     lvl2_rbNC9_closure:
         const lvl2_rbNC9_info;
 },
 lvl2_rbNC9_entry() //  [R2]
         { info_tbl: [(cbPDJ,
                       label: lvl2_rbNC9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPDJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPDN; else goto cbPDM;
       cbPDN: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = lvl2_rbNC9_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPDM: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.953594887 UTC

[section ""data" . Control.Arrow.$dm&&&_closure" {
     Control.Arrow.$dm&&&_closure:
         const Control.Arrow.$dm&&&_info;
 },
 sat_sbNIt_entry() //  [R1]
         { info_tbl: [(cbPE1,
                       label: sat_sbNIt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPE1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPE2; else goto cbPE3;
       cbPE2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPE3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl2_rbNC9_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNIs_entry() //  [R1]
         { info_tbl: [(cbPE8,
                       label: sat_sbNIs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPE8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbPE9; else goto cbPEa;
       cbPE9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPEa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Arrow.***_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dm&&&_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPEd,
                       label: Control.Arrow.$dm&&&_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPEd: // global
           _sbNIq::P64 = R4;
           _sbNIp::P64 = R3;
           _sbNIo::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbPEe; else goto cbPEf;
       cbPEf: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbPEh; else goto cbPEg;
       cbPEh: // global
           HpAlloc = 64;
           goto cbPEe;
       cbPEe: // global
           R4 = _sbNIq::P64;
           R3 = _sbNIp::P64;
           R2 = _sbNIo::P64;
           R1 = Control.Arrow.$dm&&&_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPEg: // global
           I64[Hp - 56] = sat_sbNIt_info;
           P64[Hp - 40] = _sbNIo::P64;
           I64[Hp - 32] = sat_sbNIs_info;
           P64[Hp - 16] = _sbNIo::P64;
           P64[Hp - 8] = _sbNIp::P64;
           P64[Hp] = _sbNIq::P64;
           I64[Sp - 24] = block_cbPEb_info;
           R2 = _sbNIo::P64;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPEb() //  [R1]
         { info_tbl: [(cbPEb,
                       label: block_cbPEb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPEb: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbPDX::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbPDX::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.963396269 UTC

[section ""data" . swap_rbNCa_closure" {
     swap_rbNCa_closure:
         const swap_rbNCa_info;
 },
 swap_rbNCa_entry() //  [R2]
         { info_tbl: [(cbPEN,
                       label: swap_rbNCa_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPEN: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbPER; else goto cbPEQ;
       cbPER: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = swap_rbNCa_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPEQ: // global
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.969002075 UTC

[section ""data" . Control.Arrow.$dm***_closure" {
     Control.Arrow.$dm***_closure:
         const Control.Arrow.$dm***_info;
 },
 sat_sbNIK_entry() //  [R1]
         { info_tbl: [(cbPFj,
                       label: sat_sbNIK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPFj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPFk; else goto cbPFl;
       cbPFk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPFl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.first_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNIJ_entry() //  [R1]
         { info_tbl: [(cbPFq,
                       label: sat_sbNIJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPFq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPFr; else goto cbPFs;
       cbPFr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPFs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = swap_rbNCa_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNIL_entry() //  [R1]
         { info_tbl: [(cbPFt,
                       label: sat_sbNIL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPFt: // global
           _sbNIL::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbPFu; else goto cbPFv;
       cbPFv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbPFx; else goto cbPFw;
       cbPFx: // global
           HpAlloc = 56;
           goto cbPFu;
       cbPFu: // global
           R1 = _sbNIL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPFw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNIL::P64;
           _sbNID::P64 = P64[_sbNIL::P64 + 16];
           _sbNIE::P64 = P64[_sbNIL::P64 + 24];
           _sbNIG::P64 = P64[_sbNIL::P64 + 32];
           I64[Hp - 48] = sat_sbNIK_info;
           P64[Hp - 32] = _sbNID::P64;
           P64[Hp - 24] = _sbNIE::P64;
           I64[Hp - 16] = sat_sbNIJ_info;
           P64[Hp] = _sbNID::P64;
           R2 = _sbNIG::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNII_entry() //  [R1]
         { info_tbl: [(cbPFC,
                       label: sat_sbNII_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPFC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPFD; else goto cbPFE;
       cbPFD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPFE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.first_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNIM_entry() //  [R1]
         { info_tbl: [(cbPFF,
                       label: sat_sbNIM_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPFF: // global
           _sbNIM::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbPFG; else goto cbPFH;
       cbPFH: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbPFJ; else goto cbPFI;
       cbPFJ: // global
           HpAlloc = 72;
           goto cbPFG;
       cbPFG: // global
           R1 = _sbNIM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPFI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNIM::P64;
           _sbNID::P64 = P64[_sbNIM::P64 + 16];
           _sbNIE::P64 = P64[_sbNIM::P64 + 24];
           _sbNIF::P64 = P64[_sbNIM::P64 + 32];
           _sbNIG::P64 = P64[_sbNIM::P64 + 40];
           I64[Hp - 64] = sat_sbNIL_info;
           P64[Hp - 48] = _sbNID::P64;
           P64[Hp - 40] = _sbNIE::P64;
           P64[Hp - 32] = _sbNIG::P64;
           I64[Hp - 24] = sat_sbNII_info;
           P64[Hp - 8] = _sbNID::P64;
           P64[Hp] = _sbNIF::P64;
           R2 = _sbNIG::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 64;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNIH_entry() //  [R1]
         { info_tbl: [(cbPFO,
                       label: sat_sbNIH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPFO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPFP; else goto cbPFQ;
       cbPFP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPFQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = swap_rbNCa_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dm***_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPFR,
                       label: Control.Arrow.$dm***_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPFR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPFS; else goto cbPFT;
       cbPFS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$dm***_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPFT: // global
           I64[Sp - 32] = block_cbPF3_info;
           _sbNID::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbNID::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPF3() //  [R1]
         { info_tbl: [(cbPF3,
                       label: block_cbPF3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPF3: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbPFW; else goto cbPFV;
       cbPFW: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbPFV: // global
           I64[Hp - 64] = sat_sbNIM_info;
           _sbNID::P64 = P64[Sp + 8];
           P64[Hp - 48] = _sbNID::P64;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbNIH_info;
           P64[Hp] = _sbNID::P64;
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 24] = Hp - 64;
           Sp = Sp + 8;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:40.988851069 UTC

[section ""data" . Control.Arrow.$fArrowKleisli2_closure" {
     Control.Arrow.$fArrowKleisli2_closure:
         const Control.Arrow.$fArrowKleisli2_info;
 },
 sat_sbNJg_entry() //  [R1, R2]
         { info_tbl: [(cbPGP,
                       label: sat_sbNJg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPGP: // global
           _sbNJ6::P64 = R2;
           _sbNJg::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPGQ; else goto cbPGR;
       cbPGR: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbPGT; else goto cbPGS;
       cbPGT: // global
           HpAlloc = 72;
           goto cbPGQ;
       cbPGQ: // global
           R2 = _sbNJ6::P64;
           R1 = _sbNJg::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPGS: // global
           _sbNIN::P64 = P64[_sbNJg::P64 + 7];
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sbNJ6::P64;
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sbNJ6::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = _sbNIN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbNJ4_entry() //  [R1, R2]
         { info_tbl: [(cbPH3,
                       label: sat_sbNJ4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPH3: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Arrow.$fArrowKleisli3_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJ2_entry() //  [R1, R2]
         { info_tbl: [(cbPHi,
                       label: sat_sbNJ2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPHi: // global
           _sbNIS::P64 = R2;
           _sbNJ2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPHj; else goto cbPHk;
       cbPHk: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbPHm; else goto cbPHl;
       cbPHm: // global
           HpAlloc = 72;
           goto cbPHj;
       cbPHj: // global
           R2 = _sbNIS::P64;
           R1 = _sbNJ2::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPHl: // global
           _sbNIN::P64 = P64[_sbNJ2::P64 + 7];
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sbNIS::P64;
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sbNIS::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = _sbNIN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbNIR_entry() //  [R1]
         { info_tbl: [(cbPHr,
                       label: sat_sbNIR_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPHr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPHs; else goto cbPHt;
       cbPHs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPHt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowKleisli3_entry(R4,
                                                    R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNJ3_entry() //  [R1]
         { info_tbl: [(cbPHu,
                       label: sat_sbNJ3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPHu: // global
           _sbNJ3::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbPHv; else goto cbPHw;
       cbPHw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbPHy; else goto cbPHx;
       cbPHy: // global
           HpAlloc = 56;
           goto cbPHv;
       cbPHv: // global
           R1 = _sbNJ3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPHx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNJ3::P64;
           _sbNIN::P64 = P64[_sbNJ3::P64 + 16];
           _sbNIO::P64 = P64[_sbNJ3::P64 + 24];
           _sbNIQ::P64 = P64[_sbNJ3::P64 + 32];
           I64[Hp - 48] = sat_sbNJ2_info;
           P64[Hp - 40] = _sbNIN::P64;
           I64[Hp - 32] = sat_sbNIR_info;
           P64[Hp - 16] = _sbNIN::P64;
           P64[Hp - 8] = _sbNIO::P64;
           P64[Hp] = _sbNIQ::P64;
           R2 = _sbNIN::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 47;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNJ5_entry() //  [R1]
         { info_tbl: [(cbPHz,
                       label: sat_sbNJ5_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPHz: // global
           _sbNJ5::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbPHA; else goto cbPHB;
       cbPHB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbPHD; else goto cbPHC;
       cbPHD: // global
           HpAlloc = 64;
           goto cbPHA;
       cbPHA: // global
           R1 = _sbNJ5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPHC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNJ5::P64;
           _sbNIN::P64 = P64[_sbNJ5::P64 + 16];
           _sbNIO::P64 = P64[_sbNJ5::P64 + 24];
           _sbNIP::P64 = P64[_sbNJ5::P64 + 32];
           _sbNIQ::P64 = P64[_sbNJ5::P64 + 40];
           I64[Hp - 56] = sat_sbNJ4_info;
           P64[Hp - 48] = _sbNIN::P64;
           P64[Hp - 40] = _sbNIP::P64;
           I64[Hp - 32] = sat_sbNJ3_info;
           P64[Hp - 16] = _sbNIN::P64;
           P64[Hp - 8] = _sbNIO::P64;
           P64[Hp] = _sbNIQ::P64;
           R2 = _sbNIN::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbPHE,
                       label: Control.Arrow.$fArrowKleisli2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPHE: // global
           _sbNIQ::P64 = R5;
           _sbNIP::P64 = R4;
           _sbNIO::P64 = R3;
           _sbNIN::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbPHF; else goto cbPHG;
       cbPHG: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbPHI; else goto cbPHH;
       cbPHI: // global
           HpAlloc = 64;
           goto cbPHF;
       cbPHF: // global
           R5 = _sbNIQ::P64;
           R4 = _sbNIP::P64;
           R3 = _sbNIO::P64;
           R2 = _sbNIN::P64;
           R1 = Control.Arrow.$fArrowKleisli2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPHH: // global
           I64[Hp - 56] = sat_sbNJg_info;
           P64[Hp - 48] = _sbNIN::P64;
           I64[Hp - 40] = sat_sbNJ5_info;
           P64[Hp - 24] = _sbNIN::P64;
           P64[Hp - 16] = _sbNIO::P64;
           P64[Hp - 8] = _sbNIP::P64;
           P64[Hp] = _sbNIQ::P64;
           R2 = _sbNIN::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 40;
           P64[Sp - 8] = Hp - 55;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.006636866 UTC

[section ""data" . Control.Arrow.$fArrowKleisli1_closure" {
     Control.Arrow.$fArrowKleisli1_closure:
         const Control.Arrow.$fArrowKleisli1_info;
 },
 sat_sbNJn_entry() //  [R1, R2]
         { info_tbl: [(cbPIw,
                       label: sat_sbNJn_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPIw: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Arrow.$fArrowKleisli2_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJm_entry() //  [R1]
         { info_tbl: [(cbPIE,
                       label: sat_sbNJm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPIE: // global
           _sbNJm::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbPIF; else goto cbPIG;
       cbPIG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPII; else goto cbPIH;
       cbPII: // global
           HpAlloc = 24;
           goto cbPIF;
       cbPIF: // global
           R1 = _sbNJm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPIH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNJm::P64;
           _sbNJh::P64 = P64[_sbNJm::P64 + 16];
           _sbNJk::P64 = P64[_sbNJm::P64 + 24];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbNJk::P64;
           P64[Hp] = _sbNJk::P64;
           R2 = _sbNJh::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbPIJ,
                       label: Control.Arrow.$fArrowKleisli1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPIJ: // global
           _sbNJk::P64 = R5;
           _sbNJj::P64 = R4;
           _sbNJi::P64 = R3;
           _sbNJh::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbPIK; else goto cbPIL;
       cbPIL: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbPIN; else goto cbPIM;
       cbPIN: // global
           HpAlloc = 64;
           goto cbPIK;
       cbPIK: // global
           R5 = _sbNJk::P64;
           R4 = _sbNJj::P64;
           R3 = _sbNJi::P64;
           R2 = _sbNJh::P64;
           R1 = Control.Arrow.$fArrowKleisli1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPIM: // global
           I64[Hp - 56] = sat_sbNJn_info;
           P64[Hp - 48] = _sbNJh::P64;
           P64[Hp - 40] = _sbNJi::P64;
           P64[Hp - 32] = _sbNJj::P64;
           I64[Hp - 24] = sat_sbNJm_info;
           P64[Hp - 8] = _sbNJh::P64;
           P64[Hp] = _sbNJk::P64;
           R2 = _sbNJh::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 55;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.01713886 UTC

[section ""data" . Control.Arrow.$fArrowKleisli_closure" {
     Control.Arrow.$fArrowKleisli_closure:
         const Control.Arrow.$fArrowKleisli_info;
 },
 sat_sbNJu_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbPJc,
                       label: sat_sbNJu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPJc: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fArrowKleisli1_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJt_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbPJk,
                       label: sat_sbNJt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPJk: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fArrowKleisli2_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJs_entry() //  [R1, R2, R3]
         { info_tbl: [(cbPJs,
                       label: sat_sbNJs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPJs: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowKleisli4_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJr_entry() //  [R1, R2, R3]
         { info_tbl: [(cbPJA,
                       label: sat_sbNJr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPJA: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowKleisli3_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJq_entry() //  [R1, R2, R3]
         { info_tbl: [(cbPJI,
                       label: sat_sbNJq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPJI: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowKleisli5_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJp_entry() //  [R1]
         { info_tbl: [(cbPJP,
                       label: sat_sbNJp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPJP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPJQ; else goto cbPJR;
       cbPJQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPJR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fCategoryTYPEKleisli_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli_entry() //  [R2]
         { info_tbl: [(cbPJT,
                       label: Control.Arrow.$fArrowKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPJT: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cbPJX; else goto cbPJW;
       cbPJX: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = Control.Arrow.$fArrowKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPJW: // global
           I64[Hp - 152] = sat_sbNJu_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbNJt_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbNJs_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbNJr_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbNJq_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbNJp_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = Control.Arrow.C:Arrow_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 86;
           P64[Hp - 24] = Hp - 102;
           P64[Hp - 16] = Hp - 118;
           P64[Hp - 8] = Hp - 133;
           P64[Hp] = Hp - 149;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.031203355 UTC

[section ""data" . Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_closure" {
     Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_closure:
         const Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_info;
 },
 sat_sbNJw_entry() //  [R1]
         { info_tbl: [(cbPKA,
                       label: sat_sbNJw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPKA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPKB; else goto cbPKC;
       cbPKB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPKC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_entry() //  [R2]
         { info_tbl: [(cbPKD,
                       label: Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPKD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPKH; else goto cbPKG;
       cbPKH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPKG: // global
           I64[Hp - 16] = sat_sbNJw_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Arrow.$fArrowKleisli_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.037028571 UTC

[section ""data" . Control.Arrow.$fArrowLoopKleisli_closure" {
     Control.Arrow.$fArrowLoopKleisli_closure:
         const Control.Arrow.$fArrowLoopKleisli_info;
 },
 sat_sbNJz_entry() //  [R1, R2, R3]
         { info_tbl: [(cbPKZ,
                       label: sat_sbNJz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPKZ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowLoopKleisli1_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNJy_entry() //  [R1]
         { info_tbl: [(cbPL6,
                       label: sat_sbNJy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPL6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPL7; else goto cbPL8;
       cbPL7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPL8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowLoopKleisli_entry() //  [R2]
         { info_tbl: [(cbPLa,
                       label: Control.Arrow.$fArrowLoopKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPLa: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbPLe; else goto cbPLd;
       cbPLe: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Arrow.$fArrowLoopKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPLd: // global
           I64[Hp - 56] = sat_sbNJz_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbNJy_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Arrow.C:ArrowLoop_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 54;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.044741699 UTC

[section ""data" . lvl3_rbNCb_closure" {
     lvl3_rbNCb_closure:
         const lvl3_rbNCb_info;
 },
 lvl3_rbNCb_entry() //  [R2]
         { info_tbl: [(cbPLA,
                       label: lvl3_rbNCb_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPLA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbPLB; else goto cbPLC;
       cbPLB: // global
           R2 = R2;
           R1 = lvl3_rbNCb_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPLC: // global
           I64[Sp - 8] = block_cbPLx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubPLG; else goto cbPLy;
       ubPLG: // global
           call _cbPLx(R1) args: 0, res: 0, upd: 0;
       cbPLy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbPLx() //  [R1]
         { info_tbl: [(cbPLx,
                       label: block_cbPLx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPLx: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.050577549 UTC

[section ""data" . Control.Arrow.$fArrowApplyKleisli_closure" {
     Control.Arrow.$fArrowApplyKleisli_closure:
         const Control.Arrow.$fArrowApplyKleisli_info;
 },
 sat_sbNJF_entry() //  [R1]
         { info_tbl: [(cbPLY,
                       label: sat_sbNJF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPLY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPLZ; else goto cbPM0;
       cbPLZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPM0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowKleisli_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowApplyKleisli_entry() //  [R2]
         { info_tbl: [(cbPM2,
                       label: Control.Arrow.$fArrowApplyKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPM2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbPM6; else goto cbPM5;
       cbPM6: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Control.Arrow.$fArrowApplyKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPM5: // global
           I64[Hp - 40] = sat_sbNJF_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Arrow.C:ArrowApply_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = lvl3_rbNCb_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.057260146 UTC

[section ""data" . Control.Arrow.$fArrowChoiceKleisli1_closure" {
     Control.Arrow.$fArrowChoiceKleisli1_closure:
         const Control.Arrow.$fArrowChoiceKleisli1_info;
 },
 sat_sbNJP_entry() //  [R1, R2]
         { info_tbl: [(cbPMw,
                       label: sat_sbNJP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPMw: // global
           _sbNJN::P64 = R2;
           _sbNJP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPMx; else goto cbPMy;
       cbPMy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbPMA; else goto cbPMz;
       cbPMA: // global
           HpAlloc = 16;
           goto cbPMx;
       cbPMx: // global
           R2 = _sbNJN::P64;
           R1 = _sbNJP::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPMz: // global
           _sbNJG::P64 = P64[_sbNJP::P64 + 7];
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = _sbNJN::P64;
           R2 = _sbNJG::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbNJU_entry() //  [R1, R2]
         { info_tbl: [(cbPMJ,
                       label: sat_sbNJU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPMJ: // global
           _sbNJS::P64 = R2;
           _sbNJU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPMK; else goto cbPML;
       cbPML: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbPMN; else goto cbPMM;
       cbPMN: // global
           HpAlloc = 16;
           goto cbPMK;
       cbPMK: // global
           R2 = _sbNJS::P64;
           R1 = _sbNJU::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPMM: // global
           _sbNJG::P64 = P64[_sbNJU::P64 + 7];
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = _sbNJS::P64;
           R2 = _sbNJG::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 6;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fArrowChoiceKleisli1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbPMS,
                       label: Control.Arrow.$fArrowChoiceKleisli1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPMS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPMT; else goto cbPMU;
       cbPMT: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fArrowChoiceKleisli1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPMU: // global
           I64[Sp - 32] = block_cbPMl_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubPN3; else goto cbPMm;
       ubPN3: // global
           call _cbPMl(R1) args: 0, res: 0, upd: 0;
       cbPMm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbPMl() //  [R1]
         { info_tbl: [(cbPMl,
                       label: block_cbPMl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPMl: // global
           _sbNJG::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbPMP; else goto cbPMQ;
       cbPMP: // global
           Hp = Hp + 48;
           _sbNJK::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbPN0; else goto cbPMW;
       cbPMW: // global
           _sbNJL::P64 = P64[_sbNJK::P64 + 7];
           I64[Hp - 40] = sat_sbNJP_info;
           P64[Hp - 32] = _sbNJG::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbNJL::P64;
           R2 = _sbNJG::P64;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 24;
           P64[Sp + 24] = Hp - 39;
           Sp = Sp + 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
       cbPMQ: // global
           Hp = Hp + 48;
           _sbNJK::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbPN0; else goto cbPMZ;
       cbPN0: // global
           HpAlloc = 48;
           R1 = _sbNJK::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbPMZ: // global
           _sbNJQ::P64 = P64[_sbNJK::P64 + 6];
           I64[Hp - 40] = sat_sbNJU_info;
           P64[Hp - 32] = _sbNJG::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sbNJQ::P64;
           R2 = _sbNJG::P64;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 24;
           P64[Sp + 24] = Hp - 39;
           Sp = Sp + 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.068749278 UTC

[section ""data" . Control.Arrow.$fArrowChoiceKleisli3_closure" {
     Control.Arrow.$fArrowChoiceKleisli3_closure:
         const Control.Arrow.$fArrowChoiceKleisli3_info;
 },
 sat_sbNJZ_entry() //  [R1, R2]
         { info_tbl: [(cbPNE,
                       label: sat_sbNJZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPNE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPNF; else goto cbPNG;
       cbPNF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPNG: // global
           _sbNJY::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _sbNJY::P64;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fArrowChoiceKleisli3_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPNH,
                       label: Control.Arrow.$fArrowChoiceKleisli3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPNH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbPNL; else goto cbPNK;
       cbPNL: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fArrowChoiceKleisli3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPNK: // global
           I64[Hp - 8] = sat_sbNJZ_info;
           P64[Hp] = R2;
           R5 = R4;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Control.Arrow.$fArrowChoiceKleisli1_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.074730679 UTC

[section ""data" . Control.Arrow.$fArrowChoiceKleisli2_closure" {
     Control.Arrow.$fArrowChoiceKleisli2_closure:
         const Control.Arrow.$fArrowChoiceKleisli2_info;
 },
 sat_sbNK4_entry() //  [R1, R2]
         { info_tbl: [(cbPO3,
                       label: sat_sbNK4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPO3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPO4; else goto cbPO5;
       cbPO4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPO5: // global
           _sbNK3::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _sbNK3::P64;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fArrowChoiceKleisli2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPO6,
                       label: Control.Arrow.$fArrowChoiceKleisli2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPO6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbPOa; else goto cbPO9;
       cbPOa: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fArrowChoiceKleisli2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPO9: // global
           I64[Hp - 8] = sat_sbNK4_info;
           P64[Hp] = R2;
           R5 = R4;
           R4 = R3;
           R3 = Hp - 7;
           R2 = R2;
           call Control.Arrow.$fArrowChoiceKleisli1_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.081149571 UTC

[section ""data" . lvl4_rbNCc_closure" {
     lvl4_rbNCc_closure:
         const lvl4_rbNCc_info;
 },
 lvl4_rbNCc_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPOn,
                       label: lvl4_rbNCc_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPOn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Either.either_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.085491767 UTC

[section ""data" . Control.Arrow.$fArrowChoiceKleisli_closure" {
     Control.Arrow.$fArrowChoiceKleisli_closure:
         const Control.Arrow.$fArrowChoiceKleisli_info;
 },
 sat_sbNKc_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbPOD,
                       label: sat_sbNKc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPOD: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fArrowChoiceKleisli1_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNKb_entry() //  [R1, R2, R3]
         { info_tbl: [(cbPOL,
                       label: sat_sbNKb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPOL: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowChoiceKleisli2_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNKa_entry() //  [R1, R2, R3]
         { info_tbl: [(cbPOT,
                       label: sat_sbNKa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPOT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowChoiceKleisli3_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNK9_entry() //  [R1]
         { info_tbl: [(cbPP0,
                       label: sat_sbNK9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPP0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPP1; else goto cbPP2;
       cbPP1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPP2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowKleisli_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowChoiceKleisli_entry() //  [R2]
         { info_tbl: [(cbPP4,
                       label: Control.Arrow.$fArrowChoiceKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPP4: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cbPP8; else goto cbPP7;
       cbPP8: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Control.Arrow.$fArrowChoiceKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPP7: // global
           I64[Hp - 112] = sat_sbNKc_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbNKb_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbNKa_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbNK9_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = Control.Arrow.C:ArrowChoice_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 94;
           P64[Hp - 8] = Hp - 109;
           P64[Hp] = lvl4_rbNCc_closure+3;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.097009455 UTC

[section ""data" . Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_closure" {
     Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_closure:
         const Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_info;
 },
 sat_sbNKe_entry() //  [R1]
         { info_tbl: [(cbPPD,
                       label: sat_sbNKe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPPD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPPE; else goto cbPPF;
       cbPPE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPPF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_entry() //  [R2]
         { info_tbl: [(cbPPG,
                       label: Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPPG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPPK; else goto cbPPJ;
       cbPPK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPPJ: // global
           I64[Hp - 16] = sat_sbNKe_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Arrow.$fArrowKleisli_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.10321635 UTC

[section ""data" . Control.Arrow.$fArrowZeroKleisli_closure" {
     Control.Arrow.$fArrowZeroKleisli_closure:
         const Control.Arrow.$fArrowZeroKleisli_info;
 },
 lvl5_sbNKg_entry() //  [R1]
         { info_tbl: [(cbPQ1,
                       label: lvl5_sbNKg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPQ1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPQ2; else goto cbPQ3;
       cbPQ2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPQ3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNKj_entry() //  [R1]
         { info_tbl: [(cbPQ9,
                       label: sat_sbNKj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPQ9: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNKh_entry() //  [R1]
         { info_tbl: [(cbPQg,
                       label: sat_sbNKh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPQg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPQh; else goto cbPQi;
       cbPQh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPQi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowZeroKleisli_entry() //  [R2]
         { info_tbl: [(cbPQk,
                       label: Control.Arrow.$fArrowZeroKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPQk: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbPQo; else goto cbPQn;
       cbPQo: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = Control.Arrow.$fArrowZeroKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPQn: // global
           I64[Hp - 80] = lvl5_sbNKg_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbNKj_info;
           P64[Hp - 48] = Hp - 80;
           I64[Hp - 40] = sat_sbNKh_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Arrow.C:ArrowZero_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.112531216 UTC

[section ""data" . Control.Arrow.$fArrowPlusKleisli_closure" {
     Control.Arrow.$fArrowPlusKleisli_closure:
         const Control.Arrow.$fArrowPlusKleisli_info;
 },
 sat_sbNKm_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbPQR,
                       label: sat_sbNKm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPQR: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fArrowPlusKleisli1_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNKl_entry() //  [R1]
         { info_tbl: [(cbPQY,
                       label: sat_sbNKl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPQY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPQZ; else goto cbPR0;
       cbPQZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPR0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowZeroKleisli_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowPlusKleisli_entry() //  [R2]
         { info_tbl: [(cbPR2,
                       label: Control.Arrow.$fArrowPlusKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPR2: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbPR6; else goto cbPR5;
       cbPR6: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Arrow.$fArrowPlusKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPR5: // global
           I64[Hp - 56] = sat_sbNKm_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbNKl_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Arrow.C:ArrowPlus_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 53;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.120095026 UTC

[section ""data" . Control.Arrow.$dmsecond_closure" {
     Control.Arrow.$dmsecond_closure:
         const Control.Arrow.$dmsecond_info;
 },
 sat_sbNKp_entry() //  [R1]
         { info_tbl: [(cbPRv,
                       label: sat_sbNKp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPRv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbPRw; else goto cbPRx;
       cbPRw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPRx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbPRt_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbPRt() //  [R1]
         { info_tbl: [(cbPRt,
                       label: block_cbPRt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPRt: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Category.id_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dmsecond_entry() //  [R2]
         { info_tbl: [(cbPRB,
                       label: Control.Arrow.$dmsecond_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPRB: // global
           _sbNKn::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPRC; else goto cbPRD;
       cbPRD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPRF; else goto cbPRE;
       cbPRF: // global
           HpAlloc = 24;
           goto cbPRC;
       cbPRC: // global
           R2 = _sbNKn::P64;
           R1 = Control.Arrow.$dmsecond_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPRE: // global
           I64[Hp - 16] = sat_sbNKp_info;
           P64[Hp] = _sbNKn::P64;
           R2 = _sbNKn::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Control.Arrow.***_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.128505593 UTC

[section ""data" . Control.Arrow.$dmfirst_closure" {
     Control.Arrow.$dmfirst_closure:
         const Control.Arrow.$dmfirst_info;
 },
 sat_sbNKt_entry() //  [R1]
         { info_tbl: [(cbPS3,
                       label: sat_sbNKt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPS3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbPS4; else goto cbPS5;
       cbPS4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPS5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbPS1_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbPS1() //  [R1]
         { info_tbl: [(cbPS1,
                       label: block_cbPS1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPS1: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Category.id_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dmfirst_entry() //  [R2, R3]
         { info_tbl: [(cbPS9,
                       label: Control.Arrow.$dmfirst_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPS9: // global
           _sbNKr::P64 = R3;
           _sbNKq::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbPSa; else goto cbPSb;
       cbPSb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPSd; else goto cbPSc;
       cbPSd: // global
           HpAlloc = 24;
           goto cbPSa;
       cbPSa: // global
           R3 = _sbNKr::P64;
           R2 = _sbNKq::P64;
           R1 = Control.Arrow.$dmfirst_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPSc: // global
           I64[Hp - 16] = sat_sbNKt_info;
           P64[Hp] = _sbNKq::P64;
           R2 = _sbNKq::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbNKr::P64;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Control.Arrow.***_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.136533704 UTC

[section ""data" . Control.Arrow.$cfirst_closure" {
     Control.Arrow.$cfirst_closure:
         const Control.Arrow.$cfirst_info;
 },
 sat_sbNKA_entry() //  [R1]
         { info_tbl: [(cbPSB,
                       label: sat_sbNKA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPSB: // global
           _sbNKA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPSC; else goto cbPSD;
       cbPSD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPSF; else goto cbPSE;
       cbPSF: // global
           HpAlloc = 24;
           goto cbPSC;
       cbPSC: // global
           R1 = _sbNKA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPSE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNKA::P64;
           _sbNKu::P64 = P64[_sbNKA::P64 + 16];
           _sbNKv::P64 = P64[_sbNKA::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbNKv::P64;
           R2 = Hp - 16;
           R1 = _sbNKu::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$cfirst_entry() //  [R2, R3]
         { info_tbl: [(cbPSH,
                       label: Control.Arrow.$cfirst_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPSH: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbPSL; else goto cbPSK;
       cbPSL: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$cfirst_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPSK: // global
           I64[Hp - 72] = stg_sel_1_upd_info;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sbNKA_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.143166791 UTC

[section ""data" . Control.Arrow.$csecond_closure" {
     Control.Arrow.$csecond_closure:
         const Control.Arrow.$csecond_info;
 },
 sat_sbNKP_entry() //  [R1]
         { info_tbl: [(cbPT6,
                       label: sat_sbNKP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPT6: // global
           _sbNKP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbPT7; else goto cbPT8;
       cbPT8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbPTa; else goto cbPT9;
       cbPTa: // global
           HpAlloc = 24;
           goto cbPT7;
       cbPT7: // global
           R1 = _sbNKP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPT9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNKP::P64;
           _sbNKF::P64 = P64[_sbNKP::P64 + 16];
           _sbNKG::P64 = P64[_sbNKP::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sbNKG::P64;
           R2 = Hp - 16;
           R1 = _sbNKF::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$csecond_entry() //  [R2, R3]
         { info_tbl: [(cbPTd,
                       label: Control.Arrow.$csecond_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPTd: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbPTh; else goto cbPTg;
       cbPTh: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$csecond_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPTg: // global
           I64[Hp - 72] = sat_sbNKP_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.150063434 UTC

[section ""data" . Control.Arrow.$c&&&_closure" {
     Control.Arrow.$c&&&_closure:
         const Control.Arrow.$c&&&_info;
 },
 Control.Arrow.$c&&&_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPTA,
                       label: Control.Arrow.$c&&&_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPTA: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbPTE; else goto cbPTD;
       cbPTE: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$c&&&_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPTD: // global
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.154262203 UTC

[section ""data" . Control.Arrow.$fArrow(->)_closure" {
     Control.Arrow.$fArrow(->)_closure:
         const Control.Arrow.C:Arrow_con_info;
         const Control.Category.$fCategoryTYPE(->)_closure;
         const Control.Arrow.$fArrow(->)_$carr_closure+1;
         const Control.Arrow.$cfirst_closure+2;
         const Control.Arrow.$csecond_closure+2;
         const Control.Arrow.$c***_closure+3;
         const Control.Arrow.$c&&&_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.156253283 UTC

[section ""data" . Control.Arrow.$fArrowLoop(->)_closure" {
     Control.Arrow.$fArrowLoop(->)_closure:
         const Control.Arrow.C:ArrowLoop_con_info;
         const Control.Arrow.$fArrow(->)_closure+1;
         const Control.Arrow.$fArrowLoop(->)_$cloop_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.158064494 UTC

[section ""data" . Control.Arrow.$fArrowApply(->)_closure" {
     Control.Arrow.$fArrowApply(->)_closure:
         const Control.Arrow.C:ArrowApply_con_info;
         const Control.Arrow.$fArrow(->)_closure+1;
         const Control.Arrow.$fAlternativeArrowMonad_$capp_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.160656158 UTC

[section ""data" . Control.Arrow.$c+++_closure" {
     Control.Arrow.$c+++_closure:
         const Control.Arrow.$c+++_info;
 },
 Control.Arrow.$c+++_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPU0,
                       label: Control.Arrow.$c+++_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPU0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbPU1; else goto cbPU2;
       cbPU1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$c+++_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPU2: // global
           I64[Sp - 24] = block_cbPTT_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubPUh; else goto cbPTU;
       ubPUh: // global
           call _cbPTT(R1) args: 0, res: 0, upd: 0;
       cbPTU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbPTT() //  [R1]
         { info_tbl: [(cbPTT,
                       label: block_cbPTT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPTT: // global
           if (R1 & 7 == 1) goto cbPTX; else goto cbPTY;
       cbPTX: // global
           Hp = Hp + 48;
           _sbNKY::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbPUg; else goto cbPU8;
       cbPU8: // global
           _sbNKZ::P64 = P64[_sbNKY::P64 + 7];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sbNKZ::P64;
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbPTY: // global
           Hp = Hp + 48;
           _sbNKY::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbPUg; else goto cbPUf;
       cbPUg: // global
           HpAlloc = 48;
           R1 = _sbNKY::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbPUf: // global
           _sbNL1::P64 = P64[_sbNKY::P64 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sbNL1::P64;
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.169010858 UTC

[section ""data" . Control.Arrow.$cright_closure" {
     Control.Arrow.$cright_closure:
         const Control.Arrow.$cright_info;
 },
 Control.Arrow.$cright_entry() //  [R2, R3]
         { info_tbl: [(cbPUK,
                       label: Control.Arrow.$cright_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPUK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPUL; else goto cbPUM;
       cbPUL: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$cright_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPUM: // global
           I64[Sp - 16] = block_cbPUD_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubPUX; else goto cbPUE;
       ubPUX: // global
           call _cbPUD(R1) args: 0, res: 0, upd: 0;
       cbPUE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbPUD() //  [R1]
         { info_tbl: [(cbPUD,
                       label: block_cbPUD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPUD: // global
           if (R1 & 7 == 1) goto cbPUH; else goto cbPUI;
       cbPUH: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbPUI: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbPUW; else goto cbPUV;
       cbPUW: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbPUV: // global
           _sbNL7::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sbNL7::P64;
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.175680086 UTC

[section ""data" . Control.Arrow.$cleft_closure" {
     Control.Arrow.$cleft_closure:
         const Control.Arrow.$cleft_info;
 },
 Control.Arrow.$cleft_entry() //  [R2, R3]
         { info_tbl: [(cbPVp,
                       label: Control.Arrow.$cleft_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPVp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPVq; else goto cbPVr;
       cbPVq: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$cleft_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPVr: // global
           I64[Sp - 16] = block_cbPVi_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubPVC; else goto cbPVj;
       ubPVC: // global
           call _cbPVi(R1) args: 0, res: 0, upd: 0;
       cbPVj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbPVi() //  [R1]
         { info_tbl: [(cbPVi,
                       label: block_cbPVi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPVi: // global
           if (R1 & 7 == 1) goto cbPVm; else goto cbPVn;
       cbPVm: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbPVy; else goto cbPVx;
       cbPVy: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbPVx: // global
           _sbNLc::P64 = P64[R1 + 7];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sbNLc::P64;
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbPVn: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.182082053 UTC

[section ""data" . Control.Arrow.$fArrowChoice(->)_closure" {
     Control.Arrow.$fArrowChoice(->)_closure:
         const Control.Arrow.C:ArrowChoice_con_info;
         const Control.Arrow.$fArrow(->)_closure+1;
         const Control.Arrow.$cleft_closure+2;
         const Control.Arrow.$cright_closure+2;
         const Control.Arrow.$c+++_closure+3;
         const Data.Either.either_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.184257678 UTC

[section ""data" . Control.Arrow.runKleisli1_closure" {
     Control.Arrow.runKleisli1_closure:
         const Control.Arrow.runKleisli1_info;
 },
 Control.Arrow.runKleisli1_entry() //  [R2]
         { info_tbl: [(cbPVY,
                       label: Control.Arrow.runKleisli1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPVY: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.187842779 UTC

[section ""data" . Control.Arrow.runKleisli_closure" {
     Control.Arrow.runKleisli_closure:
         const Control.Arrow.runKleisli_info;
 },
 Control.Arrow.runKleisli_entry() //  [R2]
         { info_tbl: [(cbPW9,
                       label: Control.Arrow.runKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPW9: // global
           R2 = R2;
           call Control.Arrow.runKleisli1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.191303999 UTC

[section ""data" . Control.Arrow.returnA_closure" {
     Control.Arrow.returnA_closure:
         const Control.Arrow.returnA_info;
 },
 Control.Arrow.returnA_entry() //  [R2]
         { info_tbl: [(cbPWk,
                       label: Control.Arrow.returnA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPWk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPWl; else goto cbPWm;
       cbPWl: // global
           R2 = R2;
           R1 = Control.Arrow.returnA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPWm: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.id_closure+1;
           Sp = Sp - 16;
           call Control.Arrow.arr_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.195562405 UTC

[section ""data" . Control.Arrow.^>>_closure" {
     Control.Arrow.^>>_closure:
         const Control.Arrow.^>>_info;
 },
 sat_sbNLl_entry() //  [R1]
         { info_tbl: [(cbPWA,
                       label: sat_sbNLl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPWA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPWB; else goto cbPWC;
       cbPWB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPWC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.^>>_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPWF,
                       label: Control.Arrow.^>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPWF: // global
           _sbNLj::P64 = R4;
           _sbNLi::P64 = R3;
           _sbNLh::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbPWG; else goto cbPWH;
       cbPWH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbPWJ; else goto cbPWI;
       cbPWJ: // global
           HpAlloc = 32;
           goto cbPWG;
       cbPWG: // global
           R4 = _sbNLj::P64;
           R3 = _sbNLi::P64;
           R2 = _sbNLh::P64;
           R1 = Control.Arrow.^>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPWI: // global
           I64[Hp - 24] = sat_sbNLl_info;
           P64[Hp - 8] = _sbNLh::P64;
           P64[Hp] = _sbNLi::P64;
           I64[Sp - 24] = block_cbPWD_info;
           R2 = _sbNLh::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNLj::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPWD() //  [R1]
         { info_tbl: [(cbPWD,
                       label: block_cbPWD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPWD: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbPWw::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbPWw::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.204647267 UTC

[section ""data" . Control.Arrow.>>^_closure" {
     Control.Arrow.>>^_closure:
         const Control.Arrow.>>^_info;
 },
 sat_sbNLq_entry() //  [R1]
         { info_tbl: [(cbPXa,
                       label: sat_sbNLq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPXa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPXb; else goto cbPXc;
       cbPXb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPXc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.>>^_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPXf,
                       label: Control.Arrow.>>^_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPXf: // global
           _sbNLo::P64 = R4;
           _sbNLn::P64 = R3;
           _sbNLm::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbPXg; else goto cbPXh;
       cbPXh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbPXj; else goto cbPXi;
       cbPXj: // global
           HpAlloc = 32;
           goto cbPXg;
       cbPXg: // global
           R4 = _sbNLo::P64;
           R3 = _sbNLn::P64;
           R2 = _sbNLm::P64;
           R1 = Control.Arrow.>>^_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPXi: // global
           I64[Hp - 24] = sat_sbNLq_info;
           P64[Hp - 8] = _sbNLm::P64;
           P64[Hp] = _sbNLo::P64;
           I64[Sp - 24] = block_cbPXd_info;
           R2 = _sbNLm::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNLn::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPXd() //  [R1]
         { info_tbl: [(cbPXd,
                       label: block_cbPXd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPXd: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.212641249 UTC

[section ""data" . Control.Arrow.<<^_closure" {
     Control.Arrow.<<^_closure:
         const Control.Arrow.<<^_info;
 },
 sat_sbNLv_entry() //  [R1]
         { info_tbl: [(cbPXJ,
                       label: sat_sbNLv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPXJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPXK; else goto cbPXL;
       cbPXK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPXL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.<<^_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPXO,
                       label: Control.Arrow.<<^_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPXO: // global
           _sbNLt::P64 = R4;
           _sbNLs::P64 = R3;
           _sbNLr::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbPXP; else goto cbPXQ;
       cbPXQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbPXS; else goto cbPXR;
       cbPXS: // global
           HpAlloc = 32;
           goto cbPXP;
       cbPXP: // global
           R4 = _sbNLt::P64;
           R3 = _sbNLs::P64;
           R2 = _sbNLr::P64;
           R1 = Control.Arrow.<<^_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPXR: // global
           I64[Hp - 24] = sat_sbNLv_info;
           P64[Hp - 8] = _sbNLr::P64;
           P64[Hp] = _sbNLt::P64;
           I64[Sp - 24] = block_cbPXM_info;
           R2 = _sbNLr::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNLs::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPXM() //  [R1]
         { info_tbl: [(cbPXM,
                       label: block_cbPXM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPXM: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbPXF::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbPXF::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.221206304 UTC

[section ""data" . Control.Arrow.^<<_closure" {
     Control.Arrow.^<<_closure:
         const Control.Arrow.^<<_info;
 },
 sat_sbNLA_entry() //  [R1]
         { info_tbl: [(cbPYj,
                       label: sat_sbNLA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPYj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPYk; else goto cbPYl;
       cbPYk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPYl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.^<<_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPYo,
                       label: Control.Arrow.^<<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPYo: // global
           _sbNLy::P64 = R4;
           _sbNLx::P64 = R3;
           _sbNLw::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbPYp; else goto cbPYq;
       cbPYq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbPYs; else goto cbPYr;
       cbPYs: // global
           HpAlloc = 32;
           goto cbPYp;
       cbPYp: // global
           R4 = _sbNLy::P64;
           R3 = _sbNLx::P64;
           R2 = _sbNLw::P64;
           R1 = Control.Arrow.^<<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPYr: // global
           I64[Hp - 24] = sat_sbNLA_info;
           P64[Hp - 8] = _sbNLw::P64;
           P64[Hp] = _sbNLx::P64;
           I64[Sp - 24] = block_cbPYm_info;
           R2 = _sbNLw::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbNLy::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPYm() //  [R1]
         { info_tbl: [(cbPYm,
                       label: block_cbPYm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPYm: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.232162451 UTC

[section ""data" . Control.Arrow.leftApp_closure" {
     Control.Arrow.leftApp_closure:
         const Control.Arrow.leftApp_info;
 },
 lvl5_sbNLG_entry() //  [R1]
         { info_tbl: [(cbPZ4,
                       label: lvl5_sbNLG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPZ4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbPZ5; else goto cbPZ6;
       cbPZ5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPZ6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Either.Left_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNLM_entry() //  [R1, R2]
         { info_tbl: [(cbPZB,
                       label: sat_sbNLM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPZB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbPZC; else goto cbPZD;
       cbPZC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPZD: // global
           I64[Sp - 16] = block_cbPZy_info;
           _sbNLJ::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sbNLJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubPZH; else goto cbPZz;
       ubPZH: // global
           call _cbPZy() args: 0, res: 0, upd: 0;
       cbPZz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbPZy() //  []
         { info_tbl: [(cbPZy,
                       label: block_cbPZy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPZy: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNLN_entry() //  [R1]
         { info_tbl: [(cbPZI,
                       label: sat_sbNLN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPZI: // global
           _sbNLN::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbPZJ; else goto cbPZK;
       cbPZK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbPZM; else goto cbPZL;
       cbPZM: // global
           HpAlloc = 16;
           goto cbPZJ;
       cbPZJ: // global
           R1 = _sbNLN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPZL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNLN::P64;
           _sbNLD::P64 = P64[_sbNLN::P64 + 16];
           _sbNLJ::P64 = P64[_sbNLN::P64 + 24];
           I64[Hp - 8] = sat_sbNLM_info;
           P64[Hp] = _sbNLJ::P64;
           R2 = _sbNLD::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNLO_entry() //  [R1]
         { info_tbl: [(cbPZN,
                       label: sat_sbNLO_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPZN: // global
           _sbNLO::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbPZO; else goto cbPZP;
       cbPZP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbPZR; else goto cbPZQ;
       cbPZR: // global
           HpAlloc = 32;
           goto cbPZO;
       cbPZO: // global
           R1 = _sbNLO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPZQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNLO::P64;
           _sbNLC::P64 = P64[_sbNLO::P64 + 16];
           _sbNLD::P64 = P64[_sbNLO::P64 + 24];
           _sbNLE::P64 = P64[_sbNLO::P64 + 32];
           _sbNLJ::P64 = P64[_sbNLO::P64 + 40];
           I64[Hp - 24] = sat_sbNLN_info;
           P64[Hp - 8] = _sbNLD::P64;
           P64[Hp] = _sbNLJ::P64;
           R2 = _sbNLE::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbNLC::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNLP_entry() //  [R1]
         { info_tbl: [(cbPZS,
                       label: sat_sbNLP_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPZS: // global
           _sbNLP::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbPZT; else goto cbPZU;
       cbPZU: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbPZW; else goto cbPZV;
       cbPZW: // global
           HpAlloc = 48;
           goto cbPZT;
       cbPZT: // global
           R1 = _sbNLP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbPZV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNLP::P64;
           _sbNLC::P64 = P64[_sbNLP::P64 + 16];
           _sbNLD::P64 = P64[_sbNLP::P64 + 24];
           _sbNLE::P64 = P64[_sbNLP::P64 + 32];
           _sbNLG::P64 = P64[_sbNLP::P64 + 40];
           _sbNLJ::P64 = P64[_sbNLP::P64 + 48];
           I64[Hp - 40] = sat_sbNLO_info;
           P64[Hp - 24] = _sbNLC::P64;
           P64[Hp - 16] = _sbNLD::P64;
           P64[Hp - 8] = _sbNLE::P64;
           P64[Hp] = _sbNLJ::P64;
           R2 = _sbNLE::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbNLG::P64;
           P64[Sp - 24] = Hp - 40;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbNLT_entry() //  [R1]
         { info_tbl: [(cbQ0f,
                       label: sat_sbNLT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ0f: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQ0g; else goto cbQ0h;
       cbQ0g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQ0h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbQ0c_info;
           _sbNLQ::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbNLQ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubQ0l; else goto cbQ0d;
       ubQ0l: // global
           call _cbQ0c() args: 0, res: 0, upd: 0;
       cbQ0d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbQ0c() //  []
         { info_tbl: [(cbQ0c,
                       label: block_cbQ0c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ0c: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbNLU_entry() //  [R1, R2]
         { info_tbl: [(cbQ0n,
                       label: sat_sbNLU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ0n: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbQ0r; else goto cbQ0q;
       cbQ0r: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQ0q: // global
           _sbNLQ::P64 = P64[R1 + 7];
           I64[Hp - 40] = sat_sbNLT_info;
           P64[Hp - 24] = _sbNLQ::P64;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNLV_entry() //  [R1]
         { info_tbl: [(cbQ0s,
                       label: sat_sbNLV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ0s: // global
           _sbNLV::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbQ0t; else goto cbQ0u;
       cbQ0u: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbQ0w; else goto cbQ0v;
       cbQ0w: // global
           HpAlloc = 16;
           goto cbQ0t;
       cbQ0t: // global
           R1 = _sbNLV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQ0v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNLV::P64;
           _sbNLD::P64 = P64[_sbNLV::P64 + 16];
           _sbNLQ::P64 = P64[_sbNLV::P64 + 24];
           I64[Hp - 8] = sat_sbNLU_info;
           P64[Hp] = _sbNLQ::P64;
           R2 = _sbNLD::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNLW_entry() //  [R1, R2]
         { info_tbl: [(cbQ0B,
                       label: sat_sbNLW_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ0B: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbQ0C; else goto cbQ0D;
       cbQ0C: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQ0D: // global
           I64[Sp - 40] = block_cbPZc_info;
           _sbNLC::P64 = P64[R1 + 7];
           _sbNLD::P64 = P64[R1 + 15];
           _sbNLE::P64 = P64[R1 + 23];
           _sbNLG::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sbNLC::P64;
           P64[Sp - 24] = _sbNLD::P64;
           P64[Sp - 16] = _sbNLE::P64;
           P64[Sp - 8] = _sbNLG::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubQ0M; else goto cbPZd;
       ubQ0M: // global
           call _cbPZc(R1) args: 0, res: 0, upd: 0;
       cbPZd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbPZc() //  [R1]
         { info_tbl: [(cbPZc,
                       label: block_cbPZc_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPZc: // global
           _sbNLD::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbQ0y; else goto cbQ0z;
       cbQ0y: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbQ0H; else goto cbQ0G;
       cbQ0H: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbQ0G: // global
           _sbNLJ::P64 = P64[R1 + 7];
           I64[Hp - 72] = sat_sbNLP_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _sbNLD::P64;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sbNLJ::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = GHC.Tuple.()_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbQ0z: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbQ0L; else goto cbQ0K;
       cbQ0L: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbQ0K: // global
           _sbNLQ::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sbNLV_info;
           P64[Hp - 32] = _sbNLD::P64;
           P64[Hp - 24] = _sbNLQ::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Tuple.()_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbNLX_entry() //  [R1]
         { info_tbl: [(cbQ0N,
                       label: sat_sbNLX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ0N: // global
           _sbNLX::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbQ0O; else goto cbQ0P;
       cbQ0P: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbQ0R; else goto cbQ0Q;
       cbQ0R: // global
           HpAlloc = 64;
           goto cbQ0O;
       cbQ0O: // global
           R1 = _sbNLX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQ0Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbNLX::P64;
           _sbNLC::P64 = P64[_sbNLX::P64 + 16];
           _sbNLD::P64 = P64[_sbNLX::P64 + 24];
           _sbNLE::P64 = P64[_sbNLX::P64 + 32];
           I64[Hp - 56] = lvl5_sbNLG_info;
           P64[Hp - 40] = _sbNLD::P64;
           I64[Hp - 32] = sat_sbNLW_info;
           P64[Hp - 24] = _sbNLC::P64;
           P64[Hp - 16] = _sbNLD::P64;
           P64[Hp - 8] = _sbNLE::P64;
           P64[Hp] = Hp - 56;
           R2 = _sbNLD::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 31;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbNLF_entry() //  [R1]
         { info_tbl: [(cbQ0W,
                       label: sat_sbNLF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ0W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbQ0X; else goto cbQ0Y;
       cbQ0X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQ0Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.app_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.leftApp_entry() //  [R2, R3]
         { info_tbl: [(cbQ0Z,
                       label: Control.Arrow.leftApp_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ0Z: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQ10; else goto cbQ11;
       cbQ10: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.leftApp_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQ11: // global
           I64[Sp - 24] = block_cbPYO_info;
           _sbNLB::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _sbNLB::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Control.Arrow.$p1ArrowApply_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPYO() //  [R1]
         { info_tbl: [(cbPYO,
                       label: block_cbPYO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPYO: // global
           I64[Sp - 8] = block_cbPYS_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPYS() //  [R1]
         { info_tbl: [(cbPYS,
                       label: block_cbPYS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPYS: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbQ15; else goto cbQ14;
       cbQ15: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbQ14: // global
           I64[Hp - 56] = sat_sbNLX_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbNLF_info;
           P64[Hp] = P64[Sp + 16];
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 24] = Hp - 56;
           Sp = Sp + 8;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.273162753 UTC

[section ""cstring" . Control.Arrow.$trModule4_bytes" {
     Control.Arrow.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.275085943 UTC

[section ""data" . Control.Arrow.$trModule3_closure" {
     Control.Arrow.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.276988485 UTC

[section ""cstring" . Control.Arrow.$trModule2_bytes" {
     Control.Arrow.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,65,114,114,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.278826078 UTC

[section ""data" . Control.Arrow.$trModule1_closure" {
     Control.Arrow.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.280654066 UTC

[section ""data" . Control.Arrow.$trModule_closure" {
     Control.Arrow.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Arrow.$trModule3_closure+1;
         const Control.Arrow.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.284137685 UTC

[section ""data" . $krep_rbNCd_closure" {
     $krep_rbNCd_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.286261674 UTC

[section ""data" . $krep1_rbNCe_closure" {
     $krep1_rbNCe_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.28917896 UTC

[section ""data" . Control.Arrow.$tcKleisli1_closure" {
     Control.Arrow.$tcKleisli1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const GHC.Types.krep$*->*->*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.291119919 UTC

[section ""data" . Control.Arrow.$tcArrow1_closure" {
     Control.Arrow.$tcArrow1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const $krep1_rbNCe_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.293704857 UTC

[section ""data" . Control.Arrow.$tcArrowMonad1_closure" {
     Control.Arrow.$tcArrowMonad1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const GHC.Types.krep$*Arr*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.29583899 UTC

[section ""data" . $krep2_rbNCf_closure" {
     $krep2_rbNCf_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.297839613 UTC

[section ""data" . $krep3_rbNCg_closure" {
     $krep3_rbNCg_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.299833279 UTC

[section ""data" . $krep4_rbNCh_closure" {
     $krep4_rbNCh_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.301985632 UTC

[section ""data" . $krep5_rbNCi_closure" {
     $krep5_rbNCi_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_rbNCh_closure+2;
         const $krep2_rbNCf_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.304075995 UTC

[section ""data" . $krep6_rbNCj_closure" {
     $krep6_rbNCj_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rbNCg_closure+2;
         const $krep5_rbNCi_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.3062054 UTC

[section ""data" . $krep7_rbNCk_closure" {
     $krep7_rbNCk_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_rbNCh_closure+2;
         const $krep_rbNCd_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.308256206 UTC

[section ""data" . $krep8_rbNCl_closure" {
     $krep8_rbNCl_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep7_rbNCk_closure+3;
         const $krep3_rbNCg_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.310513005 UTC

[section ""cstring" . Control.Arrow.$tcArrow3_bytes" {
     Control.Arrow.$tcArrow3_bytes:
         I8[] [65,114,114,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.312540562 UTC

[section ""data" . Control.Arrow.$tcArrow2_closure" {
     Control.Arrow.$tcArrow2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrow3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.314692137 UTC

[section ""data" . Control.Arrow.$tcArrow_closure" {
     Control.Arrow.$tcArrow_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrow2_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 12964584583212294992;
         const 10211991410748124746;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.316824659 UTC

[section ""cstring" . Control.Arrow.$tcKleisli3_bytes" {
     Control.Arrow.$tcKleisli3_bytes:
         I8[] [75,108,101,105,115,108,105]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.319973758 UTC

[section ""data" . Control.Arrow.$tcKleisli2_closure" {
     Control.Arrow.$tcKleisli2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcKleisli3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.321948734 UTC

[section ""data" . Control.Arrow.$tcKleisli_closure" {
     Control.Arrow.$tcKleisli_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcKleisli2_closure+1;
         const Control.Arrow.$tcKleisli1_closure+4;
         const 2023158159015915132;
         const 6143719008973118504;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.323938699 UTC

[section ""data" . $krep9_rbNCm_closure" {
     $krep9_rbNCm_closure:
         const :_con_info;
         const $krep2_rbNCf_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.325800763 UTC

[section ""data" . $krep10_rbNCn_closure" {
     $krep10_rbNCn_closure:
         const :_con_info;
         const $krep3_rbNCg_closure+2;
         const $krep9_rbNCm_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.327678714 UTC

[section ""data" . $krep11_rbNCo_closure" {
     $krep11_rbNCo_closure:
         const :_con_info;
         const $krep4_rbNCh_closure+2;
         const $krep10_rbNCn_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.329579862 UTC

[section ""data" . $krep12_rbNCp_closure" {
     $krep12_rbNCp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Arrow.$tcKleisli_closure+1;
         const $krep11_rbNCo_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.33149441 UTC

[section ""data" . Control.Arrow.$tc'Kleisli1_closure" {
     Control.Arrow.$tc'Kleisli1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rbNCj_closure+4;
         const $krep12_rbNCp_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.333317751 UTC

[section ""cstring" . Control.Arrow.$tc'Kleisli3_bytes" {
     Control.Arrow.$tc'Kleisli3_bytes:
         I8[] [39,75,108,101,105,115,108,105]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.334955375 UTC

[section ""data" . Control.Arrow.$tc'Kleisli2_closure" {
     Control.Arrow.$tc'Kleisli2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tc'Kleisli3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.336778818 UTC

[section ""data" . Control.Arrow.$tc'Kleisli_closure" {
     Control.Arrow.$tc'Kleisli_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tc'Kleisli2_closure+1;
         const Control.Arrow.$tc'Kleisli1_closure+4;
         const 793719726112502834;
         const 14919550952510816382;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.339329039 UTC

[section ""cstring" . Control.Arrow.$tcArrowZero2_bytes" {
     Control.Arrow.$tcArrowZero2_bytes:
         I8[] [65,114,114,111,119,90,101,114,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.34114477 UTC

[section ""data" . Control.Arrow.$tcArrowZero1_closure" {
     Control.Arrow.$tcArrowZero1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowZero2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.343067474 UTC

[section ""data" . Control.Arrow.$tcArrowZero_closure" {
     Control.Arrow.$tcArrowZero_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowZero1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 337582314637215801;
         const 485553589222180171;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.345041066 UTC

[section ""cstring" . Control.Arrow.$tcArrowPlus2_bytes" {
     Control.Arrow.$tcArrowPlus2_bytes:
         I8[] [65,114,114,111,119,80,108,117,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.346980543 UTC

[section ""data" . Control.Arrow.$tcArrowPlus1_closure" {
     Control.Arrow.$tcArrowPlus1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowPlus2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.350170938 UTC

[section ""data" . Control.Arrow.$tcArrowPlus_closure" {
     Control.Arrow.$tcArrowPlus_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowPlus1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 9089885184909062397;
         const 13092571182525076608;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.352371295 UTC

[section ""cstring" . Control.Arrow.$tcArrowChoice2_bytes" {
     Control.Arrow.$tcArrowChoice2_bytes:
         I8[] [65,114,114,111,119,67,104,111,105,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.354093969 UTC

[section ""data" . Control.Arrow.$tcArrowChoice1_closure" {
     Control.Arrow.$tcArrowChoice1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowChoice2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.355891642 UTC

[section ""data" . Control.Arrow.$tcArrowChoice_closure" {
     Control.Arrow.$tcArrowChoice_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowChoice1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 9045385674203608923;
         const 4474606397073518393;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.357733535 UTC

[section ""cstring" . Control.Arrow.$tcArrowApply2_bytes" {
     Control.Arrow.$tcArrowApply2_bytes:
         I8[] [65,114,114,111,119,65,112,112,108,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.359421713 UTC

[section ""data" . Control.Arrow.$tcArrowApply1_closure" {
     Control.Arrow.$tcArrowApply1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowApply2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.361157078 UTC

[section ""data" . Control.Arrow.$tcArrowApply_closure" {
     Control.Arrow.$tcArrowApply_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowApply1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 4969046276209689969;
         const 2697302259091605677;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.363134919 UTC

[section ""cstring" . Control.Arrow.$tcArrowMonad3_bytes" {
     Control.Arrow.$tcArrowMonad3_bytes:
         I8[] [65,114,114,111,119,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.364833378 UTC

[section ""data" . Control.Arrow.$tcArrowMonad2_closure" {
     Control.Arrow.$tcArrowMonad2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowMonad3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.366721719 UTC

[section ""data" . Control.Arrow.$tcArrowMonad_closure" {
     Control.Arrow.$tcArrowMonad_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowMonad2_closure+1;
         const Control.Arrow.$tcArrowMonad1_closure+4;
         const 2648525758856951758;
         const 13692351200590237690;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.368665156 UTC

[section ""data" . $krep13_rbNCq_closure" {
     $krep13_rbNCq_closure:
         const :_con_info;
         const $krep3_rbNCg_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.370421745 UTC

[section ""data" . $krep14_rbNCr_closure" {
     $krep14_rbNCr_closure:
         const :_con_info;
         const $krep4_rbNCh_closure+2;
         const $krep13_rbNCq_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.372152538 UTC

[section ""data" . $krep15_rbNCs_closure" {
     $krep15_rbNCs_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Arrow.$tcArrowMonad_closure+1;
         const $krep14_rbNCr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.374319833 UTC

[section ""data" . Control.Arrow.$tc'ArrowMonad1_closure" {
     Control.Arrow.$tc'ArrowMonad1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rbNCl_closure+3;
         const $krep15_rbNCs_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.376579647 UTC

[section ""cstring" . Control.Arrow.$tc'ArrowMonad3_bytes" {
     Control.Arrow.$tc'ArrowMonad3_bytes:
         I8[] [39,65,114,114,111,119,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.378296978 UTC

[section ""data" . Control.Arrow.$tc'ArrowMonad2_closure" {
     Control.Arrow.$tc'ArrowMonad2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tc'ArrowMonad3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.379959334 UTC

[section ""data" . Control.Arrow.$tc'ArrowMonad_closure" {
     Control.Arrow.$tc'ArrowMonad_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tc'ArrowMonad2_closure+1;
         const Control.Arrow.$tc'ArrowMonad1_closure+4;
         const 8781545391513276915;
         const 783725375361948493;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.381803813 UTC

[section ""cstring" . Control.Arrow.$tcArrowLoop2_bytes" {
     Control.Arrow.$tcArrowLoop2_bytes:
         I8[] [65,114,114,111,119,76,111,111,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.383406807 UTC

[section ""data" . Control.Arrow.$tcArrowLoop1_closure" {
     Control.Arrow.$tcArrowLoop1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowLoop2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.385135879 UTC

[section ""data" . Control.Arrow.$tcArrowLoop_closure" {
     Control.Arrow.$tcArrowLoop_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowLoop1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 15298492960828880948;
         const 13953070859738786616;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.387351664 UTC

[section ""data" . Control.Arrow.C:ArrowLoop_closure" {
     Control.Arrow.C:ArrowLoop_closure:
         const Control.Arrow.C:ArrowLoop_info;
 },
 Control.Arrow.C:ArrowLoop_entry() //  [R2, R3]
         { info_tbl: [(cbQ3v,
                       label: Control.Arrow.C:ArrowLoop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ3v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQ3z; else goto cbQ3y;
       cbQ3z: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowLoop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQ3y: // global
           I64[Hp - 16] = Control.Arrow.C:ArrowLoop_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.391629223 UTC

[section ""data" . Control.Arrow.C:ArrowApply_closure" {
     Control.Arrow.C:ArrowApply_closure:
         const Control.Arrow.C:ArrowApply_info;
 },
 Control.Arrow.C:ArrowApply_entry() //  [R2, R3]
         { info_tbl: [(cbQ3K,
                       label: Control.Arrow.C:ArrowApply_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ3K: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQ3O; else goto cbQ3N;
       cbQ3O: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowApply_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQ3N: // global
           I64[Hp - 16] = Control.Arrow.C:ArrowApply_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.395552074 UTC

[section ""data" . Control.Arrow.C:ArrowChoice_closure" {
     Control.Arrow.C:ArrowChoice_closure:
         const Control.Arrow.C:ArrowChoice_info;
 },
 Control.Arrow.C:ArrowChoice_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbQ3Z,
                       label: Control.Arrow.C:ArrowChoice_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ3Z: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbQ43; else goto cbQ42;
       cbQ43: // global
           HpAlloc = 48;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowChoice_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQ42: // global
           I64[Hp - 40] = Control.Arrow.C:ArrowChoice_con_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.399544477 UTC

[section ""data" . Control.Arrow.C:ArrowPlus_closure" {
     Control.Arrow.C:ArrowPlus_closure:
         const Control.Arrow.C:ArrowPlus_info;
 },
 Control.Arrow.C:ArrowPlus_entry() //  [R2, R3]
         { info_tbl: [(cbQ4e,
                       label: Control.Arrow.C:ArrowPlus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ4e: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQ4i; else goto cbQ4h;
       cbQ4i: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowPlus_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQ4h: // global
           I64[Hp - 16] = Control.Arrow.C:ArrowPlus_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.403513501 UTC

[section ""data" . Control.Arrow.C:ArrowZero_closure" {
     Control.Arrow.C:ArrowZero_closure:
         const Control.Arrow.C:ArrowZero_info;
 },
 Control.Arrow.C:ArrowZero_entry() //  [R2, R3]
         { info_tbl: [(cbQ4t,
                       label: Control.Arrow.C:ArrowZero_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ4t: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQ4x; else goto cbQ4w;
       cbQ4x: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowZero_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQ4w: // global
           I64[Hp - 16] = Control.Arrow.C:ArrowZero_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.408319334 UTC

[section ""data" . Control.Arrow.C:Arrow_closure" {
     Control.Arrow.C:Arrow_closure:
         const Control.Arrow.C:Arrow_info;
 },
 Control.Arrow.C:Arrow_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbQ4I,
                       label: Control.Arrow.C:Arrow_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ4I: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbQ4M; else goto cbQ4L;
       cbQ4M: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:Arrow_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbQ4L: // global
           I64[Hp - 48] = Control.Arrow.C:Arrow_con_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.412232654 UTC

[Control.Arrow.C:ArrowLoop_con_entry() //  [R1]
         { info_tbl: [(cbQ4T,
                       label: Control.Arrow.C:ArrowLoop_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,76,111,111,112]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ4T: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.415608057 UTC

[Control.Arrow.C:ArrowApply_con_entry() //  [R1]
         { info_tbl: [(cbQ4Z,
                       label: Control.Arrow.C:ArrowApply_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,65,112,112,108,121]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ4Z: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.419375239 UTC

[Control.Arrow.C:ArrowChoice_con_entry() //  [R1]
         { info_tbl: [(cbQ55,
                       label: Control.Arrow.C:ArrowChoice_con_info
                       rep:HeapRep 5 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,67,104,111,105,99,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ55: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.42271834 UTC

[Control.Arrow.C:ArrowPlus_con_entry() //  [R1]
         { info_tbl: [(cbQ5b,
                       label: Control.Arrow.C:ArrowPlus_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,80,108,117,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ5b: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.426130864 UTC

[Control.Arrow.C:ArrowZero_con_entry() //  [R1]
         { info_tbl: [(cbQ5h,
                       label: Control.Arrow.C:ArrowZero_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,90,101,114,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ5h: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.429298529 UTC

[Control.Arrow.C:Arrow_con_entry() //  [R1]
         { info_tbl: [(cbQ5n,
                       label: Control.Arrow.C:Arrow_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ5n: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:41.432423296 UTC

[section ""relreadonly" . SbNZ8_srt" {
     SbNZ8_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Control.Arrow.$fMonadArrowMonad_closure;
         const lvl_rbNC6_closure;
         const Control.Arrow.$fMonadPlusArrowMonad_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.785629239 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:43.787291076 UTC

[section ""data" . Control.Arrow.$p1ArrowLoop_closure" {
     Control.Arrow.$p1ArrowLoop_closure:
         const Control.Arrow.$p1ArrowLoop_info;
 },
 Control.Arrow.$p1ArrowLoop_entry() //  [R2]
         { info_tbl: [(cbQf5,
                       label: Control.Arrow.$p1ArrowLoop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQf5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQf6; else goto cbQf7;
       cbQf6: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowLoop_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQf7: // global
           I64[Sp - 8] = block_cbQf2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQfb; else goto cbQf3;
       ubQfb: // global
           call _cbQf2(R1) args: 0, res: 0, upd: 0;
       cbQf3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQf2() //  [R1]
         { info_tbl: [(cbQf2,
                       label: block_cbQf2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQf2: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.79380531 UTC

[section ""data" . Control.Arrow.loop_closure" {
     Control.Arrow.loop_closure:
         const Control.Arrow.loop_info;
 },
 Control.Arrow.loop_entry() //  [R2]
         { info_tbl: [(cbQfv,
                       label: Control.Arrow.loop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQfv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQfw; else goto cbQfx;
       cbQfw: // global
           R2 = R2;
           R1 = Control.Arrow.loop_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQfx: // global
           I64[Sp - 8] = block_cbQfs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQfB; else goto cbQft;
       ubQfB: // global
           call _cbQfs(R1) args: 0, res: 0, upd: 0;
       cbQft: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQfs() //  [R1]
         { info_tbl: [(cbQfs,
                       label: block_cbQfs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQfs: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.801677367 UTC

[section ""data" . Control.Arrow.$p1ArrowApply_closure" {
     Control.Arrow.$p1ArrowApply_closure:
         const Control.Arrow.$p1ArrowApply_info;
 },
 Control.Arrow.$p1ArrowApply_entry() //  [R2]
         { info_tbl: [(cbQfT,
                       label: Control.Arrow.$p1ArrowApply_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQfT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQfU; else goto cbQfV;
       cbQfU: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowApply_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQfV: // global
           I64[Sp - 8] = block_cbQfQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQfZ; else goto cbQfR;
       ubQfZ: // global
           call _cbQfQ(R1) args: 0, res: 0, upd: 0;
       cbQfR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQfQ() //  [R1]
         { info_tbl: [(cbQfQ,
                       label: block_cbQfQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQfQ: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.807549905 UTC

[section ""data" . Control.Arrow.app_closure" {
     Control.Arrow.app_closure:
         const Control.Arrow.app_info;
 },
 Control.Arrow.app_entry() //  [R2]
         { info_tbl: [(cbQgj,
                       label: Control.Arrow.app_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQgj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQgk; else goto cbQgl;
       cbQgk: // global
           R2 = R2;
           R1 = Control.Arrow.app_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQgl: // global
           I64[Sp - 8] = block_cbQgg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQgp; else goto cbQgh;
       ubQgp: // global
           call _cbQgg(R1) args: 0, res: 0, upd: 0;
       cbQgh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQgg() //  [R1]
         { info_tbl: [(cbQgg,
                       label: block_cbQgg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQgg: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.81280069 UTC

[section ""data" . Control.Arrow.$p1ArrowChoice_closure" {
     Control.Arrow.$p1ArrowChoice_closure:
         const Control.Arrow.$p1ArrowChoice_info;
 },
 Control.Arrow.$p1ArrowChoice_entry() //  [R2]
         { info_tbl: [(cbQgH,
                       label: Control.Arrow.$p1ArrowChoice_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQgH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQgI; else goto cbQgJ;
       cbQgI: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowChoice_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQgJ: // global
           I64[Sp - 8] = block_cbQgE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQgN; else goto cbQgF;
       ubQgN: // global
           call _cbQgE(R1) args: 0, res: 0, upd: 0;
       cbQgF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQgE() //  [R1]
         { info_tbl: [(cbQgE,
                       label: block_cbQgE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQgE: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.818099421 UTC

[section ""data" . Control.Arrow.left_closure" {
     Control.Arrow.left_closure:
         const Control.Arrow.left_info;
 },
 Control.Arrow.left_entry() //  [R2]
         { info_tbl: [(cbQh7,
                       label: Control.Arrow.left_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQh7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQh8; else goto cbQh9;
       cbQh8: // global
           R2 = R2;
           R1 = Control.Arrow.left_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQh9: // global
           I64[Sp - 8] = block_cbQh4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQhd; else goto cbQh5;
       ubQhd: // global
           call _cbQh4(R1) args: 0, res: 0, upd: 0;
       cbQh5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQh4() //  [R1]
         { info_tbl: [(cbQh4,
                       label: block_cbQh4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQh4: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.823656825 UTC

[section ""data" . Control.Arrow.right_closure" {
     Control.Arrow.right_closure:
         const Control.Arrow.right_info;
 },
 Control.Arrow.right_entry() //  [R2]
         { info_tbl: [(cbQhv,
                       label: Control.Arrow.right_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQhv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQhw; else goto cbQhx;
       cbQhw: // global
           R2 = R2;
           R1 = Control.Arrow.right_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQhx: // global
           I64[Sp - 8] = block_cbQhs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQhB; else goto cbQht;
       ubQhB: // global
           call _cbQhs(R1) args: 0, res: 0, upd: 0;
       cbQht: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQhs() //  [R1]
         { info_tbl: [(cbQhs,
                       label: block_cbQhs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQhs: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.829029011 UTC

[section ""data" . Control.Arrow.+++_closure" {
     Control.Arrow.+++_closure:
         const Control.Arrow.+++_info;
 },
 Control.Arrow.+++_entry() //  [R2]
         { info_tbl: [(cbQhT,
                       label: Control.Arrow.+++_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQhT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQhU; else goto cbQhV;
       cbQhU: // global
           R2 = R2;
           R1 = Control.Arrow.+++_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQhV: // global
           I64[Sp - 8] = block_cbQhQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQhZ; else goto cbQhR;
       ubQhZ: // global
           call _cbQhQ(R1) args: 0, res: 0, upd: 0;
       cbQhR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQhQ() //  [R1]
         { info_tbl: [(cbQhQ,
                       label: block_cbQhQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQhQ: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.835734751 UTC

[section ""data" . Control.Arrow.|||_closure" {
     Control.Arrow.|||_closure:
         const Control.Arrow.|||_info;
 },
 Control.Arrow.|||_entry() //  [R2]
         { info_tbl: [(cbQih,
                       label: Control.Arrow.|||_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQih: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQii; else goto cbQij;
       cbQii: // global
           R2 = R2;
           R1 = Control.Arrow.|||_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQij: // global
           I64[Sp - 8] = block_cbQie_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQin; else goto cbQif;
       ubQin: // global
           call _cbQie(R1) args: 0, res: 0, upd: 0;
       cbQif: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQie() //  [R1]
         { info_tbl: [(cbQie,
                       label: block_cbQie_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQie: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.841155347 UTC

[section ""data" . Control.Arrow.$p1ArrowPlus_closure" {
     Control.Arrow.$p1ArrowPlus_closure:
         const Control.Arrow.$p1ArrowPlus_info;
 },
 Control.Arrow.$p1ArrowPlus_entry() //  [R2]
         { info_tbl: [(cbQiF,
                       label: Control.Arrow.$p1ArrowPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQiF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQiG; else goto cbQiH;
       cbQiG: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQiH: // global
           I64[Sp - 8] = block_cbQiC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQiL; else goto cbQiD;
       ubQiL: // global
           call _cbQiC(R1) args: 0, res: 0, upd: 0;
       cbQiD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQiC() //  [R1]
         { info_tbl: [(cbQiC,
                       label: block_cbQiC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQiC: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.846634673 UTC

[section ""data" . Control.Arrow.<+>_closure" {
     Control.Arrow.<+>_closure:
         const Control.Arrow.<+>_info;
 },
 Control.Arrow.<+>_entry() //  [R2]
         { info_tbl: [(cbQj5,
                       label: Control.Arrow.<+>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQj5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQj6; else goto cbQj7;
       cbQj6: // global
           R2 = R2;
           R1 = Control.Arrow.<+>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQj7: // global
           I64[Sp - 8] = block_cbQj2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQjb; else goto cbQj3;
       ubQjb: // global
           call _cbQj2(R1) args: 0, res: 0, upd: 0;
       cbQj3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQj2() //  [R1]
         { info_tbl: [(cbQj2,
                       label: block_cbQj2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQj2: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.852439433 UTC

[section ""data" . Control.Arrow.$p1ArrowZero_closure" {
     Control.Arrow.$p1ArrowZero_closure:
         const Control.Arrow.$p1ArrowZero_info;
 },
 Control.Arrow.$p1ArrowZero_entry() //  [R2]
         { info_tbl: [(cbQjt,
                       label: Control.Arrow.$p1ArrowZero_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQjt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQju; else goto cbQjv;
       cbQju: // global
           R2 = R2;
           R1 = Control.Arrow.$p1ArrowZero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQjv: // global
           I64[Sp - 8] = block_cbQjq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQjz; else goto cbQjr;
       ubQjz: // global
           call _cbQjq(R1) args: 0, res: 0, upd: 0;
       cbQjr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQjq() //  [R1]
         { info_tbl: [(cbQjq,
                       label: block_cbQjq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQjq: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.858001282 UTC

[section ""data" . Control.Arrow.zeroArrow_closure" {
     Control.Arrow.zeroArrow_closure:
         const Control.Arrow.zeroArrow_info;
 },
 Control.Arrow.zeroArrow_entry() //  [R2]
         { info_tbl: [(cbQjT,
                       label: Control.Arrow.zeroArrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQjT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQjU; else goto cbQjV;
       cbQjU: // global
           R2 = R2;
           R1 = Control.Arrow.zeroArrow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQjV: // global
           I64[Sp - 8] = block_cbQjQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQjZ; else goto cbQjR;
       ubQjZ: // global
           call _cbQjQ(R1) args: 0, res: 0, upd: 0;
       cbQjR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQjQ() //  [R1]
         { info_tbl: [(cbQjQ,
                       label: block_cbQjQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQjQ: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.86355971 UTC

[section ""data" . Control.Arrow.$p1Arrow_closure" {
     Control.Arrow.$p1Arrow_closure:
         const Control.Arrow.$p1Arrow_info;
 },
 Control.Arrow.$p1Arrow_entry() //  [R2]
         { info_tbl: [(cbQkh,
                       label: Control.Arrow.$p1Arrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQkh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQki; else goto cbQkj;
       cbQki: // global
           R2 = R2;
           R1 = Control.Arrow.$p1Arrow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQkj: // global
           I64[Sp - 8] = block_cbQke_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQkn; else goto cbQkf;
       ubQkn: // global
           call _cbQke(R1) args: 0, res: 0, upd: 0;
       cbQkf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQke() //  [R1]
         { info_tbl: [(cbQke,
                       label: block_cbQke_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQke: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.870329275 UTC

[section ""data" . Control.Arrow.arr_closure" {
     Control.Arrow.arr_closure:
         const Control.Arrow.arr_info;
 },
 Control.Arrow.arr_entry() //  [R2]
         { info_tbl: [(cbQkH,
                       label: Control.Arrow.arr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQkH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQkI; else goto cbQkJ;
       cbQkI: // global
           R2 = R2;
           R1 = Control.Arrow.arr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQkJ: // global
           I64[Sp - 8] = block_cbQkE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQkN; else goto cbQkF;
       ubQkN: // global
           call _cbQkE(R1) args: 0, res: 0, upd: 0;
       cbQkF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQkE() //  [R1]
         { info_tbl: [(cbQkE,
                       label: block_cbQkE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQkE: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.875802535 UTC

[section ""data" . Control.Arrow.first_closure" {
     Control.Arrow.first_closure:
         const Control.Arrow.first_info;
 },
 Control.Arrow.first_entry() //  [R2]
         { info_tbl: [(cbQl5,
                       label: Control.Arrow.first_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQl5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQl6; else goto cbQl7;
       cbQl6: // global
           R2 = R2;
           R1 = Control.Arrow.first_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQl7: // global
           I64[Sp - 8] = block_cbQl2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQlb; else goto cbQl3;
       ubQlb: // global
           call _cbQl2(R1) args: 0, res: 0, upd: 0;
       cbQl3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQl2() //  [R1]
         { info_tbl: [(cbQl2,
                       label: block_cbQl2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQl2: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.881783431 UTC

[section ""data" . Control.Arrow.second_closure" {
     Control.Arrow.second_closure:
         const Control.Arrow.second_info;
 },
 Control.Arrow.second_entry() //  [R2]
         { info_tbl: [(cbQlt,
                       label: Control.Arrow.second_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQlt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQlu; else goto cbQlv;
       cbQlu: // global
           R2 = R2;
           R1 = Control.Arrow.second_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQlv: // global
           I64[Sp - 8] = block_cbQlq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQlz; else goto cbQlr;
       ubQlz: // global
           call _cbQlq(R1) args: 0, res: 0, upd: 0;
       cbQlr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQlq() //  [R1]
         { info_tbl: [(cbQlq,
                       label: block_cbQlq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQlq: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.88724063 UTC

[section ""data" . Control.Arrow.***_closure" {
     Control.Arrow.***_closure:
         const Control.Arrow.***_info;
 },
 Control.Arrow.***_entry() //  [R2]
         { info_tbl: [(cbQlR,
                       label: Control.Arrow.***_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQlR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQlS; else goto cbQlT;
       cbQlS: // global
           R2 = R2;
           R1 = Control.Arrow.***_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQlT: // global
           I64[Sp - 8] = block_cbQlO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQlX; else goto cbQlP;
       ubQlX: // global
           call _cbQlO(R1) args: 0, res: 0, upd: 0;
       cbQlP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQlO() //  [R1]
         { info_tbl: [(cbQlO,
                       label: block_cbQlO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQlO: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.892646528 UTC

[section ""data" . Control.Arrow.&&&_closure" {
     Control.Arrow.&&&_closure:
         const Control.Arrow.&&&_info;
 },
 Control.Arrow.&&&_entry() //  [R2]
         { info_tbl: [(cbQmf,
                       label: Control.Arrow.&&&_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQmf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQmg; else goto cbQmh;
       cbQmg: // global
           R2 = R2;
           R1 = Control.Arrow.&&&_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQmh: // global
           I64[Sp - 8] = block_cbQmc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQml; else goto cbQmd;
       ubQml: // global
           call _cbQmc(R1) args: 0, res: 0, upd: 0;
       cbQmd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQmc() //  [R1]
         { info_tbl: [(cbQmc,
                       label: block_cbQmc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQmc: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.898390878 UTC

[section ""data" . Control.Arrow.$c***_closure" {
     Control.Arrow.$c***_closure:
         const Control.Arrow.$c***_info;
 },
 sat_sbQ7x_entry() //  [R1]
         { info_tbl: [(cbQmF,
                       label: sat_sbQ7x_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQmF: // global
           _sbQ7x::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbQmG; else goto cbQmH;
       cbQmH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQmJ; else goto cbQmI;
       cbQmJ: // global
           HpAlloc = 24;
           goto cbQmG;
       cbQmG: // global
           R1 = _sbQ7x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQmI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQ7x::P64;
           _sbQ7m::P64 = P64[_sbQ7x::P64 + 16];
           _sbQ7n::P64 = P64[_sbQ7x::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sbQ7n::P64;
           R2 = Hp - 16;
           R1 = _sbQ7m::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbQ7s_entry() //  [R1]
         { info_tbl: [(cbQmP,
                       label: sat_sbQ7s_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQmP: // global
           _sbQ7s::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbQmQ; else goto cbQmR;
       cbQmR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQmT; else goto cbQmS;
       cbQmT: // global
           HpAlloc = 24;
           goto cbQmQ;
       cbQmQ: // global
           R1 = _sbQ7s::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQmS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQ7s::P64;
           _sbQ7l::P64 = P64[_sbQ7s::P64 + 16];
           _sbQ7n::P64 = P64[_sbQ7s::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbQ7n::P64;
           R2 = Hp - 16;
           R1 = _sbQ7l::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$c***_entry() //  [R2, R3, R4]
         { info_tbl: [(cbQmV,
                       label: Control.Arrow.$c***_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQmV: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbQmZ; else goto cbQmY;
       cbQmZ: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$c***_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQmY: // global
           I64[Hp - 80] = sat_sbQ7x_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sbQ7s_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.907953574 UTC

[section ""data" . Control.Arrow.$fArrow(->)_$carr_closure" {
     Control.Arrow.$fArrow(->)_$carr_closure:
         const Control.Arrow.$fArrow(->)_$carr_info;
 },
 Control.Arrow.$fArrow(->)_$carr_entry() //  [R2]
         { info_tbl: [(cbQnq,
                       label: Control.Arrow.$fArrow(->)_$carr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQnq: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.911808961 UTC

[section ""data" . Control.Arrow.$fCategoryTYPEKleisli1_closure" {
     Control.Arrow.$fCategoryTYPEKleisli1_closure:
         const Control.Arrow.$fCategoryTYPEKleisli1_info;
 },
 Control.Arrow.$fCategoryTYPEKleisli1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbQnC,
                       label: Control.Arrow.$fCategoryTYPEKleisli1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQnC: // global
           _sbQ7C::P64 = R5;
           _sbQ7B::P64 = R4;
           _sbQ7A::P64 = R3;
           _sbQ7z::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbQnD; else goto cbQnE;
       cbQnE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbQnG; else goto cbQnF;
       cbQnG: // global
           HpAlloc = 32;
           goto cbQnD;
       cbQnD: // global
           R5 = _sbQ7C::P64;
           R4 = _sbQ7B::P64;
           R3 = _sbQ7A::P64;
           R2 = _sbQ7z::P64;
           R1 = Control.Arrow.$fCategoryTYPEKleisli1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQnF: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbQ7B::P64;
           P64[Hp] = _sbQ7C::P64;
           R2 = _sbQ7z::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbQ7A::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.916500624 UTC

[section ""data" . Control.Arrow.$fCategoryTYPEKleisli_closure" {
     Control.Arrow.$fCategoryTYPEKleisli_closure:
         const Control.Arrow.$fCategoryTYPEKleisli_info;
 },
 sat_sbQ7G_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbQnY,
                       label: sat_sbQ7G_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQnY: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fCategoryTYPEKleisli1_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQ7F_entry() //  [R1]
         { info_tbl: [(cbQo5,
                       label: sat_sbQ7F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQo5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbQo6; else goto cbQo7;
       cbQo6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQo7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fCategoryTYPEKleisli_entry() //  [R2]
         { info_tbl: [(cbQo9,
                       label: Control.Arrow.$fCategoryTYPEKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQo9: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbQod; else goto cbQoc;
       cbQod: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Arrow.$fCategoryTYPEKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQoc: // global
           I64[Hp - 56] = sat_sbQ7G_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbQ7F_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Category.C:Category_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 53;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.924758345 UTC

[section ""data" . Control.Arrow.$fArrowKleisli4_closure" {
     Control.Arrow.$fArrowKleisli4_closure:
         const Control.Arrow.$fArrowKleisli4_info;
 },
 sat_sbQ7V_entry() //  [R1, R2]
         { info_tbl: [(cbQoH,
                       label: sat_sbQ7V_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQoH: // global
           _sbQ7T::P64 = R2;
           _sbQ7V::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbQoI; else goto cbQoJ;
       cbQoJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQoL; else goto cbQoK;
       cbQoL: // global
           HpAlloc = 24;
           goto cbQoI;
       cbQoI: // global
           R2 = _sbQ7T::P64;
           R1 = _sbQ7V::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQoK: // global
           _sbQ7H::P64 = P64[_sbQ7V::P64 + 7];
           _sbQ7K::P64 = P64[_sbQ7V::P64 + 15];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbQ7K::P64;
           P64[Hp] = _sbQ7T::P64;
           R2 = _sbQ7H::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbQ7S_entry() //  [R1]
         { info_tbl: [(cbQoR,
                       label: sat_sbQ7S_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQoR: // global
           _sbQ7S::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbQoS; else goto cbQoT;
       cbQoT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQoV; else goto cbQoU;
       cbQoV: // global
           HpAlloc = 24;
           goto cbQoS;
       cbQoS: // global
           R1 = _sbQ7S::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQoU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQ7S::P64;
           _sbQ7I::P64 = P64[_sbQ7S::P64 + 16];
           _sbQ7J::P64 = P64[_sbQ7S::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sbQ7J::P64;
           R2 = Hp - 16;
           R1 = _sbQ7I::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli4_entry() //  [R2, R3, R4]
         { info_tbl: [(cbQoW,
                       label: Control.Arrow.$fArrowKleisli4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQoW: // global
           _sbQ7J::P64 = R4;
           _sbQ7I::P64 = R3;
           _sbQ7H::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbQoX; else goto cbQoY;
       cbQoY: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbQp0; else goto cbQoZ;
       cbQp0: // global
           HpAlloc = 80;
           goto cbQoX;
       cbQoX: // global
           R4 = _sbQ7J::P64;
           R3 = _sbQ7I::P64;
           R2 = _sbQ7H::P64;
           R1 = Control.Arrow.$fArrowKleisli4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQoZ: // global
           I64[Hp - 72] = stg_sel_0_upd_info;
           P64[Hp - 56] = _sbQ7J::P64;
           I64[Hp - 48] = sat_sbQ7V_info;
           P64[Hp - 40] = _sbQ7H::P64;
           P64[Hp - 32] = Hp - 72;
           I64[Hp - 24] = sat_sbQ7S_info;
           P64[Hp - 8] = _sbQ7I::P64;
           P64[Hp] = _sbQ7J::P64;
           R2 = _sbQ7H::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.934383446 UTC

[section ""data" . Control.Arrow.$fArrowKleisli3_closure" {
     Control.Arrow.$fArrowKleisli3_closure:
         const Control.Arrow.$fArrowKleisli3_info;
 },
 sat_sbQ8a_entry() //  [R1, R2]
         { info_tbl: [(cbQpB,
                       label: sat_sbQ8a_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQpB: // global
           _sbQ88::P64 = R2;
           _sbQ8a::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbQpC; else goto cbQpD;
       cbQpD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQpF; else goto cbQpE;
       cbQpF: // global
           HpAlloc = 24;
           goto cbQpC;
       cbQpC: // global
           R2 = _sbQ88::P64;
           R1 = _sbQ8a::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQpE: // global
           _sbQ7W::P64 = P64[_sbQ8a::P64 + 7];
           _sbQ7Z::P64 = P64[_sbQ8a::P64 + 15];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbQ88::P64;
           P64[Hp] = _sbQ7Z::P64;
           R2 = _sbQ7W::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbQ87_entry() //  [R1]
         { info_tbl: [(cbQpL,
                       label: sat_sbQ87_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQpL: // global
           _sbQ87::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbQpM; else goto cbQpN;
       cbQpN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQpP; else goto cbQpO;
       cbQpP: // global
           HpAlloc = 24;
           goto cbQpM;
       cbQpM: // global
           R1 = _sbQ87::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQpO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQ87::P64;
           _sbQ7X::P64 = P64[_sbQ87::P64 + 16];
           _sbQ7Y::P64 = P64[_sbQ87::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbQ7Y::P64;
           R2 = Hp - 16;
           R1 = _sbQ7X::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli3_entry() //  [R2, R3, R4]
         { info_tbl: [(cbQpQ,
                       label: Control.Arrow.$fArrowKleisli3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQpQ: // global
           _sbQ7Y::P64 = R4;
           _sbQ7X::P64 = R3;
           _sbQ7W::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbQpR; else goto cbQpS;
       cbQpS: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbQpU; else goto cbQpT;
       cbQpU: // global
           HpAlloc = 80;
           goto cbQpR;
       cbQpR: // global
           R4 = _sbQ7Y::P64;
           R3 = _sbQ7X::P64;
           R2 = _sbQ7W::P64;
           R1 = Control.Arrow.$fArrowKleisli3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQpT: // global
           I64[Hp - 72] = stg_sel_1_upd_info;
           P64[Hp - 56] = _sbQ7Y::P64;
           I64[Hp - 48] = sat_sbQ8a_info;
           P64[Hp - 40] = _sbQ7W::P64;
           P64[Hp - 32] = Hp - 72;
           I64[Hp - 24] = sat_sbQ87_info;
           P64[Hp - 8] = _sbQ7X::P64;
           P64[Hp] = _sbQ7Y::P64;
           R2 = _sbQ7W::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.943329219 UTC

[section ""data" . Control.Arrow.$fArrowKleisli5_closure" {
     Control.Arrow.$fArrowKleisli5_closure:
         const Control.Arrow.$fArrowKleisli5_info;
 },
 Control.Arrow.$fArrowKleisli5_entry() //  [R2, R3, R4]
         { info_tbl: [(cbQqp,
                       label: Control.Arrow.$fArrowKleisli5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQqp: // global
           _sbQ8d::P64 = R4;
           _sbQ8c::P64 = R3;
           _sbQ8b::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbQqq; else goto cbQqr;
       cbQqr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbQqt; else goto cbQqs;
       cbQqt: // global
           HpAlloc = 32;
           goto cbQqq;
       cbQqq: // global
           R4 = _sbQ8d::P64;
           R3 = _sbQ8c::P64;
           R2 = _sbQ8b::P64;
           R1 = Control.Arrow.$fArrowKleisli5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQqs: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbQ8c::P64;
           P64[Hp] = _sbQ8d::P64;
           R2 = _sbQ8b::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.948201118 UTC

[section ""data" . Control.Arrow.$fArrowPlusKleisli1_closure" {
     Control.Arrow.$fArrowPlusKleisli1_closure:
         const Control.Arrow.$fArrowPlusKleisli1_info;
 },
 Control.Arrow.$fArrowPlusKleisli1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbQqI,
                       label: Control.Arrow.$fArrowPlusKleisli1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQqI: // global
           _sbQ8i::P64 = R5;
           _sbQ8h::P64 = R4;
           _sbQ8g::P64 = R3;
           _sbQ8f::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbQqJ; else goto cbQqK;
       cbQqK: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbQqM; else goto cbQqL;
       cbQqM: // global
           HpAlloc = 64;
           goto cbQqJ;
       cbQqJ: // global
           R5 = _sbQ8i::P64;
           R4 = _sbQ8h::P64;
           R3 = _sbQ8g::P64;
           R2 = _sbQ8f::P64;
           R1 = Control.Arrow.$fArrowPlusKleisli1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQqL: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sbQ8h::P64;
           P64[Hp - 32] = _sbQ8i::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbQ8g::P64;
           P64[Hp] = _sbQ8i::P64;
           R2 = _sbQ8f::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.952739508 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_$capp_closure" {
     Control.Arrow.$fAlternativeArrowMonad_$capp_closure:
         const Control.Arrow.$fAlternativeArrowMonad_$capp_info;
 },
 Control.Arrow.$fAlternativeArrowMonad_$capp_entry() //  [R2]
         { info_tbl: [(cbQr4,
                       label: Control.Arrow.$fAlternativeArrowMonad_$capp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQr4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQr5; else goto cbQr6;
       cbQr5: // global
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_$capp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQr6: // global
           I64[Sp - 8] = block_cbQr1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQra; else goto cbQr2;
       ubQra: // global
           call _cbQr1(R1) args: 0, res: 0, upd: 0;
       cbQr2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQr1() //  [R1]
         { info_tbl: [(cbQr1,
                       label: block_cbQr1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQr1: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.958388048 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad5_closure" {
     Control.Arrow.$fApplicativeArrowMonad5_closure:
         const Control.Arrow.$fApplicativeArrowMonad5_info;
 },
 sat_sbQ8t_entry() //  [R1]
         { info_tbl: [(cbQrt,
                       label: sat_sbQ8t_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQrt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQru; else goto cbQrv;
       cbQru: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQrv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad5_entry() //  [R2, R3, R4]
         { info_tbl: [(cbQry,
                       label: Control.Arrow.$fApplicativeArrowMonad5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQry: // global
           _sbQ8r::P64 = R4;
           _sbQ8q::P64 = R3;
           _sbQ8p::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbQrz; else goto cbQrA;
       cbQrA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbQrC; else goto cbQrB;
       cbQrC: // global
           HpAlloc = 32;
           goto cbQrz;
       cbQrz: // global
           R4 = _sbQ8r::P64;
           R3 = _sbQ8q::P64;
           R2 = _sbQ8p::P64;
           R1 = Control.Arrow.$fApplicativeArrowMonad5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQrB: // global
           I64[Hp - 24] = sat_sbQ8t_info;
           P64[Hp - 8] = _sbQ8p::P64;
           P64[Hp] = _sbQ8q::P64;
           I64[Sp - 24] = block_cbQrw_info;
           R2 = _sbQ8p::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbQ8r::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbQrw() //  [R1]
         { info_tbl: [(cbQrw,
                       label: block_cbQrw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQrw: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.966867575 UTC

[section ""data" . Control.Arrow.$fFunctorArrowMonad1_closure" {
     Control.Arrow.$fFunctorArrowMonad1_closure:
         const Control.Arrow.$fFunctorArrowMonad1_info;
 },
 sat_sbQ8z_entry() //  [R1]
         { info_tbl: [(cbQsc,
                       label: sat_sbQ8z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQsc: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQ8A_entry() //  [R1]
         { info_tbl: [(cbQsf,
                       label: sat_sbQ8A_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQsf: // global
           _sbQ8A::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbQsg; else goto cbQsh;
       cbQsh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbQsj; else goto cbQsi;
       cbQsj: // global
           HpAlloc = 16;
           goto cbQsg;
       cbQsg: // global
           R1 = _sbQ8A::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQsi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQ8A::P64;
           _sbQ8u::P64 = P64[_sbQ8A::P64 + 16];
           _sbQ8v::P64 = P64[_sbQ8A::P64 + 24];
           I64[Hp - 8] = sat_sbQ8z_info;
           P64[Hp] = _sbQ8v::P64;
           R2 = _sbQ8u::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fFunctorArrowMonad1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbQsm,
                       label: Control.Arrow.$fFunctorArrowMonad1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQsm: // global
           _sbQ8w::P64 = R4;
           _sbQ8v::P64 = R3;
           _sbQ8u::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbQsn; else goto cbQso;
       cbQso: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbQsq; else goto cbQsp;
       cbQsq: // global
           HpAlloc = 32;
           goto cbQsn;
       cbQsn: // global
           R4 = _sbQ8w::P64;
           R3 = _sbQ8v::P64;
           R2 = _sbQ8u::P64;
           R1 = Control.Arrow.$fFunctorArrowMonad1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQsp: // global
           I64[Hp - 24] = sat_sbQ8A_info;
           P64[Hp - 8] = _sbQ8u::P64;
           P64[Hp] = _sbQ8v::P64;
           I64[Sp - 24] = block_cbQsk_info;
           R2 = _sbQ8u::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbQ8w::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbQsk() //  [R1]
         { info_tbl: [(cbQsk,
                       label: block_cbQsk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQsk: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.976559967 UTC

[section ""data" . Control.Arrow.$fFunctorArrowMonad_closure" {
     Control.Arrow.$fFunctorArrowMonad_closure:
         const Control.Arrow.$fFunctorArrowMonad_info;
 },
 sat_sbQ8D_entry() //  [R1, R2, R3]
         { info_tbl: [(cbQt0,
                       label: sat_sbQ8D_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQt0: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fFunctorArrowMonad1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQ8C_entry() //  [R1, R2, R3]
         { info_tbl: [(cbQt8,
                       label: sat_sbQ8C_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQt8: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fApplicativeArrowMonad5_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fFunctorArrowMonad_entry() //  [R2]
         { info_tbl: [(cbQtc,
                       label: Control.Arrow.$fFunctorArrowMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQtc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbQtg; else goto cbQtf;
       cbQtg: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Arrow.$fFunctorArrowMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQtf: // global
           I64[Hp - 48] = sat_sbQ8D_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sbQ8C_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.984588316 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad2_closure" {
     Control.Arrow.$fAlternativeArrowMonad2_closure:
         const Control.Arrow.$fAlternativeArrowMonad2_info;
 },
 sat_sbQ8J_entry() //  [R1]
         { info_tbl: [(cbQtF,
                       label: sat_sbQ8J_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQtF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbQtG; else goto cbQtH;
       cbQtG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQtH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Arrow.&&&_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbQ8I_entry() //  [R1]
         { info_tbl: [(cbQtM,
                       label: sat_sbQ8I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQtM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQtN; else goto cbQtO;
       cbQtN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQtO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fAlternativeArrowMonad_$capp_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbQtR,
                       label: Control.Arrow.$fAlternativeArrowMonad2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQtR: // global
           _sbQ8G::P64 = R4;
           _sbQ8F::P64 = R3;
           _sbQ8E::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbQtS; else goto cbQtT;
       cbQtT: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbQtV; else goto cbQtU;
       cbQtV: // global
           HpAlloc = 64;
           goto cbQtS;
       cbQtS: // global
           R4 = _sbQ8G::P64;
           R3 = _sbQ8F::P64;
           R2 = _sbQ8E::P64;
           R1 = Control.Arrow.$fAlternativeArrowMonad2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQtU: // global
           I64[Hp - 56] = sat_sbQ8J_info;
           P64[Hp - 40] = _sbQ8E::P64;
           P64[Hp - 32] = _sbQ8F::P64;
           P64[Hp - 24] = _sbQ8G::P64;
           I64[Hp - 16] = sat_sbQ8I_info;
           P64[Hp] = _sbQ8E::P64;
           I64[Sp - 24] = block_cbQtP_info;
           R2 = _sbQ8E::P64;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbQtP() //  [R1]
         { info_tbl: [(cbQtP,
                       label: block_cbQtP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQtP: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbQtB::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbQtB::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:43.995272699 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad6_closure" {
     Control.Arrow.$fApplicativeArrowMonad6_closure:
         const Control.Arrow.$fApplicativeArrowMonad6_info;
 },
 sat_sbQ8N_entry() //  [R1]
         { info_tbl: [(cbQuC,
                       label: sat_sbQ8N_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQuC: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad6_entry() //  [R2, R3]
         { info_tbl: [(cbQuF,
                       label: Control.Arrow.$fApplicativeArrowMonad6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQuF: // global
           _sbQ8L::P64 = R3;
           _sbQ8K::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbQuG; else goto cbQuH;
       cbQuH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbQuJ; else goto cbQuI;
       cbQuJ: // global
           HpAlloc = 16;
           goto cbQuG;
       cbQuG: // global
           R3 = _sbQ8L::P64;
           R2 = _sbQ8K::P64;
           R1 = Control.Arrow.$fApplicativeArrowMonad6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQuI: // global
           I64[Hp - 8] = sat_sbQ8N_info;
           P64[Hp] = _sbQ8L::P64;
           R2 = _sbQ8K::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Arrow.arr_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.000906095 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad4_closure" {
     Control.Arrow.$fApplicativeArrowMonad4_closure:
         const Control.Arrow.$fApplicativeArrowMonad4_info;
 },
 sat_sbQ8R_entry() //  [R1]
         { info_tbl: [(cbQv3,
                       label: sat_sbQ8R_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQv3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbQv4; else goto cbQv5;
       cbQv4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQv5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fApplicativeArrowMonad5_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad4_entry() //  [R2, R3, R4]
         { info_tbl: [(cbQv6,
                       label: Control.Arrow.$fApplicativeArrowMonad4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQv6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbQva; else goto cbQv9;
       cbQva: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fApplicativeArrowMonad4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQv9: // global
           I64[Hp - 32] = sat_sbQ8R_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = Hp - 32;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad2_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.006355353 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad3_closure" {
     Control.Arrow.$fApplicativeArrowMonad3_closure:
         const Control.Arrow.$fApplicativeArrowMonad3_info;
 },
 Control.Arrow.$fApplicativeArrowMonad3_entry() //  [R3]
         { info_tbl: [(cbQvp,
                       label: Control.Arrow.$fApplicativeArrowMonad3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQvp: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.010228086 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad2_closure" {
     Control.Arrow.$fApplicativeArrowMonad2_closure:
         const Control.Arrow.$fApplicativeArrowMonad2_info;
 },
 sat_sbQ8Y_entry() //  [R1]
         { info_tbl: [(cbQvI,
                       label: sat_sbQ8Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQvI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQvJ; else goto cbQvK;
       cbQvJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQvK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fApplicativeArrowMonad3_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbQ8Z_entry() //  [R1]
         { info_tbl: [(cbQvN,
                       label: sat_sbQ8Z_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQvN: // global
           _sbQ8Z::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbQvO; else goto cbQvP;
       cbQvP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQvR; else goto cbQvQ;
       cbQvR: // global
           HpAlloc = 24;
           goto cbQvO;
       cbQvO: // global
           R1 = _sbQ8Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQvQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQ8Z::P64;
           _sbQ8U::P64 = P64[_sbQ8Z::P64 + 16];
           _sbQ8V::P64 = P64[_sbQ8Z::P64 + 24];
           I64[Hp - 16] = sat_sbQ8Y_info;
           P64[Hp] = _sbQ8U::P64;
           I64[Sp - 40] = block_cbQvL_info;
           R2 = _sbQ8U::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbQ8V::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbQvL() //  [R1]
         { info_tbl: [(cbQvL,
                       label: block_cbQvL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQvL: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbQvV,
                       label: Control.Arrow.$fApplicativeArrowMonad2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQvV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbQvZ; else goto cbQvY;
       cbQvZ: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fApplicativeArrowMonad2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQvY: // global
           I64[Hp - 24] = sat_sbQ8Z_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R4 = R4;
           R3 = Hp - 24;
           R2 = R2;
           call Control.Arrow.$fAlternativeArrowMonad2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.021794907 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad1_closure" {
     Control.Arrow.$fApplicativeArrowMonad1_closure:
         const Control.Arrow.$fApplicativeArrowMonad1_info;
 },
 sat_sbQ93_entry() //  [R1]
         { info_tbl: [(cbQwA,
                       label: sat_sbQ93_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQwA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQwB; else goto cbQwC;
       cbQwB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQwC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Base.const_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbQ94_entry() //  [R1]
         { info_tbl: [(cbQwF,
                       label: sat_sbQ94_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQwF: // global
           _sbQ94::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbQwG; else goto cbQwH;
       cbQwH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQwJ; else goto cbQwI;
       cbQwJ: // global
           HpAlloc = 24;
           goto cbQwG;
       cbQwG: // global
           R1 = _sbQ94::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQwI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQ94::P64;
           _sbQ90::P64 = P64[_sbQ94::P64 + 16];
           _sbQ91::P64 = P64[_sbQ94::P64 + 24];
           I64[Hp - 16] = sat_sbQ93_info;
           P64[Hp] = _sbQ90::P64;
           I64[Sp - 40] = block_cbQwD_info;
           R2 = _sbQ90::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbQ91::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbQwD() //  [R1]
         { info_tbl: [(cbQwD,
                       label: block_cbQwD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQwD: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad1_entry() //  [R2, R3]
         { info_tbl: [(cbQwN,
                       label: Control.Arrow.$fApplicativeArrowMonad1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQwN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbQwR; else goto cbQwQ;
       cbQwR: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fApplicativeArrowMonad1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQwQ: // global
           I64[Hp - 24] = sat_sbQ94_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad2_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.033873864 UTC

[section ""data" . Control.Arrow.$fApplicativeArrowMonad_closure" {
     Control.Arrow.$fApplicativeArrowMonad_closure:
         const Control.Arrow.$fApplicativeArrowMonad_info;
 },
 sat_sbQ9b_entry() //  [R1, R2]
         { info_tbl: [(cbQxq,
                       label: sat_sbQ9b_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQxq: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fApplicativeArrowMonad1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQ9a_entry() //  [R1, R2, R3]
         { info_tbl: [(cbQxy,
                       label: sat_sbQ9a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQxy: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fApplicativeArrowMonad2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQ99_entry() //  [R1, R2, R3]
         { info_tbl: [(cbQxG,
                       label: sat_sbQ99_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQxG: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fApplicativeArrowMonad4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQ98_entry() //  [R1, R2, R3]
         { info_tbl: [(cbQxO,
                       label: sat_sbQ98_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQxO: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fAlternativeArrowMonad2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQ97_entry() //  [R1, R2]
         { info_tbl: [(cbQxW,
                       label: sat_sbQ97_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQxW: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fApplicativeArrowMonad6_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQ96_entry() //  [R1]
         { info_tbl: [(cbQy3,
                       label: sat_sbQ96_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQy3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbQy4; else goto cbQy5;
       cbQy4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQy5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fFunctorArrowMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fApplicativeArrowMonad_entry() //  [R2]
         { info_tbl: [(cbQy7,
                       label: Control.Arrow.$fApplicativeArrowMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQy7: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cbQyb; else goto cbQya;
       cbQyb: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = Control.Arrow.$fApplicativeArrowMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQya: // global
           I64[Hp - 152] = sat_sbQ9b_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbQ9a_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbQ99_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbQ98_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbQ97_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbQ96_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 87;
           P64[Hp - 24] = Hp - 102;
           P64[Hp - 16] = Hp - 118;
           P64[Hp - 8] = Hp - 134;
           P64[Hp] = Hp - 151;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.050304659 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad_$c>>=_closure" {
     Control.Arrow.$fMonadArrowMonad_$c>>=_closure:
         const Control.Arrow.$fMonadArrowMonad_$c>>=_info;
 },
 sat_sbQ9k_entry() //  [R1, R2]
         { info_tbl: [(cbQzf,
                       label: sat_sbQ9k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQzf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbQzj; else goto cbQzi;
       cbQzj: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQzi: // global
           _sbQ9e::P64 = P64[R1 + 7];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sbQ9e::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Tuple.()_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQ9l_entry() //  [R1]
         { info_tbl: [(cbQzk,
                       label: sat_sbQ9l_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQzk: // global
           _sbQ9l::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbQzl; else goto cbQzm;
       cbQzm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbQzo; else goto cbQzn;
       cbQzo: // global
           HpAlloc = 16;
           goto cbQzl;
       cbQzl: // global
           R1 = _sbQ9l::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQzn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQ9l::P64;
           _sbQ9e::P64 = P64[_sbQ9l::P64 + 16];
           _sbQ9f::P64 = P64[_sbQ9l::P64 + 24];
           I64[Hp - 8] = sat_sbQ9k_info;
           P64[Hp] = _sbQ9e::P64;
           R2 = _sbQ9f::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbQ9m_entry() //  [R1]
         { info_tbl: [(cbQzp,
                       label: sat_sbQ9m_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQzp: // global
           _sbQ9m::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbQzq; else goto cbQzr;
       cbQzr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbQzt; else goto cbQzs;
       cbQzt: // global
           HpAlloc = 32;
           goto cbQzq;
       cbQzq: // global
           R1 = _sbQ9m::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQzs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQ9m::P64;
           _sbQ9d::P64 = P64[_sbQ9m::P64 + 16];
           _sbQ9e::P64 = P64[_sbQ9m::P64 + 24];
           _sbQ9f::P64 = P64[_sbQ9m::P64 + 32];
           _sbQ9g::P64 = P64[_sbQ9m::P64 + 40];
           I64[Hp - 24] = sat_sbQ9l_info;
           P64[Hp - 8] = _sbQ9e::P64;
           P64[Hp] = _sbQ9f::P64;
           R2 = _sbQ9g::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sbQ9d::P64;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbQ9h_entry() //  [R1]
         { info_tbl: [(cbQzy,
                       label: sat_sbQ9h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQzy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbQzz; else goto cbQzA;
       cbQzz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQzA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.app_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fMonadArrowMonad_$c>>=_entry() //  [R2, R3, R4]
         { info_tbl: [(cbQzB,
                       label: Control.Arrow.$fMonadArrowMonad_$c>>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQzB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbQzC; else goto cbQzD;
       cbQzC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fMonadArrowMonad_$c>>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQzD: // global
           I64[Sp - 32] = block_cbQyS_info;
           _sbQ9c::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbQ9c::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Arrow.$p1ArrowApply_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbQyS() //  [R1]
         { info_tbl: [(cbQyS,
                       label: block_cbQyS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQyS: // global
           I64[Sp - 8] = block_cbQyW_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbQyW() //  [R1]
         { info_tbl: [(cbQyW,
                       label: block_cbQyW_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQyW: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbQzH; else goto cbQzG;
       cbQzH: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbQzG: // global
           I64[Hp - 64] = sat_sbQ9m_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbQ9h_info;
           P64[Hp] = P64[Sp + 16];
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 16;
           P64[Sp + 32] = Hp - 64;
           Sp = Sp + 16;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.067783948 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad_$cp1Monad_closure" {
     Control.Arrow.$fMonadArrowMonad_$cp1Monad_closure:
         const Control.Arrow.$fMonadArrowMonad_$cp1Monad_info;
 },
 sat_sbQ9o_entry() //  [R1]
         { info_tbl: [(cbQAG,
                       label: sat_sbQ9o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQAG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbQAH; else goto cbQAI;
       cbQAH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQAI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowApply_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fMonadArrowMonad_$cp1Monad_entry() //  [R2]
         { info_tbl: [(cbQAJ,
                       label: Control.Arrow.$fMonadArrowMonad_$cp1Monad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQAJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQAN; else goto cbQAM;
       cbQAN: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Arrow.$fMonadArrowMonad_$cp1Monad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQAM: // global
           I64[Hp - 16] = sat_sbQ9o_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Arrow.$fApplicativeArrowMonad_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.073790917 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad1_closure" {
     Control.Arrow.$fMonadArrowMonad1_closure:
         const Control.Arrow.$fMonadArrowMonad1_info;
 },
 sat_sbQ9t_entry() //  [R1]
         { info_tbl: [(cbQB7,
                       label: sat_sbQ9t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQB7: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fMonadArrowMonad1_entry() //  [R2, R3]
         { info_tbl: [(cbQBc,
                       label: Control.Arrow.$fMonadArrowMonad1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQBc: // global
           _sbQ9q::P64 = R3;
           _sbQ9p::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbQBd; else goto cbQBe;
       cbQBe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbQBg; else goto cbQBf;
       cbQBg: // global
           HpAlloc = 16;
           goto cbQBd;
       cbQBd: // global
           R3 = _sbQ9q::P64;
           R2 = _sbQ9p::P64;
           R1 = Control.Arrow.$fMonadArrowMonad1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQBf: // global
           I64[Hp - 8] = sat_sbQ9t_info;
           P64[Hp] = _sbQ9q::P64;
           I64[Sp - 16] = block_cbQBa_info;
           R2 = _sbQ9p::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowApply_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbQBa() //  [R1]
         { info_tbl: [(cbQBa,
                       label: block_cbQBa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQBa: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call Control.Arrow.arr_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.080866355 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad_$c>>_closure" {
     Control.Arrow.$fMonadArrowMonad_$c>>_closure:
         const Control.Arrow.$fMonadArrowMonad_$c>>_info;
 },
 sat_sbQ9y_entry() //  [R1]
         { info_tbl: [(cbQBI,
                       label: sat_sbQ9y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQBI: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fMonadArrowMonad_$c>>_entry() //  [R2, R3, R4]
         { info_tbl: [(cbQBL,
                       label: Control.Arrow.$fMonadArrowMonad_$c>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQBL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbQBP; else goto cbQBO;
       cbQBP: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fMonadArrowMonad_$c>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQBO: // global
           I64[Hp - 8] = sat_sbQ9y_info;
           P64[Hp] = R4;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Control.Arrow.$fMonadArrowMonad_$c>>=_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.086592963 UTC

[section ""data" . lvl_rbNC6_closure" {
     lvl_rbNC6_closure:
         const lvl_rbNC6_info;
         const 0;
 },
 lvl_rbNC6_entry() //  [R2]
         { info_tbl: [(cbQC2,
                       label: lvl_rbNC6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQC2: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.090496714 UTC

[section ""data" . Control.Arrow.$fMonadArrowMonad_closure" {
     Control.Arrow.$fMonadArrowMonad_closure:
         const Control.Arrow.$fMonadArrowMonad_info;
         const 0;
 },
 sat_sbQ9E_entry() //  [R1, R2]
         { info_tbl: [(cbQCj,
                       label: sat_sbQ9E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQCj: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fMonadArrowMonad1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQ9D_entry() //  [R1, R2, R3]
         { info_tbl: [(cbQCr,
                       label: sat_sbQ9D_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQCr: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fMonadArrowMonad_$c>>_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQ9C_entry() //  [R1, R2, R3]
         { info_tbl: [(cbQCz,
                       label: sat_sbQ9C_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQCz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fMonadArrowMonad_$c>>=_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQ9B_entry() //  [R1]
         { info_tbl: [(cbQCG,
                       label: sat_sbQ9B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQCG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbQCH; else goto cbQCI;
       cbQCH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQCI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fMonadArrowMonad_$cp1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fMonadArrowMonad_entry() //  [R2]
         { info_tbl: [(cbQCK,
                       label: Control.Arrow.$fMonadArrowMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQCK: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cbQCO; else goto cbQCN;
       cbQCO: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Control.Arrow.$fMonadArrowMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQCN: // global
           I64[Hp - 112] = sat_sbQ9E_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbQ9D_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbQ9C_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbQ9B_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 94;
           P64[Hp - 8] = Hp - 111;
           P64[Hp] = lvl_rbNC6_closure+1;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.100881736 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad3_closure" {
     Control.Arrow.$fAlternativeArrowMonad3_closure:
         const Control.Arrow.$fAlternativeArrowMonad3_info;
 },
 Control.Arrow.$fAlternativeArrowMonad3_entry() //  [R2]
         { info_tbl: [(cbQDo,
                       label: Control.Arrow.$fAlternativeArrowMonad3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQDo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQDp; else goto cbQDq;
       cbQDp: // global
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQDq: // global
           I64[Sp - 8] = block_cbQDm_info;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Arrow.$p1ArrowPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbQDm() //  [R1]
         { info_tbl: [(cbQDm,
                       label: block_cbQDm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQDm: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Arrow.zeroArrow_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.107202899 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_closure" {
     Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_closure:
         const Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_info;
 },
 sat_sbQ9J_entry() //  [R1]
         { info_tbl: [(cbQDN,
                       label: sat_sbQ9J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQDN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbQDO; else goto cbQDP;
       cbQDO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQDP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbQDL_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1ArrowPlus_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbQDL() //  [R1]
         { info_tbl: [(cbQDL,
                       label: block_cbQDL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQDL: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_entry() //  [R2]
         { info_tbl: [(cbQDT,
                       label: Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQDT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQDX; else goto cbQDW;
       cbQDX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQDW: // global
           I64[Hp - 16] = sat_sbQ9J_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Arrow.$fApplicativeArrowMonad_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.114014708 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad1_closure" {
     Control.Arrow.$fAlternativeArrowMonad1_closure:
         const Control.Arrow.$fAlternativeArrowMonad1_info;
 },
 Control.Arrow.$fAlternativeArrowMonad1_entry() //  []
         { info_tbl: [(cbQEg,
                       label: Control.Arrow.$fAlternativeArrowMonad1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQEg: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.118701075 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_$csome_closure" {
     Control.Arrow.$fAlternativeArrowMonad_$csome_closure:
         const Control.Arrow.$fAlternativeArrowMonad_$csome_info;
 },
 sat_sbQ9V_entry() //  [R1]
         { info_tbl: [(cbQER,
                       label: sat_sbQ9V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQER: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQES; else goto cbQET;
       cbQES: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQET: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fAlternativeArrowMonad1_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbQ9W_entry() //  [R1]
         { info_tbl: [(cbQEU,
                       label: sat_sbQ9W_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQEU: // global
           _sbQ9W::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbQEV; else goto cbQEW;
       cbQEW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQEY; else goto cbQEX;
       cbQEY: // global
           HpAlloc = 24;
           goto cbQEV;
       cbQEV: // global
           R1 = _sbQ9W::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQEX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQ9W::P64;
           _sbQ9L::P64 = P64[_sbQ9W::P64 + 16];
           _sbQ9N::P64 = P64[_sbQ9W::P64 + 24];
           _sbQ9P::P64 = P64[_sbQ9W::P64 + 32];
           I64[Hp - 16] = sat_sbQ9V_info;
           P64[Hp] = _sbQ9P::P64;
           R2 = _sbQ9L::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbQ9N::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call Control.Arrow.<+>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbQ9T_entry() //  [R1]
         { info_tbl: [(cbQF7,
                       label: sat_sbQ9T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQF7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQF8; else goto cbQF9;
       cbQF8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQF9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbQ9U_entry() //  [R1]
         { info_tbl: [(cbQFc,
                       label: sat_sbQ9U_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQFc: // global
           _sbQ9U::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbQFd; else goto cbQFe;
       cbQFe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQFg; else goto cbQFf;
       cbQFg: // global
           HpAlloc = 24;
           goto cbQFd;
       cbQFd: // global
           R1 = _sbQ9U::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQFf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQ9U::P64;
           _sbQ9M::P64 = P64[_sbQ9U::P64 + 16];
           _sbQ9P::P64 = P64[_sbQ9U::P64 + 24];
           I64[Hp - 16] = sat_sbQ9T_info;
           P64[Hp] = _sbQ9P::P64;
           I64[Sp - 40] = block_cbQFa_info;
           R2 = _sbQ9P::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbQ9M::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbQFa() //  [R1]
         { info_tbl: [(cbQFa,
                       label: block_cbQFa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQFa: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbQ9X_entry() //  [R1]
         { info_tbl: [(cbQFk,
                       label: sat_sbQ9X_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQFk: // global
           _sbQ9X::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbQFl; else goto cbQFm;
       cbQFm: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbQFo; else goto cbQFn;
       cbQFo: // global
           HpAlloc = 72;
           goto cbQFl;
       cbQFl: // global
           R1 = _sbQ9X::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQFn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQ9X::P64;
           _sbQ9L::P64 = P64[_sbQ9X::P64 + 16];
           _sbQ9M::P64 = P64[_sbQ9X::P64 + 24];
           _sbQ9N::P64 = P64[_sbQ9X::P64 + 32];
           _sbQ9P::P64 = P64[_sbQ9X::P64 + 40];
           I64[Hp - 64] = sat_sbQ9W_info;
           P64[Hp - 48] = _sbQ9L::P64;
           P64[Hp - 40] = _sbQ9N::P64;
           P64[Hp - 32] = _sbQ9P::P64;
           I64[Hp - 24] = sat_sbQ9U_info;
           P64[Hp - 8] = _sbQ9M::P64;
           P64[Hp] = _sbQ9P::P64;
           R2 = _sbQ9P::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 64;
           Sp = Sp - 40;
           call Control.Arrow.&&&_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbQ9R_entry() //  [R1]
         { info_tbl: [(cbQFt,
                       label: sat_sbQ9R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQFt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQFu; else goto cbQFv;
       cbQFu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQFv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fAlternativeArrowMonad_$capp_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 some_v_sbQ9N_entry() //  [R1]
         { info_tbl: [(cbQFw,
                       label: some_v_sbQ9N_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQFw: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbQFy; else goto cbQFz;
       cbQFy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQFz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cbQEx_info;
           _sbQ9L::P64 = P64[R1 + 16];
           R2 = _sbQ9L::P64;
           P64[Sp - 40] = _sbQ9L::P64;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = R1;
           Sp = Sp - 48;
           call Control.Arrow.$p1ArrowPlus_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbQEx() //  [R1]
         { info_tbl: [(cbQEx,
                       label: block_cbQEx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQEx: // global
           I64[Sp] = block_cbQEB_info;
           R2 = R1;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbQEB() //  [R1]
         { info_tbl: [(cbQEB,
                       label: block_cbQEB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQEB: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbQFD; else goto cbQFC;
       cbQFD: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbQFC: // global
           I64[Hp - 64] = sat_sbQ9X_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbQ9R_info;
           P64[Hp] = R1;
           I64[Sp + 8] = block_cbQFx_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 24] = Hp - 64;
           Sp = Sp + 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbQFx() //  [R1]
         { info_tbl: [(cbQFx,
                       label: block_cbQFx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQFx: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad_$csome_entry() //  [R2, R3]
         { info_tbl: [(cbQFI,
                       label: Control.Arrow.$fAlternativeArrowMonad_$csome_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQFI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbQFM; else goto cbQFL;
       cbQFM: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_$csome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQFL: // global
           I64[Hp - 24] = some_v_sbQ9N_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.146583593 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_$cmany_closure" {
     Control.Arrow.$fAlternativeArrowMonad_$cmany_closure:
         const Control.Arrow.$fAlternativeArrowMonad_$cmany_info;
 },
 $dApplicative_sbQa1_entry() //  [R1]
         { info_tbl: [(cbQHk,
                       label: $dApplicative_sbQa1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQHk: // global
           R2 = P64[R1 + 16];
           call Control.Arrow.$p1ArrowPlus_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $dApplicative1_sbQa2_entry() //  [R1]
         { info_tbl: [(cbQHr,
                       label: $dApplicative1_sbQa2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQHr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbQHs; else goto cbQHt;
       cbQHs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQHt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbQa7_entry() //  [R1]
         { info_tbl: [(cbQHy,
                       label: sat_sbQa7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQHy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQHz; else goto cbQHA;
       cbQHz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQHA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Arrow.$fAlternativeArrowMonad1_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbQa4_entry() //  [R1]
         { info_tbl: [(cbQHN,
                       label: sat_sbQa4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQHN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQHO; else goto cbQHP;
       cbQHO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQHP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbQa5_entry() //  [R1]
         { info_tbl: [(cbQHS,
                       label: sat_sbQa5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQHS: // global
           _sbQa5::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbQHT; else goto cbQHU;
       cbQHU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQHW; else goto cbQHV;
       cbQHW: // global
           HpAlloc = 24;
           goto cbQHT;
       cbQHT: // global
           R1 = _sbQa5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQHV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQa5::P64;
           _sbQ9Z::P64 = P64[_sbQa5::P64 + 16];
           _sbQa2::P64 = P64[_sbQa5::P64 + 24];
           I64[Hp - 16] = sat_sbQa4_info;
           P64[Hp] = _sbQa2::P64;
           I64[Sp - 40] = block_cbQHQ_info;
           R2 = _sbQa2::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbQ9Z::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbQHQ() //  [R1]
         { info_tbl: [(cbQHQ,
                       label: block_cbQHQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQHQ: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbQa6_entry() //  [R1]
         { info_tbl: [(cbQI0,
                       label: sat_sbQa6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQI0: // global
           _sbQa6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbQI1; else goto cbQI2;
       cbQI2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbQI4; else goto cbQI3;
       cbQI4: // global
           HpAlloc = 32;
           goto cbQI1;
       cbQI1: // global
           R1 = _sbQa6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQI3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQa6::P64;
           _sbQ9Z::P64 = P64[_sbQa6::P64 + 16];
           _sbQa0::P64 = P64[_sbQa6::P64 + 24];
           _sbQa2::P64 = P64[_sbQa6::P64 + 32];
           I64[Hp - 24] = sat_sbQa5_info;
           P64[Hp - 8] = _sbQ9Z::P64;
           P64[Hp] = _sbQa2::P64;
           R4 = _sbQa0::P64;
           R3 = Hp - 24;
           R2 = _sbQa2::P64;
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad2_entry(R4,
                                                             R3,
                                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 many_v_sbQa0_entry() //  [R1]
         { info_tbl: [(cbQI5,
                       label: many_v_sbQa0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQI5: // global
           _sbQa0::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbQI6; else goto cbQI7;
       cbQI7: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cbQI9; else goto cbQI8;
       cbQI9: // global
           HpAlloc = 112;
           goto cbQI6;
       cbQI6: // global
           R1 = _sbQa0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQI8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQa0::P64;
           _sbQ9Y::P64 = P64[_sbQa0::P64 + 16];
           _sbQ9Z::P64 = P64[_sbQa0::P64 + 24];
           I64[Hp - 104] = $dApplicative_sbQa1_info;
           P64[Hp - 88] = _sbQ9Y::P64;
           I64[Hp - 80] = $dApplicative1_sbQa2_info;
           P64[Hp - 64] = Hp - 104;
           I64[Hp - 56] = sat_sbQa7_info;
           _cbQHn::P64 = Hp - 80;
           P64[Hp - 40] = _cbQHn::P64;
           I64[Hp - 32] = sat_sbQa6_info;
           P64[Hp - 16] = _sbQ9Z::P64;
           P64[Hp - 8] = _sbQa0::P64;
           P64[Hp] = _cbQHn::P64;
           R2 = _sbQ9Y::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call Control.Arrow.<+>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad_$cmany_entry() //  [R2, R3]
         { info_tbl: [(cbQIa,
                       label: Control.Arrow.$fAlternativeArrowMonad_$cmany_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQIa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbQIe; else goto cbQId;
       cbQIe: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_$cmany_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQId: // global
           I64[Hp - 24] = many_v_sbQa0_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.166682526 UTC

[section ""data" . Control.Arrow.$fAlternativeArrowMonad_closure" {
     Control.Arrow.$fAlternativeArrowMonad_closure:
         const Control.Arrow.$fAlternativeArrowMonad_info;
 },
 sat_sbQaf_entry() //  [R1, R2]
         { info_tbl: [(cbQJl,
                       label: sat_sbQaf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQJl: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fAlternativeArrowMonad_$cmany_entry(R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQae_entry() //  [R1, R2]
         { info_tbl: [(cbQJt,
                       label: sat_sbQae_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQJt: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Arrow.$fAlternativeArrowMonad_$csome_entry(R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQad_entry() //  [R1, R2, R3]
         { info_tbl: [(cbQJB,
                       label: sat_sbQad_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQJB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbQJC; else goto cbQJD;
       cbQJC: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQJD: // global
           _sbQab::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbQab::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Control.Arrow.<+>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbQaa_entry() //  [R1]
         { info_tbl: [(cbQJI,
                       label: sat_sbQaa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQJI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbQJJ; else goto cbQJK;
       cbQJJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQJK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad3_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbQa9_entry() //  [R1]
         { info_tbl: [(cbQJP,
                       label: sat_sbQa9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQJP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbQJQ; else goto cbQJR;
       cbQJQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQJR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fAlternativeArrowMonad_entry() //  [R2]
         { info_tbl: [(cbQJT,
                       label: Control.Arrow.$fAlternativeArrowMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQJT: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cbQJX; else goto cbQJW;
       cbQJX: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = Control.Arrow.$fAlternativeArrowMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQJW: // global
           I64[Hp - 136] = sat_sbQaf_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbQae_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbQad_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbQaa_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbQa9_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 102;
           P64[Hp - 8] = Hp - 119;
           P64[Hp] = Hp - 135;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.180451511 UTC

[section ""data" . Control.Arrow.$fMonadPlusArrowMonad_closure" {
     Control.Arrow.$fMonadPlusArrowMonad_closure:
         const Control.Arrow.$fMonadPlusArrowMonad_info;
         const 0;
 },
 sat_sbQan_entry() //  [R1, R2, R3]
         { info_tbl: [(cbQKI,
                       label: sat_sbQan_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQKI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbQKJ; else goto cbQKK;
       cbQKJ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQKK: // global
           _sbQal::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbQal::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Control.Arrow.<+>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbQak_entry() //  [R1]
         { info_tbl: [(cbQKP,
                       label: sat_sbQak_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQKP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbQKQ; else goto cbQKR;
       cbQKQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQKR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad3_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbQaj_entry() //  [R1]
         { info_tbl: [(cbQKW,
                       label: sat_sbQaj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQKW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbQKX; else goto cbQKY;
       cbQKX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQKY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fMonadArrowMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbQai_entry() //  [R1]
         { info_tbl: [(cbQL3,
                       label: sat_sbQai_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQL3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbQL4; else goto cbQL5;
       cbQL4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQL5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fAlternativeArrowMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fMonadPlusArrowMonad_entry() //  [R2, R3]
         { info_tbl: [(cbQL7,
                       label: Control.Arrow.$fMonadPlusArrowMonad_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQL7: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cbQLb; else goto cbQLa;
       cbQLb: // global
           HpAlloc = 128;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fMonadPlusArrowMonad_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQLa: // global
           I64[Hp - 120] = sat_sbQan_info;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = sat_sbQak_info;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sbQaj_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbQai_info;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = GHC.Base.C:MonadPlus_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 118;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.193464057 UTC

[section ""data" . Control.Arrow.$fArrowLoop(->)_$cloop_closure" {
     Control.Arrow.$fArrowLoop(->)_$cloop_closure:
         const Control.Arrow.$fArrowLoop(->)_$cloop_info;
 },
 ds_sbQaq_entry() //  [R1]
         { info_tbl: [(cbQLU,
                       label: ds_sbQaq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQLU: // global
           _sbQaq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbQLV; else goto cbQLW;
       cbQLW: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbQLY; else goto cbQLX;
       cbQLY: // global
           HpAlloc = 48;
           goto cbQLV;
       cbQLV: // global
           R1 = _sbQaq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQLX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQaq::P64;
           _sbQao::P64 = P64[_sbQaq::P64 + 16];
           _sbQap::P64 = P64[_sbQaq::P64 + 24];
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sbQaq::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbQap::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 15;
           R1 = _sbQao::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowLoop(->)_$cloop_entry() //  [R2, R3]
         { info_tbl: [(cbQM2,
                       label: Control.Arrow.$fArrowLoop(->)_$cloop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQM2: // global
           _sbQap::P64 = R3;
           _sbQao::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cbQM3; else goto cbQM4;
       cbQM4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbQM6; else goto cbQM5;
       cbQM6: // global
           HpAlloc = 32;
           goto cbQM3;
       cbQM3: // global
           R3 = _sbQap::P64;
           R2 = _sbQao::P64;
           R1 = Control.Arrow.$fArrowLoop(->)_$cloop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQM5: // global
           I64[Hp - 24] = ds_sbQaq_info;
           P64[Hp - 8] = _sbQao::P64;
           P64[Hp] = _sbQap::P64;
           I64[Sp - 8] = block_cbQLZ_info;
           R1 = Hp - 24;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQMa; else goto cbQM0;
       ubQMa: // global
           call _cbQLZ(R1) args: 0, res: 0, upd: 0;
       cbQM0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQLZ() //  [R1]
         { info_tbl: [(cbQLZ,
                       label: block_cbQLZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQLZ: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.202388184 UTC

[section ""data" . Control.Arrow.$fArrowLoopKleisli1_closure" {
     Control.Arrow.$fArrowLoopKleisli1_closure:
         const Control.Arrow.$fArrowLoopKleisli1_info;
 },
 sat_sbQaN_entry() //  [R1, R2]
         { info_tbl: [(cbQMI,
                       label: sat_sbQaN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQMI: // global
           _sbQaI::P64 = R2;
           _sbQaN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbQMJ; else goto cbQMK;
       cbQMK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQMM; else goto cbQML;
       cbQMM: // global
           HpAlloc = 24;
           goto cbQMJ;
       cbQMJ: // global
           R2 = _sbQaI::P64;
           R1 = _sbQaN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQML: // global
           _sbQaC::P64 = P64[_sbQaN::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbQaI::P64;
           R2 = _sbQaC::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbQaE_entry() //  [R1]
         { info_tbl: [(cbQN0,
                       label: sat_sbQaE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQN0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbQN1; else goto cbQN2;
       cbQN1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQN2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Tuple.snd_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbQaG_entry() //  [R1, R2]
         { info_tbl: [(cbQN4,
                       label: sat_sbQaG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQN4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbQN8; else goto cbQN7;
       cbQN8: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQN7: // global
           _sbQaA::P64 = P64[R1 + 7];
           _sbQaB::P64 = P64[R1 + 15];
           I64[Hp - 40] = sat_sbQaE_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbQaB::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 15;
           R1 = _sbQaA::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQaH_entry() //  [R1]
         { info_tbl: [(cbQN9,
                       label: sat_sbQaH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQN9: // global
           _sbQaH::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbQNa; else goto cbQNb;
       cbQNb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQNd; else goto cbQNc;
       cbQNd: // global
           HpAlloc = 24;
           goto cbQNa;
       cbQNa: // global
           R1 = _sbQaH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQNc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQaH::P64;
           _sbQaz::P64 = P64[_sbQaH::P64 + 16];
           _sbQaA::P64 = P64[_sbQaH::P64 + 24];
           _sbQaB::P64 = P64[_sbQaH::P64 + 32];
           I64[Hp - 16] = sat_sbQaG_info;
           P64[Hp - 8] = _sbQaA::P64;
           P64[Hp] = _sbQaB::P64;
           R2 = _sbQaz::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowLoopKleisli1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbQNe,
                       label: Control.Arrow.$fArrowLoopKleisli1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQNe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQNf; else goto cbQNg;
       cbQNf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fArrowLoopKleisli1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQNg: // global
           I64[Sp - 32] = block_cbQMy_info;
           _sbQaz::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbQaz::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbQMy() //  [R1]
         { info_tbl: [(cbQMy,
                       label: block_cbQMy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQMy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbQNj; else goto cbQNi;
       cbQNj: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbQNi: // global
           I64[Hp - 48] = sat_sbQaN_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sbQaH_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 32;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp + 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.216739483 UTC

[section ""data" . lvl1_rbNC7_closure" {
     lvl1_rbNC7_closure:
         const lvl1_rbNC7_info;
 },
 lvl1_rbNC7_entry() //  [R2]
         { info_tbl: [(cbQOc,
                       label: lvl1_rbNC7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQOc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQOd; else goto cbQOe;
       cbQOd: // global
           R2 = R2;
           R1 = lvl1_rbNC7_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQOe: // global
           I64[Sp - 8] = block_cbQO5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQOl; else goto cbQO6;
       ubQOl: // global
           call _cbQO5(R1) args: 0, res: 0, upd: 0;
       cbQO6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQO5() //  [R1]
         { info_tbl: [(cbQO5,
                       label: block_cbQO5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQO5: // global
           if (R1 & 7 == 1) goto cbQO9; else goto cbQOa;
       cbQO9: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbQOa: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.223175965 UTC

[section ""data" . Control.Arrow.$dm|||_closure" {
     Control.Arrow.$dm|||_closure:
         const Control.Arrow.$dm|||_info;
 },
 sat_sbQaY_entry() //  [R1]
         { info_tbl: [(cbQOK,
                       label: sat_sbQaY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQOK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbQOL; else goto cbQOM;
       cbQOL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQOM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Arrow.+++_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbQaX_entry() //  [R1]
         { info_tbl: [(cbQOR,
                       label: sat_sbQaX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQOR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQOS; else goto cbQOT;
       cbQOS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQOT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl1_rbNC7_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dm|||_entry() //  [R2, R3, R4]
         { info_tbl: [(cbQOU,
                       label: Control.Arrow.$dm|||_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQOU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQOW; else goto cbQOX;
       cbQOW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$dm|||_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQOX: // global
           I64[Sp - 32] = block_cbQOC_info;
           _sbQaS::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbQaS::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Arrow.$p1ArrowChoice_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbQOC() //  [R1]
         { info_tbl: [(cbQOC,
                       label: block_cbQOC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQOC: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbQP0; else goto cbQOZ;
       cbQP0: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbQOZ: // global
           I64[Hp - 56] = sat_sbQaY_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           I64[Hp - 16] = sat_sbQaX_info;
           P64[Hp] = R1;
           I64[Sp + 8] = block_cbQOV_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 24] = Hp - 56;
           Sp = Sp + 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbQOV() //  [R1]
         { info_tbl: [(cbQOV,
                       label: block_cbQOV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQOV: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.235700984 UTC

[section ""data" . mirror_rbNC8_closure" {
     mirror_rbNC8_closure:
         const mirror_rbNC8_info;
 },
 mirror_rbNC8_entry() //  [R2]
         { info_tbl: [(cbQPQ,
                       label: mirror_rbNC8_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQPQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbQPR; else goto cbQPS;
       cbQPR: // global
           R2 = R2;
           R1 = mirror_rbNC8_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQPS: // global
           I64[Sp - 8] = block_cbQPJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubQQ5; else goto cbQPK;
       ubQQ5: // global
           call _cbQPJ(R1) args: 0, res: 0, upd: 0;
       cbQPK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQPJ() //  [R1]
         { info_tbl: [(cbQPJ,
                       label: block_cbQPJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQPJ: // global
           if (R1 & 7 == 1) goto cbQPN; else goto cbQPO;
       cbQPN: // global
           Hp = Hp + 16;
           _sbQb0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbQQ4; else goto cbQPX;
       cbQPX: // global
           _sbQb1::P64 = P64[_sbQb0::P64 + 7];
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = _sbQb1::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbQPO: // global
           Hp = Hp + 16;
           _sbQb0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbQQ4; else goto cbQQ3;
       cbQQ4: // global
           HpAlloc = 16;
           R1 = _sbQb0::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbQQ3: // global
           _sbQb2::P64 = P64[_sbQb0::P64 + 6];
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = _sbQb2::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.242714147 UTC

[section ""data" . Control.Arrow.$dm+++_closure" {
     Control.Arrow.$dm+++_closure:
         const Control.Arrow.$dm+++_info;
 },
 sat_sbQbb_entry() //  [R1]
         { info_tbl: [(cbQQK,
                       label: sat_sbQbb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQQK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQQL; else goto cbQQM;
       cbQQL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQQM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.left_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbQba_entry() //  [R1]
         { info_tbl: [(cbQQR,
                       label: sat_sbQba_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQQR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQQS; else goto cbQQT;
       cbQQS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQQT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = mirror_rbNC8_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbQbc_entry() //  [R1]
         { info_tbl: [(cbQQU,
                       label: sat_sbQbc_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQQU: // global
           _sbQbc::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbQQV; else goto cbQQW;
       cbQQW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbQQY; else goto cbQQX;
       cbQQY: // global
           HpAlloc = 56;
           goto cbQQV;
       cbQQV: // global
           R1 = _sbQbc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQQX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQbc::P64;
           _sbQb3::P64 = P64[_sbQbc::P64 + 16];
           _sbQb4::P64 = P64[_sbQbc::P64 + 24];
           _sbQb6::P64 = P64[_sbQbc::P64 + 32];
           _sbQb7::P64 = P64[_sbQbc::P64 + 40];
           I64[Hp - 48] = sat_sbQbb_info;
           P64[Hp - 32] = _sbQb3::P64;
           P64[Hp - 24] = _sbQb4::P64;
           I64[Hp - 16] = sat_sbQba_info;
           P64[Hp] = _sbQb6::P64;
           R2 = _sbQb7::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbQb9_entry() //  [R1]
         { info_tbl: [(cbQR3,
                       label: sat_sbQb9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQR3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQR4; else goto cbQR5;
       cbQR4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQR5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.left_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbQbd_entry() //  [R1]
         { info_tbl: [(cbQR6,
                       label: sat_sbQbd_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQR6: // global
           _sbQbd::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbQR7; else goto cbQR8;
       cbQR8: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbQRa; else goto cbQR9;
       cbQRa: // global
           HpAlloc = 80;
           goto cbQR7;
       cbQR7: // global
           R1 = _sbQbd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQR9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQbd::P64;
           _sbQb3::P64 = P64[_sbQbd::P64 + 16];
           _sbQb4::P64 = P64[_sbQbd::P64 + 24];
           _sbQb5::P64 = P64[_sbQbd::P64 + 32];
           _sbQb6::P64 = P64[_sbQbd::P64 + 40];
           _sbQb7::P64 = P64[_sbQbd::P64 + 48];
           I64[Hp - 72] = sat_sbQbc_info;
           P64[Hp - 56] = _sbQb3::P64;
           P64[Hp - 48] = _sbQb4::P64;
           P64[Hp - 40] = _sbQb6::P64;
           P64[Hp - 32] = _sbQb7::P64;
           I64[Hp - 24] = sat_sbQb9_info;
           P64[Hp - 8] = _sbQb3::P64;
           P64[Hp] = _sbQb5::P64;
           R2 = _sbQb7::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 72;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbQb8_entry() //  [R1]
         { info_tbl: [(cbQRf,
                       label: sat_sbQb8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQRf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQRg; else goto cbQRh;
       cbQRg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQRh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = mirror_rbNC8_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dm+++_entry() //  [R2, R3, R4]
         { info_tbl: [(cbQRi,
                       label: Control.Arrow.$dm+++_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQRi: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbQRj; else goto cbQRk;
       cbQRj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$dm+++_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQRk: // global
           I64[Sp - 32] = block_cbQQq_info;
           _sbQb3::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbQb3::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Arrow.$p1ArrowChoice_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbQQq() //  [R1]
         { info_tbl: [(cbQQq,
                       label: block_cbQQq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQQq: // global
           I64[Sp - 8] = block_cbQQu_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbQQu() //  [R1]
         { info_tbl: [(cbQQu,
                       label: block_cbQQu_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQQu: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbQRo; else goto cbQRn;
       cbQRo: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbQRn: // global
           I64[Hp - 72] = sat_sbQbd_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 32];
           _sbQb6::P64 = P64[Sp + 8];
           P64[Hp - 32] = _sbQb6::P64;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbQb8_info;
           P64[Hp] = _sbQb6::P64;
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 16;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 16;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.26320095 UTC

[section ""data" . Control.Arrow.$dmright_closure" {
     Control.Arrow.$dmright_closure:
         const Control.Arrow.$dmright_info;
 },
 sat_sbQbh_entry() //  [R1]
         { info_tbl: [(cbQSG,
                       label: sat_sbQbh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQSG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbQSK; else goto cbQSL;
       cbQSK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQSL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbQSE_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1ArrowChoice_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbQSE() //  [R1]
         { info_tbl: [(cbQSE,
                       label: block_cbQSE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQSE: // global
           I64[Sp] = block_cbQSJ_info;
           R2 = R1;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbQSJ() //  [R1]
         { info_tbl: [(cbQSJ,
                       label: block_cbQSJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQSJ: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Category.id_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dmright_entry() //  [R2]
         { info_tbl: [(cbQSR,
                       label: Control.Arrow.$dmright_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQSR: // global
           _sbQbe::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbQSS; else goto cbQST;
       cbQST: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQSV; else goto cbQSU;
       cbQSV: // global
           HpAlloc = 24;
           goto cbQSS;
       cbQSS: // global
           R2 = _sbQbe::P64;
           R1 = Control.Arrow.$dmright_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQSU: // global
           I64[Hp - 16] = sat_sbQbh_info;
           P64[Hp] = _sbQbe::P64;
           R2 = _sbQbe::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Control.Arrow.+++_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.272809714 UTC

[section ""data" . Control.Arrow.$dmleft_closure" {
     Control.Arrow.$dmleft_closure:
         const Control.Arrow.$dmleft_info;
 },
 sat_sbQbm_entry() //  [R1]
         { info_tbl: [(cbQTr,
                       label: sat_sbQbm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQTr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbQTv; else goto cbQTw;
       cbQTv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQTw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbQTp_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1ArrowChoice_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbQTp() //  [R1]
         { info_tbl: [(cbQTp,
                       label: block_cbQTp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQTp: // global
           I64[Sp] = block_cbQTu_info;
           R2 = R1;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbQTu() //  [R1]
         { info_tbl: [(cbQTu,
                       label: block_cbQTu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQTu: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Category.id_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dmleft_entry() //  [R2, R3]
         { info_tbl: [(cbQTC,
                       label: Control.Arrow.$dmleft_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQTC: // global
           _sbQbj::P64 = R3;
           _sbQbi::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbQTD; else goto cbQTE;
       cbQTE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQTG; else goto cbQTF;
       cbQTG: // global
           HpAlloc = 24;
           goto cbQTD;
       cbQTD: // global
           R3 = _sbQbj::P64;
           R2 = _sbQbi::P64;
           R1 = Control.Arrow.$dmleft_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQTF: // global
           I64[Hp - 16] = sat_sbQbm_info;
           P64[Hp] = _sbQbi::P64;
           R2 = _sbQbi::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbQbj::P64;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Control.Arrow.+++_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.281446394 UTC

[section ""data" . lvl2_rbNC9_closure" {
     lvl2_rbNC9_closure:
         const lvl2_rbNC9_info;
 },
 lvl2_rbNC9_entry() //  [R2]
         { info_tbl: [(cbQU7,
                       label: lvl2_rbNC9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQU7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQUb; else goto cbQUa;
       cbQUb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = lvl2_rbNC9_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQUa: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.285434964 UTC

[section ""data" . Control.Arrow.$dm&&&_closure" {
     Control.Arrow.$dm&&&_closure:
         const Control.Arrow.$dm&&&_info;
 },
 sat_sbQbt_entry() //  [R1]
         { info_tbl: [(cbQUq,
                       label: sat_sbQbt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQUq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQUr; else goto cbQUs;
       cbQUr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQUs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl2_rbNC9_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbQbs_entry() //  [R1]
         { info_tbl: [(cbQUx,
                       label: sat_sbQbs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQUx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbQUy; else goto cbQUz;
       cbQUy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQUz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Arrow.***_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dm&&&_entry() //  [R2, R3, R4]
         { info_tbl: [(cbQUC,
                       label: Control.Arrow.$dm&&&_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQUC: // global
           _sbQbq::P64 = R4;
           _sbQbp::P64 = R3;
           _sbQbo::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbQUD; else goto cbQUE;
       cbQUE: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbQUG; else goto cbQUF;
       cbQUG: // global
           HpAlloc = 64;
           goto cbQUD;
       cbQUD: // global
           R4 = _sbQbq::P64;
           R3 = _sbQbp::P64;
           R2 = _sbQbo::P64;
           R1 = Control.Arrow.$dm&&&_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQUF: // global
           I64[Hp - 56] = sat_sbQbt_info;
           P64[Hp - 40] = _sbQbo::P64;
           I64[Hp - 32] = sat_sbQbs_info;
           P64[Hp - 16] = _sbQbo::P64;
           P64[Hp - 8] = _sbQbp::P64;
           P64[Hp] = _sbQbq::P64;
           I64[Sp - 24] = block_cbQUA_info;
           R2 = _sbQbo::P64;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbQUA() //  [R1]
         { info_tbl: [(cbQUA,
                       label: block_cbQUA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQUA: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbQUm::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbQUm::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.295453843 UTC

[section ""data" . swap_rbNCa_closure" {
     swap_rbNCa_closure:
         const swap_rbNCa_info;
 },
 swap_rbNCa_entry() //  [R2]
         { info_tbl: [(cbQVl,
                       label: swap_rbNCa_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQVl: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbQVp; else goto cbQVo;
       cbQVp: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = swap_rbNCa_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQVo: // global
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.300222043 UTC

[section ""data" . Control.Arrow.$dm***_closure" {
     Control.Arrow.$dm***_closure:
         const Control.Arrow.$dm***_info;
 },
 sat_sbQbK_entry() //  [R1]
         { info_tbl: [(cbQVU,
                       label: sat_sbQbK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQVU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQVV; else goto cbQVW;
       cbQVV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQVW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.first_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbQbJ_entry() //  [R1]
         { info_tbl: [(cbQW1,
                       label: sat_sbQbJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQW1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQW2; else goto cbQW3;
       cbQW2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQW3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = swap_rbNCa_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbQbL_entry() //  [R1]
         { info_tbl: [(cbQW4,
                       label: sat_sbQbL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQW4: // global
           _sbQbL::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbQW5; else goto cbQW6;
       cbQW6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbQW8; else goto cbQW7;
       cbQW8: // global
           HpAlloc = 56;
           goto cbQW5;
       cbQW5: // global
           R1 = _sbQbL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQW7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQbL::P64;
           _sbQbD::P64 = P64[_sbQbL::P64 + 16];
           _sbQbE::P64 = P64[_sbQbL::P64 + 24];
           _sbQbG::P64 = P64[_sbQbL::P64 + 32];
           I64[Hp - 48] = sat_sbQbK_info;
           P64[Hp - 32] = _sbQbD::P64;
           P64[Hp - 24] = _sbQbE::P64;
           I64[Hp - 16] = sat_sbQbJ_info;
           P64[Hp] = _sbQbD::P64;
           R2 = _sbQbG::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbQbI_entry() //  [R1]
         { info_tbl: [(cbQWd,
                       label: sat_sbQbI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQWd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQWe; else goto cbQWf;
       cbQWe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQWf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.first_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbQbM_entry() //  [R1]
         { info_tbl: [(cbQWg,
                       label: sat_sbQbM_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQWg: // global
           _sbQbM::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbQWh; else goto cbQWi;
       cbQWi: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbQWk; else goto cbQWj;
       cbQWk: // global
           HpAlloc = 72;
           goto cbQWh;
       cbQWh: // global
           R1 = _sbQbM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQWj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQbM::P64;
           _sbQbD::P64 = P64[_sbQbM::P64 + 16];
           _sbQbE::P64 = P64[_sbQbM::P64 + 24];
           _sbQbF::P64 = P64[_sbQbM::P64 + 32];
           _sbQbG::P64 = P64[_sbQbM::P64 + 40];
           I64[Hp - 64] = sat_sbQbL_info;
           P64[Hp - 48] = _sbQbD::P64;
           P64[Hp - 40] = _sbQbE::P64;
           P64[Hp - 32] = _sbQbG::P64;
           I64[Hp - 24] = sat_sbQbI_info;
           P64[Hp - 8] = _sbQbD::P64;
           P64[Hp] = _sbQbF::P64;
           R2 = _sbQbG::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 64;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbQbH_entry() //  [R1]
         { info_tbl: [(cbQWp,
                       label: sat_sbQbH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQWp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQWq; else goto cbQWr;
       cbQWq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQWr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = swap_rbNCa_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dm***_entry() //  [R2, R3, R4]
         { info_tbl: [(cbQWs,
                       label: Control.Arrow.$dm***_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQWs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQWt; else goto cbQWu;
       cbQWt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$dm***_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQWu: // global
           I64[Sp - 32] = block_cbQVE_info;
           _sbQbD::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbQbD::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbQVE() //  [R1]
         { info_tbl: [(cbQVE,
                       label: block_cbQVE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQVE: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbQWx; else goto cbQWw;
       cbQWx: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbQWw: // global
           I64[Hp - 64] = sat_sbQbM_info;
           _sbQbD::P64 = P64[Sp + 8];
           P64[Hp - 48] = _sbQbD::P64;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbQbH_info;
           P64[Hp] = _sbQbD::P64;
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 24] = Hp - 64;
           Sp = Sp + 8;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.320638074 UTC

[section ""data" . Control.Arrow.$fArrowKleisli2_closure" {
     Control.Arrow.$fArrowKleisli2_closure:
         const Control.Arrow.$fArrowKleisli2_info;
 },
 sat_sbQcg_entry() //  [R1, R2]
         { info_tbl: [(cbQXM,
                       label: sat_sbQcg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQXM: // global
           _sbQc6::P64 = R2;
           _sbQcg::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbQXN; else goto cbQXO;
       cbQXO: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbQXQ; else goto cbQXP;
       cbQXQ: // global
           HpAlloc = 72;
           goto cbQXN;
       cbQXN: // global
           R2 = _sbQc6::P64;
           R1 = _sbQcg::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQXP: // global
           _sbQbN::P64 = P64[_sbQcg::P64 + 7];
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sbQc6::P64;
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sbQc6::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = _sbQbN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbQc4_entry() //  [R1, R2]
         { info_tbl: [(cbQY0,
                       label: sat_sbQc4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQY0: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Arrow.$fArrowKleisli3_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQc2_entry() //  [R1, R2]
         { info_tbl: [(cbQYf,
                       label: sat_sbQc2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQYf: // global
           _sbQbS::P64 = R2;
           _sbQc2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbQYg; else goto cbQYh;
       cbQYh: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbQYj; else goto cbQYi;
       cbQYj: // global
           HpAlloc = 72;
           goto cbQYg;
       cbQYg: // global
           R2 = _sbQbS::P64;
           R1 = _sbQc2::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbQYi: // global
           _sbQbN::P64 = P64[_sbQc2::P64 + 7];
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sbQbS::P64;
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sbQbS::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = _sbQbN::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbQbR_entry() //  [R1]
         { info_tbl: [(cbQYo,
                       label: sat_sbQbR_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQYo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbQYp; else goto cbQYq;
       cbQYp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQYq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowKleisli3_entry(R4,
                                                    R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbQc3_entry() //  [R1]
         { info_tbl: [(cbQYr,
                       label: sat_sbQc3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQYr: // global
           _sbQc3::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbQYs; else goto cbQYt;
       cbQYt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbQYv; else goto cbQYu;
       cbQYv: // global
           HpAlloc = 56;
           goto cbQYs;
       cbQYs: // global
           R1 = _sbQc3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQYu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQc3::P64;
           _sbQbN::P64 = P64[_sbQc3::P64 + 16];
           _sbQbO::P64 = P64[_sbQc3::P64 + 24];
           _sbQbQ::P64 = P64[_sbQc3::P64 + 32];
           I64[Hp - 48] = sat_sbQc2_info;
           P64[Hp - 40] = _sbQbN::P64;
           I64[Hp - 32] = sat_sbQbR_info;
           P64[Hp - 16] = _sbQbN::P64;
           P64[Hp - 8] = _sbQbO::P64;
           P64[Hp] = _sbQbQ::P64;
           R2 = _sbQbN::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 47;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbQc5_entry() //  [R1]
         { info_tbl: [(cbQYw,
                       label: sat_sbQc5_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQYw: // global
           _sbQc5::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbQYx; else goto cbQYy;
       cbQYy: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbQYA; else goto cbQYz;
       cbQYA: // global
           HpAlloc = 64;
           goto cbQYx;
       cbQYx: // global
           R1 = _sbQc5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQYz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQc5::P64;
           _sbQbN::P64 = P64[_sbQc5::P64 + 16];
           _sbQbO::P64 = P64[_sbQc5::P64 + 24];
           _sbQbP::P64 = P64[_sbQc5::P64 + 32];
           _sbQbQ::P64 = P64[_sbQc5::P64 + 40];
           I64[Hp - 56] = sat_sbQc4_info;
           P64[Hp - 48] = _sbQbN::P64;
           P64[Hp - 40] = _sbQbP::P64;
           I64[Hp - 32] = sat_sbQc3_info;
           P64[Hp - 16] = _sbQbN::P64;
           P64[Hp - 8] = _sbQbO::P64;
           P64[Hp] = _sbQbQ::P64;
           R2 = _sbQbN::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 55;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbQYB,
                       label: Control.Arrow.$fArrowKleisli2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQYB: // global
           _sbQbQ::P64 = R5;
           _sbQbP::P64 = R4;
           _sbQbO::P64 = R3;
           _sbQbN::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbQYC; else goto cbQYD;
       cbQYD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbQYF; else goto cbQYE;
       cbQYF: // global
           HpAlloc = 64;
           goto cbQYC;
       cbQYC: // global
           R5 = _sbQbQ::P64;
           R4 = _sbQbP::P64;
           R3 = _sbQbO::P64;
           R2 = _sbQbN::P64;
           R1 = Control.Arrow.$fArrowKleisli2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQYE: // global
           I64[Hp - 56] = sat_sbQcg_info;
           P64[Hp - 48] = _sbQbN::P64;
           I64[Hp - 40] = sat_sbQc5_info;
           P64[Hp - 24] = _sbQbN::P64;
           P64[Hp - 16] = _sbQbO::P64;
           P64[Hp - 8] = _sbQbP::P64;
           P64[Hp] = _sbQbQ::P64;
           R2 = _sbQbN::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 40;
           P64[Sp - 8] = Hp - 55;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.340876614 UTC

[section ""data" . Control.Arrow.$fArrowKleisli1_closure" {
     Control.Arrow.$fArrowKleisli1_closure:
         const Control.Arrow.$fArrowKleisli1_info;
 },
 sat_sbQcn_entry() //  [R1, R2]
         { info_tbl: [(cbQZN,
                       label: sat_sbQcn_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQZN: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Arrow.$fArrowKleisli2_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQcm_entry() //  [R1]
         { info_tbl: [(cbQZV,
                       label: sat_sbQcm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQZV: // global
           _sbQcm::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbQZW; else goto cbQZX;
       cbQZX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbQZZ; else goto cbQZY;
       cbQZZ: // global
           HpAlloc = 24;
           goto cbQZW;
       cbQZW: // global
           R1 = _sbQcm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbQZY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQcm::P64;
           _sbQch::P64 = P64[_sbQcm::P64 + 16];
           _sbQck::P64 = P64[_sbQcm::P64 + 24];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbQck::P64;
           P64[Hp] = _sbQck::P64;
           R2 = _sbQch::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbR00,
                       label: Control.Arrow.$fArrowKleisli1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR00: // global
           _sbQck::P64 = R5;
           _sbQcj::P64 = R4;
           _sbQci::P64 = R3;
           _sbQch::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbR01; else goto cbR02;
       cbR02: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbR04; else goto cbR03;
       cbR04: // global
           HpAlloc = 64;
           goto cbR01;
       cbR01: // global
           R5 = _sbQck::P64;
           R4 = _sbQcj::P64;
           R3 = _sbQci::P64;
           R2 = _sbQch::P64;
           R1 = Control.Arrow.$fArrowKleisli1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbR03: // global
           I64[Hp - 56] = sat_sbQcn_info;
           P64[Hp - 48] = _sbQch::P64;
           P64[Hp - 40] = _sbQci::P64;
           P64[Hp - 32] = _sbQcj::P64;
           I64[Hp - 24] = sat_sbQcm_info;
           P64[Hp - 8] = _sbQch::P64;
           P64[Hp] = _sbQck::P64;
           R2 = _sbQch::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 55;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.349882641 UTC

[section ""data" . Control.Arrow.$fArrowKleisli_closure" {
     Control.Arrow.$fArrowKleisli_closure:
         const Control.Arrow.$fArrowKleisli_info;
 },
 sat_sbQcu_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbR0z,
                       label: sat_sbQcu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR0z: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fArrowKleisli1_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQct_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbR0H,
                       label: sat_sbQct_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR0H: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fArrowKleisli2_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQcs_entry() //  [R1, R2, R3]
         { info_tbl: [(cbR0P,
                       label: sat_sbQcs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR0P: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowKleisli4_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQcr_entry() //  [R1, R2, R3]
         { info_tbl: [(cbR0X,
                       label: sat_sbQcr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR0X: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowKleisli3_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQcq_entry() //  [R1, R2, R3]
         { info_tbl: [(cbR15,
                       label: sat_sbQcq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR15: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowKleisli5_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQcp_entry() //  [R1]
         { info_tbl: [(cbR1c,
                       label: sat_sbQcp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR1c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbR1d; else goto cbR1e;
       cbR1d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbR1e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fCategoryTYPEKleisli_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowKleisli_entry() //  [R2]
         { info_tbl: [(cbR1g,
                       label: Control.Arrow.$fArrowKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR1g: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cbR1k; else goto cbR1j;
       cbR1k: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = Control.Arrow.$fArrowKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbR1j: // global
           I64[Hp - 152] = sat_sbQcu_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbQct_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbQcs_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbQcr_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbQcq_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbQcp_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = Control.Arrow.C:Arrow_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 86;
           P64[Hp - 24] = Hp - 102;
           P64[Hp - 16] = Hp - 118;
           P64[Hp - 8] = Hp - 133;
           P64[Hp] = Hp - 149;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.36453496 UTC

[section ""data" . Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_closure" {
     Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_closure:
         const Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_info;
 },
 sat_sbQcw_entry() //  [R1]
         { info_tbl: [(cbR25,
                       label: sat_sbQcw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR25: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbR26; else goto cbR27;
       cbR26: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbR27: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_entry() //  [R2]
         { info_tbl: [(cbR28,
                       label: Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR28: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbR2c; else goto cbR2b;
       cbR2c: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbR2b: // global
           I64[Hp - 16] = sat_sbQcw_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Arrow.$fArrowKleisli_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.370475109 UTC

[section ""data" . Control.Arrow.$fArrowLoopKleisli_closure" {
     Control.Arrow.$fArrowLoopKleisli_closure:
         const Control.Arrow.$fArrowLoopKleisli_info;
 },
 sat_sbQcz_entry() //  [R1, R2, R3]
         { info_tbl: [(cbR2w,
                       label: sat_sbQcz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR2w: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowLoopKleisli1_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQcy_entry() //  [R1]
         { info_tbl: [(cbR2D,
                       label: sat_sbQcy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR2D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbR2E; else goto cbR2F;
       cbR2E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbR2F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowLoopKleisli_entry() //  [R2]
         { info_tbl: [(cbR2H,
                       label: Control.Arrow.$fArrowLoopKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR2H: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbR2L; else goto cbR2K;
       cbR2L: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Arrow.$fArrowLoopKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbR2K: // global
           I64[Hp - 56] = sat_sbQcz_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbQcy_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Arrow.C:ArrowLoop_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 54;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.378086609 UTC

[section ""data" . lvl3_rbNCb_closure" {
     lvl3_rbNCb_closure:
         const lvl3_rbNCb_info;
 },
 lvl3_rbNCb_entry() //  [R2]
         { info_tbl: [(cbR3b,
                       label: lvl3_rbNCb_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR3b: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbR3c; else goto cbR3d;
       cbR3c: // global
           R2 = R2;
           R1 = lvl3_rbNCb_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbR3d: // global
           I64[Sp - 8] = block_cbR38_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubR3h; else goto cbR39;
       ubR3h: // global
           call _cbR38(R1) args: 0, res: 0, upd: 0;
       cbR39: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbR38() //  [R1]
         { info_tbl: [(cbR38,
                       label: block_cbR38_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR38: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.383559068 UTC

[section ""data" . Control.Arrow.$fArrowApplyKleisli_closure" {
     Control.Arrow.$fArrowApplyKleisli_closure:
         const Control.Arrow.$fArrowApplyKleisli_info;
 },
 sat_sbQcF_entry() //  [R1]
         { info_tbl: [(cbR3A,
                       label: sat_sbQcF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR3A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbR3B; else goto cbR3C;
       cbR3B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbR3C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowKleisli_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowApplyKleisli_entry() //  [R2]
         { info_tbl: [(cbR3E,
                       label: Control.Arrow.$fArrowApplyKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR3E: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbR3I; else goto cbR3H;
       cbR3I: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Control.Arrow.$fArrowApplyKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbR3H: // global
           I64[Hp - 40] = sat_sbQcF_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Arrow.C:ArrowApply_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = lvl3_rbNCb_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.390612512 UTC

[section ""data" . Control.Arrow.$fArrowChoiceKleisli1_closure" {
     Control.Arrow.$fArrowChoiceKleisli1_closure:
         const Control.Arrow.$fArrowChoiceKleisli1_info;
 },
 sat_sbQcP_entry() //  [R1, R2]
         { info_tbl: [(cbR4c,
                       label: sat_sbQcP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR4c: // global
           _sbQcN::P64 = R2;
           _sbQcP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbR4d; else goto cbR4e;
       cbR4e: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbR4g; else goto cbR4f;
       cbR4g: // global
           HpAlloc = 16;
           goto cbR4d;
       cbR4d: // global
           R2 = _sbQcN::P64;
           R1 = _sbQcP::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbR4f: // global
           _sbQcG::P64 = P64[_sbQcP::P64 + 7];
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = _sbQcN::P64;
           R2 = _sbQcG::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbQcU_entry() //  [R1, R2]
         { info_tbl: [(cbR4p,
                       label: sat_sbQcU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR4p: // global
           _sbQcS::P64 = R2;
           _sbQcU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbR4q; else goto cbR4r;
       cbR4r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbR4t; else goto cbR4s;
       cbR4t: // global
           HpAlloc = 16;
           goto cbR4q;
       cbR4q: // global
           R2 = _sbQcS::P64;
           R1 = _sbQcU::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbR4s: // global
           _sbQcG::P64 = P64[_sbQcU::P64 + 7];
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = _sbQcS::P64;
           R2 = _sbQcG::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 6;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fArrowChoiceKleisli1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbR4y,
                       label: Control.Arrow.$fArrowChoiceKleisli1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR4y: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbR4z; else goto cbR4A;
       cbR4z: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fArrowChoiceKleisli1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbR4A: // global
           I64[Sp - 32] = block_cbR41_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubR4J; else goto cbR42;
       ubR4J: // global
           call _cbR41(R1) args: 0, res: 0, upd: 0;
       cbR42: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbR41() //  [R1]
         { info_tbl: [(cbR41,
                       label: block_cbR41_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR41: // global
           _sbQcG::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbR4v; else goto cbR4w;
       cbR4v: // global
           Hp = Hp + 48;
           _sbQcK::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbR4G; else goto cbR4C;
       cbR4C: // global
           _sbQcL::P64 = P64[_sbQcK::P64 + 7];
           I64[Hp - 40] = sat_sbQcP_info;
           P64[Hp - 32] = _sbQcG::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbQcL::P64;
           R2 = _sbQcG::P64;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 24;
           P64[Sp + 24] = Hp - 39;
           Sp = Sp + 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
       cbR4w: // global
           Hp = Hp + 48;
           _sbQcK::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbR4G; else goto cbR4F;
       cbR4G: // global
           HpAlloc = 48;
           R1 = _sbQcK::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbR4F: // global
           _sbQcQ::P64 = P64[_sbQcK::P64 + 6];
           I64[Hp - 40] = sat_sbQcU_info;
           P64[Hp - 32] = _sbQcG::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sbQcQ::P64;
           R2 = _sbQcG::P64;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 24;
           P64[Sp + 24] = Hp - 39;
           Sp = Sp + 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.402607115 UTC

[section ""data" . Control.Arrow.$fArrowChoiceKleisli3_closure" {
     Control.Arrow.$fArrowChoiceKleisli3_closure:
         const Control.Arrow.$fArrowChoiceKleisli3_info;
 },
 sat_sbQcZ_entry() //  [R1, R2]
         { info_tbl: [(cbR5v,
                       label: sat_sbQcZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR5v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbR5w; else goto cbR5x;
       cbR5w: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbR5x: // global
           _sbQcY::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _sbQcY::P64;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fArrowChoiceKleisli3_entry() //  [R2, R3, R4]
         { info_tbl: [(cbR5y,
                       label: Control.Arrow.$fArrowChoiceKleisli3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR5y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbR5C; else goto cbR5B;
       cbR5C: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fArrowChoiceKleisli3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbR5B: // global
           I64[Hp - 8] = sat_sbQcZ_info;
           P64[Hp] = R2;
           R5 = R4;
           R4 = Hp - 7;
           R3 = R3;
           R2 = R2;
           call Control.Arrow.$fArrowChoiceKleisli1_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.408736871 UTC

[section ""data" . Control.Arrow.$fArrowChoiceKleisli2_closure" {
     Control.Arrow.$fArrowChoiceKleisli2_closure:
         const Control.Arrow.$fArrowChoiceKleisli2_info;
 },
 sat_sbQd4_entry() //  [R1, R2]
         { info_tbl: [(cbR5W,
                       label: sat_sbQd4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR5W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbR5X; else goto cbR5Y;
       cbR5X: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbR5Y: // global
           _sbQd3::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _sbQd3::P64;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Arrow.$fArrowChoiceKleisli2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbR5Z,
                       label: Control.Arrow.$fArrowChoiceKleisli2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR5Z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbR63; else goto cbR62;
       cbR63: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$fArrowChoiceKleisli2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbR62: // global
           I64[Hp - 8] = sat_sbQd4_info;
           P64[Hp] = R2;
           R5 = R4;
           R4 = R3;
           R3 = Hp - 7;
           R2 = R2;
           call Control.Arrow.$fArrowChoiceKleisli1_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.414523726 UTC

[section ""data" . lvl4_rbNCc_closure" {
     lvl4_rbNCc_closure:
         const lvl4_rbNCc_info;
 },
 lvl4_rbNCc_entry() //  [R2, R3, R4]
         { info_tbl: [(cbR6i,
                       label: lvl4_rbNCc_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR6i: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Either.either_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.418704602 UTC

[section ""data" . Control.Arrow.$fArrowChoiceKleisli_closure" {
     Control.Arrow.$fArrowChoiceKleisli_closure:
         const Control.Arrow.$fArrowChoiceKleisli_info;
 },
 sat_sbQdc_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbR6y,
                       label: sat_sbQdc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR6y: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fArrowChoiceKleisli1_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQdb_entry() //  [R1, R2, R3]
         { info_tbl: [(cbR6G,
                       label: sat_sbQdb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR6G: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowChoiceKleisli2_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQda_entry() //  [R1, R2, R3]
         { info_tbl: [(cbR6O,
                       label: sat_sbQda_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR6O: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Arrow.$fArrowChoiceKleisli3_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQd9_entry() //  [R1]
         { info_tbl: [(cbR6V,
                       label: sat_sbQd9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR6V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbR6W; else goto cbR6X;
       cbR6W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbR6X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowKleisli_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowChoiceKleisli_entry() //  [R2]
         { info_tbl: [(cbR6Z,
                       label: Control.Arrow.$fArrowChoiceKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR6Z: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cbR73; else goto cbR72;
       cbR73: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Control.Arrow.$fArrowChoiceKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbR72: // global
           I64[Hp - 112] = sat_sbQdc_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbQdb_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbQda_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbQd9_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = Control.Arrow.C:ArrowChoice_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 94;
           P64[Hp - 8] = Hp - 109;
           P64[Hp] = lvl4_rbNCc_closure+3;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.430482032 UTC

[section ""data" . Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_closure" {
     Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_closure:
         const Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_info;
 },
 sat_sbQde_entry() //  [R1]
         { info_tbl: [(cbR7F,
                       label: sat_sbQde_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR7F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbR7G; else goto cbR7H;
       cbR7G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbR7H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_entry() //  [R2]
         { info_tbl: [(cbR7I,
                       label: Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR7I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbR7M; else goto cbR7L;
       cbR7M: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbR7L: // global
           I64[Hp - 16] = sat_sbQde_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Arrow.$fArrowKleisli_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.436550522 UTC

[section ""data" . Control.Arrow.$fArrowZeroKleisli_closure" {
     Control.Arrow.$fArrowZeroKleisli_closure:
         const Control.Arrow.$fArrowZeroKleisli_info;
 },
 lvl5_sbQdg_entry() //  [R1]
         { info_tbl: [(cbR85,
                       label: lvl5_sbQdg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR85: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbR86; else goto cbR87;
       cbR86: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbR87: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbQdj_entry() //  [R1]
         { info_tbl: [(cbR8d,
                       label: sat_sbQdj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR8d: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQdh_entry() //  [R1]
         { info_tbl: [(cbR8k,
                       label: sat_sbQdh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR8k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbR8l; else goto cbR8m;
       cbR8l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbR8m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowZeroKleisli_entry() //  [R2]
         { info_tbl: [(cbR8o,
                       label: Control.Arrow.$fArrowZeroKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR8o: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbR8s; else goto cbR8r;
       cbR8s: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = Control.Arrow.$fArrowZeroKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbR8r: // global
           I64[Hp - 80] = lvl5_sbQdg_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbQdj_info;
           P64[Hp - 48] = Hp - 80;
           I64[Hp - 40] = sat_sbQdh_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Arrow.C:ArrowZero_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.44657585 UTC

[section ""data" . Control.Arrow.$fArrowPlusKleisli_closure" {
     Control.Arrow.$fArrowPlusKleisli_closure:
         const Control.Arrow.$fArrowPlusKleisli_info;
 },
 sat_sbQdm_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbR91,
                       label: sat_sbQdm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR91: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Arrow.$fArrowPlusKleisli1_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQdl_entry() //  [R1]
         { info_tbl: [(cbR98,
                       label: sat_sbQdl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR98: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbR99; else goto cbR9a;
       cbR99: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbR9a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$fArrowZeroKleisli_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$fArrowPlusKleisli_entry() //  [R2]
         { info_tbl: [(cbR9c,
                       label: Control.Arrow.$fArrowPlusKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR9c: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbR9g; else goto cbR9f;
       cbR9g: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Arrow.$fArrowPlusKleisli_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbR9f: // global
           I64[Hp - 56] = sat_sbQdm_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbQdl_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Arrow.C:ArrowPlus_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 53;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.45454601 UTC

[section ""data" . Control.Arrow.$dmsecond_closure" {
     Control.Arrow.$dmsecond_closure:
         const Control.Arrow.$dmsecond_info;
 },
 sat_sbQdp_entry() //  [R1]
         { info_tbl: [(cbR9J,
                       label: sat_sbQdp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR9J: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbR9K; else goto cbR9L;
       cbR9K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbR9L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbR9H_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbR9H() //  [R1]
         { info_tbl: [(cbR9H,
                       label: block_cbR9H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR9H: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Category.id_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dmsecond_entry() //  [R2]
         { info_tbl: [(cbR9P,
                       label: Control.Arrow.$dmsecond_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR9P: // global
           _sbQdn::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbR9Q; else goto cbR9R;
       cbR9R: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbR9T; else goto cbR9S;
       cbR9T: // global
           HpAlloc = 24;
           goto cbR9Q;
       cbR9Q: // global
           R2 = _sbQdn::P64;
           R1 = Control.Arrow.$dmsecond_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbR9S: // global
           I64[Hp - 16] = sat_sbQdp_info;
           P64[Hp] = _sbQdn::P64;
           R2 = _sbQdn::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Control.Arrow.***_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.462207338 UTC

[section ""data" . Control.Arrow.$dmfirst_closure" {
     Control.Arrow.$dmfirst_closure:
         const Control.Arrow.$dmfirst_info;
 },
 sat_sbQdt_entry() //  [R1]
         { info_tbl: [(cbRal,
                       label: sat_sbQdt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRal: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbRam; else goto cbRan;
       cbRam: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbRan: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbRaj_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbRaj() //  [R1]
         { info_tbl: [(cbRaj,
                       label: block_cbRaj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRaj: // global
           R2 = R1;
           Sp = Sp + 8;
           call Control.Category.id_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$dmfirst_entry() //  [R2, R3]
         { info_tbl: [(cbRar,
                       label: Control.Arrow.$dmfirst_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRar: // global
           _sbQdr::P64 = R3;
           _sbQdq::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbRas; else goto cbRat;
       cbRat: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbRav; else goto cbRau;
       cbRav: // global
           HpAlloc = 24;
           goto cbRas;
       cbRas: // global
           R3 = _sbQdr::P64;
           R2 = _sbQdq::P64;
           R1 = Control.Arrow.$dmfirst_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRau: // global
           I64[Hp - 16] = sat_sbQdt_info;
           P64[Hp] = _sbQdq::P64;
           R2 = _sbQdq::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbQdr::P64;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Control.Arrow.***_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.471071821 UTC

[section ""data" . Control.Arrow.$cfirst_closure" {
     Control.Arrow.$cfirst_closure:
         const Control.Arrow.$cfirst_info;
 },
 sat_sbQdA_entry() //  [R1]
         { info_tbl: [(cbRaX,
                       label: sat_sbQdA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRaX: // global
           _sbQdA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbRaY; else goto cbRaZ;
       cbRaZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbRb1; else goto cbRb0;
       cbRb1: // global
           HpAlloc = 24;
           goto cbRaY;
       cbRaY: // global
           R1 = _sbQdA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbRb0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQdA::P64;
           _sbQdu::P64 = P64[_sbQdA::P64 + 16];
           _sbQdv::P64 = P64[_sbQdA::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbQdv::P64;
           R2 = Hp - 16;
           R1 = _sbQdu::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$cfirst_entry() //  [R2, R3]
         { info_tbl: [(cbRb3,
                       label: Control.Arrow.$cfirst_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRb3: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbRb7; else goto cbRb6;
       cbRb7: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$cfirst_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRb6: // global
           I64[Hp - 72] = stg_sel_1_upd_info;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sbQdA_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.47765983 UTC

[section ""data" . Control.Arrow.$csecond_closure" {
     Control.Arrow.$csecond_closure:
         const Control.Arrow.$csecond_info;
 },
 sat_sbQdP_entry() //  [R1]
         { info_tbl: [(cbRbx,
                       label: sat_sbQdP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRbx: // global
           _sbQdP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbRby; else goto cbRbz;
       cbRbz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbRbB; else goto cbRbA;
       cbRbB: // global
           HpAlloc = 24;
           goto cbRby;
       cbRby: // global
           R1 = _sbQdP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbRbA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQdP::P64;
           _sbQdF::P64 = P64[_sbQdP::P64 + 16];
           _sbQdG::P64 = P64[_sbQdP::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sbQdG::P64;
           R2 = Hp - 16;
           R1 = _sbQdF::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.$csecond_entry() //  [R2, R3]
         { info_tbl: [(cbRbE,
                       label: Control.Arrow.$csecond_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRbE: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbRbI; else goto cbRbH;
       cbRbI: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$csecond_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRbH: // global
           I64[Hp - 72] = sat_sbQdP_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.484291288 UTC

[section ""data" . Control.Arrow.$c&&&_closure" {
     Control.Arrow.$c&&&_closure:
         const Control.Arrow.$c&&&_info;
 },
 Control.Arrow.$c&&&_entry() //  [R2, R3, R4]
         { info_tbl: [(cbRc6,
                       label: Control.Arrow.$c&&&_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRc6: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbRca; else goto cbRc9;
       cbRca: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$c&&&_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRc9: // global
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.488305343 UTC

[section ""data" . Control.Arrow.$fArrow(->)_closure" {
     Control.Arrow.$fArrow(->)_closure:
         const Control.Arrow.C:Arrow_con_info;
         const Control.Category.$fCategoryTYPE(->)_closure;
         const Control.Arrow.$fArrow(->)_$carr_closure+1;
         const Control.Arrow.$cfirst_closure+2;
         const Control.Arrow.$csecond_closure+2;
         const Control.Arrow.$c***_closure+3;
         const Control.Arrow.$c&&&_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.490212181 UTC

[section ""data" . Control.Arrow.$fArrowLoop(->)_closure" {
     Control.Arrow.$fArrowLoop(->)_closure:
         const Control.Arrow.C:ArrowLoop_con_info;
         const Control.Arrow.$fArrow(->)_closure+1;
         const Control.Arrow.$fArrowLoop(->)_$cloop_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.491913071 UTC

[section ""data" . Control.Arrow.$fArrowApply(->)_closure" {
     Control.Arrow.$fArrowApply(->)_closure:
         const Control.Arrow.C:ArrowApply_con_info;
         const Control.Arrow.$fArrow(->)_closure+1;
         const Control.Arrow.$fAlternativeArrowMonad_$capp_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.494373698 UTC

[section ""data" . Control.Arrow.$c+++_closure" {
     Control.Arrow.$c+++_closure:
         const Control.Arrow.$c+++_info;
 },
 Control.Arrow.$c+++_entry() //  [R2, R3, R4]
         { info_tbl: [(cbRcz,
                       label: Control.Arrow.$c+++_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRcz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbRcA; else goto cbRcB;
       cbRcA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$c+++_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRcB: // global
           I64[Sp - 24] = block_cbRcs_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubRcQ; else goto cbRct;
       ubRcQ: // global
           call _cbRcs(R1) args: 0, res: 0, upd: 0;
       cbRct: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbRcs() //  [R1]
         { info_tbl: [(cbRcs,
                       label: block_cbRcs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRcs: // global
           if (R1 & 7 == 1) goto cbRcw; else goto cbRcx;
       cbRcw: // global
           Hp = Hp + 48;
           _sbQdY::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbRcP; else goto cbRcH;
       cbRcH: // global
           _sbQdZ::P64 = P64[_sbQdY::P64 + 7];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sbQdZ::P64;
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbRcx: // global
           Hp = Hp + 48;
           _sbQdY::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbRcP; else goto cbRcO;
       cbRcP: // global
           HpAlloc = 48;
           R1 = _sbQdY::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbRcO: // global
           _sbQe1::P64 = P64[_sbQdY::P64 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sbQe1::P64;
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.501834413 UTC

[section ""data" . Control.Arrow.$cright_closure" {
     Control.Arrow.$cright_closure:
         const Control.Arrow.$cright_info;
 },
 Control.Arrow.$cright_entry() //  [R2, R3]
         { info_tbl: [(cbRdo,
                       label: Control.Arrow.$cright_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRdo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbRdp; else goto cbRdq;
       cbRdp: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$cright_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRdq: // global
           I64[Sp - 16] = block_cbRdh_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubRdB; else goto cbRdi;
       ubRdB: // global
           call _cbRdh(R1) args: 0, res: 0, upd: 0;
       cbRdi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbRdh() //  [R1]
         { info_tbl: [(cbRdh,
                       label: block_cbRdh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRdh: // global
           if (R1 & 7 == 1) goto cbRdl; else goto cbRdm;
       cbRdl: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbRdm: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbRdA; else goto cbRdz;
       cbRdA: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbRdz: // global
           _sbQe7::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sbQe7::P64;
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.509227438 UTC

[section ""data" . Control.Arrow.$cleft_closure" {
     Control.Arrow.$cleft_closure:
         const Control.Arrow.$cleft_info;
 },
 Control.Arrow.$cleft_entry() //  [R2, R3]
         { info_tbl: [(cbRe6,
                       label: Control.Arrow.$cleft_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRe6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbRe7; else goto cbRe8;
       cbRe7: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.$cleft_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRe8: // global
           I64[Sp - 16] = block_cbRdZ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubRej; else goto cbRe0;
       ubRej: // global
           call _cbRdZ(R1) args: 0, res: 0, upd: 0;
       cbRe0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbRdZ() //  [R1]
         { info_tbl: [(cbRdZ,
                       label: block_cbRdZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRdZ: // global
           if (R1 & 7 == 1) goto cbRe3; else goto cbRe4;
       cbRe3: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbRef; else goto cbRee;
       cbRef: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbRee: // global
           _sbQec::P64 = P64[R1 + 7];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sbQec::P64;
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbRe4: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.515271429 UTC

[section ""data" . Control.Arrow.$fArrowChoice(->)_closure" {
     Control.Arrow.$fArrowChoice(->)_closure:
         const Control.Arrow.C:ArrowChoice_con_info;
         const Control.Arrow.$fArrow(->)_closure+1;
         const Control.Arrow.$cleft_closure+2;
         const Control.Arrow.$cright_closure+2;
         const Control.Arrow.$c+++_closure+3;
         const Data.Either.either_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.517322528 UTC

[section ""data" . Control.Arrow.runKleisli1_closure" {
     Control.Arrow.runKleisli1_closure:
         const Control.Arrow.runKleisli1_info;
 },
 Control.Arrow.runKleisli1_entry() //  [R2]
         { info_tbl: [(cbReI,
                       label: Control.Arrow.runKleisli1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbReI: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.520541239 UTC

[section ""data" . Control.Arrow.runKleisli_closure" {
     Control.Arrow.runKleisli_closure:
         const Control.Arrow.runKleisli_info;
 },
 Control.Arrow.runKleisli_entry() //  [R2]
         { info_tbl: [(cbReT,
                       label: Control.Arrow.runKleisli_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbReT: // global
           R2 = R2;
           call Control.Arrow.runKleisli1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.524333455 UTC

[section ""data" . Control.Arrow.returnA_closure" {
     Control.Arrow.returnA_closure:
         const Control.Arrow.returnA_info;
 },
 Control.Arrow.returnA_entry() //  [R2]
         { info_tbl: [(cbRf4,
                       label: Control.Arrow.returnA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRf4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbRf5; else goto cbRf6;
       cbRf5: // global
           R2 = R2;
           R1 = Control.Arrow.returnA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbRf6: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.id_closure+1;
           Sp = Sp - 16;
           call Control.Arrow.arr_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.528531762 UTC

[section ""data" . Control.Arrow.^>>_closure" {
     Control.Arrow.^>>_closure:
         const Control.Arrow.^>>_info;
 },
 sat_sbQel_entry() //  [R1]
         { info_tbl: [(cbRfn,
                       label: sat_sbQel_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRfn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbRfo; else goto cbRfp;
       cbRfo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbRfp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.^>>_entry() //  [R2, R3, R4]
         { info_tbl: [(cbRfs,
                       label: Control.Arrow.^>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRfs: // global
           _sbQej::P64 = R4;
           _sbQei::P64 = R3;
           _sbQeh::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbRft; else goto cbRfu;
       cbRfu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbRfw; else goto cbRfv;
       cbRfw: // global
           HpAlloc = 32;
           goto cbRft;
       cbRft: // global
           R4 = _sbQej::P64;
           R3 = _sbQei::P64;
           R2 = _sbQeh::P64;
           R1 = Control.Arrow.^>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRfv: // global
           I64[Hp - 24] = sat_sbQel_info;
           P64[Hp - 8] = _sbQeh::P64;
           P64[Hp] = _sbQei::P64;
           I64[Sp - 24] = block_cbRfq_info;
           R2 = _sbQeh::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbQej::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbRfq() //  [R1]
         { info_tbl: [(cbRfq,
                       label: block_cbRfq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRfq: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbRfj::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbRfj::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.536618791 UTC

[section ""data" . Control.Arrow.>>^_closure" {
     Control.Arrow.>>^_closure:
         const Control.Arrow.>>^_info;
 },
 sat_sbQeq_entry() //  [R1]
         { info_tbl: [(cbRg2,
                       label: sat_sbQeq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRg2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbRg3; else goto cbRg4;
       cbRg3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbRg4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.>>^_entry() //  [R2, R3, R4]
         { info_tbl: [(cbRg7,
                       label: Control.Arrow.>>^_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRg7: // global
           _sbQeo::P64 = R4;
           _sbQen::P64 = R3;
           _sbQem::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbRg8; else goto cbRg9;
       cbRg9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbRgb; else goto cbRga;
       cbRgb: // global
           HpAlloc = 32;
           goto cbRg8;
       cbRg8: // global
           R4 = _sbQeo::P64;
           R3 = _sbQen::P64;
           R2 = _sbQem::P64;
           R1 = Control.Arrow.>>^_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRga: // global
           I64[Hp - 24] = sat_sbQeq_info;
           P64[Hp - 8] = _sbQem::P64;
           P64[Hp] = _sbQeo::P64;
           I64[Sp - 24] = block_cbRg5_info;
           R2 = _sbQem::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbQen::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbRg5() //  [R1]
         { info_tbl: [(cbRg5,
                       label: block_cbRg5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRg5: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.545747054 UTC

[section ""data" . Control.Arrow.<<^_closure" {
     Control.Arrow.<<^_closure:
         const Control.Arrow.<<^_info;
 },
 sat_sbQev_entry() //  [R1]
         { info_tbl: [(cbRgG,
                       label: sat_sbQev_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRgG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbRgH; else goto cbRgI;
       cbRgH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbRgI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.<<^_entry() //  [R2, R3, R4]
         { info_tbl: [(cbRgL,
                       label: Control.Arrow.<<^_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRgL: // global
           _sbQet::P64 = R4;
           _sbQes::P64 = R3;
           _sbQer::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbRgM; else goto cbRgN;
       cbRgN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbRgP; else goto cbRgO;
       cbRgP: // global
           HpAlloc = 32;
           goto cbRgM;
       cbRgM: // global
           R4 = _sbQet::P64;
           R3 = _sbQes::P64;
           R2 = _sbQer::P64;
           R1 = Control.Arrow.<<^_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRgO: // global
           I64[Hp - 24] = sat_sbQev_info;
           P64[Hp - 8] = _sbQer::P64;
           P64[Hp] = _sbQet::P64;
           I64[Sp - 24] = block_cbRgJ_info;
           R2 = _sbQer::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbQes::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbRgJ() //  [R1]
         { info_tbl: [(cbRgJ,
                       label: block_cbRgJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRgJ: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbRgC::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbRgC::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.55418431 UTC

[section ""data" . Control.Arrow.^<<_closure" {
     Control.Arrow.^<<_closure:
         const Control.Arrow.^<<_info;
 },
 sat_sbQeA_entry() //  [R1]
         { info_tbl: [(cbRhl,
                       label: sat_sbQeA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRhl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbRhm; else goto cbRhn;
       cbRhm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbRhn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Arrow.^<<_entry() //  [R2, R3, R4]
         { info_tbl: [(cbRhq,
                       label: Control.Arrow.^<<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRhq: // global
           _sbQey::P64 = R4;
           _sbQex::P64 = R3;
           _sbQew::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbRhr; else goto cbRhs;
       cbRhs: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbRhu; else goto cbRht;
       cbRhu: // global
           HpAlloc = 32;
           goto cbRhr;
       cbRhr: // global
           R4 = _sbQey::P64;
           R3 = _sbQex::P64;
           R2 = _sbQew::P64;
           R1 = Control.Arrow.^<<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRht: // global
           I64[Hp - 24] = sat_sbQeA_info;
           P64[Hp - 8] = _sbQew::P64;
           P64[Hp] = _sbQex::P64;
           I64[Sp - 24] = block_cbRho_info;
           R2 = _sbQew::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbQey::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbRho() //  [R1]
         { info_tbl: [(cbRho,
                       label: block_cbRho_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRho: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.56424695 UTC

[section ""data" . Control.Arrow.leftApp_closure" {
     Control.Arrow.leftApp_closure:
         const Control.Arrow.leftApp_info;
 },
 lvl5_sbQeG_entry() //  [R1]
         { info_tbl: [(cbRib,
                       label: lvl5_sbQeG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRib: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbRic; else goto cbRid;
       cbRic: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbRid: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Either.Left_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbQeM_entry() //  [R1, R2]
         { info_tbl: [(cbRiI,
                       label: sat_sbQeM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRiI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbRiJ; else goto cbRiK;
       cbRiJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbRiK: // global
           I64[Sp - 16] = block_cbRiF_info;
           _sbQeJ::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sbQeJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubRiO; else goto cbRiG;
       ubRiO: // global
           call _cbRiF() args: 0, res: 0, upd: 0;
       cbRiG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbRiF() //  []
         { info_tbl: [(cbRiF,
                       label: block_cbRiF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRiF: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQeN_entry() //  [R1]
         { info_tbl: [(cbRiP,
                       label: sat_sbQeN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRiP: // global
           _sbQeN::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbRiQ; else goto cbRiR;
       cbRiR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbRiT; else goto cbRiS;
       cbRiT: // global
           HpAlloc = 16;
           goto cbRiQ;
       cbRiQ: // global
           R1 = _sbQeN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbRiS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQeN::P64;
           _sbQeD::P64 = P64[_sbQeN::P64 + 16];
           _sbQeJ::P64 = P64[_sbQeN::P64 + 24];
           I64[Hp - 8] = sat_sbQeM_info;
           P64[Hp] = _sbQeJ::P64;
           R2 = _sbQeD::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbQeO_entry() //  [R1]
         { info_tbl: [(cbRiU,
                       label: sat_sbQeO_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRiU: // global
           _sbQeO::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbRiV; else goto cbRiW;
       cbRiW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbRiY; else goto cbRiX;
       cbRiY: // global
           HpAlloc = 32;
           goto cbRiV;
       cbRiV: // global
           R1 = _sbQeO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbRiX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQeO::P64;
           _sbQeC::P64 = P64[_sbQeO::P64 + 16];
           _sbQeD::P64 = P64[_sbQeO::P64 + 24];
           _sbQeE::P64 = P64[_sbQeO::P64 + 32];
           _sbQeJ::P64 = P64[_sbQeO::P64 + 40];
           I64[Hp - 24] = sat_sbQeN_info;
           P64[Hp - 8] = _sbQeD::P64;
           P64[Hp] = _sbQeJ::P64;
           R2 = _sbQeE::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbQeC::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbQeP_entry() //  [R1]
         { info_tbl: [(cbRiZ,
                       label: sat_sbQeP_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRiZ: // global
           _sbQeP::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbRj0; else goto cbRj1;
       cbRj1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbRj3; else goto cbRj2;
       cbRj3: // global
           HpAlloc = 48;
           goto cbRj0;
       cbRj0: // global
           R1 = _sbQeP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbRj2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQeP::P64;
           _sbQeC::P64 = P64[_sbQeP::P64 + 16];
           _sbQeD::P64 = P64[_sbQeP::P64 + 24];
           _sbQeE::P64 = P64[_sbQeP::P64 + 32];
           _sbQeG::P64 = P64[_sbQeP::P64 + 40];
           _sbQeJ::P64 = P64[_sbQeP::P64 + 48];
           I64[Hp - 40] = sat_sbQeO_info;
           P64[Hp - 24] = _sbQeC::P64;
           P64[Hp - 16] = _sbQeD::P64;
           P64[Hp - 8] = _sbQeE::P64;
           P64[Hp] = _sbQeJ::P64;
           R2 = _sbQeE::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbQeG::P64;
           P64[Sp - 24] = Hp - 40;
           Sp = Sp - 40;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbQeT_entry() //  [R1]
         { info_tbl: [(cbRjm,
                       label: sat_sbQeT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRjm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbRjn; else goto cbRjo;
       cbRjn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbRjo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbRjj_info;
           _sbQeQ::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbQeQ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubRjs; else goto cbRjk;
       ubRjs: // global
           call _cbRjj() args: 0, res: 0, upd: 0;
       cbRjk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbRjj() //  []
         { info_tbl: [(cbRjj,
                       label: block_cbRjj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRjj: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbQeU_entry() //  [R1, R2]
         { info_tbl: [(cbRju,
                       label: sat_sbQeU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRju: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbRjy; else goto cbRjx;
       cbRjy: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbRjx: // global
           _sbQeQ::P64 = P64[R1 + 7];
           I64[Hp - 40] = sat_sbQeT_info;
           P64[Hp - 24] = _sbQeQ::P64;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQeV_entry() //  [R1]
         { info_tbl: [(cbRjz,
                       label: sat_sbQeV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRjz: // global
           _sbQeV::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbRjA; else goto cbRjB;
       cbRjB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbRjD; else goto cbRjC;
       cbRjD: // global
           HpAlloc = 16;
           goto cbRjA;
       cbRjA: // global
           R1 = _sbQeV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbRjC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQeV::P64;
           _sbQeD::P64 = P64[_sbQeV::P64 + 16];
           _sbQeQ::P64 = P64[_sbQeV::P64 + 24];
           I64[Hp - 8] = sat_sbQeU_info;
           P64[Hp] = _sbQeQ::P64;
           R2 = _sbQeD::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbQeW_entry() //  [R1, R2]
         { info_tbl: [(cbRjI,
                       label: sat_sbQeW_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRjI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbRjJ; else goto cbRjK;
       cbRjJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbRjK: // global
           I64[Sp - 40] = block_cbRij_info;
           _sbQeC::P64 = P64[R1 + 7];
           _sbQeD::P64 = P64[R1 + 15];
           _sbQeE::P64 = P64[R1 + 23];
           _sbQeG::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _sbQeC::P64;
           P64[Sp - 24] = _sbQeD::P64;
           P64[Sp - 16] = _sbQeE::P64;
           P64[Sp - 8] = _sbQeG::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubRjT; else goto cbRik;
       ubRjT: // global
           call _cbRij(R1) args: 0, res: 0, upd: 0;
       cbRik: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbRij() //  [R1]
         { info_tbl: [(cbRij,
                       label: block_cbRij_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRij: // global
           _sbQeD::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbRjF; else goto cbRjG;
       cbRjF: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbRjO; else goto cbRjN;
       cbRjO: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbRjN: // global
           _sbQeJ::P64 = P64[R1 + 7];
           I64[Hp - 72] = sat_sbQeP_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _sbQeD::P64;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sbQeJ::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = GHC.Tuple.()_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbRjG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbRjS; else goto cbRjR;
       cbRjS: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbRjR: // global
           _sbQeQ::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sbQeV_info;
           P64[Hp - 32] = _sbQeD::P64;
           P64[Hp - 24] = _sbQeQ::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Tuple.()_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbQeX_entry() //  [R1]
         { info_tbl: [(cbRjU,
                       label: sat_sbQeX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRjU: // global
           _sbQeX::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbRjV; else goto cbRjW;
       cbRjW: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbRjY; else goto cbRjX;
       cbRjY: // global
           HpAlloc = 64;
           goto cbRjV;
       cbRjV: // global
           R1 = _sbQeX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbRjX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbQeX::P64;
           _sbQeC::P64 = P64[_sbQeX::P64 + 16];
           _sbQeD::P64 = P64[_sbQeX::P64 + 24];
           _sbQeE::P64 = P64[_sbQeX::P64 + 32];
           I64[Hp - 56] = lvl5_sbQeG_info;
           P64[Hp - 40] = _sbQeD::P64;
           I64[Hp - 32] = sat_sbQeW_info;
           P64[Hp - 24] = _sbQeC::P64;
           P64[Hp - 16] = _sbQeD::P64;
           P64[Hp - 8] = _sbQeE::P64;
           P64[Hp] = Hp - 56;
           R2 = _sbQeD::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 31;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbQeF_entry() //  [R1]
         { info_tbl: [(cbRk3,
                       label: sat_sbQeF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRk3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbRk4; else goto cbRk5;
       cbRk4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbRk5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.app_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Arrow.leftApp_entry() //  [R2, R3]
         { info_tbl: [(cbRk6,
                       label: Control.Arrow.leftApp_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRk6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbRk7; else goto cbRk8;
       cbRk7: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.leftApp_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRk8: // global
           I64[Sp - 24] = block_cbRhV_info;
           _sbQeB::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _sbQeB::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Control.Arrow.$p1ArrowApply_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbRhV() //  [R1]
         { info_tbl: [(cbRhV,
                       label: block_cbRhV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRhV: // global
           I64[Sp - 8] = block_cbRhZ_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbRhZ() //  [R1]
         { info_tbl: [(cbRhZ,
                       label: block_cbRhZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRhZ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbRkc; else goto cbRkb;
       cbRkc: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbRkb: // global
           I64[Hp - 56] = sat_sbQeX_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sbQeF_info;
           P64[Hp] = P64[Sp + 16];
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 16;
           P64[Sp + 24] = Hp - 56;
           Sp = Sp + 8;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.602645295 UTC

[section ""cstring" . Control.Arrow.$trModule4_bytes" {
     Control.Arrow.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.604297324 UTC

[section ""data" . Control.Arrow.$trModule3_closure" {
     Control.Arrow.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.606032699 UTC

[section ""cstring" . Control.Arrow.$trModule2_bytes" {
     Control.Arrow.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,65,114,114,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.607672333 UTC

[section ""data" . Control.Arrow.$trModule1_closure" {
     Control.Arrow.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.609498446 UTC

[section ""data" . Control.Arrow.$trModule_closure" {
     Control.Arrow.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Arrow.$trModule3_closure+1;
         const Control.Arrow.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.611280942 UTC

[section ""data" . $krep_rbNCd_closure" {
     $krep_rbNCd_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.613151344 UTC

[section ""data" . $krep1_rbNCe_closure" {
     $krep1_rbNCe_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.614906032 UTC

[section ""data" . Control.Arrow.$tcKleisli1_closure" {
     Control.Arrow.$tcKleisli1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const GHC.Types.krep$*->*->*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.616612185 UTC

[section ""data" . Control.Arrow.$tcArrow1_closure" {
     Control.Arrow.$tcArrow1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const $krep1_rbNCe_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.618947181 UTC

[section ""data" . Control.Arrow.$tcArrowMonad1_closure" {
     Control.Arrow.$tcArrowMonad1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const GHC.Types.krep$*Arr*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.620653817 UTC

[section ""data" . $krep2_rbNCf_closure" {
     $krep2_rbNCf_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.622326373 UTC

[section ""data" . $krep3_rbNCg_closure" {
     $krep3_rbNCg_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.62408756 UTC

[section ""data" . $krep4_rbNCh_closure" {
     $krep4_rbNCh_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.625760103 UTC

[section ""data" . $krep5_rbNCi_closure" {
     $krep5_rbNCi_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_rbNCh_closure+2;
         const $krep2_rbNCf_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.6274176 UTC

[section ""data" . $krep6_rbNCj_closure" {
     $krep6_rbNCj_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rbNCg_closure+2;
         const $krep5_rbNCi_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.628989689 UTC

[section ""data" . $krep7_rbNCk_closure" {
     $krep7_rbNCk_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_rbNCh_closure+2;
         const $krep_rbNCd_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.63162783 UTC

[section ""data" . $krep8_rbNCl_closure" {
     $krep8_rbNCl_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep7_rbNCk_closure+3;
         const $krep3_rbNCg_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.633351339 UTC

[section ""cstring" . Control.Arrow.$tcArrow3_bytes" {
     Control.Arrow.$tcArrow3_bytes:
         I8[] [65,114,114,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.635082683 UTC

[section ""data" . Control.Arrow.$tcArrow2_closure" {
     Control.Arrow.$tcArrow2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrow3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.636783846 UTC

[section ""data" . Control.Arrow.$tcArrow_closure" {
     Control.Arrow.$tcArrow_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrow2_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 12964584583212294992;
         const 10211991410748124746;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.638638199 UTC

[section ""cstring" . Control.Arrow.$tcKleisli3_bytes" {
     Control.Arrow.$tcKleisli3_bytes:
         I8[] [75,108,101,105,115,108,105]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.640293864 UTC

[section ""data" . Control.Arrow.$tcKleisli2_closure" {
     Control.Arrow.$tcKleisli2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcKleisli3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.642974994 UTC

[section ""data" . Control.Arrow.$tcKleisli_closure" {
     Control.Arrow.$tcKleisli_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcKleisli2_closure+1;
         const Control.Arrow.$tcKleisli1_closure+4;
         const 2023158159015915132;
         const 6143719008973118504;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.645541558 UTC

[section ""data" . $krep9_rbNCm_closure" {
     $krep9_rbNCm_closure:
         const :_con_info;
         const $krep2_rbNCf_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.647352087 UTC

[section ""data" . $krep10_rbNCn_closure" {
     $krep10_rbNCn_closure:
         const :_con_info;
         const $krep3_rbNCg_closure+2;
         const $krep9_rbNCm_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.649163554 UTC

[section ""data" . $krep11_rbNCo_closure" {
     $krep11_rbNCo_closure:
         const :_con_info;
         const $krep4_rbNCh_closure+2;
         const $krep10_rbNCn_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.651580237 UTC

[section ""data" . $krep12_rbNCp_closure" {
     $krep12_rbNCp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Arrow.$tcKleisli_closure+1;
         const $krep11_rbNCo_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.653395834 UTC

[section ""data" . Control.Arrow.$tc'Kleisli1_closure" {
     Control.Arrow.$tc'Kleisli1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rbNCj_closure+4;
         const $krep12_rbNCp_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.65510836 UTC

[section ""cstring" . Control.Arrow.$tc'Kleisli3_bytes" {
     Control.Arrow.$tc'Kleisli3_bytes:
         I8[] [39,75,108,101,105,115,108,105]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.656724873 UTC

[section ""data" . Control.Arrow.$tc'Kleisli2_closure" {
     Control.Arrow.$tc'Kleisli2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tc'Kleisli3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.658417551 UTC

[section ""data" . Control.Arrow.$tc'Kleisli_closure" {
     Control.Arrow.$tc'Kleisli_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tc'Kleisli2_closure+1;
         const Control.Arrow.$tc'Kleisli1_closure+4;
         const 793719726112502834;
         const 14919550952510816382;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.660326516 UTC

[section ""cstring" . Control.Arrow.$tcArrowZero2_bytes" {
     Control.Arrow.$tcArrowZero2_bytes:
         I8[] [65,114,114,111,119,90,101,114,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.66203908 UTC

[section ""data" . Control.Arrow.$tcArrowZero1_closure" {
     Control.Arrow.$tcArrowZero1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowZero2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.663698552 UTC

[section ""data" . Control.Arrow.$tcArrowZero_closure" {
     Control.Arrow.$tcArrowZero_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowZero1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 337582314637215801;
         const 485553589222180171;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.665852767 UTC

[section ""cstring" . Control.Arrow.$tcArrowPlus2_bytes" {
     Control.Arrow.$tcArrowPlus2_bytes:
         I8[] [65,114,114,111,119,80,108,117,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.667467147 UTC

[section ""data" . Control.Arrow.$tcArrowPlus1_closure" {
     Control.Arrow.$tcArrowPlus1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowPlus2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.669182574 UTC

[section ""data" . Control.Arrow.$tcArrowPlus_closure" {
     Control.Arrow.$tcArrowPlus_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowPlus1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 9089885184909062397;
         const 13092571182525076608;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.671703174 UTC

[section ""cstring" . Control.Arrow.$tcArrowChoice2_bytes" {
     Control.Arrow.$tcArrowChoice2_bytes:
         I8[] [65,114,114,111,119,67,104,111,105,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.673427591 UTC

[section ""data" . Control.Arrow.$tcArrowChoice1_closure" {
     Control.Arrow.$tcArrowChoice1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowChoice2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.675133602 UTC

[section ""data" . Control.Arrow.$tcArrowChoice_closure" {
     Control.Arrow.$tcArrowChoice_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowChoice1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 9045385674203608923;
         const 4474606397073518393;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.676931463 UTC

[section ""cstring" . Control.Arrow.$tcArrowApply2_bytes" {
     Control.Arrow.$tcArrowApply2_bytes:
         I8[] [65,114,114,111,119,65,112,112,108,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.678589702 UTC

[section ""data" . Control.Arrow.$tcArrowApply1_closure" {
     Control.Arrow.$tcArrowApply1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowApply2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.680435164 UTC

[section ""data" . Control.Arrow.$tcArrowApply_closure" {
     Control.Arrow.$tcArrowApply_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowApply1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 4969046276209689969;
         const 2697302259091605677;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.682400896 UTC

[section ""cstring" . Control.Arrow.$tcArrowMonad3_bytes" {
     Control.Arrow.$tcArrowMonad3_bytes:
         I8[] [65,114,114,111,119,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.684019664 UTC

[section ""data" . Control.Arrow.$tcArrowMonad2_closure" {
     Control.Arrow.$tcArrowMonad2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowMonad3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.685824808 UTC

[section ""data" . Control.Arrow.$tcArrowMonad_closure" {
     Control.Arrow.$tcArrowMonad_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowMonad2_closure+1;
         const Control.Arrow.$tcArrowMonad1_closure+4;
         const 2648525758856951758;
         const 13692351200590237690;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.687704585 UTC

[section ""data" . $krep13_rbNCq_closure" {
     $krep13_rbNCq_closure:
         const :_con_info;
         const $krep3_rbNCg_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.690070917 UTC

[section ""data" . $krep14_rbNCr_closure" {
     $krep14_rbNCr_closure:
         const :_con_info;
         const $krep4_rbNCh_closure+2;
         const $krep13_rbNCq_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.69175451 UTC

[section ""data" . $krep15_rbNCs_closure" {
     $krep15_rbNCs_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Arrow.$tcArrowMonad_closure+1;
         const $krep14_rbNCr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.693440608 UTC

[section ""data" . Control.Arrow.$tc'ArrowMonad1_closure" {
     Control.Arrow.$tc'ArrowMonad1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rbNCl_closure+3;
         const $krep15_rbNCs_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.695151302 UTC

[section ""cstring" . Control.Arrow.$tc'ArrowMonad3_bytes" {
     Control.Arrow.$tc'ArrowMonad3_bytes:
         I8[] [39,65,114,114,111,119,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.697656938 UTC

[section ""data" . Control.Arrow.$tc'ArrowMonad2_closure" {
     Control.Arrow.$tc'ArrowMonad2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tc'ArrowMonad3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.69944315 UTC

[section ""data" . Control.Arrow.$tc'ArrowMonad_closure" {
     Control.Arrow.$tc'ArrowMonad_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tc'ArrowMonad2_closure+1;
         const Control.Arrow.$tc'ArrowMonad1_closure+4;
         const 8781545391513276915;
         const 783725375361948493;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.701194674 UTC

[section ""cstring" . Control.Arrow.$tcArrowLoop2_bytes" {
     Control.Arrow.$tcArrowLoop2_bytes:
         I8[] [65,114,114,111,119,76,111,111,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.702983593 UTC

[section ""data" . Control.Arrow.$tcArrowLoop1_closure" {
     Control.Arrow.$tcArrowLoop1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Arrow.$tcArrowLoop2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.704793948 UTC

[section ""data" . Control.Arrow.$tcArrowLoop_closure" {
     Control.Arrow.$tcArrowLoop_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Arrow.$trModule_closure+1;
         const Control.Arrow.$tcArrowLoop1_closure+1;
         const Control.Arrow.$tcArrow1_closure+4;
         const 15298492960828880948;
         const 13953070859738786616;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.706867807 UTC

[section ""data" . Control.Arrow.C:ArrowLoop_closure" {
     Control.Arrow.C:ArrowLoop_closure:
         const Control.Arrow.C:ArrowLoop_info;
 },
 Control.Arrow.C:ArrowLoop_entry() //  [R2, R3]
         { info_tbl: [(cbRng,
                       label: Control.Arrow.C:ArrowLoop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRng: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbRnk; else goto cbRnj;
       cbRnk: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowLoop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRnj: // global
           I64[Hp - 16] = Control.Arrow.C:ArrowLoop_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.710845371 UTC

[section ""data" . Control.Arrow.C:ArrowApply_closure" {
     Control.Arrow.C:ArrowApply_closure:
         const Control.Arrow.C:ArrowApply_info;
 },
 Control.Arrow.C:ArrowApply_entry() //  [R2, R3]
         { info_tbl: [(cbRnw,
                       label: Control.Arrow.C:ArrowApply_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRnw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbRnA; else goto cbRnz;
       cbRnA: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowApply_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRnz: // global
           I64[Hp - 16] = Control.Arrow.C:ArrowApply_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.714986953 UTC

[section ""data" . Control.Arrow.C:ArrowChoice_closure" {
     Control.Arrow.C:ArrowChoice_closure:
         const Control.Arrow.C:ArrowChoice_info;
 },
 Control.Arrow.C:ArrowChoice_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbRnM,
                       label: Control.Arrow.C:ArrowChoice_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRnM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbRnQ; else goto cbRnP;
       cbRnQ: // global
           HpAlloc = 48;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowChoice_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRnP: // global
           I64[Hp - 40] = Control.Arrow.C:ArrowChoice_con_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.719776852 UTC

[section ""data" . Control.Arrow.C:ArrowPlus_closure" {
     Control.Arrow.C:ArrowPlus_closure:
         const Control.Arrow.C:ArrowPlus_info;
 },
 Control.Arrow.C:ArrowPlus_entry() //  [R2, R3]
         { info_tbl: [(cbRo2,
                       label: Control.Arrow.C:ArrowPlus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRo2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbRo6; else goto cbRo5;
       cbRo6: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowPlus_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRo5: // global
           I64[Hp - 16] = Control.Arrow.C:ArrowPlus_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.723819558 UTC

[section ""data" . Control.Arrow.C:ArrowZero_closure" {
     Control.Arrow.C:ArrowZero_closure:
         const Control.Arrow.C:ArrowZero_info;
 },
 Control.Arrow.C:ArrowZero_entry() //  [R2, R3]
         { info_tbl: [(cbRoi,
                       label: Control.Arrow.C:ArrowZero_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRoi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbRom; else goto cbRol;
       cbRom: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:ArrowZero_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRol: // global
           I64[Hp - 16] = Control.Arrow.C:ArrowZero_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.727772884 UTC

[section ""data" . Control.Arrow.C:Arrow_closure" {
     Control.Arrow.C:Arrow_closure:
         const Control.Arrow.C:Arrow_info;
 },
 Control.Arrow.C:Arrow_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbRoy,
                       label: Control.Arrow.C:Arrow_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRoy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbRoC; else goto cbRoB;
       cbRoC: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Arrow.C:Arrow_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbRoB: // global
           I64[Hp - 48] = Control.Arrow.C:Arrow_con_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.732384813 UTC

[Control.Arrow.C:ArrowLoop_con_entry() //  [R1]
         { info_tbl: [(cbRoK,
                       label: Control.Arrow.C:ArrowLoop_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,76,111,111,112]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRoK: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.735880965 UTC

[Control.Arrow.C:ArrowApply_con_entry() //  [R1]
         { info_tbl: [(cbRoR,
                       label: Control.Arrow.C:ArrowApply_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,65,112,112,108,121]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRoR: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.739209514 UTC

[Control.Arrow.C:ArrowChoice_con_entry() //  [R1]
         { info_tbl: [(cbRoY,
                       label: Control.Arrow.C:ArrowChoice_con_info
                       rep:HeapRep 5 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,67,104,111,105,99,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRoY: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.742747996 UTC

[Control.Arrow.C:ArrowPlus_con_entry() //  [R1]
         { info_tbl: [(cbRp5,
                       label: Control.Arrow.C:ArrowPlus_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,80,108,117,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRp5: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.746015122 UTC

[Control.Arrow.C:ArrowZero_con_entry() //  [R1]
         { info_tbl: [(cbRpc,
                       label: Control.Arrow.C:ArrowZero_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119,90,101,114,111]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRpc: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.749130456 UTC

[Control.Arrow.C:Arrow_con_entry() //  [R1]
         { info_tbl: [(cbRpj,
                       label: Control.Arrow.C:Arrow_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,65,114,114,111,119,46,67,58,65,114,114,111,119]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRpj: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:44.752252052 UTC

[section ""relreadonly" . SbQC5_srt" {
     SbQC5_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Control.Arrow.$fMonadArrowMonad_closure;
         const lvl_rbNC6_closure;
         const Control.Arrow.$fMonadPlusArrowMonad_closure;
 }]

