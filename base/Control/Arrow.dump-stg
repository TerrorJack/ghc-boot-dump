
==================== Pre unarise: ====================
2018-03-16 16:06:39.923912138 UTC

Control.Arrow.$p1ArrowLoop
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowLoop a =>
     Control.Arrow.Arrow a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sbNCu]
        case v_sbNCu of {
          Control.Arrow.C:ArrowLoop v_sbNCw [Occ=Once] _ [Occ=Dead] ->
              v_sbNCw;
        };

Control.Arrow.loop
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowLoop a =>
     forall b d c. a (b, d) (c, d) -> a b c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sbNCy]
        case v_sbNCy of {
          Control.Arrow.C:ArrowLoop _ [Occ=Dead] v_sbNCB [Occ=Once] ->
              v_sbNCB;
        };

Control.Arrow.$p1ArrowApply
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     Control.Arrow.Arrow a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sbNCC]
        case v_sbNCC of {
          Control.Arrow.C:ArrowApply v_sbNCE [Occ=Once] _ [Occ=Dead] ->
              v_sbNCE;
        };

Control.Arrow.app
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     forall b c. a (a b c, b) c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sbNCG]
        case v_sbNCG of {
          Control.Arrow.C:ArrowApply _ [Occ=Dead] v_sbNCJ [Occ=Once] ->
              v_sbNCJ;
        };

Control.Arrow.$p1ArrowChoice
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     Control.Arrow.Arrow a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLL),U(U,A,A,A,A)>] =
    [] \r [v_sbNCK]
        case v_sbNCK of {
          Control.Arrow.C:ArrowChoice v_sbNCM [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_sbNCM;
        };

Control.Arrow.left
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c d.
     a b c -> a (Data.Either.Either b d) (Data.Either.Either c d)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLL),U(A,U,A,A,A)>] =
    [] \r [v_sbNCR]
        case v_sbNCR of {
          Control.Arrow.C:ArrowChoice _ [Occ=Dead]
                                      v_sbNCU [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_sbNCU;
        };

Control.Arrow.right
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c d.
     a b c -> a (Data.Either.Either d b) (Data.Either.Either d c)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLL),U(A,A,U,A,A)>] =
    [] \r [v_sbNCY]
        case v_sbNCY of {
          Control.Arrow.C:ArrowChoice _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_sbND2 [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_sbND2;
        };

Control.Arrow.+++
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c b' c'.
     a b c
     -> a b' c' -> a (Data.Either.Either b b') (Data.Either.Either c c')
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSL),U(A,A,A,U,A)>] =
    [] \r [v_sbND5]
        case v_sbND5 of {
          Control.Arrow.C:ArrowChoice _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_sbNDa [Occ=Once]
                                      _ [Occ=Dead] ->
              v_sbNDa;
        };

Control.Arrow.|||
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b d c. a b d -> a c d -> a (Data.Either.Either b c) d
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLS),U(A,A,A,A,U)>] =
    [] \r [v_sbNDc]
        case v_sbNDc of {
          Control.Arrow.C:ArrowChoice _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_sbNDi [Occ=Once] ->
              v_sbNDi;
        };

Control.Arrow.$p1ArrowPlus
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     Control.Arrow.ArrowZero a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sbNDj]
        case v_sbNDj of {
          Control.Arrow.C:ArrowPlus v_sbNDl [Occ=Once] _ [Occ=Dead] ->
              v_sbNDl;
        };

Control.Arrow.<+>
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     forall b c. a b c -> a b c -> a b c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sbNDn]
        case v_sbNDn of {
          Control.Arrow.C:ArrowPlus _ [Occ=Dead] v_sbNDq [Occ=Once] ->
              v_sbNDq;
        };

Control.Arrow.$p1ArrowZero
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowZero a =>
     Control.Arrow.Arrow a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sbNDr]
        case v_sbNDr of {
          Control.Arrow.C:ArrowZero v_sbNDt [Occ=Once] _ [Occ=Dead] ->
              v_sbNDt;
        };

Control.Arrow.zeroArrow
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowZero a =>
     forall b c. a b c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sbNDv]
        case v_sbNDv of {
          Control.Arrow.C:ArrowZero _ [Occ=Dead] v_sbNDy [Occ=Once] ->
              v_sbNDy;
        };

Control.Arrow.$p1Arrow
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     Control.Category.Category a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLL),U(U,A,A,A,A,A)>] =
    [] \r [v_sbNDz]
        case v_sbNDz of {
          Control.Arrow.C:Arrow v_sbNDB [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_sbNDB;
        };

Control.Arrow.arr
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c. (b -> c) -> a b c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLL),U(A,U,A,A,A,A)>] =
    [] \r [v_sbNDH]
        case v_sbNDH of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                v_sbNDK [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_sbNDK;
        };

Control.Arrow.first
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c d. a b c -> a (b, d) (c, d)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLL),U(A,A,U,A,A,A)>] =
    [] \r [v_sbNDP]
        case v_sbNDP of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_sbNDT [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_sbNDT;
        };

Control.Arrow.second
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c d. a b c -> a (d, b) (d, c)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLL),U(A,A,A,U,A,A)>] =
    [] \r [v_sbNDX]
        case v_sbNDX of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_sbNE2 [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_sbNE2;
        };

Control.Arrow.***
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c b' c'. a b c -> a b' c' -> a (b, b') (c, c')
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSL),U(A,A,A,A,U,A)>] =
    [] \r [v_sbNE5]
        case v_sbNE5 of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_sbNEb [Occ=Once]
                                _ [Occ=Dead] ->
              v_sbNEb;
        };

Control.Arrow.&&&
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c c'. a b c -> a b c' -> a b (c, c')
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLS),U(A,A,A,A,A,U)>] =
    [] \r [v_sbNEd]
        case v_sbNEd of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_sbNEk [Occ=Once] ->
              v_sbNEk;
        };

Control.Arrow.$c***
  :: forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sbNEl g_sbNEm ds_sbNEn]
        let {
          sat_sbNEx [Occ=Once] :: c'_abN4I
          [LclId] =
              [g_sbNEm ds_sbNEn] \u []
                  let {
                    sat_sbNEw [Occ=Once] :: b'_abN4H
                    [LclId] =
                        [ds_sbNEn] \u []
                            case ds_sbNEn of {
                              (,) _ [Occ=Dead] y_sbNEv [Occ=Once] -> y_sbNEv;
                            };
                  } in  g_sbNEm sat_sbNEw; } in
        let {
          sat_sbNEs [Occ=Once] :: c_abN4G
          [LclId] =
              [f_sbNEl ds_sbNEn] \u []
                  let {
                    sat_sbNEr [Occ=Once] :: b_abN4F
                    [LclId] =
                        [ds_sbNEn] \u []
                            case ds_sbNEn of {
                              (,) x_sbNEp [Occ=Once] _ [Occ=Dead] -> x_sbNEp;
                            };
                  } in  f_sbNEl sat_sbNEr;
        } in  (,) [sat_sbNEs sat_sbNEx];

Control.Arrow.$fArrow(->)_$carr :: forall b c. (b -> c) -> b -> c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [f_sbNEy] f_sbNEy;

Control.Arrow.$fCategoryTYPEKleisli1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c a.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m a b -> a -> m c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbNEz ds_sbNEA ds1_sbNEB b1_sbNEC]
        let {
          sat_sbNED [Occ=Once] :: m_abN3z b_abN3Q
          [LclId] =
              [ds1_sbNEB b1_sbNEC] \u [] ds1_sbNEB b1_sbNEC;
        } in  GHC.Base.>>= $dMonad_sbNEz sat_sbNED ds_sbNEA;

Control.Arrow.$fCategoryTYPEKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     Control.Category.Category (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,1*U,A)>m] =
    [] \r [$dMonad_sbNEE]
        let {
          sat_sbNEG [Occ=Once]
            :: forall b c a.
               Control.Arrow.Kleisli m_XbN5v b c
               -> Control.Arrow.Kleisli m_XbN5v a b
               -> Control.Arrow.Kleisli m_XbN5v a c
          [LclId] =
              [$dMonad_sbNEE] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fCategoryTYPEKleisli1
                      $dMonad_sbNEE eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbNEF [Occ=Once] :: forall a. Control.Arrow.Kleisli m_XbN5v a a
          [LclId] =
              [$dMonad_sbNEE] \u [] GHC.Base.return $dMonad_sbNEE;
        } in  Control.Category.C:Category [sat_sbNEF sat_sbNEG];

Control.Arrow.$fArrowKleisli4
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c d. Control.Arrow.Kleisli m b c -> (d, b) -> m (d, c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,1*C1(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbNEH ds_sbNEI ds1_sbNEJ]
        let {
          d1_sbNEK [Occ=OnceL] :: d_abN2Q
          [LclId] =
              [ds1_sbNEJ] \u []
                  case ds1_sbNEJ of {
                    (,) d2_sbNEM [Occ=Once] _ [Occ=Dead] -> d2_sbNEM;
                  }; } in
        let {
          sat_sbNEV [Occ=Once] :: c_abN2P -> m_abN1X (d_abN2Q, c_abN2P)
          [LclId] =
              [$dMonad_sbNEH d1_sbNEK] \r [c1_sbNET]
                  let {
                    sat_sbNEU [Occ=Once] :: (d_abN2Q, c_abN2P)
                    [LclId] =
                        CCCS (,)! [d1_sbNEK c1_sbNET];
                  } in  GHC.Base.return $dMonad_sbNEH sat_sbNEU; } in
        let {
          sat_sbNES [Occ=Once] :: m_abN1X c_abN2P
          [LclId] =
              [ds_sbNEI ds1_sbNEJ] \u []
                  let {
                    sat_sbNER [Occ=Once] :: b_abN2O
                    [LclId] =
                        [ds1_sbNEJ] \u []
                            case ds1_sbNEJ of {
                              (,) _ [Occ=Dead] b1_sbNEQ [Occ=Once] -> b1_sbNEQ;
                            };
                  } in  ds_sbNEI sat_sbNER;
        } in  GHC.Base.>>= $dMonad_sbNEH sat_sbNES sat_sbNEV;

Control.Arrow.$fArrowKleisli3
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c d. Control.Arrow.Kleisli m b c -> (b, d) -> m (c, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,1*C1(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbNEW ds_sbNEX ds1_sbNEY]
        let {
          d1_sbNEZ [Occ=OnceL] :: d_abN2u
          [LclId] =
              [ds1_sbNEY] \u []
                  case ds1_sbNEY of {
                    (,) _ [Occ=Dead] d2_sbNF2 [Occ=Once] -> d2_sbNF2;
                  }; } in
        let {
          sat_sbNFa [Occ=Once] :: c_abN2t -> m_XbN42 (c_abN2t, d_abN2u)
          [LclId] =
              [$dMonad_sbNEW d1_sbNEZ] \r [c1_sbNF8]
                  let {
                    sat_sbNF9 [Occ=Once] :: (c_abN2t, d_abN2u)
                    [LclId] =
                        CCCS (,)! [c1_sbNF8 d1_sbNEZ];
                  } in  GHC.Base.return $dMonad_sbNEW sat_sbNF9; } in
        let {
          sat_sbNF7 [Occ=Once] :: m_XbN42 c_abN2t
          [LclId] =
              [ds_sbNEX ds1_sbNEY] \u []
                  let {
                    sat_sbNF6 [Occ=Once] :: b_abN2s
                    [LclId] =
                        [ds1_sbNEY] \u []
                            case ds1_sbNEY of {
                              (,) b1_sbNF4 [Occ=Once] _ [Occ=Dead] -> b1_sbNF4;
                            };
                  } in  ds_sbNEX sat_sbNF6;
        } in  GHC.Base.>>= $dMonad_sbNEW sat_sbNF7 sat_sbNFa;

Control.Arrow.$fArrowKleisli5
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c. (b -> c) -> b -> m c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbNFb f_sbNFc eta_sbNFd]
        let {
          sat_sbNFe [Occ=Once] :: c_abN27
          [LclId] =
              [f_sbNFc eta_sbNFd] \u [] f_sbNFc eta_sbNFd;
        } in  GHC.Base.return $dMonad_sbNFb sat_sbNFe;

Control.Arrow.$fArrowPlusKleisli1
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall b c.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m b c -> b -> m c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))),1*U(A,A,A,1*C1(C1(U)))><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbNFf ds_sbNFg ds1_sbNFh x_sbNFi]
        let {
          sat_sbNFk [Occ=Once] :: m_abN1h c_abN1r
          [LclId] =
              [ds1_sbNFh x_sbNFi] \u [] ds1_sbNFh x_sbNFi; } in
        let {
          sat_sbNFj [Occ=Once] :: m_abN1h c_abN1r
          [LclId] =
              [ds_sbNFg x_sbNFi] \u [] ds_sbNFg x_sbNFi;
        } in  GHC.Base.mplus $dMonadPlus_sbNFf sat_sbNFj sat_sbNFk;

Control.Arrow.$fAlternativeArrowMonad_$capp
  :: forall b c. (b -> c, b) -> c
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),U)>,
 Unf=OtherCon []] =
    [] \r [ds_sbNFl]
        case ds_sbNFl of {
          (,) f_sbNFn [Occ=Once!] x_sbNFo [Occ=Once] -> f_sbNFn x_sbNFo;
        };

Control.Arrow.$fApplicativeArrowMonad5
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b. (a1 -> b) -> Control.Arrow.ArrowMonad a a1 -> a () b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNFp eta_sbNFq eta1_sbNFr]
        let {
          sat_sbNFt [Occ=Once] :: a_abMWW a1_abMX1 b_abMX2
          [LclId] =
              [$dArrow_sbNFp eta_sbNFq] \u []
                  Control.Arrow.arr $dArrow_sbNFp eta_sbNFq;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbNFp of sat_sbNFs {
            __DEFAULT -> Control.Category.. sat_sbNFs sat_sbNFt eta1_sbNFr;
          };

Control.Arrow.$fFunctorArrowMonad1
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b. a1 -> Control.Arrow.ArrowMonad a b -> a () a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNFu x_sbNFv eta_sbNFw]
        let {
          sat_sbNFA [Occ=Once] :: a_XbMZs b_abMXn a1_abMXm
          [LclId] =
              [$dArrow_sbNFu x_sbNFv] \u []
                  let {
                    sat_sbNFz [Occ=Once] :: b_abMXn -> a1_abMXm
                    [LclId] =
                        [x_sbNFv] \r [ds_sbNFy] x_sbNFv;
                  } in  Control.Arrow.arr $dArrow_sbNFu sat_sbNFz;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbNFu of sat_sbNFx {
            __DEFAULT -> Control.Category.. sat_sbNFx sat_sbNFA eta_sbNFw;
          };

Control.Arrow.$fFunctorArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     GHC.Base.Functor (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,A)>m] =
    [] \r [$dArrow_sbNFB]
        let {
          sat_sbNFD [Occ=Once]
            :: forall a b.
               a
               -> Control.Arrow.ArrowMonad a_XbMZA b
               -> Control.Arrow.ArrowMonad a_XbMZA a
          [LclId] =
              [$dArrow_sbNFB] \r [eta_B2 eta_B1]
                  Control.Arrow.$fFunctorArrowMonad1
                      $dArrow_sbNFB eta_B2 eta_B1; } in
        let {
          sat_sbNFC [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Control.Arrow.ArrowMonad a_XbMZA a
               -> Control.Arrow.ArrowMonad a_XbMZA b
          [LclId] =
              [$dArrow_sbNFB] \r [eta_B2 eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad5 $dArrow_sbNFB eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sbNFC sat_sbNFD];

Control.Arrow.$fAlternativeArrowMonad2
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a (a1 -> b)
     -> Control.Arrow.ArrowMonad a a1 -> a () b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNFE eta_sbNFF eta1_sbNFG]
        let {
          sat_sbNFJ [Occ=Once] :: a_abMVp () (a1_abMVM -> b_abMVN, a1_abMVM)
          [LclId] =
              [$dArrow_sbNFE eta_sbNFF eta1_sbNFG] \u []
                  Control.Arrow.&&& $dArrow_sbNFE eta_sbNFF eta1_sbNFG; } in
        let {
          sat_sbNFI [Occ=Once]
            :: a_abMVp (a1_abMVM -> b_abMVN, a1_abMVM) b_abMVN
          [LclId] =
              [$dArrow_sbNFE] \u []
                  Control.Arrow.arr
                      $dArrow_sbNFE Control.Arrow.$fAlternativeArrowMonad_$capp;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbNFE of sat_sbNFH {
            __DEFAULT -> Control.Category.. sat_sbNFH sat_sbNFI sat_sbNFJ;
          };

Control.Arrow.$fApplicativeArrowMonad6
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1. a1 -> a () a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNFK x_sbNFL]
        let {
          sat_sbNFN [Occ=Once] :: () -> a1_abMVy
          [LclId] =
              [x_sbNFL] \r [ds_sbNFM] x_sbNFL;
        } in  Control.Arrow.arr $dArrow_sbNFK sat_sbNFN;

Control.Arrow.$fApplicativeArrowMonad4
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b c.
     (a1 -> b -> c)
     -> Control.Arrow.ArrowMonad a a1
     -> Control.Arrow.ArrowMonad a b
     -> a () c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNFO f1_sbNFP x_sbNFQ]
        let {
          sat_sbNFR [Occ=Once]
            :: Control.Arrow.ArrowMonad a_XbMYk (b_abMWs -> c_abMWt)
          [LclId] =
              [$dArrow_sbNFO f1_sbNFP x_sbNFQ] \u []
                  Control.Arrow.$fApplicativeArrowMonad5
                      $dArrow_sbNFO f1_sbNFP x_sbNFQ;
        } in 
          Control.Arrow.$fAlternativeArrowMonad2 $dArrow_sbNFO sat_sbNFR;

Control.Arrow.$fApplicativeArrowMonad3 :: forall b a. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbNFS eta_sbNFT] eta_sbNFT;

Control.Arrow.$fApplicativeArrowMonad2
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a a1
     -> Control.Arrow.ArrowMonad a b -> a () b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNFU a2_sbNFV a3_sbNFW]
        let {
          sat_sbNFZ [Occ=Once]
            :: Control.Arrow.ArrowMonad a_XbMYj (b_abMWE -> b_abMWE)
          [LclId] =
              [$dArrow_sbNFU a2_sbNFV] \u []
                  let {
                    sat_sbNFY [Occ=Once] :: a_XbMYj a1_abMWD (b_abMWE -> b_abMWE)
                    [LclId] =
                        [$dArrow_sbNFU] \u []
                            Control.Arrow.arr
                                $dArrow_sbNFU Control.Arrow.$fApplicativeArrowMonad3;
                  } in 
                    case Control.Arrow.$p1Arrow $dArrow_sbNFU of sat_sbNFX {
                      __DEFAULT -> Control.Category.. sat_sbNFX sat_sbNFY a2_sbNFV;
                    };
        } in 
          Control.Arrow.$fAlternativeArrowMonad2
              $dArrow_sbNFU sat_sbNFZ a3_sbNFW;

Control.Arrow.$fApplicativeArrowMonad1
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a a1
     -> Control.Arrow.ArrowMonad a b -> a () a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNG0 x_sbNG1]
        let {
          sat_sbNG4 [Occ=Once]
            :: Control.Arrow.ArrowMonad a_XbMYi (b_abMWO -> a1_abMWN)
          [LclId] =
              [$dArrow_sbNG0 x_sbNG1] \u []
                  let {
                    sat_sbNG3 [Occ=Once] :: a_XbMYi a1_abMWN (b_abMWO -> a1_abMWN)
                    [LclId] =
                        [$dArrow_sbNG0] \u []
                            Control.Arrow.arr $dArrow_sbNG0 GHC.Base.const;
                  } in 
                    case Control.Arrow.$p1Arrow $dArrow_sbNG0 of sat_sbNG2 {
                      __DEFAULT -> Control.Category.. sat_sbNG2 sat_sbNG3 x_sbNG1;
                    };
        } in 
          Control.Arrow.$fAlternativeArrowMonad2 $dArrow_sbNG0 sat_sbNG4;

Control.Arrow.$fApplicativeArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     GHC.Base.Applicative (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>m] =
    [] \r [$dArrow_sbNG5]
        let {
          sat_sbNGb [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMYh a
               -> Control.Arrow.ArrowMonad a_XbMYh b
               -> Control.Arrow.ArrowMonad a_XbMYh a
          [LclId] =
              [$dArrow_sbNG5] \r [eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad1 $dArrow_sbNG5 eta_B1; } in
        let {
          sat_sbNGa [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMYh a
               -> Control.Arrow.ArrowMonad a_XbMYh b
               -> Control.Arrow.ArrowMonad a_XbMYh b
          [LclId] =
              [$dArrow_sbNG5] \r [eta_B2 eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad2
                      $dArrow_sbNG5 eta_B2 eta_B1; } in
        let {
          sat_sbNG9 [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Control.Arrow.ArrowMonad a_XbMYh a
               -> Control.Arrow.ArrowMonad a_XbMYh b
               -> Control.Arrow.ArrowMonad a_XbMYh c
          [LclId] =
              [$dArrow_sbNG5] \r [eta_B2 eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad4
                      $dArrow_sbNG5 eta_B2 eta_B1; } in
        let {
          sat_sbNG8 [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMYh (a -> b)
               -> Control.Arrow.ArrowMonad a_XbMYh a
               -> Control.Arrow.ArrowMonad a_XbMYh b
          [LclId] =
              [$dArrow_sbNG5] \r [eta_B2 eta_B1]
                  Control.Arrow.$fAlternativeArrowMonad2
                      $dArrow_sbNG5 eta_B2 eta_B1; } in
        let {
          sat_sbNG7 [Occ=Once]
            :: forall a. a -> Control.Arrow.ArrowMonad a_XbMYh a
          [LclId] =
              [$dArrow_sbNG5] \r [eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad6 $dArrow_sbNG5 eta_B1; } in
        let {
          sat_sbNG6 [Occ=Once]
            :: GHC.Base.Functor (Control.Arrow.ArrowMonad a_XbMYh)
          [LclId] =
              [$dArrow_sbNG5] \u []
                  Control.Arrow.$fFunctorArrowMonad $dArrow_sbNG5;
        } in 
          GHC.Base.C:Applicative [sat_sbNG6
                                  sat_sbNG7
                                  sat_sbNG8
                                  sat_sbNG9
                                  sat_sbNGa
                                  sat_sbNGb];

Control.Arrow.$fMonadArrowMonad_$c>>=
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a a1
     -> (a1 -> Control.Arrow.ArrowMonad a b)
     -> Control.Arrow.ArrowMonad a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(1*U(1*U(A,C(C1(U))),1*C1(U),A,A,A,A),1*U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbNGc eta_sbNGd eta1_sbNGe]
        case
            Control.Arrow.$p1ArrowApply $dArrowApply_sbNGc
        of
        $dArrow_sbNGf [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              case
                  Control.Arrow.$p1Arrow $dArrow_sbNGf
              of
              $dCategory_sbNGg [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
              { __DEFAULT ->
                    let {
                      sat_sbNGm [Occ=Once] :: a_abMU9 () (a_abMU9 () b_abMUj, ())
                      [LclId] =
                          [eta_sbNGd eta1_sbNGe $dArrow_sbNGf $dCategory_sbNGg] \u []
                              let {
                                sat_sbNGl [Occ=Once] :: a_abMU9 a1_abMUi (a_abMU9 () b_abMUj, ())
                                [LclId] =
                                    [eta1_sbNGe $dArrow_sbNGf] \u []
                                        let {
                                          sat_sbNGk [Occ=Once]
                                            :: a1_abMUi -> (a_abMU9 () b_abMUj, ())
                                          [LclId] =
                                              [eta1_sbNGe] \r [x_sbNGi]
                                                  let {
                                                    sat_sbNGj [Occ=Once] :: a_abMU9 () b_abMUj
                                                    [LclId] =
                                                        [eta1_sbNGe x_sbNGi] \u []
                                                            eta1_sbNGe x_sbNGi;
                                                  } in  (,) [sat_sbNGj GHC.Tuple.()];
                                        } in  Control.Arrow.arr $dArrow_sbNGf sat_sbNGk;
                              } in  Control.Category.. $dCategory_sbNGg sat_sbNGl eta_sbNGd; } in
                    let {
                      sat_sbNGh [Occ=Once] :: a_abMU9 (a_abMU9 () b_abMUj, ()) b_abMUj
                      [LclId] =
                          [$dArrowApply_sbNGc] \u [] Control.Arrow.app $dArrowApply_sbNGc;
                    } in  Control.Category.. $dCategory_sbNGg sat_sbNGh sat_sbNGm;
              };
        };

Control.Arrow.$fMonadArrowMonad_$cp1Monad
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     GHC.Base.Applicative (Control.Arrow.ArrowMonad a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)>m,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbNGn]
        let {
          sat_sbNGo [Occ=Once, Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
            :: Control.Arrow.Arrow a_abMU9
          [LclId] =
              [$dArrowApply_sbNGn] \u []
                  Control.Arrow.$p1ArrowApply $dArrowApply_sbNGn;
        } in  Control.Arrow.$fApplicativeArrowMonad sat_sbNGo;

Control.Arrow.$fMonadArrowMonad1
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     forall a1. a1 -> a () a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)L),1*U(1*U(A,1*C1(U),A,A,A,A),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbNGp eta_sbNGq]
        let {
          sat_sbNGt [Occ=Once] :: () -> a1_abMVa
          [LclId] =
              [eta_sbNGq] \r [ds_sbNGs] eta_sbNGq;
        } in 
          case Control.Arrow.$p1ArrowApply $dArrowApply_sbNGp of sat_sbNGr {
            __DEFAULT -> Control.Arrow.arr sat_sbNGr sat_sbNGt;
          };

Control.Arrow.$fMonadArrowMonad_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a a1
     -> Control.Arrow.ArrowMonad a b -> Control.Arrow.ArrowMonad a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(U(U(A,C(C1(U))),C(U),A,A,A,A),U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbNGu eta_sbNGv eta1_sbNGw]
        let {
          sat_sbNGy [Occ=Once]
            :: a1_abMV0 -> Control.Arrow.ArrowMonad a_XbMXu b_abMV1
          [LclId] =
              [eta1_sbNGw] \r [ds_sbNGx] eta1_sbNGw;
        } in 
          Control.Arrow.$fMonadArrowMonad_$c>>=
              $dArrowApply_sbNGu eta_sbNGv sat_sbNGy;

lvl_rbNC6
  :: forall (a1 :: * -> * -> *) a2.
     [GHC.Types.Char] -> Control.Arrow.ArrowMonad a1 a2
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sbNGz] GHC.Err.errorWithoutStackTrace eta_sbNGz;

Control.Arrow.$fMonadArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     GHC.Base.Monad (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),U)>m] =
    [] \r [$dArrowApply_sbNGA]
        let {
          sat_sbNGE [Occ=Once]
            :: forall a. a -> Control.Arrow.ArrowMonad a_XbMXv a
          [LclId] =
              [$dArrowApply_sbNGA] \r [eta_B1]
                  Control.Arrow.$fMonadArrowMonad1 $dArrowApply_sbNGA eta_B1; } in
        let {
          sat_sbNGD [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMXv a
               -> Control.Arrow.ArrowMonad a_XbMXv b
               -> Control.Arrow.ArrowMonad a_XbMXv b
          [LclId] =
              [$dArrowApply_sbNGA] \r [eta_B2 eta_B1]
                  Control.Arrow.$fMonadArrowMonad_$c>>
                      $dArrowApply_sbNGA eta_B2 eta_B1; } in
        let {
          sat_sbNGC [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMXv a
               -> (a -> Control.Arrow.ArrowMonad a_XbMXv b)
               -> Control.Arrow.ArrowMonad a_XbMXv b
          [LclId] =
              [$dArrowApply_sbNGA] \r [eta_B2 eta_B1]
                  Control.Arrow.$fMonadArrowMonad_$c>>=
                      $dArrowApply_sbNGA eta_B2 eta_B1; } in
        let {
          sat_sbNGB [Occ=Once]
            :: GHC.Base.Applicative (Control.Arrow.ArrowMonad a_XbMXv)
          [LclId] =
              [$dArrowApply_sbNGA] \u []
                  Control.Arrow.$fMonadArrowMonad_$cp1Monad $dArrowApply_sbNGA;
        } in 
          GHC.Base.C:Monad [sat_sbNGB
                            sat_sbNGC
                            sat_sbNGD
                            sat_sbNGE
                            lvl_rbNC6];

Control.Arrow.$fAlternativeArrowMonad3
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     forall a1. a () a1
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LS)L),1*U(1*U(A,1*U),A)>,
 Unf=OtherCon []] =
    [] \r [$dArrowPlus_sbNGF]
        case Control.Arrow.$p1ArrowPlus $dArrowPlus_sbNGF of sat_sbNGG {
          __DEFAULT -> Control.Arrow.zeroArrow sat_sbNGG;
        };

Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     GHC.Base.Applicative (Control.Arrow.ArrowMonad a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A),A)>m,
 Unf=OtherCon []] =
    [] \r [$dArrowPlus_sbNGH]
        let {
          sat_sbNGJ [Occ=Once, Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
            :: Control.Arrow.Arrow a_XbMWB
          [LclId] =
              [$dArrowPlus_sbNGH] \u []
                  case Control.Arrow.$p1ArrowPlus $dArrowPlus_sbNGH of sat_sbNGI {
                    __DEFAULT -> Control.Arrow.$p1ArrowZero sat_sbNGI;
                  };
        } in  Control.Arrow.$fApplicativeArrowMonad sat_sbNGJ;

Control.Arrow.$fAlternativeArrowMonad1 :: forall a. () -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sbNGK] [] [];

Control.Arrow.$fAlternativeArrowMonad_$csome
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     forall a1.
     Control.Arrow.ArrowMonad a a1 -> Control.Arrow.ArrowMonad a [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LC(C(S)))LLLLL)L)L),U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A),C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowPlus_sbNGL eta_sbNGM]
        let {
          some_v_sbNGN [Occ=LoopBreaker] :: a_XbMWE () [a1_abMTU]
          [LclId] =
              [$dArrowPlus_sbNGL eta_sbNGM some_v_sbNGN] \u []
                  case
                      Control.Arrow.$p1ArrowPlus $dArrowPlus_sbNGL
                  of
                  $dApplicative_sbNGO [Dmd=<S(S(S(LC(C(S)))LLLLL)L),1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,1*C1(C1(U))),A)>]
                  { __DEFAULT ->
                        case
                            Control.Arrow.$p1ArrowZero $dApplicative_sbNGO
                        of
                        $dApplicative1_sbNGP [Dmd=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,1*C1(C1(U)))>]
                        { __DEFAULT ->
                              let {
                                sat_sbNGX [Occ=Once]
                                  :: a_XbMWE () ([a1_abMTU] -> [a1_abMTU], [a1_abMTU])
                                [LclId] =
                                    [$dArrowPlus_sbNGL
                                     eta_sbNGM
                                     some_v_sbNGN
                                     $dApplicative1_sbNGP] \u []
                                        let {
                                          sat_sbNGW [Occ=Once] :: a_XbMWE () [a1_abMTU]
                                          [LclId] =
                                              [$dArrowPlus_sbNGL
                                               some_v_sbNGN
                                               $dApplicative1_sbNGP] \u []
                                                  let {
                                                    sat_sbNGV [Occ=Once] :: a_XbMWE () [a1_abMTU]
                                                    [LclId] =
                                                        [$dApplicative1_sbNGP] \u []
                                                            Control.Arrow.arr
                                                                $dApplicative1_sbNGP
                                                                Control.Arrow.$fAlternativeArrowMonad1;
                                                  } in 
                                                    Control.Arrow.<+>
                                                        $dArrowPlus_sbNGL
                                                        some_v_sbNGN
                                                        sat_sbNGV; } in
                                        let {
                                          sat_sbNGU [Occ=Once]
                                            :: a_XbMWE () ([a1_abMTU] -> [a1_abMTU])
                                          [LclId] =
                                              [eta_sbNGM $dApplicative1_sbNGP] \u []
                                                  let {
                                                    sat_sbNGT [Occ=Once]
                                                      :: a_XbMWE a1_abMTU ([a1_abMTU] -> [a1_abMTU])
                                                    [LclId] =
                                                        [$dApplicative1_sbNGP] \u []
                                                            Control.Arrow.arr
                                                                $dApplicative1_sbNGP GHC.Types.:;
                                                  } in 
                                                    case
                                                        Control.Arrow.$p1Arrow $dApplicative1_sbNGP
                                                    of
                                                    sat_sbNGS
                                                    { __DEFAULT ->
                                                          Control.Category..
                                                              sat_sbNGS sat_sbNGT eta_sbNGM;
                                                    };
                                        } in 
                                          Control.Arrow.&&&
                                              $dApplicative1_sbNGP sat_sbNGU sat_sbNGW; } in
                              let {
                                sat_sbNGR [Occ=Once]
                                  :: a_XbMWE ([a1_abMTU] -> [a1_abMTU], [a1_abMTU]) [a1_abMTU]
                                [LclId] =
                                    [$dApplicative1_sbNGP] \u []
                                        Control.Arrow.arr
                                            $dApplicative1_sbNGP
                                            Control.Arrow.$fAlternativeArrowMonad_$capp;
                              } in 
                                case Control.Arrow.$p1Arrow $dApplicative1_sbNGP of sat_sbNGQ {
                                  __DEFAULT -> Control.Category.. sat_sbNGQ sat_sbNGR sat_sbNGX;
                                };
                        };
                  };
        } in  some_v_sbNGN;

Control.Arrow.$fAlternativeArrowMonad_$cmany
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     forall a1.
     Control.Arrow.ArrowMonad a a1 -> Control.Arrow.ArrowMonad a [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A),C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowPlus_sbNGY eta_sbNGZ]
        let {
          many_v_sbNH0 [Occ=LoopBreaker] :: a_XbMWD () [a1_abMU2]
          [LclId] =
              [$dArrowPlus_sbNGY eta_sbNGZ many_v_sbNH0] \u []
                  let {
                    $dApplicative_sbNH1 [Occ=OnceL,
                                         Dmd=<L,1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)>]
                      :: Control.Arrow.ArrowZero a_XbMWD
                    [LclId] =
                        [$dArrowPlus_sbNGY] \s []
                            Control.Arrow.$p1ArrowPlus $dArrowPlus_sbNGY; } in
                  let {
                    $dApplicative1_sbNH2 [Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
                      :: Control.Arrow.Arrow a_XbMWD
                    [LclId] =
                        [$dApplicative_sbNH1] \u []
                            Control.Arrow.$p1ArrowZero $dApplicative_sbNH1; } in
                  let {
                    sat_sbNH7 [Occ=Once] :: a_XbMWD () [a1_abMU2]
                    [LclId] =
                        [$dApplicative1_sbNH2] \u []
                            Control.Arrow.arr
                                $dApplicative1_sbNH2 Control.Arrow.$fAlternativeArrowMonad1; } in
                  let {
                    sat_sbNH6 [Occ=Once] :: a_XbMWD () [a1_abMU2]
                    [LclId] =
                        [eta_sbNGZ many_v_sbNH0 $dApplicative1_sbNH2] \u []
                            let {
                              sat_sbNH5 [Occ=Once]
                                :: Control.Arrow.ArrowMonad a_XbMWD ([a1_abMU2] -> [a1_abMU2])
                              [LclId] =
                                  [eta_sbNGZ $dApplicative1_sbNH2] \u []
                                      let {
                                        sat_sbNH4 [Occ=Once]
                                          :: a_XbMWD a1_abMU2 ([a1_abMU2] -> [a1_abMU2])
                                        [LclId] =
                                            [$dApplicative1_sbNH2] \u []
                                                Control.Arrow.arr $dApplicative1_sbNH2 GHC.Types.:;
                                      } in 
                                        case
                                            Control.Arrow.$p1Arrow $dApplicative1_sbNH2
                                        of
                                        sat_sbNH3
                                        { __DEFAULT ->
                                              Control.Category.. sat_sbNH3 sat_sbNH4 eta_sbNGZ;
                                        };
                            } in 
                              Control.Arrow.$fAlternativeArrowMonad2
                                  $dApplicative1_sbNH2 sat_sbNH5 many_v_sbNH0;
                  } in  Control.Arrow.<+> $dArrowPlus_sbNGY sat_sbNH6 sat_sbNH7;
        } in  many_v_sbNH0;

Control.Arrow.$fAlternativeArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     GHC.Base.Alternative (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),1*U),C(C1(U)))>m] =
    [] \r [$dArrowPlus_sbNH8]
        let {
          sat_sbNHf [Occ=Once]
            :: forall a.
               Control.Arrow.ArrowMonad a_XbMWC a
               -> Control.Arrow.ArrowMonad a_XbMWC [a]
          [LclId] =
              [$dArrowPlus_sbNH8] \r [eta_B1]
                  Control.Arrow.$fAlternativeArrowMonad_$cmany
                      $dArrowPlus_sbNH8 eta_B1; } in
        let {
          sat_sbNHe [Occ=Once]
            :: forall a.
               Control.Arrow.ArrowMonad a_XbMWC a
               -> Control.Arrow.ArrowMonad a_XbMWC [a]
          [LclId] =
              [$dArrowPlus_sbNH8] \r [eta_B1]
                  Control.Arrow.$fAlternativeArrowMonad_$csome
                      $dArrowPlus_sbNH8 eta_B1; } in
        let {
          sat_sbNHd [Occ=Once]
            :: forall a.
               Control.Arrow.ArrowMonad a_XbMWC a
               -> Control.Arrow.ArrowMonad a_XbMWC a
               -> Control.Arrow.ArrowMonad a_XbMWC a
          [LclId] =
              [$dArrowPlus_sbNH8] \r [ds_sbNHb ds1_sbNHc]
                  Control.Arrow.<+> $dArrowPlus_sbNH8 ds_sbNHb ds1_sbNHc; } in
        let {
          sat_sbNHa [Occ=Once]
            :: forall a. Control.Arrow.ArrowMonad a_XbMWC a
          [LclId] =
              [$dArrowPlus_sbNH8] \u []
                  Control.Arrow.$fAlternativeArrowMonad3 $dArrowPlus_sbNH8; } in
        let {
          sat_sbNH9 [Occ=Once]
            :: GHC.Base.Applicative (Control.Arrow.ArrowMonad a_XbMWC)
          [LclId] =
              [$dArrowPlus_sbNH8] \u []
                  Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative
                      $dArrowPlus_sbNH8;
        } in 
          GHC.Base.C:Alternative [sat_sbNH9
                                  sat_sbNHa
                                  sat_sbNHd
                                  sat_sbNHe
                                  sat_sbNHf];

Control.Arrow.$fMonadPlusArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     (Control.Arrow.ArrowApply a, Control.Arrow.ArrowPlus a) =>
     GHC.Base.MonadPlus (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),U)><L,U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),U),C(C1(U)))>m] =
    [] \r [$dArrowApply_sbNHg $dArrowPlus_sbNHh]
        let {
          sat_sbNHn [Occ=Once]
            :: forall a.
               Control.Arrow.ArrowMonad a_abMSU a
               -> Control.Arrow.ArrowMonad a_abMSU a
               -> Control.Arrow.ArrowMonad a_abMSU a
          [LclId] =
              [$dArrowPlus_sbNHh] \r [ds_sbNHl ds1_sbNHm]
                  Control.Arrow.<+> $dArrowPlus_sbNHh ds_sbNHl ds1_sbNHm; } in
        let {
          sat_sbNHk [Occ=Once]
            :: forall a. Control.Arrow.ArrowMonad a_abMSU a
          [LclId] =
              [$dArrowPlus_sbNHh] \u []
                  Control.Arrow.$fAlternativeArrowMonad3 $dArrowPlus_sbNHh; } in
        let {
          sat_sbNHj [Occ=Once]
            :: GHC.Base.Monad (Control.Arrow.ArrowMonad a_abMSU)
          [LclId] =
              [$dArrowApply_sbNHg] \u []
                  Control.Arrow.$fMonadArrowMonad $dArrowApply_sbNHg; } in
        let {
          sat_sbNHi [Occ=Once]
            :: GHC.Base.Alternative (Control.Arrow.ArrowMonad a_abMSU)
          [LclId] =
              [$dArrowPlus_sbNHh] \u []
                  Control.Arrow.$fAlternativeArrowMonad $dArrowPlus_sbNHh;
        } in 
          GHC.Base.C:MonadPlus [sat_sbNHi sat_sbNHj sat_sbNHk sat_sbNHn];

Control.Arrow.$fArrowLoop(->)_$cloop
  :: forall b d c. ((b, d) -> (c, d)) -> b -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U(U,U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sbNHo b1_sbNHp]
        let {
          ds_sbNHq [Occ=LoopBreaker] :: (c_abMSD, d_abMSC)
          [LclId] =
              [f_sbNHo b1_sbNHp ds_sbNHq] \u []
                  let {
                    sat_sbNHu [Occ=OnceL] :: d_abMSC
                    [LclId] =
                        [ds_sbNHq] \u []
                            case ds_sbNHq of {
                              (,) _ [Occ=Dead] d1_sbNHt [Occ=Once] -> d1_sbNHt;
                            }; } in
                  let {
                    sat_sbNHv [Occ=Once] :: (b_abMSB, d_abMSC)
                    [LclId] =
                        CCCS (,)! [b1_sbNHp sat_sbNHu];
                  } in  f_sbNHo sat_sbNHv;
        } in 
          case ds_sbNHq of {
            (,) c1_sbNHx [Occ=Once] _ [Occ=Dead] -> c1_sbNHx;
          };

Control.Arrow.$fArrowLoopKleisli1
  :: forall (m :: * -> *).
     Control.Monad.Fix.MonadFix m =>
     forall b d c. Control.Arrow.Kleisli m (b, d) (c, d) -> b -> m c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S))LLL)L),U(1*U(A,1*C1(C1(U)),A,C(U),A),1*C1(U))><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadFix_sbNHz eta_sbNHA eta1_sbNHB]
        case
            Control.Monad.Fix.$p1MonadFix $dMonadFix_sbNHz
        of
        $dMonad_sbNHC [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
        { __DEFAULT ->
              let {
                sat_sbNHN [Occ=Once] :: (c_abMRB, d_abMRA) -> m_abMRq c_abMRB
                [LclId] =
                    [$dMonad_sbNHC] \r [x1_sbNHI]
                        let {
                          sat_sbNHM [Occ=Once] :: c_abMRB
                          [LclId] =
                              [x1_sbNHI] \u []
                                  case x1_sbNHI of {
                                    (,) x_sbNHK [Occ=Once] _ [Occ=Dead] -> x_sbNHK;
                                  };
                        } in  GHC.Base.return $dMonad_sbNHC sat_sbNHM; } in
              let {
                sat_sbNHH [Occ=Once] :: m_abMRq (c_abMRB, d_abMRA)
                [LclId] =
                    [$dMonadFix_sbNHz eta_sbNHA eta1_sbNHB] \u []
                        let {
                          sat_sbNHG [Occ=Once]
                            :: (c_abMRB, d_abMRA) -> m_abMRq (c_abMRB, d_abMRA)
                          [LclId] =
                              [eta_sbNHA eta1_sbNHB] \r [y_sbNHD]
                                  let {
                                    sat_sbNHE [Occ=Once] :: d_abMRA
                                    [LclId] =
                                        [y_sbNHD] \u [] Data.Tuple.snd y_sbNHD; } in
                                  let {
                                    sat_sbNHF [Occ=Once] :: (b_abMRz, d_abMRA)
                                    [LclId] =
                                        CCCS (,)! [eta1_sbNHB sat_sbNHE];
                                  } in  eta_sbNHA sat_sbNHF;
                        } in  Control.Monad.Fix.mfix $dMonadFix_sbNHz sat_sbNHG;
              } in  GHC.Base.>>= $dMonad_sbNHC sat_sbNHH sat_sbNHN;
        };

lvl1_rbNC7 :: forall d. Data.Either.Either d d -> d
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbNHO]
        case ds_sbNHO of {
          Data.Either.Left x_sbNHQ [Occ=Once] -> x_sbNHQ;
          Data.Either.Right y_sbNHR [Occ=Once] -> y_sbNHR;
        };

Control.Arrow.$dm|||
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b d c. a b d -> a c d -> a (Data.Either.Either b c) d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)LLLL),U(1*U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A),A,A,1*C1(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowChoice_sbNHS eta_sbNHT eta1_sbNHU]
        case
            Control.Arrow.$p1ArrowChoice $dArrowChoice_sbNHS
        of
        $dArrow_sbNHV [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sbNHY [Occ=Once]
                  :: a_abMu0 (Data.Either.Either b_abMQL c_abMQN) (Data.Either.Either
                                                                     d_abMQM d_abMQM)
                [LclId] =
                    [$dArrowChoice_sbNHS eta_sbNHT eta1_sbNHU] \u []
                        Control.Arrow.+++ $dArrowChoice_sbNHS eta_sbNHT eta1_sbNHU; } in
              let {
                sat_sbNHX [Occ=Once]
                  :: a_abMu0 (Data.Either.Either d_abMQM d_abMQM) d_abMQM
                [LclId] =
                    [$dArrow_sbNHV] \u [] Control.Arrow.arr $dArrow_sbNHV lvl1_rbNC7;
              } in 
                case Control.Arrow.$p1Arrow $dArrow_sbNHV of sat_sbNHW {
                  __DEFAULT -> Control.Category.. sat_sbNHW sat_sbNHX sat_sbNHY;
                };
        };

mirror_rbNC8
  :: forall x y. Data.Either.Either x y -> Data.Either.Either y x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbNHZ]
        case ds_sbNHZ of {
          Data.Either.Left x1_sbNI1 [Occ=Once] ->
              Data.Either.Right [x1_sbNI1];
          Data.Either.Right y1_sbNI2 [Occ=Once] ->
              Data.Either.Left [y1_sbNI2];
        };

Control.Arrow.$dm+++
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c b' c'.
     a b c
     -> a b' c' -> a (Data.Either.Either b b') (Data.Either.Either c c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)LLLL),U(1*U(1*U(A,C(C1(U))),C(U),A,A,A,A),C(U),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowChoice_sbNI3 eta_sbNI4 eta1_sbNI5]
        case
            Control.Arrow.$p1ArrowChoice $dArrowChoice_sbNI3
        of
        $dArrow_sbNI6 [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),C(U),A,A,A,A)>]
        { __DEFAULT ->
              case
                  Control.Arrow.$p1Arrow $dArrow_sbNI6
              of
              $dCategory_sbNI7 [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
              { __DEFAULT ->
                    let {
                      sat_sbNId [Occ=Once]
                        :: a_abMu0 (Data.Either.Either
                                      b_abMPE b'_abMPG) (Data.Either.Either c'_abMPH c_abMPF)
                      [LclId] =
                          [$dArrowChoice_sbNI3
                           eta_sbNI4
                           eta1_sbNI5
                           $dArrow_sbNI6
                           $dCategory_sbNI7] \u []
                              let {
                                sat_sbNIc [Occ=Once]
                                  :: a_abMu0 (Data.Either.Either
                                                b_abMPE b'_abMPG) (Data.Either.Either
                                                                     b'_abMPG c_abMPF)
                                [LclId] =
                                    [$dArrowChoice_sbNI3
                                     eta_sbNI4
                                     $dArrow_sbNI6
                                     $dCategory_sbNI7] \u []
                                        let {
                                          sat_sbNIb [Occ=Once]
                                            :: a_abMu0 (Data.Either.Either
                                                          b_abMPE b'_abMPG) (Data.Either.Either
                                                                               c_abMPF b'_abMPG)
                                          [LclId] =
                                              [$dArrowChoice_sbNI3 eta_sbNI4] \u []
                                                  Control.Arrow.left
                                                      $dArrowChoice_sbNI3 eta_sbNI4; } in
                                        let {
                                          sat_sbNIa [Occ=Once]
                                            :: a_abMu0 (Data.Either.Either
                                                          c_abMPF b'_abMPG) (Data.Either.Either
                                                                               b'_abMPG c_abMPF)
                                          [LclId] =
                                              [$dArrow_sbNI6] \u []
                                                  Control.Arrow.arr $dArrow_sbNI6 mirror_rbNC8;
                                        } in 
                                          Control.Category..
                                              $dCategory_sbNI7 sat_sbNIa sat_sbNIb; } in
                              let {
                                sat_sbNI9 [Occ=Once]
                                  :: a_abMu0 (Data.Either.Either
                                                b'_abMPG c_abMPF) (Data.Either.Either
                                                                     c'_abMPH c_abMPF)
                                [LclId] =
                                    [$dArrowChoice_sbNI3 eta1_sbNI5] \u []
                                        Control.Arrow.left $dArrowChoice_sbNI3 eta1_sbNI5;
                              } in  Control.Category.. $dCategory_sbNI7 sat_sbNI9 sat_sbNIc; } in
                    let {
                      sat_sbNI8 [Occ=Once]
                        :: a_abMu0 (Data.Either.Either
                                      c'_abMPH c_abMPF) (Data.Either.Either c_abMPF c'_abMPH)
                      [LclId] =
                          [$dArrow_sbNI6] \u [] Control.Arrow.arr $dArrow_sbNI6 mirror_rbNC8;
                    } in  Control.Category.. $dCategory_sbNI7 sat_sbNI8 sat_sbNId;
              };
        };

Control.Arrow.$dmright
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c d.
     a b c -> a (Data.Either.Either d b) (Data.Either.Either d c)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),U(1*U(1*U(1*U,A),A,A,A,A,A),A,A,1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dArrowChoice_sbNIe]
        let {
          sat_sbNIh [Occ=Once] :: a_abMu0 d_abMPp d_abMPp
          [LclId] =
              [$dArrowChoice_sbNIe] \u []
                  case
                      Control.Arrow.$p1ArrowChoice $dArrowChoice_sbNIe
                  of
                  sat_sbNIf
                  { __DEFAULT ->
                        case Control.Arrow.$p1Arrow sat_sbNIf of sat_sbNIg {
                          __DEFAULT -> Control.Category.id sat_sbNIg;
                        };
                  };
        } in  Control.Arrow.+++ $dArrowChoice_sbNIe sat_sbNIh;

Control.Arrow.$dmleft
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c d.
     a b c -> a (Data.Either.Either b d) (Data.Either.Either c d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))L),U(1*U(1*U(1*U,A),A,A,A,A,A),A,A,1*C1(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowChoice_sbNIi eta_sbNIj]
        let {
          sat_sbNIm [Occ=Once] :: a_abMu0 d_abMP8 d_abMP8
          [LclId] =
              [$dArrowChoice_sbNIi] \u []
                  case
                      Control.Arrow.$p1ArrowChoice $dArrowChoice_sbNIi
                  of
                  sat_sbNIk
                  { __DEFAULT ->
                        case Control.Arrow.$p1Arrow sat_sbNIk of sat_sbNIl {
                          __DEFAULT -> Control.Category.id sat_sbNIl;
                        };
                  };
        } in  Control.Arrow.+++ $dArrowChoice_sbNIi eta_sbNIj sat_sbNIm;

lvl2_rbNC9 :: forall b. b -> (b, b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [b1_sbNIn] (,) [b1_sbNIn b1_sbNIn];

Control.Arrow.$dm&&&
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c c'. a b c -> a b c' -> a b (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,1*C1(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNIo eta_sbNIp eta1_sbNIq]
        let {
          sat_sbNIt [Occ=Once] :: a_abMuz b_abMOE (b_abMOE, b_abMOE)
          [LclId] =
              [$dArrow_sbNIo] \u []
                  Control.Arrow.arr $dArrow_sbNIo lvl2_rbNC9; } in
        let {
          sat_sbNIs [Occ=Once]
            :: a_abMuz (b_abMOE, b_abMOE) (c_abMOF, c'_abMOG)
          [LclId] =
              [$dArrow_sbNIo eta_sbNIp eta1_sbNIq] \u []
                  Control.Arrow.*** $dArrow_sbNIo eta_sbNIp eta1_sbNIq;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbNIo of sat_sbNIr {
            __DEFAULT -> Control.Category.. sat_sbNIr sat_sbNIs sat_sbNIt;
          };

swap_rbNCa :: forall b a. (b, a) -> (a, b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sbNIu]
        let {
          sat_sbNIC [Occ=Once] :: b_abMNN
          [LclId] =
              [ds_sbNIu] \u []
                  case ds_sbNIu of {
                    (,) x_sbNIA [Occ=Once] _ [Occ=Dead] -> x_sbNIA;
                  }; } in
        let {
          sat_sbNIy [Occ=Once] :: a_abMNM
          [LclId] =
              [ds_sbNIu] \u []
                  case ds_sbNIu of {
                    (,) _ [Occ=Dead] y_sbNIx [Occ=Once] -> y_sbNIx;
                  };
        } in  (,) [sat_sbNIy sat_sbNIC];

Control.Arrow.$dm***
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c b' c'. a b c -> a b' c' -> a (b, b') (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),C(U),C(U),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNID eta_sbNIE eta1_sbNIF]
        case
            Control.Arrow.$p1Arrow $dArrow_sbNID
        of
        $dCategory_sbNIG [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
        { __DEFAULT ->
              let {
                sat_sbNIM [Occ=Once]
                  :: a_abMuz (b_abMNy, b'_abMNA) (c'_abMNB, c_abMNz)
                [LclId] =
                    [$dArrow_sbNID eta_sbNIE eta1_sbNIF $dCategory_sbNIG] \u []
                        let {
                          sat_sbNIL [Occ=Once]
                            :: a_abMuz (b_abMNy, b'_abMNA) (b'_abMNA, c_abMNz)
                          [LclId] =
                              [$dArrow_sbNID eta_sbNIE $dCategory_sbNIG] \u []
                                  let {
                                    sat_sbNIK [Occ=Once]
                                      :: a_abMuz (b_abMNy, b'_abMNA) (c_abMNz, b'_abMNA)
                                    [LclId] =
                                        [$dArrow_sbNID eta_sbNIE] \u []
                                            Control.Arrow.first $dArrow_sbNID eta_sbNIE; } in
                                  let {
                                    sat_sbNIJ [Occ=Once]
                                      :: a_abMuz (c_abMNz, b'_abMNA) (b'_abMNA, c_abMNz)
                                    [LclId] =
                                        [$dArrow_sbNID] \u []
                                            Control.Arrow.arr $dArrow_sbNID swap_rbNCa;
                                  } in 
                                    Control.Category.. $dCategory_sbNIG sat_sbNIJ sat_sbNIK; } in
                        let {
                          sat_sbNII [Occ=Once]
                            :: a_abMuz (b'_abMNA, c_abMNz) (c'_abMNB, c_abMNz)
                          [LclId] =
                              [$dArrow_sbNID eta1_sbNIF] \u []
                                  Control.Arrow.first $dArrow_sbNID eta1_sbNIF;
                        } in  Control.Category.. $dCategory_sbNIG sat_sbNII sat_sbNIL; } in
              let {
                sat_sbNIH [Occ=Once]
                  :: a_abMuz (c'_abMNB, c_abMNz) (c_abMNz, c'_abMNB)
                [LclId] =
                    [$dArrow_sbNID] \u [] Control.Arrow.arr $dArrow_sbNID swap_rbNCa;
              } in  Control.Category.. $dCategory_sbNIG sat_sbNIH sat_sbNIM;
        };

Control.Arrow.$fArrowKleisli2
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c b' c'.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m b' c' -> (b, b') -> m (c, c')
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(U)><L,C(U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbNIN f_sbNIO g_sbNIP eta_sbNIQ]
        let {
          sat_sbNJg [Occ=Once]
            :: (c'_abN3d, c_abN3b) -> m_XbN5E (c_abN3b, c'_abN3d)
          [LclId] =
              [$dMonad_sbNIN] \r [eta1_sbNJ6]
                  let {
                    sat_sbNJe [Occ=Once] :: c'_abN3d
                    [LclId] =
                        [eta1_sbNJ6] \u []
                            case eta1_sbNJ6 of {
                              (,) x_sbNJc [Occ=Once] _ [Occ=Dead] -> x_sbNJc;
                            }; } in
                  let {
                    sat_sbNJa [Occ=Once] :: c_abN3b
                    [LclId] =
                        [eta1_sbNJ6] \u []
                            case eta1_sbNJ6 of {
                              (,) _ [Occ=Dead] y_sbNJ9 [Occ=Once] -> y_sbNJ9;
                            }; } in
                  let {
                    sat_sbNJf [Occ=Once] :: (c_abN3b, c'_abN3d)
                    [LclId] =
                        CCCS (,)! [sat_sbNJa sat_sbNJe];
                  } in  GHC.Base.return $dMonad_sbNIN sat_sbNJf; } in
        let {
          sat_sbNJ5 [Occ=Once] :: m_XbN5E (c'_abN3d, c_abN3b)
          [LclId] =
              [$dMonad_sbNIN f_sbNIO g_sbNIP eta_sbNIQ] \u []
                  let {
                    sat_sbNJ4 [Occ=Once]
                      :: (b'_abN3c, c_abN3b) -> m_XbN5E (c'_abN3d, c_abN3b)
                    [LclId] =
                        [$dMonad_sbNIN g_sbNIP] \r [eta_B1]
                            Control.Arrow.$fArrowKleisli3 $dMonad_sbNIN g_sbNIP eta_B1; } in
                  let {
                    sat_sbNJ3 [Occ=Once] :: m_XbN5E (b'_abN3c, c_abN3b)
                    [LclId] =
                        [$dMonad_sbNIN f_sbNIO eta_sbNIQ] \u []
                            let {
                              sat_sbNJ2 [Occ=Once]
                                :: (c_abN3b, b'_abN3c) -> m_XbN5E (b'_abN3c, c_abN3b)
                              [LclId] =
                                  [$dMonad_sbNIN] \r [eta1_sbNIS]
                                      let {
                                        sat_sbNJ0 [Occ=Once] :: c_abN3b
                                        [LclId] =
                                            [eta1_sbNIS] \u []
                                                case eta1_sbNIS of {
                                                  (,) x_sbNIY [Occ=Once] _ [Occ=Dead] -> x_sbNIY;
                                                }; } in
                                      let {
                                        sat_sbNIW [Occ=Once] :: b'_abN3c
                                        [LclId] =
                                            [eta1_sbNIS] \u []
                                                case eta1_sbNIS of {
                                                  (,) _ [Occ=Dead] y_sbNIV [Occ=Once] -> y_sbNIV;
                                                }; } in
                                      let {
                                        sat_sbNJ1 [Occ=Once] :: (b'_abN3c, c_abN3b)
                                        [LclId] =
                                            CCCS (,)! [sat_sbNIW sat_sbNJ0];
                                      } in  GHC.Base.return $dMonad_sbNIN sat_sbNJ1; } in
                            let {
                              sat_sbNIR [Occ=Once] :: m_XbN5E (c_abN3b, b'_abN3c)
                              [LclId] =
                                  [$dMonad_sbNIN f_sbNIO eta_sbNIQ] \u []
                                      Control.Arrow.$fArrowKleisli3 $dMonad_sbNIN f_sbNIO eta_sbNIQ;
                            } in  GHC.Base.>>= $dMonad_sbNIN sat_sbNIR sat_sbNJ2;
                  } in  GHC.Base.>>= $dMonad_sbNIN sat_sbNJ3 sat_sbNJ4;
        } in  GHC.Base.>>= $dMonad_sbNIN sat_sbNJ5 sat_sbNJg;

Control.Arrow.$fArrowKleisli1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c c'.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m b c' -> b -> m (c, c')
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(U)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbNJh f_sbNJi g_sbNJj eta_sbNJk]
        let {
          sat_sbNJn [Occ=Once]
            :: (b_abN3o, b_abN3o) -> m_XbN5D (c_abN3p, c'_abN3q)
          [LclId] =
              [$dMonad_sbNJh f_sbNJi g_sbNJj] \r [eta_B1]
                  Control.Arrow.$fArrowKleisli2
                      $dMonad_sbNJh f_sbNJi g_sbNJj eta_B1; } in
        let {
          sat_sbNJm [Occ=Once] :: m_XbN5D (b_abN3o, b_abN3o)
          [LclId] =
              [$dMonad_sbNJh eta_sbNJk] \u []
                  let {
                    sat_sbNJl [Occ=Once] :: (b_abN3o, b_abN3o)
                    [LclId] =
                        CCCS (,)! [eta_sbNJk eta_sbNJk];
                  } in  GHC.Base.return $dMonad_sbNJh sat_sbNJl;
        } in  GHC.Base.>>= $dMonad_sbNJh sat_sbNJm sat_sbNJn;

Control.Arrow.$fArrowKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     Control.Arrow.Arrow (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,U,A)>m] =
    [] \r [$dMonad_sbNJo]
        let {
          sat_sbNJu [Occ=Once]
            :: forall b c c'.
               Control.Arrow.Kleisli m_XbN5C b c
               -> Control.Arrow.Kleisli m_XbN5C b c'
               -> Control.Arrow.Kleisli m_XbN5C b (c, c')
          [LclId] =
              [$dMonad_sbNJo] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli1
                      $dMonad_sbNJo eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbNJt [Occ=Once]
            :: forall b c b' c'.
               Control.Arrow.Kleisli m_XbN5C b c
               -> Control.Arrow.Kleisli m_XbN5C b' c'
               -> Control.Arrow.Kleisli m_XbN5C (b, b') (c, c')
          [LclId] =
              [$dMonad_sbNJo] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli2
                      $dMonad_sbNJo eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbNJs [Occ=Once]
            :: forall b c d.
               Control.Arrow.Kleisli m_XbN5C b c
               -> Control.Arrow.Kleisli m_XbN5C (d, b) (d, c)
          [LclId] =
              [$dMonad_sbNJo] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli4 $dMonad_sbNJo eta_B2 eta_B1; } in
        let {
          sat_sbNJr [Occ=Once]
            :: forall b c d.
               Control.Arrow.Kleisli m_XbN5C b c
               -> Control.Arrow.Kleisli m_XbN5C (b, d) (c, d)
          [LclId] =
              [$dMonad_sbNJo] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli3 $dMonad_sbNJo eta_B2 eta_B1; } in
        let {
          sat_sbNJq [Occ=Once]
            :: forall b c. (b -> c) -> Control.Arrow.Kleisli m_XbN5C b c
          [LclId] =
              [$dMonad_sbNJo] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli5 $dMonad_sbNJo eta_B2 eta_B1; } in
        let {
          sat_sbNJp [Occ=Once]
            :: Control.Category.Category (Control.Arrow.Kleisli m_XbN5C)
          [LclId] =
              [$dMonad_sbNJo] \u []
                  Control.Arrow.$fCategoryTYPEKleisli $dMonad_sbNJo;
        } in 
          Control.Arrow.C:Arrow [sat_sbNJp
                                 sat_sbNJq
                                 sat_sbNJr
                                 sat_sbNJs
                                 sat_sbNJt
                                 sat_sbNJu];

Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop
  :: forall (m :: * -> *).
     Control.Monad.Fix.MonadFix m =>
     Control.Arrow.Arrow (Control.Arrow.Kleisli m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,U,A),A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadFix_sbNJv]
        let {
          sat_sbNJw [Occ=Once, Dmd=<L,U(A,C(C1(U)),A,U,A)>]
            :: GHC.Base.Monad m_XbMVo
          [LclId] =
              [$dMonadFix_sbNJv] \u []
                  Control.Monad.Fix.$p1MonadFix $dMonadFix_sbNJv;
        } in  Control.Arrow.$fArrowKleisli sat_sbNJw;

Control.Arrow.$fArrowLoopKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     Control.Monad.Fix.MonadFix m =>
     Control.Arrow.ArrowLoop (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U)),A,U,A),C(U))>m] =
    [] \r [$dMonadFix_sbNJx]
        let {
          sat_sbNJz [Occ=Once]
            :: forall b d c.
               Control.Arrow.Kleisli m_XbMVp (b, d) (c, d)
               -> Control.Arrow.Kleisli m_XbMVp b c
          [LclId] =
              [$dMonadFix_sbNJx] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowLoopKleisli1
                      $dMonadFix_sbNJx eta_B2 eta_B1; } in
        let {
          sat_sbNJy [Occ=Once]
            :: Control.Arrow.Arrow (Control.Arrow.Kleisli m_XbMVp)
          [LclId] =
              [$dMonadFix_sbNJx] \u []
                  Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop $dMonadFix_sbNJx;
        } in  Control.Arrow.C:ArrowLoop [sat_sbNJy sat_sbNJz];

lvl3_rbNCb
  :: forall (m :: * -> *) b c.
     (Control.Arrow.Kleisli m b c, b) -> m c
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),U)>,
 Unf=OtherCon []] =
    [] \r [ds_sbNJA]
        case ds_sbNJA of {
          (,) ds1_sbNJC [Occ=Once] x_sbNJD [Occ=Once] -> ds1_sbNJC x_sbNJD;
        };

Control.Arrow.$fArrowApplyKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     Control.Arrow.ArrowApply (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,U,A)>m] =
    [] \r [$dMonad_sbNJE]
        let {
          sat_sbNJF [Occ=Once]
            :: Control.Arrow.Arrow (Control.Arrow.Kleisli m_XbN1f)
          [LclId] =
              [$dMonad_sbNJE] \u [] Control.Arrow.$fArrowKleisli $dMonad_sbNJE;
        } in  Control.Arrow.C:ArrowApply [sat_sbNJF lvl3_rbNCb];

Control.Arrow.$fArrowChoiceKleisli1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c b' c'.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m b' c'
     -> Data.Either.Either b b'
     -> m (Data.Either.Either c c')
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbNJG f_sbNJH g_sbNJI eta_sbNJJ]
        case eta_sbNJJ of {
          Data.Either.Left x_sbNJL [Occ=Once] ->
              let {
                sat_sbNJP [Occ=Once]
                  :: c_abMYX -> m_XbN1R (Data.Either.Either c_abMYX c'_abMYZ)
                [LclId] =
                    [$dMonad_sbNJG] \r [eta1_sbNJN]
                        let {
                          sat_sbNJO [Occ=Once] :: Data.Either.Either c_abMYX c'_abMYZ
                          [LclId] =
                              CCCS Data.Either.Left! [eta1_sbNJN];
                        } in  GHC.Base.return $dMonad_sbNJG sat_sbNJO; } in
              let {
                sat_sbNJM [Occ=Once] :: m_XbN1R c_abMYX
                [LclId] =
                    [f_sbNJH x_sbNJL] \u [] f_sbNJH x_sbNJL;
              } in  GHC.Base.>>= $dMonad_sbNJG sat_sbNJM sat_sbNJP;
          Data.Either.Right y_sbNJQ [Occ=Once] ->
              let {
                sat_sbNJU [Occ=Once]
                  :: c'_abMYZ -> m_XbN1R (Data.Either.Either c_abMYX c'_abMYZ)
                [LclId] =
                    [$dMonad_sbNJG] \r [eta1_sbNJS]
                        let {
                          sat_sbNJT [Occ=Once] :: Data.Either.Either c_abMYX c'_abMYZ
                          [LclId] =
                              CCCS Data.Either.Right! [eta1_sbNJS];
                        } in  GHC.Base.return $dMonad_sbNJG sat_sbNJT; } in
              let {
                sat_sbNJR [Occ=Once] :: m_XbN1R c'_abMYZ
                [LclId] =
                    [g_sbNJI y_sbNJQ] \u [] g_sbNJI y_sbNJQ;
              } in  GHC.Base.>>= $dMonad_sbNJG sat_sbNJR sat_sbNJU;
        };

Control.Arrow.$fArrowChoiceKleisli3
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c d.
     Control.Arrow.Kleisli m b c
     -> Data.Either.Either b d -> m (Data.Either.Either c d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbNJV f_sbNJW eta_sbNJX]
        let {
          sat_sbNJZ [Occ=Once]
            :: Control.Arrow.Kleisli m_XbN1Q d_abMYe d_abMYe
          [LclId] =
              [$dMonad_sbNJV] \r [eta1_sbNJY]
                  GHC.Base.return $dMonad_sbNJV eta1_sbNJY;
        } in 
          Control.Arrow.$fArrowChoiceKleisli1
              $dMonad_sbNJV f_sbNJW sat_sbNJZ eta_sbNJX;

Control.Arrow.$fArrowChoiceKleisli2
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c d.
     Control.Arrow.Kleisli m b c
     -> Data.Either.Either d b -> m (Data.Either.Either d c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbNK0 f_sbNK1 eta_sbNK2]
        let {
          sat_sbNK4 [Occ=Once]
            :: Control.Arrow.Kleisli m_XbN1P d_abMYB d_abMYB
          [LclId] =
              [$dMonad_sbNK0] \r [eta1_sbNK3]
                  GHC.Base.return $dMonad_sbNK0 eta1_sbNK3;
        } in 
          Control.Arrow.$fArrowChoiceKleisli1
              $dMonad_sbNK0 sat_sbNK4 f_sbNK1 eta_sbNK2;

lvl4_rbNCc
  :: forall (m :: * -> *) b d c.
     Control.Arrow.Kleisli m b d
     -> Control.Arrow.Kleisli m c d -> Data.Either.Either b c -> m d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbNK5 ds1_sbNK6 eta_sbNK7]
        Data.Either.either ds_sbNK5 ds1_sbNK6 eta_sbNK7;

Control.Arrow.$fArrowChoiceKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     Control.Arrow.ArrowChoice (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,U,A)>m] =
    [] \r [$dMonad_sbNK8]
        let {
          sat_sbNKc [Occ=Once]
            :: forall b c b' c'.
               Control.Arrow.Kleisli m_XbN1O b c
               -> Control.Arrow.Kleisli m_XbN1O b' c'
               -> Control.Arrow.Kleisli
                    m_XbN1O (Data.Either.Either b b') (Data.Either.Either c c')
          [LclId] =
              [$dMonad_sbNK8] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fArrowChoiceKleisli1
                      $dMonad_sbNK8 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbNKb [Occ=Once]
            :: forall b c d.
               Control.Arrow.Kleisli m_XbN1O b c
               -> Control.Arrow.Kleisli
                    m_XbN1O (Data.Either.Either d b) (Data.Either.Either d c)
          [LclId] =
              [$dMonad_sbNK8] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowChoiceKleisli2
                      $dMonad_sbNK8 eta_B2 eta_B1; } in
        let {
          sat_sbNKa [Occ=Once]
            :: forall b c d.
               Control.Arrow.Kleisli m_XbN1O b c
               -> Control.Arrow.Kleisli
                    m_XbN1O (Data.Either.Either b d) (Data.Either.Either c d)
          [LclId] =
              [$dMonad_sbNK8] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowChoiceKleisli3
                      $dMonad_sbNK8 eta_B2 eta_B1; } in
        let {
          sat_sbNK9 [Occ=Once]
            :: Control.Arrow.Arrow (Control.Arrow.Kleisli m_XbN1O)
          [LclId] =
              [$dMonad_sbNK8] \u [] Control.Arrow.$fArrowKleisli $dMonad_sbNK8;
        } in 
          Control.Arrow.C:ArrowChoice [sat_sbNK9
                                       sat_sbNKa
                                       sat_sbNKb
                                       sat_sbNKc
                                       lvl4_rbNCc];

Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Control.Arrow.Arrow (Control.Arrow.Kleisli m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(A,C(C1(U)),A,U,A),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbNKd]
        let {
          sat_sbNKe [Occ=Once, Dmd=<L,U(A,C(C1(U)),A,U,A)>]
            :: GHC.Base.Monad m_XbN5r
          [LclId] =
              [$dMonadPlus_sbNKd] \u [] GHC.Base.$p2MonadPlus $dMonadPlus_sbNKd;
        } in  Control.Arrow.$fArrowKleisli sat_sbNKe;

Control.Arrow.$fArrowZeroKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Control.Arrow.ArrowZero (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U(A,C(C1(U)),A,U,A),1*U,A)>m] =
    [] \r [$dMonadPlus_sbNKf]
        let {
          lvl5_sbNKg [Occ=OnceL] :: forall c. m_XbN5s c
          [LclId] =
              [$dMonadPlus_sbNKf] \u [] GHC.Base.mzero $dMonadPlus_sbNKf; } in
        let {
          sat_sbNKj [Occ=Once]
            :: forall b c. Control.Arrow.Kleisli m_XbN5s b c
          [LclId] =
              [lvl5_sbNKg] \r [ds_sbNKi] lvl5_sbNKg; } in
        let {
          sat_sbNKh [Occ=Once]
            :: Control.Arrow.Arrow (Control.Arrow.Kleisli m_XbN5s)
          [LclId] =
              [$dMonadPlus_sbNKf] \u []
                  Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero $dMonadPlus_sbNKf;
        } in  Control.Arrow.C:ArrowZero [sat_sbNKh sat_sbNKj];

Control.Arrow.$fArrowPlusKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Control.Arrow.ArrowPlus (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,U(A,C(C1(U)),A,U,A),U,C(C1(U)))>m] =
    [] \r [$dMonadPlus_sbNKk]
        let {
          sat_sbNKm [Occ=Once]
            :: forall b c.
               Control.Arrow.Kleisli m_XbN58 b c
               -> Control.Arrow.Kleisli m_XbN58 b c
               -> Control.Arrow.Kleisli m_XbN58 b c
          [LclId] =
              [$dMonadPlus_sbNKk] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fArrowPlusKleisli1
                      $dMonadPlus_sbNKk eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbNKl [Occ=Once]
            :: Control.Arrow.ArrowZero (Control.Arrow.Kleisli m_XbN58)
          [LclId] =
              [$dMonadPlus_sbNKk] \u []
                  Control.Arrow.$fArrowZeroKleisli $dMonadPlus_sbNKk;
        } in  Control.Arrow.C:ArrowPlus [sat_sbNKl sat_sbNKm];

Control.Arrow.$dmsecond
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c d. a b c -> a (d, b) (d, c)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLC(S)L),U(1*U(1*U,A),A,A,A,1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNKn]
        let {
          sat_sbNKp [Occ=Once] :: a_abMuz d_abMNj d_abMNj
          [LclId] =
              [$dArrow_sbNKn] \u []
                  case Control.Arrow.$p1Arrow $dArrow_sbNKn of sat_sbNKo {
                    __DEFAULT -> Control.Category.id sat_sbNKo;
                  };
        } in  Control.Arrow.*** $dArrow_sbNKn sat_sbNKp;

Control.Arrow.$dmfirst
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c d. a b c -> a (b, d) (c, d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLC(C(S))L),U(1*U(1*U,A),A,A,A,1*C1(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNKq eta_sbNKr]
        let {
          sat_sbNKt [Occ=Once] :: a_abMuz d_abMN2 d_abMN2
          [LclId] =
              [$dArrow_sbNKq] \u []
                  case Control.Arrow.$p1Arrow $dArrow_sbNKq of sat_sbNKs {
                    __DEFAULT -> Control.Category.id sat_sbNKs;
                  };
        } in  Control.Arrow.*** $dArrow_sbNKq eta_sbNKr sat_sbNKt;

Control.Arrow.$cfirst :: forall b c d. (b -> c) -> (b, d) -> (c, d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sbNKu ds1_sbNKv]
        let {
          sat_sbNKE [Occ=Once] :: d_abN4j
          [LclId] =
              [ds1_sbNKv] \u []
                  case ds1_sbNKv of {
                    (,) _ [Occ=Dead] y_sbNKD [Occ=Once] -> y_sbNKD;
                  }; } in
        let {
          sat_sbNKA [Occ=Once] :: c_abN4i
          [LclId] =
              [ds_sbNKu ds1_sbNKv] \u []
                  let {
                    sat_sbNKz [Occ=Once] :: b_abN4h
                    [LclId] =
                        [ds1_sbNKv] \u []
                            case ds1_sbNKv of {
                              (,) x_sbNKx [Occ=Once] _ [Occ=Dead] -> x_sbNKx;
                            };
                  } in  ds_sbNKu sat_sbNKz;
        } in  (,) [sat_sbNKA sat_sbNKE];

Control.Arrow.$csecond
  :: forall b c d. (b -> c) -> (d, b) -> (d, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sbNKF ds_sbNKG]
        let {
          sat_sbNKP [Occ=Once] :: c_abN4u
          [LclId] =
              [g_sbNKF ds_sbNKG] \u []
                  let {
                    sat_sbNKO [Occ=Once] :: b_abN4t
                    [LclId] =
                        [ds_sbNKG] \u []
                            case ds_sbNKG of {
                              (,) _ [Occ=Dead] y_sbNKN [Occ=Once] -> y_sbNKN;
                            };
                  } in  g_sbNKF sat_sbNKO; } in
        let {
          sat_sbNKK [Occ=Once] :: d_abN4v
          [LclId] =
              [ds_sbNKG] \u []
                  case ds_sbNKG of {
                    (,) x_sbNKI [Occ=Once] _ [Occ=Dead] -> x_sbNKI;
                  };
        } in  (,) [sat_sbNKK sat_sbNKP];

Control.Arrow.$c&&&
  :: forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [f_sbNKQ g_sbNKR eta_sbNKS]
        let {
          sat_sbNKU [Occ=Once] :: c'_abN4P
          [LclId] =
              [g_sbNKR eta_sbNKS] \u [] g_sbNKR eta_sbNKS; } in
        let {
          sat_sbNKT [Occ=Once] :: c_abN4O
          [LclId] =
              [f_sbNKQ eta_sbNKS] \u [] f_sbNKQ eta_sbNKS;
        } in  (,) [sat_sbNKT sat_sbNKU];

Control.Arrow.$fArrow(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Arrow.Arrow (->)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Arrow.C:Arrow! [Control.Category.$fCategoryTYPE(->)
                                          Control.Arrow.$fArrow(->)_$carr
                                          Control.Arrow.$cfirst
                                          Control.Arrow.$csecond
                                          Control.Arrow.$c***
                                          Control.Arrow.$c&&&];

Control.Arrow.$fArrowLoop(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Arrow.ArrowLoop (->)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Arrow.C:ArrowLoop! [Control.Arrow.$fArrow(->)
                                              Control.Arrow.$fArrowLoop(->)_$cloop];

Control.Arrow.$fArrowApply(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Arrow.ArrowApply (->)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Arrow.C:ArrowApply! [Control.Arrow.$fArrow(->)
                                               Control.Arrow.$fAlternativeArrowMonad_$capp];

Control.Arrow.$c+++
  :: forall b c b' c'.
     (b -> c)
     -> (b' -> c') -> Data.Either.Either b b' -> Data.Either.Either c c'
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sbNKV g_sbNKW ds1_sbNKX]
        case ds1_sbNKX of {
          Data.Either.Left x_sbNKZ [Occ=Once] ->
              let {
                sat_sbNL0 [Occ=Once] :: c_abN0A
                [LclId] =
                    [f_sbNKV x_sbNKZ] \u [] f_sbNKV x_sbNKZ;
              } in  Data.Either.Left [sat_sbNL0];
          Data.Either.Right y_sbNL1 [Occ=Once] ->
              let {
                sat_sbNL2 [Occ=Once] :: c'_abN0C
                [LclId] =
                    [g_sbNKW y_sbNL1] \u [] g_sbNKW y_sbNL1;
              } in  Data.Either.Right [sat_sbNL2];
        };

Control.Arrow.$cright
  :: forall b c d.
     (b -> c) -> Data.Either.Either d b -> Data.Either.Either d c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sbNL3 ds1_sbNL4]
        case ds1_sbNL4 of {
          Data.Either.Left x_sbNL6 [Occ=Once] -> wild_sbNL5;
          Data.Either.Right y_sbNL7 [Occ=Once] ->
              let {
                sat_sbNL8 [Occ=Once] :: c_abN0g
                [LclId] =
                    [f_sbNL3 y_sbNL7] \u [] f_sbNL3 y_sbNL7;
              } in  Data.Either.Right [sat_sbNL8];
        };

Control.Arrow.$cleft
  :: forall b c d.
     (b -> c) -> Data.Either.Either b d -> Data.Either.Either c d
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sbNL9 ds1_sbNLa]
        case ds1_sbNLa of {
          Data.Either.Left x_sbNLc [Occ=Once] ->
              let {
                sat_sbNLd [Occ=Once] :: c_abMZW
                [LclId] =
                    [f_sbNL9 x_sbNLc] \u [] f_sbNL9 x_sbNLc;
              } in  Data.Either.Left [sat_sbNLd];
          Data.Either.Right y_sbNLe [Occ=Once] -> wild_sbNLb;
        };

Control.Arrow.$fArrowChoice(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Arrow.ArrowChoice (->)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Arrow.C:ArrowChoice! [Control.Arrow.$fArrow(->)
                                                Control.Arrow.$cleft
                                                Control.Arrow.$cright
                                                Control.Arrow.$c+++
                                                Data.Either.either];

Control.Arrow.runKleisli1
  :: forall (m :: * -> *) a b.
     Control.Arrow.Kleisli m a b -> Control.Arrow.Kleisli m a b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbNLf] ds_sbNLf;

Control.Arrow.runKleisli
  :: forall (m :: * -> *) a b.
     Control.Arrow.Kleisli m a b -> a -> m b
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Control.Arrow.runKleisli1 eta_B1;

Control.Arrow.returnA
  :: forall (a :: * -> * -> *) b. Control.Arrow.Arrow a => a b b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNLg] Control.Arrow.arr $dArrow_sbNLg GHC.Base.id;

Control.Arrow.^>>
  :: forall (a :: * -> * -> *) b c d.
     Control.Arrow.Arrow a =>
     (b -> c) -> a c d -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNLh eta_sbNLi eta1_sbNLj]
        let {
          sat_sbNLl [Occ=Once] :: a_abMMs b_abMMt c_abMMu
          [LclId] =
              [$dArrow_sbNLh eta_sbNLi] \u []
                  Control.Arrow.arr $dArrow_sbNLh eta_sbNLi;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbNLh of sat_sbNLk {
            __DEFAULT -> Control.Category.. sat_sbNLk eta1_sbNLj sat_sbNLl;
          };

Control.Arrow.>>^
  :: forall (a :: * -> * -> *) b c d.
     Control.Arrow.Arrow a =>
     a b c -> (c -> d) -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNLm eta_sbNLn eta1_sbNLo]
        let {
          sat_sbNLq [Occ=Once] :: a_abMMb c_abMMd d_abMMe
          [LclId] =
              [$dArrow_sbNLm eta1_sbNLo] \u []
                  Control.Arrow.arr $dArrow_sbNLm eta1_sbNLo;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbNLm of sat_sbNLp {
            __DEFAULT -> Control.Category.. sat_sbNLp sat_sbNLq eta_sbNLn;
          };

Control.Arrow.<<^
  :: forall (a :: * -> * -> *) c d b.
     Control.Arrow.Arrow a =>
     a c d -> (b -> c) -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNLr eta_sbNLs eta1_sbNLt]
        let {
          sat_sbNLv [Occ=Once] :: a_abMLU b_abMLX c_abMLV
          [LclId] =
              [$dArrow_sbNLr eta1_sbNLt] \u []
                  Control.Arrow.arr $dArrow_sbNLr eta1_sbNLt;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbNLr of sat_sbNLu {
            __DEFAULT -> Control.Category.. sat_sbNLu eta_sbNLs sat_sbNLv;
          };

Control.Arrow.^<<
  :: forall (a :: * -> * -> *) c d b.
     Control.Arrow.Arrow a =>
     (c -> d) -> a b c -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNLw eta_sbNLx eta1_sbNLy]
        let {
          sat_sbNLA [Occ=Once] :: a_abMLx c_abMLy d_abMLz
          [LclId] =
              [$dArrow_sbNLw eta_sbNLx] \u []
                  Control.Arrow.arr $dArrow_sbNLw eta_sbNLx;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbNLw of sat_sbNLz {
            __DEFAULT -> Control.Category.. sat_sbNLz sat_sbNLA eta1_sbNLy;
          };

Control.Arrow.leftApp
  :: forall (a :: * -> * -> *) b c d.
     Control.Arrow.ArrowApply a =>
     a b c -> a (Data.Either.Either b d) (Data.Either.Either c d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(1*U(1*U(A,C(C1(U))),C(U),A,A,A,A),1*U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbNLB eta_sbNLC]
        case
            Control.Arrow.$p1ArrowApply $dArrowApply_sbNLB
        of
        $dArrow_sbNLD [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),C(U),A,A,A,A)>]
        { __DEFAULT ->
              case
                  Control.Arrow.$p1Arrow $dArrow_sbNLD
              of
              $dCategory_sbNLE [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
              { __DEFAULT ->
                    let {
                      sat_sbNLX [Occ=Once]
                        :: a_abMK6 (Data.Either.Either
                                      b_abMK7 d_abMK9) (a_abMK6 () (Data.Either.Either
                                                                      c_abMK8 d_abMK9),
                                                        ())
                      [LclId] =
                          [eta_sbNLC $dArrow_sbNLD $dCategory_sbNLE] \u []
                              let {
                                lvl5_sbNLG [Occ=OnceL]
                                  :: a_abMK6 c_abMK8 (Data.Either.Either c_abMK8 d_abMK9)
                                [LclId] =
                                    [$dArrow_sbNLD] \u []
                                        Control.Arrow.arr $dArrow_sbNLD Data.Either.Left; } in
                              let {
                                sat_sbNLW [Occ=Once]
                                  :: Data.Either.Either b_abMK7 d_abMK9
                                     -> (a_abMK6 () (Data.Either.Either c_abMK8 d_abMK9), ())
                                [LclId] =
                                    [eta_sbNLC
                                     $dArrow_sbNLD
                                     $dCategory_sbNLE
                                     lvl5_sbNLG] \r [ds1_sbNLH]
                                        case ds1_sbNLH of {
                                          Data.Either.Left x_sbNLJ [Occ=OnceL] ->
                                              let {
                                                sat_sbNLP [Occ=Once]
                                                  :: a_abMK6 () (Data.Either.Either c_abMK8 d_abMK9)
                                                [LclId] =
                                                    [eta_sbNLC
                                                     $dArrow_sbNLD
                                                     $dCategory_sbNLE
                                                     lvl5_sbNLG
                                                     x_sbNLJ] \u []
                                                        let {
                                                          sat_sbNLO [Occ=Once] :: a_abMK6 () c_abMK8
                                                          [LclId] =
                                                              [eta_sbNLC
                                                               $dArrow_sbNLD
                                                               $dCategory_sbNLE
                                                               x_sbNLJ] \u []
                                                                  let {
                                                                    sat_sbNLN [Occ=Once]
                                                                      :: a_abMK6 () b_abMK7
                                                                    [LclId] =
                                                                        [$dArrow_sbNLD
                                                                         x_sbNLJ] \u []
                                                                            let {
                                                                              sat_sbNLM [Occ=Once]
                                                                                :: () -> b_abMK7
                                                                              [LclId] =
                                                                                  [x_sbNLJ] \r [ds_sbNLK]
                                                                                      case
                                                                                          ds_sbNLK
                                                                                      of
                                                                                      { () ->
                                                                                            x_sbNLJ;
                                                                                      };
                                                                            } in 
                                                                              Control.Arrow.arr
                                                                                  $dArrow_sbNLD
                                                                                  sat_sbNLM;
                                                                  } in 
                                                                    Control.Category..
                                                                        $dCategory_sbNLE
                                                                        eta_sbNLC
                                                                        sat_sbNLN;
                                                        } in 
                                                          Control.Category..
                                                              $dCategory_sbNLE lvl5_sbNLG sat_sbNLO;
                                              } in  (,) [sat_sbNLP GHC.Tuple.()];
                                          Data.Either.Right y_sbNLQ [Occ=OnceL] ->
                                              let {
                                                sat_sbNLV [Occ=Once]
                                                  :: a_abMK6 () (Data.Either.Either c_abMK8 d_abMK9)
                                                [LclId] =
                                                    [$dArrow_sbNLD y_sbNLQ] \u []
                                                        let {
                                                          sat_sbNLU [Occ=Once]
                                                            :: ()
                                                               -> Data.Either.Either c_abMK8 d_abMK9
                                                          [LclId] =
                                                              [y_sbNLQ] \r [x_sbNLR]
                                                                  let {
                                                                    sat_sbNLT [Occ=Once] :: d_abMK9
                                                                    [LclId] =
                                                                        [y_sbNLQ x_sbNLR] \u []
                                                                            case x_sbNLR of {
                                                                              () -> y_sbNLQ;
                                                                            };
                                                                  } in 
                                                                    Data.Either.Right [sat_sbNLT];
                                                        } in 
                                                          Control.Arrow.arr $dArrow_sbNLD sat_sbNLU;
                                              } in  (,) [sat_sbNLV GHC.Tuple.()];
                                        };
                              } in  Control.Arrow.arr $dArrow_sbNLD sat_sbNLW; } in
                    let {
                      sat_sbNLF [Occ=Once]
                        :: a_abMK6 (a_abMK6 () (Data.Either.Either c_abMK8 d_abMK9),
                                    ()) (Data.Either.Either c_abMK8 d_abMK9)
                      [LclId] =
                          [$dArrowApply_sbNLB] \u [] Control.Arrow.app $dArrowApply_sbNLB;
                    } in  Control.Category.. $dCategory_sbNLE sat_sbNLF sat_sbNLX;
              };
        };

Control.Arrow.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Control.Arrow.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$trModule4];

Control.Arrow.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Control.Arrow"#;

Control.Arrow.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$trModule2];

Control.Arrow.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Control.Arrow.$trModule3
                                     Control.Arrow.$trModule1];

$krep_rbNCd :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Tuple.$tc()
                                              GHC.Types.[]];

$krep1_rbNCe :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Control.Arrow.$tcKleisli1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         GHC.Types.krep$*->*->*];

Control.Arrow.$tcArrow1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep1_rbNCe];

Control.Arrow.$tcArrowMonad1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         GHC.Types.krep$*Arr*];

$krep2_rbNCf :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep3_rbNCg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep4_rbNCh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep5_rbNCi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_rbNCh $krep2_rbNCf];

$krep6_rbNCj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rbNCg $krep5_rbNCi];

$krep7_rbNCk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_rbNCh $krep_rbNCd];

$krep8_rbNCl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep7_rbNCk $krep3_rbNCg];

Control.Arrow.$tcArrow3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Arrow"#;

Control.Arrow.$tcArrow2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrow3];

Control.Arrow.$tcArrow :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12964584583212294992##
                                    10211991410748124746##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrow2
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcKleisli3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Kleisli"#;

Control.Arrow.$tcKleisli2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcKleisli3];

Control.Arrow.$tcKleisli :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2023158159015915132##
                                    6143719008973118504##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcKleisli2
                                    0#
                                    Control.Arrow.$tcKleisli1];

$krep9_rbNCm :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rbNCf GHC.Types.[]];

$krep10_rbNCn :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_rbNCg $krep9_rbNCm];

$krep11_rbNCo :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_rbNCh $krep10_rbNCn];

$krep12_rbNCp :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Arrow.$tcKleisli
                                              $krep11_rbNCo];

Control.Arrow.$tc'Kleisli1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_rbNCj $krep12_rbNCp];

Control.Arrow.$tc'Kleisli3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Kleisli"#;

Control.Arrow.$tc'Kleisli2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tc'Kleisli3];

Control.Arrow.$tc'Kleisli :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [793719726112502834##
                                    14919550952510816382##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tc'Kleisli2
                                    3#
                                    Control.Arrow.$tc'Kleisli1];

Control.Arrow.$tcArrowZero2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowZero"#;

Control.Arrow.$tcArrowZero1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowZero2];

Control.Arrow.$tcArrowZero :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [337582314637215801##
                                    485553589222180171##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowZero1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcArrowPlus2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowPlus"#;

Control.Arrow.$tcArrowPlus1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowPlus2];

Control.Arrow.$tcArrowPlus :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9089885184909062397##
                                    13092571182525076608##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowPlus1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcArrowChoice2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowChoice"#;

Control.Arrow.$tcArrowChoice1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowChoice2];

Control.Arrow.$tcArrowChoice :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9045385674203608923##
                                    4474606397073518393##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowChoice1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcArrowApply2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowApply"#;

Control.Arrow.$tcArrowApply1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowApply2];

Control.Arrow.$tcArrowApply :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4969046276209689969##
                                    2697302259091605677##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowApply1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcArrowMonad3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowMonad"#;

Control.Arrow.$tcArrowMonad2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowMonad3];

Control.Arrow.$tcArrowMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2648525758856951758##
                                    13692351200590237690##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowMonad2
                                    0#
                                    Control.Arrow.$tcArrowMonad1];

$krep13_rbNCq :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_rbNCg GHC.Types.[]];

$krep14_rbNCr :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_rbNCh $krep13_rbNCq];

$krep15_rbNCs :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Arrow.$tcArrowMonad
                                              $krep14_rbNCr];

Control.Arrow.$tc'ArrowMonad1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_rbNCl $krep15_rbNCs];

Control.Arrow.$tc'ArrowMonad3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'ArrowMonad"#;

Control.Arrow.$tc'ArrowMonad2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tc'ArrowMonad3];

Control.Arrow.$tc'ArrowMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8781545391513276915##
                                    783725375361948493##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tc'ArrowMonad2
                                    2#
                                    Control.Arrow.$tc'ArrowMonad1];

Control.Arrow.$tcArrowLoop2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowLoop"#;

Control.Arrow.$tcArrowLoop1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowLoop2];

Control.Arrow.$tcArrowLoop :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15298492960828880948##
                                    13953070859738786616##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowLoop1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.C:ArrowLoop
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     (forall b d c. a (b, d) (c, d) -> a b c)
     -> Control.Arrow.ArrowLoop a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Control.Arrow.C:ArrowLoop [eta_B2 eta_B1];

Control.Arrow.C:ArrowApply
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     (forall b c. a (a b c, b) c) -> Control.Arrow.ArrowApply a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Control.Arrow.C:ArrowApply [eta_B2 eta_B1];

Control.Arrow.C:ArrowChoice
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     (forall b c d.
      a b c -> a (Data.Either.Either b d) (Data.Either.Either c d))
     -> (forall b c d.
         a b c -> a (Data.Either.Either d b) (Data.Either.Either d c))
     -> (forall b c b' c'.
         a b c
         -> a b' c'
         -> a (Data.Either.Either b b') (Data.Either.Either c c'))
     -> (forall b d c. a b d -> a c d -> a (Data.Either.Either b c) d)
     -> Control.Arrow.ArrowChoice a
[GblId[DataCon],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Control.Arrow.C:ArrowChoice [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];

Control.Arrow.C:ArrowPlus
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowZero a =>
     (forall b c. a b c -> a b c -> a b c) -> Control.Arrow.ArrowPlus a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Control.Arrow.C:ArrowPlus [eta_B2 eta_B1];

Control.Arrow.C:ArrowZero
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     (forall b c. a b c) -> Control.Arrow.ArrowZero a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Control.Arrow.C:ArrowZero [eta_B2 eta_B1];

Control.Arrow.C:Arrow
  :: forall (a :: * -> * -> *).
     Control.Category.Category a =>
     (forall b c. (b -> c) -> a b c)
     -> (forall b c d. a b c -> a (b, d) (c, d))
     -> (forall b c d. a b c -> a (d, b) (d, c))
     -> (forall b c b' c'. a b c -> a b' c' -> a (b, b') (c, c'))
     -> (forall b c c'. a b c -> a b c' -> a b (c, c'))
     -> Control.Arrow.Arrow a
[GblId[DataCon],
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Control.Arrow.C:Arrow [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:06:39.970242442 UTC

Control.Arrow.$p1ArrowLoop
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowLoop a =>
     Control.Arrow.Arrow a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sbNCu]
        case v_sbNCu of {
          Control.Arrow.C:ArrowLoop v_sbNCw [Occ=Once] _ [Occ=Dead] ->
              v_sbNCw;
        };

Control.Arrow.loop
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowLoop a =>
     forall b d c. a (b, d) (c, d) -> a b c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sbNCy]
        case v_sbNCy of {
          Control.Arrow.C:ArrowLoop _ [Occ=Dead] v_sbNCB [Occ=Once] ->
              v_sbNCB;
        };

Control.Arrow.$p1ArrowApply
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     Control.Arrow.Arrow a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sbNCC]
        case v_sbNCC of {
          Control.Arrow.C:ArrowApply v_sbNCE [Occ=Once] _ [Occ=Dead] ->
              v_sbNCE;
        };

Control.Arrow.app
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     forall b c. a (a b c, b) c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sbNCG]
        case v_sbNCG of {
          Control.Arrow.C:ArrowApply _ [Occ=Dead] v_sbNCJ [Occ=Once] ->
              v_sbNCJ;
        };

Control.Arrow.$p1ArrowChoice
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     Control.Arrow.Arrow a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLL),U(U,A,A,A,A)>] =
    [] \r [v_sbNCK]
        case v_sbNCK of {
          Control.Arrow.C:ArrowChoice v_sbNCM [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_sbNCM;
        };

Control.Arrow.left
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c d.
     a b c -> a (Data.Either.Either b d) (Data.Either.Either c d)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLL),U(A,U,A,A,A)>] =
    [] \r [v_sbNCR]
        case v_sbNCR of {
          Control.Arrow.C:ArrowChoice _ [Occ=Dead]
                                      v_sbNCU [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_sbNCU;
        };

Control.Arrow.right
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c d.
     a b c -> a (Data.Either.Either d b) (Data.Either.Either d c)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLL),U(A,A,U,A,A)>] =
    [] \r [v_sbNCY]
        case v_sbNCY of {
          Control.Arrow.C:ArrowChoice _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_sbND2 [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_sbND2;
        };

Control.Arrow.+++
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c b' c'.
     a b c
     -> a b' c' -> a (Data.Either.Either b b') (Data.Either.Either c c')
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSL),U(A,A,A,U,A)>] =
    [] \r [v_sbND5]
        case v_sbND5 of {
          Control.Arrow.C:ArrowChoice _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_sbNDa [Occ=Once]
                                      _ [Occ=Dead] ->
              v_sbNDa;
        };

Control.Arrow.|||
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b d c. a b d -> a c d -> a (Data.Either.Either b c) d
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLS),U(A,A,A,A,U)>] =
    [] \r [v_sbNDc]
        case v_sbNDc of {
          Control.Arrow.C:ArrowChoice _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_sbNDi [Occ=Once] ->
              v_sbNDi;
        };

Control.Arrow.$p1ArrowPlus
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     Control.Arrow.ArrowZero a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sbNDj]
        case v_sbNDj of {
          Control.Arrow.C:ArrowPlus v_sbNDl [Occ=Once] _ [Occ=Dead] ->
              v_sbNDl;
        };

Control.Arrow.<+>
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     forall b c. a b c -> a b c -> a b c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sbNDn]
        case v_sbNDn of {
          Control.Arrow.C:ArrowPlus _ [Occ=Dead] v_sbNDq [Occ=Once] ->
              v_sbNDq;
        };

Control.Arrow.$p1ArrowZero
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowZero a =>
     Control.Arrow.Arrow a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sbNDr]
        case v_sbNDr of {
          Control.Arrow.C:ArrowZero v_sbNDt [Occ=Once] _ [Occ=Dead] ->
              v_sbNDt;
        };

Control.Arrow.zeroArrow
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowZero a =>
     forall b c. a b c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sbNDv]
        case v_sbNDv of {
          Control.Arrow.C:ArrowZero _ [Occ=Dead] v_sbNDy [Occ=Once] ->
              v_sbNDy;
        };

Control.Arrow.$p1Arrow
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     Control.Category.Category a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLL),U(U,A,A,A,A,A)>] =
    [] \r [v_sbNDz]
        case v_sbNDz of {
          Control.Arrow.C:Arrow v_sbNDB [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_sbNDB;
        };

Control.Arrow.arr
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c. (b -> c) -> a b c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLL),U(A,U,A,A,A,A)>] =
    [] \r [v_sbNDH]
        case v_sbNDH of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                v_sbNDK [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_sbNDK;
        };

Control.Arrow.first
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c d. a b c -> a (b, d) (c, d)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLL),U(A,A,U,A,A,A)>] =
    [] \r [v_sbNDP]
        case v_sbNDP of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_sbNDT [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_sbNDT;
        };

Control.Arrow.second
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c d. a b c -> a (d, b) (d, c)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLL),U(A,A,A,U,A,A)>] =
    [] \r [v_sbNDX]
        case v_sbNDX of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_sbNE2 [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_sbNE2;
        };

Control.Arrow.***
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c b' c'. a b c -> a b' c' -> a (b, b') (c, c')
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSL),U(A,A,A,A,U,A)>] =
    [] \r [v_sbNE5]
        case v_sbNE5 of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_sbNEb [Occ=Once]
                                _ [Occ=Dead] ->
              v_sbNEb;
        };

Control.Arrow.&&&
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c c'. a b c -> a b c' -> a b (c, c')
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLS),U(A,A,A,A,A,U)>] =
    [] \r [v_sbNEd]
        case v_sbNEd of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_sbNEk [Occ=Once] ->
              v_sbNEk;
        };

Control.Arrow.$c***
  :: forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sbNEl g_sbNEm ds_sbNEn]
        let {
          sat_sbNEx [Occ=Once] :: c'_abN4I
          [LclId] =
              [g_sbNEm ds_sbNEn] \u []
                  let {
                    sat_sbNEw [Occ=Once] :: b'_abN4H
                    [LclId] =
                        [ds_sbNEn] \u []
                            case ds_sbNEn of {
                              (,) _ [Occ=Dead] y_sbNEv [Occ=Once] -> y_sbNEv;
                            };
                  } in  g_sbNEm sat_sbNEw; } in
        let {
          sat_sbNEs [Occ=Once] :: c_abN4G
          [LclId] =
              [f_sbNEl ds_sbNEn] \u []
                  let {
                    sat_sbNEr [Occ=Once] :: b_abN4F
                    [LclId] =
                        [ds_sbNEn] \u []
                            case ds_sbNEn of {
                              (,) x_sbNEp [Occ=Once] _ [Occ=Dead] -> x_sbNEp;
                            };
                  } in  f_sbNEl sat_sbNEr;
        } in  (,) [sat_sbNEs sat_sbNEx];

Control.Arrow.$fArrow(->)_$carr :: forall b c. (b -> c) -> b -> c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [f_sbNEy] f_sbNEy;

Control.Arrow.$fCategoryTYPEKleisli1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c a.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m a b -> a -> m c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbNEz ds_sbNEA ds1_sbNEB b1_sbNEC]
        let {
          sat_sbNED [Occ=Once] :: m_abN3z b_abN3Q
          [LclId] =
              [ds1_sbNEB b1_sbNEC] \u [] ds1_sbNEB b1_sbNEC;
        } in  GHC.Base.>>= $dMonad_sbNEz sat_sbNED ds_sbNEA;

Control.Arrow.$fCategoryTYPEKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     Control.Category.Category (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,1*U,A)>m] =
    [] \r [$dMonad_sbNEE]
        let {
          sat_sbNEG [Occ=Once]
            :: forall b c a.
               Control.Arrow.Kleisli m_XbN5v b c
               -> Control.Arrow.Kleisli m_XbN5v a b
               -> Control.Arrow.Kleisli m_XbN5v a c
          [LclId] =
              [$dMonad_sbNEE] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fCategoryTYPEKleisli1
                      $dMonad_sbNEE eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbNEF [Occ=Once] :: forall a. Control.Arrow.Kleisli m_XbN5v a a
          [LclId] =
              [$dMonad_sbNEE] \u [] GHC.Base.return $dMonad_sbNEE;
        } in  Control.Category.C:Category [sat_sbNEF sat_sbNEG];

Control.Arrow.$fArrowKleisli4
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c d. Control.Arrow.Kleisli m b c -> (d, b) -> m (d, c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,1*C1(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbNEH ds_sbNEI ds1_sbNEJ]
        let {
          d1_sbNEK [Occ=OnceL] :: d_abN2Q
          [LclId] =
              [ds1_sbNEJ] \u []
                  case ds1_sbNEJ of {
                    (,) d2_sbNEM [Occ=Once] _ [Occ=Dead] -> d2_sbNEM;
                  }; } in
        let {
          sat_sbNEV [Occ=Once] :: c_abN2P -> m_abN1X (d_abN2Q, c_abN2P)
          [LclId] =
              [$dMonad_sbNEH d1_sbNEK] \r [c1_sbNET]
                  let {
                    sat_sbNEU [Occ=Once] :: (d_abN2Q, c_abN2P)
                    [LclId] =
                        CCCS (,)! [d1_sbNEK c1_sbNET];
                  } in  GHC.Base.return $dMonad_sbNEH sat_sbNEU; } in
        let {
          sat_sbNES [Occ=Once] :: m_abN1X c_abN2P
          [LclId] =
              [ds_sbNEI ds1_sbNEJ] \u []
                  let {
                    sat_sbNER [Occ=Once] :: b_abN2O
                    [LclId] =
                        [ds1_sbNEJ] \u []
                            case ds1_sbNEJ of {
                              (,) _ [Occ=Dead] b1_sbNEQ [Occ=Once] -> b1_sbNEQ;
                            };
                  } in  ds_sbNEI sat_sbNER;
        } in  GHC.Base.>>= $dMonad_sbNEH sat_sbNES sat_sbNEV;

Control.Arrow.$fArrowKleisli3
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c d. Control.Arrow.Kleisli m b c -> (b, d) -> m (c, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,1*C1(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbNEW ds_sbNEX ds1_sbNEY]
        let {
          d1_sbNEZ [Occ=OnceL] :: d_abN2u
          [LclId] =
              [ds1_sbNEY] \u []
                  case ds1_sbNEY of {
                    (,) _ [Occ=Dead] d2_sbNF2 [Occ=Once] -> d2_sbNF2;
                  }; } in
        let {
          sat_sbNFa [Occ=Once] :: c_abN2t -> m_XbN42 (c_abN2t, d_abN2u)
          [LclId] =
              [$dMonad_sbNEW d1_sbNEZ] \r [c1_sbNF8]
                  let {
                    sat_sbNF9 [Occ=Once] :: (c_abN2t, d_abN2u)
                    [LclId] =
                        CCCS (,)! [c1_sbNF8 d1_sbNEZ];
                  } in  GHC.Base.return $dMonad_sbNEW sat_sbNF9; } in
        let {
          sat_sbNF7 [Occ=Once] :: m_XbN42 c_abN2t
          [LclId] =
              [ds_sbNEX ds1_sbNEY] \u []
                  let {
                    sat_sbNF6 [Occ=Once] :: b_abN2s
                    [LclId] =
                        [ds1_sbNEY] \u []
                            case ds1_sbNEY of {
                              (,) b1_sbNF4 [Occ=Once] _ [Occ=Dead] -> b1_sbNF4;
                            };
                  } in  ds_sbNEX sat_sbNF6;
        } in  GHC.Base.>>= $dMonad_sbNEW sat_sbNF7 sat_sbNFa;

Control.Arrow.$fArrowKleisli5
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c. (b -> c) -> b -> m c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbNFb f_sbNFc eta_sbNFd]
        let {
          sat_sbNFe [Occ=Once] :: c_abN27
          [LclId] =
              [f_sbNFc eta_sbNFd] \u [] f_sbNFc eta_sbNFd;
        } in  GHC.Base.return $dMonad_sbNFb sat_sbNFe;

Control.Arrow.$fArrowPlusKleisli1
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall b c.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m b c -> b -> m c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))),1*U(A,A,A,1*C1(C1(U)))><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbNFf ds_sbNFg ds1_sbNFh x_sbNFi]
        let {
          sat_sbNFk [Occ=Once] :: m_abN1h c_abN1r
          [LclId] =
              [ds1_sbNFh x_sbNFi] \u [] ds1_sbNFh x_sbNFi; } in
        let {
          sat_sbNFj [Occ=Once] :: m_abN1h c_abN1r
          [LclId] =
              [ds_sbNFg x_sbNFi] \u [] ds_sbNFg x_sbNFi;
        } in  GHC.Base.mplus $dMonadPlus_sbNFf sat_sbNFj sat_sbNFk;

Control.Arrow.$fAlternativeArrowMonad_$capp
  :: forall b c. (b -> c, b) -> c
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),U)>,
 Unf=OtherCon []] =
    [] \r [ds_sbNFl]
        case ds_sbNFl of {
          (,) f_sbNFn [Occ=Once!] x_sbNFo [Occ=Once] -> f_sbNFn x_sbNFo;
        };

Control.Arrow.$fApplicativeArrowMonad5
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b. (a1 -> b) -> Control.Arrow.ArrowMonad a a1 -> a () b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNFp eta_sbNFq eta1_sbNFr]
        let {
          sat_sbNFt [Occ=Once] :: a_abMWW a1_abMX1 b_abMX2
          [LclId] =
              [$dArrow_sbNFp eta_sbNFq] \u []
                  Control.Arrow.arr $dArrow_sbNFp eta_sbNFq;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbNFp of sat_sbNFs {
            __DEFAULT -> Control.Category.. sat_sbNFs sat_sbNFt eta1_sbNFr;
          };

Control.Arrow.$fFunctorArrowMonad1
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b. a1 -> Control.Arrow.ArrowMonad a b -> a () a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNFu x_sbNFv eta_sbNFw]
        let {
          sat_sbNFA [Occ=Once] :: a_XbMZs b_abMXn a1_abMXm
          [LclId] =
              [$dArrow_sbNFu x_sbNFv] \u []
                  let {
                    sat_sbNFz [Occ=Once] :: b_abMXn -> a1_abMXm
                    [LclId] =
                        [x_sbNFv] \r [ds_sbNFy] x_sbNFv;
                  } in  Control.Arrow.arr $dArrow_sbNFu sat_sbNFz;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbNFu of sat_sbNFx {
            __DEFAULT -> Control.Category.. sat_sbNFx sat_sbNFA eta_sbNFw;
          };

Control.Arrow.$fFunctorArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     GHC.Base.Functor (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,A)>m] =
    [] \r [$dArrow_sbNFB]
        let {
          sat_sbNFD [Occ=Once]
            :: forall a b.
               a
               -> Control.Arrow.ArrowMonad a_XbMZA b
               -> Control.Arrow.ArrowMonad a_XbMZA a
          [LclId] =
              [$dArrow_sbNFB] \r [eta_B2 eta_B1]
                  Control.Arrow.$fFunctorArrowMonad1
                      $dArrow_sbNFB eta_B2 eta_B1; } in
        let {
          sat_sbNFC [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Control.Arrow.ArrowMonad a_XbMZA a
               -> Control.Arrow.ArrowMonad a_XbMZA b
          [LclId] =
              [$dArrow_sbNFB] \r [eta_B2 eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad5 $dArrow_sbNFB eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sbNFC sat_sbNFD];

Control.Arrow.$fAlternativeArrowMonad2
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a (a1 -> b)
     -> Control.Arrow.ArrowMonad a a1 -> a () b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNFE eta_sbNFF eta1_sbNFG]
        let {
          sat_sbNFJ [Occ=Once] :: a_abMVp () (a1_abMVM -> b_abMVN, a1_abMVM)
          [LclId] =
              [$dArrow_sbNFE eta_sbNFF eta1_sbNFG] \u []
                  Control.Arrow.&&& $dArrow_sbNFE eta_sbNFF eta1_sbNFG; } in
        let {
          sat_sbNFI [Occ=Once]
            :: a_abMVp (a1_abMVM -> b_abMVN, a1_abMVM) b_abMVN
          [LclId] =
              [$dArrow_sbNFE] \u []
                  Control.Arrow.arr
                      $dArrow_sbNFE Control.Arrow.$fAlternativeArrowMonad_$capp;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbNFE of sat_sbNFH {
            __DEFAULT -> Control.Category.. sat_sbNFH sat_sbNFI sat_sbNFJ;
          };

Control.Arrow.$fApplicativeArrowMonad6
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1. a1 -> a () a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNFK x_sbNFL]
        let {
          sat_sbNFN [Occ=Once] :: () -> a1_abMVy
          [LclId] =
              [x_sbNFL] \r [ds_sbNFM] x_sbNFL;
        } in  Control.Arrow.arr $dArrow_sbNFK sat_sbNFN;

Control.Arrow.$fApplicativeArrowMonad4
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b c.
     (a1 -> b -> c)
     -> Control.Arrow.ArrowMonad a a1
     -> Control.Arrow.ArrowMonad a b
     -> a () c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNFO f1_sbNFP x_sbNFQ]
        let {
          sat_sbNFR [Occ=Once]
            :: Control.Arrow.ArrowMonad a_XbMYk (b_abMWs -> c_abMWt)
          [LclId] =
              [$dArrow_sbNFO f1_sbNFP x_sbNFQ] \u []
                  Control.Arrow.$fApplicativeArrowMonad5
                      $dArrow_sbNFO f1_sbNFP x_sbNFQ;
        } in 
          Control.Arrow.$fAlternativeArrowMonad2 $dArrow_sbNFO sat_sbNFR;

Control.Arrow.$fApplicativeArrowMonad3 :: forall b a. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbNFS eta_sbNFT] eta_sbNFT;

Control.Arrow.$fApplicativeArrowMonad2
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a a1
     -> Control.Arrow.ArrowMonad a b -> a () b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNFU a2_sbNFV a3_sbNFW]
        let {
          sat_sbNFZ [Occ=Once]
            :: Control.Arrow.ArrowMonad a_XbMYj (b_abMWE -> b_abMWE)
          [LclId] =
              [$dArrow_sbNFU a2_sbNFV] \u []
                  let {
                    sat_sbNFY [Occ=Once] :: a_XbMYj a1_abMWD (b_abMWE -> b_abMWE)
                    [LclId] =
                        [$dArrow_sbNFU] \u []
                            Control.Arrow.arr
                                $dArrow_sbNFU Control.Arrow.$fApplicativeArrowMonad3;
                  } in 
                    case Control.Arrow.$p1Arrow $dArrow_sbNFU of sat_sbNFX {
                      __DEFAULT -> Control.Category.. sat_sbNFX sat_sbNFY a2_sbNFV;
                    };
        } in 
          Control.Arrow.$fAlternativeArrowMonad2
              $dArrow_sbNFU sat_sbNFZ a3_sbNFW;

Control.Arrow.$fApplicativeArrowMonad1
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a a1
     -> Control.Arrow.ArrowMonad a b -> a () a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNG0 x_sbNG1]
        let {
          sat_sbNG4 [Occ=Once]
            :: Control.Arrow.ArrowMonad a_XbMYi (b_abMWO -> a1_abMWN)
          [LclId] =
              [$dArrow_sbNG0 x_sbNG1] \u []
                  let {
                    sat_sbNG3 [Occ=Once] :: a_XbMYi a1_abMWN (b_abMWO -> a1_abMWN)
                    [LclId] =
                        [$dArrow_sbNG0] \u []
                            Control.Arrow.arr $dArrow_sbNG0 GHC.Base.const;
                  } in 
                    case Control.Arrow.$p1Arrow $dArrow_sbNG0 of sat_sbNG2 {
                      __DEFAULT -> Control.Category.. sat_sbNG2 sat_sbNG3 x_sbNG1;
                    };
        } in 
          Control.Arrow.$fAlternativeArrowMonad2 $dArrow_sbNG0 sat_sbNG4;

Control.Arrow.$fApplicativeArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     GHC.Base.Applicative (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>m] =
    [] \r [$dArrow_sbNG5]
        let {
          sat_sbNGb [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMYh a
               -> Control.Arrow.ArrowMonad a_XbMYh b
               -> Control.Arrow.ArrowMonad a_XbMYh a
          [LclId] =
              [$dArrow_sbNG5] \r [eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad1 $dArrow_sbNG5 eta_B1; } in
        let {
          sat_sbNGa [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMYh a
               -> Control.Arrow.ArrowMonad a_XbMYh b
               -> Control.Arrow.ArrowMonad a_XbMYh b
          [LclId] =
              [$dArrow_sbNG5] \r [eta_B2 eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad2
                      $dArrow_sbNG5 eta_B2 eta_B1; } in
        let {
          sat_sbNG9 [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Control.Arrow.ArrowMonad a_XbMYh a
               -> Control.Arrow.ArrowMonad a_XbMYh b
               -> Control.Arrow.ArrowMonad a_XbMYh c
          [LclId] =
              [$dArrow_sbNG5] \r [eta_B2 eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad4
                      $dArrow_sbNG5 eta_B2 eta_B1; } in
        let {
          sat_sbNG8 [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMYh (a -> b)
               -> Control.Arrow.ArrowMonad a_XbMYh a
               -> Control.Arrow.ArrowMonad a_XbMYh b
          [LclId] =
              [$dArrow_sbNG5] \r [eta_B2 eta_B1]
                  Control.Arrow.$fAlternativeArrowMonad2
                      $dArrow_sbNG5 eta_B2 eta_B1; } in
        let {
          sat_sbNG7 [Occ=Once]
            :: forall a. a -> Control.Arrow.ArrowMonad a_XbMYh a
          [LclId] =
              [$dArrow_sbNG5] \r [eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad6 $dArrow_sbNG5 eta_B1; } in
        let {
          sat_sbNG6 [Occ=Once]
            :: GHC.Base.Functor (Control.Arrow.ArrowMonad a_XbMYh)
          [LclId] =
              [$dArrow_sbNG5] \u []
                  Control.Arrow.$fFunctorArrowMonad $dArrow_sbNG5;
        } in 
          GHC.Base.C:Applicative [sat_sbNG6
                                  sat_sbNG7
                                  sat_sbNG8
                                  sat_sbNG9
                                  sat_sbNGa
                                  sat_sbNGb];

Control.Arrow.$fMonadArrowMonad_$c>>=
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a a1
     -> (a1 -> Control.Arrow.ArrowMonad a b)
     -> Control.Arrow.ArrowMonad a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(1*U(1*U(A,C(C1(U))),1*C1(U),A,A,A,A),1*U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbNGc eta_sbNGd eta1_sbNGe]
        case
            Control.Arrow.$p1ArrowApply $dArrowApply_sbNGc
        of
        $dArrow_sbNGf [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              case
                  Control.Arrow.$p1Arrow $dArrow_sbNGf
              of
              $dCategory_sbNGg [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
              { __DEFAULT ->
                    let {
                      sat_sbNGm [Occ=Once] :: a_abMU9 () (a_abMU9 () b_abMUj, ())
                      [LclId] =
                          [eta_sbNGd eta1_sbNGe $dArrow_sbNGf $dCategory_sbNGg] \u []
                              let {
                                sat_sbNGl [Occ=Once] :: a_abMU9 a1_abMUi (a_abMU9 () b_abMUj, ())
                                [LclId] =
                                    [eta1_sbNGe $dArrow_sbNGf] \u []
                                        let {
                                          sat_sbNGk [Occ=Once]
                                            :: a1_abMUi -> (a_abMU9 () b_abMUj, ())
                                          [LclId] =
                                              [eta1_sbNGe] \r [x_sbNGi]
                                                  let {
                                                    sat_sbNGj [Occ=Once] :: a_abMU9 () b_abMUj
                                                    [LclId] =
                                                        [eta1_sbNGe x_sbNGi] \u []
                                                            eta1_sbNGe x_sbNGi;
                                                  } in  (,) [sat_sbNGj GHC.Tuple.()];
                                        } in  Control.Arrow.arr $dArrow_sbNGf sat_sbNGk;
                              } in  Control.Category.. $dCategory_sbNGg sat_sbNGl eta_sbNGd; } in
                    let {
                      sat_sbNGh [Occ=Once] :: a_abMU9 (a_abMU9 () b_abMUj, ()) b_abMUj
                      [LclId] =
                          [$dArrowApply_sbNGc] \u [] Control.Arrow.app $dArrowApply_sbNGc;
                    } in  Control.Category.. $dCategory_sbNGg sat_sbNGh sat_sbNGm;
              };
        };

Control.Arrow.$fMonadArrowMonad_$cp1Monad
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     GHC.Base.Applicative (Control.Arrow.ArrowMonad a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)>m,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbNGn]
        let {
          sat_sbNGo [Occ=Once, Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
            :: Control.Arrow.Arrow a_abMU9
          [LclId] =
              [$dArrowApply_sbNGn] \u []
                  Control.Arrow.$p1ArrowApply $dArrowApply_sbNGn;
        } in  Control.Arrow.$fApplicativeArrowMonad sat_sbNGo;

Control.Arrow.$fMonadArrowMonad1
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     forall a1. a1 -> a () a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)L),1*U(1*U(A,1*C1(U),A,A,A,A),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbNGp eta_sbNGq]
        let {
          sat_sbNGt [Occ=Once] :: () -> a1_abMVa
          [LclId] =
              [eta_sbNGq] \r [ds_sbNGs] eta_sbNGq;
        } in 
          case Control.Arrow.$p1ArrowApply $dArrowApply_sbNGp of sat_sbNGr {
            __DEFAULT -> Control.Arrow.arr sat_sbNGr sat_sbNGt;
          };

Control.Arrow.$fMonadArrowMonad_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a a1
     -> Control.Arrow.ArrowMonad a b -> Control.Arrow.ArrowMonad a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(U(U(A,C(C1(U))),C(U),A,A,A,A),U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbNGu eta_sbNGv eta1_sbNGw]
        let {
          sat_sbNGy [Occ=Once]
            :: a1_abMV0 -> Control.Arrow.ArrowMonad a_XbMXu b_abMV1
          [LclId] =
              [eta1_sbNGw] \r [ds_sbNGx] eta1_sbNGw;
        } in 
          Control.Arrow.$fMonadArrowMonad_$c>>=
              $dArrowApply_sbNGu eta_sbNGv sat_sbNGy;

lvl_rbNC6
  :: forall (a1 :: * -> * -> *) a2.
     [GHC.Types.Char] -> Control.Arrow.ArrowMonad a1 a2
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sbNGz] GHC.Err.errorWithoutStackTrace eta_sbNGz;

Control.Arrow.$fMonadArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     GHC.Base.Monad (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),U)>m] =
    [] \r [$dArrowApply_sbNGA]
        let {
          sat_sbNGE [Occ=Once]
            :: forall a. a -> Control.Arrow.ArrowMonad a_XbMXv a
          [LclId] =
              [$dArrowApply_sbNGA] \r [eta_B1]
                  Control.Arrow.$fMonadArrowMonad1 $dArrowApply_sbNGA eta_B1; } in
        let {
          sat_sbNGD [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMXv a
               -> Control.Arrow.ArrowMonad a_XbMXv b
               -> Control.Arrow.ArrowMonad a_XbMXv b
          [LclId] =
              [$dArrowApply_sbNGA] \r [eta_B2 eta_B1]
                  Control.Arrow.$fMonadArrowMonad_$c>>
                      $dArrowApply_sbNGA eta_B2 eta_B1; } in
        let {
          sat_sbNGC [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMXv a
               -> (a -> Control.Arrow.ArrowMonad a_XbMXv b)
               -> Control.Arrow.ArrowMonad a_XbMXv b
          [LclId] =
              [$dArrowApply_sbNGA] \r [eta_B2 eta_B1]
                  Control.Arrow.$fMonadArrowMonad_$c>>=
                      $dArrowApply_sbNGA eta_B2 eta_B1; } in
        let {
          sat_sbNGB [Occ=Once]
            :: GHC.Base.Applicative (Control.Arrow.ArrowMonad a_XbMXv)
          [LclId] =
              [$dArrowApply_sbNGA] \u []
                  Control.Arrow.$fMonadArrowMonad_$cp1Monad $dArrowApply_sbNGA;
        } in 
          GHC.Base.C:Monad [sat_sbNGB
                            sat_sbNGC
                            sat_sbNGD
                            sat_sbNGE
                            lvl_rbNC6];

Control.Arrow.$fAlternativeArrowMonad3
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     forall a1. a () a1
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LS)L),1*U(1*U(A,1*U),A)>,
 Unf=OtherCon []] =
    [] \r [$dArrowPlus_sbNGF]
        case Control.Arrow.$p1ArrowPlus $dArrowPlus_sbNGF of sat_sbNGG {
          __DEFAULT -> Control.Arrow.zeroArrow sat_sbNGG;
        };

Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     GHC.Base.Applicative (Control.Arrow.ArrowMonad a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A),A)>m,
 Unf=OtherCon []] =
    [] \r [$dArrowPlus_sbNGH]
        let {
          sat_sbNGJ [Occ=Once, Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
            :: Control.Arrow.Arrow a_XbMWB
          [LclId] =
              [$dArrowPlus_sbNGH] \u []
                  case Control.Arrow.$p1ArrowPlus $dArrowPlus_sbNGH of sat_sbNGI {
                    __DEFAULT -> Control.Arrow.$p1ArrowZero sat_sbNGI;
                  };
        } in  Control.Arrow.$fApplicativeArrowMonad sat_sbNGJ;

Control.Arrow.$fAlternativeArrowMonad1 :: forall a. () -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sbNGK] [] [];

Control.Arrow.$fAlternativeArrowMonad_$csome
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     forall a1.
     Control.Arrow.ArrowMonad a a1 -> Control.Arrow.ArrowMonad a [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LC(C(S)))LLLLL)L)L),U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A),C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowPlus_sbNGL eta_sbNGM]
        let {
          some_v_sbNGN [Occ=LoopBreaker] :: a_XbMWE () [a1_abMTU]
          [LclId] =
              [$dArrowPlus_sbNGL eta_sbNGM some_v_sbNGN] \u []
                  case
                      Control.Arrow.$p1ArrowPlus $dArrowPlus_sbNGL
                  of
                  $dApplicative_sbNGO [Dmd=<S(S(S(LC(C(S)))LLLLL)L),1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,1*C1(C1(U))),A)>]
                  { __DEFAULT ->
                        case
                            Control.Arrow.$p1ArrowZero $dApplicative_sbNGO
                        of
                        $dApplicative1_sbNGP [Dmd=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,1*C1(C1(U)))>]
                        { __DEFAULT ->
                              let {
                                sat_sbNGX [Occ=Once]
                                  :: a_XbMWE () ([a1_abMTU] -> [a1_abMTU], [a1_abMTU])
                                [LclId] =
                                    [$dArrowPlus_sbNGL
                                     eta_sbNGM
                                     some_v_sbNGN
                                     $dApplicative1_sbNGP] \u []
                                        let {
                                          sat_sbNGW [Occ=Once] :: a_XbMWE () [a1_abMTU]
                                          [LclId] =
                                              [$dArrowPlus_sbNGL
                                               some_v_sbNGN
                                               $dApplicative1_sbNGP] \u []
                                                  let {
                                                    sat_sbNGV [Occ=Once] :: a_XbMWE () [a1_abMTU]
                                                    [LclId] =
                                                        [$dApplicative1_sbNGP] \u []
                                                            Control.Arrow.arr
                                                                $dApplicative1_sbNGP
                                                                Control.Arrow.$fAlternativeArrowMonad1;
                                                  } in 
                                                    Control.Arrow.<+>
                                                        $dArrowPlus_sbNGL
                                                        some_v_sbNGN
                                                        sat_sbNGV; } in
                                        let {
                                          sat_sbNGU [Occ=Once]
                                            :: a_XbMWE () ([a1_abMTU] -> [a1_abMTU])
                                          [LclId] =
                                              [eta_sbNGM $dApplicative1_sbNGP] \u []
                                                  let {
                                                    sat_sbNGT [Occ=Once]
                                                      :: a_XbMWE a1_abMTU ([a1_abMTU] -> [a1_abMTU])
                                                    [LclId] =
                                                        [$dApplicative1_sbNGP] \u []
                                                            Control.Arrow.arr
                                                                $dApplicative1_sbNGP GHC.Types.:;
                                                  } in 
                                                    case
                                                        Control.Arrow.$p1Arrow $dApplicative1_sbNGP
                                                    of
                                                    sat_sbNGS
                                                    { __DEFAULT ->
                                                          Control.Category..
                                                              sat_sbNGS sat_sbNGT eta_sbNGM;
                                                    };
                                        } in 
                                          Control.Arrow.&&&
                                              $dApplicative1_sbNGP sat_sbNGU sat_sbNGW; } in
                              let {
                                sat_sbNGR [Occ=Once]
                                  :: a_XbMWE ([a1_abMTU] -> [a1_abMTU], [a1_abMTU]) [a1_abMTU]
                                [LclId] =
                                    [$dApplicative1_sbNGP] \u []
                                        Control.Arrow.arr
                                            $dApplicative1_sbNGP
                                            Control.Arrow.$fAlternativeArrowMonad_$capp;
                              } in 
                                case Control.Arrow.$p1Arrow $dApplicative1_sbNGP of sat_sbNGQ {
                                  __DEFAULT -> Control.Category.. sat_sbNGQ sat_sbNGR sat_sbNGX;
                                };
                        };
                  };
        } in  some_v_sbNGN;

Control.Arrow.$fAlternativeArrowMonad_$cmany
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     forall a1.
     Control.Arrow.ArrowMonad a a1 -> Control.Arrow.ArrowMonad a [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A),C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowPlus_sbNGY eta_sbNGZ]
        let {
          many_v_sbNH0 [Occ=LoopBreaker] :: a_XbMWD () [a1_abMU2]
          [LclId] =
              [$dArrowPlus_sbNGY eta_sbNGZ many_v_sbNH0] \u []
                  let {
                    $dApplicative_sbNH1 [Occ=OnceL,
                                         Dmd=<L,1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)>]
                      :: Control.Arrow.ArrowZero a_XbMWD
                    [LclId] =
                        [$dArrowPlus_sbNGY] \s []
                            Control.Arrow.$p1ArrowPlus $dArrowPlus_sbNGY; } in
                  let {
                    $dApplicative1_sbNH2 [Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
                      :: Control.Arrow.Arrow a_XbMWD
                    [LclId] =
                        [$dApplicative_sbNH1] \u []
                            Control.Arrow.$p1ArrowZero $dApplicative_sbNH1; } in
                  let {
                    sat_sbNH7 [Occ=Once] :: a_XbMWD () [a1_abMU2]
                    [LclId] =
                        [$dApplicative1_sbNH2] \u []
                            Control.Arrow.arr
                                $dApplicative1_sbNH2 Control.Arrow.$fAlternativeArrowMonad1; } in
                  let {
                    sat_sbNH6 [Occ=Once] :: a_XbMWD () [a1_abMU2]
                    [LclId] =
                        [eta_sbNGZ many_v_sbNH0 $dApplicative1_sbNH2] \u []
                            let {
                              sat_sbNH5 [Occ=Once]
                                :: Control.Arrow.ArrowMonad a_XbMWD ([a1_abMU2] -> [a1_abMU2])
                              [LclId] =
                                  [eta_sbNGZ $dApplicative1_sbNH2] \u []
                                      let {
                                        sat_sbNH4 [Occ=Once]
                                          :: a_XbMWD a1_abMU2 ([a1_abMU2] -> [a1_abMU2])
                                        [LclId] =
                                            [$dApplicative1_sbNH2] \u []
                                                Control.Arrow.arr $dApplicative1_sbNH2 GHC.Types.:;
                                      } in 
                                        case
                                            Control.Arrow.$p1Arrow $dApplicative1_sbNH2
                                        of
                                        sat_sbNH3
                                        { __DEFAULT ->
                                              Control.Category.. sat_sbNH3 sat_sbNH4 eta_sbNGZ;
                                        };
                            } in 
                              Control.Arrow.$fAlternativeArrowMonad2
                                  $dApplicative1_sbNH2 sat_sbNH5 many_v_sbNH0;
                  } in  Control.Arrow.<+> $dArrowPlus_sbNGY sat_sbNH6 sat_sbNH7;
        } in  many_v_sbNH0;

Control.Arrow.$fAlternativeArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     GHC.Base.Alternative (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),1*U),C(C1(U)))>m] =
    [] \r [$dArrowPlus_sbNH8]
        let {
          sat_sbNHf [Occ=Once]
            :: forall a.
               Control.Arrow.ArrowMonad a_XbMWC a
               -> Control.Arrow.ArrowMonad a_XbMWC [a]
          [LclId] =
              [$dArrowPlus_sbNH8] \r [eta_B1]
                  Control.Arrow.$fAlternativeArrowMonad_$cmany
                      $dArrowPlus_sbNH8 eta_B1; } in
        let {
          sat_sbNHe [Occ=Once]
            :: forall a.
               Control.Arrow.ArrowMonad a_XbMWC a
               -> Control.Arrow.ArrowMonad a_XbMWC [a]
          [LclId] =
              [$dArrowPlus_sbNH8] \r [eta_B1]
                  Control.Arrow.$fAlternativeArrowMonad_$csome
                      $dArrowPlus_sbNH8 eta_B1; } in
        let {
          sat_sbNHd [Occ=Once]
            :: forall a.
               Control.Arrow.ArrowMonad a_XbMWC a
               -> Control.Arrow.ArrowMonad a_XbMWC a
               -> Control.Arrow.ArrowMonad a_XbMWC a
          [LclId] =
              [$dArrowPlus_sbNH8] \r [ds_sbNHb ds1_sbNHc]
                  Control.Arrow.<+> $dArrowPlus_sbNH8 ds_sbNHb ds1_sbNHc; } in
        let {
          sat_sbNHa [Occ=Once]
            :: forall a. Control.Arrow.ArrowMonad a_XbMWC a
          [LclId] =
              [$dArrowPlus_sbNH8] \u []
                  Control.Arrow.$fAlternativeArrowMonad3 $dArrowPlus_sbNH8; } in
        let {
          sat_sbNH9 [Occ=Once]
            :: GHC.Base.Applicative (Control.Arrow.ArrowMonad a_XbMWC)
          [LclId] =
              [$dArrowPlus_sbNH8] \u []
                  Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative
                      $dArrowPlus_sbNH8;
        } in 
          GHC.Base.C:Alternative [sat_sbNH9
                                  sat_sbNHa
                                  sat_sbNHd
                                  sat_sbNHe
                                  sat_sbNHf];

Control.Arrow.$fMonadPlusArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     (Control.Arrow.ArrowApply a, Control.Arrow.ArrowPlus a) =>
     GHC.Base.MonadPlus (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),U)><L,U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),U),C(C1(U)))>m] =
    [] \r [$dArrowApply_sbNHg $dArrowPlus_sbNHh]
        let {
          sat_sbNHn [Occ=Once]
            :: forall a.
               Control.Arrow.ArrowMonad a_abMSU a
               -> Control.Arrow.ArrowMonad a_abMSU a
               -> Control.Arrow.ArrowMonad a_abMSU a
          [LclId] =
              [$dArrowPlus_sbNHh] \r [ds_sbNHl ds1_sbNHm]
                  Control.Arrow.<+> $dArrowPlus_sbNHh ds_sbNHl ds1_sbNHm; } in
        let {
          sat_sbNHk [Occ=Once]
            :: forall a. Control.Arrow.ArrowMonad a_abMSU a
          [LclId] =
              [$dArrowPlus_sbNHh] \u []
                  Control.Arrow.$fAlternativeArrowMonad3 $dArrowPlus_sbNHh; } in
        let {
          sat_sbNHj [Occ=Once]
            :: GHC.Base.Monad (Control.Arrow.ArrowMonad a_abMSU)
          [LclId] =
              [$dArrowApply_sbNHg] \u []
                  Control.Arrow.$fMonadArrowMonad $dArrowApply_sbNHg; } in
        let {
          sat_sbNHi [Occ=Once]
            :: GHC.Base.Alternative (Control.Arrow.ArrowMonad a_abMSU)
          [LclId] =
              [$dArrowPlus_sbNHh] \u []
                  Control.Arrow.$fAlternativeArrowMonad $dArrowPlus_sbNHh;
        } in 
          GHC.Base.C:MonadPlus [sat_sbNHi sat_sbNHj sat_sbNHk sat_sbNHn];

Control.Arrow.$fArrowLoop(->)_$cloop
  :: forall b d c. ((b, d) -> (c, d)) -> b -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U(U,U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sbNHo b1_sbNHp]
        let {
          ds_sbNHq [Occ=LoopBreaker] :: (c_abMSD, d_abMSC)
          [LclId] =
              [f_sbNHo b1_sbNHp ds_sbNHq] \u []
                  let {
                    sat_sbNHu [Occ=OnceL] :: d_abMSC
                    [LclId] =
                        [ds_sbNHq] \u []
                            case ds_sbNHq of {
                              (,) _ [Occ=Dead] d1_sbNHt [Occ=Once] -> d1_sbNHt;
                            }; } in
                  let {
                    sat_sbNHv [Occ=Once] :: (b_abMSB, d_abMSC)
                    [LclId] =
                        CCCS (,)! [b1_sbNHp sat_sbNHu];
                  } in  f_sbNHo sat_sbNHv;
        } in 
          case ds_sbNHq of {
            (,) c1_sbNHx [Occ=Once] _ [Occ=Dead] -> c1_sbNHx;
          };

Control.Arrow.$fArrowLoopKleisli1
  :: forall (m :: * -> *).
     Control.Monad.Fix.MonadFix m =>
     forall b d c. Control.Arrow.Kleisli m (b, d) (c, d) -> b -> m c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S))LLL)L),U(1*U(A,1*C1(C1(U)),A,C(U),A),1*C1(U))><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadFix_sbNHz eta_sbNHA eta1_sbNHB]
        case
            Control.Monad.Fix.$p1MonadFix $dMonadFix_sbNHz
        of
        $dMonad_sbNHC [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
        { __DEFAULT ->
              let {
                sat_sbNHN [Occ=Once] :: (c_abMRB, d_abMRA) -> m_abMRq c_abMRB
                [LclId] =
                    [$dMonad_sbNHC] \r [x1_sbNHI]
                        let {
                          sat_sbNHM [Occ=Once] :: c_abMRB
                          [LclId] =
                              [x1_sbNHI] \u []
                                  case x1_sbNHI of {
                                    (,) x_sbNHK [Occ=Once] _ [Occ=Dead] -> x_sbNHK;
                                  };
                        } in  GHC.Base.return $dMonad_sbNHC sat_sbNHM; } in
              let {
                sat_sbNHH [Occ=Once] :: m_abMRq (c_abMRB, d_abMRA)
                [LclId] =
                    [$dMonadFix_sbNHz eta_sbNHA eta1_sbNHB] \u []
                        let {
                          sat_sbNHG [Occ=Once]
                            :: (c_abMRB, d_abMRA) -> m_abMRq (c_abMRB, d_abMRA)
                          [LclId] =
                              [eta_sbNHA eta1_sbNHB] \r [y_sbNHD]
                                  let {
                                    sat_sbNHE [Occ=Once] :: d_abMRA
                                    [LclId] =
                                        [y_sbNHD] \u [] Data.Tuple.snd y_sbNHD; } in
                                  let {
                                    sat_sbNHF [Occ=Once] :: (b_abMRz, d_abMRA)
                                    [LclId] =
                                        CCCS (,)! [eta1_sbNHB sat_sbNHE];
                                  } in  eta_sbNHA sat_sbNHF;
                        } in  Control.Monad.Fix.mfix $dMonadFix_sbNHz sat_sbNHG;
              } in  GHC.Base.>>= $dMonad_sbNHC sat_sbNHH sat_sbNHN;
        };

lvl1_rbNC7 :: forall d. Data.Either.Either d d -> d
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbNHO]
        case ds_sbNHO of {
          Data.Either.Left x_sbNHQ [Occ=Once] -> x_sbNHQ;
          Data.Either.Right y_sbNHR [Occ=Once] -> y_sbNHR;
        };

Control.Arrow.$dm|||
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b d c. a b d -> a c d -> a (Data.Either.Either b c) d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)LLLL),U(1*U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A),A,A,1*C1(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowChoice_sbNHS eta_sbNHT eta1_sbNHU]
        case
            Control.Arrow.$p1ArrowChoice $dArrowChoice_sbNHS
        of
        $dArrow_sbNHV [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sbNHY [Occ=Once]
                  :: a_abMu0 (Data.Either.Either b_abMQL c_abMQN) (Data.Either.Either
                                                                     d_abMQM d_abMQM)
                [LclId] =
                    [$dArrowChoice_sbNHS eta_sbNHT eta1_sbNHU] \u []
                        Control.Arrow.+++ $dArrowChoice_sbNHS eta_sbNHT eta1_sbNHU; } in
              let {
                sat_sbNHX [Occ=Once]
                  :: a_abMu0 (Data.Either.Either d_abMQM d_abMQM) d_abMQM
                [LclId] =
                    [$dArrow_sbNHV] \u [] Control.Arrow.arr $dArrow_sbNHV lvl1_rbNC7;
              } in 
                case Control.Arrow.$p1Arrow $dArrow_sbNHV of sat_sbNHW {
                  __DEFAULT -> Control.Category.. sat_sbNHW sat_sbNHX sat_sbNHY;
                };
        };

mirror_rbNC8
  :: forall x y. Data.Either.Either x y -> Data.Either.Either y x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbNHZ]
        case ds_sbNHZ of {
          Data.Either.Left x1_sbNI1 [Occ=Once] ->
              Data.Either.Right [x1_sbNI1];
          Data.Either.Right y1_sbNI2 [Occ=Once] ->
              Data.Either.Left [y1_sbNI2];
        };

Control.Arrow.$dm+++
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c b' c'.
     a b c
     -> a b' c' -> a (Data.Either.Either b b') (Data.Either.Either c c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)LLLL),U(1*U(1*U(A,C(C1(U))),C(U),A,A,A,A),C(U),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowChoice_sbNI3 eta_sbNI4 eta1_sbNI5]
        case
            Control.Arrow.$p1ArrowChoice $dArrowChoice_sbNI3
        of
        $dArrow_sbNI6 [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),C(U),A,A,A,A)>]
        { __DEFAULT ->
              case
                  Control.Arrow.$p1Arrow $dArrow_sbNI6
              of
              $dCategory_sbNI7 [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
              { __DEFAULT ->
                    let {
                      sat_sbNId [Occ=Once]
                        :: a_abMu0 (Data.Either.Either
                                      b_abMPE b'_abMPG) (Data.Either.Either c'_abMPH c_abMPF)
                      [LclId] =
                          [$dArrowChoice_sbNI3
                           eta_sbNI4
                           eta1_sbNI5
                           $dArrow_sbNI6
                           $dCategory_sbNI7] \u []
                              let {
                                sat_sbNIc [Occ=Once]
                                  :: a_abMu0 (Data.Either.Either
                                                b_abMPE b'_abMPG) (Data.Either.Either
                                                                     b'_abMPG c_abMPF)
                                [LclId] =
                                    [$dArrowChoice_sbNI3
                                     eta_sbNI4
                                     $dArrow_sbNI6
                                     $dCategory_sbNI7] \u []
                                        let {
                                          sat_sbNIb [Occ=Once]
                                            :: a_abMu0 (Data.Either.Either
                                                          b_abMPE b'_abMPG) (Data.Either.Either
                                                                               c_abMPF b'_abMPG)
                                          [LclId] =
                                              [$dArrowChoice_sbNI3 eta_sbNI4] \u []
                                                  Control.Arrow.left
                                                      $dArrowChoice_sbNI3 eta_sbNI4; } in
                                        let {
                                          sat_sbNIa [Occ=Once]
                                            :: a_abMu0 (Data.Either.Either
                                                          c_abMPF b'_abMPG) (Data.Either.Either
                                                                               b'_abMPG c_abMPF)
                                          [LclId] =
                                              [$dArrow_sbNI6] \u []
                                                  Control.Arrow.arr $dArrow_sbNI6 mirror_rbNC8;
                                        } in 
                                          Control.Category..
                                              $dCategory_sbNI7 sat_sbNIa sat_sbNIb; } in
                              let {
                                sat_sbNI9 [Occ=Once]
                                  :: a_abMu0 (Data.Either.Either
                                                b'_abMPG c_abMPF) (Data.Either.Either
                                                                     c'_abMPH c_abMPF)
                                [LclId] =
                                    [$dArrowChoice_sbNI3 eta1_sbNI5] \u []
                                        Control.Arrow.left $dArrowChoice_sbNI3 eta1_sbNI5;
                              } in  Control.Category.. $dCategory_sbNI7 sat_sbNI9 sat_sbNIc; } in
                    let {
                      sat_sbNI8 [Occ=Once]
                        :: a_abMu0 (Data.Either.Either
                                      c'_abMPH c_abMPF) (Data.Either.Either c_abMPF c'_abMPH)
                      [LclId] =
                          [$dArrow_sbNI6] \u [] Control.Arrow.arr $dArrow_sbNI6 mirror_rbNC8;
                    } in  Control.Category.. $dCategory_sbNI7 sat_sbNI8 sat_sbNId;
              };
        };

Control.Arrow.$dmright
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c d.
     a b c -> a (Data.Either.Either d b) (Data.Either.Either d c)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),U(1*U(1*U(1*U,A),A,A,A,A,A),A,A,1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dArrowChoice_sbNIe]
        let {
          sat_sbNIh [Occ=Once] :: a_abMu0 d_abMPp d_abMPp
          [LclId] =
              [$dArrowChoice_sbNIe] \u []
                  case
                      Control.Arrow.$p1ArrowChoice $dArrowChoice_sbNIe
                  of
                  sat_sbNIf
                  { __DEFAULT ->
                        case Control.Arrow.$p1Arrow sat_sbNIf of sat_sbNIg {
                          __DEFAULT -> Control.Category.id sat_sbNIg;
                        };
                  };
        } in  Control.Arrow.+++ $dArrowChoice_sbNIe sat_sbNIh;

Control.Arrow.$dmleft
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c d.
     a b c -> a (Data.Either.Either b d) (Data.Either.Either c d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))L),U(1*U(1*U(1*U,A),A,A,A,A,A),A,A,1*C1(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowChoice_sbNIi eta_sbNIj]
        let {
          sat_sbNIm [Occ=Once] :: a_abMu0 d_abMP8 d_abMP8
          [LclId] =
              [$dArrowChoice_sbNIi] \u []
                  case
                      Control.Arrow.$p1ArrowChoice $dArrowChoice_sbNIi
                  of
                  sat_sbNIk
                  { __DEFAULT ->
                        case Control.Arrow.$p1Arrow sat_sbNIk of sat_sbNIl {
                          __DEFAULT -> Control.Category.id sat_sbNIl;
                        };
                  };
        } in  Control.Arrow.+++ $dArrowChoice_sbNIi eta_sbNIj sat_sbNIm;

lvl2_rbNC9 :: forall b. b -> (b, b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [b1_sbNIn] (,) [b1_sbNIn b1_sbNIn];

Control.Arrow.$dm&&&
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c c'. a b c -> a b c' -> a b (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,1*C1(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNIo eta_sbNIp eta1_sbNIq]
        let {
          sat_sbNIt [Occ=Once] :: a_abMuz b_abMOE (b_abMOE, b_abMOE)
          [LclId] =
              [$dArrow_sbNIo] \u []
                  Control.Arrow.arr $dArrow_sbNIo lvl2_rbNC9; } in
        let {
          sat_sbNIs [Occ=Once]
            :: a_abMuz (b_abMOE, b_abMOE) (c_abMOF, c'_abMOG)
          [LclId] =
              [$dArrow_sbNIo eta_sbNIp eta1_sbNIq] \u []
                  Control.Arrow.*** $dArrow_sbNIo eta_sbNIp eta1_sbNIq;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbNIo of sat_sbNIr {
            __DEFAULT -> Control.Category.. sat_sbNIr sat_sbNIs sat_sbNIt;
          };

swap_rbNCa :: forall b a. (b, a) -> (a, b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sbNIu]
        let {
          sat_sbNIC [Occ=Once] :: b_abMNN
          [LclId] =
              [ds_sbNIu] \u []
                  case ds_sbNIu of {
                    (,) x_sbNIA [Occ=Once] _ [Occ=Dead] -> x_sbNIA;
                  }; } in
        let {
          sat_sbNIy [Occ=Once] :: a_abMNM
          [LclId] =
              [ds_sbNIu] \u []
                  case ds_sbNIu of {
                    (,) _ [Occ=Dead] y_sbNIx [Occ=Once] -> y_sbNIx;
                  };
        } in  (,) [sat_sbNIy sat_sbNIC];

Control.Arrow.$dm***
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c b' c'. a b c -> a b' c' -> a (b, b') (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),C(U),C(U),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNID eta_sbNIE eta1_sbNIF]
        case
            Control.Arrow.$p1Arrow $dArrow_sbNID
        of
        $dCategory_sbNIG [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
        { __DEFAULT ->
              let {
                sat_sbNIM [Occ=Once]
                  :: a_abMuz (b_abMNy, b'_abMNA) (c'_abMNB, c_abMNz)
                [LclId] =
                    [$dArrow_sbNID eta_sbNIE eta1_sbNIF $dCategory_sbNIG] \u []
                        let {
                          sat_sbNIL [Occ=Once]
                            :: a_abMuz (b_abMNy, b'_abMNA) (b'_abMNA, c_abMNz)
                          [LclId] =
                              [$dArrow_sbNID eta_sbNIE $dCategory_sbNIG] \u []
                                  let {
                                    sat_sbNIK [Occ=Once]
                                      :: a_abMuz (b_abMNy, b'_abMNA) (c_abMNz, b'_abMNA)
                                    [LclId] =
                                        [$dArrow_sbNID eta_sbNIE] \u []
                                            Control.Arrow.first $dArrow_sbNID eta_sbNIE; } in
                                  let {
                                    sat_sbNIJ [Occ=Once]
                                      :: a_abMuz (c_abMNz, b'_abMNA) (b'_abMNA, c_abMNz)
                                    [LclId] =
                                        [$dArrow_sbNID] \u []
                                            Control.Arrow.arr $dArrow_sbNID swap_rbNCa;
                                  } in 
                                    Control.Category.. $dCategory_sbNIG sat_sbNIJ sat_sbNIK; } in
                        let {
                          sat_sbNII [Occ=Once]
                            :: a_abMuz (b'_abMNA, c_abMNz) (c'_abMNB, c_abMNz)
                          [LclId] =
                              [$dArrow_sbNID eta1_sbNIF] \u []
                                  Control.Arrow.first $dArrow_sbNID eta1_sbNIF;
                        } in  Control.Category.. $dCategory_sbNIG sat_sbNII sat_sbNIL; } in
              let {
                sat_sbNIH [Occ=Once]
                  :: a_abMuz (c'_abMNB, c_abMNz) (c_abMNz, c'_abMNB)
                [LclId] =
                    [$dArrow_sbNID] \u [] Control.Arrow.arr $dArrow_sbNID swap_rbNCa;
              } in  Control.Category.. $dCategory_sbNIG sat_sbNIH sat_sbNIM;
        };

Control.Arrow.$fArrowKleisli2
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c b' c'.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m b' c' -> (b, b') -> m (c, c')
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(U)><L,C(U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbNIN f_sbNIO g_sbNIP eta_sbNIQ]
        let {
          sat_sbNJg [Occ=Once]
            :: (c'_abN3d, c_abN3b) -> m_XbN5E (c_abN3b, c'_abN3d)
          [LclId] =
              [$dMonad_sbNIN] \r [eta1_sbNJ6]
                  let {
                    sat_sbNJe [Occ=Once] :: c'_abN3d
                    [LclId] =
                        [eta1_sbNJ6] \u []
                            case eta1_sbNJ6 of {
                              (,) x_sbNJc [Occ=Once] _ [Occ=Dead] -> x_sbNJc;
                            }; } in
                  let {
                    sat_sbNJa [Occ=Once] :: c_abN3b
                    [LclId] =
                        [eta1_sbNJ6] \u []
                            case eta1_sbNJ6 of {
                              (,) _ [Occ=Dead] y_sbNJ9 [Occ=Once] -> y_sbNJ9;
                            }; } in
                  let {
                    sat_sbNJf [Occ=Once] :: (c_abN3b, c'_abN3d)
                    [LclId] =
                        CCCS (,)! [sat_sbNJa sat_sbNJe];
                  } in  GHC.Base.return $dMonad_sbNIN sat_sbNJf; } in
        let {
          sat_sbNJ5 [Occ=Once] :: m_XbN5E (c'_abN3d, c_abN3b)
          [LclId] =
              [$dMonad_sbNIN f_sbNIO g_sbNIP eta_sbNIQ] \u []
                  let {
                    sat_sbNJ4 [Occ=Once]
                      :: (b'_abN3c, c_abN3b) -> m_XbN5E (c'_abN3d, c_abN3b)
                    [LclId] =
                        [$dMonad_sbNIN g_sbNIP] \r [eta_B1]
                            Control.Arrow.$fArrowKleisli3 $dMonad_sbNIN g_sbNIP eta_B1; } in
                  let {
                    sat_sbNJ3 [Occ=Once] :: m_XbN5E (b'_abN3c, c_abN3b)
                    [LclId] =
                        [$dMonad_sbNIN f_sbNIO eta_sbNIQ] \u []
                            let {
                              sat_sbNJ2 [Occ=Once]
                                :: (c_abN3b, b'_abN3c) -> m_XbN5E (b'_abN3c, c_abN3b)
                              [LclId] =
                                  [$dMonad_sbNIN] \r [eta1_sbNIS]
                                      let {
                                        sat_sbNJ0 [Occ=Once] :: c_abN3b
                                        [LclId] =
                                            [eta1_sbNIS] \u []
                                                case eta1_sbNIS of {
                                                  (,) x_sbNIY [Occ=Once] _ [Occ=Dead] -> x_sbNIY;
                                                }; } in
                                      let {
                                        sat_sbNIW [Occ=Once] :: b'_abN3c
                                        [LclId] =
                                            [eta1_sbNIS] \u []
                                                case eta1_sbNIS of {
                                                  (,) _ [Occ=Dead] y_sbNIV [Occ=Once] -> y_sbNIV;
                                                }; } in
                                      let {
                                        sat_sbNJ1 [Occ=Once] :: (b'_abN3c, c_abN3b)
                                        [LclId] =
                                            CCCS (,)! [sat_sbNIW sat_sbNJ0];
                                      } in  GHC.Base.return $dMonad_sbNIN sat_sbNJ1; } in
                            let {
                              sat_sbNIR [Occ=Once] :: m_XbN5E (c_abN3b, b'_abN3c)
                              [LclId] =
                                  [$dMonad_sbNIN f_sbNIO eta_sbNIQ] \u []
                                      Control.Arrow.$fArrowKleisli3 $dMonad_sbNIN f_sbNIO eta_sbNIQ;
                            } in  GHC.Base.>>= $dMonad_sbNIN sat_sbNIR sat_sbNJ2;
                  } in  GHC.Base.>>= $dMonad_sbNIN sat_sbNJ3 sat_sbNJ4;
        } in  GHC.Base.>>= $dMonad_sbNIN sat_sbNJ5 sat_sbNJg;

Control.Arrow.$fArrowKleisli1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c c'.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m b c' -> b -> m (c, c')
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(U)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbNJh f_sbNJi g_sbNJj eta_sbNJk]
        let {
          sat_sbNJn [Occ=Once]
            :: (b_abN3o, b_abN3o) -> m_XbN5D (c_abN3p, c'_abN3q)
          [LclId] =
              [$dMonad_sbNJh f_sbNJi g_sbNJj] \r [eta_B1]
                  Control.Arrow.$fArrowKleisli2
                      $dMonad_sbNJh f_sbNJi g_sbNJj eta_B1; } in
        let {
          sat_sbNJm [Occ=Once] :: m_XbN5D (b_abN3o, b_abN3o)
          [LclId] =
              [$dMonad_sbNJh eta_sbNJk] \u []
                  let {
                    sat_sbNJl [Occ=Once] :: (b_abN3o, b_abN3o)
                    [LclId] =
                        CCCS (,)! [eta_sbNJk eta_sbNJk];
                  } in  GHC.Base.return $dMonad_sbNJh sat_sbNJl;
        } in  GHC.Base.>>= $dMonad_sbNJh sat_sbNJm sat_sbNJn;

Control.Arrow.$fArrowKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     Control.Arrow.Arrow (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,U,A)>m] =
    [] \r [$dMonad_sbNJo]
        let {
          sat_sbNJu [Occ=Once]
            :: forall b c c'.
               Control.Arrow.Kleisli m_XbN5C b c
               -> Control.Arrow.Kleisli m_XbN5C b c'
               -> Control.Arrow.Kleisli m_XbN5C b (c, c')
          [LclId] =
              [$dMonad_sbNJo] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli1
                      $dMonad_sbNJo eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbNJt [Occ=Once]
            :: forall b c b' c'.
               Control.Arrow.Kleisli m_XbN5C b c
               -> Control.Arrow.Kleisli m_XbN5C b' c'
               -> Control.Arrow.Kleisli m_XbN5C (b, b') (c, c')
          [LclId] =
              [$dMonad_sbNJo] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli2
                      $dMonad_sbNJo eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbNJs [Occ=Once]
            :: forall b c d.
               Control.Arrow.Kleisli m_XbN5C b c
               -> Control.Arrow.Kleisli m_XbN5C (d, b) (d, c)
          [LclId] =
              [$dMonad_sbNJo] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli4 $dMonad_sbNJo eta_B2 eta_B1; } in
        let {
          sat_sbNJr [Occ=Once]
            :: forall b c d.
               Control.Arrow.Kleisli m_XbN5C b c
               -> Control.Arrow.Kleisli m_XbN5C (b, d) (c, d)
          [LclId] =
              [$dMonad_sbNJo] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli3 $dMonad_sbNJo eta_B2 eta_B1; } in
        let {
          sat_sbNJq [Occ=Once]
            :: forall b c. (b -> c) -> Control.Arrow.Kleisli m_XbN5C b c
          [LclId] =
              [$dMonad_sbNJo] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli5 $dMonad_sbNJo eta_B2 eta_B1; } in
        let {
          sat_sbNJp [Occ=Once]
            :: Control.Category.Category (Control.Arrow.Kleisli m_XbN5C)
          [LclId] =
              [$dMonad_sbNJo] \u []
                  Control.Arrow.$fCategoryTYPEKleisli $dMonad_sbNJo;
        } in 
          Control.Arrow.C:Arrow [sat_sbNJp
                                 sat_sbNJq
                                 sat_sbNJr
                                 sat_sbNJs
                                 sat_sbNJt
                                 sat_sbNJu];

Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop
  :: forall (m :: * -> *).
     Control.Monad.Fix.MonadFix m =>
     Control.Arrow.Arrow (Control.Arrow.Kleisli m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,U,A),A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadFix_sbNJv]
        let {
          sat_sbNJw [Occ=Once, Dmd=<L,U(A,C(C1(U)),A,U,A)>]
            :: GHC.Base.Monad m_XbMVo
          [LclId] =
              [$dMonadFix_sbNJv] \u []
                  Control.Monad.Fix.$p1MonadFix $dMonadFix_sbNJv;
        } in  Control.Arrow.$fArrowKleisli sat_sbNJw;

Control.Arrow.$fArrowLoopKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     Control.Monad.Fix.MonadFix m =>
     Control.Arrow.ArrowLoop (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U)),A,U,A),C(U))>m] =
    [] \r [$dMonadFix_sbNJx]
        let {
          sat_sbNJz [Occ=Once]
            :: forall b d c.
               Control.Arrow.Kleisli m_XbMVp (b, d) (c, d)
               -> Control.Arrow.Kleisli m_XbMVp b c
          [LclId] =
              [$dMonadFix_sbNJx] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowLoopKleisli1
                      $dMonadFix_sbNJx eta_B2 eta_B1; } in
        let {
          sat_sbNJy [Occ=Once]
            :: Control.Arrow.Arrow (Control.Arrow.Kleisli m_XbMVp)
          [LclId] =
              [$dMonadFix_sbNJx] \u []
                  Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop $dMonadFix_sbNJx;
        } in  Control.Arrow.C:ArrowLoop [sat_sbNJy sat_sbNJz];

lvl3_rbNCb
  :: forall (m :: * -> *) b c.
     (Control.Arrow.Kleisli m b c, b) -> m c
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),U)>,
 Unf=OtherCon []] =
    [] \r [ds_sbNJA]
        case ds_sbNJA of {
          (,) ds1_sbNJC [Occ=Once] x_sbNJD [Occ=Once] -> ds1_sbNJC x_sbNJD;
        };

Control.Arrow.$fArrowApplyKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     Control.Arrow.ArrowApply (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,U,A)>m] =
    [] \r [$dMonad_sbNJE]
        let {
          sat_sbNJF [Occ=Once]
            :: Control.Arrow.Arrow (Control.Arrow.Kleisli m_XbN1f)
          [LclId] =
              [$dMonad_sbNJE] \u [] Control.Arrow.$fArrowKleisli $dMonad_sbNJE;
        } in  Control.Arrow.C:ArrowApply [sat_sbNJF lvl3_rbNCb];

Control.Arrow.$fArrowChoiceKleisli1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c b' c'.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m b' c'
     -> Data.Either.Either b b'
     -> m (Data.Either.Either c c')
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbNJG f_sbNJH g_sbNJI eta_sbNJJ]
        case eta_sbNJJ of {
          Data.Either.Left x_sbNJL [Occ=Once] ->
              let {
                sat_sbNJP [Occ=Once]
                  :: c_abMYX -> m_XbN1R (Data.Either.Either c_abMYX c'_abMYZ)
                [LclId] =
                    [$dMonad_sbNJG] \r [eta1_sbNJN]
                        let {
                          sat_sbNJO [Occ=Once] :: Data.Either.Either c_abMYX c'_abMYZ
                          [LclId] =
                              CCCS Data.Either.Left! [eta1_sbNJN];
                        } in  GHC.Base.return $dMonad_sbNJG sat_sbNJO; } in
              let {
                sat_sbNJM [Occ=Once] :: m_XbN1R c_abMYX
                [LclId] =
                    [f_sbNJH x_sbNJL] \u [] f_sbNJH x_sbNJL;
              } in  GHC.Base.>>= $dMonad_sbNJG sat_sbNJM sat_sbNJP;
          Data.Either.Right y_sbNJQ [Occ=Once] ->
              let {
                sat_sbNJU [Occ=Once]
                  :: c'_abMYZ -> m_XbN1R (Data.Either.Either c_abMYX c'_abMYZ)
                [LclId] =
                    [$dMonad_sbNJG] \r [eta1_sbNJS]
                        let {
                          sat_sbNJT [Occ=Once] :: Data.Either.Either c_abMYX c'_abMYZ
                          [LclId] =
                              CCCS Data.Either.Right! [eta1_sbNJS];
                        } in  GHC.Base.return $dMonad_sbNJG sat_sbNJT; } in
              let {
                sat_sbNJR [Occ=Once] :: m_XbN1R c'_abMYZ
                [LclId] =
                    [g_sbNJI y_sbNJQ] \u [] g_sbNJI y_sbNJQ;
              } in  GHC.Base.>>= $dMonad_sbNJG sat_sbNJR sat_sbNJU;
        };

Control.Arrow.$fArrowChoiceKleisli3
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c d.
     Control.Arrow.Kleisli m b c
     -> Data.Either.Either b d -> m (Data.Either.Either c d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbNJV f_sbNJW eta_sbNJX]
        let {
          sat_sbNJZ [Occ=Once]
            :: Control.Arrow.Kleisli m_XbN1Q d_abMYe d_abMYe
          [LclId] =
              [$dMonad_sbNJV] \r [eta1_sbNJY]
                  GHC.Base.return $dMonad_sbNJV eta1_sbNJY;
        } in 
          Control.Arrow.$fArrowChoiceKleisli1
              $dMonad_sbNJV f_sbNJW sat_sbNJZ eta_sbNJX;

Control.Arrow.$fArrowChoiceKleisli2
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c d.
     Control.Arrow.Kleisli m b c
     -> Data.Either.Either d b -> m (Data.Either.Either d c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbNK0 f_sbNK1 eta_sbNK2]
        let {
          sat_sbNK4 [Occ=Once]
            :: Control.Arrow.Kleisli m_XbN1P d_abMYB d_abMYB
          [LclId] =
              [$dMonad_sbNK0] \r [eta1_sbNK3]
                  GHC.Base.return $dMonad_sbNK0 eta1_sbNK3;
        } in 
          Control.Arrow.$fArrowChoiceKleisli1
              $dMonad_sbNK0 sat_sbNK4 f_sbNK1 eta_sbNK2;

lvl4_rbNCc
  :: forall (m :: * -> *) b d c.
     Control.Arrow.Kleisli m b d
     -> Control.Arrow.Kleisli m c d -> Data.Either.Either b c -> m d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbNK5 ds1_sbNK6 eta_sbNK7]
        Data.Either.either ds_sbNK5 ds1_sbNK6 eta_sbNK7;

Control.Arrow.$fArrowChoiceKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     Control.Arrow.ArrowChoice (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,U,A)>m] =
    [] \r [$dMonad_sbNK8]
        let {
          sat_sbNKc [Occ=Once]
            :: forall b c b' c'.
               Control.Arrow.Kleisli m_XbN1O b c
               -> Control.Arrow.Kleisli m_XbN1O b' c'
               -> Control.Arrow.Kleisli
                    m_XbN1O (Data.Either.Either b b') (Data.Either.Either c c')
          [LclId] =
              [$dMonad_sbNK8] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fArrowChoiceKleisli1
                      $dMonad_sbNK8 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbNKb [Occ=Once]
            :: forall b c d.
               Control.Arrow.Kleisli m_XbN1O b c
               -> Control.Arrow.Kleisli
                    m_XbN1O (Data.Either.Either d b) (Data.Either.Either d c)
          [LclId] =
              [$dMonad_sbNK8] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowChoiceKleisli2
                      $dMonad_sbNK8 eta_B2 eta_B1; } in
        let {
          sat_sbNKa [Occ=Once]
            :: forall b c d.
               Control.Arrow.Kleisli m_XbN1O b c
               -> Control.Arrow.Kleisli
                    m_XbN1O (Data.Either.Either b d) (Data.Either.Either c d)
          [LclId] =
              [$dMonad_sbNK8] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowChoiceKleisli3
                      $dMonad_sbNK8 eta_B2 eta_B1; } in
        let {
          sat_sbNK9 [Occ=Once]
            :: Control.Arrow.Arrow (Control.Arrow.Kleisli m_XbN1O)
          [LclId] =
              [$dMonad_sbNK8] \u [] Control.Arrow.$fArrowKleisli $dMonad_sbNK8;
        } in 
          Control.Arrow.C:ArrowChoice [sat_sbNK9
                                       sat_sbNKa
                                       sat_sbNKb
                                       sat_sbNKc
                                       lvl4_rbNCc];

Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Control.Arrow.Arrow (Control.Arrow.Kleisli m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(A,C(C1(U)),A,U,A),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbNKd]
        let {
          sat_sbNKe [Occ=Once, Dmd=<L,U(A,C(C1(U)),A,U,A)>]
            :: GHC.Base.Monad m_XbN5r
          [LclId] =
              [$dMonadPlus_sbNKd] \u [] GHC.Base.$p2MonadPlus $dMonadPlus_sbNKd;
        } in  Control.Arrow.$fArrowKleisli sat_sbNKe;

Control.Arrow.$fArrowZeroKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Control.Arrow.ArrowZero (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U(A,C(C1(U)),A,U,A),1*U,A)>m] =
    [] \r [$dMonadPlus_sbNKf]
        let {
          lvl5_sbNKg [Occ=OnceL] :: forall c. m_XbN5s c
          [LclId] =
              [$dMonadPlus_sbNKf] \u [] GHC.Base.mzero $dMonadPlus_sbNKf; } in
        let {
          sat_sbNKj [Occ=Once]
            :: forall b c. Control.Arrow.Kleisli m_XbN5s b c
          [LclId] =
              [lvl5_sbNKg] \r [ds_sbNKi] lvl5_sbNKg; } in
        let {
          sat_sbNKh [Occ=Once]
            :: Control.Arrow.Arrow (Control.Arrow.Kleisli m_XbN5s)
          [LclId] =
              [$dMonadPlus_sbNKf] \u []
                  Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero $dMonadPlus_sbNKf;
        } in  Control.Arrow.C:ArrowZero [sat_sbNKh sat_sbNKj];

Control.Arrow.$fArrowPlusKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Control.Arrow.ArrowPlus (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,U(A,C(C1(U)),A,U,A),U,C(C1(U)))>m] =
    [] \r [$dMonadPlus_sbNKk]
        let {
          sat_sbNKm [Occ=Once]
            :: forall b c.
               Control.Arrow.Kleisli m_XbN58 b c
               -> Control.Arrow.Kleisli m_XbN58 b c
               -> Control.Arrow.Kleisli m_XbN58 b c
          [LclId] =
              [$dMonadPlus_sbNKk] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fArrowPlusKleisli1
                      $dMonadPlus_sbNKk eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbNKl [Occ=Once]
            :: Control.Arrow.ArrowZero (Control.Arrow.Kleisli m_XbN58)
          [LclId] =
              [$dMonadPlus_sbNKk] \u []
                  Control.Arrow.$fArrowZeroKleisli $dMonadPlus_sbNKk;
        } in  Control.Arrow.C:ArrowPlus [sat_sbNKl sat_sbNKm];

Control.Arrow.$dmsecond
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c d. a b c -> a (d, b) (d, c)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLC(S)L),U(1*U(1*U,A),A,A,A,1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNKn]
        let {
          sat_sbNKp [Occ=Once] :: a_abMuz d_abMNj d_abMNj
          [LclId] =
              [$dArrow_sbNKn] \u []
                  case Control.Arrow.$p1Arrow $dArrow_sbNKn of sat_sbNKo {
                    __DEFAULT -> Control.Category.id sat_sbNKo;
                  };
        } in  Control.Arrow.*** $dArrow_sbNKn sat_sbNKp;

Control.Arrow.$dmfirst
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c d. a b c -> a (b, d) (c, d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLC(C(S))L),U(1*U(1*U,A),A,A,A,1*C1(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNKq eta_sbNKr]
        let {
          sat_sbNKt [Occ=Once] :: a_abMuz d_abMN2 d_abMN2
          [LclId] =
              [$dArrow_sbNKq] \u []
                  case Control.Arrow.$p1Arrow $dArrow_sbNKq of sat_sbNKs {
                    __DEFAULT -> Control.Category.id sat_sbNKs;
                  };
        } in  Control.Arrow.*** $dArrow_sbNKq eta_sbNKr sat_sbNKt;

Control.Arrow.$cfirst :: forall b c d. (b -> c) -> (b, d) -> (c, d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sbNKu ds1_sbNKv]
        let {
          sat_sbNKE [Occ=Once] :: d_abN4j
          [LclId] =
              [ds1_sbNKv] \u []
                  case ds1_sbNKv of {
                    (,) _ [Occ=Dead] y_sbNKD [Occ=Once] -> y_sbNKD;
                  }; } in
        let {
          sat_sbNKA [Occ=Once] :: c_abN4i
          [LclId] =
              [ds_sbNKu ds1_sbNKv] \u []
                  let {
                    sat_sbNKz [Occ=Once] :: b_abN4h
                    [LclId] =
                        [ds1_sbNKv] \u []
                            case ds1_sbNKv of {
                              (,) x_sbNKx [Occ=Once] _ [Occ=Dead] -> x_sbNKx;
                            };
                  } in  ds_sbNKu sat_sbNKz;
        } in  (,) [sat_sbNKA sat_sbNKE];

Control.Arrow.$csecond
  :: forall b c d. (b -> c) -> (d, b) -> (d, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sbNKF ds_sbNKG]
        let {
          sat_sbNKP [Occ=Once] :: c_abN4u
          [LclId] =
              [g_sbNKF ds_sbNKG] \u []
                  let {
                    sat_sbNKO [Occ=Once] :: b_abN4t
                    [LclId] =
                        [ds_sbNKG] \u []
                            case ds_sbNKG of {
                              (,) _ [Occ=Dead] y_sbNKN [Occ=Once] -> y_sbNKN;
                            };
                  } in  g_sbNKF sat_sbNKO; } in
        let {
          sat_sbNKK [Occ=Once] :: d_abN4v
          [LclId] =
              [ds_sbNKG] \u []
                  case ds_sbNKG of {
                    (,) x_sbNKI [Occ=Once] _ [Occ=Dead] -> x_sbNKI;
                  };
        } in  (,) [sat_sbNKK sat_sbNKP];

Control.Arrow.$c&&&
  :: forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [f_sbNKQ g_sbNKR eta_sbNKS]
        let {
          sat_sbNKU [Occ=Once] :: c'_abN4P
          [LclId] =
              [g_sbNKR eta_sbNKS] \u [] g_sbNKR eta_sbNKS; } in
        let {
          sat_sbNKT [Occ=Once] :: c_abN4O
          [LclId] =
              [f_sbNKQ eta_sbNKS] \u [] f_sbNKQ eta_sbNKS;
        } in  (,) [sat_sbNKT sat_sbNKU];

Control.Arrow.$fArrow(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Arrow.Arrow (->)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Arrow.C:Arrow! [Control.Category.$fCategoryTYPE(->)
                                          Control.Arrow.$fArrow(->)_$carr
                                          Control.Arrow.$cfirst
                                          Control.Arrow.$csecond
                                          Control.Arrow.$c***
                                          Control.Arrow.$c&&&];

Control.Arrow.$fArrowLoop(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Arrow.ArrowLoop (->)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Arrow.C:ArrowLoop! [Control.Arrow.$fArrow(->)
                                              Control.Arrow.$fArrowLoop(->)_$cloop];

Control.Arrow.$fArrowApply(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Arrow.ArrowApply (->)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Arrow.C:ArrowApply! [Control.Arrow.$fArrow(->)
                                               Control.Arrow.$fAlternativeArrowMonad_$capp];

Control.Arrow.$c+++
  :: forall b c b' c'.
     (b -> c)
     -> (b' -> c') -> Data.Either.Either b b' -> Data.Either.Either c c'
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sbNKV g_sbNKW ds1_sbNKX]
        case ds1_sbNKX of {
          Data.Either.Left x_sbNKZ [Occ=Once] ->
              let {
                sat_sbNL0 [Occ=Once] :: c_abN0A
                [LclId] =
                    [f_sbNKV x_sbNKZ] \u [] f_sbNKV x_sbNKZ;
              } in  Data.Either.Left [sat_sbNL0];
          Data.Either.Right y_sbNL1 [Occ=Once] ->
              let {
                sat_sbNL2 [Occ=Once] :: c'_abN0C
                [LclId] =
                    [g_sbNKW y_sbNL1] \u [] g_sbNKW y_sbNL1;
              } in  Data.Either.Right [sat_sbNL2];
        };

Control.Arrow.$cright
  :: forall b c d.
     (b -> c) -> Data.Either.Either d b -> Data.Either.Either d c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sbNL3 ds1_sbNL4]
        case ds1_sbNL4 of {
          Data.Either.Left x_sbNL6 [Occ=Once] -> wild_sbNL5;
          Data.Either.Right y_sbNL7 [Occ=Once] ->
              let {
                sat_sbNL8 [Occ=Once] :: c_abN0g
                [LclId] =
                    [f_sbNL3 y_sbNL7] \u [] f_sbNL3 y_sbNL7;
              } in  Data.Either.Right [sat_sbNL8];
        };

Control.Arrow.$cleft
  :: forall b c d.
     (b -> c) -> Data.Either.Either b d -> Data.Either.Either c d
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sbNL9 ds1_sbNLa]
        case ds1_sbNLa of {
          Data.Either.Left x_sbNLc [Occ=Once] ->
              let {
                sat_sbNLd [Occ=Once] :: c_abMZW
                [LclId] =
                    [f_sbNL9 x_sbNLc] \u [] f_sbNL9 x_sbNLc;
              } in  Data.Either.Left [sat_sbNLd];
          Data.Either.Right y_sbNLe [Occ=Once] -> wild_sbNLb;
        };

Control.Arrow.$fArrowChoice(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Arrow.ArrowChoice (->)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Arrow.C:ArrowChoice! [Control.Arrow.$fArrow(->)
                                                Control.Arrow.$cleft
                                                Control.Arrow.$cright
                                                Control.Arrow.$c+++
                                                Data.Either.either];

Control.Arrow.runKleisli1
  :: forall (m :: * -> *) a b.
     Control.Arrow.Kleisli m a b -> Control.Arrow.Kleisli m a b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbNLf] ds_sbNLf;

Control.Arrow.runKleisli
  :: forall (m :: * -> *) a b.
     Control.Arrow.Kleisli m a b -> a -> m b
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Control.Arrow.runKleisli1 eta_B1;

Control.Arrow.returnA
  :: forall (a :: * -> * -> *) b. Control.Arrow.Arrow a => a b b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNLg] Control.Arrow.arr $dArrow_sbNLg GHC.Base.id;

Control.Arrow.^>>
  :: forall (a :: * -> * -> *) b c d.
     Control.Arrow.Arrow a =>
     (b -> c) -> a c d -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNLh eta_sbNLi eta1_sbNLj]
        let {
          sat_sbNLl [Occ=Once] :: a_abMMs b_abMMt c_abMMu
          [LclId] =
              [$dArrow_sbNLh eta_sbNLi] \u []
                  Control.Arrow.arr $dArrow_sbNLh eta_sbNLi;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbNLh of sat_sbNLk {
            __DEFAULT -> Control.Category.. sat_sbNLk eta1_sbNLj sat_sbNLl;
          };

Control.Arrow.>>^
  :: forall (a :: * -> * -> *) b c d.
     Control.Arrow.Arrow a =>
     a b c -> (c -> d) -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNLm eta_sbNLn eta1_sbNLo]
        let {
          sat_sbNLq [Occ=Once] :: a_abMMb c_abMMd d_abMMe
          [LclId] =
              [$dArrow_sbNLm eta1_sbNLo] \u []
                  Control.Arrow.arr $dArrow_sbNLm eta1_sbNLo;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbNLm of sat_sbNLp {
            __DEFAULT -> Control.Category.. sat_sbNLp sat_sbNLq eta_sbNLn;
          };

Control.Arrow.<<^
  :: forall (a :: * -> * -> *) c d b.
     Control.Arrow.Arrow a =>
     a c d -> (b -> c) -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNLr eta_sbNLs eta1_sbNLt]
        let {
          sat_sbNLv [Occ=Once] :: a_abMLU b_abMLX c_abMLV
          [LclId] =
              [$dArrow_sbNLr eta1_sbNLt] \u []
                  Control.Arrow.arr $dArrow_sbNLr eta1_sbNLt;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbNLr of sat_sbNLu {
            __DEFAULT -> Control.Category.. sat_sbNLu eta_sbNLs sat_sbNLv;
          };

Control.Arrow.^<<
  :: forall (a :: * -> * -> *) c d b.
     Control.Arrow.Arrow a =>
     (c -> d) -> a b c -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbNLw eta_sbNLx eta1_sbNLy]
        let {
          sat_sbNLA [Occ=Once] :: a_abMLx c_abMLy d_abMLz
          [LclId] =
              [$dArrow_sbNLw eta_sbNLx] \u []
                  Control.Arrow.arr $dArrow_sbNLw eta_sbNLx;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbNLw of sat_sbNLz {
            __DEFAULT -> Control.Category.. sat_sbNLz sat_sbNLA eta1_sbNLy;
          };

Control.Arrow.leftApp
  :: forall (a :: * -> * -> *) b c d.
     Control.Arrow.ArrowApply a =>
     a b c -> a (Data.Either.Either b d) (Data.Either.Either c d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(1*U(1*U(A,C(C1(U))),C(U),A,A,A,A),1*U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbNLB eta_sbNLC]
        case
            Control.Arrow.$p1ArrowApply $dArrowApply_sbNLB
        of
        $dArrow_sbNLD [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),C(U),A,A,A,A)>]
        { __DEFAULT ->
              case
                  Control.Arrow.$p1Arrow $dArrow_sbNLD
              of
              $dCategory_sbNLE [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
              { __DEFAULT ->
                    let {
                      sat_sbNLX [Occ=Once]
                        :: a_abMK6 (Data.Either.Either
                                      b_abMK7 d_abMK9) (a_abMK6 () (Data.Either.Either
                                                                      c_abMK8 d_abMK9),
                                                        ())
                      [LclId] =
                          [eta_sbNLC $dArrow_sbNLD $dCategory_sbNLE] \u []
                              let {
                                lvl5_sbNLG [Occ=OnceL]
                                  :: a_abMK6 c_abMK8 (Data.Either.Either c_abMK8 d_abMK9)
                                [LclId] =
                                    [$dArrow_sbNLD] \u []
                                        Control.Arrow.arr $dArrow_sbNLD Data.Either.Left; } in
                              let {
                                sat_sbNLW [Occ=Once]
                                  :: Data.Either.Either b_abMK7 d_abMK9
                                     -> (a_abMK6 () (Data.Either.Either c_abMK8 d_abMK9), ())
                                [LclId] =
                                    [eta_sbNLC
                                     $dArrow_sbNLD
                                     $dCategory_sbNLE
                                     lvl5_sbNLG] \r [ds1_sbNLH]
                                        case ds1_sbNLH of {
                                          Data.Either.Left x_sbNLJ [Occ=OnceL] ->
                                              let {
                                                sat_sbNLP [Occ=Once]
                                                  :: a_abMK6 () (Data.Either.Either c_abMK8 d_abMK9)
                                                [LclId] =
                                                    [eta_sbNLC
                                                     $dArrow_sbNLD
                                                     $dCategory_sbNLE
                                                     lvl5_sbNLG
                                                     x_sbNLJ] \u []
                                                        let {
                                                          sat_sbNLO [Occ=Once] :: a_abMK6 () c_abMK8
                                                          [LclId] =
                                                              [eta_sbNLC
                                                               $dArrow_sbNLD
                                                               $dCategory_sbNLE
                                                               x_sbNLJ] \u []
                                                                  let {
                                                                    sat_sbNLN [Occ=Once]
                                                                      :: a_abMK6 () b_abMK7
                                                                    [LclId] =
                                                                        [$dArrow_sbNLD
                                                                         x_sbNLJ] \u []
                                                                            let {
                                                                              sat_sbNLM [Occ=Once]
                                                                                :: () -> b_abMK7
                                                                              [LclId] =
                                                                                  [x_sbNLJ] \r [ds_sbNLK]
                                                                                      case
                                                                                          ds_sbNLK
                                                                                      of
                                                                                      { () ->
                                                                                            x_sbNLJ;
                                                                                      };
                                                                            } in 
                                                                              Control.Arrow.arr
                                                                                  $dArrow_sbNLD
                                                                                  sat_sbNLM;
                                                                  } in 
                                                                    Control.Category..
                                                                        $dCategory_sbNLE
                                                                        eta_sbNLC
                                                                        sat_sbNLN;
                                                        } in 
                                                          Control.Category..
                                                              $dCategory_sbNLE lvl5_sbNLG sat_sbNLO;
                                              } in  (,) [sat_sbNLP GHC.Tuple.()];
                                          Data.Either.Right y_sbNLQ [Occ=OnceL] ->
                                              let {
                                                sat_sbNLV [Occ=Once]
                                                  :: a_abMK6 () (Data.Either.Either c_abMK8 d_abMK9)
                                                [LclId] =
                                                    [$dArrow_sbNLD y_sbNLQ] \u []
                                                        let {
                                                          sat_sbNLU [Occ=Once]
                                                            :: ()
                                                               -> Data.Either.Either c_abMK8 d_abMK9
                                                          [LclId] =
                                                              [y_sbNLQ] \r [x_sbNLR]
                                                                  let {
                                                                    sat_sbNLT [Occ=Once] :: d_abMK9
                                                                    [LclId] =
                                                                        [y_sbNLQ x_sbNLR] \u []
                                                                            case x_sbNLR of {
                                                                              () -> y_sbNLQ;
                                                                            };
                                                                  } in 
                                                                    Data.Either.Right [sat_sbNLT];
                                                        } in 
                                                          Control.Arrow.arr $dArrow_sbNLD sat_sbNLU;
                                              } in  (,) [sat_sbNLV GHC.Tuple.()];
                                        };
                              } in  Control.Arrow.arr $dArrow_sbNLD sat_sbNLW; } in
                    let {
                      sat_sbNLF [Occ=Once]
                        :: a_abMK6 (a_abMK6 () (Data.Either.Either c_abMK8 d_abMK9),
                                    ()) (Data.Either.Either c_abMK8 d_abMK9)
                      [LclId] =
                          [$dArrowApply_sbNLB] \u [] Control.Arrow.app $dArrowApply_sbNLB;
                    } in  Control.Category.. $dCategory_sbNLE sat_sbNLF sat_sbNLX;
              };
        };

Control.Arrow.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Control.Arrow.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$trModule4];

Control.Arrow.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Control.Arrow"#;

Control.Arrow.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$trModule2];

Control.Arrow.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Control.Arrow.$trModule3
                                     Control.Arrow.$trModule1];

$krep_rbNCd :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Tuple.$tc()
                                              GHC.Types.[]];

$krep1_rbNCe :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Control.Arrow.$tcKleisli1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         GHC.Types.krep$*->*->*];

Control.Arrow.$tcArrow1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep1_rbNCe];

Control.Arrow.$tcArrowMonad1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         GHC.Types.krep$*Arr*];

$krep2_rbNCf :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep3_rbNCg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep4_rbNCh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep5_rbNCi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_rbNCh $krep2_rbNCf];

$krep6_rbNCj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rbNCg $krep5_rbNCi];

$krep7_rbNCk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_rbNCh $krep_rbNCd];

$krep8_rbNCl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep7_rbNCk $krep3_rbNCg];

Control.Arrow.$tcArrow3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Arrow"#;

Control.Arrow.$tcArrow2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrow3];

Control.Arrow.$tcArrow :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12964584583212294992##
                                    10211991410748124746##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrow2
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcKleisli3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Kleisli"#;

Control.Arrow.$tcKleisli2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcKleisli3];

Control.Arrow.$tcKleisli :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2023158159015915132##
                                    6143719008973118504##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcKleisli2
                                    0#
                                    Control.Arrow.$tcKleisli1];

$krep9_rbNCm :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rbNCf GHC.Types.[]];

$krep10_rbNCn :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_rbNCg $krep9_rbNCm];

$krep11_rbNCo :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_rbNCh $krep10_rbNCn];

$krep12_rbNCp :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Arrow.$tcKleisli
                                              $krep11_rbNCo];

Control.Arrow.$tc'Kleisli1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_rbNCj $krep12_rbNCp];

Control.Arrow.$tc'Kleisli3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Kleisli"#;

Control.Arrow.$tc'Kleisli2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tc'Kleisli3];

Control.Arrow.$tc'Kleisli :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [793719726112502834##
                                    14919550952510816382##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tc'Kleisli2
                                    3#
                                    Control.Arrow.$tc'Kleisli1];

Control.Arrow.$tcArrowZero2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowZero"#;

Control.Arrow.$tcArrowZero1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowZero2];

Control.Arrow.$tcArrowZero :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [337582314637215801##
                                    485553589222180171##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowZero1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcArrowPlus2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowPlus"#;

Control.Arrow.$tcArrowPlus1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowPlus2];

Control.Arrow.$tcArrowPlus :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9089885184909062397##
                                    13092571182525076608##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowPlus1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcArrowChoice2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowChoice"#;

Control.Arrow.$tcArrowChoice1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowChoice2];

Control.Arrow.$tcArrowChoice :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9045385674203608923##
                                    4474606397073518393##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowChoice1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcArrowApply2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowApply"#;

Control.Arrow.$tcArrowApply1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowApply2];

Control.Arrow.$tcArrowApply :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4969046276209689969##
                                    2697302259091605677##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowApply1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcArrowMonad3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowMonad"#;

Control.Arrow.$tcArrowMonad2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowMonad3];

Control.Arrow.$tcArrowMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2648525758856951758##
                                    13692351200590237690##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowMonad2
                                    0#
                                    Control.Arrow.$tcArrowMonad1];

$krep13_rbNCq :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_rbNCg GHC.Types.[]];

$krep14_rbNCr :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_rbNCh $krep13_rbNCq];

$krep15_rbNCs :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Arrow.$tcArrowMonad
                                              $krep14_rbNCr];

Control.Arrow.$tc'ArrowMonad1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_rbNCl $krep15_rbNCs];

Control.Arrow.$tc'ArrowMonad3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'ArrowMonad"#;

Control.Arrow.$tc'ArrowMonad2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tc'ArrowMonad3];

Control.Arrow.$tc'ArrowMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8781545391513276915##
                                    783725375361948493##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tc'ArrowMonad2
                                    2#
                                    Control.Arrow.$tc'ArrowMonad1];

Control.Arrow.$tcArrowLoop2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowLoop"#;

Control.Arrow.$tcArrowLoop1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowLoop2];

Control.Arrow.$tcArrowLoop :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15298492960828880948##
                                    13953070859738786616##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowLoop1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.C:ArrowLoop
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     (forall b d c. a (b, d) (c, d) -> a b c)
     -> Control.Arrow.ArrowLoop a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Control.Arrow.C:ArrowLoop [eta_B2 eta_B1];

Control.Arrow.C:ArrowApply
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     (forall b c. a (a b c, b) c) -> Control.Arrow.ArrowApply a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Control.Arrow.C:ArrowApply [eta_B2 eta_B1];

Control.Arrow.C:ArrowChoice
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     (forall b c d.
      a b c -> a (Data.Either.Either b d) (Data.Either.Either c d))
     -> (forall b c d.
         a b c -> a (Data.Either.Either d b) (Data.Either.Either d c))
     -> (forall b c b' c'.
         a b c
         -> a b' c'
         -> a (Data.Either.Either b b') (Data.Either.Either c c'))
     -> (forall b d c. a b d -> a c d -> a (Data.Either.Either b c) d)
     -> Control.Arrow.ArrowChoice a
[GblId[DataCon],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Control.Arrow.C:ArrowChoice [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];

Control.Arrow.C:ArrowPlus
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowZero a =>
     (forall b c. a b c -> a b c -> a b c) -> Control.Arrow.ArrowPlus a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Control.Arrow.C:ArrowPlus [eta_B2 eta_B1];

Control.Arrow.C:ArrowZero
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     (forall b c. a b c) -> Control.Arrow.ArrowZero a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Control.Arrow.C:ArrowZero [eta_B2 eta_B1];

Control.Arrow.C:Arrow
  :: forall (a :: * -> * -> *).
     Control.Category.Category a =>
     (forall b c. (b -> c) -> a b c)
     -> (forall b c d. a b c -> a (b, d) (c, d))
     -> (forall b c d. a b c -> a (d, b) (d, c))
     -> (forall b c b' c'. a b c -> a b' c' -> a (b, b') (c, c'))
     -> (forall b c c'. a b c -> a b c' -> a b (c, c'))
     -> Control.Arrow.Arrow a
[GblId[DataCon],
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Control.Arrow.C:Arrow [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];


==================== Pre unarise: ====================
2018-03-16 16:06:43.665048384 UTC

Control.Arrow.$p1ArrowLoop
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowLoop a =>
     Control.Arrow.Arrow a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sbQ5u]
        case v_sbQ5u of {
          Control.Arrow.C:ArrowLoop v_sbQ5w [Occ=Once] _ [Occ=Dead] ->
              v_sbQ5w;
        };

Control.Arrow.loop
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowLoop a =>
     forall b d c. a (b, d) (c, d) -> a b c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sbQ5y]
        case v_sbQ5y of {
          Control.Arrow.C:ArrowLoop _ [Occ=Dead] v_sbQ5B [Occ=Once] ->
              v_sbQ5B;
        };

Control.Arrow.$p1ArrowApply
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     Control.Arrow.Arrow a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sbQ5C]
        case v_sbQ5C of {
          Control.Arrow.C:ArrowApply v_sbQ5E [Occ=Once] _ [Occ=Dead] ->
              v_sbQ5E;
        };

Control.Arrow.app
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     forall b c. a (a b c, b) c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sbQ5G]
        case v_sbQ5G of {
          Control.Arrow.C:ArrowApply _ [Occ=Dead] v_sbQ5J [Occ=Once] ->
              v_sbQ5J;
        };

Control.Arrow.$p1ArrowChoice
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     Control.Arrow.Arrow a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLL),U(U,A,A,A,A)>] =
    [] \r [v_sbQ5K]
        case v_sbQ5K of {
          Control.Arrow.C:ArrowChoice v_sbQ5M [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_sbQ5M;
        };

Control.Arrow.left
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c d.
     a b c -> a (Data.Either.Either b d) (Data.Either.Either c d)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLL),U(A,U,A,A,A)>] =
    [] \r [v_sbQ5R]
        case v_sbQ5R of {
          Control.Arrow.C:ArrowChoice _ [Occ=Dead]
                                      v_sbQ5U [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_sbQ5U;
        };

Control.Arrow.right
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c d.
     a b c -> a (Data.Either.Either d b) (Data.Either.Either d c)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLL),U(A,A,U,A,A)>] =
    [] \r [v_sbQ5Y]
        case v_sbQ5Y of {
          Control.Arrow.C:ArrowChoice _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_sbQ62 [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_sbQ62;
        };

Control.Arrow.+++
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c b' c'.
     a b c
     -> a b' c' -> a (Data.Either.Either b b') (Data.Either.Either c c')
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSL),U(A,A,A,U,A)>] =
    [] \r [v_sbQ65]
        case v_sbQ65 of {
          Control.Arrow.C:ArrowChoice _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_sbQ6a [Occ=Once]
                                      _ [Occ=Dead] ->
              v_sbQ6a;
        };

Control.Arrow.|||
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b d c. a b d -> a c d -> a (Data.Either.Either b c) d
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLS),U(A,A,A,A,U)>] =
    [] \r [v_sbQ6c]
        case v_sbQ6c of {
          Control.Arrow.C:ArrowChoice _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_sbQ6i [Occ=Once] ->
              v_sbQ6i;
        };

Control.Arrow.$p1ArrowPlus
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     Control.Arrow.ArrowZero a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sbQ6j]
        case v_sbQ6j of {
          Control.Arrow.C:ArrowPlus v_sbQ6l [Occ=Once] _ [Occ=Dead] ->
              v_sbQ6l;
        };

Control.Arrow.<+>
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     forall b c. a b c -> a b c -> a b c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sbQ6n]
        case v_sbQ6n of {
          Control.Arrow.C:ArrowPlus _ [Occ=Dead] v_sbQ6q [Occ=Once] ->
              v_sbQ6q;
        };

Control.Arrow.$p1ArrowZero
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowZero a =>
     Control.Arrow.Arrow a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sbQ6r]
        case v_sbQ6r of {
          Control.Arrow.C:ArrowZero v_sbQ6t [Occ=Once] _ [Occ=Dead] ->
              v_sbQ6t;
        };

Control.Arrow.zeroArrow
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowZero a =>
     forall b c. a b c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sbQ6v]
        case v_sbQ6v of {
          Control.Arrow.C:ArrowZero _ [Occ=Dead] v_sbQ6y [Occ=Once] ->
              v_sbQ6y;
        };

Control.Arrow.$p1Arrow
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     Control.Category.Category a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLL),U(U,A,A,A,A,A)>] =
    [] \r [v_sbQ6z]
        case v_sbQ6z of {
          Control.Arrow.C:Arrow v_sbQ6B [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_sbQ6B;
        };

Control.Arrow.arr
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c. (b -> c) -> a b c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLL),U(A,U,A,A,A,A)>] =
    [] \r [v_sbQ6H]
        case v_sbQ6H of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                v_sbQ6K [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_sbQ6K;
        };

Control.Arrow.first
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c d. a b c -> a (b, d) (c, d)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLL),U(A,A,U,A,A,A)>] =
    [] \r [v_sbQ6P]
        case v_sbQ6P of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_sbQ6T [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_sbQ6T;
        };

Control.Arrow.second
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c d. a b c -> a (d, b) (d, c)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLL),U(A,A,A,U,A,A)>] =
    [] \r [v_sbQ6X]
        case v_sbQ6X of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_sbQ72 [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_sbQ72;
        };

Control.Arrow.***
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c b' c'. a b c -> a b' c' -> a (b, b') (c, c')
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSL),U(A,A,A,A,U,A)>] =
    [] \r [v_sbQ75]
        case v_sbQ75 of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_sbQ7b [Occ=Once]
                                _ [Occ=Dead] ->
              v_sbQ7b;
        };

Control.Arrow.&&&
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c c'. a b c -> a b c' -> a b (c, c')
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLS),U(A,A,A,A,A,U)>] =
    [] \r [v_sbQ7d]
        case v_sbQ7d of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_sbQ7k [Occ=Once] ->
              v_sbQ7k;
        };

Control.Arrow.$c***
  :: forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sbQ7l g_sbQ7m ds_sbQ7n]
        let {
          sat_sbQ7x [Occ=Once] :: c'_abN4I
          [LclId] =
              [g_sbQ7m ds_sbQ7n] \u []
                  let {
                    sat_sbQ7w [Occ=Once] :: b'_abN4H
                    [LclId] =
                        [ds_sbQ7n] \u []
                            case ds_sbQ7n of {
                              (,) _ [Occ=Dead] y_sbQ7v [Occ=Once] -> y_sbQ7v;
                            };
                  } in  g_sbQ7m sat_sbQ7w; } in
        let {
          sat_sbQ7s [Occ=Once] :: c_abN4G
          [LclId] =
              [f_sbQ7l ds_sbQ7n] \u []
                  let {
                    sat_sbQ7r [Occ=Once] :: b_abN4F
                    [LclId] =
                        [ds_sbQ7n] \u []
                            case ds_sbQ7n of {
                              (,) x_sbQ7p [Occ=Once] _ [Occ=Dead] -> x_sbQ7p;
                            };
                  } in  f_sbQ7l sat_sbQ7r;
        } in  (,) [sat_sbQ7s sat_sbQ7x];

Control.Arrow.$fArrow(->)_$carr :: forall b c. (b -> c) -> b -> c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [f_sbQ7y] f_sbQ7y;

Control.Arrow.$fCategoryTYPEKleisli1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c a.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m a b -> a -> m c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbQ7z ds_sbQ7A ds1_sbQ7B b1_sbQ7C]
        let {
          sat_sbQ7D [Occ=Once] :: m_abN3z b_abN3Q
          [LclId] =
              [ds1_sbQ7B b1_sbQ7C] \u [] ds1_sbQ7B b1_sbQ7C;
        } in  GHC.Base.>>= $dMonad_sbQ7z sat_sbQ7D ds_sbQ7A;

Control.Arrow.$fCategoryTYPEKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     Control.Category.Category (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,1*U,A)>m] =
    [] \r [$dMonad_sbQ7E]
        let {
          sat_sbQ7G [Occ=Once]
            :: forall b c a.
               Control.Arrow.Kleisli m_XbN5v b c
               -> Control.Arrow.Kleisli m_XbN5v a b
               -> Control.Arrow.Kleisli m_XbN5v a c
          [LclId] =
              [$dMonad_sbQ7E] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fCategoryTYPEKleisli1
                      $dMonad_sbQ7E eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbQ7F [Occ=Once] :: forall a. Control.Arrow.Kleisli m_XbN5v a a
          [LclId] =
              [$dMonad_sbQ7E] \u [] GHC.Base.return $dMonad_sbQ7E;
        } in  Control.Category.C:Category [sat_sbQ7F sat_sbQ7G];

Control.Arrow.$fArrowKleisli4
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c d. Control.Arrow.Kleisli m b c -> (d, b) -> m (d, c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,1*C1(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbQ7H ds_sbQ7I ds1_sbQ7J]
        let {
          d1_sbQ7K [Occ=OnceL] :: d_abN2Q
          [LclId] =
              [ds1_sbQ7J] \u []
                  case ds1_sbQ7J of {
                    (,) d2_sbQ7M [Occ=Once] _ [Occ=Dead] -> d2_sbQ7M;
                  }; } in
        let {
          sat_sbQ7V [Occ=Once] :: c_abN2P -> m_abN1X (d_abN2Q, c_abN2P)
          [LclId] =
              [$dMonad_sbQ7H d1_sbQ7K] \r [c1_sbQ7T]
                  let {
                    sat_sbQ7U [Occ=Once] :: (d_abN2Q, c_abN2P)
                    [LclId] =
                        CCCS (,)! [d1_sbQ7K c1_sbQ7T];
                  } in  GHC.Base.return $dMonad_sbQ7H sat_sbQ7U; } in
        let {
          sat_sbQ7S [Occ=Once] :: m_abN1X c_abN2P
          [LclId] =
              [ds_sbQ7I ds1_sbQ7J] \u []
                  let {
                    sat_sbQ7R [Occ=Once] :: b_abN2O
                    [LclId] =
                        [ds1_sbQ7J] \u []
                            case ds1_sbQ7J of {
                              (,) _ [Occ=Dead] b1_sbQ7Q [Occ=Once] -> b1_sbQ7Q;
                            };
                  } in  ds_sbQ7I sat_sbQ7R;
        } in  GHC.Base.>>= $dMonad_sbQ7H sat_sbQ7S sat_sbQ7V;

Control.Arrow.$fArrowKleisli3
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c d. Control.Arrow.Kleisli m b c -> (b, d) -> m (c, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,1*C1(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbQ7W ds_sbQ7X ds1_sbQ7Y]
        let {
          d1_sbQ7Z [Occ=OnceL] :: d_abN2u
          [LclId] =
              [ds1_sbQ7Y] \u []
                  case ds1_sbQ7Y of {
                    (,) _ [Occ=Dead] d2_sbQ82 [Occ=Once] -> d2_sbQ82;
                  }; } in
        let {
          sat_sbQ8a [Occ=Once] :: c_abN2t -> m_XbN42 (c_abN2t, d_abN2u)
          [LclId] =
              [$dMonad_sbQ7W d1_sbQ7Z] \r [c1_sbQ88]
                  let {
                    sat_sbQ89 [Occ=Once] :: (c_abN2t, d_abN2u)
                    [LclId] =
                        CCCS (,)! [c1_sbQ88 d1_sbQ7Z];
                  } in  GHC.Base.return $dMonad_sbQ7W sat_sbQ89; } in
        let {
          sat_sbQ87 [Occ=Once] :: m_XbN42 c_abN2t
          [LclId] =
              [ds_sbQ7X ds1_sbQ7Y] \u []
                  let {
                    sat_sbQ86 [Occ=Once] :: b_abN2s
                    [LclId] =
                        [ds1_sbQ7Y] \u []
                            case ds1_sbQ7Y of {
                              (,) b1_sbQ84 [Occ=Once] _ [Occ=Dead] -> b1_sbQ84;
                            };
                  } in  ds_sbQ7X sat_sbQ86;
        } in  GHC.Base.>>= $dMonad_sbQ7W sat_sbQ87 sat_sbQ8a;

Control.Arrow.$fArrowKleisli5
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c. (b -> c) -> b -> m c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbQ8b f_sbQ8c eta_sbQ8d]
        let {
          sat_sbQ8e [Occ=Once] :: c_abN27
          [LclId] =
              [f_sbQ8c eta_sbQ8d] \u [] f_sbQ8c eta_sbQ8d;
        } in  GHC.Base.return $dMonad_sbQ8b sat_sbQ8e;

Control.Arrow.$fArrowPlusKleisli1
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall b c.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m b c -> b -> m c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))),1*U(A,A,A,1*C1(C1(U)))><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbQ8f ds_sbQ8g ds1_sbQ8h x_sbQ8i]
        let {
          sat_sbQ8k [Occ=Once] :: m_abN1h c_abN1r
          [LclId] =
              [ds1_sbQ8h x_sbQ8i] \u [] ds1_sbQ8h x_sbQ8i; } in
        let {
          sat_sbQ8j [Occ=Once] :: m_abN1h c_abN1r
          [LclId] =
              [ds_sbQ8g x_sbQ8i] \u [] ds_sbQ8g x_sbQ8i;
        } in  GHC.Base.mplus $dMonadPlus_sbQ8f sat_sbQ8j sat_sbQ8k;

Control.Arrow.$fAlternativeArrowMonad_$capp
  :: forall b c. (b -> c, b) -> c
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),U)>,
 Unf=OtherCon []] =
    [] \r [ds_sbQ8l]
        case ds_sbQ8l of {
          (,) f_sbQ8n [Occ=Once!] x_sbQ8o [Occ=Once] -> f_sbQ8n x_sbQ8o;
        };

Control.Arrow.$fApplicativeArrowMonad5
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b. (a1 -> b) -> Control.Arrow.ArrowMonad a a1 -> a () b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQ8p eta_sbQ8q eta1_sbQ8r]
        let {
          sat_sbQ8t [Occ=Once] :: a_abMWW a1_abMX1 b_abMX2
          [LclId] =
              [$dArrow_sbQ8p eta_sbQ8q] \u []
                  Control.Arrow.arr $dArrow_sbQ8p eta_sbQ8q;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbQ8p of sat_sbQ8s {
            __DEFAULT -> Control.Category.. sat_sbQ8s sat_sbQ8t eta1_sbQ8r;
          };

Control.Arrow.$fFunctorArrowMonad1
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b. a1 -> Control.Arrow.ArrowMonad a b -> a () a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQ8u x_sbQ8v eta_sbQ8w]
        let {
          sat_sbQ8A [Occ=Once] :: a_XbMZs b_abMXn a1_abMXm
          [LclId] =
              [$dArrow_sbQ8u x_sbQ8v] \u []
                  let {
                    sat_sbQ8z [Occ=Once] :: b_abMXn -> a1_abMXm
                    [LclId] =
                        [x_sbQ8v] \r [ds_sbQ8y] x_sbQ8v;
                  } in  Control.Arrow.arr $dArrow_sbQ8u sat_sbQ8z;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbQ8u of sat_sbQ8x {
            __DEFAULT -> Control.Category.. sat_sbQ8x sat_sbQ8A eta_sbQ8w;
          };

Control.Arrow.$fFunctorArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     GHC.Base.Functor (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,A)>m] =
    [] \r [$dArrow_sbQ8B]
        let {
          sat_sbQ8D [Occ=Once]
            :: forall a b.
               a
               -> Control.Arrow.ArrowMonad a_XbMZA b
               -> Control.Arrow.ArrowMonad a_XbMZA a
          [LclId] =
              [$dArrow_sbQ8B] \r [eta_B2 eta_B1]
                  Control.Arrow.$fFunctorArrowMonad1
                      $dArrow_sbQ8B eta_B2 eta_B1; } in
        let {
          sat_sbQ8C [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Control.Arrow.ArrowMonad a_XbMZA a
               -> Control.Arrow.ArrowMonad a_XbMZA b
          [LclId] =
              [$dArrow_sbQ8B] \r [eta_B2 eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad5 $dArrow_sbQ8B eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sbQ8C sat_sbQ8D];

Control.Arrow.$fAlternativeArrowMonad2
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a (a1 -> b)
     -> Control.Arrow.ArrowMonad a a1 -> a () b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQ8E eta_sbQ8F eta1_sbQ8G]
        let {
          sat_sbQ8J [Occ=Once] :: a_abMVp () (a1_abMVM -> b_abMVN, a1_abMVM)
          [LclId] =
              [$dArrow_sbQ8E eta_sbQ8F eta1_sbQ8G] \u []
                  Control.Arrow.&&& $dArrow_sbQ8E eta_sbQ8F eta1_sbQ8G; } in
        let {
          sat_sbQ8I [Occ=Once]
            :: a_abMVp (a1_abMVM -> b_abMVN, a1_abMVM) b_abMVN
          [LclId] =
              [$dArrow_sbQ8E] \u []
                  Control.Arrow.arr
                      $dArrow_sbQ8E Control.Arrow.$fAlternativeArrowMonad_$capp;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbQ8E of sat_sbQ8H {
            __DEFAULT -> Control.Category.. sat_sbQ8H sat_sbQ8I sat_sbQ8J;
          };

Control.Arrow.$fApplicativeArrowMonad6
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1. a1 -> a () a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQ8K x_sbQ8L]
        let {
          sat_sbQ8N [Occ=Once] :: () -> a1_abMVy
          [LclId] =
              [x_sbQ8L] \r [ds_sbQ8M] x_sbQ8L;
        } in  Control.Arrow.arr $dArrow_sbQ8K sat_sbQ8N;

Control.Arrow.$fApplicativeArrowMonad4
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b c.
     (a1 -> b -> c)
     -> Control.Arrow.ArrowMonad a a1
     -> Control.Arrow.ArrowMonad a b
     -> a () c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQ8O f1_sbQ8P x_sbQ8Q]
        let {
          sat_sbQ8R [Occ=Once]
            :: Control.Arrow.ArrowMonad a_XbMYk (b_abMWs -> c_abMWt)
          [LclId] =
              [$dArrow_sbQ8O f1_sbQ8P x_sbQ8Q] \u []
                  Control.Arrow.$fApplicativeArrowMonad5
                      $dArrow_sbQ8O f1_sbQ8P x_sbQ8Q;
        } in 
          Control.Arrow.$fAlternativeArrowMonad2 $dArrow_sbQ8O sat_sbQ8R;

Control.Arrow.$fApplicativeArrowMonad3 :: forall b a. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbQ8S eta_sbQ8T] eta_sbQ8T;

Control.Arrow.$fApplicativeArrowMonad2
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a a1
     -> Control.Arrow.ArrowMonad a b -> a () b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQ8U a2_sbQ8V a3_sbQ8W]
        let {
          sat_sbQ8Z [Occ=Once]
            :: Control.Arrow.ArrowMonad a_XbMYj (b_abMWE -> b_abMWE)
          [LclId] =
              [$dArrow_sbQ8U a2_sbQ8V] \u []
                  let {
                    sat_sbQ8Y [Occ=Once] :: a_XbMYj a1_abMWD (b_abMWE -> b_abMWE)
                    [LclId] =
                        [$dArrow_sbQ8U] \u []
                            Control.Arrow.arr
                                $dArrow_sbQ8U Control.Arrow.$fApplicativeArrowMonad3;
                  } in 
                    case Control.Arrow.$p1Arrow $dArrow_sbQ8U of sat_sbQ8X {
                      __DEFAULT -> Control.Category.. sat_sbQ8X sat_sbQ8Y a2_sbQ8V;
                    };
        } in 
          Control.Arrow.$fAlternativeArrowMonad2
              $dArrow_sbQ8U sat_sbQ8Z a3_sbQ8W;

Control.Arrow.$fApplicativeArrowMonad1
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a a1
     -> Control.Arrow.ArrowMonad a b -> a () a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQ90 x_sbQ91]
        let {
          sat_sbQ94 [Occ=Once]
            :: Control.Arrow.ArrowMonad a_XbMYi (b_abMWO -> a1_abMWN)
          [LclId] =
              [$dArrow_sbQ90 x_sbQ91] \u []
                  let {
                    sat_sbQ93 [Occ=Once] :: a_XbMYi a1_abMWN (b_abMWO -> a1_abMWN)
                    [LclId] =
                        [$dArrow_sbQ90] \u []
                            Control.Arrow.arr $dArrow_sbQ90 GHC.Base.const;
                  } in 
                    case Control.Arrow.$p1Arrow $dArrow_sbQ90 of sat_sbQ92 {
                      __DEFAULT -> Control.Category.. sat_sbQ92 sat_sbQ93 x_sbQ91;
                    };
        } in 
          Control.Arrow.$fAlternativeArrowMonad2 $dArrow_sbQ90 sat_sbQ94;

Control.Arrow.$fApplicativeArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     GHC.Base.Applicative (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>m] =
    [] \r [$dArrow_sbQ95]
        let {
          sat_sbQ9b [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMYh a
               -> Control.Arrow.ArrowMonad a_XbMYh b
               -> Control.Arrow.ArrowMonad a_XbMYh a
          [LclId] =
              [$dArrow_sbQ95] \r [eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad1 $dArrow_sbQ95 eta_B1; } in
        let {
          sat_sbQ9a [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMYh a
               -> Control.Arrow.ArrowMonad a_XbMYh b
               -> Control.Arrow.ArrowMonad a_XbMYh b
          [LclId] =
              [$dArrow_sbQ95] \r [eta_B2 eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad2
                      $dArrow_sbQ95 eta_B2 eta_B1; } in
        let {
          sat_sbQ99 [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Control.Arrow.ArrowMonad a_XbMYh a
               -> Control.Arrow.ArrowMonad a_XbMYh b
               -> Control.Arrow.ArrowMonad a_XbMYh c
          [LclId] =
              [$dArrow_sbQ95] \r [eta_B2 eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad4
                      $dArrow_sbQ95 eta_B2 eta_B1; } in
        let {
          sat_sbQ98 [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMYh (a -> b)
               -> Control.Arrow.ArrowMonad a_XbMYh a
               -> Control.Arrow.ArrowMonad a_XbMYh b
          [LclId] =
              [$dArrow_sbQ95] \r [eta_B2 eta_B1]
                  Control.Arrow.$fAlternativeArrowMonad2
                      $dArrow_sbQ95 eta_B2 eta_B1; } in
        let {
          sat_sbQ97 [Occ=Once]
            :: forall a. a -> Control.Arrow.ArrowMonad a_XbMYh a
          [LclId] =
              [$dArrow_sbQ95] \r [eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad6 $dArrow_sbQ95 eta_B1; } in
        let {
          sat_sbQ96 [Occ=Once]
            :: GHC.Base.Functor (Control.Arrow.ArrowMonad a_XbMYh)
          [LclId] =
              [$dArrow_sbQ95] \u []
                  Control.Arrow.$fFunctorArrowMonad $dArrow_sbQ95;
        } in 
          GHC.Base.C:Applicative [sat_sbQ96
                                  sat_sbQ97
                                  sat_sbQ98
                                  sat_sbQ99
                                  sat_sbQ9a
                                  sat_sbQ9b];

Control.Arrow.$fMonadArrowMonad_$c>>=
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a a1
     -> (a1 -> Control.Arrow.ArrowMonad a b)
     -> Control.Arrow.ArrowMonad a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(1*U(1*U(A,C(C1(U))),1*C1(U),A,A,A,A),1*U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbQ9c eta_sbQ9d eta1_sbQ9e]
        case
            Control.Arrow.$p1ArrowApply $dArrowApply_sbQ9c
        of
        $dArrow_sbQ9f [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              case
                  Control.Arrow.$p1Arrow $dArrow_sbQ9f
              of
              $dCategory_sbQ9g [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
              { __DEFAULT ->
                    let {
                      sat_sbQ9m [Occ=Once] :: a_abMU9 () (a_abMU9 () b_abMUj, ())
                      [LclId] =
                          [eta_sbQ9d eta1_sbQ9e $dArrow_sbQ9f $dCategory_sbQ9g] \u []
                              let {
                                sat_sbQ9l [Occ=Once] :: a_abMU9 a1_abMUi (a_abMU9 () b_abMUj, ())
                                [LclId] =
                                    [eta1_sbQ9e $dArrow_sbQ9f] \u []
                                        let {
                                          sat_sbQ9k [Occ=Once]
                                            :: a1_abMUi -> (a_abMU9 () b_abMUj, ())
                                          [LclId] =
                                              [eta1_sbQ9e] \r [x_sbQ9i]
                                                  let {
                                                    sat_sbQ9j [Occ=Once] :: a_abMU9 () b_abMUj
                                                    [LclId] =
                                                        [eta1_sbQ9e x_sbQ9i] \u []
                                                            eta1_sbQ9e x_sbQ9i;
                                                  } in  (,) [sat_sbQ9j GHC.Tuple.()];
                                        } in  Control.Arrow.arr $dArrow_sbQ9f sat_sbQ9k;
                              } in  Control.Category.. $dCategory_sbQ9g sat_sbQ9l eta_sbQ9d; } in
                    let {
                      sat_sbQ9h [Occ=Once] :: a_abMU9 (a_abMU9 () b_abMUj, ()) b_abMUj
                      [LclId] =
                          [$dArrowApply_sbQ9c] \u [] Control.Arrow.app $dArrowApply_sbQ9c;
                    } in  Control.Category.. $dCategory_sbQ9g sat_sbQ9h sat_sbQ9m;
              };
        };

Control.Arrow.$fMonadArrowMonad_$cp1Monad
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     GHC.Base.Applicative (Control.Arrow.ArrowMonad a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)>m,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbQ9n]
        let {
          sat_sbQ9o [Occ=Once, Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
            :: Control.Arrow.Arrow a_abMU9
          [LclId] =
              [$dArrowApply_sbQ9n] \u []
                  Control.Arrow.$p1ArrowApply $dArrowApply_sbQ9n;
        } in  Control.Arrow.$fApplicativeArrowMonad sat_sbQ9o;

Control.Arrow.$fMonadArrowMonad1
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     forall a1. a1 -> a () a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)L),1*U(1*U(A,1*C1(U),A,A,A,A),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbQ9p eta_sbQ9q]
        let {
          sat_sbQ9t [Occ=Once] :: () -> a1_abMVa
          [LclId] =
              [eta_sbQ9q] \r [ds_sbQ9s] eta_sbQ9q;
        } in 
          case Control.Arrow.$p1ArrowApply $dArrowApply_sbQ9p of sat_sbQ9r {
            __DEFAULT -> Control.Arrow.arr sat_sbQ9r sat_sbQ9t;
          };

Control.Arrow.$fMonadArrowMonad_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a a1
     -> Control.Arrow.ArrowMonad a b -> Control.Arrow.ArrowMonad a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(U(U(A,C(C1(U))),C(U),A,A,A,A),U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbQ9u eta_sbQ9v eta1_sbQ9w]
        let {
          sat_sbQ9y [Occ=Once]
            :: a1_abMV0 -> Control.Arrow.ArrowMonad a_XbMXu b_abMV1
          [LclId] =
              [eta1_sbQ9w] \r [ds_sbQ9x] eta1_sbQ9w;
        } in 
          Control.Arrow.$fMonadArrowMonad_$c>>=
              $dArrowApply_sbQ9u eta_sbQ9v sat_sbQ9y;

lvl_rbNC6
  :: forall (a1 :: * -> * -> *) a2.
     [GHC.Types.Char] -> Control.Arrow.ArrowMonad a1 a2
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sbQ9z] GHC.Err.errorWithoutStackTrace eta_sbQ9z;

Control.Arrow.$fMonadArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     GHC.Base.Monad (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),U)>m] =
    [] \r [$dArrowApply_sbQ9A]
        let {
          sat_sbQ9E [Occ=Once]
            :: forall a. a -> Control.Arrow.ArrowMonad a_XbMXv a
          [LclId] =
              [$dArrowApply_sbQ9A] \r [eta_B1]
                  Control.Arrow.$fMonadArrowMonad1 $dArrowApply_sbQ9A eta_B1; } in
        let {
          sat_sbQ9D [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMXv a
               -> Control.Arrow.ArrowMonad a_XbMXv b
               -> Control.Arrow.ArrowMonad a_XbMXv b
          [LclId] =
              [$dArrowApply_sbQ9A] \r [eta_B2 eta_B1]
                  Control.Arrow.$fMonadArrowMonad_$c>>
                      $dArrowApply_sbQ9A eta_B2 eta_B1; } in
        let {
          sat_sbQ9C [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMXv a
               -> (a -> Control.Arrow.ArrowMonad a_XbMXv b)
               -> Control.Arrow.ArrowMonad a_XbMXv b
          [LclId] =
              [$dArrowApply_sbQ9A] \r [eta_B2 eta_B1]
                  Control.Arrow.$fMonadArrowMonad_$c>>=
                      $dArrowApply_sbQ9A eta_B2 eta_B1; } in
        let {
          sat_sbQ9B [Occ=Once]
            :: GHC.Base.Applicative (Control.Arrow.ArrowMonad a_XbMXv)
          [LclId] =
              [$dArrowApply_sbQ9A] \u []
                  Control.Arrow.$fMonadArrowMonad_$cp1Monad $dArrowApply_sbQ9A;
        } in 
          GHC.Base.C:Monad [sat_sbQ9B
                            sat_sbQ9C
                            sat_sbQ9D
                            sat_sbQ9E
                            lvl_rbNC6];

Control.Arrow.$fAlternativeArrowMonad3
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     forall a1. a () a1
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LS)L),1*U(1*U(A,1*U),A)>,
 Unf=OtherCon []] =
    [] \r [$dArrowPlus_sbQ9F]
        case Control.Arrow.$p1ArrowPlus $dArrowPlus_sbQ9F of sat_sbQ9G {
          __DEFAULT -> Control.Arrow.zeroArrow sat_sbQ9G;
        };

Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     GHC.Base.Applicative (Control.Arrow.ArrowMonad a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A),A)>m,
 Unf=OtherCon []] =
    [] \r [$dArrowPlus_sbQ9H]
        let {
          sat_sbQ9J [Occ=Once, Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
            :: Control.Arrow.Arrow a_XbMWB
          [LclId] =
              [$dArrowPlus_sbQ9H] \u []
                  case Control.Arrow.$p1ArrowPlus $dArrowPlus_sbQ9H of sat_sbQ9I {
                    __DEFAULT -> Control.Arrow.$p1ArrowZero sat_sbQ9I;
                  };
        } in  Control.Arrow.$fApplicativeArrowMonad sat_sbQ9J;

Control.Arrow.$fAlternativeArrowMonad1 :: forall a. () -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sbQ9K] [] [];

Control.Arrow.$fAlternativeArrowMonad_$csome
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     forall a1.
     Control.Arrow.ArrowMonad a a1 -> Control.Arrow.ArrowMonad a [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LC(C(S)))LLLLL)L)L),U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A),C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowPlus_sbQ9L eta_sbQ9M]
        let {
          some_v_sbQ9N [Occ=LoopBreaker] :: a_XbMWE () [a1_abMTU]
          [LclId] =
              [$dArrowPlus_sbQ9L eta_sbQ9M some_v_sbQ9N] \u []
                  case
                      Control.Arrow.$p1ArrowPlus $dArrowPlus_sbQ9L
                  of
                  $dApplicative_sbQ9O [Dmd=<S(S(S(LC(C(S)))LLLLL)L),1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,1*C1(C1(U))),A)>]
                  { __DEFAULT ->
                        case
                            Control.Arrow.$p1ArrowZero $dApplicative_sbQ9O
                        of
                        $dApplicative1_sbQ9P [Dmd=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,1*C1(C1(U)))>]
                        { __DEFAULT ->
                              let {
                                sat_sbQ9X [Occ=Once]
                                  :: a_XbMWE () ([a1_abMTU] -> [a1_abMTU], [a1_abMTU])
                                [LclId] =
                                    [$dArrowPlus_sbQ9L
                                     eta_sbQ9M
                                     some_v_sbQ9N
                                     $dApplicative1_sbQ9P] \u []
                                        let {
                                          sat_sbQ9W [Occ=Once] :: a_XbMWE () [a1_abMTU]
                                          [LclId] =
                                              [$dArrowPlus_sbQ9L
                                               some_v_sbQ9N
                                               $dApplicative1_sbQ9P] \u []
                                                  let {
                                                    sat_sbQ9V [Occ=Once] :: a_XbMWE () [a1_abMTU]
                                                    [LclId] =
                                                        [$dApplicative1_sbQ9P] \u []
                                                            Control.Arrow.arr
                                                                $dApplicative1_sbQ9P
                                                                Control.Arrow.$fAlternativeArrowMonad1;
                                                  } in 
                                                    Control.Arrow.<+>
                                                        $dArrowPlus_sbQ9L
                                                        some_v_sbQ9N
                                                        sat_sbQ9V; } in
                                        let {
                                          sat_sbQ9U [Occ=Once]
                                            :: a_XbMWE () ([a1_abMTU] -> [a1_abMTU])
                                          [LclId] =
                                              [eta_sbQ9M $dApplicative1_sbQ9P] \u []
                                                  let {
                                                    sat_sbQ9T [Occ=Once]
                                                      :: a_XbMWE a1_abMTU ([a1_abMTU] -> [a1_abMTU])
                                                    [LclId] =
                                                        [$dApplicative1_sbQ9P] \u []
                                                            Control.Arrow.arr
                                                                $dApplicative1_sbQ9P GHC.Types.:;
                                                  } in 
                                                    case
                                                        Control.Arrow.$p1Arrow $dApplicative1_sbQ9P
                                                    of
                                                    sat_sbQ9S
                                                    { __DEFAULT ->
                                                          Control.Category..
                                                              sat_sbQ9S sat_sbQ9T eta_sbQ9M;
                                                    };
                                        } in 
                                          Control.Arrow.&&&
                                              $dApplicative1_sbQ9P sat_sbQ9U sat_sbQ9W; } in
                              let {
                                sat_sbQ9R [Occ=Once]
                                  :: a_XbMWE ([a1_abMTU] -> [a1_abMTU], [a1_abMTU]) [a1_abMTU]
                                [LclId] =
                                    [$dApplicative1_sbQ9P] \u []
                                        Control.Arrow.arr
                                            $dApplicative1_sbQ9P
                                            Control.Arrow.$fAlternativeArrowMonad_$capp;
                              } in 
                                case Control.Arrow.$p1Arrow $dApplicative1_sbQ9P of sat_sbQ9Q {
                                  __DEFAULT -> Control.Category.. sat_sbQ9Q sat_sbQ9R sat_sbQ9X;
                                };
                        };
                  };
        } in  some_v_sbQ9N;

Control.Arrow.$fAlternativeArrowMonad_$cmany
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     forall a1.
     Control.Arrow.ArrowMonad a a1 -> Control.Arrow.ArrowMonad a [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A),C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowPlus_sbQ9Y eta_sbQ9Z]
        let {
          many_v_sbQa0 [Occ=LoopBreaker] :: a_XbMWD () [a1_abMU2]
          [LclId] =
              [$dArrowPlus_sbQ9Y eta_sbQ9Z many_v_sbQa0] \u []
                  let {
                    $dApplicative_sbQa1 [Occ=OnceL,
                                         Dmd=<L,1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)>]
                      :: Control.Arrow.ArrowZero a_XbMWD
                    [LclId] =
                        [$dArrowPlus_sbQ9Y] \s []
                            Control.Arrow.$p1ArrowPlus $dArrowPlus_sbQ9Y; } in
                  let {
                    $dApplicative1_sbQa2 [Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
                      :: Control.Arrow.Arrow a_XbMWD
                    [LclId] =
                        [$dApplicative_sbQa1] \u []
                            Control.Arrow.$p1ArrowZero $dApplicative_sbQa1; } in
                  let {
                    sat_sbQa7 [Occ=Once] :: a_XbMWD () [a1_abMU2]
                    [LclId] =
                        [$dApplicative1_sbQa2] \u []
                            Control.Arrow.arr
                                $dApplicative1_sbQa2 Control.Arrow.$fAlternativeArrowMonad1; } in
                  let {
                    sat_sbQa6 [Occ=Once] :: a_XbMWD () [a1_abMU2]
                    [LclId] =
                        [eta_sbQ9Z many_v_sbQa0 $dApplicative1_sbQa2] \u []
                            let {
                              sat_sbQa5 [Occ=Once]
                                :: Control.Arrow.ArrowMonad a_XbMWD ([a1_abMU2] -> [a1_abMU2])
                              [LclId] =
                                  [eta_sbQ9Z $dApplicative1_sbQa2] \u []
                                      let {
                                        sat_sbQa4 [Occ=Once]
                                          :: a_XbMWD a1_abMU2 ([a1_abMU2] -> [a1_abMU2])
                                        [LclId] =
                                            [$dApplicative1_sbQa2] \u []
                                                Control.Arrow.arr $dApplicative1_sbQa2 GHC.Types.:;
                                      } in 
                                        case
                                            Control.Arrow.$p1Arrow $dApplicative1_sbQa2
                                        of
                                        sat_sbQa3
                                        { __DEFAULT ->
                                              Control.Category.. sat_sbQa3 sat_sbQa4 eta_sbQ9Z;
                                        };
                            } in 
                              Control.Arrow.$fAlternativeArrowMonad2
                                  $dApplicative1_sbQa2 sat_sbQa5 many_v_sbQa0;
                  } in  Control.Arrow.<+> $dArrowPlus_sbQ9Y sat_sbQa6 sat_sbQa7;
        } in  many_v_sbQa0;

Control.Arrow.$fAlternativeArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     GHC.Base.Alternative (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),1*U),C(C1(U)))>m] =
    [] \r [$dArrowPlus_sbQa8]
        let {
          sat_sbQaf [Occ=Once]
            :: forall a.
               Control.Arrow.ArrowMonad a_XbMWC a
               -> Control.Arrow.ArrowMonad a_XbMWC [a]
          [LclId] =
              [$dArrowPlus_sbQa8] \r [eta_B1]
                  Control.Arrow.$fAlternativeArrowMonad_$cmany
                      $dArrowPlus_sbQa8 eta_B1; } in
        let {
          sat_sbQae [Occ=Once]
            :: forall a.
               Control.Arrow.ArrowMonad a_XbMWC a
               -> Control.Arrow.ArrowMonad a_XbMWC [a]
          [LclId] =
              [$dArrowPlus_sbQa8] \r [eta_B1]
                  Control.Arrow.$fAlternativeArrowMonad_$csome
                      $dArrowPlus_sbQa8 eta_B1; } in
        let {
          sat_sbQad [Occ=Once]
            :: forall a.
               Control.Arrow.ArrowMonad a_XbMWC a
               -> Control.Arrow.ArrowMonad a_XbMWC a
               -> Control.Arrow.ArrowMonad a_XbMWC a
          [LclId] =
              [$dArrowPlus_sbQa8] \r [ds_sbQab ds1_sbQac]
                  Control.Arrow.<+> $dArrowPlus_sbQa8 ds_sbQab ds1_sbQac; } in
        let {
          sat_sbQaa [Occ=Once]
            :: forall a. Control.Arrow.ArrowMonad a_XbMWC a
          [LclId] =
              [$dArrowPlus_sbQa8] \u []
                  Control.Arrow.$fAlternativeArrowMonad3 $dArrowPlus_sbQa8; } in
        let {
          sat_sbQa9 [Occ=Once]
            :: GHC.Base.Applicative (Control.Arrow.ArrowMonad a_XbMWC)
          [LclId] =
              [$dArrowPlus_sbQa8] \u []
                  Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative
                      $dArrowPlus_sbQa8;
        } in 
          GHC.Base.C:Alternative [sat_sbQa9
                                  sat_sbQaa
                                  sat_sbQad
                                  sat_sbQae
                                  sat_sbQaf];

Control.Arrow.$fMonadPlusArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     (Control.Arrow.ArrowApply a, Control.Arrow.ArrowPlus a) =>
     GHC.Base.MonadPlus (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),U)><L,U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),U),C(C1(U)))>m] =
    [] \r [$dArrowApply_sbQag $dArrowPlus_sbQah]
        let {
          sat_sbQan [Occ=Once]
            :: forall a.
               Control.Arrow.ArrowMonad a_abMSU a
               -> Control.Arrow.ArrowMonad a_abMSU a
               -> Control.Arrow.ArrowMonad a_abMSU a
          [LclId] =
              [$dArrowPlus_sbQah] \r [ds_sbQal ds1_sbQam]
                  Control.Arrow.<+> $dArrowPlus_sbQah ds_sbQal ds1_sbQam; } in
        let {
          sat_sbQak [Occ=Once]
            :: forall a. Control.Arrow.ArrowMonad a_abMSU a
          [LclId] =
              [$dArrowPlus_sbQah] \u []
                  Control.Arrow.$fAlternativeArrowMonad3 $dArrowPlus_sbQah; } in
        let {
          sat_sbQaj [Occ=Once]
            :: GHC.Base.Monad (Control.Arrow.ArrowMonad a_abMSU)
          [LclId] =
              [$dArrowApply_sbQag] \u []
                  Control.Arrow.$fMonadArrowMonad $dArrowApply_sbQag; } in
        let {
          sat_sbQai [Occ=Once]
            :: GHC.Base.Alternative (Control.Arrow.ArrowMonad a_abMSU)
          [LclId] =
              [$dArrowPlus_sbQah] \u []
                  Control.Arrow.$fAlternativeArrowMonad $dArrowPlus_sbQah;
        } in 
          GHC.Base.C:MonadPlus [sat_sbQai sat_sbQaj sat_sbQak sat_sbQan];

Control.Arrow.$fArrowLoop(->)_$cloop
  :: forall b d c. ((b, d) -> (c, d)) -> b -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U(U,U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sbQao b1_sbQap]
        let {
          ds_sbQaq [Occ=LoopBreaker] :: (c_abMSD, d_abMSC)
          [LclId] =
              [f_sbQao b1_sbQap ds_sbQaq] \u []
                  let {
                    sat_sbQau [Occ=OnceL] :: d_abMSC
                    [LclId] =
                        [ds_sbQaq] \u []
                            case ds_sbQaq of {
                              (,) _ [Occ=Dead] d1_sbQat [Occ=Once] -> d1_sbQat;
                            }; } in
                  let {
                    sat_sbQav [Occ=Once] :: (b_abMSB, d_abMSC)
                    [LclId] =
                        CCCS (,)! [b1_sbQap sat_sbQau];
                  } in  f_sbQao sat_sbQav;
        } in 
          case ds_sbQaq of {
            (,) c1_sbQax [Occ=Once] _ [Occ=Dead] -> c1_sbQax;
          };

Control.Arrow.$fArrowLoopKleisli1
  :: forall (m :: * -> *).
     Control.Monad.Fix.MonadFix m =>
     forall b d c. Control.Arrow.Kleisli m (b, d) (c, d) -> b -> m c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S))LLL)L),U(1*U(A,1*C1(C1(U)),A,C(U),A),1*C1(U))><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadFix_sbQaz eta_sbQaA eta1_sbQaB]
        case
            Control.Monad.Fix.$p1MonadFix $dMonadFix_sbQaz
        of
        $dMonad_sbQaC [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
        { __DEFAULT ->
              let {
                sat_sbQaN [Occ=Once] :: (c_abMRB, d_abMRA) -> m_abMRq c_abMRB
                [LclId] =
                    [$dMonad_sbQaC] \r [x1_sbQaI]
                        let {
                          sat_sbQaM [Occ=Once] :: c_abMRB
                          [LclId] =
                              [x1_sbQaI] \u []
                                  case x1_sbQaI of {
                                    (,) x_sbQaK [Occ=Once] _ [Occ=Dead] -> x_sbQaK;
                                  };
                        } in  GHC.Base.return $dMonad_sbQaC sat_sbQaM; } in
              let {
                sat_sbQaH [Occ=Once] :: m_abMRq (c_abMRB, d_abMRA)
                [LclId] =
                    [$dMonadFix_sbQaz eta_sbQaA eta1_sbQaB] \u []
                        let {
                          sat_sbQaG [Occ=Once]
                            :: (c_abMRB, d_abMRA) -> m_abMRq (c_abMRB, d_abMRA)
                          [LclId] =
                              [eta_sbQaA eta1_sbQaB] \r [y_sbQaD]
                                  let {
                                    sat_sbQaE [Occ=Once] :: d_abMRA
                                    [LclId] =
                                        [y_sbQaD] \u [] Data.Tuple.snd y_sbQaD; } in
                                  let {
                                    sat_sbQaF [Occ=Once] :: (b_abMRz, d_abMRA)
                                    [LclId] =
                                        CCCS (,)! [eta1_sbQaB sat_sbQaE];
                                  } in  eta_sbQaA sat_sbQaF;
                        } in  Control.Monad.Fix.mfix $dMonadFix_sbQaz sat_sbQaG;
              } in  GHC.Base.>>= $dMonad_sbQaC sat_sbQaH sat_sbQaN;
        };

lvl1_rbNC7 :: forall d. Data.Either.Either d d -> d
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbQaO]
        case ds_sbQaO of {
          Data.Either.Left x_sbQaQ [Occ=Once] -> x_sbQaQ;
          Data.Either.Right y_sbQaR [Occ=Once] -> y_sbQaR;
        };

Control.Arrow.$dm|||
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b d c. a b d -> a c d -> a (Data.Either.Either b c) d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)LLLL),U(1*U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A),A,A,1*C1(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowChoice_sbQaS eta_sbQaT eta1_sbQaU]
        case
            Control.Arrow.$p1ArrowChoice $dArrowChoice_sbQaS
        of
        $dArrow_sbQaV [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sbQaY [Occ=Once]
                  :: a_abMu0 (Data.Either.Either b_abMQL c_abMQN) (Data.Either.Either
                                                                     d_abMQM d_abMQM)
                [LclId] =
                    [$dArrowChoice_sbQaS eta_sbQaT eta1_sbQaU] \u []
                        Control.Arrow.+++ $dArrowChoice_sbQaS eta_sbQaT eta1_sbQaU; } in
              let {
                sat_sbQaX [Occ=Once]
                  :: a_abMu0 (Data.Either.Either d_abMQM d_abMQM) d_abMQM
                [LclId] =
                    [$dArrow_sbQaV] \u [] Control.Arrow.arr $dArrow_sbQaV lvl1_rbNC7;
              } in 
                case Control.Arrow.$p1Arrow $dArrow_sbQaV of sat_sbQaW {
                  __DEFAULT -> Control.Category.. sat_sbQaW sat_sbQaX sat_sbQaY;
                };
        };

mirror_rbNC8
  :: forall x y. Data.Either.Either x y -> Data.Either.Either y x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbQaZ]
        case ds_sbQaZ of {
          Data.Either.Left x1_sbQb1 [Occ=Once] ->
              Data.Either.Right [x1_sbQb1];
          Data.Either.Right y1_sbQb2 [Occ=Once] ->
              Data.Either.Left [y1_sbQb2];
        };

Control.Arrow.$dm+++
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c b' c'.
     a b c
     -> a b' c' -> a (Data.Either.Either b b') (Data.Either.Either c c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)LLLL),U(1*U(1*U(A,C(C1(U))),C(U),A,A,A,A),C(U),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowChoice_sbQb3 eta_sbQb4 eta1_sbQb5]
        case
            Control.Arrow.$p1ArrowChoice $dArrowChoice_sbQb3
        of
        $dArrow_sbQb6 [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),C(U),A,A,A,A)>]
        { __DEFAULT ->
              case
                  Control.Arrow.$p1Arrow $dArrow_sbQb6
              of
              $dCategory_sbQb7 [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
              { __DEFAULT ->
                    let {
                      sat_sbQbd [Occ=Once]
                        :: a_abMu0 (Data.Either.Either
                                      b_abMPE b'_abMPG) (Data.Either.Either c'_abMPH c_abMPF)
                      [LclId] =
                          [$dArrowChoice_sbQb3
                           eta_sbQb4
                           eta1_sbQb5
                           $dArrow_sbQb6
                           $dCategory_sbQb7] \u []
                              let {
                                sat_sbQbc [Occ=Once]
                                  :: a_abMu0 (Data.Either.Either
                                                b_abMPE b'_abMPG) (Data.Either.Either
                                                                     b'_abMPG c_abMPF)
                                [LclId] =
                                    [$dArrowChoice_sbQb3
                                     eta_sbQb4
                                     $dArrow_sbQb6
                                     $dCategory_sbQb7] \u []
                                        let {
                                          sat_sbQbb [Occ=Once]
                                            :: a_abMu0 (Data.Either.Either
                                                          b_abMPE b'_abMPG) (Data.Either.Either
                                                                               c_abMPF b'_abMPG)
                                          [LclId] =
                                              [$dArrowChoice_sbQb3 eta_sbQb4] \u []
                                                  Control.Arrow.left
                                                      $dArrowChoice_sbQb3 eta_sbQb4; } in
                                        let {
                                          sat_sbQba [Occ=Once]
                                            :: a_abMu0 (Data.Either.Either
                                                          c_abMPF b'_abMPG) (Data.Either.Either
                                                                               b'_abMPG c_abMPF)
                                          [LclId] =
                                              [$dArrow_sbQb6] \u []
                                                  Control.Arrow.arr $dArrow_sbQb6 mirror_rbNC8;
                                        } in 
                                          Control.Category..
                                              $dCategory_sbQb7 sat_sbQba sat_sbQbb; } in
                              let {
                                sat_sbQb9 [Occ=Once]
                                  :: a_abMu0 (Data.Either.Either
                                                b'_abMPG c_abMPF) (Data.Either.Either
                                                                     c'_abMPH c_abMPF)
                                [LclId] =
                                    [$dArrowChoice_sbQb3 eta1_sbQb5] \u []
                                        Control.Arrow.left $dArrowChoice_sbQb3 eta1_sbQb5;
                              } in  Control.Category.. $dCategory_sbQb7 sat_sbQb9 sat_sbQbc; } in
                    let {
                      sat_sbQb8 [Occ=Once]
                        :: a_abMu0 (Data.Either.Either
                                      c'_abMPH c_abMPF) (Data.Either.Either c_abMPF c'_abMPH)
                      [LclId] =
                          [$dArrow_sbQb6] \u [] Control.Arrow.arr $dArrow_sbQb6 mirror_rbNC8;
                    } in  Control.Category.. $dCategory_sbQb7 sat_sbQb8 sat_sbQbd;
              };
        };

Control.Arrow.$dmright
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c d.
     a b c -> a (Data.Either.Either d b) (Data.Either.Either d c)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),U(1*U(1*U(1*U,A),A,A,A,A,A),A,A,1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dArrowChoice_sbQbe]
        let {
          sat_sbQbh [Occ=Once] :: a_abMu0 d_abMPp d_abMPp
          [LclId] =
              [$dArrowChoice_sbQbe] \u []
                  case
                      Control.Arrow.$p1ArrowChoice $dArrowChoice_sbQbe
                  of
                  sat_sbQbf
                  { __DEFAULT ->
                        case Control.Arrow.$p1Arrow sat_sbQbf of sat_sbQbg {
                          __DEFAULT -> Control.Category.id sat_sbQbg;
                        };
                  };
        } in  Control.Arrow.+++ $dArrowChoice_sbQbe sat_sbQbh;

Control.Arrow.$dmleft
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c d.
     a b c -> a (Data.Either.Either b d) (Data.Either.Either c d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))L),U(1*U(1*U(1*U,A),A,A,A,A,A),A,A,1*C1(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowChoice_sbQbi eta_sbQbj]
        let {
          sat_sbQbm [Occ=Once] :: a_abMu0 d_abMP8 d_abMP8
          [LclId] =
              [$dArrowChoice_sbQbi] \u []
                  case
                      Control.Arrow.$p1ArrowChoice $dArrowChoice_sbQbi
                  of
                  sat_sbQbk
                  { __DEFAULT ->
                        case Control.Arrow.$p1Arrow sat_sbQbk of sat_sbQbl {
                          __DEFAULT -> Control.Category.id sat_sbQbl;
                        };
                  };
        } in  Control.Arrow.+++ $dArrowChoice_sbQbi eta_sbQbj sat_sbQbm;

lvl2_rbNC9 :: forall b. b -> (b, b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [b1_sbQbn] (,) [b1_sbQbn b1_sbQbn];

Control.Arrow.$dm&&&
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c c'. a b c -> a b c' -> a b (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,1*C1(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQbo eta_sbQbp eta1_sbQbq]
        let {
          sat_sbQbt [Occ=Once] :: a_abMuz b_abMOE (b_abMOE, b_abMOE)
          [LclId] =
              [$dArrow_sbQbo] \u []
                  Control.Arrow.arr $dArrow_sbQbo lvl2_rbNC9; } in
        let {
          sat_sbQbs [Occ=Once]
            :: a_abMuz (b_abMOE, b_abMOE) (c_abMOF, c'_abMOG)
          [LclId] =
              [$dArrow_sbQbo eta_sbQbp eta1_sbQbq] \u []
                  Control.Arrow.*** $dArrow_sbQbo eta_sbQbp eta1_sbQbq;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbQbo of sat_sbQbr {
            __DEFAULT -> Control.Category.. sat_sbQbr sat_sbQbs sat_sbQbt;
          };

swap_rbNCa :: forall b a. (b, a) -> (a, b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sbQbu]
        let {
          sat_sbQbC [Occ=Once] :: b_abMNN
          [LclId] =
              [ds_sbQbu] \u []
                  case ds_sbQbu of {
                    (,) x_sbQbA [Occ=Once] _ [Occ=Dead] -> x_sbQbA;
                  }; } in
        let {
          sat_sbQby [Occ=Once] :: a_abMNM
          [LclId] =
              [ds_sbQbu] \u []
                  case ds_sbQbu of {
                    (,) _ [Occ=Dead] y_sbQbx [Occ=Once] -> y_sbQbx;
                  };
        } in  (,) [sat_sbQby sat_sbQbC];

Control.Arrow.$dm***
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c b' c'. a b c -> a b' c' -> a (b, b') (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),C(U),C(U),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQbD eta_sbQbE eta1_sbQbF]
        case
            Control.Arrow.$p1Arrow $dArrow_sbQbD
        of
        $dCategory_sbQbG [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
        { __DEFAULT ->
              let {
                sat_sbQbM [Occ=Once]
                  :: a_abMuz (b_abMNy, b'_abMNA) (c'_abMNB, c_abMNz)
                [LclId] =
                    [$dArrow_sbQbD eta_sbQbE eta1_sbQbF $dCategory_sbQbG] \u []
                        let {
                          sat_sbQbL [Occ=Once]
                            :: a_abMuz (b_abMNy, b'_abMNA) (b'_abMNA, c_abMNz)
                          [LclId] =
                              [$dArrow_sbQbD eta_sbQbE $dCategory_sbQbG] \u []
                                  let {
                                    sat_sbQbK [Occ=Once]
                                      :: a_abMuz (b_abMNy, b'_abMNA) (c_abMNz, b'_abMNA)
                                    [LclId] =
                                        [$dArrow_sbQbD eta_sbQbE] \u []
                                            Control.Arrow.first $dArrow_sbQbD eta_sbQbE; } in
                                  let {
                                    sat_sbQbJ [Occ=Once]
                                      :: a_abMuz (c_abMNz, b'_abMNA) (b'_abMNA, c_abMNz)
                                    [LclId] =
                                        [$dArrow_sbQbD] \u []
                                            Control.Arrow.arr $dArrow_sbQbD swap_rbNCa;
                                  } in 
                                    Control.Category.. $dCategory_sbQbG sat_sbQbJ sat_sbQbK; } in
                        let {
                          sat_sbQbI [Occ=Once]
                            :: a_abMuz (b'_abMNA, c_abMNz) (c'_abMNB, c_abMNz)
                          [LclId] =
                              [$dArrow_sbQbD eta1_sbQbF] \u []
                                  Control.Arrow.first $dArrow_sbQbD eta1_sbQbF;
                        } in  Control.Category.. $dCategory_sbQbG sat_sbQbI sat_sbQbL; } in
              let {
                sat_sbQbH [Occ=Once]
                  :: a_abMuz (c'_abMNB, c_abMNz) (c_abMNz, c'_abMNB)
                [LclId] =
                    [$dArrow_sbQbD] \u [] Control.Arrow.arr $dArrow_sbQbD swap_rbNCa;
              } in  Control.Category.. $dCategory_sbQbG sat_sbQbH sat_sbQbM;
        };

Control.Arrow.$fArrowKleisli2
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c b' c'.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m b' c' -> (b, b') -> m (c, c')
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(U)><L,C(U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbQbN f_sbQbO g_sbQbP eta_sbQbQ]
        let {
          sat_sbQcg [Occ=Once]
            :: (c'_abN3d, c_abN3b) -> m_XbN5E (c_abN3b, c'_abN3d)
          [LclId] =
              [$dMonad_sbQbN] \r [eta1_sbQc6]
                  let {
                    sat_sbQce [Occ=Once] :: c'_abN3d
                    [LclId] =
                        [eta1_sbQc6] \u []
                            case eta1_sbQc6 of {
                              (,) x_sbQcc [Occ=Once] _ [Occ=Dead] -> x_sbQcc;
                            }; } in
                  let {
                    sat_sbQca [Occ=Once] :: c_abN3b
                    [LclId] =
                        [eta1_sbQc6] \u []
                            case eta1_sbQc6 of {
                              (,) _ [Occ=Dead] y_sbQc9 [Occ=Once] -> y_sbQc9;
                            }; } in
                  let {
                    sat_sbQcf [Occ=Once] :: (c_abN3b, c'_abN3d)
                    [LclId] =
                        CCCS (,)! [sat_sbQca sat_sbQce];
                  } in  GHC.Base.return $dMonad_sbQbN sat_sbQcf; } in
        let {
          sat_sbQc5 [Occ=Once] :: m_XbN5E (c'_abN3d, c_abN3b)
          [LclId] =
              [$dMonad_sbQbN f_sbQbO g_sbQbP eta_sbQbQ] \u []
                  let {
                    sat_sbQc4 [Occ=Once]
                      :: (b'_abN3c, c_abN3b) -> m_XbN5E (c'_abN3d, c_abN3b)
                    [LclId] =
                        [$dMonad_sbQbN g_sbQbP] \r [eta_B1]
                            Control.Arrow.$fArrowKleisli3 $dMonad_sbQbN g_sbQbP eta_B1; } in
                  let {
                    sat_sbQc3 [Occ=Once] :: m_XbN5E (b'_abN3c, c_abN3b)
                    [LclId] =
                        [$dMonad_sbQbN f_sbQbO eta_sbQbQ] \u []
                            let {
                              sat_sbQc2 [Occ=Once]
                                :: (c_abN3b, b'_abN3c) -> m_XbN5E (b'_abN3c, c_abN3b)
                              [LclId] =
                                  [$dMonad_sbQbN] \r [eta1_sbQbS]
                                      let {
                                        sat_sbQc0 [Occ=Once] :: c_abN3b
                                        [LclId] =
                                            [eta1_sbQbS] \u []
                                                case eta1_sbQbS of {
                                                  (,) x_sbQbY [Occ=Once] _ [Occ=Dead] -> x_sbQbY;
                                                }; } in
                                      let {
                                        sat_sbQbW [Occ=Once] :: b'_abN3c
                                        [LclId] =
                                            [eta1_sbQbS] \u []
                                                case eta1_sbQbS of {
                                                  (,) _ [Occ=Dead] y_sbQbV [Occ=Once] -> y_sbQbV;
                                                }; } in
                                      let {
                                        sat_sbQc1 [Occ=Once] :: (b'_abN3c, c_abN3b)
                                        [LclId] =
                                            CCCS (,)! [sat_sbQbW sat_sbQc0];
                                      } in  GHC.Base.return $dMonad_sbQbN sat_sbQc1; } in
                            let {
                              sat_sbQbR [Occ=Once] :: m_XbN5E (c_abN3b, b'_abN3c)
                              [LclId] =
                                  [$dMonad_sbQbN f_sbQbO eta_sbQbQ] \u []
                                      Control.Arrow.$fArrowKleisli3 $dMonad_sbQbN f_sbQbO eta_sbQbQ;
                            } in  GHC.Base.>>= $dMonad_sbQbN sat_sbQbR sat_sbQc2;
                  } in  GHC.Base.>>= $dMonad_sbQbN sat_sbQc3 sat_sbQc4;
        } in  GHC.Base.>>= $dMonad_sbQbN sat_sbQc5 sat_sbQcg;

Control.Arrow.$fArrowKleisli1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c c'.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m b c' -> b -> m (c, c')
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(U)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbQch f_sbQci g_sbQcj eta_sbQck]
        let {
          sat_sbQcn [Occ=Once]
            :: (b_abN3o, b_abN3o) -> m_XbN5D (c_abN3p, c'_abN3q)
          [LclId] =
              [$dMonad_sbQch f_sbQci g_sbQcj] \r [eta_B1]
                  Control.Arrow.$fArrowKleisli2
                      $dMonad_sbQch f_sbQci g_sbQcj eta_B1; } in
        let {
          sat_sbQcm [Occ=Once] :: m_XbN5D (b_abN3o, b_abN3o)
          [LclId] =
              [$dMonad_sbQch eta_sbQck] \u []
                  let {
                    sat_sbQcl [Occ=Once] :: (b_abN3o, b_abN3o)
                    [LclId] =
                        CCCS (,)! [eta_sbQck eta_sbQck];
                  } in  GHC.Base.return $dMonad_sbQch sat_sbQcl;
        } in  GHC.Base.>>= $dMonad_sbQch sat_sbQcm sat_sbQcn;

Control.Arrow.$fArrowKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     Control.Arrow.Arrow (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,U,A)>m] =
    [] \r [$dMonad_sbQco]
        let {
          sat_sbQcu [Occ=Once]
            :: forall b c c'.
               Control.Arrow.Kleisli m_XbN5C b c
               -> Control.Arrow.Kleisli m_XbN5C b c'
               -> Control.Arrow.Kleisli m_XbN5C b (c, c')
          [LclId] =
              [$dMonad_sbQco] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli1
                      $dMonad_sbQco eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbQct [Occ=Once]
            :: forall b c b' c'.
               Control.Arrow.Kleisli m_XbN5C b c
               -> Control.Arrow.Kleisli m_XbN5C b' c'
               -> Control.Arrow.Kleisli m_XbN5C (b, b') (c, c')
          [LclId] =
              [$dMonad_sbQco] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli2
                      $dMonad_sbQco eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbQcs [Occ=Once]
            :: forall b c d.
               Control.Arrow.Kleisli m_XbN5C b c
               -> Control.Arrow.Kleisli m_XbN5C (d, b) (d, c)
          [LclId] =
              [$dMonad_sbQco] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli4 $dMonad_sbQco eta_B2 eta_B1; } in
        let {
          sat_sbQcr [Occ=Once]
            :: forall b c d.
               Control.Arrow.Kleisli m_XbN5C b c
               -> Control.Arrow.Kleisli m_XbN5C (b, d) (c, d)
          [LclId] =
              [$dMonad_sbQco] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli3 $dMonad_sbQco eta_B2 eta_B1; } in
        let {
          sat_sbQcq [Occ=Once]
            :: forall b c. (b -> c) -> Control.Arrow.Kleisli m_XbN5C b c
          [LclId] =
              [$dMonad_sbQco] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli5 $dMonad_sbQco eta_B2 eta_B1; } in
        let {
          sat_sbQcp [Occ=Once]
            :: Control.Category.Category (Control.Arrow.Kleisli m_XbN5C)
          [LclId] =
              [$dMonad_sbQco] \u []
                  Control.Arrow.$fCategoryTYPEKleisli $dMonad_sbQco;
        } in 
          Control.Arrow.C:Arrow [sat_sbQcp
                                 sat_sbQcq
                                 sat_sbQcr
                                 sat_sbQcs
                                 sat_sbQct
                                 sat_sbQcu];

Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop
  :: forall (m :: * -> *).
     Control.Monad.Fix.MonadFix m =>
     Control.Arrow.Arrow (Control.Arrow.Kleisli m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,U,A),A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadFix_sbQcv]
        let {
          sat_sbQcw [Occ=Once, Dmd=<L,U(A,C(C1(U)),A,U,A)>]
            :: GHC.Base.Monad m_XbMVo
          [LclId] =
              [$dMonadFix_sbQcv] \u []
                  Control.Monad.Fix.$p1MonadFix $dMonadFix_sbQcv;
        } in  Control.Arrow.$fArrowKleisli sat_sbQcw;

Control.Arrow.$fArrowLoopKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     Control.Monad.Fix.MonadFix m =>
     Control.Arrow.ArrowLoop (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U)),A,U,A),C(U))>m] =
    [] \r [$dMonadFix_sbQcx]
        let {
          sat_sbQcz [Occ=Once]
            :: forall b d c.
               Control.Arrow.Kleisli m_XbMVp (b, d) (c, d)
               -> Control.Arrow.Kleisli m_XbMVp b c
          [LclId] =
              [$dMonadFix_sbQcx] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowLoopKleisli1
                      $dMonadFix_sbQcx eta_B2 eta_B1; } in
        let {
          sat_sbQcy [Occ=Once]
            :: Control.Arrow.Arrow (Control.Arrow.Kleisli m_XbMVp)
          [LclId] =
              [$dMonadFix_sbQcx] \u []
                  Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop $dMonadFix_sbQcx;
        } in  Control.Arrow.C:ArrowLoop [sat_sbQcy sat_sbQcz];

lvl3_rbNCb
  :: forall (m :: * -> *) b c.
     (Control.Arrow.Kleisli m b c, b) -> m c
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),U)>,
 Unf=OtherCon []] =
    [] \r [ds_sbQcA]
        case ds_sbQcA of {
          (,) ds1_sbQcC [Occ=Once] x_sbQcD [Occ=Once] -> ds1_sbQcC x_sbQcD;
        };

Control.Arrow.$fArrowApplyKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     Control.Arrow.ArrowApply (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,U,A)>m] =
    [] \r [$dMonad_sbQcE]
        let {
          sat_sbQcF [Occ=Once]
            :: Control.Arrow.Arrow (Control.Arrow.Kleisli m_XbN1f)
          [LclId] =
              [$dMonad_sbQcE] \u [] Control.Arrow.$fArrowKleisli $dMonad_sbQcE;
        } in  Control.Arrow.C:ArrowApply [sat_sbQcF lvl3_rbNCb];

Control.Arrow.$fArrowChoiceKleisli1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c b' c'.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m b' c'
     -> Data.Either.Either b b'
     -> m (Data.Either.Either c c')
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbQcG f_sbQcH g_sbQcI eta_sbQcJ]
        case eta_sbQcJ of {
          Data.Either.Left x_sbQcL [Occ=Once] ->
              let {
                sat_sbQcP [Occ=Once]
                  :: c_abMYX -> m_XbN1R (Data.Either.Either c_abMYX c'_abMYZ)
                [LclId] =
                    [$dMonad_sbQcG] \r [eta1_sbQcN]
                        let {
                          sat_sbQcO [Occ=Once] :: Data.Either.Either c_abMYX c'_abMYZ
                          [LclId] =
                              CCCS Data.Either.Left! [eta1_sbQcN];
                        } in  GHC.Base.return $dMonad_sbQcG sat_sbQcO; } in
              let {
                sat_sbQcM [Occ=Once] :: m_XbN1R c_abMYX
                [LclId] =
                    [f_sbQcH x_sbQcL] \u [] f_sbQcH x_sbQcL;
              } in  GHC.Base.>>= $dMonad_sbQcG sat_sbQcM sat_sbQcP;
          Data.Either.Right y_sbQcQ [Occ=Once] ->
              let {
                sat_sbQcU [Occ=Once]
                  :: c'_abMYZ -> m_XbN1R (Data.Either.Either c_abMYX c'_abMYZ)
                [LclId] =
                    [$dMonad_sbQcG] \r [eta1_sbQcS]
                        let {
                          sat_sbQcT [Occ=Once] :: Data.Either.Either c_abMYX c'_abMYZ
                          [LclId] =
                              CCCS Data.Either.Right! [eta1_sbQcS];
                        } in  GHC.Base.return $dMonad_sbQcG sat_sbQcT; } in
              let {
                sat_sbQcR [Occ=Once] :: m_XbN1R c'_abMYZ
                [LclId] =
                    [g_sbQcI y_sbQcQ] \u [] g_sbQcI y_sbQcQ;
              } in  GHC.Base.>>= $dMonad_sbQcG sat_sbQcR sat_sbQcU;
        };

Control.Arrow.$fArrowChoiceKleisli3
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c d.
     Control.Arrow.Kleisli m b c
     -> Data.Either.Either b d -> m (Data.Either.Either c d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbQcV f_sbQcW eta_sbQcX]
        let {
          sat_sbQcZ [Occ=Once]
            :: Control.Arrow.Kleisli m_XbN1Q d_abMYe d_abMYe
          [LclId] =
              [$dMonad_sbQcV] \r [eta1_sbQcY]
                  GHC.Base.return $dMonad_sbQcV eta1_sbQcY;
        } in 
          Control.Arrow.$fArrowChoiceKleisli1
              $dMonad_sbQcV f_sbQcW sat_sbQcZ eta_sbQcX;

Control.Arrow.$fArrowChoiceKleisli2
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c d.
     Control.Arrow.Kleisli m b c
     -> Data.Either.Either d b -> m (Data.Either.Either d c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbQd0 f_sbQd1 eta_sbQd2]
        let {
          sat_sbQd4 [Occ=Once]
            :: Control.Arrow.Kleisli m_XbN1P d_abMYB d_abMYB
          [LclId] =
              [$dMonad_sbQd0] \r [eta1_sbQd3]
                  GHC.Base.return $dMonad_sbQd0 eta1_sbQd3;
        } in 
          Control.Arrow.$fArrowChoiceKleisli1
              $dMonad_sbQd0 sat_sbQd4 f_sbQd1 eta_sbQd2;

lvl4_rbNCc
  :: forall (m :: * -> *) b d c.
     Control.Arrow.Kleisli m b d
     -> Control.Arrow.Kleisli m c d -> Data.Either.Either b c -> m d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbQd5 ds1_sbQd6 eta_sbQd7]
        Data.Either.either ds_sbQd5 ds1_sbQd6 eta_sbQd7;

Control.Arrow.$fArrowChoiceKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     Control.Arrow.ArrowChoice (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,U,A)>m] =
    [] \r [$dMonad_sbQd8]
        let {
          sat_sbQdc [Occ=Once]
            :: forall b c b' c'.
               Control.Arrow.Kleisli m_XbN1O b c
               -> Control.Arrow.Kleisli m_XbN1O b' c'
               -> Control.Arrow.Kleisli
                    m_XbN1O (Data.Either.Either b b') (Data.Either.Either c c')
          [LclId] =
              [$dMonad_sbQd8] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fArrowChoiceKleisli1
                      $dMonad_sbQd8 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbQdb [Occ=Once]
            :: forall b c d.
               Control.Arrow.Kleisli m_XbN1O b c
               -> Control.Arrow.Kleisli
                    m_XbN1O (Data.Either.Either d b) (Data.Either.Either d c)
          [LclId] =
              [$dMonad_sbQd8] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowChoiceKleisli2
                      $dMonad_sbQd8 eta_B2 eta_B1; } in
        let {
          sat_sbQda [Occ=Once]
            :: forall b c d.
               Control.Arrow.Kleisli m_XbN1O b c
               -> Control.Arrow.Kleisli
                    m_XbN1O (Data.Either.Either b d) (Data.Either.Either c d)
          [LclId] =
              [$dMonad_sbQd8] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowChoiceKleisli3
                      $dMonad_sbQd8 eta_B2 eta_B1; } in
        let {
          sat_sbQd9 [Occ=Once]
            :: Control.Arrow.Arrow (Control.Arrow.Kleisli m_XbN1O)
          [LclId] =
              [$dMonad_sbQd8] \u [] Control.Arrow.$fArrowKleisli $dMonad_sbQd8;
        } in 
          Control.Arrow.C:ArrowChoice [sat_sbQd9
                                       sat_sbQda
                                       sat_sbQdb
                                       sat_sbQdc
                                       lvl4_rbNCc];

Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Control.Arrow.Arrow (Control.Arrow.Kleisli m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(A,C(C1(U)),A,U,A),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbQdd]
        let {
          sat_sbQde [Occ=Once, Dmd=<L,U(A,C(C1(U)),A,U,A)>]
            :: GHC.Base.Monad m_XbN5r
          [LclId] =
              [$dMonadPlus_sbQdd] \u [] GHC.Base.$p2MonadPlus $dMonadPlus_sbQdd;
        } in  Control.Arrow.$fArrowKleisli sat_sbQde;

Control.Arrow.$fArrowZeroKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Control.Arrow.ArrowZero (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U(A,C(C1(U)),A,U,A),1*U,A)>m] =
    [] \r [$dMonadPlus_sbQdf]
        let {
          lvl5_sbQdg [Occ=OnceL] :: forall c. m_XbN5s c
          [LclId] =
              [$dMonadPlus_sbQdf] \u [] GHC.Base.mzero $dMonadPlus_sbQdf; } in
        let {
          sat_sbQdj [Occ=Once]
            :: forall b c. Control.Arrow.Kleisli m_XbN5s b c
          [LclId] =
              [lvl5_sbQdg] \r [ds_sbQdi] lvl5_sbQdg; } in
        let {
          sat_sbQdh [Occ=Once]
            :: Control.Arrow.Arrow (Control.Arrow.Kleisli m_XbN5s)
          [LclId] =
              [$dMonadPlus_sbQdf] \u []
                  Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero $dMonadPlus_sbQdf;
        } in  Control.Arrow.C:ArrowZero [sat_sbQdh sat_sbQdj];

Control.Arrow.$fArrowPlusKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Control.Arrow.ArrowPlus (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,U(A,C(C1(U)),A,U,A),U,C(C1(U)))>m] =
    [] \r [$dMonadPlus_sbQdk]
        let {
          sat_sbQdm [Occ=Once]
            :: forall b c.
               Control.Arrow.Kleisli m_XbN58 b c
               -> Control.Arrow.Kleisli m_XbN58 b c
               -> Control.Arrow.Kleisli m_XbN58 b c
          [LclId] =
              [$dMonadPlus_sbQdk] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fArrowPlusKleisli1
                      $dMonadPlus_sbQdk eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbQdl [Occ=Once]
            :: Control.Arrow.ArrowZero (Control.Arrow.Kleisli m_XbN58)
          [LclId] =
              [$dMonadPlus_sbQdk] \u []
                  Control.Arrow.$fArrowZeroKleisli $dMonadPlus_sbQdk;
        } in  Control.Arrow.C:ArrowPlus [sat_sbQdl sat_sbQdm];

Control.Arrow.$dmsecond
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c d. a b c -> a (d, b) (d, c)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLC(S)L),U(1*U(1*U,A),A,A,A,1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQdn]
        let {
          sat_sbQdp [Occ=Once] :: a_abMuz d_abMNj d_abMNj
          [LclId] =
              [$dArrow_sbQdn] \u []
                  case Control.Arrow.$p1Arrow $dArrow_sbQdn of sat_sbQdo {
                    __DEFAULT -> Control.Category.id sat_sbQdo;
                  };
        } in  Control.Arrow.*** $dArrow_sbQdn sat_sbQdp;

Control.Arrow.$dmfirst
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c d. a b c -> a (b, d) (c, d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLC(C(S))L),U(1*U(1*U,A),A,A,A,1*C1(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQdq eta_sbQdr]
        let {
          sat_sbQdt [Occ=Once] :: a_abMuz d_abMN2 d_abMN2
          [LclId] =
              [$dArrow_sbQdq] \u []
                  case Control.Arrow.$p1Arrow $dArrow_sbQdq of sat_sbQds {
                    __DEFAULT -> Control.Category.id sat_sbQds;
                  };
        } in  Control.Arrow.*** $dArrow_sbQdq eta_sbQdr sat_sbQdt;

Control.Arrow.$cfirst :: forall b c d. (b -> c) -> (b, d) -> (c, d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sbQdu ds1_sbQdv]
        let {
          sat_sbQdE [Occ=Once] :: d_abN4j
          [LclId] =
              [ds1_sbQdv] \u []
                  case ds1_sbQdv of {
                    (,) _ [Occ=Dead] y_sbQdD [Occ=Once] -> y_sbQdD;
                  }; } in
        let {
          sat_sbQdA [Occ=Once] :: c_abN4i
          [LclId] =
              [ds_sbQdu ds1_sbQdv] \u []
                  let {
                    sat_sbQdz [Occ=Once] :: b_abN4h
                    [LclId] =
                        [ds1_sbQdv] \u []
                            case ds1_sbQdv of {
                              (,) x_sbQdx [Occ=Once] _ [Occ=Dead] -> x_sbQdx;
                            };
                  } in  ds_sbQdu sat_sbQdz;
        } in  (,) [sat_sbQdA sat_sbQdE];

Control.Arrow.$csecond
  :: forall b c d. (b -> c) -> (d, b) -> (d, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sbQdF ds_sbQdG]
        let {
          sat_sbQdP [Occ=Once] :: c_abN4u
          [LclId] =
              [g_sbQdF ds_sbQdG] \u []
                  let {
                    sat_sbQdO [Occ=Once] :: b_abN4t
                    [LclId] =
                        [ds_sbQdG] \u []
                            case ds_sbQdG of {
                              (,) _ [Occ=Dead] y_sbQdN [Occ=Once] -> y_sbQdN;
                            };
                  } in  g_sbQdF sat_sbQdO; } in
        let {
          sat_sbQdK [Occ=Once] :: d_abN4v
          [LclId] =
              [ds_sbQdG] \u []
                  case ds_sbQdG of {
                    (,) x_sbQdI [Occ=Once] _ [Occ=Dead] -> x_sbQdI;
                  };
        } in  (,) [sat_sbQdK sat_sbQdP];

Control.Arrow.$c&&&
  :: forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [f_sbQdQ g_sbQdR eta_sbQdS]
        let {
          sat_sbQdU [Occ=Once] :: c'_abN4P
          [LclId] =
              [g_sbQdR eta_sbQdS] \u [] g_sbQdR eta_sbQdS; } in
        let {
          sat_sbQdT [Occ=Once] :: c_abN4O
          [LclId] =
              [f_sbQdQ eta_sbQdS] \u [] f_sbQdQ eta_sbQdS;
        } in  (,) [sat_sbQdT sat_sbQdU];

Control.Arrow.$fArrow(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Arrow.Arrow (->)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Arrow.C:Arrow! [Control.Category.$fCategoryTYPE(->)
                                          Control.Arrow.$fArrow(->)_$carr
                                          Control.Arrow.$cfirst
                                          Control.Arrow.$csecond
                                          Control.Arrow.$c***
                                          Control.Arrow.$c&&&];

Control.Arrow.$fArrowLoop(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Arrow.ArrowLoop (->)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Arrow.C:ArrowLoop! [Control.Arrow.$fArrow(->)
                                              Control.Arrow.$fArrowLoop(->)_$cloop];

Control.Arrow.$fArrowApply(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Arrow.ArrowApply (->)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Arrow.C:ArrowApply! [Control.Arrow.$fArrow(->)
                                               Control.Arrow.$fAlternativeArrowMonad_$capp];

Control.Arrow.$c+++
  :: forall b c b' c'.
     (b -> c)
     -> (b' -> c') -> Data.Either.Either b b' -> Data.Either.Either c c'
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sbQdV g_sbQdW ds1_sbQdX]
        case ds1_sbQdX of {
          Data.Either.Left x_sbQdZ [Occ=Once] ->
              let {
                sat_sbQe0 [Occ=Once] :: c_abN0A
                [LclId] =
                    [f_sbQdV x_sbQdZ] \u [] f_sbQdV x_sbQdZ;
              } in  Data.Either.Left [sat_sbQe0];
          Data.Either.Right y_sbQe1 [Occ=Once] ->
              let {
                sat_sbQe2 [Occ=Once] :: c'_abN0C
                [LclId] =
                    [g_sbQdW y_sbQe1] \u [] g_sbQdW y_sbQe1;
              } in  Data.Either.Right [sat_sbQe2];
        };

Control.Arrow.$cright
  :: forall b c d.
     (b -> c) -> Data.Either.Either d b -> Data.Either.Either d c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sbQe3 ds1_sbQe4]
        case ds1_sbQe4 of {
          Data.Either.Left x_sbQe6 [Occ=Once] -> wild_sbQe5;
          Data.Either.Right y_sbQe7 [Occ=Once] ->
              let {
                sat_sbQe8 [Occ=Once] :: c_abN0g
                [LclId] =
                    [f_sbQe3 y_sbQe7] \u [] f_sbQe3 y_sbQe7;
              } in  Data.Either.Right [sat_sbQe8];
        };

Control.Arrow.$cleft
  :: forall b c d.
     (b -> c) -> Data.Either.Either b d -> Data.Either.Either c d
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sbQe9 ds1_sbQea]
        case ds1_sbQea of {
          Data.Either.Left x_sbQec [Occ=Once] ->
              let {
                sat_sbQed [Occ=Once] :: c_abMZW
                [LclId] =
                    [f_sbQe9 x_sbQec] \u [] f_sbQe9 x_sbQec;
              } in  Data.Either.Left [sat_sbQed];
          Data.Either.Right y_sbQee [Occ=Once] -> wild_sbQeb;
        };

Control.Arrow.$fArrowChoice(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Arrow.ArrowChoice (->)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Arrow.C:ArrowChoice! [Control.Arrow.$fArrow(->)
                                                Control.Arrow.$cleft
                                                Control.Arrow.$cright
                                                Control.Arrow.$c+++
                                                Data.Either.either];

Control.Arrow.runKleisli1
  :: forall (m :: * -> *) a b.
     Control.Arrow.Kleisli m a b -> Control.Arrow.Kleisli m a b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbQef] ds_sbQef;

Control.Arrow.runKleisli
  :: forall (m :: * -> *) a b.
     Control.Arrow.Kleisli m a b -> a -> m b
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Control.Arrow.runKleisli1 eta_B1;

Control.Arrow.returnA
  :: forall (a :: * -> * -> *) b. Control.Arrow.Arrow a => a b b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQeg] Control.Arrow.arr $dArrow_sbQeg GHC.Base.id;

Control.Arrow.^>>
  :: forall (a :: * -> * -> *) b c d.
     Control.Arrow.Arrow a =>
     (b -> c) -> a c d -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQeh eta_sbQei eta1_sbQej]
        let {
          sat_sbQel [Occ=Once] :: a_abMMs b_abMMt c_abMMu
          [LclId] =
              [$dArrow_sbQeh eta_sbQei] \u []
                  Control.Arrow.arr $dArrow_sbQeh eta_sbQei;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbQeh of sat_sbQek {
            __DEFAULT -> Control.Category.. sat_sbQek eta1_sbQej sat_sbQel;
          };

Control.Arrow.>>^
  :: forall (a :: * -> * -> *) b c d.
     Control.Arrow.Arrow a =>
     a b c -> (c -> d) -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQem eta_sbQen eta1_sbQeo]
        let {
          sat_sbQeq [Occ=Once] :: a_abMMb c_abMMd d_abMMe
          [LclId] =
              [$dArrow_sbQem eta1_sbQeo] \u []
                  Control.Arrow.arr $dArrow_sbQem eta1_sbQeo;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbQem of sat_sbQep {
            __DEFAULT -> Control.Category.. sat_sbQep sat_sbQeq eta_sbQen;
          };

Control.Arrow.<<^
  :: forall (a :: * -> * -> *) c d b.
     Control.Arrow.Arrow a =>
     a c d -> (b -> c) -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQer eta_sbQes eta1_sbQet]
        let {
          sat_sbQev [Occ=Once] :: a_abMLU b_abMLX c_abMLV
          [LclId] =
              [$dArrow_sbQer eta1_sbQet] \u []
                  Control.Arrow.arr $dArrow_sbQer eta1_sbQet;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbQer of sat_sbQeu {
            __DEFAULT -> Control.Category.. sat_sbQeu eta_sbQes sat_sbQev;
          };

Control.Arrow.^<<
  :: forall (a :: * -> * -> *) c d b.
     Control.Arrow.Arrow a =>
     (c -> d) -> a b c -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQew eta_sbQex eta1_sbQey]
        let {
          sat_sbQeA [Occ=Once] :: a_abMLx c_abMLy d_abMLz
          [LclId] =
              [$dArrow_sbQew eta_sbQex] \u []
                  Control.Arrow.arr $dArrow_sbQew eta_sbQex;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbQew of sat_sbQez {
            __DEFAULT -> Control.Category.. sat_sbQez sat_sbQeA eta1_sbQey;
          };

Control.Arrow.leftApp
  :: forall (a :: * -> * -> *) b c d.
     Control.Arrow.ArrowApply a =>
     a b c -> a (Data.Either.Either b d) (Data.Either.Either c d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(1*U(1*U(A,C(C1(U))),C(U),A,A,A,A),1*U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbQeB eta_sbQeC]
        case
            Control.Arrow.$p1ArrowApply $dArrowApply_sbQeB
        of
        $dArrow_sbQeD [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),C(U),A,A,A,A)>]
        { __DEFAULT ->
              case
                  Control.Arrow.$p1Arrow $dArrow_sbQeD
              of
              $dCategory_sbQeE [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
              { __DEFAULT ->
                    let {
                      sat_sbQeX [Occ=Once]
                        :: a_abMK6 (Data.Either.Either
                                      b_abMK7 d_abMK9) (a_abMK6 () (Data.Either.Either
                                                                      c_abMK8 d_abMK9),
                                                        ())
                      [LclId] =
                          [eta_sbQeC $dArrow_sbQeD $dCategory_sbQeE] \u []
                              let {
                                lvl5_sbQeG [Occ=OnceL]
                                  :: a_abMK6 c_abMK8 (Data.Either.Either c_abMK8 d_abMK9)
                                [LclId] =
                                    [$dArrow_sbQeD] \u []
                                        Control.Arrow.arr $dArrow_sbQeD Data.Either.Left; } in
                              let {
                                sat_sbQeW [Occ=Once]
                                  :: Data.Either.Either b_abMK7 d_abMK9
                                     -> (a_abMK6 () (Data.Either.Either c_abMK8 d_abMK9), ())
                                [LclId] =
                                    [eta_sbQeC
                                     $dArrow_sbQeD
                                     $dCategory_sbQeE
                                     lvl5_sbQeG] \r [ds1_sbQeH]
                                        case ds1_sbQeH of {
                                          Data.Either.Left x_sbQeJ [Occ=OnceL] ->
                                              let {
                                                sat_sbQeP [Occ=Once]
                                                  :: a_abMK6 () (Data.Either.Either c_abMK8 d_abMK9)
                                                [LclId] =
                                                    [eta_sbQeC
                                                     $dArrow_sbQeD
                                                     $dCategory_sbQeE
                                                     lvl5_sbQeG
                                                     x_sbQeJ] \u []
                                                        let {
                                                          sat_sbQeO [Occ=Once] :: a_abMK6 () c_abMK8
                                                          [LclId] =
                                                              [eta_sbQeC
                                                               $dArrow_sbQeD
                                                               $dCategory_sbQeE
                                                               x_sbQeJ] \u []
                                                                  let {
                                                                    sat_sbQeN [Occ=Once]
                                                                      :: a_abMK6 () b_abMK7
                                                                    [LclId] =
                                                                        [$dArrow_sbQeD
                                                                         x_sbQeJ] \u []
                                                                            let {
                                                                              sat_sbQeM [Occ=Once]
                                                                                :: () -> b_abMK7
                                                                              [LclId] =
                                                                                  [x_sbQeJ] \r [ds_sbQeK]
                                                                                      case
                                                                                          ds_sbQeK
                                                                                      of
                                                                                      { () ->
                                                                                            x_sbQeJ;
                                                                                      };
                                                                            } in 
                                                                              Control.Arrow.arr
                                                                                  $dArrow_sbQeD
                                                                                  sat_sbQeM;
                                                                  } in 
                                                                    Control.Category..
                                                                        $dCategory_sbQeE
                                                                        eta_sbQeC
                                                                        sat_sbQeN;
                                                        } in 
                                                          Control.Category..
                                                              $dCategory_sbQeE lvl5_sbQeG sat_sbQeO;
                                              } in  (,) [sat_sbQeP GHC.Tuple.()];
                                          Data.Either.Right y_sbQeQ [Occ=OnceL] ->
                                              let {
                                                sat_sbQeV [Occ=Once]
                                                  :: a_abMK6 () (Data.Either.Either c_abMK8 d_abMK9)
                                                [LclId] =
                                                    [$dArrow_sbQeD y_sbQeQ] \u []
                                                        let {
                                                          sat_sbQeU [Occ=Once]
                                                            :: ()
                                                               -> Data.Either.Either c_abMK8 d_abMK9
                                                          [LclId] =
                                                              [y_sbQeQ] \r [x_sbQeR]
                                                                  let {
                                                                    sat_sbQeT [Occ=Once] :: d_abMK9
                                                                    [LclId] =
                                                                        [y_sbQeQ x_sbQeR] \u []
                                                                            case x_sbQeR of {
                                                                              () -> y_sbQeQ;
                                                                            };
                                                                  } in 
                                                                    Data.Either.Right [sat_sbQeT];
                                                        } in 
                                                          Control.Arrow.arr $dArrow_sbQeD sat_sbQeU;
                                              } in  (,) [sat_sbQeV GHC.Tuple.()];
                                        };
                              } in  Control.Arrow.arr $dArrow_sbQeD sat_sbQeW; } in
                    let {
                      sat_sbQeF [Occ=Once]
                        :: a_abMK6 (a_abMK6 () (Data.Either.Either c_abMK8 d_abMK9),
                                    ()) (Data.Either.Either c_abMK8 d_abMK9)
                      [LclId] =
                          [$dArrowApply_sbQeB] \u [] Control.Arrow.app $dArrowApply_sbQeB;
                    } in  Control.Category.. $dCategory_sbQeE sat_sbQeF sat_sbQeX;
              };
        };

Control.Arrow.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Control.Arrow.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$trModule4];

Control.Arrow.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Control.Arrow"#;

Control.Arrow.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$trModule2];

Control.Arrow.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Control.Arrow.$trModule3
                                     Control.Arrow.$trModule1];

$krep_rbNCd :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Tuple.$tc()
                                              GHC.Types.[]];

$krep1_rbNCe :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Control.Arrow.$tcKleisli1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         GHC.Types.krep$*->*->*];

Control.Arrow.$tcArrow1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep1_rbNCe];

Control.Arrow.$tcArrowMonad1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         GHC.Types.krep$*Arr*];

$krep2_rbNCf :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep3_rbNCg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep4_rbNCh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep5_rbNCi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_rbNCh $krep2_rbNCf];

$krep6_rbNCj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rbNCg $krep5_rbNCi];

$krep7_rbNCk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_rbNCh $krep_rbNCd];

$krep8_rbNCl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep7_rbNCk $krep3_rbNCg];

Control.Arrow.$tcArrow3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Arrow"#;

Control.Arrow.$tcArrow2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrow3];

Control.Arrow.$tcArrow :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12964584583212294992##
                                    10211991410748124746##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrow2
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcKleisli3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Kleisli"#;

Control.Arrow.$tcKleisli2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcKleisli3];

Control.Arrow.$tcKleisli :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2023158159015915132##
                                    6143719008973118504##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcKleisli2
                                    0#
                                    Control.Arrow.$tcKleisli1];

$krep9_rbNCm :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rbNCf GHC.Types.[]];

$krep10_rbNCn :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_rbNCg $krep9_rbNCm];

$krep11_rbNCo :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_rbNCh $krep10_rbNCn];

$krep12_rbNCp :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Arrow.$tcKleisli
                                              $krep11_rbNCo];

Control.Arrow.$tc'Kleisli1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_rbNCj $krep12_rbNCp];

Control.Arrow.$tc'Kleisli3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Kleisli"#;

Control.Arrow.$tc'Kleisli2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tc'Kleisli3];

Control.Arrow.$tc'Kleisli :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [793719726112502834##
                                    14919550952510816382##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tc'Kleisli2
                                    3#
                                    Control.Arrow.$tc'Kleisli1];

Control.Arrow.$tcArrowZero2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowZero"#;

Control.Arrow.$tcArrowZero1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowZero2];

Control.Arrow.$tcArrowZero :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [337582314637215801##
                                    485553589222180171##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowZero1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcArrowPlus2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowPlus"#;

Control.Arrow.$tcArrowPlus1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowPlus2];

Control.Arrow.$tcArrowPlus :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9089885184909062397##
                                    13092571182525076608##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowPlus1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcArrowChoice2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowChoice"#;

Control.Arrow.$tcArrowChoice1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowChoice2];

Control.Arrow.$tcArrowChoice :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9045385674203608923##
                                    4474606397073518393##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowChoice1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcArrowApply2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowApply"#;

Control.Arrow.$tcArrowApply1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowApply2];

Control.Arrow.$tcArrowApply :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4969046276209689969##
                                    2697302259091605677##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowApply1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcArrowMonad3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowMonad"#;

Control.Arrow.$tcArrowMonad2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowMonad3];

Control.Arrow.$tcArrowMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2648525758856951758##
                                    13692351200590237690##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowMonad2
                                    0#
                                    Control.Arrow.$tcArrowMonad1];

$krep13_rbNCq :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_rbNCg GHC.Types.[]];

$krep14_rbNCr :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_rbNCh $krep13_rbNCq];

$krep15_rbNCs :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Arrow.$tcArrowMonad
                                              $krep14_rbNCr];

Control.Arrow.$tc'ArrowMonad1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_rbNCl $krep15_rbNCs];

Control.Arrow.$tc'ArrowMonad3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'ArrowMonad"#;

Control.Arrow.$tc'ArrowMonad2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tc'ArrowMonad3];

Control.Arrow.$tc'ArrowMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8781545391513276915##
                                    783725375361948493##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tc'ArrowMonad2
                                    2#
                                    Control.Arrow.$tc'ArrowMonad1];

Control.Arrow.$tcArrowLoop2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowLoop"#;

Control.Arrow.$tcArrowLoop1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowLoop2];

Control.Arrow.$tcArrowLoop :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15298492960828880948##
                                    13953070859738786616##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowLoop1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.C:ArrowLoop
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     (forall b d c. a (b, d) (c, d) -> a b c)
     -> Control.Arrow.ArrowLoop a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Control.Arrow.C:ArrowLoop [eta_B2 eta_B1];

Control.Arrow.C:ArrowApply
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     (forall b c. a (a b c, b) c) -> Control.Arrow.ArrowApply a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Control.Arrow.C:ArrowApply [eta_B2 eta_B1];

Control.Arrow.C:ArrowChoice
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     (forall b c d.
      a b c -> a (Data.Either.Either b d) (Data.Either.Either c d))
     -> (forall b c d.
         a b c -> a (Data.Either.Either d b) (Data.Either.Either d c))
     -> (forall b c b' c'.
         a b c
         -> a b' c'
         -> a (Data.Either.Either b b') (Data.Either.Either c c'))
     -> (forall b d c. a b d -> a c d -> a (Data.Either.Either b c) d)
     -> Control.Arrow.ArrowChoice a
[GblId[DataCon],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Control.Arrow.C:ArrowChoice [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];

Control.Arrow.C:ArrowPlus
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowZero a =>
     (forall b c. a b c -> a b c -> a b c) -> Control.Arrow.ArrowPlus a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Control.Arrow.C:ArrowPlus [eta_B2 eta_B1];

Control.Arrow.C:ArrowZero
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     (forall b c. a b c) -> Control.Arrow.ArrowZero a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Control.Arrow.C:ArrowZero [eta_B2 eta_B1];

Control.Arrow.C:Arrow
  :: forall (a :: * -> * -> *).
     Control.Category.Category a =>
     (forall b c. (b -> c) -> a b c)
     -> (forall b c d. a b c -> a (b, d) (c, d))
     -> (forall b c d. a b c -> a (d, b) (d, c))
     -> (forall b c b' c'. a b c -> a b' c' -> a (b, b') (c, c'))
     -> (forall b c c'. a b c -> a b c' -> a b (c, c'))
     -> Control.Arrow.Arrow a
[GblId[DataCon],
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Control.Arrow.C:Arrow [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:06:43.740386945 UTC

Control.Arrow.$p1ArrowLoop
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowLoop a =>
     Control.Arrow.Arrow a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sbQ5u]
        case v_sbQ5u of {
          Control.Arrow.C:ArrowLoop v_sbQ5w [Occ=Once] _ [Occ=Dead] ->
              v_sbQ5w;
        };

Control.Arrow.loop
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowLoop a =>
     forall b d c. a (b, d) (c, d) -> a b c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sbQ5y]
        case v_sbQ5y of {
          Control.Arrow.C:ArrowLoop _ [Occ=Dead] v_sbQ5B [Occ=Once] ->
              v_sbQ5B;
        };

Control.Arrow.$p1ArrowApply
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     Control.Arrow.Arrow a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sbQ5C]
        case v_sbQ5C of {
          Control.Arrow.C:ArrowApply v_sbQ5E [Occ=Once] _ [Occ=Dead] ->
              v_sbQ5E;
        };

Control.Arrow.app
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     forall b c. a (a b c, b) c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sbQ5G]
        case v_sbQ5G of {
          Control.Arrow.C:ArrowApply _ [Occ=Dead] v_sbQ5J [Occ=Once] ->
              v_sbQ5J;
        };

Control.Arrow.$p1ArrowChoice
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     Control.Arrow.Arrow a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLL),U(U,A,A,A,A)>] =
    [] \r [v_sbQ5K]
        case v_sbQ5K of {
          Control.Arrow.C:ArrowChoice v_sbQ5M [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_sbQ5M;
        };

Control.Arrow.left
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c d.
     a b c -> a (Data.Either.Either b d) (Data.Either.Either c d)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLL),U(A,U,A,A,A)>] =
    [] \r [v_sbQ5R]
        case v_sbQ5R of {
          Control.Arrow.C:ArrowChoice _ [Occ=Dead]
                                      v_sbQ5U [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_sbQ5U;
        };

Control.Arrow.right
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c d.
     a b c -> a (Data.Either.Either d b) (Data.Either.Either d c)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLL),U(A,A,U,A,A)>] =
    [] \r [v_sbQ5Y]
        case v_sbQ5Y of {
          Control.Arrow.C:ArrowChoice _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_sbQ62 [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_sbQ62;
        };

Control.Arrow.+++
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c b' c'.
     a b c
     -> a b' c' -> a (Data.Either.Either b b') (Data.Either.Either c c')
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSL),U(A,A,A,U,A)>] =
    [] \r [v_sbQ65]
        case v_sbQ65 of {
          Control.Arrow.C:ArrowChoice _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_sbQ6a [Occ=Once]
                                      _ [Occ=Dead] ->
              v_sbQ6a;
        };

Control.Arrow.|||
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b d c. a b d -> a c d -> a (Data.Either.Either b c) d
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLS),U(A,A,A,A,U)>] =
    [] \r [v_sbQ6c]
        case v_sbQ6c of {
          Control.Arrow.C:ArrowChoice _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_sbQ6i [Occ=Once] ->
              v_sbQ6i;
        };

Control.Arrow.$p1ArrowPlus
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     Control.Arrow.ArrowZero a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sbQ6j]
        case v_sbQ6j of {
          Control.Arrow.C:ArrowPlus v_sbQ6l [Occ=Once] _ [Occ=Dead] ->
              v_sbQ6l;
        };

Control.Arrow.<+>
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     forall b c. a b c -> a b c -> a b c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sbQ6n]
        case v_sbQ6n of {
          Control.Arrow.C:ArrowPlus _ [Occ=Dead] v_sbQ6q [Occ=Once] ->
              v_sbQ6q;
        };

Control.Arrow.$p1ArrowZero
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowZero a =>
     Control.Arrow.Arrow a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sbQ6r]
        case v_sbQ6r of {
          Control.Arrow.C:ArrowZero v_sbQ6t [Occ=Once] _ [Occ=Dead] ->
              v_sbQ6t;
        };

Control.Arrow.zeroArrow
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowZero a =>
     forall b c. a b c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sbQ6v]
        case v_sbQ6v of {
          Control.Arrow.C:ArrowZero _ [Occ=Dead] v_sbQ6y [Occ=Once] ->
              v_sbQ6y;
        };

Control.Arrow.$p1Arrow
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     Control.Category.Category a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLL),U(U,A,A,A,A,A)>] =
    [] \r [v_sbQ6z]
        case v_sbQ6z of {
          Control.Arrow.C:Arrow v_sbQ6B [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_sbQ6B;
        };

Control.Arrow.arr
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c. (b -> c) -> a b c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLL),U(A,U,A,A,A,A)>] =
    [] \r [v_sbQ6H]
        case v_sbQ6H of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                v_sbQ6K [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_sbQ6K;
        };

Control.Arrow.first
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c d. a b c -> a (b, d) (c, d)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLL),U(A,A,U,A,A,A)>] =
    [] \r [v_sbQ6P]
        case v_sbQ6P of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_sbQ6T [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_sbQ6T;
        };

Control.Arrow.second
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c d. a b c -> a (d, b) (d, c)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLL),U(A,A,A,U,A,A)>] =
    [] \r [v_sbQ6X]
        case v_sbQ6X of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_sbQ72 [Occ=Once]
                                _ [Occ=Dead]
                                _ [Occ=Dead] ->
              v_sbQ72;
        };

Control.Arrow.***
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c b' c'. a b c -> a b' c' -> a (b, b') (c, c')
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSL),U(A,A,A,A,U,A)>] =
    [] \r [v_sbQ75]
        case v_sbQ75 of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_sbQ7b [Occ=Once]
                                _ [Occ=Dead] ->
              v_sbQ7b;
        };

Control.Arrow.&&&
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c c'. a b c -> a b c' -> a b (c, c')
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLS),U(A,A,A,A,A,U)>] =
    [] \r [v_sbQ7d]
        case v_sbQ7d of {
          Control.Arrow.C:Arrow _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                _ [Occ=Dead]
                                v_sbQ7k [Occ=Once] ->
              v_sbQ7k;
        };

Control.Arrow.$c***
  :: forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sbQ7l g_sbQ7m ds_sbQ7n]
        let {
          sat_sbQ7x [Occ=Once] :: c'_abN4I
          [LclId] =
              [g_sbQ7m ds_sbQ7n] \u []
                  let {
                    sat_sbQ7w [Occ=Once] :: b'_abN4H
                    [LclId] =
                        [ds_sbQ7n] \u []
                            case ds_sbQ7n of {
                              (,) _ [Occ=Dead] y_sbQ7v [Occ=Once] -> y_sbQ7v;
                            };
                  } in  g_sbQ7m sat_sbQ7w; } in
        let {
          sat_sbQ7s [Occ=Once] :: c_abN4G
          [LclId] =
              [f_sbQ7l ds_sbQ7n] \u []
                  let {
                    sat_sbQ7r [Occ=Once] :: b_abN4F
                    [LclId] =
                        [ds_sbQ7n] \u []
                            case ds_sbQ7n of {
                              (,) x_sbQ7p [Occ=Once] _ [Occ=Dead] -> x_sbQ7p;
                            };
                  } in  f_sbQ7l sat_sbQ7r;
        } in  (,) [sat_sbQ7s sat_sbQ7x];

Control.Arrow.$fArrow(->)_$carr :: forall b c. (b -> c) -> b -> c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [f_sbQ7y] f_sbQ7y;

Control.Arrow.$fCategoryTYPEKleisli1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c a.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m a b -> a -> m c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbQ7z ds_sbQ7A ds1_sbQ7B b1_sbQ7C]
        let {
          sat_sbQ7D [Occ=Once] :: m_abN3z b_abN3Q
          [LclId] =
              [ds1_sbQ7B b1_sbQ7C] \u [] ds1_sbQ7B b1_sbQ7C;
        } in  GHC.Base.>>= $dMonad_sbQ7z sat_sbQ7D ds_sbQ7A;

Control.Arrow.$fCategoryTYPEKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     Control.Category.Category (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,1*U,A)>m] =
    [] \r [$dMonad_sbQ7E]
        let {
          sat_sbQ7G [Occ=Once]
            :: forall b c a.
               Control.Arrow.Kleisli m_XbN5v b c
               -> Control.Arrow.Kleisli m_XbN5v a b
               -> Control.Arrow.Kleisli m_XbN5v a c
          [LclId] =
              [$dMonad_sbQ7E] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fCategoryTYPEKleisli1
                      $dMonad_sbQ7E eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbQ7F [Occ=Once] :: forall a. Control.Arrow.Kleisli m_XbN5v a a
          [LclId] =
              [$dMonad_sbQ7E] \u [] GHC.Base.return $dMonad_sbQ7E;
        } in  Control.Category.C:Category [sat_sbQ7F sat_sbQ7G];

Control.Arrow.$fArrowKleisli4
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c d. Control.Arrow.Kleisli m b c -> (d, b) -> m (d, c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,1*C1(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbQ7H ds_sbQ7I ds1_sbQ7J]
        let {
          d1_sbQ7K [Occ=OnceL] :: d_abN2Q
          [LclId] =
              [ds1_sbQ7J] \u []
                  case ds1_sbQ7J of {
                    (,) d2_sbQ7M [Occ=Once] _ [Occ=Dead] -> d2_sbQ7M;
                  }; } in
        let {
          sat_sbQ7V [Occ=Once] :: c_abN2P -> m_abN1X (d_abN2Q, c_abN2P)
          [LclId] =
              [$dMonad_sbQ7H d1_sbQ7K] \r [c1_sbQ7T]
                  let {
                    sat_sbQ7U [Occ=Once] :: (d_abN2Q, c_abN2P)
                    [LclId] =
                        CCCS (,)! [d1_sbQ7K c1_sbQ7T];
                  } in  GHC.Base.return $dMonad_sbQ7H sat_sbQ7U; } in
        let {
          sat_sbQ7S [Occ=Once] :: m_abN1X c_abN2P
          [LclId] =
              [ds_sbQ7I ds1_sbQ7J] \u []
                  let {
                    sat_sbQ7R [Occ=Once] :: b_abN2O
                    [LclId] =
                        [ds1_sbQ7J] \u []
                            case ds1_sbQ7J of {
                              (,) _ [Occ=Dead] b1_sbQ7Q [Occ=Once] -> b1_sbQ7Q;
                            };
                  } in  ds_sbQ7I sat_sbQ7R;
        } in  GHC.Base.>>= $dMonad_sbQ7H sat_sbQ7S sat_sbQ7V;

Control.Arrow.$fArrowKleisli3
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c d. Control.Arrow.Kleisli m b c -> (b, d) -> m (c, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,1*C1(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbQ7W ds_sbQ7X ds1_sbQ7Y]
        let {
          d1_sbQ7Z [Occ=OnceL] :: d_abN2u
          [LclId] =
              [ds1_sbQ7Y] \u []
                  case ds1_sbQ7Y of {
                    (,) _ [Occ=Dead] d2_sbQ82 [Occ=Once] -> d2_sbQ82;
                  }; } in
        let {
          sat_sbQ8a [Occ=Once] :: c_abN2t -> m_XbN42 (c_abN2t, d_abN2u)
          [LclId] =
              [$dMonad_sbQ7W d1_sbQ7Z] \r [c1_sbQ88]
                  let {
                    sat_sbQ89 [Occ=Once] :: (c_abN2t, d_abN2u)
                    [LclId] =
                        CCCS (,)! [c1_sbQ88 d1_sbQ7Z];
                  } in  GHC.Base.return $dMonad_sbQ7W sat_sbQ89; } in
        let {
          sat_sbQ87 [Occ=Once] :: m_XbN42 c_abN2t
          [LclId] =
              [ds_sbQ7X ds1_sbQ7Y] \u []
                  let {
                    sat_sbQ86 [Occ=Once] :: b_abN2s
                    [LclId] =
                        [ds1_sbQ7Y] \u []
                            case ds1_sbQ7Y of {
                              (,) b1_sbQ84 [Occ=Once] _ [Occ=Dead] -> b1_sbQ84;
                            };
                  } in  ds_sbQ7X sat_sbQ86;
        } in  GHC.Base.>>= $dMonad_sbQ7W sat_sbQ87 sat_sbQ8a;

Control.Arrow.$fArrowKleisli5
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c. (b -> c) -> b -> m c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbQ8b f_sbQ8c eta_sbQ8d]
        let {
          sat_sbQ8e [Occ=Once] :: c_abN27
          [LclId] =
              [f_sbQ8c eta_sbQ8d] \u [] f_sbQ8c eta_sbQ8d;
        } in  GHC.Base.return $dMonad_sbQ8b sat_sbQ8e;

Control.Arrow.$fArrowPlusKleisli1
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall b c.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m b c -> b -> m c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))),1*U(A,A,A,1*C1(C1(U)))><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbQ8f ds_sbQ8g ds1_sbQ8h x_sbQ8i]
        let {
          sat_sbQ8k [Occ=Once] :: m_abN1h c_abN1r
          [LclId] =
              [ds1_sbQ8h x_sbQ8i] \u [] ds1_sbQ8h x_sbQ8i; } in
        let {
          sat_sbQ8j [Occ=Once] :: m_abN1h c_abN1r
          [LclId] =
              [ds_sbQ8g x_sbQ8i] \u [] ds_sbQ8g x_sbQ8i;
        } in  GHC.Base.mplus $dMonadPlus_sbQ8f sat_sbQ8j sat_sbQ8k;

Control.Arrow.$fAlternativeArrowMonad_$capp
  :: forall b c. (b -> c, b) -> c
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),U)>,
 Unf=OtherCon []] =
    [] \r [ds_sbQ8l]
        case ds_sbQ8l of {
          (,) f_sbQ8n [Occ=Once!] x_sbQ8o [Occ=Once] -> f_sbQ8n x_sbQ8o;
        };

Control.Arrow.$fApplicativeArrowMonad5
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b. (a1 -> b) -> Control.Arrow.ArrowMonad a a1 -> a () b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQ8p eta_sbQ8q eta1_sbQ8r]
        let {
          sat_sbQ8t [Occ=Once] :: a_abMWW a1_abMX1 b_abMX2
          [LclId] =
              [$dArrow_sbQ8p eta_sbQ8q] \u []
                  Control.Arrow.arr $dArrow_sbQ8p eta_sbQ8q;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbQ8p of sat_sbQ8s {
            __DEFAULT -> Control.Category.. sat_sbQ8s sat_sbQ8t eta1_sbQ8r;
          };

Control.Arrow.$fFunctorArrowMonad1
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b. a1 -> Control.Arrow.ArrowMonad a b -> a () a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQ8u x_sbQ8v eta_sbQ8w]
        let {
          sat_sbQ8A [Occ=Once] :: a_XbMZs b_abMXn a1_abMXm
          [LclId] =
              [$dArrow_sbQ8u x_sbQ8v] \u []
                  let {
                    sat_sbQ8z [Occ=Once] :: b_abMXn -> a1_abMXm
                    [LclId] =
                        [x_sbQ8v] \r [ds_sbQ8y] x_sbQ8v;
                  } in  Control.Arrow.arr $dArrow_sbQ8u sat_sbQ8z;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbQ8u of sat_sbQ8x {
            __DEFAULT -> Control.Category.. sat_sbQ8x sat_sbQ8A eta_sbQ8w;
          };

Control.Arrow.$fFunctorArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     GHC.Base.Functor (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,A)>m] =
    [] \r [$dArrow_sbQ8B]
        let {
          sat_sbQ8D [Occ=Once]
            :: forall a b.
               a
               -> Control.Arrow.ArrowMonad a_XbMZA b
               -> Control.Arrow.ArrowMonad a_XbMZA a
          [LclId] =
              [$dArrow_sbQ8B] \r [eta_B2 eta_B1]
                  Control.Arrow.$fFunctorArrowMonad1
                      $dArrow_sbQ8B eta_B2 eta_B1; } in
        let {
          sat_sbQ8C [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Control.Arrow.ArrowMonad a_XbMZA a
               -> Control.Arrow.ArrowMonad a_XbMZA b
          [LclId] =
              [$dArrow_sbQ8B] \r [eta_B2 eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad5 $dArrow_sbQ8B eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sbQ8C sat_sbQ8D];

Control.Arrow.$fAlternativeArrowMonad2
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a (a1 -> b)
     -> Control.Arrow.ArrowMonad a a1 -> a () b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQ8E eta_sbQ8F eta1_sbQ8G]
        let {
          sat_sbQ8J [Occ=Once] :: a_abMVp () (a1_abMVM -> b_abMVN, a1_abMVM)
          [LclId] =
              [$dArrow_sbQ8E eta_sbQ8F eta1_sbQ8G] \u []
                  Control.Arrow.&&& $dArrow_sbQ8E eta_sbQ8F eta1_sbQ8G; } in
        let {
          sat_sbQ8I [Occ=Once]
            :: a_abMVp (a1_abMVM -> b_abMVN, a1_abMVM) b_abMVN
          [LclId] =
              [$dArrow_sbQ8E] \u []
                  Control.Arrow.arr
                      $dArrow_sbQ8E Control.Arrow.$fAlternativeArrowMonad_$capp;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbQ8E of sat_sbQ8H {
            __DEFAULT -> Control.Category.. sat_sbQ8H sat_sbQ8I sat_sbQ8J;
          };

Control.Arrow.$fApplicativeArrowMonad6
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1. a1 -> a () a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQ8K x_sbQ8L]
        let {
          sat_sbQ8N [Occ=Once] :: () -> a1_abMVy
          [LclId] =
              [x_sbQ8L] \r [ds_sbQ8M] x_sbQ8L;
        } in  Control.Arrow.arr $dArrow_sbQ8K sat_sbQ8N;

Control.Arrow.$fApplicativeArrowMonad4
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b c.
     (a1 -> b -> c)
     -> Control.Arrow.ArrowMonad a a1
     -> Control.Arrow.ArrowMonad a b
     -> a () c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQ8O f1_sbQ8P x_sbQ8Q]
        let {
          sat_sbQ8R [Occ=Once]
            :: Control.Arrow.ArrowMonad a_XbMYk (b_abMWs -> c_abMWt)
          [LclId] =
              [$dArrow_sbQ8O f1_sbQ8P x_sbQ8Q] \u []
                  Control.Arrow.$fApplicativeArrowMonad5
                      $dArrow_sbQ8O f1_sbQ8P x_sbQ8Q;
        } in 
          Control.Arrow.$fAlternativeArrowMonad2 $dArrow_sbQ8O sat_sbQ8R;

Control.Arrow.$fApplicativeArrowMonad3 :: forall b a. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbQ8S eta_sbQ8T] eta_sbQ8T;

Control.Arrow.$fApplicativeArrowMonad2
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a a1
     -> Control.Arrow.ArrowMonad a b -> a () b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQ8U a2_sbQ8V a3_sbQ8W]
        let {
          sat_sbQ8Z [Occ=Once]
            :: Control.Arrow.ArrowMonad a_XbMYj (b_abMWE -> b_abMWE)
          [LclId] =
              [$dArrow_sbQ8U a2_sbQ8V] \u []
                  let {
                    sat_sbQ8Y [Occ=Once] :: a_XbMYj a1_abMWD (b_abMWE -> b_abMWE)
                    [LclId] =
                        [$dArrow_sbQ8U] \u []
                            Control.Arrow.arr
                                $dArrow_sbQ8U Control.Arrow.$fApplicativeArrowMonad3;
                  } in 
                    case Control.Arrow.$p1Arrow $dArrow_sbQ8U of sat_sbQ8X {
                      __DEFAULT -> Control.Category.. sat_sbQ8X sat_sbQ8Y a2_sbQ8V;
                    };
        } in 
          Control.Arrow.$fAlternativeArrowMonad2
              $dArrow_sbQ8U sat_sbQ8Z a3_sbQ8W;

Control.Arrow.$fApplicativeArrowMonad1
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a a1
     -> Control.Arrow.ArrowMonad a b -> a () a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQ90 x_sbQ91]
        let {
          sat_sbQ94 [Occ=Once]
            :: Control.Arrow.ArrowMonad a_XbMYi (b_abMWO -> a1_abMWN)
          [LclId] =
              [$dArrow_sbQ90 x_sbQ91] \u []
                  let {
                    sat_sbQ93 [Occ=Once] :: a_XbMYi a1_abMWN (b_abMWO -> a1_abMWN)
                    [LclId] =
                        [$dArrow_sbQ90] \u []
                            Control.Arrow.arr $dArrow_sbQ90 GHC.Base.const;
                  } in 
                    case Control.Arrow.$p1Arrow $dArrow_sbQ90 of sat_sbQ92 {
                      __DEFAULT -> Control.Category.. sat_sbQ92 sat_sbQ93 x_sbQ91;
                    };
        } in 
          Control.Arrow.$fAlternativeArrowMonad2 $dArrow_sbQ90 sat_sbQ94;

Control.Arrow.$fApplicativeArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     GHC.Base.Applicative (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>m] =
    [] \r [$dArrow_sbQ95]
        let {
          sat_sbQ9b [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMYh a
               -> Control.Arrow.ArrowMonad a_XbMYh b
               -> Control.Arrow.ArrowMonad a_XbMYh a
          [LclId] =
              [$dArrow_sbQ95] \r [eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad1 $dArrow_sbQ95 eta_B1; } in
        let {
          sat_sbQ9a [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMYh a
               -> Control.Arrow.ArrowMonad a_XbMYh b
               -> Control.Arrow.ArrowMonad a_XbMYh b
          [LclId] =
              [$dArrow_sbQ95] \r [eta_B2 eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad2
                      $dArrow_sbQ95 eta_B2 eta_B1; } in
        let {
          sat_sbQ99 [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Control.Arrow.ArrowMonad a_XbMYh a
               -> Control.Arrow.ArrowMonad a_XbMYh b
               -> Control.Arrow.ArrowMonad a_XbMYh c
          [LclId] =
              [$dArrow_sbQ95] \r [eta_B2 eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad4
                      $dArrow_sbQ95 eta_B2 eta_B1; } in
        let {
          sat_sbQ98 [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMYh (a -> b)
               -> Control.Arrow.ArrowMonad a_XbMYh a
               -> Control.Arrow.ArrowMonad a_XbMYh b
          [LclId] =
              [$dArrow_sbQ95] \r [eta_B2 eta_B1]
                  Control.Arrow.$fAlternativeArrowMonad2
                      $dArrow_sbQ95 eta_B2 eta_B1; } in
        let {
          sat_sbQ97 [Occ=Once]
            :: forall a. a -> Control.Arrow.ArrowMonad a_XbMYh a
          [LclId] =
              [$dArrow_sbQ95] \r [eta_B1]
                  Control.Arrow.$fApplicativeArrowMonad6 $dArrow_sbQ95 eta_B1; } in
        let {
          sat_sbQ96 [Occ=Once]
            :: GHC.Base.Functor (Control.Arrow.ArrowMonad a_XbMYh)
          [LclId] =
              [$dArrow_sbQ95] \u []
                  Control.Arrow.$fFunctorArrowMonad $dArrow_sbQ95;
        } in 
          GHC.Base.C:Applicative [sat_sbQ96
                                  sat_sbQ97
                                  sat_sbQ98
                                  sat_sbQ99
                                  sat_sbQ9a
                                  sat_sbQ9b];

Control.Arrow.$fMonadArrowMonad_$c>>=
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a a1
     -> (a1 -> Control.Arrow.ArrowMonad a b)
     -> Control.Arrow.ArrowMonad a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(1*U(1*U(A,C(C1(U))),1*C1(U),A,A,A,A),1*U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbQ9c eta_sbQ9d eta1_sbQ9e]
        case
            Control.Arrow.$p1ArrowApply $dArrowApply_sbQ9c
        of
        $dArrow_sbQ9f [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              case
                  Control.Arrow.$p1Arrow $dArrow_sbQ9f
              of
              $dCategory_sbQ9g [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
              { __DEFAULT ->
                    let {
                      sat_sbQ9m [Occ=Once] :: a_abMU9 () (a_abMU9 () b_abMUj, ())
                      [LclId] =
                          [eta_sbQ9d eta1_sbQ9e $dArrow_sbQ9f $dCategory_sbQ9g] \u []
                              let {
                                sat_sbQ9l [Occ=Once] :: a_abMU9 a1_abMUi (a_abMU9 () b_abMUj, ())
                                [LclId] =
                                    [eta1_sbQ9e $dArrow_sbQ9f] \u []
                                        let {
                                          sat_sbQ9k [Occ=Once]
                                            :: a1_abMUi -> (a_abMU9 () b_abMUj, ())
                                          [LclId] =
                                              [eta1_sbQ9e] \r [x_sbQ9i]
                                                  let {
                                                    sat_sbQ9j [Occ=Once] :: a_abMU9 () b_abMUj
                                                    [LclId] =
                                                        [eta1_sbQ9e x_sbQ9i] \u []
                                                            eta1_sbQ9e x_sbQ9i;
                                                  } in  (,) [sat_sbQ9j GHC.Tuple.()];
                                        } in  Control.Arrow.arr $dArrow_sbQ9f sat_sbQ9k;
                              } in  Control.Category.. $dCategory_sbQ9g sat_sbQ9l eta_sbQ9d; } in
                    let {
                      sat_sbQ9h [Occ=Once] :: a_abMU9 (a_abMU9 () b_abMUj, ()) b_abMUj
                      [LclId] =
                          [$dArrowApply_sbQ9c] \u [] Control.Arrow.app $dArrowApply_sbQ9c;
                    } in  Control.Category.. $dCategory_sbQ9g sat_sbQ9h sat_sbQ9m;
              };
        };

Control.Arrow.$fMonadArrowMonad_$cp1Monad
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     GHC.Base.Applicative (Control.Arrow.ArrowMonad a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)>m,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbQ9n]
        let {
          sat_sbQ9o [Occ=Once, Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
            :: Control.Arrow.Arrow a_abMU9
          [LclId] =
              [$dArrowApply_sbQ9n] \u []
                  Control.Arrow.$p1ArrowApply $dArrowApply_sbQ9n;
        } in  Control.Arrow.$fApplicativeArrowMonad sat_sbQ9o;

Control.Arrow.$fMonadArrowMonad1
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     forall a1. a1 -> a () a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)L),1*U(1*U(A,1*C1(U),A,A,A,A),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbQ9p eta_sbQ9q]
        let {
          sat_sbQ9t [Occ=Once] :: () -> a1_abMVa
          [LclId] =
              [eta_sbQ9q] \r [ds_sbQ9s] eta_sbQ9q;
        } in 
          case Control.Arrow.$p1ArrowApply $dArrowApply_sbQ9p of sat_sbQ9r {
            __DEFAULT -> Control.Arrow.arr sat_sbQ9r sat_sbQ9t;
          };

Control.Arrow.$fMonadArrowMonad_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     forall a1 b.
     Control.Arrow.ArrowMonad a a1
     -> Control.Arrow.ArrowMonad a b -> Control.Arrow.ArrowMonad a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(U(U(A,C(C1(U))),C(U),A,A,A,A),U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbQ9u eta_sbQ9v eta1_sbQ9w]
        let {
          sat_sbQ9y [Occ=Once]
            :: a1_abMV0 -> Control.Arrow.ArrowMonad a_XbMXu b_abMV1
          [LclId] =
              [eta1_sbQ9w] \r [ds_sbQ9x] eta1_sbQ9w;
        } in 
          Control.Arrow.$fMonadArrowMonad_$c>>=
              $dArrowApply_sbQ9u eta_sbQ9v sat_sbQ9y;

lvl_rbNC6
  :: forall (a1 :: * -> * -> *) a2.
     [GHC.Types.Char] -> Control.Arrow.ArrowMonad a1 a2
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sbQ9z] GHC.Err.errorWithoutStackTrace eta_sbQ9z;

Control.Arrow.$fMonadArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowApply a =>
     GHC.Base.Monad (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),U)>m] =
    [] \r [$dArrowApply_sbQ9A]
        let {
          sat_sbQ9E [Occ=Once]
            :: forall a. a -> Control.Arrow.ArrowMonad a_XbMXv a
          [LclId] =
              [$dArrowApply_sbQ9A] \r [eta_B1]
                  Control.Arrow.$fMonadArrowMonad1 $dArrowApply_sbQ9A eta_B1; } in
        let {
          sat_sbQ9D [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMXv a
               -> Control.Arrow.ArrowMonad a_XbMXv b
               -> Control.Arrow.ArrowMonad a_XbMXv b
          [LclId] =
              [$dArrowApply_sbQ9A] \r [eta_B2 eta_B1]
                  Control.Arrow.$fMonadArrowMonad_$c>>
                      $dArrowApply_sbQ9A eta_B2 eta_B1; } in
        let {
          sat_sbQ9C [Occ=Once]
            :: forall a b.
               Control.Arrow.ArrowMonad a_XbMXv a
               -> (a -> Control.Arrow.ArrowMonad a_XbMXv b)
               -> Control.Arrow.ArrowMonad a_XbMXv b
          [LclId] =
              [$dArrowApply_sbQ9A] \r [eta_B2 eta_B1]
                  Control.Arrow.$fMonadArrowMonad_$c>>=
                      $dArrowApply_sbQ9A eta_B2 eta_B1; } in
        let {
          sat_sbQ9B [Occ=Once]
            :: GHC.Base.Applicative (Control.Arrow.ArrowMonad a_XbMXv)
          [LclId] =
              [$dArrowApply_sbQ9A] \u []
                  Control.Arrow.$fMonadArrowMonad_$cp1Monad $dArrowApply_sbQ9A;
        } in 
          GHC.Base.C:Monad [sat_sbQ9B
                            sat_sbQ9C
                            sat_sbQ9D
                            sat_sbQ9E
                            lvl_rbNC6];

Control.Arrow.$fAlternativeArrowMonad3
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     forall a1. a () a1
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LS)L),1*U(1*U(A,1*U),A)>,
 Unf=OtherCon []] =
    [] \r [$dArrowPlus_sbQ9F]
        case Control.Arrow.$p1ArrowPlus $dArrowPlus_sbQ9F of sat_sbQ9G {
          __DEFAULT -> Control.Arrow.zeroArrow sat_sbQ9G;
        };

Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     GHC.Base.Applicative (Control.Arrow.ArrowMonad a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A),A)>m,
 Unf=OtherCon []] =
    [] \r [$dArrowPlus_sbQ9H]
        let {
          sat_sbQ9J [Occ=Once, Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
            :: Control.Arrow.Arrow a_XbMWB
          [LclId] =
              [$dArrowPlus_sbQ9H] \u []
                  case Control.Arrow.$p1ArrowPlus $dArrowPlus_sbQ9H of sat_sbQ9I {
                    __DEFAULT -> Control.Arrow.$p1ArrowZero sat_sbQ9I;
                  };
        } in  Control.Arrow.$fApplicativeArrowMonad sat_sbQ9J;

Control.Arrow.$fAlternativeArrowMonad1 :: forall a. () -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sbQ9K] [] [];

Control.Arrow.$fAlternativeArrowMonad_$csome
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     forall a1.
     Control.Arrow.ArrowMonad a a1 -> Control.Arrow.ArrowMonad a [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LC(C(S)))LLLLL)L)L),U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A),C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowPlus_sbQ9L eta_sbQ9M]
        let {
          some_v_sbQ9N [Occ=LoopBreaker] :: a_XbMWE () [a1_abMTU]
          [LclId] =
              [$dArrowPlus_sbQ9L eta_sbQ9M some_v_sbQ9N] \u []
                  case
                      Control.Arrow.$p1ArrowPlus $dArrowPlus_sbQ9L
                  of
                  $dApplicative_sbQ9O [Dmd=<S(S(S(LC(C(S)))LLLLL)L),1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,1*C1(C1(U))),A)>]
                  { __DEFAULT ->
                        case
                            Control.Arrow.$p1ArrowZero $dApplicative_sbQ9O
                        of
                        $dApplicative1_sbQ9P [Dmd=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,1*C1(C1(U)))>]
                        { __DEFAULT ->
                              let {
                                sat_sbQ9X [Occ=Once]
                                  :: a_XbMWE () ([a1_abMTU] -> [a1_abMTU], [a1_abMTU])
                                [LclId] =
                                    [$dArrowPlus_sbQ9L
                                     eta_sbQ9M
                                     some_v_sbQ9N
                                     $dApplicative1_sbQ9P] \u []
                                        let {
                                          sat_sbQ9W [Occ=Once] :: a_XbMWE () [a1_abMTU]
                                          [LclId] =
                                              [$dArrowPlus_sbQ9L
                                               some_v_sbQ9N
                                               $dApplicative1_sbQ9P] \u []
                                                  let {
                                                    sat_sbQ9V [Occ=Once] :: a_XbMWE () [a1_abMTU]
                                                    [LclId] =
                                                        [$dApplicative1_sbQ9P] \u []
                                                            Control.Arrow.arr
                                                                $dApplicative1_sbQ9P
                                                                Control.Arrow.$fAlternativeArrowMonad1;
                                                  } in 
                                                    Control.Arrow.<+>
                                                        $dArrowPlus_sbQ9L
                                                        some_v_sbQ9N
                                                        sat_sbQ9V; } in
                                        let {
                                          sat_sbQ9U [Occ=Once]
                                            :: a_XbMWE () ([a1_abMTU] -> [a1_abMTU])
                                          [LclId] =
                                              [eta_sbQ9M $dApplicative1_sbQ9P] \u []
                                                  let {
                                                    sat_sbQ9T [Occ=Once]
                                                      :: a_XbMWE a1_abMTU ([a1_abMTU] -> [a1_abMTU])
                                                    [LclId] =
                                                        [$dApplicative1_sbQ9P] \u []
                                                            Control.Arrow.arr
                                                                $dApplicative1_sbQ9P GHC.Types.:;
                                                  } in 
                                                    case
                                                        Control.Arrow.$p1Arrow $dApplicative1_sbQ9P
                                                    of
                                                    sat_sbQ9S
                                                    { __DEFAULT ->
                                                          Control.Category..
                                                              sat_sbQ9S sat_sbQ9T eta_sbQ9M;
                                                    };
                                        } in 
                                          Control.Arrow.&&&
                                              $dApplicative1_sbQ9P sat_sbQ9U sat_sbQ9W; } in
                              let {
                                sat_sbQ9R [Occ=Once]
                                  :: a_XbMWE ([a1_abMTU] -> [a1_abMTU], [a1_abMTU]) [a1_abMTU]
                                [LclId] =
                                    [$dApplicative1_sbQ9P] \u []
                                        Control.Arrow.arr
                                            $dApplicative1_sbQ9P
                                            Control.Arrow.$fAlternativeArrowMonad_$capp;
                              } in 
                                case Control.Arrow.$p1Arrow $dApplicative1_sbQ9P of sat_sbQ9Q {
                                  __DEFAULT -> Control.Category.. sat_sbQ9Q sat_sbQ9R sat_sbQ9X;
                                };
                        };
                  };
        } in  some_v_sbQ9N;

Control.Arrow.$fAlternativeArrowMonad_$cmany
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     forall a1.
     Control.Arrow.ArrowMonad a a1 -> Control.Arrow.ArrowMonad a [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A),C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowPlus_sbQ9Y eta_sbQ9Z]
        let {
          many_v_sbQa0 [Occ=LoopBreaker] :: a_XbMWD () [a1_abMU2]
          [LclId] =
              [$dArrowPlus_sbQ9Y eta_sbQ9Z many_v_sbQa0] \u []
                  let {
                    $dApplicative_sbQa1 [Occ=OnceL,
                                         Dmd=<L,1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)>]
                      :: Control.Arrow.ArrowZero a_XbMWD
                    [LclId] =
                        [$dArrowPlus_sbQ9Y] \s []
                            Control.Arrow.$p1ArrowPlus $dArrowPlus_sbQ9Y; } in
                  let {
                    $dApplicative1_sbQa2 [Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
                      :: Control.Arrow.Arrow a_XbMWD
                    [LclId] =
                        [$dApplicative_sbQa1] \u []
                            Control.Arrow.$p1ArrowZero $dApplicative_sbQa1; } in
                  let {
                    sat_sbQa7 [Occ=Once] :: a_XbMWD () [a1_abMU2]
                    [LclId] =
                        [$dApplicative1_sbQa2] \u []
                            Control.Arrow.arr
                                $dApplicative1_sbQa2 Control.Arrow.$fAlternativeArrowMonad1; } in
                  let {
                    sat_sbQa6 [Occ=Once] :: a_XbMWD () [a1_abMU2]
                    [LclId] =
                        [eta_sbQ9Z many_v_sbQa0 $dApplicative1_sbQa2] \u []
                            let {
                              sat_sbQa5 [Occ=Once]
                                :: Control.Arrow.ArrowMonad a_XbMWD ([a1_abMU2] -> [a1_abMU2])
                              [LclId] =
                                  [eta_sbQ9Z $dApplicative1_sbQa2] \u []
                                      let {
                                        sat_sbQa4 [Occ=Once]
                                          :: a_XbMWD a1_abMU2 ([a1_abMU2] -> [a1_abMU2])
                                        [LclId] =
                                            [$dApplicative1_sbQa2] \u []
                                                Control.Arrow.arr $dApplicative1_sbQa2 GHC.Types.:;
                                      } in 
                                        case
                                            Control.Arrow.$p1Arrow $dApplicative1_sbQa2
                                        of
                                        sat_sbQa3
                                        { __DEFAULT ->
                                              Control.Category.. sat_sbQa3 sat_sbQa4 eta_sbQ9Z;
                                        };
                            } in 
                              Control.Arrow.$fAlternativeArrowMonad2
                                  $dApplicative1_sbQa2 sat_sbQa5 many_v_sbQa0;
                  } in  Control.Arrow.<+> $dArrowPlus_sbQ9Y sat_sbQa6 sat_sbQa7;
        } in  many_v_sbQa0;

Control.Arrow.$fAlternativeArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowPlus a =>
     GHC.Base.Alternative (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),1*U),C(C1(U)))>m] =
    [] \r [$dArrowPlus_sbQa8]
        let {
          sat_sbQaf [Occ=Once]
            :: forall a.
               Control.Arrow.ArrowMonad a_XbMWC a
               -> Control.Arrow.ArrowMonad a_XbMWC [a]
          [LclId] =
              [$dArrowPlus_sbQa8] \r [eta_B1]
                  Control.Arrow.$fAlternativeArrowMonad_$cmany
                      $dArrowPlus_sbQa8 eta_B1; } in
        let {
          sat_sbQae [Occ=Once]
            :: forall a.
               Control.Arrow.ArrowMonad a_XbMWC a
               -> Control.Arrow.ArrowMonad a_XbMWC [a]
          [LclId] =
              [$dArrowPlus_sbQa8] \r [eta_B1]
                  Control.Arrow.$fAlternativeArrowMonad_$csome
                      $dArrowPlus_sbQa8 eta_B1; } in
        let {
          sat_sbQad [Occ=Once]
            :: forall a.
               Control.Arrow.ArrowMonad a_XbMWC a
               -> Control.Arrow.ArrowMonad a_XbMWC a
               -> Control.Arrow.ArrowMonad a_XbMWC a
          [LclId] =
              [$dArrowPlus_sbQa8] \r [ds_sbQab ds1_sbQac]
                  Control.Arrow.<+> $dArrowPlus_sbQa8 ds_sbQab ds1_sbQac; } in
        let {
          sat_sbQaa [Occ=Once]
            :: forall a. Control.Arrow.ArrowMonad a_XbMWC a
          [LclId] =
              [$dArrowPlus_sbQa8] \u []
                  Control.Arrow.$fAlternativeArrowMonad3 $dArrowPlus_sbQa8; } in
        let {
          sat_sbQa9 [Occ=Once]
            :: GHC.Base.Applicative (Control.Arrow.ArrowMonad a_XbMWC)
          [LclId] =
              [$dArrowPlus_sbQa8] \u []
                  Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative
                      $dArrowPlus_sbQa8;
        } in 
          GHC.Base.C:Alternative [sat_sbQa9
                                  sat_sbQaa
                                  sat_sbQad
                                  sat_sbQae
                                  sat_sbQaf];

Control.Arrow.$fMonadPlusArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     (Control.Arrow.ArrowApply a, Control.Arrow.ArrowPlus a) =>
     GHC.Base.MonadPlus (Control.Arrow.ArrowMonad a)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),U)><L,U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),U),C(C1(U)))>m] =
    [] \r [$dArrowApply_sbQag $dArrowPlus_sbQah]
        let {
          sat_sbQan [Occ=Once]
            :: forall a.
               Control.Arrow.ArrowMonad a_abMSU a
               -> Control.Arrow.ArrowMonad a_abMSU a
               -> Control.Arrow.ArrowMonad a_abMSU a
          [LclId] =
              [$dArrowPlus_sbQah] \r [ds_sbQal ds1_sbQam]
                  Control.Arrow.<+> $dArrowPlus_sbQah ds_sbQal ds1_sbQam; } in
        let {
          sat_sbQak [Occ=Once]
            :: forall a. Control.Arrow.ArrowMonad a_abMSU a
          [LclId] =
              [$dArrowPlus_sbQah] \u []
                  Control.Arrow.$fAlternativeArrowMonad3 $dArrowPlus_sbQah; } in
        let {
          sat_sbQaj [Occ=Once]
            :: GHC.Base.Monad (Control.Arrow.ArrowMonad a_abMSU)
          [LclId] =
              [$dArrowApply_sbQag] \u []
                  Control.Arrow.$fMonadArrowMonad $dArrowApply_sbQag; } in
        let {
          sat_sbQai [Occ=Once]
            :: GHC.Base.Alternative (Control.Arrow.ArrowMonad a_abMSU)
          [LclId] =
              [$dArrowPlus_sbQah] \u []
                  Control.Arrow.$fAlternativeArrowMonad $dArrowPlus_sbQah;
        } in 
          GHC.Base.C:MonadPlus [sat_sbQai sat_sbQaj sat_sbQak sat_sbQan];

Control.Arrow.$fArrowLoop(->)_$cloop
  :: forall b d c. ((b, d) -> (c, d)) -> b -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U(U,U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sbQao b1_sbQap]
        let {
          ds_sbQaq [Occ=LoopBreaker] :: (c_abMSD, d_abMSC)
          [LclId] =
              [f_sbQao b1_sbQap ds_sbQaq] \u []
                  let {
                    sat_sbQau [Occ=OnceL] :: d_abMSC
                    [LclId] =
                        [ds_sbQaq] \u []
                            case ds_sbQaq of {
                              (,) _ [Occ=Dead] d1_sbQat [Occ=Once] -> d1_sbQat;
                            }; } in
                  let {
                    sat_sbQav [Occ=Once] :: (b_abMSB, d_abMSC)
                    [LclId] =
                        CCCS (,)! [b1_sbQap sat_sbQau];
                  } in  f_sbQao sat_sbQav;
        } in 
          case ds_sbQaq of {
            (,) c1_sbQax [Occ=Once] _ [Occ=Dead] -> c1_sbQax;
          };

Control.Arrow.$fArrowLoopKleisli1
  :: forall (m :: * -> *).
     Control.Monad.Fix.MonadFix m =>
     forall b d c. Control.Arrow.Kleisli m (b, d) (c, d) -> b -> m c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S))LLL)L),U(1*U(A,1*C1(C1(U)),A,C(U),A),1*C1(U))><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadFix_sbQaz eta_sbQaA eta1_sbQaB]
        case
            Control.Monad.Fix.$p1MonadFix $dMonadFix_sbQaz
        of
        $dMonad_sbQaC [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
        { __DEFAULT ->
              let {
                sat_sbQaN [Occ=Once] :: (c_abMRB, d_abMRA) -> m_abMRq c_abMRB
                [LclId] =
                    [$dMonad_sbQaC] \r [x1_sbQaI]
                        let {
                          sat_sbQaM [Occ=Once] :: c_abMRB
                          [LclId] =
                              [x1_sbQaI] \u []
                                  case x1_sbQaI of {
                                    (,) x_sbQaK [Occ=Once] _ [Occ=Dead] -> x_sbQaK;
                                  };
                        } in  GHC.Base.return $dMonad_sbQaC sat_sbQaM; } in
              let {
                sat_sbQaH [Occ=Once] :: m_abMRq (c_abMRB, d_abMRA)
                [LclId] =
                    [$dMonadFix_sbQaz eta_sbQaA eta1_sbQaB] \u []
                        let {
                          sat_sbQaG [Occ=Once]
                            :: (c_abMRB, d_abMRA) -> m_abMRq (c_abMRB, d_abMRA)
                          [LclId] =
                              [eta_sbQaA eta1_sbQaB] \r [y_sbQaD]
                                  let {
                                    sat_sbQaE [Occ=Once] :: d_abMRA
                                    [LclId] =
                                        [y_sbQaD] \u [] Data.Tuple.snd y_sbQaD; } in
                                  let {
                                    sat_sbQaF [Occ=Once] :: (b_abMRz, d_abMRA)
                                    [LclId] =
                                        CCCS (,)! [eta1_sbQaB sat_sbQaE];
                                  } in  eta_sbQaA sat_sbQaF;
                        } in  Control.Monad.Fix.mfix $dMonadFix_sbQaz sat_sbQaG;
              } in  GHC.Base.>>= $dMonad_sbQaC sat_sbQaH sat_sbQaN;
        };

lvl1_rbNC7 :: forall d. Data.Either.Either d d -> d
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbQaO]
        case ds_sbQaO of {
          Data.Either.Left x_sbQaQ [Occ=Once] -> x_sbQaQ;
          Data.Either.Right y_sbQaR [Occ=Once] -> y_sbQaR;
        };

Control.Arrow.$dm|||
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b d c. a b d -> a c d -> a (Data.Either.Either b c) d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)LLLL),U(1*U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A),A,A,1*C1(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowChoice_sbQaS eta_sbQaT eta1_sbQaU]
        case
            Control.Arrow.$p1ArrowChoice $dArrowChoice_sbQaS
        of
        $dArrow_sbQaV [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sbQaY [Occ=Once]
                  :: a_abMu0 (Data.Either.Either b_abMQL c_abMQN) (Data.Either.Either
                                                                     d_abMQM d_abMQM)
                [LclId] =
                    [$dArrowChoice_sbQaS eta_sbQaT eta1_sbQaU] \u []
                        Control.Arrow.+++ $dArrowChoice_sbQaS eta_sbQaT eta1_sbQaU; } in
              let {
                sat_sbQaX [Occ=Once]
                  :: a_abMu0 (Data.Either.Either d_abMQM d_abMQM) d_abMQM
                [LclId] =
                    [$dArrow_sbQaV] \u [] Control.Arrow.arr $dArrow_sbQaV lvl1_rbNC7;
              } in 
                case Control.Arrow.$p1Arrow $dArrow_sbQaV of sat_sbQaW {
                  __DEFAULT -> Control.Category.. sat_sbQaW sat_sbQaX sat_sbQaY;
                };
        };

mirror_rbNC8
  :: forall x y. Data.Either.Either x y -> Data.Either.Either y x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbQaZ]
        case ds_sbQaZ of {
          Data.Either.Left x1_sbQb1 [Occ=Once] ->
              Data.Either.Right [x1_sbQb1];
          Data.Either.Right y1_sbQb2 [Occ=Once] ->
              Data.Either.Left [y1_sbQb2];
        };

Control.Arrow.$dm+++
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c b' c'.
     a b c
     -> a b' c' -> a (Data.Either.Either b b') (Data.Either.Either c c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)LLLL),U(1*U(1*U(A,C(C1(U))),C(U),A,A,A,A),C(U),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowChoice_sbQb3 eta_sbQb4 eta1_sbQb5]
        case
            Control.Arrow.$p1ArrowChoice $dArrowChoice_sbQb3
        of
        $dArrow_sbQb6 [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),C(U),A,A,A,A)>]
        { __DEFAULT ->
              case
                  Control.Arrow.$p1Arrow $dArrow_sbQb6
              of
              $dCategory_sbQb7 [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
              { __DEFAULT ->
                    let {
                      sat_sbQbd [Occ=Once]
                        :: a_abMu0 (Data.Either.Either
                                      b_abMPE b'_abMPG) (Data.Either.Either c'_abMPH c_abMPF)
                      [LclId] =
                          [$dArrowChoice_sbQb3
                           eta_sbQb4
                           eta1_sbQb5
                           $dArrow_sbQb6
                           $dCategory_sbQb7] \u []
                              let {
                                sat_sbQbc [Occ=Once]
                                  :: a_abMu0 (Data.Either.Either
                                                b_abMPE b'_abMPG) (Data.Either.Either
                                                                     b'_abMPG c_abMPF)
                                [LclId] =
                                    [$dArrowChoice_sbQb3
                                     eta_sbQb4
                                     $dArrow_sbQb6
                                     $dCategory_sbQb7] \u []
                                        let {
                                          sat_sbQbb [Occ=Once]
                                            :: a_abMu0 (Data.Either.Either
                                                          b_abMPE b'_abMPG) (Data.Either.Either
                                                                               c_abMPF b'_abMPG)
                                          [LclId] =
                                              [$dArrowChoice_sbQb3 eta_sbQb4] \u []
                                                  Control.Arrow.left
                                                      $dArrowChoice_sbQb3 eta_sbQb4; } in
                                        let {
                                          sat_sbQba [Occ=Once]
                                            :: a_abMu0 (Data.Either.Either
                                                          c_abMPF b'_abMPG) (Data.Either.Either
                                                                               b'_abMPG c_abMPF)
                                          [LclId] =
                                              [$dArrow_sbQb6] \u []
                                                  Control.Arrow.arr $dArrow_sbQb6 mirror_rbNC8;
                                        } in 
                                          Control.Category..
                                              $dCategory_sbQb7 sat_sbQba sat_sbQbb; } in
                              let {
                                sat_sbQb9 [Occ=Once]
                                  :: a_abMu0 (Data.Either.Either
                                                b'_abMPG c_abMPF) (Data.Either.Either
                                                                     c'_abMPH c_abMPF)
                                [LclId] =
                                    [$dArrowChoice_sbQb3 eta1_sbQb5] \u []
                                        Control.Arrow.left $dArrowChoice_sbQb3 eta1_sbQb5;
                              } in  Control.Category.. $dCategory_sbQb7 sat_sbQb9 sat_sbQbc; } in
                    let {
                      sat_sbQb8 [Occ=Once]
                        :: a_abMu0 (Data.Either.Either
                                      c'_abMPH c_abMPF) (Data.Either.Either c_abMPF c'_abMPH)
                      [LclId] =
                          [$dArrow_sbQb6] \u [] Control.Arrow.arr $dArrow_sbQb6 mirror_rbNC8;
                    } in  Control.Category.. $dCategory_sbQb7 sat_sbQb8 sat_sbQbd;
              };
        };

Control.Arrow.$dmright
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c d.
     a b c -> a (Data.Either.Either d b) (Data.Either.Either d c)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),U(1*U(1*U(1*U,A),A,A,A,A,A),A,A,1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dArrowChoice_sbQbe]
        let {
          sat_sbQbh [Occ=Once] :: a_abMu0 d_abMPp d_abMPp
          [LclId] =
              [$dArrowChoice_sbQbe] \u []
                  case
                      Control.Arrow.$p1ArrowChoice $dArrowChoice_sbQbe
                  of
                  sat_sbQbf
                  { __DEFAULT ->
                        case Control.Arrow.$p1Arrow sat_sbQbf of sat_sbQbg {
                          __DEFAULT -> Control.Category.id sat_sbQbg;
                        };
                  };
        } in  Control.Arrow.+++ $dArrowChoice_sbQbe sat_sbQbh;

Control.Arrow.$dmleft
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowChoice a =>
     forall b c d.
     a b c -> a (Data.Either.Either b d) (Data.Either.Either c d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))L),U(1*U(1*U(1*U,A),A,A,A,A,A),A,A,1*C1(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowChoice_sbQbi eta_sbQbj]
        let {
          sat_sbQbm [Occ=Once] :: a_abMu0 d_abMP8 d_abMP8
          [LclId] =
              [$dArrowChoice_sbQbi] \u []
                  case
                      Control.Arrow.$p1ArrowChoice $dArrowChoice_sbQbi
                  of
                  sat_sbQbk
                  { __DEFAULT ->
                        case Control.Arrow.$p1Arrow sat_sbQbk of sat_sbQbl {
                          __DEFAULT -> Control.Category.id sat_sbQbl;
                        };
                  };
        } in  Control.Arrow.+++ $dArrowChoice_sbQbi eta_sbQbj sat_sbQbm;

lvl2_rbNC9 :: forall b. b -> (b, b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [b1_sbQbn] (,) [b1_sbQbn b1_sbQbn];

Control.Arrow.$dm&&&
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c c'. a b c -> a b c' -> a b (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,1*C1(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQbo eta_sbQbp eta1_sbQbq]
        let {
          sat_sbQbt [Occ=Once] :: a_abMuz b_abMOE (b_abMOE, b_abMOE)
          [LclId] =
              [$dArrow_sbQbo] \u []
                  Control.Arrow.arr $dArrow_sbQbo lvl2_rbNC9; } in
        let {
          sat_sbQbs [Occ=Once]
            :: a_abMuz (b_abMOE, b_abMOE) (c_abMOF, c'_abMOG)
          [LclId] =
              [$dArrow_sbQbo eta_sbQbp eta1_sbQbq] \u []
                  Control.Arrow.*** $dArrow_sbQbo eta_sbQbp eta1_sbQbq;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbQbo of sat_sbQbr {
            __DEFAULT -> Control.Category.. sat_sbQbr sat_sbQbs sat_sbQbt;
          };

swap_rbNCa :: forall b a. (b, a) -> (a, b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sbQbu]
        let {
          sat_sbQbC [Occ=Once] :: b_abMNN
          [LclId] =
              [ds_sbQbu] \u []
                  case ds_sbQbu of {
                    (,) x_sbQbA [Occ=Once] _ [Occ=Dead] -> x_sbQbA;
                  }; } in
        let {
          sat_sbQby [Occ=Once] :: a_abMNM
          [LclId] =
              [ds_sbQbu] \u []
                  case ds_sbQbu of {
                    (,) _ [Occ=Dead] y_sbQbx [Occ=Once] -> y_sbQbx;
                  };
        } in  (,) [sat_sbQby sat_sbQbC];

Control.Arrow.$dm***
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c b' c'. a b c -> a b' c' -> a (b, b') (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),C(U),C(U),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQbD eta_sbQbE eta1_sbQbF]
        case
            Control.Arrow.$p1Arrow $dArrow_sbQbD
        of
        $dCategory_sbQbG [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
        { __DEFAULT ->
              let {
                sat_sbQbM [Occ=Once]
                  :: a_abMuz (b_abMNy, b'_abMNA) (c'_abMNB, c_abMNz)
                [LclId] =
                    [$dArrow_sbQbD eta_sbQbE eta1_sbQbF $dCategory_sbQbG] \u []
                        let {
                          sat_sbQbL [Occ=Once]
                            :: a_abMuz (b_abMNy, b'_abMNA) (b'_abMNA, c_abMNz)
                          [LclId] =
                              [$dArrow_sbQbD eta_sbQbE $dCategory_sbQbG] \u []
                                  let {
                                    sat_sbQbK [Occ=Once]
                                      :: a_abMuz (b_abMNy, b'_abMNA) (c_abMNz, b'_abMNA)
                                    [LclId] =
                                        [$dArrow_sbQbD eta_sbQbE] \u []
                                            Control.Arrow.first $dArrow_sbQbD eta_sbQbE; } in
                                  let {
                                    sat_sbQbJ [Occ=Once]
                                      :: a_abMuz (c_abMNz, b'_abMNA) (b'_abMNA, c_abMNz)
                                    [LclId] =
                                        [$dArrow_sbQbD] \u []
                                            Control.Arrow.arr $dArrow_sbQbD swap_rbNCa;
                                  } in 
                                    Control.Category.. $dCategory_sbQbG sat_sbQbJ sat_sbQbK; } in
                        let {
                          sat_sbQbI [Occ=Once]
                            :: a_abMuz (b'_abMNA, c_abMNz) (c'_abMNB, c_abMNz)
                          [LclId] =
                              [$dArrow_sbQbD eta1_sbQbF] \u []
                                  Control.Arrow.first $dArrow_sbQbD eta1_sbQbF;
                        } in  Control.Category.. $dCategory_sbQbG sat_sbQbI sat_sbQbL; } in
              let {
                sat_sbQbH [Occ=Once]
                  :: a_abMuz (c'_abMNB, c_abMNz) (c_abMNz, c'_abMNB)
                [LclId] =
                    [$dArrow_sbQbD] \u [] Control.Arrow.arr $dArrow_sbQbD swap_rbNCa;
              } in  Control.Category.. $dCategory_sbQbG sat_sbQbH sat_sbQbM;
        };

Control.Arrow.$fArrowKleisli2
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c b' c'.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m b' c' -> (b, b') -> m (c, c')
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(U)><L,C(U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbQbN f_sbQbO g_sbQbP eta_sbQbQ]
        let {
          sat_sbQcg [Occ=Once]
            :: (c'_abN3d, c_abN3b) -> m_XbN5E (c_abN3b, c'_abN3d)
          [LclId] =
              [$dMonad_sbQbN] \r [eta1_sbQc6]
                  let {
                    sat_sbQce [Occ=Once] :: c'_abN3d
                    [LclId] =
                        [eta1_sbQc6] \u []
                            case eta1_sbQc6 of {
                              (,) x_sbQcc [Occ=Once] _ [Occ=Dead] -> x_sbQcc;
                            }; } in
                  let {
                    sat_sbQca [Occ=Once] :: c_abN3b
                    [LclId] =
                        [eta1_sbQc6] \u []
                            case eta1_sbQc6 of {
                              (,) _ [Occ=Dead] y_sbQc9 [Occ=Once] -> y_sbQc9;
                            }; } in
                  let {
                    sat_sbQcf [Occ=Once] :: (c_abN3b, c'_abN3d)
                    [LclId] =
                        CCCS (,)! [sat_sbQca sat_sbQce];
                  } in  GHC.Base.return $dMonad_sbQbN sat_sbQcf; } in
        let {
          sat_sbQc5 [Occ=Once] :: m_XbN5E (c'_abN3d, c_abN3b)
          [LclId] =
              [$dMonad_sbQbN f_sbQbO g_sbQbP eta_sbQbQ] \u []
                  let {
                    sat_sbQc4 [Occ=Once]
                      :: (b'_abN3c, c_abN3b) -> m_XbN5E (c'_abN3d, c_abN3b)
                    [LclId] =
                        [$dMonad_sbQbN g_sbQbP] \r [eta_B1]
                            Control.Arrow.$fArrowKleisli3 $dMonad_sbQbN g_sbQbP eta_B1; } in
                  let {
                    sat_sbQc3 [Occ=Once] :: m_XbN5E (b'_abN3c, c_abN3b)
                    [LclId] =
                        [$dMonad_sbQbN f_sbQbO eta_sbQbQ] \u []
                            let {
                              sat_sbQc2 [Occ=Once]
                                :: (c_abN3b, b'_abN3c) -> m_XbN5E (b'_abN3c, c_abN3b)
                              [LclId] =
                                  [$dMonad_sbQbN] \r [eta1_sbQbS]
                                      let {
                                        sat_sbQc0 [Occ=Once] :: c_abN3b
                                        [LclId] =
                                            [eta1_sbQbS] \u []
                                                case eta1_sbQbS of {
                                                  (,) x_sbQbY [Occ=Once] _ [Occ=Dead] -> x_sbQbY;
                                                }; } in
                                      let {
                                        sat_sbQbW [Occ=Once] :: b'_abN3c
                                        [LclId] =
                                            [eta1_sbQbS] \u []
                                                case eta1_sbQbS of {
                                                  (,) _ [Occ=Dead] y_sbQbV [Occ=Once] -> y_sbQbV;
                                                }; } in
                                      let {
                                        sat_sbQc1 [Occ=Once] :: (b'_abN3c, c_abN3b)
                                        [LclId] =
                                            CCCS (,)! [sat_sbQbW sat_sbQc0];
                                      } in  GHC.Base.return $dMonad_sbQbN sat_sbQc1; } in
                            let {
                              sat_sbQbR [Occ=Once] :: m_XbN5E (c_abN3b, b'_abN3c)
                              [LclId] =
                                  [$dMonad_sbQbN f_sbQbO eta_sbQbQ] \u []
                                      Control.Arrow.$fArrowKleisli3 $dMonad_sbQbN f_sbQbO eta_sbQbQ;
                            } in  GHC.Base.>>= $dMonad_sbQbN sat_sbQbR sat_sbQc2;
                  } in  GHC.Base.>>= $dMonad_sbQbN sat_sbQc3 sat_sbQc4;
        } in  GHC.Base.>>= $dMonad_sbQbN sat_sbQc5 sat_sbQcg;

Control.Arrow.$fArrowKleisli1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c c'.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m b c' -> b -> m (c, c')
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(U)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbQch f_sbQci g_sbQcj eta_sbQck]
        let {
          sat_sbQcn [Occ=Once]
            :: (b_abN3o, b_abN3o) -> m_XbN5D (c_abN3p, c'_abN3q)
          [LclId] =
              [$dMonad_sbQch f_sbQci g_sbQcj] \r [eta_B1]
                  Control.Arrow.$fArrowKleisli2
                      $dMonad_sbQch f_sbQci g_sbQcj eta_B1; } in
        let {
          sat_sbQcm [Occ=Once] :: m_XbN5D (b_abN3o, b_abN3o)
          [LclId] =
              [$dMonad_sbQch eta_sbQck] \u []
                  let {
                    sat_sbQcl [Occ=Once] :: (b_abN3o, b_abN3o)
                    [LclId] =
                        CCCS (,)! [eta_sbQck eta_sbQck];
                  } in  GHC.Base.return $dMonad_sbQch sat_sbQcl;
        } in  GHC.Base.>>= $dMonad_sbQch sat_sbQcm sat_sbQcn;

Control.Arrow.$fArrowKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     Control.Arrow.Arrow (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,U,A)>m] =
    [] \r [$dMonad_sbQco]
        let {
          sat_sbQcu [Occ=Once]
            :: forall b c c'.
               Control.Arrow.Kleisli m_XbN5C b c
               -> Control.Arrow.Kleisli m_XbN5C b c'
               -> Control.Arrow.Kleisli m_XbN5C b (c, c')
          [LclId] =
              [$dMonad_sbQco] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli1
                      $dMonad_sbQco eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbQct [Occ=Once]
            :: forall b c b' c'.
               Control.Arrow.Kleisli m_XbN5C b c
               -> Control.Arrow.Kleisli m_XbN5C b' c'
               -> Control.Arrow.Kleisli m_XbN5C (b, b') (c, c')
          [LclId] =
              [$dMonad_sbQco] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli2
                      $dMonad_sbQco eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbQcs [Occ=Once]
            :: forall b c d.
               Control.Arrow.Kleisli m_XbN5C b c
               -> Control.Arrow.Kleisli m_XbN5C (d, b) (d, c)
          [LclId] =
              [$dMonad_sbQco] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli4 $dMonad_sbQco eta_B2 eta_B1; } in
        let {
          sat_sbQcr [Occ=Once]
            :: forall b c d.
               Control.Arrow.Kleisli m_XbN5C b c
               -> Control.Arrow.Kleisli m_XbN5C (b, d) (c, d)
          [LclId] =
              [$dMonad_sbQco] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli3 $dMonad_sbQco eta_B2 eta_B1; } in
        let {
          sat_sbQcq [Occ=Once]
            :: forall b c. (b -> c) -> Control.Arrow.Kleisli m_XbN5C b c
          [LclId] =
              [$dMonad_sbQco] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowKleisli5 $dMonad_sbQco eta_B2 eta_B1; } in
        let {
          sat_sbQcp [Occ=Once]
            :: Control.Category.Category (Control.Arrow.Kleisli m_XbN5C)
          [LclId] =
              [$dMonad_sbQco] \u []
                  Control.Arrow.$fCategoryTYPEKleisli $dMonad_sbQco;
        } in 
          Control.Arrow.C:Arrow [sat_sbQcp
                                 sat_sbQcq
                                 sat_sbQcr
                                 sat_sbQcs
                                 sat_sbQct
                                 sat_sbQcu];

Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop
  :: forall (m :: * -> *).
     Control.Monad.Fix.MonadFix m =>
     Control.Arrow.Arrow (Control.Arrow.Kleisli m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,U,A),A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadFix_sbQcv]
        let {
          sat_sbQcw [Occ=Once, Dmd=<L,U(A,C(C1(U)),A,U,A)>]
            :: GHC.Base.Monad m_XbMVo
          [LclId] =
              [$dMonadFix_sbQcv] \u []
                  Control.Monad.Fix.$p1MonadFix $dMonadFix_sbQcv;
        } in  Control.Arrow.$fArrowKleisli sat_sbQcw;

Control.Arrow.$fArrowLoopKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     Control.Monad.Fix.MonadFix m =>
     Control.Arrow.ArrowLoop (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U)),A,U,A),C(U))>m] =
    [] \r [$dMonadFix_sbQcx]
        let {
          sat_sbQcz [Occ=Once]
            :: forall b d c.
               Control.Arrow.Kleisli m_XbMVp (b, d) (c, d)
               -> Control.Arrow.Kleisli m_XbMVp b c
          [LclId] =
              [$dMonadFix_sbQcx] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowLoopKleisli1
                      $dMonadFix_sbQcx eta_B2 eta_B1; } in
        let {
          sat_sbQcy [Occ=Once]
            :: Control.Arrow.Arrow (Control.Arrow.Kleisli m_XbMVp)
          [LclId] =
              [$dMonadFix_sbQcx] \u []
                  Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop $dMonadFix_sbQcx;
        } in  Control.Arrow.C:ArrowLoop [sat_sbQcy sat_sbQcz];

lvl3_rbNCb
  :: forall (m :: * -> *) b c.
     (Control.Arrow.Kleisli m b c, b) -> m c
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),U)>,
 Unf=OtherCon []] =
    [] \r [ds_sbQcA]
        case ds_sbQcA of {
          (,) ds1_sbQcC [Occ=Once] x_sbQcD [Occ=Once] -> ds1_sbQcC x_sbQcD;
        };

Control.Arrow.$fArrowApplyKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     Control.Arrow.ArrowApply (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,U,A)>m] =
    [] \r [$dMonad_sbQcE]
        let {
          sat_sbQcF [Occ=Once]
            :: Control.Arrow.Arrow (Control.Arrow.Kleisli m_XbN1f)
          [LclId] =
              [$dMonad_sbQcE] \u [] Control.Arrow.$fArrowKleisli $dMonad_sbQcE;
        } in  Control.Arrow.C:ArrowApply [sat_sbQcF lvl3_rbNCb];

Control.Arrow.$fArrowChoiceKleisli1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c b' c'.
     Control.Arrow.Kleisli m b c
     -> Control.Arrow.Kleisli m b' c'
     -> Data.Either.Either b b'
     -> m (Data.Either.Either c c')
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbQcG f_sbQcH g_sbQcI eta_sbQcJ]
        case eta_sbQcJ of {
          Data.Either.Left x_sbQcL [Occ=Once] ->
              let {
                sat_sbQcP [Occ=Once]
                  :: c_abMYX -> m_XbN1R (Data.Either.Either c_abMYX c'_abMYZ)
                [LclId] =
                    [$dMonad_sbQcG] \r [eta1_sbQcN]
                        let {
                          sat_sbQcO [Occ=Once] :: Data.Either.Either c_abMYX c'_abMYZ
                          [LclId] =
                              CCCS Data.Either.Left! [eta1_sbQcN];
                        } in  GHC.Base.return $dMonad_sbQcG sat_sbQcO; } in
              let {
                sat_sbQcM [Occ=Once] :: m_XbN1R c_abMYX
                [LclId] =
                    [f_sbQcH x_sbQcL] \u [] f_sbQcH x_sbQcL;
              } in  GHC.Base.>>= $dMonad_sbQcG sat_sbQcM sat_sbQcP;
          Data.Either.Right y_sbQcQ [Occ=Once] ->
              let {
                sat_sbQcU [Occ=Once]
                  :: c'_abMYZ -> m_XbN1R (Data.Either.Either c_abMYX c'_abMYZ)
                [LclId] =
                    [$dMonad_sbQcG] \r [eta1_sbQcS]
                        let {
                          sat_sbQcT [Occ=Once] :: Data.Either.Either c_abMYX c'_abMYZ
                          [LclId] =
                              CCCS Data.Either.Right! [eta1_sbQcS];
                        } in  GHC.Base.return $dMonad_sbQcG sat_sbQcT; } in
              let {
                sat_sbQcR [Occ=Once] :: m_XbN1R c'_abMYZ
                [LclId] =
                    [g_sbQcI y_sbQcQ] \u [] g_sbQcI y_sbQcQ;
              } in  GHC.Base.>>= $dMonad_sbQcG sat_sbQcR sat_sbQcU;
        };

Control.Arrow.$fArrowChoiceKleisli3
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c d.
     Control.Arrow.Kleisli m b c
     -> Data.Either.Either b d -> m (Data.Either.Either c d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbQcV f_sbQcW eta_sbQcX]
        let {
          sat_sbQcZ [Occ=Once]
            :: Control.Arrow.Kleisli m_XbN1Q d_abMYe d_abMYe
          [LclId] =
              [$dMonad_sbQcV] \r [eta1_sbQcY]
                  GHC.Base.return $dMonad_sbQcV eta1_sbQcY;
        } in 
          Control.Arrow.$fArrowChoiceKleisli1
              $dMonad_sbQcV f_sbQcW sat_sbQcZ eta_sbQcX;

Control.Arrow.$fArrowChoiceKleisli2
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall b c d.
     Control.Arrow.Kleisli m b c
     -> Data.Either.Either d b -> m (Data.Either.Either d c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbQd0 f_sbQd1 eta_sbQd2]
        let {
          sat_sbQd4 [Occ=Once]
            :: Control.Arrow.Kleisli m_XbN1P d_abMYB d_abMYB
          [LclId] =
              [$dMonad_sbQd0] \r [eta1_sbQd3]
                  GHC.Base.return $dMonad_sbQd0 eta1_sbQd3;
        } in 
          Control.Arrow.$fArrowChoiceKleisli1
              $dMonad_sbQd0 sat_sbQd4 f_sbQd1 eta_sbQd2;

lvl4_rbNCc
  :: forall (m :: * -> *) b d c.
     Control.Arrow.Kleisli m b d
     -> Control.Arrow.Kleisli m c d -> Data.Either.Either b c -> m d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbQd5 ds1_sbQd6 eta_sbQd7]
        Data.Either.either ds_sbQd5 ds1_sbQd6 eta_sbQd7;

Control.Arrow.$fArrowChoiceKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     Control.Arrow.ArrowChoice (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,U,A)>m] =
    [] \r [$dMonad_sbQd8]
        let {
          sat_sbQdc [Occ=Once]
            :: forall b c b' c'.
               Control.Arrow.Kleisli m_XbN1O b c
               -> Control.Arrow.Kleisli m_XbN1O b' c'
               -> Control.Arrow.Kleisli
                    m_XbN1O (Data.Either.Either b b') (Data.Either.Either c c')
          [LclId] =
              [$dMonad_sbQd8] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fArrowChoiceKleisli1
                      $dMonad_sbQd8 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbQdb [Occ=Once]
            :: forall b c d.
               Control.Arrow.Kleisli m_XbN1O b c
               -> Control.Arrow.Kleisli
                    m_XbN1O (Data.Either.Either d b) (Data.Either.Either d c)
          [LclId] =
              [$dMonad_sbQd8] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowChoiceKleisli2
                      $dMonad_sbQd8 eta_B2 eta_B1; } in
        let {
          sat_sbQda [Occ=Once]
            :: forall b c d.
               Control.Arrow.Kleisli m_XbN1O b c
               -> Control.Arrow.Kleisli
                    m_XbN1O (Data.Either.Either b d) (Data.Either.Either c d)
          [LclId] =
              [$dMonad_sbQd8] \r [eta_B2 eta_B1]
                  Control.Arrow.$fArrowChoiceKleisli3
                      $dMonad_sbQd8 eta_B2 eta_B1; } in
        let {
          sat_sbQd9 [Occ=Once]
            :: Control.Arrow.Arrow (Control.Arrow.Kleisli m_XbN1O)
          [LclId] =
              [$dMonad_sbQd8] \u [] Control.Arrow.$fArrowKleisli $dMonad_sbQd8;
        } in 
          Control.Arrow.C:ArrowChoice [sat_sbQd9
                                       sat_sbQda
                                       sat_sbQdb
                                       sat_sbQdc
                                       lvl4_rbNCc];

Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Control.Arrow.Arrow (Control.Arrow.Kleisli m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(A,C(C1(U)),A,U,A),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbQdd]
        let {
          sat_sbQde [Occ=Once, Dmd=<L,U(A,C(C1(U)),A,U,A)>]
            :: GHC.Base.Monad m_XbN5r
          [LclId] =
              [$dMonadPlus_sbQdd] \u [] GHC.Base.$p2MonadPlus $dMonadPlus_sbQdd;
        } in  Control.Arrow.$fArrowKleisli sat_sbQde;

Control.Arrow.$fArrowZeroKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Control.Arrow.ArrowZero (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U(A,C(C1(U)),A,U,A),1*U,A)>m] =
    [] \r [$dMonadPlus_sbQdf]
        let {
          lvl5_sbQdg [Occ=OnceL] :: forall c. m_XbN5s c
          [LclId] =
              [$dMonadPlus_sbQdf] \u [] GHC.Base.mzero $dMonadPlus_sbQdf; } in
        let {
          sat_sbQdj [Occ=Once]
            :: forall b c. Control.Arrow.Kleisli m_XbN5s b c
          [LclId] =
              [lvl5_sbQdg] \r [ds_sbQdi] lvl5_sbQdg; } in
        let {
          sat_sbQdh [Occ=Once]
            :: Control.Arrow.Arrow (Control.Arrow.Kleisli m_XbN5s)
          [LclId] =
              [$dMonadPlus_sbQdf] \u []
                  Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero $dMonadPlus_sbQdf;
        } in  Control.Arrow.C:ArrowZero [sat_sbQdh sat_sbQdj];

Control.Arrow.$fArrowPlusKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Control.Arrow.ArrowPlus (Control.Arrow.Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,U(A,C(C1(U)),A,U,A),U,C(C1(U)))>m] =
    [] \r [$dMonadPlus_sbQdk]
        let {
          sat_sbQdm [Occ=Once]
            :: forall b c.
               Control.Arrow.Kleisli m_XbN58 b c
               -> Control.Arrow.Kleisli m_XbN58 b c
               -> Control.Arrow.Kleisli m_XbN58 b c
          [LclId] =
              [$dMonadPlus_sbQdk] \r [eta_B3 eta_B2 eta_B1]
                  Control.Arrow.$fArrowPlusKleisli1
                      $dMonadPlus_sbQdk eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbQdl [Occ=Once]
            :: Control.Arrow.ArrowZero (Control.Arrow.Kleisli m_XbN58)
          [LclId] =
              [$dMonadPlus_sbQdk] \u []
                  Control.Arrow.$fArrowZeroKleisli $dMonadPlus_sbQdk;
        } in  Control.Arrow.C:ArrowPlus [sat_sbQdl sat_sbQdm];

Control.Arrow.$dmsecond
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c d. a b c -> a (d, b) (d, c)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLC(S)L),U(1*U(1*U,A),A,A,A,1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQdn]
        let {
          sat_sbQdp [Occ=Once] :: a_abMuz d_abMNj d_abMNj
          [LclId] =
              [$dArrow_sbQdn] \u []
                  case Control.Arrow.$p1Arrow $dArrow_sbQdn of sat_sbQdo {
                    __DEFAULT -> Control.Category.id sat_sbQdo;
                  };
        } in  Control.Arrow.*** $dArrow_sbQdn sat_sbQdp;

Control.Arrow.$dmfirst
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     forall b c d. a b c -> a (b, d) (c, d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLC(C(S))L),U(1*U(1*U,A),A,A,A,1*C1(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQdq eta_sbQdr]
        let {
          sat_sbQdt [Occ=Once] :: a_abMuz d_abMN2 d_abMN2
          [LclId] =
              [$dArrow_sbQdq] \u []
                  case Control.Arrow.$p1Arrow $dArrow_sbQdq of sat_sbQds {
                    __DEFAULT -> Control.Category.id sat_sbQds;
                  };
        } in  Control.Arrow.*** $dArrow_sbQdq eta_sbQdr sat_sbQdt;

Control.Arrow.$cfirst :: forall b c d. (b -> c) -> (b, d) -> (c, d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sbQdu ds1_sbQdv]
        let {
          sat_sbQdE [Occ=Once] :: d_abN4j
          [LclId] =
              [ds1_sbQdv] \u []
                  case ds1_sbQdv of {
                    (,) _ [Occ=Dead] y_sbQdD [Occ=Once] -> y_sbQdD;
                  }; } in
        let {
          sat_sbQdA [Occ=Once] :: c_abN4i
          [LclId] =
              [ds_sbQdu ds1_sbQdv] \u []
                  let {
                    sat_sbQdz [Occ=Once] :: b_abN4h
                    [LclId] =
                        [ds1_sbQdv] \u []
                            case ds1_sbQdv of {
                              (,) x_sbQdx [Occ=Once] _ [Occ=Dead] -> x_sbQdx;
                            };
                  } in  ds_sbQdu sat_sbQdz;
        } in  (,) [sat_sbQdA sat_sbQdE];

Control.Arrow.$csecond
  :: forall b c d. (b -> c) -> (d, b) -> (d, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sbQdF ds_sbQdG]
        let {
          sat_sbQdP [Occ=Once] :: c_abN4u
          [LclId] =
              [g_sbQdF ds_sbQdG] \u []
                  let {
                    sat_sbQdO [Occ=Once] :: b_abN4t
                    [LclId] =
                        [ds_sbQdG] \u []
                            case ds_sbQdG of {
                              (,) _ [Occ=Dead] y_sbQdN [Occ=Once] -> y_sbQdN;
                            };
                  } in  g_sbQdF sat_sbQdO; } in
        let {
          sat_sbQdK [Occ=Once] :: d_abN4v
          [LclId] =
              [ds_sbQdG] \u []
                  case ds_sbQdG of {
                    (,) x_sbQdI [Occ=Once] _ [Occ=Dead] -> x_sbQdI;
                  };
        } in  (,) [sat_sbQdK sat_sbQdP];

Control.Arrow.$c&&&
  :: forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [f_sbQdQ g_sbQdR eta_sbQdS]
        let {
          sat_sbQdU [Occ=Once] :: c'_abN4P
          [LclId] =
              [g_sbQdR eta_sbQdS] \u [] g_sbQdR eta_sbQdS; } in
        let {
          sat_sbQdT [Occ=Once] :: c_abN4O
          [LclId] =
              [f_sbQdQ eta_sbQdS] \u [] f_sbQdQ eta_sbQdS;
        } in  (,) [sat_sbQdT sat_sbQdU];

Control.Arrow.$fArrow(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Arrow.Arrow (->)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Arrow.C:Arrow! [Control.Category.$fCategoryTYPE(->)
                                          Control.Arrow.$fArrow(->)_$carr
                                          Control.Arrow.$cfirst
                                          Control.Arrow.$csecond
                                          Control.Arrow.$c***
                                          Control.Arrow.$c&&&];

Control.Arrow.$fArrowLoop(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Arrow.ArrowLoop (->)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Arrow.C:ArrowLoop! [Control.Arrow.$fArrow(->)
                                              Control.Arrow.$fArrowLoop(->)_$cloop];

Control.Arrow.$fArrowApply(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Arrow.ArrowApply (->)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Arrow.C:ArrowApply! [Control.Arrow.$fArrow(->)
                                               Control.Arrow.$fAlternativeArrowMonad_$capp];

Control.Arrow.$c+++
  :: forall b c b' c'.
     (b -> c)
     -> (b' -> c') -> Data.Either.Either b b' -> Data.Either.Either c c'
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sbQdV g_sbQdW ds1_sbQdX]
        case ds1_sbQdX of {
          Data.Either.Left x_sbQdZ [Occ=Once] ->
              let {
                sat_sbQe0 [Occ=Once] :: c_abN0A
                [LclId] =
                    [f_sbQdV x_sbQdZ] \u [] f_sbQdV x_sbQdZ;
              } in  Data.Either.Left [sat_sbQe0];
          Data.Either.Right y_sbQe1 [Occ=Once] ->
              let {
                sat_sbQe2 [Occ=Once] :: c'_abN0C
                [LclId] =
                    [g_sbQdW y_sbQe1] \u [] g_sbQdW y_sbQe1;
              } in  Data.Either.Right [sat_sbQe2];
        };

Control.Arrow.$cright
  :: forall b c d.
     (b -> c) -> Data.Either.Either d b -> Data.Either.Either d c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sbQe3 ds1_sbQe4]
        case ds1_sbQe4 of {
          Data.Either.Left x_sbQe6 [Occ=Once] -> wild_sbQe5;
          Data.Either.Right y_sbQe7 [Occ=Once] ->
              let {
                sat_sbQe8 [Occ=Once] :: c_abN0g
                [LclId] =
                    [f_sbQe3 y_sbQe7] \u [] f_sbQe3 y_sbQe7;
              } in  Data.Either.Right [sat_sbQe8];
        };

Control.Arrow.$cleft
  :: forall b c d.
     (b -> c) -> Data.Either.Either b d -> Data.Either.Either c d
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sbQe9 ds1_sbQea]
        case ds1_sbQea of {
          Data.Either.Left x_sbQec [Occ=Once] ->
              let {
                sat_sbQed [Occ=Once] :: c_abMZW
                [LclId] =
                    [f_sbQe9 x_sbQec] \u [] f_sbQe9 x_sbQec;
              } in  Data.Either.Left [sat_sbQed];
          Data.Either.Right y_sbQee [Occ=Once] -> wild_sbQeb;
        };

Control.Arrow.$fArrowChoice(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Arrow.ArrowChoice (->)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Arrow.C:ArrowChoice! [Control.Arrow.$fArrow(->)
                                                Control.Arrow.$cleft
                                                Control.Arrow.$cright
                                                Control.Arrow.$c+++
                                                Data.Either.either];

Control.Arrow.runKleisli1
  :: forall (m :: * -> *) a b.
     Control.Arrow.Kleisli m a b -> Control.Arrow.Kleisli m a b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbQef] ds_sbQef;

Control.Arrow.runKleisli
  :: forall (m :: * -> *) a b.
     Control.Arrow.Kleisli m a b -> a -> m b
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Control.Arrow.runKleisli1 eta_B1;

Control.Arrow.returnA
  :: forall (a :: * -> * -> *) b. Control.Arrow.Arrow a => a b b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQeg] Control.Arrow.arr $dArrow_sbQeg GHC.Base.id;

Control.Arrow.^>>
  :: forall (a :: * -> * -> *) b c d.
     Control.Arrow.Arrow a =>
     (b -> c) -> a c d -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQeh eta_sbQei eta1_sbQej]
        let {
          sat_sbQel [Occ=Once] :: a_abMMs b_abMMt c_abMMu
          [LclId] =
              [$dArrow_sbQeh eta_sbQei] \u []
                  Control.Arrow.arr $dArrow_sbQeh eta_sbQei;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbQeh of sat_sbQek {
            __DEFAULT -> Control.Category.. sat_sbQek eta1_sbQej sat_sbQel;
          };

Control.Arrow.>>^
  :: forall (a :: * -> * -> *) b c d.
     Control.Arrow.Arrow a =>
     a b c -> (c -> d) -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQem eta_sbQen eta1_sbQeo]
        let {
          sat_sbQeq [Occ=Once] :: a_abMMb c_abMMd d_abMMe
          [LclId] =
              [$dArrow_sbQem eta1_sbQeo] \u []
                  Control.Arrow.arr $dArrow_sbQem eta1_sbQeo;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbQem of sat_sbQep {
            __DEFAULT -> Control.Category.. sat_sbQep sat_sbQeq eta_sbQen;
          };

Control.Arrow.<<^
  :: forall (a :: * -> * -> *) c d b.
     Control.Arrow.Arrow a =>
     a c d -> (b -> c) -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQer eta_sbQes eta1_sbQet]
        let {
          sat_sbQev [Occ=Once] :: a_abMLU b_abMLX c_abMLV
          [LclId] =
              [$dArrow_sbQer eta1_sbQet] \u []
                  Control.Arrow.arr $dArrow_sbQer eta1_sbQet;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbQer of sat_sbQeu {
            __DEFAULT -> Control.Category.. sat_sbQeu eta_sbQes sat_sbQev;
          };

Control.Arrow.^<<
  :: forall (a :: * -> * -> *) c d b.
     Control.Arrow.Arrow a =>
     (c -> d) -> a b c -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbQew eta_sbQex eta1_sbQey]
        let {
          sat_sbQeA [Occ=Once] :: a_abMLx c_abMLy d_abMLz
          [LclId] =
              [$dArrow_sbQew eta_sbQex] \u []
                  Control.Arrow.arr $dArrow_sbQew eta_sbQex;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbQew of sat_sbQez {
            __DEFAULT -> Control.Category.. sat_sbQez sat_sbQeA eta1_sbQey;
          };

Control.Arrow.leftApp
  :: forall (a :: * -> * -> *) b c d.
     Control.Arrow.ArrowApply a =>
     a b c -> a (Data.Either.Either b d) (Data.Either.Either c d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(1*U(1*U(A,C(C1(U))),C(U),A,A,A,A),1*U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowApply_sbQeB eta_sbQeC]
        case
            Control.Arrow.$p1ArrowApply $dArrowApply_sbQeB
        of
        $dArrow_sbQeD [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),C(U),A,A,A,A)>]
        { __DEFAULT ->
              case
                  Control.Arrow.$p1Arrow $dArrow_sbQeD
              of
              $dCategory_sbQeE [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
              { __DEFAULT ->
                    let {
                      sat_sbQeX [Occ=Once]
                        :: a_abMK6 (Data.Either.Either
                                      b_abMK7 d_abMK9) (a_abMK6 () (Data.Either.Either
                                                                      c_abMK8 d_abMK9),
                                                        ())
                      [LclId] =
                          [eta_sbQeC $dArrow_sbQeD $dCategory_sbQeE] \u []
                              let {
                                lvl5_sbQeG [Occ=OnceL]
                                  :: a_abMK6 c_abMK8 (Data.Either.Either c_abMK8 d_abMK9)
                                [LclId] =
                                    [$dArrow_sbQeD] \u []
                                        Control.Arrow.arr $dArrow_sbQeD Data.Either.Left; } in
                              let {
                                sat_sbQeW [Occ=Once]
                                  :: Data.Either.Either b_abMK7 d_abMK9
                                     -> (a_abMK6 () (Data.Either.Either c_abMK8 d_abMK9), ())
                                [LclId] =
                                    [eta_sbQeC
                                     $dArrow_sbQeD
                                     $dCategory_sbQeE
                                     lvl5_sbQeG] \r [ds1_sbQeH]
                                        case ds1_sbQeH of {
                                          Data.Either.Left x_sbQeJ [Occ=OnceL] ->
                                              let {
                                                sat_sbQeP [Occ=Once]
                                                  :: a_abMK6 () (Data.Either.Either c_abMK8 d_abMK9)
                                                [LclId] =
                                                    [eta_sbQeC
                                                     $dArrow_sbQeD
                                                     $dCategory_sbQeE
                                                     lvl5_sbQeG
                                                     x_sbQeJ] \u []
                                                        let {
                                                          sat_sbQeO [Occ=Once] :: a_abMK6 () c_abMK8
                                                          [LclId] =
                                                              [eta_sbQeC
                                                               $dArrow_sbQeD
                                                               $dCategory_sbQeE
                                                               x_sbQeJ] \u []
                                                                  let {
                                                                    sat_sbQeN [Occ=Once]
                                                                      :: a_abMK6 () b_abMK7
                                                                    [LclId] =
                                                                        [$dArrow_sbQeD
                                                                         x_sbQeJ] \u []
                                                                            let {
                                                                              sat_sbQeM [Occ=Once]
                                                                                :: () -> b_abMK7
                                                                              [LclId] =
                                                                                  [x_sbQeJ] \r [ds_sbQeK]
                                                                                      case
                                                                                          ds_sbQeK
                                                                                      of
                                                                                      { () ->
                                                                                            x_sbQeJ;
                                                                                      };
                                                                            } in 
                                                                              Control.Arrow.arr
                                                                                  $dArrow_sbQeD
                                                                                  sat_sbQeM;
                                                                  } in 
                                                                    Control.Category..
                                                                        $dCategory_sbQeE
                                                                        eta_sbQeC
                                                                        sat_sbQeN;
                                                        } in 
                                                          Control.Category..
                                                              $dCategory_sbQeE lvl5_sbQeG sat_sbQeO;
                                              } in  (,) [sat_sbQeP GHC.Tuple.()];
                                          Data.Either.Right y_sbQeQ [Occ=OnceL] ->
                                              let {
                                                sat_sbQeV [Occ=Once]
                                                  :: a_abMK6 () (Data.Either.Either c_abMK8 d_abMK9)
                                                [LclId] =
                                                    [$dArrow_sbQeD y_sbQeQ] \u []
                                                        let {
                                                          sat_sbQeU [Occ=Once]
                                                            :: ()
                                                               -> Data.Either.Either c_abMK8 d_abMK9
                                                          [LclId] =
                                                              [y_sbQeQ] \r [x_sbQeR]
                                                                  let {
                                                                    sat_sbQeT [Occ=Once] :: d_abMK9
                                                                    [LclId] =
                                                                        [y_sbQeQ x_sbQeR] \u []
                                                                            case x_sbQeR of {
                                                                              () -> y_sbQeQ;
                                                                            };
                                                                  } in 
                                                                    Data.Either.Right [sat_sbQeT];
                                                        } in 
                                                          Control.Arrow.arr $dArrow_sbQeD sat_sbQeU;
                                              } in  (,) [sat_sbQeV GHC.Tuple.()];
                                        };
                              } in  Control.Arrow.arr $dArrow_sbQeD sat_sbQeW; } in
                    let {
                      sat_sbQeF [Occ=Once]
                        :: a_abMK6 (a_abMK6 () (Data.Either.Either c_abMK8 d_abMK9),
                                    ()) (Data.Either.Either c_abMK8 d_abMK9)
                      [LclId] =
                          [$dArrowApply_sbQeB] \u [] Control.Arrow.app $dArrowApply_sbQeB;
                    } in  Control.Category.. $dCategory_sbQeE sat_sbQeF sat_sbQeX;
              };
        };

Control.Arrow.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Control.Arrow.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$trModule4];

Control.Arrow.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Control.Arrow"#;

Control.Arrow.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$trModule2];

Control.Arrow.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Control.Arrow.$trModule3
                                     Control.Arrow.$trModule1];

$krep_rbNCd :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Tuple.$tc()
                                              GHC.Types.[]];

$krep1_rbNCe :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Control.Arrow.$tcKleisli1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         GHC.Types.krep$*->*->*];

Control.Arrow.$tcArrow1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep1_rbNCe];

Control.Arrow.$tcArrowMonad1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         GHC.Types.krep$*Arr*];

$krep2_rbNCf :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep3_rbNCg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep4_rbNCh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep5_rbNCi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_rbNCh $krep2_rbNCf];

$krep6_rbNCj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rbNCg $krep5_rbNCi];

$krep7_rbNCk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_rbNCh $krep_rbNCd];

$krep8_rbNCl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep7_rbNCk $krep3_rbNCg];

Control.Arrow.$tcArrow3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Arrow"#;

Control.Arrow.$tcArrow2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrow3];

Control.Arrow.$tcArrow :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12964584583212294992##
                                    10211991410748124746##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrow2
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcKleisli3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Kleisli"#;

Control.Arrow.$tcKleisli2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcKleisli3];

Control.Arrow.$tcKleisli :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2023158159015915132##
                                    6143719008973118504##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcKleisli2
                                    0#
                                    Control.Arrow.$tcKleisli1];

$krep9_rbNCm :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rbNCf GHC.Types.[]];

$krep10_rbNCn :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_rbNCg $krep9_rbNCm];

$krep11_rbNCo :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_rbNCh $krep10_rbNCn];

$krep12_rbNCp :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Arrow.$tcKleisli
                                              $krep11_rbNCo];

Control.Arrow.$tc'Kleisli1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_rbNCj $krep12_rbNCp];

Control.Arrow.$tc'Kleisli3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Kleisli"#;

Control.Arrow.$tc'Kleisli2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tc'Kleisli3];

Control.Arrow.$tc'Kleisli :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [793719726112502834##
                                    14919550952510816382##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tc'Kleisli2
                                    3#
                                    Control.Arrow.$tc'Kleisli1];

Control.Arrow.$tcArrowZero2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowZero"#;

Control.Arrow.$tcArrowZero1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowZero2];

Control.Arrow.$tcArrowZero :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [337582314637215801##
                                    485553589222180171##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowZero1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcArrowPlus2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowPlus"#;

Control.Arrow.$tcArrowPlus1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowPlus2];

Control.Arrow.$tcArrowPlus :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9089885184909062397##
                                    13092571182525076608##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowPlus1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcArrowChoice2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowChoice"#;

Control.Arrow.$tcArrowChoice1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowChoice2];

Control.Arrow.$tcArrowChoice :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9045385674203608923##
                                    4474606397073518393##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowChoice1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcArrowApply2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowApply"#;

Control.Arrow.$tcArrowApply1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowApply2];

Control.Arrow.$tcArrowApply :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4969046276209689969##
                                    2697302259091605677##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowApply1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.$tcArrowMonad3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowMonad"#;

Control.Arrow.$tcArrowMonad2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowMonad3];

Control.Arrow.$tcArrowMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2648525758856951758##
                                    13692351200590237690##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowMonad2
                                    0#
                                    Control.Arrow.$tcArrowMonad1];

$krep13_rbNCq :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_rbNCg GHC.Types.[]];

$krep14_rbNCr :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_rbNCh $krep13_rbNCq];

$krep15_rbNCs :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Arrow.$tcArrowMonad
                                              $krep14_rbNCr];

Control.Arrow.$tc'ArrowMonad1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_rbNCl $krep15_rbNCs];

Control.Arrow.$tc'ArrowMonad3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'ArrowMonad"#;

Control.Arrow.$tc'ArrowMonad2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tc'ArrowMonad3];

Control.Arrow.$tc'ArrowMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8781545391513276915##
                                    783725375361948493##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tc'ArrowMonad2
                                    2#
                                    Control.Arrow.$tc'ArrowMonad1];

Control.Arrow.$tcArrowLoop2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ArrowLoop"#;

Control.Arrow.$tcArrowLoop1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Arrow.$tcArrowLoop2];

Control.Arrow.$tcArrowLoop :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15298492960828880948##
                                    13953070859738786616##
                                    Control.Arrow.$trModule
                                    Control.Arrow.$tcArrowLoop1
                                    0#
                                    Control.Arrow.$tcArrow1];

Control.Arrow.C:ArrowLoop
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     (forall b d c. a (b, d) (c, d) -> a b c)
     -> Control.Arrow.ArrowLoop a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Control.Arrow.C:ArrowLoop [eta_B2 eta_B1];

Control.Arrow.C:ArrowApply
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     (forall b c. a (a b c, b) c) -> Control.Arrow.ArrowApply a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Control.Arrow.C:ArrowApply [eta_B2 eta_B1];

Control.Arrow.C:ArrowChoice
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     (forall b c d.
      a b c -> a (Data.Either.Either b d) (Data.Either.Either c d))
     -> (forall b c d.
         a b c -> a (Data.Either.Either d b) (Data.Either.Either d c))
     -> (forall b c b' c'.
         a b c
         -> a b' c'
         -> a (Data.Either.Either b b') (Data.Either.Either c c'))
     -> (forall b d c. a b d -> a c d -> a (Data.Either.Either b c) d)
     -> Control.Arrow.ArrowChoice a
[GblId[DataCon],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Control.Arrow.C:ArrowChoice [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];

Control.Arrow.C:ArrowPlus
  :: forall (a :: * -> * -> *).
     Control.Arrow.ArrowZero a =>
     (forall b c. a b c -> a b c -> a b c) -> Control.Arrow.ArrowPlus a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Control.Arrow.C:ArrowPlus [eta_B2 eta_B1];

Control.Arrow.C:ArrowZero
  :: forall (a :: * -> * -> *).
     Control.Arrow.Arrow a =>
     (forall b c. a b c) -> Control.Arrow.ArrowZero a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Control.Arrow.C:ArrowZero [eta_B2 eta_B1];

Control.Arrow.C:Arrow
  :: forall (a :: * -> * -> *).
     Control.Category.Category a =>
     (forall b c. (b -> c) -> a b c)
     -> (forall b c d. a b c -> a (b, d) (c, d))
     -> (forall b c d. a b c -> a (d, b) (d, c))
     -> (forall b c b' c'. a b c -> a b' c' -> a (b, b') (c, c'))
     -> (forall b c c'. a b c -> a b c' -> a b (c, c'))
     -> Control.Arrow.Arrow a
[GblId[DataCon],
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Control.Arrow.C:Arrow [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];

