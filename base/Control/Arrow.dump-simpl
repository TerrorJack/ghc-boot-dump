
==================== Tidy Core ====================
2018-03-16 16:06:39.815054916 UTC

Result size of Tidy Core
  = {terms: 1,525, types: 4,948, coercions: 664, joins: 0/20}

-- RHS size: {terms: 6, types: 28, coercions: 0, joins: 0/0}
Control.Arrow.$p1ArrowLoop
  :: forall (a :: * -> * -> *). ArrowLoop a => Arrow a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),U(U,A)>,
 RULES: Built in rule for Control.Arrow.$p1ArrowLoop: "Class op $p1ArrowLoop"]
Control.Arrow.$p1ArrowLoop
  = \ (@ (a_abMtR :: * -> * -> *)) (v_B1 :: ArrowLoop a_abMtR) ->
      case v_B1 of v_B1 { Control.Arrow.C:ArrowLoop v_B2 v_B3 -> v_B2 }

-- RHS size: {terms: 6, types: 28, coercions: 0, joins: 0/0}
loop
  :: forall (a :: * -> * -> *).
     ArrowLoop a =>
     forall b d c. a (b, d) (c, d) -> a b c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),U(A,U)>,
 RULES: Built in rule for loop: "Class op loop"]
loop
  = \ (@ (a_abMtR :: * -> * -> *)) (v_B1 :: ArrowLoop a_abMtR) ->
      case v_B1 of v_B1 { Control.Arrow.C:ArrowLoop v_B2 v_B3 -> v_B3 }

-- RHS size: {terms: 6, types: 23, coercions: 0, joins: 0/0}
Control.Arrow.$p1ArrowApply
  :: forall (a :: * -> * -> *). ArrowApply a => Arrow a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),U(U,A)>,
 RULES: Built in rule for Control.Arrow.$p1ArrowApply: "Class op $p1ArrowApply"]
Control.Arrow.$p1ArrowApply
  = \ (@ (a_abMtX :: * -> * -> *)) (v_B1 :: ArrowApply a_abMtX) ->
      case v_B1 of v_B1 { Control.Arrow.C:ArrowApply v_B2 v_B3 -> v_B2 }

-- RHS size: {terms: 6, types: 23, coercions: 0, joins: 0/0}
app
  :: forall (a :: * -> * -> *).
     ArrowApply a =>
     forall b c. a (a b c, b) c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),U(A,U)>,
 RULES: Built in rule for app: "Class op app"]
app
  = \ (@ (a_abMtX :: * -> * -> *)) (v_B1 :: ArrowApply a_abMtX) ->
      case v_B1 of v_B1 { Control.Arrow.C:ArrowApply v_B2 v_B3 -> v_B3 }

-- RHS size: {terms: 6, types: 82, coercions: 0, joins: 0/0}
Control.Arrow.$p1ArrowChoice
  :: forall (a :: * -> * -> *). ArrowChoice a => Arrow a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLL),U(U,A,A,A,A)>,
 RULES: Built in rule for Control.Arrow.$p1ArrowChoice: "Class op $p1ArrowChoice"]
Control.Arrow.$p1ArrowChoice
  = \ (@ (a_abMu0 :: * -> * -> *)) (v_B1 :: ArrowChoice a_abMu0) ->
      case v_B1 of v_B1
      { Control.Arrow.C:ArrowChoice v_B2 v_B3 v_B4 v_B5 v_B6 ->
      v_B2
      }

-- RHS size: {terms: 6, types: 82, coercions: 0, joins: 0/0}
left
  :: forall (a :: * -> * -> *).
     ArrowChoice a =>
     forall b c d. a b c -> a (Either b d) (Either c d)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLL),U(A,U,A,A,A)>,
 RULES: Built in rule for left: "Class op left"]
left
  = \ (@ (a_abMu0 :: * -> * -> *)) (v_B1 :: ArrowChoice a_abMu0) ->
      case v_B1 of v_B1
      { Control.Arrow.C:ArrowChoice v_B2 v_B3 v_B4 v_B5 v_B6 ->
      v_B3
      }

-- RHS size: {terms: 6, types: 82, coercions: 0, joins: 0/0}
right
  :: forall (a :: * -> * -> *).
     ArrowChoice a =>
     forall b c d. a b c -> a (Either d b) (Either d c)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLL),U(A,A,U,A,A)>,
 RULES: Built in rule for right: "Class op right"]
right
  = \ (@ (a_abMu0 :: * -> * -> *)) (v_B1 :: ArrowChoice a_abMu0) ->
      case v_B1 of v_B1
      { Control.Arrow.C:ArrowChoice v_B2 v_B3 v_B4 v_B5 v_B6 ->
      v_B4
      }

-- RHS size: {terms: 6, types: 82, coercions: 0, joins: 0/0}
+++
  :: forall (a :: * -> * -> *).
     ArrowChoice a =>
     forall b c b' c'. a b c -> a b' c' -> a (Either b b') (Either c c')
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSL),U(A,A,A,U,A)>,
 RULES: Built in rule for +++: "Class op +++"]
+++
  = \ (@ (a_abMu0 :: * -> * -> *)) (v_B1 :: ArrowChoice a_abMu0) ->
      case v_B1 of v_B1
      { Control.Arrow.C:ArrowChoice v_B2 v_B3 v_B4 v_B5 v_B6 ->
      v_B5
      }

-- RHS size: {terms: 6, types: 82, coercions: 0, joins: 0/0}
|||
  :: forall (a :: * -> * -> *).
     ArrowChoice a =>
     forall b d c. a b d -> a c d -> a (Either b c) d
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLS),U(A,A,A,A,U)>,
 RULES: Built in rule for |||: "Class op |||"]
|||
  = \ (@ (a_abMu0 :: * -> * -> *)) (v_B1 :: ArrowChoice a_abMu0) ->
      case v_B1 of v_B1
      { Control.Arrow.C:ArrowChoice v_B2 v_B3 v_B4 v_B5 v_B6 ->
      v_B6
      }

-- RHS size: {terms: 6, types: 25, coercions: 0, joins: 0/0}
Control.Arrow.$p1ArrowPlus
  :: forall (a :: * -> * -> *). ArrowPlus a => ArrowZero a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),U(U,A)>,
 RULES: Built in rule for Control.Arrow.$p1ArrowPlus: "Class op $p1ArrowPlus"]
Control.Arrow.$p1ArrowPlus
  = \ (@ (a_abMuq :: * -> * -> *)) (v_B1 :: ArrowPlus a_abMuq) ->
      case v_B1 of v_B1 { Control.Arrow.C:ArrowPlus v_B2 v_B3 -> v_B2 }

-- RHS size: {terms: 6, types: 25, coercions: 0, joins: 0/0}
<+>
  :: forall (a :: * -> * -> *).
     ArrowPlus a =>
     forall b c. a b c -> a b c -> a b c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),U(A,U)>,
 RULES: Built in rule for <+>: "Class op <+>"]
<+>
  = \ (@ (a_abMuq :: * -> * -> *)) (v_B1 :: ArrowPlus a_abMuq) ->
      case v_B1 of v_B1 { Control.Arrow.C:ArrowPlus v_B2 v_B3 -> v_B3 }

-- RHS size: {terms: 6, types: 19, coercions: 0, joins: 0/0}
Control.Arrow.$p1ArrowZero
  :: forall (a :: * -> * -> *). ArrowZero a => Arrow a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),U(U,A)>,
 RULES: Built in rule for Control.Arrow.$p1ArrowZero: "Class op $p1ArrowZero"]
Control.Arrow.$p1ArrowZero
  = \ (@ (a_abMut :: * -> * -> *)) (v_B1 :: ArrowZero a_abMut) ->
      case v_B1 of v_B1 { Control.Arrow.C:ArrowZero v_B2 v_B3 -> v_B2 }

-- RHS size: {terms: 6, types: 19, coercions: 0, joins: 0/0}
zeroArrow
  :: forall (a :: * -> * -> *). ArrowZero a => forall b c. a b c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),U(A,U)>,
 RULES: Built in rule for zeroArrow: "Class op zeroArrow"]
zeroArrow
  = \ (@ (a_abMut :: * -> * -> *)) (v_B1 :: ArrowZero a_abMut) ->
      case v_B1 of v_B1 { Control.Arrow.C:ArrowZero v_B2 v_B3 -> v_B3 }

-- RHS size: {terms: 6, types: 93, coercions: 0, joins: 0/0}
Control.Arrow.$p1Arrow
  :: forall (a :: * -> * -> *). Arrow a => Category a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLL),U(U,A,A,A,A,A)>,
 RULES: Built in rule for Control.Arrow.$p1Arrow: "Class op $p1Arrow"]
Control.Arrow.$p1Arrow
  = \ (@ (a_abMuz :: * -> * -> *)) (v_B1 :: Arrow a_abMuz) ->
      case v_B1 of v_B1
      { Control.Arrow.C:Arrow v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 ->
      v_B2
      }

-- RHS size: {terms: 6, types: 93, coercions: 0, joins: 0/0}
arr
  :: forall (a :: * -> * -> *).
     Arrow a =>
     forall b c. (b -> c) -> a b c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLL),U(A,U,A,A,A,A)>,
 RULES: Built in rule for arr: "Class op arr"]
arr
  = \ (@ (a_abMuz :: * -> * -> *)) (v_B1 :: Arrow a_abMuz) ->
      case v_B1 of v_B1
      { Control.Arrow.C:Arrow v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 ->
      v_B3
      }

-- RHS size: {terms: 6, types: 93, coercions: 0, joins: 0/0}
first
  :: forall (a :: * -> * -> *).
     Arrow a =>
     forall b c d. a b c -> a (b, d) (c, d)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLL),U(A,A,U,A,A,A)>,
 RULES: Built in rule for first: "Class op first"]
first
  = \ (@ (a_abMuz :: * -> * -> *)) (v_B1 :: Arrow a_abMuz) ->
      case v_B1 of v_B1
      { Control.Arrow.C:Arrow v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 ->
      v_B4
      }

-- RHS size: {terms: 6, types: 93, coercions: 0, joins: 0/0}
second
  :: forall (a :: * -> * -> *).
     Arrow a =>
     forall b c d. a b c -> a (d, b) (d, c)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLL),U(A,A,A,U,A,A)>,
 RULES: Built in rule for second: "Class op second"]
second
  = \ (@ (a_abMuz :: * -> * -> *)) (v_B1 :: Arrow a_abMuz) ->
      case v_B1 of v_B1
      { Control.Arrow.C:Arrow v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 ->
      v_B5
      }

-- RHS size: {terms: 6, types: 93, coercions: 0, joins: 0/0}
***
  :: forall (a :: * -> * -> *).
     Arrow a =>
     forall b c b' c'. a b c -> a b' c' -> a (b, b') (c, c')
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSL),U(A,A,A,A,U,A)>,
 RULES: Built in rule for ***: "Class op ***"]
***
  = \ (@ (a_abMuz :: * -> * -> *)) (v_B1 :: Arrow a_abMuz) ->
      case v_B1 of v_B1
      { Control.Arrow.C:Arrow v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 ->
      v_B6
      }

-- RHS size: {terms: 6, types: 93, coercions: 0, joins: 0/0}
&&&
  :: forall (a :: * -> * -> *).
     Arrow a =>
     forall b c c'. a b c -> a b c' -> a b (c, c')
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLS),U(A,A,A,A,A,U)>,
 RULES: Built in rule for &&&: "Class op &&&"]
&&&
  = \ (@ (a_abMuz :: * -> * -> *)) (v_B1 :: Arrow a_abMuz) ->
      case v_B1 of v_B1
      { Control.Arrow.C:Arrow v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 ->
      v_B7
      }

-- RHS size: {terms: 18, types: 27, coercions: 0, joins: 0/0}
Control.Arrow.$c***
  :: forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_abN4F)
                 (@ c_abN4G)
                 (@ b'_abN4H)
                 (@ c'_abN4I)
                 (f_abMvW [Occ=Once!] :: b_abN4F -> c_abN4G)
                 (g_abMvX [Occ=Once!] :: b'_abN4H -> c'_abN4I)
                 (ds_dbNnY :: (b_abN4F, b'_abN4H)) ->
                 (f_abMvW
                    (case ds_dbNnY of { (x_abMvY [Occ=Once], _ [Occ=Dead]) ->
                     x_abMvY
                     }),
                  g_abMvX
                    (case ds_dbNnY of { (_ [Occ=Dead], y_abMvZ [Occ=Once]) ->
                     y_abMvZ
                     }))}]
Control.Arrow.$c***
  = \ (@ b_abN4F)
      (@ c_abN4G)
      (@ b'_abN4H)
      (@ c'_abN4I)
      (f_abMvW :: b_abN4F -> c_abN4G)
      (g_abMvX :: b'_abN4H -> c'_abN4I)
      (ds_dbNnY :: (b_abN4F, b'_abN4H)) ->
      (f_abMvW (case ds_dbNnY of { (x_abMvY, y_abMvZ) -> x_abMvY }),
       g_abMvX (case ds_dbNnY of { (x_abMvY, y_abMvZ) -> y_abMvZ }))

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Control.Arrow.$fArrow(->)_$carr :: forall b c. (b -> c) -> b -> c
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_abN4b)
                 (@ c_abN4c)
                 (f_abMvV [Occ=Once] :: b_abN4b -> c_abN4c) ->
                 f_abMvV}]
Control.Arrow.$fArrow(->)_$carr
  = \ (@ b_abN4b) (@ c_abN4c) (f_abMvV :: b_abN4b -> c_abN4c) ->
      f_abMvV

-- RHS size: {terms: 13, types: 24, coercions: 8, joins: 0/0}
Control.Arrow.$fCategoryTYPEKleisli1
  :: forall (m :: * -> *).
     Monad m =>
     forall b c a. Kleisli m b c -> Kleisli m a b -> a -> m c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_abN3z :: * -> *))
                 ($dMonad_abN3A [Occ=Once] :: Monad m_abN3z)
                 (@ b_abN3Q)
                 (@ c_abN3R)
                 (@ a_abN3S)
                 (ds_dbNnL [Occ=Once] :: Kleisli m_abN3z b_abN3Q c_abN3R)
                 (ds1_dbNnM [Occ=Once] :: Kleisli m_abN3z a_abN3S b_abN3Q)
                 (b1_abMvU [Occ=Once] :: a_abN3S) ->
                 >>=
                   @ m_abN3z
                   $dMonad_abN3A
                   @ b_abN3Q
                   @ c_abN3R
                   ((ds1_dbNnM
                     `cast` (Control.Arrow.N:Kleisli[0]
                                 <m_abN3z>_R <a_abN3S>_R <b_abN3Q>_N
                             :: (Kleisli m_abN3z a_abN3S b_abN3Q :: *)
                                ~R# (a_abN3S -> m_abN3z b_abN3Q :: *)))
                      b1_abMvU)
                   (ds_dbNnL
                    `cast` (Control.Arrow.N:Kleisli[0]
                                <m_abN3z>_R <b_abN3Q>_R <c_abN3R>_N
                            :: (Kleisli m_abN3z b_abN3Q c_abN3R :: *)
                               ~R# (b_abN3Q -> m_abN3z c_abN3R :: *)))}]
Control.Arrow.$fCategoryTYPEKleisli1
  = \ (@ (m_abN3z :: * -> *))
      ($dMonad_abN3A :: Monad m_abN3z)
      (@ b_abN3Q)
      (@ c_abN3R)
      (@ a_abN3S)
      (ds_dbNnL :: Kleisli m_abN3z b_abN3Q c_abN3R)
      (ds1_dbNnM :: Kleisli m_abN3z a_abN3S b_abN3Q)
      (b1_abMvU :: a_abN3S) ->
      >>=
        @ m_abN3z
        $dMonad_abN3A
        @ b_abN3Q
        @ c_abN3R
        ((ds1_dbNnM
          `cast` (Control.Arrow.N:Kleisli[0]
                      <m_abN3z>_R <a_abN3S>_R <b_abN3Q>_N
                  :: (Kleisli m_abN3z a_abN3S b_abN3Q :: *)
                     ~R# (a_abN3S -> m_abN3z b_abN3Q :: *)))
           b1_abMvU)
        (ds_dbNnL
         `cast` (Control.Arrow.N:Kleisli[0]
                     <m_abN3z>_R <b_abN3Q>_R <c_abN3R>_N
                 :: (Kleisli m_abN3z b_abN3Q c_abN3R :: *)
                    ~R# (b_abN3Q -> m_abN3z c_abN3R :: *)))

-- RHS size: {terms: 7, types: 12, coercions: 32, joins: 0/0}
Control.Arrow.$fCategoryTYPEKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *). Monad m => Category (Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,1*U,A)>m,
 Unf=DFun: \ (@ (m_abMvR :: * -> *)) (v_B1 :: Monad m_abMvR) ->
       Control.Category.C:Category TYPE: *
                                   TYPE: Kleisli m_abMvR
                                   (return @ m_abMvR v_B1)
                                   `cast` (forall (a :: <*>_N).
                                           Sym (Control.Arrow.N:Kleisli[0] <m_abMvR>_R <a>_R <a>_N)
                                           :: (forall a. a -> m_abMvR a :: *)
                                              ~R# (forall a. Kleisli m_abMvR a a :: *))
                                   (Control.Arrow.$fCategoryTYPEKleisli1 @ m_abMvR v_B1)
                                   `cast` (forall (b :: <*>_N) (c :: <*>_N) (a :: <*>_N).
                                           <Kleisli m_abMvR b c>_R
                                           ->_R <Kleisli m_abMvR a b>_R
                                           ->_R Sym (Control.Arrow.N:Kleisli[0]
                                                         <m_abMvR>_R <a>_R <c>_N)
                                           :: (forall b c a.
                                               Kleisli m_abMvR b c
                                               -> Kleisli m_abMvR a b -> a -> m_abMvR c :: *)
                                              ~R# (forall b c a.
                                                   Kleisli m_abMvR b c
                                                   -> Kleisli m_abMvR a b
                                                   -> Kleisli m_abMvR a c :: *))]
Control.Arrow.$fCategoryTYPEKleisli
  = \ (@ (m_XbN5v :: * -> *)) ($dMonad_XbN5x :: Monad m_XbN5v) ->
      Control.Category.C:Category
        @ *
        @ (Kleisli m_XbN5v)
        ((return @ m_XbN5v $dMonad_XbN5x)
         `cast` (forall (a :: <*>_N).
                 Sym (Control.Arrow.N:Kleisli[0] <m_XbN5v>_R <a>_R <a>_N)
                 :: (forall a. a -> m_XbN5v a :: *)
                    ~R# (forall a. Kleisli m_XbN5v a a :: *)))
        ((Control.Arrow.$fCategoryTYPEKleisli1 @ m_XbN5v $dMonad_XbN5x)
         `cast` (forall (b :: <*>_N) (c :: <*>_N) (a :: <*>_N).
                 <Kleisli m_XbN5v b c>_R
                 ->_R <Kleisli m_XbN5v a b>_R
                 ->_R Sym (Control.Arrow.N:Kleisli[0] <m_XbN5v>_R <a>_R <c>_N)
                 :: (forall b c a.
                     Kleisli m_XbN5v b c -> Kleisli m_XbN5v a b -> a -> m_XbN5v c :: *)
                    ~R# (forall b c a.
                         Kleisli m_XbN5v b c
                         -> Kleisli m_XbN5v a b -> Kleisli m_XbN5v a c :: *)))

-- RHS size: {terms: 25, types: 42, coercions: 4, joins: 0/1}
Control.Arrow.$fArrowKleisli4
  :: forall (m :: * -> *).
     Monad m =>
     forall b c d. Kleisli m b c -> (d, b) -> m (d, c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,1*C1(U)><L,U(1*U,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60 40] 140 0}]
Control.Arrow.$fArrowKleisli4
  = \ (@ (m_abN1X :: * -> *))
      ($dMonad_abN1Y :: Monad m_abN1X)
      (@ b_abN2O)
      (@ c_abN2P)
      (@ d_abN2Q)
      (ds_dbNnh :: Kleisli m_abN1X b_abN2O c_abN2P)
      (ds1_dbNni :: (d_abN2Q, b_abN2O)) ->
      let {
        d1_sbNsW :: d_abN2Q
        [LclId]
        d1_sbNsW
          = case ds1_dbNni of { (d2_XbMxV, b1_abMvP) -> d2_XbMxV } } in
      >>=
        @ m_abN1X
        $dMonad_abN1Y
        @ c_abN2P
        @ (d_abN2Q, c_abN2P)
        ((ds_dbNnh
          `cast` (Control.Arrow.N:Kleisli[0]
                      <m_abN1X>_R <b_abN2O>_R <c_abN2P>_N
                  :: (Kleisli m_abN1X b_abN2O c_abN2P :: *)
                     ~R# (b_abN2O -> m_abN1X c_abN2P :: *)))
           (case ds1_dbNni of { (d2_XbMw3, b1_abMvP) -> b1_abMvP }))
        (\ (c1_abMvQ :: c_abN2P) ->
           return
             @ m_abN1X $dMonad_abN1Y @ (d_abN2Q, c_abN2P) (d1_sbNsW, c1_abMvQ))

-- RHS size: {terms: 25, types: 42, coercions: 4, joins: 0/1}
Control.Arrow.$fArrowKleisli3
  :: forall (m :: * -> *).
     Monad m =>
     forall b c d. Kleisli m b c -> (b, d) -> m (c, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,1*C1(U)><L,U(1*U,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60 40] 140 0}]
Control.Arrow.$fArrowKleisli3
  = \ (@ (m_XbN42 :: * -> *))
      ($dMonad_XbN44 :: Monad m_XbN42)
      (@ b_abN2s)
      (@ c_abN2t)
      (@ d_abN2u)
      (ds_dbNmQ :: Kleisli m_XbN42 b_abN2s c_abN2t)
      (ds1_dbNmR :: (b_abN2s, d_abN2u)) ->
      let {
        d1_sbNsU :: d_abN2u
        [LclId]
        d1_sbNsU
          = case ds1_dbNmR of { (b1_abMvK, d2_XbMy1) -> d2_XbMy1 } } in
      >>=
        @ m_XbN42
        $dMonad_XbN44
        @ c_abN2t
        @ (c_abN2t, d_abN2u)
        ((ds_dbNmQ
          `cast` (Control.Arrow.N:Kleisli[0]
                      <m_XbN42>_R <b_abN2s>_R <c_abN2t>_N
                  :: (Kleisli m_XbN42 b_abN2s c_abN2t :: *)
                     ~R# (b_abN2s -> m_XbN42 c_abN2t :: *)))
           (case ds1_dbNmR of { (b1_abMvK, d2_XbMw2) -> b1_abMvK }))
        (\ (c1_abMvM :: c_abN2t) ->
           return
             @ m_XbN42 $dMonad_XbN44 @ (c_abN2t, d_abN2u) (c1_abMvM, d1_sbNsU))

-- RHS size: {terms: 10, types: 15, coercions: 0, joins: 0/0}
Control.Arrow.$fArrowKleisli5
  :: forall (m :: * -> *).
     Monad m =>
     forall b c. (b -> c) -> b -> m c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_XbN4a :: * -> *))
                 ($dMonad_XbN4c [Occ=Once] :: Monad m_XbN4a)
                 (@ b_abN26)
                 (@ c_abN27)
                 (f_abMvI [Occ=Once!] :: b_abN26 -> c_abN27)
                 (eta_B1 [Occ=Once] :: b_abN26) ->
                 return @ m_XbN4a $dMonad_XbN4c @ c_abN27 (f_abMvI eta_B1)}]
Control.Arrow.$fArrowKleisli5
  = \ (@ (m_XbN4a :: * -> *))
      ($dMonad_XbN4c :: Monad m_XbN4a)
      (@ b_abN26)
      (@ c_abN27)
      (f_abMvI :: b_abN26 -> c_abN27)
      (eta_B1 :: b_abN26) ->
      return @ m_XbN4a $dMonad_XbN4c @ c_abN27 (f_abMvI eta_B1)

-- RHS size: {terms: 13, types: 21, coercions: 8, joins: 0/0}
Control.Arrow.$fArrowPlusKleisli1
  :: forall (m :: * -> *).
     MonadPlus m =>
     forall b c. Kleisli m b c -> Kleisli m b c -> b -> m c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))),1*U(A,A,A,1*C1(C1(U)))><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_abN1h :: * -> *))
                 ($dMonadPlus_abN1i [Occ=Once] :: MonadPlus m_abN1h)
                 (@ b_abN1q)
                 (@ c_abN1r)
                 (ds_dbNmd [Occ=Once] :: Kleisli m_abN1h b_abN1q c_abN1r)
                 (ds1_dbNme [Occ=Once] :: Kleisli m_abN1h b_abN1q c_abN1r)
                 (x_abMvF :: b_abN1q) ->
                 mplus
                   @ m_abN1h
                   $dMonadPlus_abN1i
                   @ c_abN1r
                   ((ds_dbNmd
                     `cast` (Control.Arrow.N:Kleisli[0]
                                 <m_abN1h>_R <b_abN1q>_R <c_abN1r>_N
                             :: (Kleisli m_abN1h b_abN1q c_abN1r :: *)
                                ~R# (b_abN1q -> m_abN1h c_abN1r :: *)))
                      x_abMvF)
                   ((ds1_dbNme
                     `cast` (Control.Arrow.N:Kleisli[0]
                                 <m_abN1h>_R <b_abN1q>_R <c_abN1r>_N
                             :: (Kleisli m_abN1h b_abN1q c_abN1r :: *)
                                ~R# (b_abN1q -> m_abN1h c_abN1r :: *)))
                      x_abMvF)}]
Control.Arrow.$fArrowPlusKleisli1
  = \ (@ (m_abN1h :: * -> *))
      ($dMonadPlus_abN1i :: MonadPlus m_abN1h)
      (@ b_abN1q)
      (@ c_abN1r)
      (ds_dbNmd :: Kleisli m_abN1h b_abN1q c_abN1r)
      (ds1_dbNme :: Kleisli m_abN1h b_abN1q c_abN1r)
      (x_abMvF :: b_abN1q) ->
      mplus
        @ m_abN1h
        $dMonadPlus_abN1i
        @ c_abN1r
        ((ds_dbNmd
          `cast` (Control.Arrow.N:Kleisli[0]
                      <m_abN1h>_R <b_abN1q>_R <c_abN1r>_N
                  :: (Kleisli m_abN1h b_abN1q c_abN1r :: *)
                     ~R# (b_abN1q -> m_abN1h c_abN1r :: *)))
           x_abMvF)
        ((ds1_dbNme
          `cast` (Control.Arrow.N:Kleisli[0]
                      <m_abN1h>_R <b_abN1q>_R <c_abN1r>_N
                  :: (Kleisli m_abN1h b_abN1q c_abN1r :: *)
                     ~R# (b_abN1q -> m_abN1h c_abN1r :: *)))
           x_abMvF)

-- RHS size: {terms: 8, types: 15, coercions: 0, joins: 0/0}
Control.Arrow.$fAlternativeArrowMonad_$capp
  :: forall b c. (b -> c, b) -> c
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_abMXY)
                 (@ c_abMXZ)
                 (ds_dbNlz [Occ=Once!] :: (b_abMXY -> c_abMXZ, b_abMXY)) ->
                 case ds_dbNlz of { (f_abMvp [Occ=Once!], x_abMvq [Occ=Once]) ->
                 f_abMvp x_abMvq
                 }}]
Control.Arrow.$fAlternativeArrowMonad_$capp
  = \ (@ b_abMXY)
      (@ c_abMXZ)
      (ds_dbNlz :: (b_abMXY -> c_abMXZ, b_abMXY)) ->
      case ds_dbNlz of { (f_abMvp, x_abMvq) -> f_abMvp x_abMvq }

-- RHS size: {terms: 13, types: 27, coercions: 3, joins: 0/0}
Control.Arrow.$fApplicativeArrowMonad5
  :: forall (a :: * -> * -> *).
     Arrow a =>
     forall a1 b. (a1 -> b) -> ArrowMonad a a1 -> a () b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_abMWW :: * -> * -> *))
                 ($dArrow_abMWX :: Arrow a_abMWW)
                 (@ a1_abMX1)
                 (@ b_abMX2)
                 (eta_B2 [Occ=Once] :: a1_abMX1 -> b_abMX2)
                 (eta1_B1 [Occ=Once] :: ArrowMonad a_abMWW a1_abMX1) ->
                 . @ *
                   @ a_abMWW
                   (Control.Arrow.$p1Arrow @ a_abMWW $dArrow_abMWX)
                   @ a1_abMX1
                   @ b_abMX2
                   @ ()
                   (arr @ a_abMWW $dArrow_abMWX @ a1_abMX1 @ b_abMX2 eta_B2)
                   (eta1_B1
                    `cast` (Control.Arrow.N:ArrowMonad[0] <a_abMWW>_R <a1_abMX1>_N
                            :: (ArrowMonad a_abMWW a1_abMX1 :: *)
                               ~R# (a_abMWW () a1_abMX1 :: *)))}]
Control.Arrow.$fApplicativeArrowMonad5
  = \ (@ (a_abMWW :: * -> * -> *))
      ($dArrow_abMWX :: Arrow a_abMWW)
      (@ a1_abMX1)
      (@ b_abMX2)
      (eta_B2 :: a1_abMX1 -> b_abMX2)
      (eta1_B1 :: ArrowMonad a_abMWW a1_abMX1) ->
      . @ *
        @ a_abMWW
        (Control.Arrow.$p1Arrow @ a_abMWW $dArrow_abMWX)
        @ a1_abMX1
        @ b_abMX2
        @ ()
        (arr @ a_abMWW $dArrow_abMWX @ a1_abMX1 @ b_abMX2 eta_B2)
        (eta1_B1
         `cast` (Control.Arrow.N:ArrowMonad[0] <a_abMWW>_R <a1_abMX1>_N
                 :: (ArrowMonad a_abMWW a1_abMX1 :: *)
                    ~R# (a_abMWW () a1_abMX1 :: *)))

-- RHS size: {terms: 14, types: 27, coercions: 3, joins: 0/0}
Control.Arrow.$fFunctorArrowMonad1
  :: forall (a :: * -> * -> *).
     Arrow a =>
     forall a1 b. a1 -> ArrowMonad a b -> a () a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_XbMZs :: * -> * -> *))
                 ($dArrow_XbMZu :: Arrow a_XbMZs)
                 (@ a1_abMXm)
                 (@ b_abMXn)
                 (x_i9DkS [Occ=OnceL] :: a1_abMXm)
                 (eta_X2C [Occ=Once] :: ArrowMonad a_XbMZs b_abMXn) ->
                 . @ *
                   @ a_XbMZs
                   (Control.Arrow.$p1Arrow @ a_XbMZs $dArrow_XbMZu)
                   @ b_abMXn
                   @ a1_abMXm
                   @ ()
                   (arr
                      @ a_XbMZs
                      $dArrow_XbMZu
                      @ b_abMXn
                      @ a1_abMXm
                      (\ _ [Occ=Dead] -> x_i9DkS))
                   (eta_X2C
                    `cast` (Control.Arrow.N:ArrowMonad[0] <a_XbMZs>_R <b_abMXn>_N
                            :: (ArrowMonad a_XbMZs b_abMXn :: *)
                               ~R# (a_XbMZs () b_abMXn :: *)))}]
Control.Arrow.$fFunctorArrowMonad1
  = \ (@ (a_XbMZs :: * -> * -> *))
      ($dArrow_XbMZu :: Arrow a_XbMZs)
      (@ a1_abMXm)
      (@ b_abMXn)
      (x_i9DkS :: a1_abMXm)
      (eta_X2C :: ArrowMonad a_XbMZs b_abMXn) ->
      . @ *
        @ a_XbMZs
        (Control.Arrow.$p1Arrow @ a_XbMZs $dArrow_XbMZu)
        @ b_abMXn
        @ a1_abMXm
        @ ()
        (arr
           @ a_XbMZs
           $dArrow_XbMZu
           @ b_abMXn
           @ a1_abMXm
           (\ _ [Occ=Dead] -> x_i9DkS))
        (eta_X2C
         `cast` (Control.Arrow.N:ArrowMonad[0] <a_XbMZs>_R <b_abMXn>_N
                 :: (ArrowMonad a_XbMZs b_abMXn :: *)
                    ~R# (a_XbMZs () b_abMXn :: *)))

-- RHS size: {terms: 7, types: 12, coercions: 33, joins: 0/0}
Control.Arrow.$fFunctorArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *). Arrow a => Functor (ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,A)>m,
 Unf=DFun: \ (@ (a_abMvj :: * -> * -> *))
             (v_X2G :: Arrow a_abMvj) ->
       GHC.Base.C:Functor TYPE: ArrowMonad a_abMvj
                          (Control.Arrow.$fApplicativeArrowMonad5 @ a_abMvj v_X2G)
                          `cast` (forall (a1 :: <*>_N) (b :: <*>_N).
                                  <a1 -> b>_R
                                  ->_R <ArrowMonad a_abMvj a1>_R
                                  ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_abMvj>_R) <b>_N
                                  :: (forall a1 b.
                                      (a1 -> b) -> ArrowMonad a_abMvj a1 -> a_abMvj () b :: *)
                                     ~R# (forall a1 b.
                                          (a1 -> b)
                                          -> ArrowMonad a_abMvj a1 -> ArrowMonad a_abMvj b :: *))
                          (Control.Arrow.$fFunctorArrowMonad1 @ a_abMvj v_X2G)
                          `cast` (forall (a1 :: <*>_N) (b :: <*>_N).
                                  <a1>_R
                                  ->_R <ArrowMonad a_abMvj b>_R
                                  ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_abMvj>_R) <a1>_N
                                  :: (forall a1 b. a1 -> ArrowMonad a_abMvj b -> a_abMvj () a1 :: *)
                                     ~R# (forall a1 b.
                                          a1
                                          -> ArrowMonad a_abMvj b -> ArrowMonad a_abMvj a1 :: *))]
Control.Arrow.$fFunctorArrowMonad
  = \ (@ (a_XbMZA :: * -> * -> *))
      ($dArrow_XbMZC :: Arrow a_XbMZA) ->
      GHC.Base.C:Functor
        @ (ArrowMonad a_XbMZA)
        ((Control.Arrow.$fApplicativeArrowMonad5 @ a_XbMZA $dArrow_XbMZC)
         `cast` (forall (a1 :: <*>_N) (b :: <*>_N).
                 <a1 -> b>_R
                 ->_R <ArrowMonad a_XbMZA a1>_R
                 ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_XbMZA>_R) <b>_N
                 :: (forall a1 b.
                     (a1 -> b) -> ArrowMonad a_XbMZA a1 -> a_XbMZA () b :: *)
                    ~R# (forall a1 b.
                         (a1 -> b) -> ArrowMonad a_XbMZA a1 -> ArrowMonad a_XbMZA b :: *)))
        ((Control.Arrow.$fFunctorArrowMonad1 @ a_XbMZA $dArrow_XbMZC)
         `cast` (forall (a1 :: <*>_N) (b :: <*>_N).
                 <a1>_R
                 ->_R <ArrowMonad a_XbMZA b>_R
                 ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_XbMZA>_R) <a1>_N
                 :: (forall a1 b. a1 -> ArrowMonad a_XbMZA b -> a_XbMZA () a1 :: *)
                    ~R# (forall a1 b.
                         a1 -> ArrowMonad a_XbMZA b -> ArrowMonad a_XbMZA a1 :: *)))

-- RHS size: {terms: 16, types: 42, coercions: 7, joins: 0/0}
Control.Arrow.$fAlternativeArrowMonad2
  :: forall (a :: * -> * -> *).
     Arrow a =>
     forall a1 b. ArrowMonad a (a1 -> b) -> ArrowMonad a a1 -> a () b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,1*C1(C1(U)))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 0 0] 130 0}]
Control.Arrow.$fAlternativeArrowMonad2
  = \ (@ (a_abMVp :: * -> * -> *))
      ($dArrow_abMVq :: Arrow a_abMVp)
      (@ a1_abMVM)
      (@ b_abMVN)
      (eta_X2L :: ArrowMonad a_abMVp (a1_abMVM -> b_abMVN))
      (eta1_X5v :: ArrowMonad a_abMVp a1_abMVM) ->
      . @ *
        @ a_abMVp
        (Control.Arrow.$p1Arrow @ a_abMVp $dArrow_abMVq)
        @ (a1_abMVM -> b_abMVN, a1_abMVM)
        @ b_abMVN
        @ ()
        (arr
           @ a_abMVp
           $dArrow_abMVq
           @ (a1_abMVM -> b_abMVN, a1_abMVM)
           @ b_abMVN
           (Control.Arrow.$fAlternativeArrowMonad_$capp @ a1_abMVM @ b_abMVN))
        (&&&
           @ a_abMVp
           $dArrow_abMVq
           @ ()
           @ (a1_abMVM -> b_abMVN)
           @ a1_abMVM
           (eta_X2L
            `cast` (Control.Arrow.N:ArrowMonad[0] <a_abMVp>_R <a1_abMVM
                                                               -> b_abMVN>_N
                    :: (ArrowMonad a_abMVp (a1_abMVM -> b_abMVN) :: *)
                       ~R# (a_abMVp () (a1_abMVM -> b_abMVN) :: *)))
           (eta1_X5v
            `cast` (Control.Arrow.N:ArrowMonad[0] <a_abMVp>_R <a1_abMVM>_N
                    :: (ArrowMonad a_abMVp a1_abMVM :: *)
                       ~R# (a_abMVp () a1_abMVM :: *))))

-- RHS size: {terms: 8, types: 15, coercions: 0, joins: 0/0}
Control.Arrow.$fApplicativeArrowMonad6
  :: forall (a :: * -> * -> *). Arrow a => forall a1. a1 -> a () a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_XbMYc :: * -> * -> *))
                 ($dArrow_XbMYe [Occ=Once] :: Arrow a_XbMYc)
                 (@ a1_abMVy)
                 (x_abMvg [Occ=OnceL] :: a1_abMVy) ->
                 arr
                   @ a_XbMYc
                   $dArrow_XbMYe
                   @ ()
                   @ a1_abMVy
                   (\ _ [Occ=Dead] -> x_abMvg)}]
Control.Arrow.$fApplicativeArrowMonad6
  = \ (@ (a_XbMYc :: * -> * -> *))
      ($dArrow_XbMYe :: Arrow a_XbMYc)
      (@ a1_abMVy)
      (x_abMvg :: a1_abMVy) ->
      arr
        @ a_XbMYc $dArrow_XbMYe @ () @ a1_abMVy (\ _ [Occ=Dead] -> x_abMvg)

-- RHS size: {terms: 13, types: 27, coercions: 5, joins: 0/0}
Control.Arrow.$fApplicativeArrowMonad4
  :: forall (a :: * -> * -> *).
     Arrow a =>
     forall a1 b c.
     (a1 -> b -> c) -> ArrowMonad a a1 -> ArrowMonad a b -> a () c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_XbMYk :: * -> * -> *))
                 ($dArrow_XbMYm :: Arrow a_XbMYk)
                 (@ a1_abMWr)
                 (@ b_abMWs)
                 (@ c_abMWt)
                 (f1_ibNlf [Occ=Once] :: a1_abMWr -> b_abMWs -> c_abMWt)
                 (x_ibNlg [Occ=Once] :: ArrowMonad a_XbMYk a1_abMWr) ->
                 Control.Arrow.$fAlternativeArrowMonad2
                   @ a_XbMYk
                   $dArrow_XbMYm
                   @ b_abMWs
                   @ c_abMWt
                   ((Control.Arrow.$fApplicativeArrowMonad5
                       @ a_XbMYk
                       $dArrow_XbMYm
                       @ a1_abMWr
                       @ (b_abMWs -> c_abMWt)
                       f1_ibNlf
                       x_ibNlg)
                    `cast` (Sym (Control.Arrow.N:ArrowMonad[0] <a_XbMYk>_R) <b_abMWs
                                                                             -> c_abMWt>_N
                            :: (a_XbMYk () (b_abMWs -> c_abMWt) :: *)
                               ~R# (ArrowMonad a_XbMYk (b_abMWs -> c_abMWt) :: *)))}]
Control.Arrow.$fApplicativeArrowMonad4
  = \ (@ (a_XbMYk :: * -> * -> *))
      ($dArrow_XbMYm :: Arrow a_XbMYk)
      (@ a1_abMWr)
      (@ b_abMWs)
      (@ c_abMWt)
      (f1_ibNlf :: a1_abMWr -> b_abMWs -> c_abMWt)
      (x_ibNlg :: ArrowMonad a_XbMYk a1_abMWr) ->
      Control.Arrow.$fAlternativeArrowMonad2
        @ a_XbMYk
        $dArrow_XbMYm
        @ b_abMWs
        @ c_abMWt
        ((Control.Arrow.$fApplicativeArrowMonad5
            @ a_XbMYk
            $dArrow_XbMYm
            @ a1_abMWr
            @ (b_abMWs -> c_abMWt)
            f1_ibNlf
            x_ibNlg)
         `cast` (Sym (Control.Arrow.N:ArrowMonad[0] <a_XbMYk>_R) <b_abMWs
                                                                  -> c_abMWt>_N
                 :: (a_XbMYk () (b_abMWs -> c_abMWt) :: *)
                    ~R# (ArrowMonad a_XbMYk (b_abMWs -> c_abMWt) :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Control.Arrow.$fApplicativeArrowMonad3 :: forall b a. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_abMWE)
                 (@ a_abMWD)
                 _ [Occ=Dead]
                 (eta_B1 [Occ=Once] :: b_abMWE) ->
                 eta_B1}]
Control.Arrow.$fApplicativeArrowMonad3
  = \ (@ b_abMWE) (@ a_abMWD) _ [Occ=Dead] (eta_B1 :: b_abMWE) ->
      eta_B1

-- RHS size: {terms: 16, types: 35, coercions: 8, joins: 0/0}
Control.Arrow.$fApplicativeArrowMonad2
  :: forall (a :: * -> * -> *).
     Arrow a =>
     forall a1 b. ArrowMonad a a1 -> ArrowMonad a b -> a () b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 130 0}]
Control.Arrow.$fApplicativeArrowMonad2
  = \ (@ (a_XbMYj :: * -> * -> *))
      ($dArrow_XbMYl :: Arrow a_XbMYj)
      (@ a1_abMWD)
      (@ b_abMWE)
      (a2_ibJeW :: ArrowMonad a_XbMYj a1_abMWD)
      (a3_ibJeX :: ArrowMonad a_XbMYj b_abMWE) ->
      Control.Arrow.$fAlternativeArrowMonad2
        @ a_XbMYj
        $dArrow_XbMYl
        @ b_abMWE
        @ b_abMWE
        ((. @ *
            @ a_XbMYj
            (Control.Arrow.$p1Arrow @ a_XbMYj $dArrow_XbMYl)
            @ a1_abMWD
            @ (b_abMWE -> b_abMWE)
            @ ()
            (arr
               @ a_XbMYj
               $dArrow_XbMYl
               @ a1_abMWD
               @ (b_abMWE -> b_abMWE)
               (Control.Arrow.$fApplicativeArrowMonad3 @ b_abMWE @ a1_abMWD))
            (a2_ibJeW
             `cast` (Control.Arrow.N:ArrowMonad[0] <a_XbMYj>_R <a1_abMWD>_N
                     :: (ArrowMonad a_XbMYj a1_abMWD :: *)
                        ~R# (a_XbMYj () a1_abMWD :: *))))
         `cast` (Sym (Control.Arrow.N:ArrowMonad[0] <a_XbMYj>_R) <b_abMWE
                                                                  -> b_abMWE>_N
                 :: (a_XbMYj () (b_abMWE -> b_abMWE) :: *)
                    ~R# (ArrowMonad a_XbMYj (b_abMWE -> b_abMWE) :: *)))
        a3_ibJeX

-- RHS size: {terms: 14, types: 32, coercions: 8, joins: 0/0}
Control.Arrow.$fApplicativeArrowMonad1
  :: forall (a :: * -> * -> *).
     Arrow a =>
     forall a1 b. ArrowMonad a a1 -> ArrowMonad a b -> a () a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 120 60}]
Control.Arrow.$fApplicativeArrowMonad1
  = \ (@ (a_XbMYi :: * -> * -> *))
      ($dArrow_XbN1q :: Arrow a_XbMYi)
      (@ a1_abMWN)
      (@ b_abMWO)
      (x_XbNor :: ArrowMonad a_XbMYi a1_abMWN) ->
      Control.Arrow.$fAlternativeArrowMonad2
        @ a_XbMYi
        $dArrow_XbN1q
        @ b_abMWO
        @ a1_abMWN
        ((. @ *
            @ a_XbMYi
            (Control.Arrow.$p1Arrow @ a_XbMYi $dArrow_XbN1q)
            @ a1_abMWN
            @ (b_abMWO -> a1_abMWN)
            @ ()
            (arr
               @ a_XbMYi
               $dArrow_XbN1q
               @ a1_abMWN
               @ (b_abMWO -> a1_abMWN)
               (const @ a1_abMWN @ b_abMWO))
            (x_XbNor
             `cast` (Control.Arrow.N:ArrowMonad[0] <a_XbMYi>_R <a1_abMWN>_N
                     :: (ArrowMonad a_XbMYi a1_abMWN :: *)
                        ~R# (a_XbMYi () a1_abMWN :: *))))
         `cast` (Sym (Control.Arrow.N:ArrowMonad[0] <a_XbMYi>_R) <b_abMWO
                                                                  -> a1_abMWN>_N
                 :: (a_XbMYi () (b_abMWO -> a1_abMWN) :: *)
                    ~R# (ArrowMonad a_XbMYi (b_abMWO -> a1_abMWN) :: *)))

-- RHS size: {terms: 15, types: 16, coercions: 89, joins: 0/0}
Control.Arrow.$fApplicativeArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *). Arrow a => Applicative (ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>m,
 Unf=DFun: \ (@ (a_abMvf :: * -> * -> *))
             (v_X3d :: Arrow a_abMvf) ->
       GHC.Base.C:Applicative TYPE: ArrowMonad a_abMvf
                              Control.Arrow.$fFunctorArrowMonad @ a_abMvf v_X3d
                              (Control.Arrow.$fApplicativeArrowMonad6 @ a_abMvf v_X3d)
                              `cast` (forall (a1 :: <*>_N).
                                      <a1>_R
                                      ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_abMvf>_R) <a1>_N
                                      :: (forall a1. a1 -> a_abMvf () a1 :: *)
                                         ~R# (forall a1. a1 -> ArrowMonad a_abMvf a1 :: *))
                              (Control.Arrow.$fAlternativeArrowMonad2 @ a_abMvf v_X3d)
                              `cast` (forall (a1 :: <*>_N) (b :: <*>_N).
                                      <ArrowMonad a_abMvf (a1 -> b)>_R
                                      ->_R <ArrowMonad a_abMvf a1>_R
                                      ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_abMvf>_R) <b>_N
                                      :: (forall a1 b.
                                          ArrowMonad a_abMvf (a1 -> b)
                                          -> ArrowMonad a_abMvf a1 -> a_abMvf () b :: *)
                                         ~R# (forall a1 b.
                                              ArrowMonad a_abMvf (a1 -> b)
                                              -> ArrowMonad a_abMvf a1
                                              -> ArrowMonad a_abMvf b :: *))
                              (Control.Arrow.$fApplicativeArrowMonad4 @ a_abMvf v_X3d)
                              `cast` (forall (a1 :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                                      <a1 -> b -> c>_R
                                      ->_R <ArrowMonad a_abMvf a1>_R
                                      ->_R <ArrowMonad a_abMvf b>_R
                                      ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_abMvf>_R) <c>_N
                                      :: (forall a1 b c.
                                          (a1 -> b -> c)
                                          -> ArrowMonad a_abMvf a1
                                          -> ArrowMonad a_abMvf b
                                          -> a_abMvf () c :: *)
                                         ~R# (forall a1 b c.
                                              (a1 -> b -> c)
                                              -> ArrowMonad a_abMvf a1
                                              -> ArrowMonad a_abMvf b
                                              -> ArrowMonad a_abMvf c :: *))
                              (Control.Arrow.$fApplicativeArrowMonad2 @ a_abMvf v_X3d)
                              `cast` (forall (a1 :: <*>_N) (b :: <*>_N).
                                      <ArrowMonad a_abMvf a1>_R
                                      ->_R <ArrowMonad a_abMvf b>_R
                                      ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_abMvf>_R) <b>_N
                                      :: (forall a1 b.
                                          ArrowMonad a_abMvf a1
                                          -> ArrowMonad a_abMvf b -> a_abMvf () b :: *)
                                         ~R# (forall a1 b.
                                              ArrowMonad a_abMvf a1
                                              -> ArrowMonad a_abMvf b -> ArrowMonad a_abMvf b :: *))
                              (Control.Arrow.$fApplicativeArrowMonad1 @ a_abMvf v_X3d)
                              `cast` (forall (a1 :: <*>_N) (b :: <*>_N).
                                      <ArrowMonad a_abMvf a1>_R
                                      ->_R <ArrowMonad a_abMvf b>_R
                                      ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_abMvf>_R) <a1>_N
                                      :: (forall a1 b.
                                          ArrowMonad a_abMvf a1
                                          -> ArrowMonad a_abMvf b -> a_abMvf () a1 :: *)
                                         ~R# (forall a1 b.
                                              ArrowMonad a_abMvf a1
                                              -> ArrowMonad a_abMvf b
                                              -> ArrowMonad a_abMvf a1 :: *))]
Control.Arrow.$fApplicativeArrowMonad
  = \ (@ (a_XbMYh :: * -> * -> *))
      ($dArrow_XbN1v :: Arrow a_XbMYh) ->
      GHC.Base.C:Applicative
        @ (ArrowMonad a_XbMYh)
        (Control.Arrow.$fFunctorArrowMonad @ a_XbMYh $dArrow_XbN1v)
        ((Control.Arrow.$fApplicativeArrowMonad6 @ a_XbMYh $dArrow_XbN1v)
         `cast` (forall (a1 :: <*>_N).
                 <a1>_R ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_XbMYh>_R) <a1>_N
                 :: (forall a1. a1 -> a_XbMYh () a1 :: *)
                    ~R# (forall a1. a1 -> ArrowMonad a_XbMYh a1 :: *)))
        ((Control.Arrow.$fAlternativeArrowMonad2 @ a_XbMYh $dArrow_XbN1v)
         `cast` (forall (a1 :: <*>_N) (b :: <*>_N).
                 <ArrowMonad a_XbMYh (a1 -> b)>_R
                 ->_R <ArrowMonad a_XbMYh a1>_R
                 ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_XbMYh>_R) <b>_N
                 :: (forall a1 b.
                     ArrowMonad a_XbMYh (a1 -> b)
                     -> ArrowMonad a_XbMYh a1 -> a_XbMYh () b :: *)
                    ~R# (forall a1 b.
                         ArrowMonad a_XbMYh (a1 -> b)
                         -> ArrowMonad a_XbMYh a1 -> ArrowMonad a_XbMYh b :: *)))
        ((Control.Arrow.$fApplicativeArrowMonad4 @ a_XbMYh $dArrow_XbN1v)
         `cast` (forall (a1 :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                 <a1 -> b -> c>_R
                 ->_R <ArrowMonad a_XbMYh a1>_R
                 ->_R <ArrowMonad a_XbMYh b>_R
                 ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_XbMYh>_R) <c>_N
                 :: (forall a1 b c.
                     (a1 -> b -> c)
                     -> ArrowMonad a_XbMYh a1
                     -> ArrowMonad a_XbMYh b
                     -> a_XbMYh () c :: *)
                    ~R# (forall a1 b c.
                         (a1 -> b -> c)
                         -> ArrowMonad a_XbMYh a1
                         -> ArrowMonad a_XbMYh b
                         -> ArrowMonad a_XbMYh c :: *)))
        ((Control.Arrow.$fApplicativeArrowMonad2 @ a_XbMYh $dArrow_XbN1v)
         `cast` (forall (a1 :: <*>_N) (b :: <*>_N).
                 <ArrowMonad a_XbMYh a1>_R
                 ->_R <ArrowMonad a_XbMYh b>_R
                 ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_XbMYh>_R) <b>_N
                 :: (forall a1 b.
                     ArrowMonad a_XbMYh a1 -> ArrowMonad a_XbMYh b -> a_XbMYh () b :: *)
                    ~R# (forall a1 b.
                         ArrowMonad a_XbMYh a1
                         -> ArrowMonad a_XbMYh b -> ArrowMonad a_XbMYh b :: *)))
        ((Control.Arrow.$fApplicativeArrowMonad1 @ a_XbMYh $dArrow_XbN1v)
         `cast` (forall (a1 :: <*>_N) (b :: <*>_N).
                 <ArrowMonad a_XbMYh a1>_R
                 ->_R <ArrowMonad a_XbMYh b>_R
                 ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_XbMYh>_R) <a1>_N
                 :: (forall a1 b.
                     ArrowMonad a_XbMYh a1
                     -> ArrowMonad a_XbMYh b -> a_XbMYh () a1 :: *)
                    ~R# (forall a1 b.
                         ArrowMonad a_XbMYh a1
                         -> ArrowMonad a_XbMYh b -> ArrowMonad a_XbMYh a1 :: *)))

-- RHS size: {terms: 26, types: 62, coercions: 10, joins: 0/2}
Control.Arrow.$fMonadArrowMonad_$c>>=
  :: forall (a :: * -> * -> *).
     ArrowApply a =>
     forall a1 b.
     ArrowMonad a a1 -> (a1 -> ArrowMonad a b) -> ArrowMonad a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(1*U(1*U(A,C(C1(U))),1*C1(U),A,A,A,A),1*U)><L,U><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 60] 230 0}]
Control.Arrow.$fMonadArrowMonad_$c>>=
  = \ (@ (a_abMU9 :: * -> * -> *))
      ($dArrowApply_abMUa :: ArrowApply a_abMU9)
      (@ a1_abMUi)
      (@ b_abMUj)
      (eta_X3i :: ArrowMonad a_abMU9 a1_abMUi)
      (eta1_X6z :: a1_abMUi -> ArrowMonad a_abMU9 b_abMUj) ->
      let {
        $dArrow_sbNsS [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),1*C1(U),A,A,A,A)>]
          :: Arrow a_abMU9
        [LclId]
        $dArrow_sbNsS
          = Control.Arrow.$p1ArrowApply @ a_abMU9 $dArrowApply_abMUa } in
      let {
        $dCategory_sbNsR [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
          :: Category a_abMU9
        [LclId]
        $dCategory_sbNsR
          = Control.Arrow.$p1Arrow @ a_abMU9 $dArrow_sbNsS } in
      (. @ *
         @ a_abMU9
         $dCategory_sbNsR
         @ (a_abMU9 () b_abMUj, ())
         @ b_abMUj
         @ ()
         (app @ a_abMU9 $dArrowApply_abMUa @ () @ b_abMUj)
         (. @ *
            @ a_abMU9
            $dCategory_sbNsR
            @ a1_abMUi
            @ (a_abMU9 () b_abMUj, ())
            @ ()
            (arr
               @ a_abMU9
               $dArrow_sbNsS
               @ a1_abMUi
               @ (a_abMU9 () b_abMUj, ())
               (\ (x_abMvd :: a1_abMUi) ->
                  ((eta1_X6z x_abMvd)
                   `cast` (Control.Arrow.N:ArrowMonad[0] <a_abMU9>_R <b_abMUj>_N
                           :: (ArrowMonad a_abMU9 b_abMUj :: *)
                              ~R# (a_abMU9 () b_abMUj :: *)),
                   GHC.Tuple.())))
            (eta_X3i
             `cast` (Control.Arrow.N:ArrowMonad[0] <a_abMU9>_R <a1_abMUi>_N
                     :: (ArrowMonad a_abMU9 a1_abMUi :: *)
                        ~R# (a_abMU9 () a1_abMUi :: *)))))
      `cast` (Sym (Control.Arrow.N:ArrowMonad[0] <a_abMU9>_R) <b_abMUj>_N
              :: (a_abMU9 () b_abMUj :: *) ~R# (ArrowMonad a_abMU9 b_abMUj :: *))

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Control.Arrow.$fMonadArrowMonad_$cp1Monad
  :: forall (a :: * -> * -> *).
     ArrowApply a =>
     Applicative (ArrowMonad a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_abMU9 :: * -> * -> *))
                 ($dArrowApply_abMUa [Occ=Once] :: ArrowApply a_abMU9) ->
                 Control.Arrow.$fApplicativeArrowMonad
                   @ a_abMU9
                   (Control.Arrow.$p1ArrowApply @ a_abMU9 $dArrowApply_abMUa)}]
Control.Arrow.$fMonadArrowMonad_$cp1Monad
  = \ (@ (a_abMU9 :: * -> * -> *))
      ($dArrowApply_abMUa :: ArrowApply a_abMU9) ->
      Control.Arrow.$fApplicativeArrowMonad
        @ a_abMU9
        (Control.Arrow.$p1ArrowApply @ a_abMU9 $dArrowApply_abMUa)

-- RHS size: {terms: 9, types: 16, coercions: 0, joins: 0/0}
Control.Arrow.$fMonadArrowMonad1
  :: forall (a :: * -> * -> *).
     ArrowApply a =>
     forall a1. a1 -> a () a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)L),1*U(1*U(A,1*C1(U),A,A,A,A),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_abMU9 :: * -> * -> *))
                 ($dArrowApply_abMUa [Occ=Once] :: ArrowApply a_abMU9)
                 (@ a1_abMVa)
                 (eta_X3i [Occ=OnceL] :: a1_abMVa) ->
                 arr
                   @ a_abMU9
                   (Control.Arrow.$p1ArrowApply @ a_abMU9 $dArrowApply_abMUa)
                   @ ()
                   @ a1_abMVa
                   (\ _ [Occ=Dead] -> eta_X3i)}]
Control.Arrow.$fMonadArrowMonad1
  = \ (@ (a_abMU9 :: * -> * -> *))
      ($dArrowApply_abMUa :: ArrowApply a_abMU9)
      (@ a1_abMVa)
      (eta_X3i :: a1_abMVa) ->
      arr
        @ a_abMU9
        (Control.Arrow.$p1ArrowApply @ a_abMU9 $dArrowApply_abMUa)
        @ ()
        @ a1_abMVa
        (\ _ [Occ=Dead] -> eta_X3i)

-- RHS size: {terms: 11, types: 22, coercions: 0, joins: 0/0}
Control.Arrow.$fMonadArrowMonad_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall (a :: * -> * -> *).
     ArrowApply a =>
     forall a1 b. ArrowMonad a a1 -> ArrowMonad a b -> ArrowMonad a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(U(U(A,C(C1(U))),C(U),A,A,A,A),U)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (a_XbMXu :: * -> * -> *))
                 ($dArrowApply_XbMXw [Occ=Once] :: ArrowApply a_XbMXu)
                 (@ a1_abMV0)
                 (@ b_abMV1)
                 (m1_ibJeL [Occ=Once] :: ArrowMonad a_XbMXu a1_abMV0)
                 (k_ibJeM [Occ=OnceL] :: ArrowMonad a_XbMXu b_abMV1) ->
                 Control.Arrow.$fMonadArrowMonad_$c>>=
                   @ a_XbMXu
                   $dArrowApply_XbMXw
                   @ a1_abMV0
                   @ b_abMV1
                   m1_ibJeL
                   (\ _ [Occ=Dead] -> k_ibJeM)}]
Control.Arrow.$fMonadArrowMonad_$c>>
  = \ (@ (a_XbMXu :: * -> * -> *))
      ($dArrowApply_XbMXw :: ArrowApply a_XbMXu)
      (@ a1_abMV0)
      (@ b_abMV1)
      (eta_X3r :: ArrowMonad a_XbMXu a1_abMV0)
      (eta1_X6R :: ArrowMonad a_XbMXu b_abMV1) ->
      Control.Arrow.$fMonadArrowMonad_$c>>=
        @ a_XbMXu
        $dArrowApply_XbMXw
        @ a1_abMV0
        @ b_abMV1
        eta_X3r
        (\ _ [Occ=Dead] -> eta1_X6R)

-- RHS size: {terms: 5, types: 14, coercions: 0, joins: 0/0}
lvl_rbNC6
  :: forall (a1 :: * -> * -> *) a2. [Char] -> ArrowMonad a1 a2
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
lvl_rbNC6
  = \ (@ (a_XbMXv :: * -> * -> *)) (@ a1_abMVi) (eta_B1 :: [Char]) ->
      errorWithoutStackTrace
        @ 'LiftedRep @ (ArrowMonad a_XbMXv a1_abMVi) eta_B1

-- RHS size: {terms: 12, types: 15, coercions: 9, joins: 0/0}
Control.Arrow.$fMonadArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *). ArrowApply a => Monad (ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),U)>m,
 Unf=DFun: \ (@ (a_abMva :: * -> * -> *))
             (v_X3o :: ArrowApply a_abMva) ->
       GHC.Base.C:Monad TYPE: ArrowMonad a_abMva
                        Control.Arrow.$fMonadArrowMonad_$cp1Monad @ a_abMva v_X3o
                        Control.Arrow.$fMonadArrowMonad_$c>>= @ a_abMva v_X3o
                        Control.Arrow.$fMonadArrowMonad_$c>> @ a_abMva v_X3o
                        (Control.Arrow.$fMonadArrowMonad1 @ a_abMva v_X3o)
                        `cast` (forall (a1 :: <*>_N).
                                <a1>_R ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_abMva>_R) <a1>_N
                                :: (forall a1. a1 -> a_abMva () a1 :: *)
                                   ~R# (forall a1. a1 -> ArrowMonad a_abMva a1 :: *))
                        \ (@ a1_abMVi) ->
                          errorWithoutStackTrace
                            @ 'LiftedRep @ (ArrowMonad a_abMva a1_abMVi)]
Control.Arrow.$fMonadArrowMonad
  = \ (@ (a_XbMXv :: * -> * -> *))
      ($dArrowApply_XbMXx :: ArrowApply a_XbMXv) ->
      GHC.Base.C:Monad
        @ (ArrowMonad a_XbMXv)
        (Control.Arrow.$fMonadArrowMonad_$cp1Monad
           @ a_XbMXv $dArrowApply_XbMXx)
        (Control.Arrow.$fMonadArrowMonad_$c>>=
           @ a_XbMXv $dArrowApply_XbMXx)
        (Control.Arrow.$fMonadArrowMonad_$c>> @ a_XbMXv $dArrowApply_XbMXx)
        ((Control.Arrow.$fMonadArrowMonad1 @ a_XbMXv $dArrowApply_XbMXx)
         `cast` (forall (a1 :: <*>_N).
                 <a1>_R ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_XbMXv>_R) <a1>_N
                 :: (forall a1. a1 -> a_XbMXv () a1 :: *)
                    ~R# (forall a1. a1 -> ArrowMonad a_XbMXv a1 :: *)))
        (lvl_rbNC6 @ a_XbMXv)

-- RHS size: {terms: 6, types: 14, coercions: 0, joins: 0/0}
Control.Arrow.$fAlternativeArrowMonad3
  :: forall (a :: * -> * -> *). ArrowPlus a => forall a1. a () a1
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LS)L),1*U(1*U(A,1*U),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_XbMWw :: * -> * -> *))
                 ($dArrowPlus_XbMWy [Occ=Once] :: ArrowPlus a_XbMWw)
                 (@ a1_abMTw) ->
                 zeroArrow
                   @ a_XbMWw
                   (Control.Arrow.$p1ArrowPlus @ a_XbMWw $dArrowPlus_XbMWy)
                   @ ()
                   @ a1_abMTw}]
Control.Arrow.$fAlternativeArrowMonad3
  = \ (@ (a_XbMWw :: * -> * -> *))
      ($dArrowPlus_XbMWy :: ArrowPlus a_XbMWw)
      (@ a1_abMTw) ->
      zeroArrow
        @ a_XbMWw
        (Control.Arrow.$p1ArrowPlus @ a_XbMWw $dArrowPlus_XbMWy)
        @ ()
        @ a1_abMTw

-- RHS size: {terms: 6, types: 11, coercions: 0, joins: 0/0}
Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative
  :: forall (a :: * -> * -> *).
     ArrowPlus a =>
     Applicative (ArrowMonad a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A),A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_XbMWB :: * -> * -> *))
                 ($dArrowPlus_XbMWD [Occ=Once] :: ArrowPlus a_XbMWB) ->
                 Control.Arrow.$fApplicativeArrowMonad
                   @ a_XbMWB
                   (Control.Arrow.$p1ArrowZero
                      @ a_XbMWB
                      (Control.Arrow.$p1ArrowPlus @ a_XbMWB $dArrowPlus_XbMWD))}]
Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative
  = \ (@ (a_XbMWB :: * -> * -> *))
      ($dArrowPlus_XbMWD :: ArrowPlus a_XbMWB) ->
      Control.Arrow.$fApplicativeArrowMonad
        @ a_XbMWB
        (Control.Arrow.$p1ArrowZero
           @ a_XbMWB (Control.Arrow.$p1ArrowPlus @ a_XbMWB $dArrowPlus_XbMWD))

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Control.Arrow.$fAlternativeArrowMonad1 :: forall a. () -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_abMTU) _ [Occ=Dead] -> GHC.Types.[] @ a_abMTU}]
Control.Arrow.$fAlternativeArrowMonad1
  = \ (@ a_abMTU) _ [Occ=Dead] -> GHC.Types.[] @ a_abMTU

-- RHS size: {terms: 33, types: 85, coercions: 8, joins: 0/3}
Control.Arrow.$fAlternativeArrowMonad_$csome
  :: forall (a :: * -> * -> *).
     ArrowPlus a =>
     forall a1. ArrowMonad a a1 -> ArrowMonad a [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LC(C(S)))LLLLL)L)L),U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A),C(C1(U)))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 360 0}]
Control.Arrow.$fAlternativeArrowMonad_$csome
  = \ (@ (a_XbMWE :: * -> * -> *))
      ($dArrowPlus_XbMWG :: ArrowPlus a_XbMWE)
      (@ a1_abMTU)
      (eta_B1 :: ArrowMonad a_XbMWE a1_abMTU) ->
      letrec {
        some_v_sbNsM [Occ=LoopBreaker] :: a_XbMWE () [a1_abMTU]
        [LclId]
        some_v_sbNsM
          = let {
              $dApplicative_sbNsO [Dmd=<S(S(S(LC(C(S)))LLLLL)L),1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,1*C1(C1(U))),A)>]
                :: ArrowZero a_XbMWE
              [LclId]
              $dApplicative_sbNsO
                = Control.Arrow.$p1ArrowPlus @ a_XbMWE $dArrowPlus_XbMWG } in
            let {
              $dApplicative1_sbNsN [Dmd=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,1*C1(C1(U)))>]
                :: Arrow a_XbMWE
              [LclId]
              $dApplicative1_sbNsN
                = Control.Arrow.$p1ArrowZero @ a_XbMWE $dApplicative_sbNsO } in
            . @ *
              @ a_XbMWE
              (Control.Arrow.$p1Arrow @ a_XbMWE $dApplicative1_sbNsN)
              @ ([a1_abMTU] -> [a1_abMTU], [a1_abMTU])
              @ [a1_abMTU]
              @ ()
              (arr
                 @ a_XbMWE
                 $dApplicative1_sbNsN
                 @ ([a1_abMTU] -> [a1_abMTU], [a1_abMTU])
                 @ [a1_abMTU]
                 (Control.Arrow.$fAlternativeArrowMonad_$capp
                    @ [a1_abMTU] @ [a1_abMTU]))
              (&&&
                 @ a_XbMWE
                 $dApplicative1_sbNsN
                 @ ()
                 @ ([a1_abMTU] -> [a1_abMTU])
                 @ [a1_abMTU]
                 (. @ *
                    @ a_XbMWE
                    (Control.Arrow.$p1Arrow @ a_XbMWE $dApplicative1_sbNsN)
                    @ a1_abMTU
                    @ ([a1_abMTU] -> [a1_abMTU])
                    @ ()
                    (arr
                       @ a_XbMWE
                       $dApplicative1_sbNsN
                       @ a1_abMTU
                       @ ([a1_abMTU] -> [a1_abMTU])
                       (GHC.Types.: @ a1_abMTU))
                    (eta_B1
                     `cast` (Control.Arrow.N:ArrowMonad[0] <a_XbMWE>_R <a1_abMTU>_N
                             :: (ArrowMonad a_XbMWE a1_abMTU :: *)
                                ~R# (a_XbMWE () a1_abMTU :: *))))
                 (<+>
                    @ a_XbMWE
                    $dArrowPlus_XbMWG
                    @ ()
                    @ [a1_abMTU]
                    some_v_sbNsM
                    (arr
                       @ a_XbMWE
                       $dApplicative1_sbNsN
                       @ ()
                       @ [a1_abMTU]
                       (Control.Arrow.$fAlternativeArrowMonad1 @ a1_abMTU)))); } in
      some_v_sbNsM
      `cast` (Sym (Control.Arrow.N:ArrowMonad[0]
                       <a_XbMWE>_R) <[a1_abMTU]>_N
              :: (a_XbMWE () [a1_abMTU] :: *)
                 ~R# (ArrowMonad a_XbMWE [a1_abMTU] :: *))

-- RHS size: {terms: 27, types: 54, coercions: 20, joins: 0/3}
Control.Arrow.$fAlternativeArrowMonad_$cmany
  :: forall (a :: * -> * -> *).
     ArrowPlus a =>
     forall a1. ArrowMonad a a1 -> ArrowMonad a [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A),C(C1(U)))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 270 0}]
Control.Arrow.$fAlternativeArrowMonad_$cmany
  = \ (@ (a_XbMWD :: * -> * -> *))
      ($dArrowPlus_XbMWF :: ArrowPlus a_XbMWD)
      (@ a1_abMU2)
      (eta_B1 :: ArrowMonad a_XbMWD a1_abMU2) ->
      letrec {
        many_v_sbNsG [Occ=LoopBreaker] :: a_XbMWD () [a1_abMU2]
        [LclId]
        many_v_sbNsG
          = let {
              $dApplicative_sbNsI [Dmd=<L,1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)>]
                :: ArrowZero a_XbMWD
              [LclId]
              $dApplicative_sbNsI
                = Control.Arrow.$p1ArrowPlus @ a_XbMWD $dArrowPlus_XbMWF } in
            let {
              $dApplicative1_sbNsH [Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
                :: Arrow a_XbMWD
              [LclId]
              $dApplicative1_sbNsH
                = Control.Arrow.$p1ArrowZero @ a_XbMWD $dApplicative_sbNsI } in
            <+>
              @ a_XbMWD
              $dArrowPlus_XbMWF
              @ ()
              @ [a1_abMU2]
              (Control.Arrow.$fAlternativeArrowMonad2
                 @ a_XbMWD
                 $dApplicative1_sbNsH
                 @ [a1_abMU2]
                 @ [a1_abMU2]
                 ((. @ *
                     @ a_XbMWD
                     (Control.Arrow.$p1Arrow @ a_XbMWD $dApplicative1_sbNsH)
                     @ a1_abMU2
                     @ ([a1_abMU2] -> [a1_abMU2])
                     @ ()
                     (arr
                        @ a_XbMWD
                        $dApplicative1_sbNsH
                        @ a1_abMU2
                        @ ([a1_abMU2] -> [a1_abMU2])
                        (GHC.Types.: @ a1_abMU2))
                     (eta_B1
                      `cast` (Control.Arrow.N:ArrowMonad[0] <a_XbMWD>_R <a1_abMU2>_N
                              :: (ArrowMonad a_XbMWD a1_abMU2 :: *)
                                 ~R# (a_XbMWD () a1_abMU2 :: *))))
                  `cast` (Sym (Control.Arrow.N:ArrowMonad[0] <a_XbMWD>_R) <[a1_abMU2]
                                                                           -> [a1_abMU2]>_N
                          :: (a_XbMWD () ([a1_abMU2] -> [a1_abMU2]) :: *)
                             ~R# (ArrowMonad a_XbMWD ([a1_abMU2] -> [a1_abMU2]) :: *)))
                 (many_v_sbNsG
                  `cast` (Sym (Control.Arrow.N:ArrowMonad[0]
                                   <a_XbMWD>_R) <[a1_abMU2]>_N
                          :: (a_XbMWD () [a1_abMU2] :: *)
                             ~R# (ArrowMonad a_XbMWD [a1_abMU2] :: *))))
              (arr
                 @ a_XbMWD
                 $dApplicative1_sbNsH
                 @ ()
                 @ [a1_abMU2]
                 (Control.Arrow.$fAlternativeArrowMonad1 @ a1_abMU2)); } in
      many_v_sbNsG
      `cast` (Sym (Control.Arrow.N:ArrowMonad[0]
                       <a_XbMWD>_R) <[a1_abMU2]>_N
              :: (a_XbMWD () [a1_abMU2] :: *)
                 ~R# (ArrowMonad a_XbMWD [a1_abMU2] :: *))

-- RHS size: {terms: 18, types: 25, coercions: 28, joins: 0/0}
Control.Arrow.$fAlternativeArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     ArrowPlus a =>
     Alternative (ArrowMonad a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),1*U),C(C1(U)))>m,
 Unf=DFun: \ (@ (a_abMv7 :: * -> * -> *))
             (v_X3t :: ArrowPlus a_abMv7) ->
       GHC.Base.C:Alternative TYPE: ArrowMonad a_abMv7
                              Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative
                                @ a_abMv7 v_X3t
                              (Control.Arrow.$fAlternativeArrowMonad3 @ a_abMv7 v_X3t)
                              `cast` (forall (a1 :: <*>_N).
                                      Sym (Control.Arrow.N:ArrowMonad[0] <a_abMv7>_R) <a1>_N
                                      :: (forall a1. a_abMv7 () a1 :: *)
                                         ~R# (forall a1. ArrowMonad a_abMv7 a1 :: *))
                              (\ (@ a1_XbMX0)
                                 (ds_XbNnB [Occ=Once] :: ArrowMonad a_abMv7 a1_XbMX0)
                                 (ds1_XbNnD [Occ=Once] :: ArrowMonad a_abMv7 a1_XbMX0) ->
                                 <+>
                                   @ a_abMv7
                                   v_X3t
                                   @ ()
                                   @ a1_XbMX0
                                   (ds_XbNnB
                                    `cast` (Control.Arrow.N:ArrowMonad[0] <a_abMv7>_R <a1_XbMX0>_N
                                            :: (ArrowMonad a_abMv7 a1_XbMX0 :: *)
                                               ~R# (a_abMv7 () a1_XbMX0 :: *)))
                                   (ds1_XbNnD
                                    `cast` (Control.Arrow.N:ArrowMonad[0] <a_abMv7>_R <a1_XbMX0>_N
                                            :: (ArrowMonad a_abMv7 a1_XbMX0 :: *)
                                               ~R# (a_abMv7 () a1_XbMX0 :: *))))
                              `cast` (forall (a1 :: <*>_N).
                                      <ArrowMonad a_abMv7 a1>_R
                                      ->_R <ArrowMonad a_abMv7 a1>_R
                                      ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_abMv7>_R) <a1>_N
                                      :: (forall a1.
                                          ArrowMonad a_abMv7 a1
                                          -> ArrowMonad a_abMv7 a1 -> a_abMv7 () a1 :: *)
                                         ~R# (forall a1.
                                              ArrowMonad a_abMv7 a1
                                              -> ArrowMonad a_abMv7 a1
                                              -> ArrowMonad a_abMv7 a1 :: *))
                              Control.Arrow.$fAlternativeArrowMonad_$csome @ a_abMv7 v_X3t
                              Control.Arrow.$fAlternativeArrowMonad_$cmany @ a_abMv7 v_X3t]
Control.Arrow.$fAlternativeArrowMonad
  = \ (@ (a_XbMWC :: * -> * -> *))
      ($dArrowPlus_XbMWE :: ArrowPlus a_XbMWC) ->
      GHC.Base.C:Alternative
        @ (ArrowMonad a_XbMWC)
        (Control.Arrow.$fAlternativeArrowMonad_$cp1Alternative
           @ a_XbMWC $dArrowPlus_XbMWE)
        ((Control.Arrow.$fAlternativeArrowMonad3
            @ a_XbMWC $dArrowPlus_XbMWE)
         `cast` (forall (a1 :: <*>_N).
                 Sym (Control.Arrow.N:ArrowMonad[0] <a_XbMWC>_R) <a1>_N
                 :: (forall a1. a_XbMWC () a1 :: *)
                    ~R# (forall a1. ArrowMonad a_XbMWC a1 :: *)))
        ((\ (@ a1_XbMX0)
            (ds_XbNnB :: ArrowMonad a_XbMWC a1_XbMX0)
            (ds1_XbNnD :: ArrowMonad a_XbMWC a1_XbMX0) ->
            <+>
              @ a_XbMWC
              $dArrowPlus_XbMWE
              @ ()
              @ a1_XbMX0
              (ds_XbNnB
               `cast` (Control.Arrow.N:ArrowMonad[0] <a_XbMWC>_R <a1_XbMX0>_N
                       :: (ArrowMonad a_XbMWC a1_XbMX0 :: *)
                          ~R# (a_XbMWC () a1_XbMX0 :: *)))
              (ds1_XbNnD
               `cast` (Control.Arrow.N:ArrowMonad[0] <a_XbMWC>_R <a1_XbMX0>_N
                       :: (ArrowMonad a_XbMWC a1_XbMX0 :: *)
                          ~R# (a_XbMWC () a1_XbMX0 :: *))))
         `cast` (forall (a1 :: <*>_N).
                 <ArrowMonad a_XbMWC a1>_R
                 ->_R <ArrowMonad a_XbMWC a1>_R
                 ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_XbMWC>_R) <a1>_N
                 :: (forall a1.
                     ArrowMonad a_XbMWC a1
                     -> ArrowMonad a_XbMWC a1 -> a_XbMWC () a1 :: *)
                    ~R# (forall a1.
                         ArrowMonad a_XbMWC a1
                         -> ArrowMonad a_XbMWC a1 -> ArrowMonad a_XbMWC a1 :: *)))
        (Control.Arrow.$fAlternativeArrowMonad_$csome
           @ a_XbMWC $dArrowPlus_XbMWE)
        (Control.Arrow.$fAlternativeArrowMonad_$cmany
           @ a_XbMWC $dArrowPlus_XbMWE)

-- RHS size: {terms: 18, types: 29, coercions: 28, joins: 0/0}
Control.Arrow.$fMonadPlusArrowMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *).
     (ArrowApply a, ArrowPlus a) =>
     MonadPlus (ArrowMonad a)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),U)><L,U(U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),U),C(C1(U)))>m,
 Unf=DFun: \ (@ (a_abMv6 :: * -> * -> *))
             (v_X3y :: ArrowApply a_abMv6)
             (v1_X3A :: ArrowPlus a_abMv6) ->
       GHC.Base.C:MonadPlus TYPE: ArrowMonad a_abMv6
                            Control.Arrow.$fAlternativeArrowMonad @ a_abMv6 v1_X3A
                            Control.Arrow.$fMonadArrowMonad @ a_abMv6 v_X3y
                            (\ (@ a1_abMT8) ->
                               Control.Arrow.$fAlternativeArrowMonad3 @ a_abMv6 v1_X3A @ a1_abMT8)
                            `cast` (forall (a1 :: <*>_N).
                                    Sym (Control.Arrow.N:ArrowMonad[0] <a_abMv6>_R) <a1>_N
                                    :: (forall a1. a_abMv6 () a1 :: *)
                                       ~R# (forall a1. ArrowMonad a_abMv6 a1 :: *))
                            (\ (@ a1_abMTg)
                               (ds_XbNnB [Occ=Once] :: ArrowMonad a_abMv6 a1_abMTg)
                               (ds1_XbNnD [Occ=Once] :: ArrowMonad a_abMv6 a1_abMTg) ->
                               <+>
                                 @ a_abMv6
                                 v1_X3A
                                 @ ()
                                 @ a1_abMTg
                                 (ds_XbNnB
                                  `cast` (Control.Arrow.N:ArrowMonad[0] <a_abMv6>_R <a1_abMTg>_N
                                          :: (ArrowMonad a_abMv6 a1_abMTg :: *)
                                             ~R# (a_abMv6 () a1_abMTg :: *)))
                                 (ds1_XbNnD
                                  `cast` (Control.Arrow.N:ArrowMonad[0] <a_abMv6>_R <a1_abMTg>_N
                                          :: (ArrowMonad a_abMv6 a1_abMTg :: *)
                                             ~R# (a_abMv6 () a1_abMTg :: *))))
                            `cast` (forall (a1 :: <*>_N).
                                    <ArrowMonad a_abMv6 a1>_R
                                    ->_R <ArrowMonad a_abMv6 a1>_R
                                    ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_abMv6>_R) <a1>_N
                                    :: (forall a1.
                                        ArrowMonad a_abMv6 a1
                                        -> ArrowMonad a_abMv6 a1 -> a_abMv6 () a1 :: *)
                                       ~R# (forall a1.
                                            ArrowMonad a_abMv6 a1
                                            -> ArrowMonad a_abMv6 a1
                                            -> ArrowMonad a_abMv6 a1 :: *))]
Control.Arrow.$fMonadPlusArrowMonad
  = \ (@ (a_abMSU :: * -> * -> *))
      ($dArrowApply_abMSV :: ArrowApply a_abMSU)
      ($dArrowPlus_abMSW :: ArrowPlus a_abMSU) ->
      GHC.Base.C:MonadPlus
        @ (ArrowMonad a_abMSU)
        (Control.Arrow.$fAlternativeArrowMonad @ a_abMSU $dArrowPlus_abMSW)
        (Control.Arrow.$fMonadArrowMonad @ a_abMSU $dArrowApply_abMSV)
        ((\ (@ a1_abMT8) ->
            Control.Arrow.$fAlternativeArrowMonad3
              @ a_abMSU $dArrowPlus_abMSW @ a1_abMT8)
         `cast` (forall (a1 :: <*>_N).
                 Sym (Control.Arrow.N:ArrowMonad[0] <a_abMSU>_R) <a1>_N
                 :: (forall a1. a_abMSU () a1 :: *)
                    ~R# (forall a1. ArrowMonad a_abMSU a1 :: *)))
        ((\ (@ a1_abMTg)
            (ds_XbNnB :: ArrowMonad a_abMSU a1_abMTg)
            (ds1_XbNnD :: ArrowMonad a_abMSU a1_abMTg) ->
            <+>
              @ a_abMSU
              $dArrowPlus_abMSW
              @ ()
              @ a1_abMTg
              (ds_XbNnB
               `cast` (Control.Arrow.N:ArrowMonad[0] <a_abMSU>_R <a1_abMTg>_N
                       :: (ArrowMonad a_abMSU a1_abMTg :: *)
                          ~R# (a_abMSU () a1_abMTg :: *)))
              (ds1_XbNnD
               `cast` (Control.Arrow.N:ArrowMonad[0] <a_abMSU>_R <a1_abMTg>_N
                       :: (ArrowMonad a_abMSU a1_abMTg :: *)
                          ~R# (a_abMSU () a1_abMTg :: *))))
         `cast` (forall (a1 :: <*>_N).
                 <ArrowMonad a_abMSU a1>_R
                 ->_R <ArrowMonad a_abMSU a1>_R
                 ->_R Sym (Control.Arrow.N:ArrowMonad[0] <a_abMSU>_R) <a1>_N
                 :: (forall a1.
                     ArrowMonad a_abMSU a1
                     -> ArrowMonad a_abMSU a1 -> a_abMSU () a1 :: *)
                    ~R# (forall a1.
                         ArrowMonad a_abMSU a1
                         -> ArrowMonad a_abMSU a1 -> ArrowMonad a_abMSU a1 :: *)))

-- RHS size: {terms: 17, types: 28, coercions: 0, joins: 0/1}
Control.Arrow.$fArrowLoop(->)_$cloop
  :: forall b d c. ((b, d) -> (c, d)) -> b -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U(U,U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_abMSB)
                 (@ d_abMSC)
                 (@ c_abMSD)
                 (f_abMv2 [Occ=Once!] :: (b_abMSB, d_abMSC) -> (c_abMSD, d_abMSC))
                 (b1_abMv3 [Occ=Once] :: b_abMSB) ->
                 letrec {
                   ds_sbNsC [Occ=LoopBreaker] :: (c_abMSD, d_abMSC)
                   [LclId]
                   ds_sbNsC
                     = f_abMv2
                         (b1_abMv3,
                          case ds_sbNsC of { (_ [Occ=Dead], d1_XbMTA [Occ=Once]) ->
                          d1_XbMTA
                          }); } in
                 case ds_sbNsC of { (c1_abMSL [Occ=Once], _ [Occ=Dead]) ->
                 c1_abMSL
                 }}]
Control.Arrow.$fArrowLoop(->)_$cloop
  = \ (@ b_abMSB)
      (@ d_abMSC)
      (@ c_abMSD)
      (f_abMv2 :: (b_abMSB, d_abMSC) -> (c_abMSD, d_abMSC))
      (b1_abMv3 :: b_abMSB) ->
      letrec {
        ds_sbNsC [Occ=LoopBreaker] :: (c_abMSD, d_abMSC)
        [LclId]
        ds_sbNsC
          = f_abMv2
              (b1_abMv3,
               case ds_sbNsC of { (c1_abMSL, d1_XbMTA) -> d1_XbMTA }); } in
      case ds_sbNsC of { (c1_abMSL, d1_XbMTA) -> c1_abMSL }

-- RHS size: {terms: 27, types: 50, coercions: 8, joins: 0/1}
Control.Arrow.$fArrowLoopKleisli1
  :: forall (m :: * -> *).
     MonadFix m =>
     forall b d c. Kleisli m (b, d) (c, d) -> b -> m c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S))LLL)L),U(1*U(A,1*C1(C1(U)),A,C(U),A),1*C1(U))><L,C(U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60 0] 210 0}]
Control.Arrow.$fArrowLoopKleisli1
  = \ (@ (m_abMRq :: * -> *))
      ($dMonadFix_abMRr :: MonadFix m_abMRq)
      (@ b_abMRz)
      (@ d_abMRA)
      (@ c_abMRB)
      (eta_X3F :: Kleisli m_abMRq (b_abMRz, d_abMRA) (c_abMRB, d_abMRA))
      (eta1_X7j :: b_abMRz) ->
      let {
        $dMonad_sbNsA [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_abMRq
        [LclId]
        $dMonad_sbNsA
          = Control.Monad.Fix.$p1MonadFix @ m_abMRq $dMonadFix_abMRr } in
      >>=
        @ m_abMRq
        $dMonad_sbNsA
        @ (c_abMRB, d_abMRA)
        @ c_abMRB
        (mfix
           @ m_abMRq
           $dMonadFix_abMRr
           @ (c_abMRB, d_abMRA)
           (\ (y_abMv1 :: (c_abMRB, d_abMRA)) ->
              (eta_X3F
               `cast` (Control.Arrow.N:Kleisli[0]
                           <m_abMRq>_R <(b_abMRz, d_abMRA)>_R <(c_abMRB, d_abMRA)>_N
                       :: (Kleisli m_abMRq (b_abMRz, d_abMRA) (c_abMRB, d_abMRA) :: *)
                          ~R# ((b_abMRz, d_abMRA) -> m_abMRq (c_abMRB, d_abMRA) :: *)))
                (eta1_X7j, snd @ c_abMRB @ d_abMRA y_abMv1)))
        (\ (x1_i7S9R :: (c_abMRB, d_abMRA)) ->
           return
             @ m_abMRq
             $dMonad_sbNsA
             @ c_abMRB
             (case x1_i7S9R of { (x_i8S6A, ds1_i8S6B) -> x_i8S6A }))

-- RHS size: {terms: 8, types: 10, coercions: 0, joins: 0/0}
lvl1_rbNC7 :: forall d. Either d d -> d
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
lvl1_rbNC7
  = \ (@ d_abMQM) (ds_dbNjK :: Either d_abMQM d_abMQM) ->
      case ds_dbNjK of {
        Left x_abMuo -> x_abMuo;
        Right y_abMup -> y_abMup
      }

-- RHS size: {terms: 20, types: 45, coercions: 0, joins: 0/1}
Control.Arrow.$dm|||
  :: forall (a :: * -> * -> *).
     ArrowChoice a =>
     forall b d c. a b d -> a c d -> a (Either b c) d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)LLLL),U(1*U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A),A,A,1*C1(C1(U)),A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_abMu0 :: * -> * -> *))
                 ($dArrowChoice_abMP4 :: ArrowChoice a_abMu0) ->
                 let {
                   $dArrow_abNeP :: Arrow a_abMu0
                   [LclId]
                   $dArrow_abNeP
                     = Control.Arrow.$p1ArrowChoice @ a_abMu0 $dArrowChoice_abMP4 } in
                 \ (@ b_abMQL) (@ d_abMQM) (@ c_abMQN) ->
                   let {
                     $dCategory_abMRa [Occ=OnceL] :: Category a_abMu0
                     [LclId]
                     $dCategory_abMRa
                       = Control.Arrow.$p1Arrow @ a_abMu0 $dArrow_abNeP } in
                   \ (f_abMul [Occ=Once] :: a_abMu0 b_abMQL d_abMQM)
                     (g_abMum [Occ=Once] :: a_abMu0 c_abMQN d_abMQM) ->
                     . @ *
                       @ a_abMu0
                       $dCategory_abMRa
                       @ (Either d_abMQM d_abMQM)
                       @ d_abMQM
                       @ (Either b_abMQL c_abMQN)
                       (arr
                          @ a_abMu0
                          $dArrow_abNeP
                          @ (Either d_abMQM d_abMQM)
                          @ d_abMQM
                          (\ (ds_dbNjK [Occ=Once!] :: Either d_abMQM d_abMQM) ->
                             case ds_dbNjK of {
                               Left x_abMuo [Occ=Once] -> x_abMuo;
                               Right y_abMup [Occ=Once] -> y_abMup
                             }))
                       (+++
                          @ a_abMu0
                          $dArrowChoice_abMP4
                          @ b_abMQL
                          @ d_abMQM
                          @ c_abMQN
                          @ d_abMQM
                          f_abMul
                          g_abMum)}]
Control.Arrow.$dm|||
  = \ (@ (a_abMu0 :: * -> * -> *))
      ($dArrowChoice_abMP4 :: ArrowChoice a_abMu0)
      (@ b_abMQL)
      (@ d_abMQM)
      (@ c_abMQN)
      (eta_X3N :: a_abMu0 b_abMQL d_abMQM)
      (eta1_X7z :: a_abMu0 c_abMQN d_abMQM) ->
      let {
        $dArrow_sbNsy [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)>]
          :: Arrow a_abMu0
        [LclId]
        $dArrow_sbNsy
          = Control.Arrow.$p1ArrowChoice @ a_abMu0 $dArrowChoice_abMP4 } in
      . @ *
        @ a_abMu0
        (Control.Arrow.$p1Arrow @ a_abMu0 $dArrow_sbNsy)
        @ (Either d_abMQM d_abMQM)
        @ d_abMQM
        @ (Either b_abMQL c_abMQN)
        (arr
           @ a_abMu0
           $dArrow_sbNsy
           @ (Either d_abMQM d_abMQM)
           @ d_abMQM
           (lvl1_rbNC7 @ d_abMQM))
        (+++
           @ a_abMu0
           $dArrowChoice_abMP4
           @ b_abMQL
           @ d_abMQM
           @ c_abMQN
           @ d_abMQM
           eta_X3N
           eta1_X7z)

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
mirror_rbNC8 :: forall x y. Either x y -> Either y x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
mirror_rbNC8
  = \ (@ x_abMPX) (@ y_abMPY) (ds_dbNjz :: Either x_abMPX y_abMPY) ->
      case ds_dbNjz of {
        Left x1_abMuj -> Data.Either.Right @ y_abMPY @ x_abMPX x1_abMuj;
        Right y1_abMuk -> Data.Either.Left @ y_abMPY @ x_abMPX y1_abMuk
      }

-- RHS size: {terms: 32, types: 92, coercions: 0, joins: 0/2}
Control.Arrow.$dm+++
  :: forall (a :: * -> * -> *).
     ArrowChoice a =>
     forall b c b' c'. a b c -> a b' c' -> a (Either b b') (Either c c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)LLLL),U(1*U(1*U(A,C(C1(U))),C(U),A,A,A,A),C(U),A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_abMu0 :: * -> * -> *))
                 ($dArrowChoice_abMP4 :: ArrowChoice a_abMu0) ->
                 let {
                   $dArrow_abNeN :: Arrow a_abMu0
                   [LclId]
                   $dArrow_abNeN
                     = Control.Arrow.$p1ArrowChoice @ a_abMu0 $dArrowChoice_abMP4 } in
                 let {
                   $dCategory_abNeO :: Category a_abMu0
                   [LclId]
                   $dCategory_abNeO
                     = Control.Arrow.$p1Arrow @ a_abMu0 $dArrow_abNeN } in
                 \ (@ b_abMPE)
                   (@ c_abMPF)
                   (@ b'_abMPG)
                   (@ c'_abMPH)
                   (f_abMue [Occ=Once] :: a_abMu0 b_abMPE c_abMPF)
                   (g_abMuf [Occ=Once] :: a_abMu0 b'_abMPG c'_abMPH) ->
                   let {
                     mirror1_abMug :: forall x y. Either x y -> Either y x
                     [LclId, Arity=1, Unf=OtherCon []]
                     mirror1_abMug
                       = \ (@ x_abMPX)
                           (@ y_abMPY)
                           (ds_dbNjz [Occ=Once!] :: Either x_abMPX y_abMPY) ->
                           case ds_dbNjz of {
                             Left x1_abMuj [Occ=Once] ->
                               Data.Either.Right @ y_abMPY @ x_abMPX x1_abMuj;
                             Right y1_abMuk [Occ=Once] ->
                               Data.Either.Left @ y_abMPY @ x_abMPX y1_abMuk
                           } } in
                   . @ *
                     @ a_abMu0
                     $dCategory_abNeO
                     @ (Either c'_abMPH c_abMPF)
                     @ (Either c_abMPF c'_abMPH)
                     @ (Either b_abMPE b'_abMPG)
                     (arr
                        @ a_abMu0
                        $dArrow_abNeN
                        @ (Either c'_abMPH c_abMPF)
                        @ (Either c_abMPF c'_abMPH)
                        (mirror1_abMug @ c'_abMPH @ c_abMPF))
                     (. @ *
                        @ a_abMu0
                        $dCategory_abNeO
                        @ (Either b'_abMPG c_abMPF)
                        @ (Either c'_abMPH c_abMPF)
                        @ (Either b_abMPE b'_abMPG)
                        (left
                           @ a_abMu0
                           $dArrowChoice_abMP4
                           @ b'_abMPG
                           @ c'_abMPH
                           @ c_abMPF
                           g_abMuf)
                        (. @ *
                           @ a_abMu0
                           $dCategory_abNeO
                           @ (Either c_abMPF b'_abMPG)
                           @ (Either b'_abMPG c_abMPF)
                           @ (Either b_abMPE b'_abMPG)
                           (arr
                              @ a_abMu0
                              $dArrow_abNeN
                              @ (Either c_abMPF b'_abMPG)
                              @ (Either b'_abMPG c_abMPF)
                              (mirror1_abMug @ c_abMPF @ b'_abMPG))
                           (left
                              @ a_abMu0
                              $dArrowChoice_abMP4
                              @ b_abMPE
                              @ c_abMPF
                              @ b'_abMPG
                              f_abMue)))}]
Control.Arrow.$dm+++
  = \ (@ (a_abMu0 :: * -> * -> *))
      ($dArrowChoice_abMP4 :: ArrowChoice a_abMu0)
      (@ b_abMPE)
      (@ c_abMPF)
      (@ b'_abMPG)
      (@ c'_abMPH)
      (eta_X3P :: a_abMu0 b_abMPE c_abMPF)
      (eta1_X7D :: a_abMu0 b'_abMPG c'_abMPH) ->
      let {
        $dArrow_sbNsw [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),C(U),A,A,A,A)>]
          :: Arrow a_abMu0
        [LclId]
        $dArrow_sbNsw
          = Control.Arrow.$p1ArrowChoice @ a_abMu0 $dArrowChoice_abMP4 } in
      let {
        $dCategory_sbNsv [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
          :: Category a_abMu0
        [LclId]
        $dCategory_sbNsv
          = Control.Arrow.$p1Arrow @ a_abMu0 $dArrow_sbNsw } in
      . @ *
        @ a_abMu0
        $dCategory_sbNsv
        @ (Either c'_abMPH c_abMPF)
        @ (Either c_abMPF c'_abMPH)
        @ (Either b_abMPE b'_abMPG)
        (arr
           @ a_abMu0
           $dArrow_sbNsw
           @ (Either c'_abMPH c_abMPF)
           @ (Either c_abMPF c'_abMPH)
           (mirror_rbNC8 @ c'_abMPH @ c_abMPF))
        (. @ *
           @ a_abMu0
           $dCategory_sbNsv
           @ (Either b'_abMPG c_abMPF)
           @ (Either c'_abMPH c_abMPF)
           @ (Either b_abMPE b'_abMPG)
           (left
              @ a_abMu0
              $dArrowChoice_abMP4
              @ b'_abMPG
              @ c'_abMPH
              @ c_abMPF
              eta1_X7D)
           (. @ *
              @ a_abMu0
              $dCategory_sbNsv
              @ (Either c_abMPF b'_abMPG)
              @ (Either b'_abMPG c_abMPF)
              @ (Either b_abMPE b'_abMPG)
              (arr
                 @ a_abMu0
                 $dArrow_sbNsw
                 @ (Either c_abMPF b'_abMPG)
                 @ (Either b'_abMPG c_abMPF)
                 (mirror_rbNC8 @ c_abMPF @ b'_abMPG))
              (left
                 @ a_abMu0
                 $dArrowChoice_abMP4
                 @ b_abMPE
                 @ c_abMPF
                 @ b'_abMPG
                 eta_X3P)))

-- RHS size: {terms: 11, types: 25, coercions: 0, joins: 0/0}
Control.Arrow.$dmright
  :: forall (a :: * -> * -> *).
     ArrowChoice a =>
     forall b c d. a b c -> a (Either d b) (Either d c)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),U(1*U(1*U(1*U,A),A,A,A,A,A),A,A,1*C1(U),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_abMu0 :: * -> * -> *))
                 ($dArrowChoice_abMP4 :: ArrowChoice a_abMu0)
                 (@ b_abMPn)
                 (@ c_abMPo)
                 (@ d_abMPp) ->
                 +++
                   @ a_abMu0
                   $dArrowChoice_abMP4
                   @ d_abMPp
                   @ d_abMPp
                   @ b_abMPn
                   @ c_abMPo
                   (id
                      @ *
                      @ a_abMu0
                      (Control.Arrow.$p1Arrow
                         @ a_abMu0
                         (Control.Arrow.$p1ArrowChoice @ a_abMu0 $dArrowChoice_abMP4))
                      @ d_abMPp)}]
Control.Arrow.$dmright
  = \ (@ (a_abMu0 :: * -> * -> *))
      ($dArrowChoice_abMP4 :: ArrowChoice a_abMu0)
      (@ b_abMPn)
      (@ c_abMPo)
      (@ d_abMPp) ->
      +++
        @ a_abMu0
        $dArrowChoice_abMP4
        @ d_abMPp
        @ d_abMPp
        @ b_abMPn
        @ c_abMPo
        (id
           @ *
           @ a_abMu0
           (Control.Arrow.$p1Arrow
              @ a_abMu0
              (Control.Arrow.$p1ArrowChoice @ a_abMu0 $dArrowChoice_abMP4))
           @ d_abMPp)

-- RHS size: {terms: 13, types: 28, coercions: 0, joins: 0/0}
Control.Arrow.$dmleft
  :: forall (a :: * -> * -> *).
     ArrowChoice a =>
     forall b c d. a b c -> a (Either b d) (Either c d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))L),U(1*U(1*U(1*U,A),A,A,A,A,A),A,A,1*C1(C1(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_abMu0 :: * -> * -> *))
                 ($dArrowChoice_abMP4 :: ArrowChoice a_abMu0)
                 (@ b_abMP6)
                 (@ c_abMP7)
                 (@ d_abMP8) ->
                 let {
                   $dCategory_sbNpb [Occ=OnceL] :: Arrow a_abMu0
                   [LclId]
                   $dCategory_sbNpb
                     = Control.Arrow.$p1ArrowChoice @ a_abMu0 $dArrowChoice_abMP4 } in
                 let {
                   $dCategory1_abMPi [Occ=OnceL] :: Category a_abMu0
                   [LclId]
                   $dCategory1_abMPi
                     = Control.Arrow.$p1Arrow @ a_abMu0 $dCategory_sbNpb } in
                 let {
                   ds_dbNjp [Occ=OnceL] :: a_abMu0 d_abMP8 d_abMP8
                   [LclId]
                   ds_dbNjp = id @ * @ a_abMu0 $dCategory1_abMPi @ d_abMP8 } in
                 \ (ds1_dbNjo [Occ=Once] :: a_abMu0 b_abMP6 c_abMP7) ->
                   +++
                     @ a_abMu0
                     $dArrowChoice_abMP4
                     @ b_abMP6
                     @ c_abMP7
                     @ d_abMP8
                     @ d_abMP8
                     ds1_dbNjo
                     ds_dbNjp}]
Control.Arrow.$dmleft
  = \ (@ (a_abMu0 :: * -> * -> *))
      ($dArrowChoice_abMP4 :: ArrowChoice a_abMu0)
      (@ b_abMP6)
      (@ c_abMP7)
      (@ d_abMP8)
      (eta_X3P :: a_abMu0 b_abMP6 c_abMP7) ->
      +++
        @ a_abMu0
        $dArrowChoice_abMP4
        @ b_abMP6
        @ c_abMP7
        @ d_abMP8
        @ d_abMP8
        eta_X3P
        (id
           @ *
           @ a_abMu0
           (Control.Arrow.$p1Arrow
              @ a_abMu0
              (Control.Arrow.$p1ArrowChoice @ a_abMu0 $dArrowChoice_abMP4))
           @ d_abMP8)

-- RHS size: {terms: 5, types: 5, coercions: 0, joins: 0/0}
lvl2_rbNC9 :: forall b. b -> (b, b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []]
lvl2_rbNC9
  = \ (@ b_abMOE) (b1_abMuW :: b_abMOE) -> (b1_abMuW, b1_abMuW)

-- RHS size: {terms: 17, types: 42, coercions: 0, joins: 0/0}
Control.Arrow.$dm&&&
  :: forall (a :: * -> * -> *).
     Arrow a =>
     forall b c c'. a b c -> a b c' -> a b (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,1*C1(C1(U)),A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_abMuz :: * -> * -> *))
                 ($dArrow_abMMY :: Arrow a_abMuz)
                 (@ b_abMOE)
                 (@ c_abMOF)
                 (@ c'_abMOG) ->
                 let {
                   $dCategory_abMON [Occ=OnceL] :: Category a_abMuz
                   [LclId]
                   $dCategory_abMON
                     = Control.Arrow.$p1Arrow @ a_abMuz $dArrow_abMMY } in
                 \ (f_abMuU [Occ=Once] :: a_abMuz b_abMOE c_abMOF)
                   (g_abMuV [Occ=Once] :: a_abMuz b_abMOE c'_abMOG) ->
                   . @ *
                     @ a_abMuz
                     $dCategory_abMON
                     @ (b_abMOE, b_abMOE)
                     @ (c_abMOF, c'_abMOG)
                     @ b_abMOE
                     (***
                        @ a_abMuz
                        $dArrow_abMMY
                        @ b_abMOE
                        @ c_abMOF
                        @ b_abMOE
                        @ c'_abMOG
                        f_abMuU
                        g_abMuV)
                     (arr
                        @ a_abMuz
                        $dArrow_abMMY
                        @ b_abMOE
                        @ (b_abMOE, b_abMOE)
                        (\ (b1_abMuW :: b_abMOE) -> (b1_abMuW, b1_abMuW)))}]
Control.Arrow.$dm&&&
  = \ (@ (a_abMuz :: * -> * -> *))
      ($dArrow_abMMY :: Arrow a_abMuz)
      (@ b_abMOE)
      (@ c_abMOF)
      (@ c'_abMOG)
      (eta_X3R :: a_abMuz b_abMOE c_abMOF)
      (eta1_X7H :: a_abMuz b_abMOE c'_abMOG) ->
      . @ *
        @ a_abMuz
        (Control.Arrow.$p1Arrow @ a_abMuz $dArrow_abMMY)
        @ (b_abMOE, b_abMOE)
        @ (c_abMOF, c'_abMOG)
        @ b_abMOE
        (***
           @ a_abMuz
           $dArrow_abMMY
           @ b_abMOE
           @ c_abMOF
           @ b_abMOE
           @ c'_abMOG
           eta_X3R
           eta1_X7H)
        (arr
           @ a_abMuz
           $dArrow_abMMY
           @ b_abMOE
           @ (b_abMOE, b_abMOE)
           (lvl2_rbNC9 @ b_abMOE))

-- RHS size: {terms: 12, types: 19, coercions: 0, joins: 0/0}
swap_rbNCa :: forall b a. (b, a) -> (a, b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []]
swap_rbNCa
  = \ (@ b_abMNN) (@ a_abMNM) (ds_dbNj5 :: (b_abMNN, a_abMNM)) ->
      (case ds_dbNj5 of { (x_abMuS, y_abMuT) -> y_abMuT },
       case ds_dbNj5 of { (x_abMuS, y_abMuT) -> x_abMuS })

-- RHS size: {terms: 29, types: 89, coercions: 0, joins: 0/1}
Control.Arrow.$dm***
  :: forall (a :: * -> * -> *).
     Arrow a =>
     forall b c b' c'. a b c -> a b' c' -> a (b, b') (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),C(U),C(U),A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_abMuz :: * -> * -> *))
                 ($dArrow_abMMY :: Arrow a_abMuz) ->
                 let {
                   $dCategory_abNeH :: Category a_abMuz
                   [LclId]
                   $dCategory_abNeH
                     = Control.Arrow.$p1Arrow @ a_abMuz $dArrow_abMMY } in
                 \ (@ b_abMNy)
                   (@ c_abMNz)
                   (@ b'_abMNA)
                   (@ c'_abMNB)
                   (f_abMuP [Occ=Once] :: a_abMuz b_abMNy c_abMNz)
                   (g_abMuQ [Occ=Once] :: a_abMuz b'_abMNA c'_abMNB) ->
                   let {
                     swap1_abMuR :: forall b1 a1. (b1, a1) -> (a1, b1)
                     [LclId, Arity=1, Unf=OtherCon []]
                     swap1_abMuR
                       = \ (@ b1_abMNN) (@ a1_abMNM) (ds_dbNj5 :: (b1_abMNN, a1_abMNM)) ->
                           (case ds_dbNj5 of { (_ [Occ=Dead], y_abMuT [Occ=Once]) ->
                            y_abMuT
                            },
                            case ds_dbNj5 of { (x_abMuS [Occ=Once], _ [Occ=Dead]) ->
                            x_abMuS
                            }) } in
                   . @ *
                     @ a_abMuz
                     $dCategory_abNeH
                     @ (c'_abMNB, c_abMNz)
                     @ (c_abMNz, c'_abMNB)
                     @ (b_abMNy, b'_abMNA)
                     (arr
                        @ a_abMuz
                        $dArrow_abMMY
                        @ (c'_abMNB, c_abMNz)
                        @ (c_abMNz, c'_abMNB)
                        (swap1_abMuR @ c'_abMNB @ c_abMNz))
                     (. @ *
                        @ a_abMuz
                        $dCategory_abNeH
                        @ (b'_abMNA, c_abMNz)
                        @ (c'_abMNB, c_abMNz)
                        @ (b_abMNy, b'_abMNA)
                        (first
                           @ a_abMuz $dArrow_abMMY @ b'_abMNA @ c'_abMNB @ c_abMNz g_abMuQ)
                        (. @ *
                           @ a_abMuz
                           $dCategory_abNeH
                           @ (c_abMNz, b'_abMNA)
                           @ (b'_abMNA, c_abMNz)
                           @ (b_abMNy, b'_abMNA)
                           (arr
                              @ a_abMuz
                              $dArrow_abMMY
                              @ (c_abMNz, b'_abMNA)
                              @ (b'_abMNA, c_abMNz)
                              (swap1_abMuR @ c_abMNz @ b'_abMNA))
                           (first
                              @ a_abMuz $dArrow_abMMY @ b_abMNy @ c_abMNz @ b'_abMNA f_abMuP)))}]
Control.Arrow.$dm***
  = \ (@ (a_abMuz :: * -> * -> *))
      ($dArrow_abMMY :: Arrow a_abMuz)
      (@ b_abMNy)
      (@ c_abMNz)
      (@ b'_abMNA)
      (@ c'_abMNB)
      (eta_X3T :: a_abMuz b_abMNy c_abMNz)
      (eta1_X7L :: a_abMuz b'_abMNA c'_abMNB) ->
      let {
        $dCategory_sbNsq [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
          :: Category a_abMuz
        [LclId]
        $dCategory_sbNsq
          = Control.Arrow.$p1Arrow @ a_abMuz $dArrow_abMMY } in
      . @ *
        @ a_abMuz
        $dCategory_sbNsq
        @ (c'_abMNB, c_abMNz)
        @ (c_abMNz, c'_abMNB)
        @ (b_abMNy, b'_abMNA)
        (arr
           @ a_abMuz
           $dArrow_abMMY
           @ (c'_abMNB, c_abMNz)
           @ (c_abMNz, c'_abMNB)
           (swap_rbNCa @ c'_abMNB @ c_abMNz))
        (. @ *
           @ a_abMuz
           $dCategory_sbNsq
           @ (b'_abMNA, c_abMNz)
           @ (c'_abMNB, c_abMNz)
           @ (b_abMNy, b'_abMNA)
           (first
              @ a_abMuz $dArrow_abMMY @ b'_abMNA @ c'_abMNB @ c_abMNz eta1_X7L)
           (. @ *
              @ a_abMuz
              $dCategory_sbNsq
              @ (c_abMNz, b'_abMNA)
              @ (b'_abMNA, c_abMNz)
              @ (b_abMNy, b'_abMNA)
              (arr
                 @ a_abMuz
                 $dArrow_abMMY
                 @ (c_abMNz, b'_abMNA)
                 @ (b'_abMNA, c_abMNz)
                 (swap_rbNCa @ c_abMNz @ b'_abMNA))
              (first
                 @ a_abMuz $dArrow_abMMY @ b_abMNy @ c_abMNz @ b'_abMNA eta_X3T)))

-- RHS size: {terms: 46, types: 92, coercions: 0, joins: 0/0}
Control.Arrow.$fArrowKleisli2
  :: forall (m :: * -> *).
     Monad m =>
     forall b c b' c'.
     Kleisli m b c -> Kleisli m b' c' -> (b, b') -> m (c, c')
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(U)><L,C(U)><L,U(U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [150 0 0 0] 330 0}]
Control.Arrow.$fArrowKleisli2
  = \ (@ (m_XbN5E :: * -> *))
      ($dMonad_XbN5G :: Monad m_XbN5E)
      (@ b_abN3a)
      (@ c_abN3b)
      (@ b'_abN3c)
      (@ c'_abN3d)
      (f_abMuP :: Kleisli m_XbN5E b_abN3a c_abN3b)
      (g_abMuQ :: Kleisli m_XbN5E b'_abN3c c'_abN3d)
      (eta_X3V :: (b_abN3a, b'_abN3c)) ->
      >>=
        @ m_XbN5E
        $dMonad_XbN5G
        @ (c'_abN3d, c_abN3b)
        @ (c_abN3b, c'_abN3d)
        (>>=
           @ m_XbN5E
           $dMonad_XbN5G
           @ (b'_abN3c, c_abN3b)
           @ (c'_abN3d, c_abN3b)
           (>>=
              @ m_XbN5E
              $dMonad_XbN5G
              @ (c_abN3b, b'_abN3c)
              @ (b'_abN3c, c_abN3b)
              (Control.Arrow.$fArrowKleisli3
                 @ m_XbN5E
                 $dMonad_XbN5G
                 @ b_abN3a
                 @ c_abN3b
                 @ b'_abN3c
                 f_abMuP
                 eta_X3V)
              (\ (eta1_X40 :: (c_abN3b, b'_abN3c)) ->
                 return
                   @ m_XbN5E
                   $dMonad_XbN5G
                   @ (b'_abN3c, c_abN3b)
                   (case eta1_X40 of { (x_abMuS, y_abMuT) -> y_abMuT },
                    case eta1_X40 of { (x_abMuS, y_abMuT) -> x_abMuS })))
           (Control.Arrow.$fArrowKleisli3
              @ m_XbN5E $dMonad_XbN5G @ b'_abN3c @ c'_abN3d @ c_abN3b g_abMuQ))
        (\ (eta1_X3W :: (c'_abN3d, c_abN3b)) ->
           return
             @ m_XbN5E
             $dMonad_XbN5G
             @ (c_abN3b, c'_abN3d)
             (case eta1_X3W of { (x_abMuS, y_abMuT) -> y_abMuT },
              case eta1_X3W of { (x_abMuS, y_abMuT) -> x_abMuS }))

-- RHS size: {terms: 19, types: 39, coercions: 0, joins: 0/0}
Control.Arrow.$fArrowKleisli1
  :: forall (m :: * -> *).
     Monad m =>
     forall b c c'. Kleisli m b c -> Kleisli m b c' -> b -> m (c, c')
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(U)><L,C(U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0 0] 120 0}]
Control.Arrow.$fArrowKleisli1
  = \ (@ (m_XbN5D :: * -> *))
      ($dMonad_XbN5F :: Monad m_XbN5D)
      (@ b_abN3o)
      (@ c_abN3p)
      (@ c'_abN3q)
      (f_abMuU :: Kleisli m_XbN5D b_abN3o c_abN3p)
      (g_abMuV :: Kleisli m_XbN5D b_abN3o c'_abN3q)
      (eta_B1 :: b_abN3o) ->
      >>=
        @ m_XbN5D
        $dMonad_XbN5F
        @ (b_abN3o, b_abN3o)
        @ (c_abN3p, c'_abN3q)
        (return
           @ m_XbN5D $dMonad_XbN5F @ (b_abN3o, b_abN3o) (eta_B1, eta_B1))
        (Control.Arrow.$fArrowKleisli2
           @ m_XbN5D
           $dMonad_XbN5F
           @ b_abN3o
           @ c_abN3p
           @ b_abN3o
           @ c'_abN3q
           f_abMuU
           g_abMuV)

-- RHS size: {terms: 15, types: 14, coercions: 117, joins: 0/0}
Control.Arrow.$fArrowKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *). Monad m => Arrow (Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,U,A)>m,
 Unf=DFun: \ (@ (m_abMvH :: * -> *)) (v_X3Z :: Monad m_abMvH) ->
       Control.Arrow.C:Arrow TYPE: Kleisli m_abMvH
                             Control.Arrow.$fCategoryTYPEKleisli @ m_abMvH v_X3Z
                             (Control.Arrow.$fArrowKleisli5 @ m_abMvH v_X3Z)
                             `cast` (forall (b :: <*>_N) (c :: <*>_N).
                                     <b -> c>_R
                                     ->_R Sym (Control.Arrow.N:Kleisli[0] <m_abMvH>_R <b>_R <c>_N)
                                     :: (forall b c. (b -> c) -> b -> m_abMvH c :: *)
                                        ~R# (forall b c. (b -> c) -> Kleisli m_abMvH b c :: *))
                             (Control.Arrow.$fArrowKleisli3 @ m_abMvH v_X3Z)
                             `cast` (forall (b :: <*>_N) (c :: <*>_N) (d :: <*>_N).
                                     <Kleisli m_abMvH b c>_R
                                     ->_R Sym (Control.Arrow.N:Kleisli[0]
                                                   <m_abMvH>_R <(b, d)>_R <(c, d)>_N)
                                     :: (forall b c d.
                                         Kleisli m_abMvH b c -> (b, d) -> m_abMvH (c, d) :: *)
                                        ~R# (forall b c d.
                                             Kleisli m_abMvH b c
                                             -> Kleisli m_abMvH (b, d) (c, d) :: *))
                             (Control.Arrow.$fArrowKleisli4 @ m_abMvH v_X3Z)
                             `cast` (forall (b :: <*>_N) (c :: <*>_N) (d :: <*>_N).
                                     <Kleisli m_abMvH b c>_R
                                     ->_R Sym (Control.Arrow.N:Kleisli[0]
                                                   <m_abMvH>_R <(d, b)>_R <(d, c)>_N)
                                     :: (forall b c d.
                                         Kleisli m_abMvH b c -> (d, b) -> m_abMvH (d, c) :: *)
                                        ~R# (forall b c d.
                                             Kleisli m_abMvH b c
                                             -> Kleisli m_abMvH (d, b) (d, c) :: *))
                             (Control.Arrow.$fArrowKleisli2 @ m_abMvH v_X3Z)
                             `cast` (forall (b :: <*>_N) (c :: <*>_N) (b' :: <*>_N) (c' :: <*>_N).
                                     <Kleisli m_abMvH b c>_R
                                     ->_R <Kleisli m_abMvH b' c'>_R
                                     ->_R Sym (Control.Arrow.N:Kleisli[0]
                                                   <m_abMvH>_R <(b, b')>_R <(c, c')>_N)
                                     :: (forall b c b' c'.
                                         Kleisli m_abMvH b c
                                         -> Kleisli m_abMvH b' c'
                                         -> (b, b')
                                         -> m_abMvH (c, c') :: *)
                                        ~R# (forall b c b' c'.
                                             Kleisli m_abMvH b c
                                             -> Kleisli m_abMvH b' c'
                                             -> Kleisli m_abMvH (b, b') (c, c') :: *))
                             (Control.Arrow.$fArrowKleisli1 @ m_abMvH v_X3Z)
                             `cast` (forall (b :: <*>_N) (c :: <*>_N) (c' :: <*>_N).
                                     <Kleisli m_abMvH b c>_R
                                     ->_R <Kleisli m_abMvH b c'>_R
                                     ->_R Sym (Control.Arrow.N:Kleisli[0]
                                                   <m_abMvH>_R <b>_R <(c, c')>_N)
                                     :: (forall b c c'.
                                         Kleisli m_abMvH b c
                                         -> Kleisli m_abMvH b c' -> b -> m_abMvH (c, c') :: *)
                                        ~R# (forall b c c'.
                                             Kleisli m_abMvH b c
                                             -> Kleisli m_abMvH b c'
                                             -> Kleisli m_abMvH b (c, c') :: *))]
Control.Arrow.$fArrowKleisli
  = \ (@ (m_XbN5C :: * -> *)) ($dMonad_XbN9C :: Monad m_XbN5C) ->
      Control.Arrow.C:Arrow
        @ (Kleisli m_XbN5C)
        (Control.Arrow.$fCategoryTYPEKleisli @ m_XbN5C $dMonad_XbN9C)
        ((Control.Arrow.$fArrowKleisli5 @ m_XbN5C $dMonad_XbN9C)
         `cast` (forall (b :: <*>_N) (c :: <*>_N).
                 <b -> c>_R
                 ->_R Sym (Control.Arrow.N:Kleisli[0] <m_XbN5C>_R <b>_R <c>_N)
                 :: (forall b c. (b -> c) -> b -> m_XbN5C c :: *)
                    ~R# (forall b c. (b -> c) -> Kleisli m_XbN5C b c :: *)))
        ((Control.Arrow.$fArrowKleisli3 @ m_XbN5C $dMonad_XbN9C)
         `cast` (forall (b :: <*>_N) (c :: <*>_N) (d :: <*>_N).
                 <Kleisli m_XbN5C b c>_R
                 ->_R Sym (Control.Arrow.N:Kleisli[0]
                               <m_XbN5C>_R <(b, d)>_R <(c, d)>_N)
                 :: (forall b c d.
                     Kleisli m_XbN5C b c -> (b, d) -> m_XbN5C (c, d) :: *)
                    ~R# (forall b c d.
                         Kleisli m_XbN5C b c -> Kleisli m_XbN5C (b, d) (c, d) :: *)))
        ((Control.Arrow.$fArrowKleisli4 @ m_XbN5C $dMonad_XbN9C)
         `cast` (forall (b :: <*>_N) (c :: <*>_N) (d :: <*>_N).
                 <Kleisli m_XbN5C b c>_R
                 ->_R Sym (Control.Arrow.N:Kleisli[0]
                               <m_XbN5C>_R <(d, b)>_R <(d, c)>_N)
                 :: (forall b c d.
                     Kleisli m_XbN5C b c -> (d, b) -> m_XbN5C (d, c) :: *)
                    ~R# (forall b c d.
                         Kleisli m_XbN5C b c -> Kleisli m_XbN5C (d, b) (d, c) :: *)))
        ((Control.Arrow.$fArrowKleisli2 @ m_XbN5C $dMonad_XbN9C)
         `cast` (forall (b :: <*>_N) (c :: <*>_N) (b' :: <*>_N) (c' :: <*>_N).
                 <Kleisli m_XbN5C b c>_R
                 ->_R <Kleisli m_XbN5C b' c'>_R
                 ->_R Sym (Control.Arrow.N:Kleisli[0]
                               <m_XbN5C>_R <(b, b')>_R <(c, c')>_N)
                 :: (forall b c b' c'.
                     Kleisli m_XbN5C b c
                     -> Kleisli m_XbN5C b' c' -> (b, b') -> m_XbN5C (c, c') :: *)
                    ~R# (forall b c b' c'.
                         Kleisli m_XbN5C b c
                         -> Kleisli m_XbN5C b' c' -> Kleisli m_XbN5C (b, b') (c, c') :: *)))
        ((Control.Arrow.$fArrowKleisli1 @ m_XbN5C $dMonad_XbN9C)
         `cast` (forall (b :: <*>_N) (c :: <*>_N) (c' :: <*>_N).
                 <Kleisli m_XbN5C b c>_R
                 ->_R <Kleisli m_XbN5C b c'>_R
                 ->_R Sym (Control.Arrow.N:Kleisli[0] <m_XbN5C>_R <b>_R <(c, c')>_N)
                 :: (forall b c c'.
                     Kleisli m_XbN5C b c
                     -> Kleisli m_XbN5C b c' -> b -> m_XbN5C (c, c') :: *)
                    ~R# (forall b c c'.
                         Kleisli m_XbN5C b c
                         -> Kleisli m_XbN5C b c' -> Kleisli m_XbN5C b (c, c') :: *)))

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop
  :: forall (m :: * -> *). MonadFix m => Arrow (Kleisli m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,U,A),A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_XbMVo :: * -> *))
                 ($dMonadFix_XbMVq [Occ=Once] :: MonadFix m_XbMVo) ->
                 Control.Arrow.$fArrowKleisli
                   @ m_XbMVo
                   (Control.Monad.Fix.$p1MonadFix @ m_XbMVo $dMonadFix_XbMVq)}]
Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop
  = \ (@ (m_XbMVo :: * -> *))
      ($dMonadFix_XbMVq :: MonadFix m_XbMVo) ->
      Control.Arrow.$fArrowKleisli
        @ m_XbMVo
        (Control.Monad.Fix.$p1MonadFix @ m_XbMVo $dMonadFix_XbMVq)

-- RHS size: {terms: 7, types: 10, coercions: 23, joins: 0/0}
Control.Arrow.$fArrowLoopKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *). MonadFix m => ArrowLoop (Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U)),A,U,A),C(U))>m,
 Unf=DFun: \ (@ (m_abMuX :: * -> *)) (v_X41 :: MonadFix m_abMuX) ->
       Control.Arrow.C:ArrowLoop TYPE: Kleisli m_abMuX
                                 Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop @ m_abMuX v_X41
                                 (Control.Arrow.$fArrowLoopKleisli1 @ m_abMuX v_X41)
                                 `cast` (forall (b :: <*>_N) (d :: <*>_N) (c :: <*>_N).
                                         <Kleisli m_abMuX (b, d) (c, d)>_R
                                         ->_R Sym (Control.Arrow.N:Kleisli[0]
                                                       <m_abMuX>_R <b>_R <c>_N)
                                         :: (forall b d c.
                                             Kleisli m_abMuX (b, d) (c, d) -> b -> m_abMuX c :: *)
                                            ~R# (forall b d c.
                                                 Kleisli m_abMuX (b, d) (c, d)
                                                 -> Kleisli m_abMuX b c :: *))]
Control.Arrow.$fArrowLoopKleisli
  = \ (@ (m_XbMVp :: * -> *))
      ($dMonadFix_XbMVr :: MonadFix m_XbMVp) ->
      Control.Arrow.C:ArrowLoop
        @ (Kleisli m_XbMVp)
        (Control.Arrow.$fArrowLoopKleisli_$cp1ArrowLoop
           @ m_XbMVp $dMonadFix_XbMVr)
        ((Control.Arrow.$fArrowLoopKleisli1 @ m_XbMVp $dMonadFix_XbMVr)
         `cast` (forall (b :: <*>_N) (d :: <*>_N) (c :: <*>_N).
                 <Kleisli m_XbMVp (b, d) (c, d)>_R
                 ->_R Sym (Control.Arrow.N:Kleisli[0] <m_XbMVp>_R <b>_R <c>_N)
                 :: (forall b d c.
                     Kleisli m_XbMVp (b, d) (c, d) -> b -> m_XbMVp c :: *)
                    ~R# (forall b d c.
                         Kleisli m_XbMVp (b, d) (c, d) -> Kleisli m_XbMVp b c :: *)))

-- RHS size: {terms: 9, types: 25, coercions: 4, joins: 0/0}
lvl3_rbNCb :: forall (m :: * -> *) b c. (Kleisli m b c, b) -> m c
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),U)>,
 Unf=OtherCon []]
lvl3_rbNCb
  = \ (@ (m_XbN1f :: * -> *))
      (@ b_XbN5s)
      (@ c_XbN1s)
      (ds_dbNlm :: (Kleisli m_XbN1f b_XbN5s c_XbN1s, b_XbN5s)) ->
      case ds_dbNlm of { (ds1_dbNlv, x_abMvo) ->
      (ds1_dbNlv
       `cast` (Control.Arrow.N:Kleisli[0]
                   <m_XbN1f>_R <b_XbN5s>_R <c_XbN1s>_N
               :: (Kleisli m_XbN1f b_XbN5s c_XbN1s :: *)
                  ~R# (b_XbN5s -> m_XbN1f c_XbN1s :: *)))
        x_abMvo
      }

-- RHS size: {terms: 6, types: 10, coercions: 16, joins: 0/0}
Control.Arrow.$fArrowApplyKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *). Monad m => ArrowApply (Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,U,A)>m,
 Unf=DFun: \ (@ (m_abMvm :: * -> *)) (v_X42 :: Monad m_abMvm) ->
       Control.Arrow.C:ArrowApply TYPE: Kleisli m_abMvm
                                  Control.Arrow.$fArrowKleisli @ m_abMvm v_X42
                                  (\ (@ b_XbN5s)
                                     (@ c_XbN1s)
                                     (ds_dbNlm [Occ=Once!]
                                        :: (Kleisli m_abMvm b_XbN5s c_XbN1s, b_XbN5s)) ->
                                     case ds_dbNlm of
                                     { (ds1_dbNlv [Occ=Once], x_abMvo [Occ=Once]) ->
                                     (ds1_dbNlv
                                      `cast` (Control.Arrow.N:Kleisli[0]
                                                  <m_abMvm>_R <b_XbN5s>_R <c_XbN1s>_N
                                              :: (Kleisli m_abMvm b_XbN5s c_XbN1s :: *)
                                                 ~R# (b_XbN5s -> m_abMvm c_XbN1s :: *)))
                                       x_abMvo
                                     })
                                  `cast` (forall (b :: <*>_N) (c :: <*>_N).
                                          Sym (Control.Arrow.N:Kleisli[0]
                                                   <m_abMvm>_R <(Kleisli m_abMvm b c, b)>_R <c>_N)
                                          :: (forall b c.
                                              (Kleisli m_abMvm b c, b) -> m_abMvm c :: *)
                                             ~R# (forall b c.
                                                  Kleisli m_abMvm (Kleisli m_abMvm b c, b) c :: *))]
Control.Arrow.$fArrowApplyKleisli
  = \ (@ (m_XbN1f :: * -> *)) ($dMonad_XbN1h :: Monad m_XbN1f) ->
      Control.Arrow.C:ArrowApply
        @ (Kleisli m_XbN1f)
        (Control.Arrow.$fArrowKleisli @ m_XbN1f $dMonad_XbN1h)
        ((lvl3_rbNCb @ m_XbN1f)
         `cast` (forall (b :: <*>_N) (c :: <*>_N).
                 Sym (Control.Arrow.N:Kleisli[0]
                          <m_XbN1f>_R <(Kleisli m_XbN1f b c, b)>_R <c>_N)
                 :: (forall b c. (Kleisli m_XbN1f b c, b) -> m_XbN1f c :: *)
                    ~R# (forall b c. Kleisli m_XbN1f (Kleisli m_XbN1f b c, b) c :: *)))

-- RHS size: {terms: 31, types: 54, coercions: 8, joins: 0/0}
Control.Arrow.$fArrowChoiceKleisli1
  :: forall (m :: * -> *).
     Monad m =>
     forall b c b' c'.
     Kleisli m b c -> Kleisli m b' c' -> Either b b' -> m (Either c c')
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [120 60 60 140] 240 0}]
Control.Arrow.$fArrowChoiceKleisli1
  = \ (@ (m_XbN1R :: * -> *))
      ($dMonad_XbN1T :: Monad m_XbN1R)
      (@ b_abMYW)
      (@ c_abMYX)
      (@ b'_abMYY)
      (@ c'_abMYZ)
      (f_abMvu :: Kleisli m_XbN1R b_abMYW c_abMYX)
      (g_abMvv :: Kleisli m_XbN1R b'_abMYY c'_abMYZ)
      (eta_X4a :: Either b_abMYW b'_abMYY) ->
      case eta_X4a of {
        Left x_ibNlX ->
          >>=
            @ m_XbN1R
            $dMonad_XbN1T
            @ c_abMYX
            @ (Either c_abMYX c'_abMYZ)
            ((f_abMvu
              `cast` (Control.Arrow.N:Kleisli[0]
                          <m_XbN1R>_R <b_abMYW>_R <c_abMYX>_N
                      :: (Kleisli m_XbN1R b_abMYW c_abMYX :: *)
                         ~R# (b_abMYW -> m_XbN1R c_abMYX :: *)))
               x_ibNlX)
            (\ (eta1_X8 :: c_abMYX) ->
               return
                 @ m_XbN1R
                 $dMonad_XbN1T
                 @ (Either c_abMYX c'_abMYZ)
                 (Data.Either.Left @ c_abMYX @ c'_abMYZ eta1_X8));
        Right y_ibNm0 ->
          >>=
            @ m_XbN1R
            $dMonad_XbN1T
            @ c'_abMYZ
            @ (Either c_abMYX c'_abMYZ)
            ((g_abMvv
              `cast` (Control.Arrow.N:Kleisli[0]
                          <m_XbN1R>_R <b'_abMYY>_R <c'_abMYZ>_N
                      :: (Kleisli m_XbN1R b'_abMYY c'_abMYZ :: *)
                         ~R# (b'_abMYY -> m_XbN1R c'_abMYZ :: *)))
               y_ibNm0)
            (\ (eta1_X8 :: c'_abMYZ) ->
               return
                 @ m_XbN1R
                 $dMonad_XbN1T
                 @ (Either c_abMYX c'_abMYZ)
                 (Data.Either.Right @ c_abMYX @ c'_abMYZ eta1_X8))
      }

-- RHS size: {terms: 15, types: 27, coercions: 5, joins: 0/0}
Control.Arrow.$fArrowChoiceKleisli3
  :: forall (m :: * -> *).
     Monad m =>
     forall b c d. Kleisli m b c -> Either b d -> m (Either c d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_XbN1Q :: * -> *))
                 ($dMonad_XbN1S :: Monad m_XbN1Q)
                 (@ b_abMYc)
                 (@ c_abMYd)
                 (@ d_abMYe)
                 (f_abMvs [Occ=Once] :: Kleisli m_XbN1Q b_abMYc c_abMYd)
                 (eta_B1 [Occ=Once] :: Either b_abMYc d_abMYe) ->
                 Control.Arrow.$fArrowChoiceKleisli1
                   @ m_XbN1Q
                   $dMonad_XbN1S
                   @ b_abMYc
                   @ c_abMYd
                   @ d_abMYe
                   @ d_abMYe
                   f_abMvs
                   ((\ (eta1_X4i [Occ=Once, OS=OneShot] :: d_abMYe) ->
                       return @ m_XbN1Q $dMonad_XbN1S @ d_abMYe eta1_X4i)
                    `cast` (Sym (Control.Arrow.N:Kleisli[0]
                                     <m_XbN1Q>_R <d_abMYe>_R <d_abMYe>_N)
                            :: (d_abMYe -> m_XbN1Q d_abMYe :: *)
                               ~R# (Kleisli m_XbN1Q d_abMYe d_abMYe :: *)))
                   eta_B1}]
Control.Arrow.$fArrowChoiceKleisli3
  = \ (@ (m_XbN1Q :: * -> *))
      ($dMonad_XbN1S :: Monad m_XbN1Q)
      (@ b_abMYc)
      (@ c_abMYd)
      (@ d_abMYe)
      (f_abMvs :: Kleisli m_XbN1Q b_abMYc c_abMYd)
      (eta_B1 :: Either b_abMYc d_abMYe) ->
      Control.Arrow.$fArrowChoiceKleisli1
        @ m_XbN1Q
        $dMonad_XbN1S
        @ b_abMYc
        @ c_abMYd
        @ d_abMYe
        @ d_abMYe
        f_abMvs
        ((\ (eta1_X4i [OS=OneShot] :: d_abMYe) ->
            return @ m_XbN1Q $dMonad_XbN1S @ d_abMYe eta1_X4i)
         `cast` (Sym (Control.Arrow.N:Kleisli[0]
                          <m_XbN1Q>_R <d_abMYe>_R <d_abMYe>_N)
                 :: (d_abMYe -> m_XbN1Q d_abMYe :: *)
                    ~R# (Kleisli m_XbN1Q d_abMYe d_abMYe :: *)))
        eta_B1

-- RHS size: {terms: 15, types: 27, coercions: 5, joins: 0/0}
Control.Arrow.$fArrowChoiceKleisli2
  :: forall (m :: * -> *).
     Monad m =>
     forall b c d. Kleisli m b c -> Either d b -> m (Either d c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_XbN1P :: * -> *))
                 ($dMonad_XbN6b :: Monad m_XbN1P)
                 (@ b_abMYz)
                 (@ c_abMYA)
                 (@ d_abMYB)
                 (f_abMvt [Occ=Once] :: Kleisli m_XbN1P b_abMYz c_abMYA)
                 (eta_B1 [Occ=Once] :: Either d_abMYB b_abMYz) ->
                 Control.Arrow.$fArrowChoiceKleisli1
                   @ m_XbN1P
                   $dMonad_XbN6b
                   @ d_abMYB
                   @ d_abMYB
                   @ b_abMYz
                   @ c_abMYA
                   ((\ (eta1_X4q [Occ=Once, OS=OneShot] :: d_abMYB) ->
                       return @ m_XbN1P $dMonad_XbN6b @ d_abMYB eta1_X4q)
                    `cast` (Sym (Control.Arrow.N:Kleisli[0]
                                     <m_XbN1P>_R <d_abMYB>_R <d_abMYB>_N)
                            :: (d_abMYB -> m_XbN1P d_abMYB :: *)
                               ~R# (Kleisli m_XbN1P d_abMYB d_abMYB :: *)))
                   f_abMvt
                   eta_B1}]
Control.Arrow.$fArrowChoiceKleisli2
  = \ (@ (m_XbN1P :: * -> *))
      ($dMonad_XbN6b :: Monad m_XbN1P)
      (@ b_abMYz)
      (@ c_abMYA)
      (@ d_abMYB)
      (f_abMvt :: Kleisli m_XbN1P b_abMYz c_abMYA)
      (eta_B1 :: Either d_abMYB b_abMYz) ->
      Control.Arrow.$fArrowChoiceKleisli1
        @ m_XbN1P
        $dMonad_XbN6b
        @ d_abMYB
        @ d_abMYB
        @ b_abMYz
        @ c_abMYA
        ((\ (eta1_X4q [OS=OneShot] :: d_abMYB) ->
            return @ m_XbN1P $dMonad_XbN6b @ d_abMYB eta1_X4q)
         `cast` (Sym (Control.Arrow.N:Kleisli[0]
                          <m_XbN1P>_R <d_abMYB>_R <d_abMYB>_N)
                 :: (d_abMYB -> m_XbN1P d_abMYB :: *)
                    ~R# (Kleisli m_XbN1P d_abMYB d_abMYB :: *)))
        f_abMvt
        eta_B1

-- RHS size: {terms: 11, types: 25, coercions: 8, joins: 0/0}
lvl4_rbNCc
  :: forall (m :: * -> *) b d c.
     Kleisli m b d -> Kleisli m c d -> Either b c -> m d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []]
lvl4_rbNCc
  = \ (@ (m_XbN1O :: * -> *))
      (@ b_XbN3l)
      (@ d_XbN3n)
      (@ c_XbN3p)
      (ds_XbNpD :: Kleisli m_XbN1O b_XbN3l d_XbN3n)
      (ds1_XbNpF :: Kleisli m_XbN1O c_XbN3p d_XbN3n)
      (eta_X4z :: Either b_XbN3l c_XbN3p) ->
      either
        @ b_XbN3l
        @ (m_XbN1O d_XbN3n)
        @ c_XbN3p
        (ds_XbNpD
         `cast` (Control.Arrow.N:Kleisli[0]
                     <m_XbN1O>_R <b_XbN3l>_R <d_XbN3n>_N
                 :: (Kleisli m_XbN1O b_XbN3l d_XbN3n :: *)
                    ~R# (b_XbN3l -> m_XbN1O d_XbN3n :: *)))
        (ds1_XbNpF
         `cast` (Control.Arrow.N:Kleisli[0]
                     <m_XbN1O>_R <c_XbN3p>_R <d_XbN3n>_N
                 :: (Kleisli m_XbN1O c_XbN3p d_XbN3n :: *)
                    ~R# (c_XbN3p -> m_XbN1O d_XbN3n :: *)))
        eta_X4z

-- RHS size: {terms: 12, types: 13, coercions: 103, joins: 0/0}
Control.Arrow.$fArrowChoiceKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *). Monad m => ArrowChoice (Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,U,A)>m,
 Unf=DFun: \ (@ (m_abMvr :: * -> *)) (v_X4t :: Monad m_abMvr) ->
       Control.Arrow.C:ArrowChoice TYPE: Kleisli m_abMvr
                                   Control.Arrow.$fArrowKleisli @ m_abMvr v_X4t
                                   (Control.Arrow.$fArrowChoiceKleisli3 @ m_abMvr v_X4t)
                                   `cast` (forall (b :: <*>_N) (c :: <*>_N) (d :: <*>_N).
                                           <Kleisli m_abMvr b c>_R
                                           ->_R Sym (Control.Arrow.N:Kleisli[0]
                                                         <m_abMvr>_R <Either b d>_R <Either c d>_N)
                                           :: (forall b c d.
                                               Kleisli m_abMvr b c
                                               -> Either b d -> m_abMvr (Either c d) :: *)
                                              ~R# (forall b c d.
                                                   Kleisli m_abMvr b c
                                                   -> Kleisli
                                                        m_abMvr (Either b d) (Either c d) :: *))
                                   (Control.Arrow.$fArrowChoiceKleisli2 @ m_abMvr v_X4t)
                                   `cast` (forall (b :: <*>_N) (c :: <*>_N) (d :: <*>_N).
                                           <Kleisli m_abMvr b c>_R
                                           ->_R Sym (Control.Arrow.N:Kleisli[0]
                                                         <m_abMvr>_R <Either d b>_R <Either d c>_N)
                                           :: (forall b c d.
                                               Kleisli m_abMvr b c
                                               -> Either d b -> m_abMvr (Either d c) :: *)
                                              ~R# (forall b c d.
                                                   Kleisli m_abMvr b c
                                                   -> Kleisli
                                                        m_abMvr (Either d b) (Either d c) :: *))
                                   (Control.Arrow.$fArrowChoiceKleisli1 @ m_abMvr v_X4t)
                                   `cast` (forall (b :: <*>_N) (c :: <*>_N) (b' :: <*>_N) (c' :: <*>_N).
                                           <Kleisli m_abMvr b c>_R
                                           ->_R <Kleisli m_abMvr b' c'>_R
                                           ->_R Sym (Control.Arrow.N:Kleisli[0]
                                                         <m_abMvr>_R
                                                         <Either b b'>_R
                                                         <Either c c'>_N)
                                           :: (forall b c b' c'.
                                               Kleisli m_abMvr b c
                                               -> Kleisli m_abMvr b' c'
                                               -> Either b b'
                                               -> m_abMvr (Either c c') :: *)
                                              ~R# (forall b c b' c'.
                                                   Kleisli m_abMvr b c
                                                   -> Kleisli m_abMvr b' c'
                                                   -> Kleisli
                                                        m_abMvr (Either b b') (Either c c') :: *))
                                   (\ (@ b_XbN3l)
                                      (@ d_XbN3n)
                                      (@ c_XbN3p)
                                      (ds_XbNpD [Occ=Once] :: Kleisli m_abMvr b_XbN3l d_XbN3n)
                                      (ds1_XbNpF [Occ=Once] :: Kleisli m_abMvr c_XbN3p d_XbN3n) ->
                                      either
                                        @ b_XbN3l
                                        @ (m_abMvr d_XbN3n)
                                        @ c_XbN3p
                                        (ds_XbNpD
                                         `cast` (Control.Arrow.N:Kleisli[0]
                                                     <m_abMvr>_R <b_XbN3l>_R <d_XbN3n>_N
                                                 :: (Kleisli m_abMvr b_XbN3l d_XbN3n :: *)
                                                    ~R# (b_XbN3l -> m_abMvr d_XbN3n :: *)))
                                        (ds1_XbNpF
                                         `cast` (Control.Arrow.N:Kleisli[0]
                                                     <m_abMvr>_R <c_XbN3p>_R <d_XbN3n>_N
                                                 :: (Kleisli m_abMvr c_XbN3p d_XbN3n :: *)
                                                    ~R# (c_XbN3p -> m_abMvr d_XbN3n :: *))))
                                   `cast` (forall (b :: <*>_N) (d :: <*>_N) (c :: <*>_N).
                                           <Kleisli m_abMvr b d>_R
                                           ->_R <Kleisli m_abMvr c d>_R
                                           ->_R Sym (Control.Arrow.N:Kleisli[0]
                                                         <m_abMvr>_R <Either b c>_R <d>_N)
                                           :: (forall b d c.
                                               Kleisli m_abMvr b d
                                               -> Kleisli m_abMvr c d
                                               -> Either b c
                                               -> m_abMvr d :: *)
                                              ~R# (forall b d c.
                                                   Kleisli m_abMvr b d
                                                   -> Kleisli m_abMvr c d
                                                   -> Kleisli m_abMvr (Either b c) d :: *))]
Control.Arrow.$fArrowChoiceKleisli
  = \ (@ (m_XbN1O :: * -> *)) ($dMonad_XbN6i :: Monad m_XbN1O) ->
      Control.Arrow.C:ArrowChoice
        @ (Kleisli m_XbN1O)
        (Control.Arrow.$fArrowKleisli @ m_XbN1O $dMonad_XbN6i)
        ((Control.Arrow.$fArrowChoiceKleisli3 @ m_XbN1O $dMonad_XbN6i)
         `cast` (forall (b :: <*>_N) (c :: <*>_N) (d :: <*>_N).
                 <Kleisli m_XbN1O b c>_R
                 ->_R Sym (Control.Arrow.N:Kleisli[0]
                               <m_XbN1O>_R <Either b d>_R <Either c d>_N)
                 :: (forall b c d.
                     Kleisli m_XbN1O b c -> Either b d -> m_XbN1O (Either c d) :: *)
                    ~R# (forall b c d.
                         Kleisli m_XbN1O b c
                         -> Kleisli m_XbN1O (Either b d) (Either c d) :: *)))
        ((Control.Arrow.$fArrowChoiceKleisli2 @ m_XbN1O $dMonad_XbN6i)
         `cast` (forall (b :: <*>_N) (c :: <*>_N) (d :: <*>_N).
                 <Kleisli m_XbN1O b c>_R
                 ->_R Sym (Control.Arrow.N:Kleisli[0]
                               <m_XbN1O>_R <Either d b>_R <Either d c>_N)
                 :: (forall b c d.
                     Kleisli m_XbN1O b c -> Either d b -> m_XbN1O (Either d c) :: *)
                    ~R# (forall b c d.
                         Kleisli m_XbN1O b c
                         -> Kleisli m_XbN1O (Either d b) (Either d c) :: *)))
        ((Control.Arrow.$fArrowChoiceKleisli1 @ m_XbN1O $dMonad_XbN6i)
         `cast` (forall (b :: <*>_N) (c :: <*>_N) (b' :: <*>_N) (c' :: <*>_N).
                 <Kleisli m_XbN1O b c>_R
                 ->_R <Kleisli m_XbN1O b' c'>_R
                 ->_R Sym (Control.Arrow.N:Kleisli[0]
                               <m_XbN1O>_R <Either b b'>_R <Either c c'>_N)
                 :: (forall b c b' c'.
                     Kleisli m_XbN1O b c
                     -> Kleisli m_XbN1O b' c'
                     -> Either b b'
                     -> m_XbN1O (Either c c') :: *)
                    ~R# (forall b c b' c'.
                         Kleisli m_XbN1O b c
                         -> Kleisli m_XbN1O b' c'
                         -> Kleisli m_XbN1O (Either b b') (Either c c') :: *)))
        ((lvl4_rbNCc @ m_XbN1O)
         `cast` (forall (b :: <*>_N) (d :: <*>_N) (c :: <*>_N).
                 <Kleisli m_XbN1O b d>_R
                 ->_R <Kleisli m_XbN1O c d>_R
                 ->_R Sym (Control.Arrow.N:Kleisli[0]
                               <m_XbN1O>_R <Either b c>_R <d>_N)
                 :: (forall b d c.
                     Kleisli m_XbN1O b d
                     -> Kleisli m_XbN1O c d -> Either b c -> m_XbN1O d :: *)
                    ~R# (forall b d c.
                         Kleisli m_XbN1O b d
                         -> Kleisli m_XbN1O c d -> Kleisli m_XbN1O (Either b c) d :: *)))

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero
  :: forall (m :: * -> *). MonadPlus m => Arrow (Kleisli m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(A,C(C1(U)),A,U,A),A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_XbN5r :: * -> *))
                 ($dMonadPlus_XbN5t [Occ=Once] :: MonadPlus m_XbN5r) ->
                 Control.Arrow.$fArrowKleisli
                   @ m_XbN5r (GHC.Base.$p2MonadPlus @ m_XbN5r $dMonadPlus_XbN5t)}]
Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero
  = \ (@ (m_XbN5r :: * -> *))
      ($dMonadPlus_XbN5t :: MonadPlus m_XbN5r) ->
      Control.Arrow.$fArrowKleisli
        @ m_XbN5r (GHC.Base.$p2MonadPlus @ m_XbN5r $dMonadPlus_XbN5t)

-- RHS size: {terms: 13, types: 23, coercions: 11, joins: 0/1}
Control.Arrow.$fArrowZeroKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *). MonadPlus m => ArrowZero (Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U(A,C(C1(U)),A,U,A),1*U,A)>m,
 Unf=DFun: \ (@ (m_abMvG :: * -> *)) (v_X4v :: MonadPlus m_abMvG) ->
       Control.Arrow.C:ArrowZero TYPE: Kleisli m_abMvG
                                 Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero @ m_abMvG v_X4v
                                 (\ (@ b_XbNa9) (@ c_XbNac) _ [Occ=Dead] ->
                                    mzero @ m_abMvG v_X4v @ c_XbNac)
                                 `cast` (forall (b :: <*>_N) (c :: <*>_N).
                                         Sym (Control.Arrow.N:Kleisli[0] <m_abMvG>_R <b>_R <c>_N)
                                         :: (forall b c. b -> m_abMvG c :: *)
                                            ~R# (forall b c. Kleisli m_abMvG b c :: *))]
Control.Arrow.$fArrowZeroKleisli
  = \ (@ (m_XbN5s :: * -> *))
      ($dMonadPlus_XbN5u :: MonadPlus m_XbN5s) ->
      let {
        lvl5_sbNtb :: forall c. m_XbN5s c
        [LclId]
        lvl5_sbNtb
          = \ (@ c_XbNac) -> mzero @ m_XbN5s $dMonadPlus_XbN5u @ c_XbNac } in
      Control.Arrow.C:ArrowZero
        @ (Kleisli m_XbN5s)
        (Control.Arrow.$fArrowZeroKleisli_$cp1ArrowZero
           @ m_XbN5s $dMonadPlus_XbN5u)
        ((\ (@ b_XbNa9) (@ c_XbNac) _ [Occ=Dead] -> lvl5_sbNtb @ c_XbNac)
         `cast` (forall (b :: <*>_N) (c :: <*>_N).
                 Sym (Control.Arrow.N:Kleisli[0] <m_XbN5s>_R <b>_R <c>_N)
                 :: (forall b c. b -> m_XbN5s c :: *)
                    ~R# (forall b c. Kleisli m_XbN5s b c :: *)))

-- RHS size: {terms: 7, types: 10, coercions: 21, joins: 0/0}
Control.Arrow.$fArrowPlusKleisli [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *). MonadPlus m => ArrowPlus (Kleisli m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,U(A,C(C1(U)),A,U,A),U,C(C1(U)))>m,
 Unf=DFun: \ (@ (m_abMvC :: * -> *)) (v_X4w :: MonadPlus m_abMvC) ->
       Control.Arrow.C:ArrowPlus TYPE: Kleisli m_abMvC
                                 Control.Arrow.$fArrowZeroKleisli @ m_abMvC v_X4w
                                 (Control.Arrow.$fArrowPlusKleisli1 @ m_abMvC v_X4w)
                                 `cast` (forall (b :: <*>_N) (c :: <*>_N).
                                         <Kleisli m_abMvC b c>_R
                                         ->_R <Kleisli m_abMvC b c>_R
                                         ->_R Sym (Control.Arrow.N:Kleisli[0]
                                                       <m_abMvC>_R <b>_R <c>_N)
                                         :: (forall b c.
                                             Kleisli m_abMvC b c
                                             -> Kleisli m_abMvC b c -> b -> m_abMvC c :: *)
                                            ~R# (forall b c.
                                                 Kleisli m_abMvC b c
                                                 -> Kleisli m_abMvC b c
                                                 -> Kleisli m_abMvC b c :: *))]
Control.Arrow.$fArrowPlusKleisli
  = \ (@ (m_XbN58 :: * -> *))
      ($dMonadPlus_XbN5a :: MonadPlus m_XbN58) ->
      Control.Arrow.C:ArrowPlus
        @ (Kleisli m_XbN58)
        (Control.Arrow.$fArrowZeroKleisli @ m_XbN58 $dMonadPlus_XbN5a)
        ((Control.Arrow.$fArrowPlusKleisli1 @ m_XbN58 $dMonadPlus_XbN5a)
         `cast` (forall (b :: <*>_N) (c :: <*>_N).
                 <Kleisli m_XbN58 b c>_R
                 ->_R <Kleisli m_XbN58 b c>_R
                 ->_R Sym (Control.Arrow.N:Kleisli[0] <m_XbN58>_R <b>_R <c>_N)
                 :: (forall b c.
                     Kleisli m_XbN58 b c -> Kleisli m_XbN58 b c -> b -> m_XbN58 c :: *)
                    ~R# (forall b c.
                         Kleisli m_XbN58 b c
                         -> Kleisli m_XbN58 b c -> Kleisli m_XbN58 b c :: *)))

-- RHS size: {terms: 10, types: 24, coercions: 0, joins: 0/0}
Control.Arrow.$dmsecond
  :: forall (a :: * -> * -> *).
     Arrow a =>
     forall b c d. a b c -> a (d, b) (d, c)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLC(S)L),U(1*U(1*U,A),A,A,A,1*C1(U),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_abMuz :: * -> * -> *))
                 ($dArrow_abMMY :: Arrow a_abMuz)
                 (@ b_abMNh)
                 (@ c_abMNi)
                 (@ d_abMNj) ->
                 ***
                   @ a_abMuz
                   $dArrow_abMMY
                   @ d_abMNj
                   @ d_abMNj
                   @ b_abMNh
                   @ c_abMNi
                   (id
                      @ *
                      @ a_abMuz
                      (Control.Arrow.$p1Arrow @ a_abMuz $dArrow_abMMY)
                      @ d_abMNj)}]
Control.Arrow.$dmsecond
  = \ (@ (a_abMuz :: * -> * -> *))
      ($dArrow_abMMY :: Arrow a_abMuz)
      (@ b_abMNh)
      (@ c_abMNi)
      (@ d_abMNj) ->
      ***
        @ a_abMuz
        $dArrow_abMMY
        @ d_abMNj
        @ d_abMNj
        @ b_abMNh
        @ c_abMNi
        (id
           @ *
           @ a_abMuz
           (Control.Arrow.$p1Arrow @ a_abMuz $dArrow_abMMY)
           @ d_abMNj)

-- RHS size: {terms: 12, types: 27, coercions: 0, joins: 0/0}
Control.Arrow.$dmfirst
  :: forall (a :: * -> * -> *).
     Arrow a =>
     forall b c d. a b c -> a (b, d) (c, d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLC(C(S))L),U(1*U(1*U,A),A,A,A,1*C1(C1(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_abMuz :: * -> * -> *))
                 ($dArrow_abMMY :: Arrow a_abMuz)
                 (@ b_abMN0)
                 (@ c_abMN1)
                 (@ d_abMN2) ->
                 let {
                   $dCategory_abMNc [Occ=OnceL] :: Category a_abMuz
                   [LclId]
                   $dCategory_abMNc
                     = Control.Arrow.$p1Arrow @ a_abMuz $dArrow_abMMY } in
                 let {
                   ds_dbNiY [Occ=OnceL] :: a_abMuz d_abMN2 d_abMN2
                   [LclId]
                   ds_dbNiY = id @ * @ a_abMuz $dCategory_abMNc @ d_abMN2 } in
                 \ (ds1_dbNiX [Occ=Once] :: a_abMuz b_abMN0 c_abMN1) ->
                   ***
                     @ a_abMuz
                     $dArrow_abMMY
                     @ b_abMN0
                     @ c_abMN1
                     @ d_abMN2
                     @ d_abMN2
                     ds1_dbNiX
                     ds_dbNiY}]
Control.Arrow.$dmfirst
  = \ (@ (a_abMuz :: * -> * -> *))
      ($dArrow_abMMY :: Arrow a_abMuz)
      (@ b_abMN0)
      (@ c_abMN1)
      (@ d_abMN2)
      (eta_X4C :: a_abMuz b_abMN0 c_abMN1) ->
      ***
        @ a_abMuz
        $dArrow_abMMY
        @ b_abMN0
        @ c_abMN1
        @ d_abMN2
        @ d_abMN2
        eta_X4C
        (id
           @ *
           @ a_abMuz
           (Control.Arrow.$p1Arrow @ a_abMuz $dArrow_abMMY)
           @ d_abMN2)

-- RHS size: {terms: 15, types: 23, coercions: 0, joins: 0/0}
Control.Arrow.$cfirst :: forall b c d. (b -> c) -> (b, d) -> (c, d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_abN4h)
                 (@ c_abN4i)
                 (@ d_abN4j)
                 (ds_dbNiX [Occ=Once!] :: b_abN4h -> c_abN4i)
                 (ds1_dbNnY :: (b_abN4h, d_abN4j)) ->
                 (ds_dbNiX
                    (case ds1_dbNnY of { (x_abMvY [Occ=Once], _ [Occ=Dead]) ->
                     x_abMvY
                     }),
                  case ds1_dbNnY of { (_ [Occ=Dead], y_abMvZ [Occ=Once]) ->
                  y_abMvZ
                  })}]
Control.Arrow.$cfirst
  = \ (@ b_abN4h)
      (@ c_abN4i)
      (@ d_abN4j)
      (ds_dbNiX :: b_abN4h -> c_abN4i)
      (ds1_dbNnY :: (b_abN4h, d_abN4j)) ->
      (ds_dbNiX (case ds1_dbNnY of { (x_abMvY, y_abMvZ) -> x_abMvY }),
       case ds1_dbNnY of { (x_abMvY, y_abMvZ) -> y_abMvZ })

-- RHS size: {terms: 15, types: 23, coercions: 0, joins: 0/0}
Control.Arrow.$csecond
  :: forall b c d. (b -> c) -> (d, b) -> (d, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_abN4t)
                 (@ c_abN4u)
                 (@ d_abN4v)
                 (g_abMvX [Occ=Once!] :: b_abN4t -> c_abN4u)
                 (ds_dbNnY :: (d_abN4v, b_abN4t)) ->
                 (case ds_dbNnY of { (x_abMvY [Occ=Once], _ [Occ=Dead]) ->
                  x_abMvY
                  },
                  g_abMvX
                    (case ds_dbNnY of { (_ [Occ=Dead], y_abMvZ [Occ=Once]) ->
                     y_abMvZ
                     }))}]
Control.Arrow.$csecond
  = \ (@ b_abN4t)
      (@ c_abN4u)
      (@ d_abN4v)
      (g_abMvX :: b_abN4t -> c_abN4u)
      (ds_dbNnY :: (d_abN4v, b_abN4t)) ->
      (case ds_dbNnY of { (x_abMvY, y_abMvZ) -> x_abMvY },
       g_abMvX (case ds_dbNnY of { (x_abMvY, y_abMvZ) -> y_abMvZ }))

-- RHS size: {terms: 11, types: 13, coercions: 0, joins: 0/0}
Control.Arrow.$c&&&
  :: forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_abN4N)
                 (@ c_abN4O)
                 (@ c'_abN4P)
                 (f_XbMy1 [Occ=Once!] :: b_abN4N -> c_abN4O)
                 (g_XbMy3 [Occ=Once!] :: b_abN4N -> c'_abN4P)
                 (eta_X4F :: b_abN4N) ->
                 (f_XbMy1 eta_X4F, g_XbMy3 eta_X4F)}]
Control.Arrow.$c&&&
  = \ (@ b_abN4N)
      (@ c_abN4O)
      (@ c'_abN4P)
      (f_XbMy1 :: b_abN4N -> c_abN4O)
      (g_XbMy3 :: b_abN4N -> c'_abN4P)
      (eta_X4F :: b_abN4N) ->
      (f_XbMy1 eta_X4F, g_XbMy3 eta_X4F)

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
Control.Arrow.$fArrow(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: Arrow (->)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Control.Arrow.C:Arrow TYPE: (->)
                             Control.Category.$fCategoryTYPE(->)
                             Control.Arrow.$fArrow(->)_$carr
                             Control.Arrow.$cfirst
                             Control.Arrow.$csecond
                             Control.Arrow.$c***
                             Control.Arrow.$c&&&]
Control.Arrow.$fArrow(->)
  = Control.Arrow.C:Arrow
      @ (->)
      Control.Category.$fCategoryTYPE(->)
      Control.Arrow.$fArrow(->)_$carr
      Control.Arrow.$cfirst
      Control.Arrow.$csecond
      Control.Arrow.$c***
      Control.Arrow.$c&&&

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
Control.Arrow.$fArrowLoop(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: ArrowLoop (->)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Control.Arrow.C:ArrowLoop TYPE: (->)
                                 Control.Arrow.$fArrow(->)
                                 Control.Arrow.$fArrowLoop(->)_$cloop]
Control.Arrow.$fArrowLoop(->)
  = Control.Arrow.C:ArrowLoop
      @ (->)
      Control.Arrow.$fArrow(->)
      Control.Arrow.$fArrowLoop(->)_$cloop

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
Control.Arrow.$fArrowApply(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: ArrowApply (->)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Control.Arrow.C:ArrowApply TYPE: (->)
                                  Control.Arrow.$fArrow(->)
                                  Control.Arrow.$fAlternativeArrowMonad_$capp]
Control.Arrow.$fArrowApply(->)
  = Control.Arrow.C:ArrowApply
      @ (->)
      Control.Arrow.$fArrow(->)
      Control.Arrow.$fAlternativeArrowMonad_$capp

-- RHS size: {terms: 17, types: 24, coercions: 0, joins: 0/0}
Control.Arrow.$c+++
  :: forall b c b' c'.
     (b -> c) -> (b' -> c') -> Either b b' -> Either c c'
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_abN0z)
                 (@ c_abN0A)
                 (@ b'_abN0B)
                 (@ c'_abN0C)
                 (f_abMvA [Occ=Once!] :: b_abN0z -> c_abN0A)
                 (g_abMvB [Occ=Once!] :: b'_abN0B -> c'_abN0C)
                 (ds1_ibNlU [Occ=Once!] :: Either b_abN0z b'_abN0B) ->
                 case ds1_ibNlU of {
                   Left x_ibNlX [Occ=Once] ->
                     Data.Either.Left @ c_abN0A @ c'_abN0C (f_abMvA x_ibNlX);
                   Right y_ibNm0 [Occ=Once] ->
                     Data.Either.Right @ c_abN0A @ c'_abN0C (g_abMvB y_ibNm0)
                 }}]
Control.Arrow.$c+++
  = \ (@ b_abN0z)
      (@ c_abN0A)
      (@ b'_abN0B)
      (@ c'_abN0C)
      (f_abMvA :: b_abN0z -> c_abN0A)
      (g_abMvB :: b'_abN0B -> c'_abN0C)
      (ds1_ibNlU :: Either b_abN0z b'_abN0B) ->
      case ds1_ibNlU of {
        Left x_ibNlX ->
          Data.Either.Left @ c_abN0A @ c'_abN0C (f_abMvA x_ibNlX);
        Right y_ibNm0 ->
          Data.Either.Right @ c_abN0A @ c'_abN0C (g_abMvB y_ibNm0)
      }

-- RHS size: {terms: 14, types: 20, coercions: 0, joins: 0/0}
Control.Arrow.$cright
  :: forall b c d. (b -> c) -> Either d b -> Either d c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_abN0f)
                 (@ c_abN0g)
                 (@ d_abN0h)
                 (f_abMvz [Occ=Once!] :: b_abN0f -> c_abN0g)
                 (ds1_ibNlU [Occ=Once!] :: Either d_abN0h b_abN0f) ->
                 case ds1_ibNlU of {
                   Left x_ibNlX [Occ=Once] ->
                     Data.Either.Left @ d_abN0h @ c_abN0g x_ibNlX;
                   Right y_ibNm0 [Occ=Once] ->
                     Data.Either.Right @ d_abN0h @ c_abN0g (f_abMvz y_ibNm0)
                 }}]
Control.Arrow.$cright
  = \ (@ b_abN0f)
      (@ c_abN0g)
      (@ d_abN0h)
      (f_abMvz :: b_abN0f -> c_abN0g)
      (ds1_ibNlU :: Either d_abN0h b_abN0f) ->
      case ds1_ibNlU of {
        Left x_ibNlX -> Data.Either.Left @ d_abN0h @ c_abN0g x_ibNlX;
        Right y_ibNm0 ->
          Data.Either.Right @ d_abN0h @ c_abN0g (f_abMvz y_ibNm0)
      }

-- RHS size: {terms: 14, types: 20, coercions: 0, joins: 0/0}
Control.Arrow.$cleft
  :: forall b c d. (b -> c) -> Either b d -> Either c d
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_abMZV)
                 (@ c_abMZW)
                 (@ d_abMZX)
                 (f_abMvy [Occ=Once!] :: b_abMZV -> c_abMZW)
                 (ds1_ibNlU [Occ=Once!] :: Either b_abMZV d_abMZX) ->
                 case ds1_ibNlU of {
                   Left x_ibNlX [Occ=Once] ->
                     Data.Either.Left @ c_abMZW @ d_abMZX (f_abMvy x_ibNlX);
                   Right y_ibNm0 [Occ=Once] ->
                     Data.Either.Right @ c_abMZW @ d_abMZX y_ibNm0
                 }}]
Control.Arrow.$cleft
  = \ (@ b_abMZV)
      (@ c_abMZW)
      (@ d_abMZX)
      (f_abMvy :: b_abMZV -> c_abMZW)
      (ds1_ibNlU :: Either b_abMZV d_abMZX) ->
      case ds1_ibNlU of {
        Left x_ibNlX ->
          Data.Either.Left @ c_abMZW @ d_abMZX (f_abMvy x_ibNlX);
        Right y_ibNm0 -> Data.Either.Right @ c_abMZW @ d_abMZX y_ibNm0
      }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
Control.Arrow.$fArrowChoice(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: ArrowChoice (->)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Control.Arrow.C:ArrowChoice TYPE: (->)
                                   Control.Arrow.$fArrow(->)
                                   Control.Arrow.$cleft
                                   Control.Arrow.$cright
                                   Control.Arrow.$c+++
                                   either]
Control.Arrow.$fArrowChoice(->)
  = Control.Arrow.C:ArrowChoice
      @ (->)
      Control.Arrow.$fArrow(->)
      Control.Arrow.$cleft
      Control.Arrow.$cright
      Control.Arrow.$c+++
      either

-- RHS size: {terms: 5, types: 12, coercions: 0, joins: 0/0}
Control.Arrow.runKleisli1
  :: forall (m :: * -> *) a b. Kleisli m a b -> Kleisli m a b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_abMAz :: * -> *))
                 (@ a_abMAA)
                 (@ b_abMAB)
                 (ds_dbNiV [Occ=Once] :: Kleisli m_abMAz a_abMAA b_abMAB) ->
                 ds_dbNiV}]
Control.Arrow.runKleisli1
  = \ (@ (m_abMAz :: * -> *))
      (@ a_abMAA)
      (@ b_abMAB)
      (ds_dbNiV :: Kleisli m_abMAz a_abMAA b_abMAB) ->
      ds_dbNiV

-- RHS size: {terms: 1, types: 0, coercions: 20, joins: 0/0}
runKleisli :: forall (m :: * -> *) a b. Kleisli m a b -> a -> m b
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Control.Arrow.runKleisli1
               `cast` (forall (m :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
                       <Kleisli m a b>_R ->_R Control.Arrow.N:Kleisli[0] <m>_R <a>_R <b>_N
                       :: (forall (m :: * -> *) a b. Kleisli m a b -> Kleisli m a b :: *)
                          ~R# (forall (m :: * -> *) a b. Kleisli m a b -> a -> m b :: *))}]
runKleisli
  = Control.Arrow.runKleisli1
    `cast` (forall (m :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
            <Kleisli m a b>_R ->_R Control.Arrow.N:Kleisli[0] <m>_R <a>_R <b>_N
            :: (forall (m :: * -> *) a b. Kleisli m a b -> Kleisli m a b :: *)
               ~R# (forall (m :: * -> *) a b. Kleisli m a b -> a -> m b :: *))

-- RHS size: {terms: 6, types: 14, coercions: 0, joins: 0/0}
returnA :: forall (a :: * -> * -> *) b. Arrow a => a b b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_abMMJ :: * -> * -> *))
                 (@ b_abMMK)
                 ($dArrow_abMMM [Occ=Once] :: Arrow a_abMMJ) ->
                 arr
                   @ a_abMMJ
                   $dArrow_abMMM
                   @ b_abMMK
                   @ b_abMMK
                   (GHC.Base.id @ b_abMMK)}]
returnA
  = \ (@ (a_abMMJ :: * -> * -> *))
      (@ b_abMMK)
      ($dArrow_abMMM :: Arrow a_abMMJ) ->
      arr
        @ a_abMMJ $dArrow_abMMM @ b_abMMK @ b_abMMK (GHC.Base.id @ b_abMMK)

-- RHS size: {terms: 14, types: 29, coercions: 0, joins: 0/0}
^>>
  :: forall (a :: * -> * -> *) b c d.
     Arrow a =>
     (b -> c) -> a c d -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_abMMs :: * -> * -> *))
                 (@ b_abMMt)
                 (@ c_abMMu)
                 (@ d_abMMv)
                 ($dArrow_abMMx :: Arrow a_abMMs)
                 (eta_X4R [Occ=Once] :: b_abMMt -> c_abMMu)
                 (eta1_X9H [Occ=Once] :: a_abMMs c_abMMu d_abMMv) ->
                 . @ *
                   @ a_abMMs
                   (Control.Arrow.$p1Arrow @ a_abMMs $dArrow_abMMx)
                   @ c_abMMu
                   @ d_abMMv
                   @ b_abMMt
                   eta1_X9H
                   (arr @ a_abMMs $dArrow_abMMx @ b_abMMt @ c_abMMu eta_X4R)}]
^>>
  = \ (@ (a_abMMs :: * -> * -> *))
      (@ b_abMMt)
      (@ c_abMMu)
      (@ d_abMMv)
      ($dArrow_abMMx :: Arrow a_abMMs)
      (eta_X4R :: b_abMMt -> c_abMMu)
      (eta1_X9H :: a_abMMs c_abMMu d_abMMv) ->
      . @ *
        @ a_abMMs
        (Control.Arrow.$p1Arrow @ a_abMMs $dArrow_abMMx)
        @ c_abMMu
        @ d_abMMv
        @ b_abMMt
        eta1_X9H
        (arr @ a_abMMs $dArrow_abMMx @ b_abMMt @ c_abMMu eta_X4R)

-- RHS size: {terms: 14, types: 29, coercions: 0, joins: 0/0}
>>^
  :: forall (a :: * -> * -> *) b c d.
     Arrow a =>
     a b c -> (c -> d) -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_abMMb :: * -> * -> *))
                 (@ b_abMMc)
                 (@ c_abMMd)
                 (@ d_abMMe)
                 ($dArrow_abMMg :: Arrow a_abMMb)
                 (eta_X4S [Occ=Once] :: a_abMMb b_abMMc c_abMMd)
                 (eta1_X9J [Occ=Once] :: c_abMMd -> d_abMMe) ->
                 . @ *
                   @ a_abMMb
                   (Control.Arrow.$p1Arrow @ a_abMMb $dArrow_abMMg)
                   @ c_abMMd
                   @ d_abMMe
                   @ b_abMMc
                   (arr @ a_abMMb $dArrow_abMMg @ c_abMMd @ d_abMMe eta1_X9J)
                   eta_X4S}]
>>^
  = \ (@ (a_abMMb :: * -> * -> *))
      (@ b_abMMc)
      (@ c_abMMd)
      (@ d_abMMe)
      ($dArrow_abMMg :: Arrow a_abMMb)
      (eta_X4S :: a_abMMb b_abMMc c_abMMd)
      (eta1_X9J :: c_abMMd -> d_abMMe) ->
      . @ *
        @ a_abMMb
        (Control.Arrow.$p1Arrow @ a_abMMb $dArrow_abMMg)
        @ c_abMMd
        @ d_abMMe
        @ b_abMMc
        (arr @ a_abMMb $dArrow_abMMg @ c_abMMd @ d_abMMe eta1_X9J)
        eta_X4S

-- RHS size: {terms: 14, types: 29, coercions: 0, joins: 0/0}
<<^
  :: forall (a :: * -> * -> *) c d b.
     Arrow a =>
     a c d -> (b -> c) -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_abMLU :: * -> * -> *))
                 (@ c_abMLV)
                 (@ d_abMLW)
                 (@ b_abMLX)
                 ($dArrow_abMLZ :: Arrow a_abMLU)
                 (eta_X4T [Occ=Once] :: a_abMLU c_abMLV d_abMLW)
                 (eta1_X9L [Occ=Once] :: b_abMLX -> c_abMLV) ->
                 . @ *
                   @ a_abMLU
                   (Control.Arrow.$p1Arrow @ a_abMLU $dArrow_abMLZ)
                   @ c_abMLV
                   @ d_abMLW
                   @ b_abMLX
                   eta_X4T
                   (arr @ a_abMLU $dArrow_abMLZ @ b_abMLX @ c_abMLV eta1_X9L)}]
<<^
  = \ (@ (a_abMLU :: * -> * -> *))
      (@ c_abMLV)
      (@ d_abMLW)
      (@ b_abMLX)
      ($dArrow_abMLZ :: Arrow a_abMLU)
      (eta_X4T :: a_abMLU c_abMLV d_abMLW)
      (eta1_X9L :: b_abMLX -> c_abMLV) ->
      . @ *
        @ a_abMLU
        (Control.Arrow.$p1Arrow @ a_abMLU $dArrow_abMLZ)
        @ c_abMLV
        @ d_abMLW
        @ b_abMLX
        eta_X4T
        (arr @ a_abMLU $dArrow_abMLZ @ b_abMLX @ c_abMLV eta1_X9L)

-- RHS size: {terms: 14, types: 29, coercions: 0, joins: 0/0}
^<<
  :: forall (a :: * -> * -> *) c d b.
     Arrow a =>
     (c -> d) -> a b c -> a b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_abMLx :: * -> * -> *))
                 (@ c_abMLy)
                 (@ d_abMLz)
                 (@ b_abMLA)
                 ($dArrow_abMLC :: Arrow a_abMLx)
                 (eta_X4U [Occ=Once] :: c_abMLy -> d_abMLz)
                 (eta1_X9N [Occ=Once] :: a_abMLx b_abMLA c_abMLy) ->
                 . @ *
                   @ a_abMLx
                   (Control.Arrow.$p1Arrow @ a_abMLx $dArrow_abMLC)
                   @ c_abMLy
                   @ d_abMLz
                   @ b_abMLA
                   (arr @ a_abMLx $dArrow_abMLC @ c_abMLy @ d_abMLz eta_X4U)
                   eta1_X9N}]
^<<
  = \ (@ (a_abMLx :: * -> * -> *))
      (@ c_abMLy)
      (@ d_abMLz)
      (@ b_abMLA)
      ($dArrow_abMLC :: Arrow a_abMLx)
      (eta_X4U :: c_abMLy -> d_abMLz)
      (eta1_X9N :: a_abMLx b_abMLA c_abMLy) ->
      . @ *
        @ a_abMLx
        (Control.Arrow.$p1Arrow @ a_abMLx $dArrow_abMLC)
        @ c_abMLy
        @ d_abMLz
        @ b_abMLA
        (arr @ a_abMLx $dArrow_abMLC @ c_abMLy @ d_abMLz eta_X4U)
        eta1_X9N

-- RHS size: {terms: 52, types: 117, coercions: 0, joins: 0/3}
leftApp
  :: forall (a :: * -> * -> *) b c d.
     ArrowApply a =>
     a b c -> a (Either b d) (Either c d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(1*U(1*U(A,C(C1(U))),C(U),A,A,A,A),1*U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 430 0}]
leftApp
  = \ (@ (a_abMK6 :: * -> * -> *))
      (@ b_abMK7)
      (@ c_abMK8)
      (@ d_abMK9)
      ($dArrowApply_abMKb :: ArrowApply a_abMK6)
      (eta_X4U :: a_abMK6 b_abMK7 c_abMK8) ->
      let {
        $dArrow_sbNsm [Dmd=<S(S(LC(C(S)))LLLLL),U(1*U(A,C(C1(U))),C(U),A,A,A,A)>]
          :: Arrow a_abMK6
        [LclId]
        $dArrow_sbNsm
          = Control.Arrow.$p1ArrowApply @ a_abMK6 $dArrowApply_abMKb } in
      let {
        $dCategory_sbNsl [Dmd=<S(LC(C(S))),U(A,C(C1(U)))>]
          :: Category a_abMK6
        [LclId]
        $dCategory_sbNsl
          = Control.Arrow.$p1Arrow @ a_abMK6 $dArrow_sbNsm } in
      . @ *
        @ a_abMK6
        $dCategory_sbNsl
        @ (a_abMK6 () (Either c_abMK8 d_abMK9), ())
        @ (Either c_abMK8 d_abMK9)
        @ (Either b_abMK7 d_abMK9)
        (app @ a_abMK6 $dArrowApply_abMKb @ () @ (Either c_abMK8 d_abMK9))
        (let {
           lvl5_sbNtc :: a_abMK6 c_abMK8 (Either c_abMK8 d_abMK9)
           [LclId]
           lvl5_sbNtc
             = arr
                 @ a_abMK6
                 $dArrow_sbNsm
                 @ c_abMK8
                 @ (Either c_abMK8 d_abMK9)
                 (Data.Either.Left @ c_abMK8 @ d_abMK9) } in
         arr
           @ a_abMK6
           $dArrow_sbNsm
           @ (Either b_abMK7 d_abMK9)
           @ (a_abMK6 () (Either c_abMK8 d_abMK9), ())
           (\ (ds1_ibNlU :: Either b_abMK7 d_abMK9) ->
              case ds1_ibNlU of {
                Left x_ibNlX ->
                  (. @ *
                     @ a_abMK6
                     $dCategory_sbNsl
                     @ c_abMK8
                     @ (Either c_abMK8 d_abMK9)
                     @ ()
                     lvl5_sbNtc
                     (. @ *
                        @ a_abMK6
                        $dCategory_sbNsl
                        @ b_abMK7
                        @ c_abMK8
                        @ ()
                        eta_X4U
                        (arr
                           @ a_abMK6
                           $dArrow_sbNsm
                           @ ()
                           @ b_abMK7
                           (\ (ds_dbNim :: ()) -> case ds_dbNim of { () -> x_ibNlX }))),
                   GHC.Tuple.());
                Right y_ibNm0 ->
                  (arr
                     @ a_abMK6
                     $dArrow_sbNsm
                     @ ()
                     @ (Either c_abMK8 d_abMK9)
                     (\ (x_i7Rxi :: ()) ->
                        Data.Either.Right
                          @ c_abMK8 @ d_abMK9 (case x_i7Rxi of { () -> y_ibNm0 })),
                   GHC.Tuple.())
              }))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Control.Arrow.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Arrow.$trModule3
  = GHC.Types.TrNameS Control.Arrow.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Control.Arrow.$trModule2 = "Control.Arrow"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Arrow.$trModule1
  = GHC.Types.TrNameS Control.Arrow.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Control.Arrow.$trModule
  = GHC.Types.Module
      Control.Arrow.$trModule3 Control.Arrow.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_rbNCd :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_rbNCd
  = GHC.Types.KindRepTyConApp
      GHC.Tuple.$tc() (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1_rbNCe :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep1_rbNCe
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcConstraint (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcKleisli1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Control.Arrow.$tcKleisli1
  = GHC.Types.KindRepFun GHC.Types.krep$*Arr* GHC.Types.krep$*->*->*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrow1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Control.Arrow.$tcArrow1
  = GHC.Types.KindRepFun GHC.Types.krep$*->*->* $krep1_rbNCe

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrowMonad1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Control.Arrow.$tcArrowMonad1
  = GHC.Types.KindRepFun GHC.Types.krep$*->*->* GHC.Types.krep$*Arr*

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep2_rbNCf :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep2_rbNCf = GHC.Types.KindRepVar 2#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep3_rbNCg :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep3_rbNCg = GHC.Types.KindRepVar 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep4_rbNCh :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep4_rbNCh = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5_rbNCi :: KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []]
$krep5_rbNCi = GHC.Types.KindRepApp $krep4_rbNCh $krep2_rbNCf

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep6_rbNCj :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep6_rbNCj = GHC.Types.KindRepFun $krep3_rbNCg $krep5_rbNCi

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep7_rbNCk :: KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []]
$krep7_rbNCk = GHC.Types.KindRepApp $krep4_rbNCh $krep_rbNCd

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep8_rbNCl :: KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []]
$krep8_rbNCl = GHC.Types.KindRepApp $krep7_rbNCk $krep3_rbNCg

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrow3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Control.Arrow.$tcArrow3 = "Arrow"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrow2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Arrow.$tcArrow2 = GHC.Types.TrNameS Control.Arrow.$tcArrow3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrow :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Arrow.$tcArrow
  = GHC.Types.TyCon
      12964584583212294992##
      10211991410748124746##
      Control.Arrow.$trModule
      Control.Arrow.$tcArrow2
      0#
      Control.Arrow.$tcArrow1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcKleisli3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Control.Arrow.$tcKleisli3 = "Kleisli"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcKleisli2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Arrow.$tcKleisli2
  = GHC.Types.TrNameS Control.Arrow.$tcKleisli3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcKleisli :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Arrow.$tcKleisli
  = GHC.Types.TyCon
      2023158159015915132##
      6143719008973118504##
      Control.Arrow.$trModule
      Control.Arrow.$tcKleisli2
      0#
      Control.Arrow.$tcKleisli1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep9_rbNCm :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep9_rbNCm
  = GHC.Types.: @ KindRep $krep2_rbNCf (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep10_rbNCn :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep10_rbNCn = GHC.Types.: @ KindRep $krep3_rbNCg $krep9_rbNCm

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep11_rbNCo :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep11_rbNCo = GHC.Types.: @ KindRep $krep4_rbNCh $krep10_rbNCn

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep12_rbNCp :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep12_rbNCp
  = GHC.Types.KindRepTyConApp Control.Arrow.$tcKleisli $krep11_rbNCo

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tc'Kleisli1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Control.Arrow.$tc'Kleisli1
  = GHC.Types.KindRepFun $krep6_rbNCj $krep12_rbNCp

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tc'Kleisli3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Control.Arrow.$tc'Kleisli3 = "'Kleisli"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tc'Kleisli2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Arrow.$tc'Kleisli2
  = GHC.Types.TrNameS Control.Arrow.$tc'Kleisli3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tc'Kleisli :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Arrow.$tc'Kleisli
  = GHC.Types.TyCon
      793719726112502834##
      14919550952510816382##
      Control.Arrow.$trModule
      Control.Arrow.$tc'Kleisli2
      3#
      Control.Arrow.$tc'Kleisli1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrowZero2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Arrow.$tcArrowZero2 = "ArrowZero"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrowZero1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Arrow.$tcArrowZero1
  = GHC.Types.TrNameS Control.Arrow.$tcArrowZero2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrowZero :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Arrow.$tcArrowZero
  = GHC.Types.TyCon
      337582314637215801##
      485553589222180171##
      Control.Arrow.$trModule
      Control.Arrow.$tcArrowZero1
      0#
      Control.Arrow.$tcArrow1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrowPlus2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Arrow.$tcArrowPlus2 = "ArrowPlus"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrowPlus1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Arrow.$tcArrowPlus1
  = GHC.Types.TrNameS Control.Arrow.$tcArrowPlus2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrowPlus :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Arrow.$tcArrowPlus
  = GHC.Types.TyCon
      9089885184909062397##
      13092571182525076608##
      Control.Arrow.$trModule
      Control.Arrow.$tcArrowPlus1
      0#
      Control.Arrow.$tcArrow1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrowChoice2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Arrow.$tcArrowChoice2 = "ArrowChoice"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrowChoice1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Arrow.$tcArrowChoice1
  = GHC.Types.TrNameS Control.Arrow.$tcArrowChoice2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrowChoice :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Arrow.$tcArrowChoice
  = GHC.Types.TyCon
      9045385674203608923##
      4474606397073518393##
      Control.Arrow.$trModule
      Control.Arrow.$tcArrowChoice1
      0#
      Control.Arrow.$tcArrow1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrowApply2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Arrow.$tcArrowApply2 = "ArrowApply"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrowApply1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Arrow.$tcArrowApply1
  = GHC.Types.TrNameS Control.Arrow.$tcArrowApply2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrowApply :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Arrow.$tcArrowApply
  = GHC.Types.TyCon
      4969046276209689969##
      2697302259091605677##
      Control.Arrow.$trModule
      Control.Arrow.$tcArrowApply1
      0#
      Control.Arrow.$tcArrow1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrowMonad3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Arrow.$tcArrowMonad3 = "ArrowMonad"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrowMonad2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Arrow.$tcArrowMonad2
  = GHC.Types.TrNameS Control.Arrow.$tcArrowMonad3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrowMonad :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Arrow.$tcArrowMonad
  = GHC.Types.TyCon
      2648525758856951758##
      13692351200590237690##
      Control.Arrow.$trModule
      Control.Arrow.$tcArrowMonad2
      0#
      Control.Arrow.$tcArrowMonad1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep13_rbNCq :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep13_rbNCq
  = GHC.Types.: @ KindRep $krep3_rbNCg (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep14_rbNCr :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep14_rbNCr = GHC.Types.: @ KindRep $krep4_rbNCh $krep13_rbNCq

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep15_rbNCs :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep15_rbNCs
  = GHC.Types.KindRepTyConApp
      Control.Arrow.$tcArrowMonad $krep14_rbNCr

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tc'ArrowMonad1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Control.Arrow.$tc'ArrowMonad1
  = GHC.Types.KindRepFun $krep8_rbNCl $krep15_rbNCs

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tc'ArrowMonad3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Arrow.$tc'ArrowMonad3 = "'ArrowMonad"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tc'ArrowMonad2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Arrow.$tc'ArrowMonad2
  = GHC.Types.TrNameS Control.Arrow.$tc'ArrowMonad3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tc'ArrowMonad :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Arrow.$tc'ArrowMonad
  = GHC.Types.TyCon
      8781545391513276915##
      783725375361948493##
      Control.Arrow.$trModule
      Control.Arrow.$tc'ArrowMonad2
      2#
      Control.Arrow.$tc'ArrowMonad1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrowLoop2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Arrow.$tcArrowLoop2 = "ArrowLoop"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrowLoop1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Arrow.$tcArrowLoop1
  = GHC.Types.TrNameS Control.Arrow.$tcArrowLoop2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Arrow.$tcArrowLoop :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Arrow.$tcArrowLoop
  = GHC.Types.TyCon
      15298492960828880948##
      13953070859738786616##
      Control.Arrow.$trModule
      Control.Arrow.$tcArrowLoop1
      0#
      Control.Arrow.$tcArrow1


------ Local rules for imported ids --------
"left/arr"
    forall (@ (a_abN51 :: * -> * -> *))
           (@ b_abN5h)
           (@ d_abN55)
           (@ c_abN5i)
           ($dArrowChoice_abN52 :: ArrowChoice a_abN51)
           ($dArrow_abN57 :: Arrow a_abN51)
           (f_abMwx :: b_abN5h -> c_abN5i).
      left @ a_abN51
           $dArrowChoice_abN52
           @ b_abN5h
           @ c_abN5i
           @ d_abN55
           (arr @ a_abN51 $dArrow_abN57 @ b_abN5h @ c_abN5i f_abMwx)
      = arr
          @ a_abN51
          (Control.Arrow.$p1ArrowChoice @ a_abN51 $dArrowChoice_abN52)
          @ (Either b_abN5h d_abN55)
          @ (Either c_abN5i d_abN55)
          (Control.Arrow.$cleft @ b_abN5h @ c_abN5i @ d_abN55 f_abMwx)
"right/arr"
    forall (@ (a_abN5F :: * -> * -> *))
           (@ d_abN5J)
           (@ b_abN5V)
           (@ c_abN5W)
           ($dArrowChoice_abN5G :: ArrowChoice a_abN5F)
           ($dArrow_abN5L :: Arrow a_abN5F)
           (f_abMwy :: b_abN5V -> c_abN5W).
      right @ a_abN5F
            $dArrowChoice_abN5G
            @ b_abN5V
            @ c_abN5W
            @ d_abN5J
            (arr @ a_abN5F $dArrow_abN5L @ b_abN5V @ c_abN5W f_abMwy)
      = arr
          @ a_abN5F
          (Control.Arrow.$p1ArrowChoice @ a_abN5F $dArrowChoice_abN5G)
          @ (Either d_abN5J b_abN5V)
          @ (Either d_abN5J c_abN5W)
          (Control.Arrow.$cright @ b_abN5V @ c_abN5W @ d_abN5J f_abMwy)
"sum/arr"
    forall (@ (a_abN6l :: * -> * -> *))
           (@ b_abN6G)
           (@ b'_abN6I)
           (@ c_abN6H)
           (@ c'_abN6J)
           ($dArrowChoice_abN6m :: ArrowChoice a_abN6l)
           ($dArrow_abN6s :: Arrow a_abN6l)
           ($dArrow1_abN6w :: Arrow a_abN6l)
           (f_abMwz :: b_abN6G -> c_abN6H)
           (g_abMwA :: b'_abN6I -> c'_abN6J).
      +++ @ a_abN6l
          $dArrowChoice_abN6m
          @ b_abN6G
          @ c_abN6H
          @ b'_abN6I
          @ c'_abN6J
          (arr @ a_abN6l $dArrow_abN6s @ b_abN6G @ c_abN6H f_abMwz)
          (arr @ a_abN6l $dArrow1_abN6w @ b'_abN6I @ c'_abN6J g_abMwA)
      = arr
          @ a_abN6l
          (Control.Arrow.$p1ArrowChoice @ a_abN6l $dArrowChoice_abN6m)
          @ (Either b_abN6G b'_abN6I)
          @ (Either c_abN6H c'_abN6J)
          (Control.Arrow.$c+++
             @ b_abN6G @ c_abN6H @ b'_abN6I @ c'_abN6J f_abMwz g_abMwA)
"fanin/arr"
    forall (@ (a_abN7a :: * -> * -> *))
           (@ b_abN7u)
           (@ c_abN7w)
           (@ d_abN7v)
           ($dArrowChoice_abN7b :: ArrowChoice a_abN7a)
           ($dArrow_abN7g :: Arrow a_abN7a)
           ($dArrow1_abN7k :: Arrow a_abN7a)
           (f_abMwB :: b_abN7u -> d_abN7v)
           (g_abMwC :: c_abN7w -> d_abN7v).
      ||| @ a_abN7a
          $dArrowChoice_abN7b
          @ b_abN7u
          @ d_abN7v
          @ c_abN7w
          (arr @ a_abN7a $dArrow_abN7g @ b_abN7u @ d_abN7v f_abMwB)
          (arr @ a_abN7a $dArrow1_abN7k @ c_abN7w @ d_abN7v g_abMwC)
      = arr
          @ a_abN7a
          (Control.Arrow.$p1ArrowChoice @ a_abN7a $dArrowChoice_abN7b)
          @ (Either b_abN7u c_abN7w)
          @ d_abN7v
          (either @ b_abN7u @ d_abN7v @ c_abN7w f_abMwB g_abMwC)
"compose/left"
    forall (@ (a_abN8d :: * -> * -> *))
           (@ b_abN8f)
           (@ d_abN86)
           (@ c_abN8g)
           (@ b1_abN8l)
           ($dCategory_abN7Y :: Category a_abN8d)
           ($dArrowChoice_abN83 :: ArrowChoice a_abN8d)
           ($dArrowChoice1_abN88 :: ArrowChoice a_abN8d)
           (f_abMwD :: a_abN8d b1_abN8l c_abN8g)
           (g_abMwE :: a_abN8d b_abN8f b1_abN8l).
      . @ *
        @ a_abN8d
        $dCategory_abN7Y
        @ (Either b1_abN8l d_abN86)
        @ (Either c_abN8g d_abN86)
        @ (Either b_abN8f d_abN86)
        (left
           @ a_abN8d
           $dArrowChoice_abN83
           @ b1_abN8l
           @ c_abN8g
           @ d_abN86
           f_abMwD)
        (left
           @ a_abN8d
           $dArrowChoice1_abN88
           @ b_abN8f
           @ b1_abN8l
           @ d_abN86
           g_abMwE)
      = left
          @ a_abN8d
          $dArrowChoice_abN83
          @ b_abN8f
          @ c_abN8g
          @ d_abN86
          (. @ *
             @ a_abN8d
             (Control.Arrow.$p1Arrow
                @ a_abN8d
                (Control.Arrow.$p1ArrowChoice @ a_abN8d $dArrowChoice_abN83))
             @ b1_abN8l
             @ c_abN8g
             @ b_abN8f
             f_abMwD
             g_abMwE)
"compose/right"
    forall (@ (a_abN8S :: * -> * -> *))
           (@ d_abN8L)
           (@ b_abN8U)
           (@ c_abN8V)
           (@ b1_abN90)
           ($dCategory_abN8D :: Category a_abN8S)
           ($dArrowChoice_abN8I :: ArrowChoice a_abN8S)
           ($dArrowChoice1_abN8N :: ArrowChoice a_abN8S)
           (f_abMwF :: a_abN8S b1_abN90 c_abN8V)
           (g_abMwG :: a_abN8S b_abN8U b1_abN90).
      . @ *
        @ a_abN8S
        $dCategory_abN8D
        @ (Either d_abN8L b1_abN90)
        @ (Either d_abN8L c_abN8V)
        @ (Either d_abN8L b_abN8U)
        (right
           @ a_abN8S
           $dArrowChoice_abN8I
           @ b1_abN90
           @ c_abN8V
           @ d_abN8L
           f_abMwF)
        (right
           @ a_abN8S
           $dArrowChoice1_abN8N
           @ b_abN8U
           @ b1_abN90
           @ d_abN8L
           g_abMwG)
      = right
          @ a_abN8S
          $dArrowChoice_abN8I
          @ b_abN8U
          @ c_abN8V
          @ d_abN8L
          (. @ *
             @ a_abN8S
             (Control.Arrow.$p1Arrow
                @ a_abN8S
                (Control.Arrow.$p1ArrowChoice @ a_abN8S $dArrowChoice_abN8I))
             @ b1_abN90
             @ c_abN8V
             @ b_abN8U
             f_abMwF
             g_abMwG)
"compose/arr"
    forall (@ (cat_abN9h :: * -> * -> *))
           (@ a_abN9E)
           (@ c_abN9D)
           (@ b_abN9C)
           ($dCategory_abN9i :: Category cat_abN9h)
           ($dArrow_abN9n :: Arrow cat_abN9h)
           ($dArrow1_abN9r :: Arrow cat_abN9h)
           (f_abMwH :: b_abN9C -> c_abN9D)
           (g_abMwI :: a_abN9E -> b_abN9C).
      . @ *
        @ cat_abN9h
        $dCategory_abN9i
        @ b_abN9C
        @ c_abN9D
        @ a_abN9E
        (arr @ cat_abN9h $dArrow_abN9n @ b_abN9C @ c_abN9D f_abMwH)
        (arr @ cat_abN9h $dArrow1_abN9r @ a_abN9E @ b_abN9C g_abMwI)
      = arr
          @ cat_abN9h
          $dArrow_abN9n
          @ a_abN9E
          @ c_abN9D
          (GHC.Base.. @ b_abN9C @ c_abN9D @ a_abN9E f_abMwH g_abMwI)
"first/arr"
    forall (@ (a_abNa2 :: * -> * -> *))
           (@ b_abNai)
           (@ d_abNa6)
           (@ c_abNaj)
           ($dArrow_abNa3 :: Arrow a_abNa2)
           ($dArrow1_abNa8 :: Arrow a_abNa2)
           (f_abMwJ :: b_abNai -> c_abNaj).
      first @ a_abNa2
            $dArrow_abNa3
            @ b_abNai
            @ c_abNaj
            @ d_abNa6
            (arr @ a_abNa2 $dArrow1_abNa8 @ b_abNai @ c_abNaj f_abMwJ)
      = arr
          @ a_abNa2
          $dArrow_abNa3
          @ (b_abNai, d_abNa6)
          @ (c_abNaj, d_abNa6)
          (Control.Arrow.$cfirst @ b_abNai @ c_abNaj @ d_abNa6 f_abMwJ)
"second/arr"
    forall (@ (a_abNaG :: * -> * -> *))
           (@ d_abNaK)
           (@ b_abNaW)
           (@ c_abNaX)
           ($dArrow_abNaH :: Arrow a_abNaG)
           ($dArrow1_abNaM :: Arrow a_abNaG)
           (f_abMwK :: b_abNaW -> c_abNaX).
      second @ a_abNaG
             $dArrow_abNaH
             @ b_abNaW
             @ c_abNaX
             @ d_abNaK
             (arr @ a_abNaG $dArrow1_abNaM @ b_abNaW @ c_abNaX f_abMwK)
      = arr
          @ a_abNaG
          $dArrow_abNaH
          @ (d_abNaK, b_abNaW)
          @ (d_abNaK, c_abNaX)
          (Control.Arrow.$csecond @ b_abNaW @ c_abNaX @ d_abNaK f_abMwK)
"product/arr"
    forall (@ (a_abNbm :: * -> * -> *))
           (@ b_abNbH)
           (@ b'_abNbJ)
           (@ c_abNbI)
           (@ c'_abNbK)
           ($dArrow_abNbn :: Arrow a_abNbm)
           ($dArrow1_abNbt :: Arrow a_abNbm)
           ($dArrow2_abNbx :: Arrow a_abNbm)
           (f_abMwL :: b_abNbH -> c_abNbI)
           (g_abMwM :: b'_abNbJ -> c'_abNbK).
      *** @ a_abNbm
          $dArrow_abNbn
          @ b_abNbH
          @ c_abNbI
          @ b'_abNbJ
          @ c'_abNbK
          (arr @ a_abNbm $dArrow1_abNbt @ b_abNbH @ c_abNbI f_abMwL)
          (arr @ a_abNbm $dArrow2_abNbx @ b'_abNbJ @ c'_abNbK g_abMwM)
      = arr
          @ a_abNbm
          $dArrow_abNbn
          @ (b_abNbH, b'_abNbJ)
          @ (c_abNbI, c'_abNbK)
          (Control.Arrow.$c***
             @ b_abNbH @ c_abNbI @ b'_abNbJ @ c'_abNbK f_abMwL g_abMwM)
"fanout/arr"
    forall (@ (a_abNcb :: * -> * -> *))
           (@ b_abNcv)
           (@ c_abNcw)
           (@ c'_abNcx)
           ($dArrow_abNcc :: Arrow a_abNcb)
           ($dArrow1_abNch :: Arrow a_abNcb)
           ($dArrow2_abNcl :: Arrow a_abNcb)
           (f_abMwN :: b_abNcv -> c_abNcw)
           (g_abMwO :: b_abNcv -> c'_abNcx).
      &&& @ a_abNcb
          $dArrow_abNcc
          @ b_abNcv
          @ c_abNcw
          @ c'_abNcx
          (arr @ a_abNcb $dArrow1_abNch @ b_abNcv @ c_abNcw f_abMwN)
          (arr @ a_abNcb $dArrow2_abNcl @ b_abNcv @ c'_abNcx g_abMwO)
      = arr
          @ a_abNcb
          $dArrow_abNcc
          @ b_abNcv
          @ (c_abNcw, c'_abNcx)
          (Control.Arrow.$c&&&
             @ b_abNcv @ c_abNcw @ c'_abNcx f_abMwN g_abMwO)
"compose/first"
    forall (@ (a_abNde :: * -> * -> *))
           (@ b_abNdg)
           (@ d_abNd7)
           (@ c_abNdh)
           (@ b1_abNdm)
           ($dCategory_abNcZ :: Category a_abNde)
           ($dArrow_abNd4 :: Arrow a_abNde)
           ($dArrow1_abNd9 :: Arrow a_abNde)
           (f_abMwP :: a_abNde b1_abNdm c_abNdh)
           (g_abMwQ :: a_abNde b_abNdg b1_abNdm).
      . @ *
        @ a_abNde
        $dCategory_abNcZ
        @ (b1_abNdm, d_abNd7)
        @ (c_abNdh, d_abNd7)
        @ (b_abNdg, d_abNd7)
        (first
           @ a_abNde $dArrow_abNd4 @ b1_abNdm @ c_abNdh @ d_abNd7 f_abMwP)
        (first
           @ a_abNde $dArrow1_abNd9 @ b_abNdg @ b1_abNdm @ d_abNd7 g_abMwQ)
      = first
          @ a_abNde
          $dArrow_abNd4
          @ b_abNdg
          @ c_abNdh
          @ d_abNd7
          (. @ *
             @ a_abNde
             (Control.Arrow.$p1Arrow @ a_abNde $dArrow_abNd4)
             @ b1_abNdm
             @ c_abNdh
             @ b_abNdg
             f_abMwP
             g_abMwQ)
"compose/second"
    forall (@ (a_abNdT :: * -> * -> *))
           (@ d_abNdM)
           (@ b_abNdV)
           (@ c_abNdW)
           (@ b1_abNe1)
           ($dCategory_abNdE :: Category a_abNdT)
           ($dArrow_abNdJ :: Arrow a_abNdT)
           ($dArrow1_abNdO :: Arrow a_abNdT)
           (f_abMwR :: a_abNdT b1_abNe1 c_abNdW)
           (g_abMwS :: a_abNdT b_abNdV b1_abNe1).
      . @ *
        @ a_abNdT
        $dCategory_abNdE
        @ (d_abNdM, b1_abNe1)
        @ (d_abNdM, c_abNdW)
        @ (d_abNdM, b_abNdV)
        (second
           @ a_abNdT $dArrow_abNdJ @ b1_abNe1 @ c_abNdW @ d_abNdM f_abMwR)
        (second
           @ a_abNdT $dArrow1_abNdO @ b_abNdV @ b1_abNe1 @ d_abNdM g_abMwS)
      = second
          @ a_abNdT
          $dArrow_abNdJ
          @ b_abNdV
          @ c_abNdW
          @ d_abNdM
          (. @ *
             @ a_abNdT
             (Control.Arrow.$p1Arrow @ a_abNdT $dArrow_abNdJ)
             @ b1_abNe1
             @ c_abNdW
             @ b_abNdV
             f_abMwR
             g_abMwS)

