
==================== Raw Cmm ====================
2018-03-16 16:09:12.383100528 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:09:12.385856683 UTC

[section ""data" . Control.Concurrent.isCurrentThreadBound1_closure" {
     Control.Concurrent.isCurrentThreadBound1_closure:
         const Control.Concurrent.isCurrentThreadBound1_info;
 },
 sat_sdWo9_entry() //  [R1]
         { []
         }
     {offset
       cdX4L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdX4M; else goto cdX4N;
       cdX4M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdX4N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto cdX4K; else goto cdX4J;
       cdX4K: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdX4J: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdWo9_info" {
     sat_sdWo9_info:
         const sat_sdWo9_entry;
         const 4294967296;
         const 17;
 },
 Control.Concurrent.isCurrentThreadBound1_entry() //  []
         { []
         }
     {offset
       cdX4O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdX4P; else goto cdX4Q;
       cdX4P: // global
           R1 = Control.Concurrent.isCurrentThreadBound1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX4Q: // global
           I64[Sp - 8] = block_cdX4B_info;
           Sp = Sp - 8;
           call stg_isCurrentThreadBound#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.isCurrentThreadBound1_info" {
     Control.Concurrent.isCurrentThreadBound1_info:
         const Control.Concurrent.isCurrentThreadBound1_entry;
         const 0;
         const 14;
         const 4294967299;
 },
 _cdX4B() //  [R1]
         { []
         }
     {offset
       cdX4B: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdX4T; else goto cdX4S;
       cdX4T: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdX4S: // global
           I64[Hp - 16] = sat_sdWo9_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdX4B_info" {
     block_cdX4B_info:
         const _cdX4B;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.406268343 UTC

[section ""data" . Control.Concurrent.isCurrentThreadBound_closure" {
     Control.Concurrent.isCurrentThreadBound_closure:
         const Control.Concurrent.isCurrentThreadBound_info;
 },
 Control.Concurrent.isCurrentThreadBound_entry() //  []
         { []
         }
     {offset
       cdX5d: // global
           call Control.Concurrent.isCurrentThreadBound1_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.isCurrentThreadBound_info" {
     Control.Concurrent.isCurrentThreadBound_info:
         const Control.Concurrent.isCurrentThreadBound_entry;
         const 0;
         const 14;
         const 4294967299;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.412477429 UTC

[section ""data" . Control.Concurrent.threadWaitRead_closure" {
     Control.Concurrent.threadWaitRead_closure:
         const Control.Concurrent.threadWaitRead_info;
         const 0;
 },
 Control.Concurrent.threadWaitRead_entry() //  [R2]
         { []
         }
     {offset
       cdX5o: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitRead1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.threadWaitRead_info" {
     Control.Concurrent.threadWaitRead_info:
         const Control.Concurrent.threadWaitRead_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SdWuv_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.418832624 UTC

[section ""data" . Control.Concurrent.threadWaitWrite_closure" {
     Control.Concurrent.threadWaitWrite_closure:
         const Control.Concurrent.threadWaitWrite_info;
         const 0;
 },
 Control.Concurrent.threadWaitWrite_entry() //  [R2]
         { []
         }
     {offset
       cdX5z: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWrite1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.threadWaitWrite_info" {
     Control.Concurrent.threadWaitWrite_info:
         const Control.Concurrent.threadWaitWrite_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SdWuv_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.425076883 UTC

[section ""data" . Control.Concurrent.threadWaitReadSTM_closure" {
     Control.Concurrent.threadWaitReadSTM_closure:
         const Control.Concurrent.threadWaitReadSTM_info;
         const 0;
 },
 Control.Concurrent.threadWaitReadSTM_entry() //  [R2]
         { []
         }
     {offset
       cdX5K: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitReadSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.threadWaitReadSTM_info" {
     Control.Concurrent.threadWaitReadSTM_info:
         const Control.Concurrent.threadWaitReadSTM_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SdWuv_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.428881683 UTC

[section ""data" . Control.Concurrent.threadWaitWriteSTM_closure" {
     Control.Concurrent.threadWaitWriteSTM_closure:
         const Control.Concurrent.threadWaitWriteSTM_info;
         const 0;
 },
 Control.Concurrent.threadWaitWriteSTM_entry() //  [R2]
         { []
         }
     {offset
       cdX5V: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWriteSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.threadWaitWriteSTM_info" {
     Control.Concurrent.threadWaitWriteSTM_info:
         const Control.Concurrent.threadWaitWriteSTM_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SdWuv_srt+24;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.434166954 UTC

[section ""cstring" . Control.Concurrent.$trModule4_bytes" {
     Control.Concurrent.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.436248056 UTC

[section ""data" . Control.Concurrent.$trModule3_closure" {
     Control.Concurrent.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.43810577 UTC

[section ""cstring" . Control.Concurrent.$trModule2_bytes" {
     Control.Concurrent.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116]
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.439831085 UTC

[section ""data" . Control.Concurrent.$trModule1_closure" {
     Control.Concurrent.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.441710158 UTC

[section ""data" . Control.Concurrent.$trModule_closure" {
     Control.Concurrent.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.$trModule3_closure+1;
         const Control.Concurrent.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.444658962 UTC

[section ""data" . Control.Concurrent.rtsSupportsBoundThreads_closure" {
     Control.Concurrent.rtsSupportsBoundThreads_closure:
         const Control.Concurrent.rtsSupportsBoundThreads_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Concurrent.rtsSupportsBoundThreads_entry() //  [R1]
         { []
         }
     {offset
       cdX6i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdX6j; else goto cdX6k;
       cdX6j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdX6k: // global
           (_cdX6a::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdX6a::I64 == 0) goto cdX6c; else goto cdX6b;
       cdX6c: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdX6b: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdX6a::I64;
           (_sdWod::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sdWod::I64 == 0) goto cdX6h; else goto cdX6g;
       cdX6h: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdX6g: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . Control.Concurrent.rtsSupportsBoundThreads_info" {
     Control.Concurrent.rtsSupportsBoundThreads_info:
         const Control.Concurrent.rtsSupportsBoundThreads_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.449418101 UTC

[section ""data" . Control.Concurrent.forkFinally2_closure" {
     Control.Concurrent.forkFinally2_closure:
         const Control.Concurrent.forkFinally2_info;
 },
 Control.Concurrent.forkFinally2_entry() //  [R2]
         { []
         }
     {offset
       cdX6z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX6D; else goto cdX6C;
       cdX6D: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Control.Concurrent.forkFinally2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdX6C: // global
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.forkFinally2_info" {
     Control.Concurrent.forkFinally2_info:
         const Control.Concurrent.forkFinally2_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.470603924 UTC

[section ""data" . Control.Concurrent.runInUnboundThread1_closure" {
     Control.Concurrent.runInUnboundThread1_closure:
         const Control.Concurrent.runInUnboundThread1_info;
         const 0;
 },
 lvl13_sdWou_entry() //  [R1]
         { []
         }
     {offset
       cdX70: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . lvl13_sdWou_info" {
     lvl13_sdWou_info:
         const lvl13_sdWou_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_sdWoE_entry() //  [R1]
         { []
         }
     {offset
       cdX7n: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdX7o; else goto cdX7p;
       cdX7o: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX7p: // global
           I64[Sp - 8] = block_cdX7k_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWoE_info" {
     sat_sdWoE_info:
         const sat_sdWoE_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _cdX7k() //  [R1]
         { []
         }
     {offset
       cdX7k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX7s; else goto cdX7r;
       cdX7s: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdX7r: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdX7k_info" {
     block_cdX7k_info:
         const _cdX7k;
         const 0;
         const 30;
 },
 sat_sdWoJ_entry() //  [R1]
         { []
         }
     {offset
       cdX7x: // global
           _sdWoJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdX7y; else goto cdX7z;
       cdX7z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX7B; else goto cdX7A;
       cdX7B: // global
           HpAlloc = 16;
           goto cdX7y;
       cdX7y: // global
           R1 = _sdWoJ::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX7A: // global
           _sdWoi::P64 = P64[_sdWoJ::P64 + 7];
           _sdWoq::P64 = P64[_sdWoJ::P64 + 15];
           I64[Hp - 8] = sat_sdWoE_info;
           P64[Hp] = _sdWoi::P64;
           I64[Sp - 16] = block_cdX7t_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWoq::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWoJ_info" {
     sat_sdWoJ_info:
         const sat_sdWoJ_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdX7t() //  [R1]
         { []
         }
     {offset
       cdX7t: // global
           _sdWoq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdX7v_info;
           R2 = R1;
           R1 = _sdWoq::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdX7t_info" {
     block_cdX7t_info:
         const _cdX7t;
         const 1;
         const 30;
 },
 _cdX7v() //  []
         { []
         }
     {offset
       cdX7v: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdX7v_info" {
     block_cdX7v_info:
         const _cdX7v;
         const 0;
         const 30;
 },
 sat_sdWoK_entry() //  [R1]
         { []
         }
     {offset
       cdX7E: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdX7I; else goto cdX7H;
       cdX7I: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX7H: // global
           _sdWoi::P64 = P64[R1 + 7];
           _sdWoq::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWoJ_info;
           P64[Hp - 8] = _sdWoi::P64;
           P64[Hp] = _sdWoq::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWoK_info" {
     sat_sdWoK_info:
         const sat_sdWoK_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SdWuv_srt+32;
 },
 sat_sdWoT_entry() //  [R1, R2]
         { []
         }
     {offset
       cdX7X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdX7Y; else goto cdX7Z;
       cdX7Y: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdX7Z: // global
           I64[Sp - 16] = block_cdX7V_info;
           R2 = R2;
           _sdWoO::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdWoO::P64;
           Sp = Sp - 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWoT_info" {
     sat_sdWoT_info:
         const sat_sdWoT_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _cdX7V() //  []
         { []
         }
     {offset
       cdX7V: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call wait_sdWoO_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdX7V_info" {
     block_cdX7V_info:
         const _cdX7V;
         const 1;
         const 30;
 },
 wait_sdWoO_entry() //  [R1]
         { []
         }
     {offset
       cdX81: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdX85; else goto cdX84;
       cdX85: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX84: // global
           _sdWou::P64 = P64[R1 + 7];
           _sdWoN::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWoT_info;
           P64[Hp - 8] = _sdWoN::P64;
           P64[Hp] = R1;
           R2 = Hp - 14;
           R1 = _sdWou::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . wait_sdWoO_info" {
     wait_sdWoO_info:
         const wait_sdWoO_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 sat_sdWp8_entry() //  [R1]
         { []
         }
     {offset
       cdX8u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdX8v; else goto cdX8w;
       cdX8v: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX8w: // global
           I64[Sp - 8] = block_cdX8r_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWp8_info" {
     sat_sdWp8_info:
         const sat_sdWp8_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _cdX8r() //  [R1]
         { []
         }
     {offset
       cdX8r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX8z; else goto cdX8y;
       cdX8z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdX8y: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdX8r_info" {
     block_cdX8r_info:
         const _cdX8r;
         const 0;
         const 30;
 },
 sat_sdWpd_entry() //  [R1]
         { []
         }
     {offset
       cdX8E: // global
           _sdWpd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdX8F; else goto cdX8G;
       cdX8G: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX8I; else goto cdX8H;
       cdX8I: // global
           HpAlloc = 16;
           goto cdX8F;
       cdX8F: // global
           R1 = _sdWpd::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX8H: // global
           _sdWoi::P64 = P64[_sdWpd::P64 + 7];
           _sdWoq::P64 = P64[_sdWpd::P64 + 15];
           I64[Hp - 8] = sat_sdWp8_info;
           P64[Hp] = _sdWoi::P64;
           I64[Sp - 16] = block_cdX8A_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWoq::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWpd_info" {
     sat_sdWpd_info:
         const sat_sdWpd_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdX8A() //  [R1]
         { []
         }
     {offset
       cdX8A: // global
           _sdWoq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdX8C_info;
           R2 = R1;
           R1 = _sdWoq::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdX8A_info" {
     block_cdX8A_info:
         const _cdX8A;
         const 1;
         const 30;
 },
 _cdX8C() //  []
         { []
         }
     {offset
       cdX8C: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdX8C_info" {
     block_cdX8C_info:
         const _cdX8C;
         const 0;
         const 30;
 },
 sat_sdWpe_entry() //  [R1]
         { []
         }
     {offset
       cdX8L: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdX8P; else goto cdX8O;
       cdX8P: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX8O: // global
           _sdWoi::P64 = P64[R1 + 7];
           _sdWoq::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWpd_info;
           P64[Hp - 8] = _sdWoi::P64;
           P64[Hp] = _sdWoq::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWpe_info" {
     sat_sdWpe_info:
         const sat_sdWpe_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SdWuv_srt+32;
 },
 sat_sdWpn_entry() //  [R1, R2]
         { []
         }
     {offset
       cdX94: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdX95; else goto cdX96;
       cdX95: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdX96: // global
           I64[Sp - 16] = block_cdX92_info;
           R2 = R2;
           _sdWpi::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdWpi::P64;
           Sp = Sp - 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWpn_info" {
     sat_sdWpn_info:
         const sat_sdWpn_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _cdX92() //  []
         { []
         }
     {offset
       cdX92: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call wait_sdWpi_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdX92_info" {
     block_cdX92_info:
         const _cdX92;
         const 1;
         const 30;
 },
 wait_sdWpi_entry() //  [R1]
         { []
         }
     {offset
       cdX98: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdX9c; else goto cdX9b;
       cdX9c: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX9b: // global
           _sdWou::P64 = P64[R1 + 7];
           _sdWph::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWpn_info;
           P64[Hp - 8] = _sdWph::P64;
           P64[Hp] = R1;
           R2 = Hp - 14;
           R1 = _sdWou::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . wait_sdWpi_info" {
     wait_sdWpi_info:
         const wait_sdWpi_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 sat_sdWpu_entry() //  [R1]
         { []
         }
     {offset
       cdX9m: // global
           _sdWpu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdX9n; else goto cdX9o;
       cdX9o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdX9q; else goto cdX9p;
       cdX9q: // global
           HpAlloc = 24;
           goto cdX9n;
       cdX9n: // global
           R1 = _sdWpu::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX9p: // global
           _sdWoi::P64 = P64[_sdWpu::P64 + 7];
           _sdWoq::P64 = P64[_sdWpu::P64 + 15];
           _sdWou::P64 = P64[_sdWpu::P64 + 23];
           I64[Hp - 16] = sat_sdWpe_info;
           P64[Hp - 8] = _sdWoi::P64;
           P64[Hp] = _sdWoq::P64;
           I64[Sp - 16] = block_cdX8Q_info;
           R1 = Hp - 15;
           P64[Sp - 8] = _sdWou::P64;
           Sp = Sp - 16;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWpu_info" {
     sat_sdWpu_info:
         const sat_sdWpu_entry;
         const 3;
         const 4294967304;
         const 4294967299;
         const SdWuv_srt+32;
 },
 _cdX8Q() //  [R1]
         { []
         }
     {offset
       cdX8Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdX9t; else goto cdX9s;
       cdX9t: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdX9s: // global
           I64[Hp - 16] = wait_sdWpi_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cdX9d_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call wait_sdWpi_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdX8Q_info" {
     block_cdX8Q_info:
         const _cdX8Q;
         const 1;
         const 30;
 },
 _cdX9d() //  [R1]
         { []
         }
     {offset
       cdX9d: // global
           I64[Sp] = block_cdX9f_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udX9B; else goto cdX9g;
       udX9B: // global
           call _cdX9f(R1) args: 0, res: 0, upd: 0;
       cdX9g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdX9d_info" {
     block_cdX9d_info:
         const _cdX9d;
         const 0;
         const 30;
 },
 _cdX9f() //  [R1]
         { []
         }
     {offset
       cdX9f: // global
           if (R1 & 7 == 1) goto cdX9j; else goto cdX9k;
       cdX9j: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdX9k: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdX9f_info" {
     block_cdX9f_info:
         const _cdX9f;
         const 0;
         const 30;
 },
 sat_sdWpC_entry() //  [R1]
         { []
         }
     {offset
       cdX9V: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdX9W; else goto cdX9X;
       cdX9W: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX9X: // global
           I64[Sp - 8] = block_cdX9S_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWpC_info" {
     sat_sdWpC_info:
         const sat_sdWpC_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _cdX9S() //  [R1]
         { []
         }
     {offset
       cdX9S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXa0; else goto cdX9Z;
       cdXa0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdX9Z: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdX9S_info" {
     block_cdX9S_info:
         const _cdX9S;
         const 0;
         const 30;
 },
 sat_sdWpH_entry() //  [R1]
         { []
         }
     {offset
       cdXa5: // global
           _sdWpH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXa6; else goto cdXa7;
       cdXa7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXa9; else goto cdXa8;
       cdXa9: // global
           HpAlloc = 16;
           goto cdXa6;
       cdXa6: // global
           R1 = _sdWpH::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXa8: // global
           _sdWoi::P64 = P64[_sdWpH::P64 + 7];
           _sdWoq::P64 = P64[_sdWpH::P64 + 15];
           I64[Hp - 8] = sat_sdWpC_info;
           P64[Hp] = _sdWoi::P64;
           I64[Sp - 16] = block_cdXa1_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWoq::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWpH_info" {
     sat_sdWpH_info:
         const sat_sdWpH_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdXa1() //  [R1]
         { []
         }
     {offset
       cdXa1: // global
           _sdWoq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdXa3_info;
           R2 = R1;
           R1 = _sdWoq::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXa1_info" {
     block_cdXa1_info:
         const _cdXa1;
         const 1;
         const 30;
 },
 _cdXa3() //  []
         { []
         }
     {offset
       cdXa3: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXa3_info" {
     block_cdXa3_info:
         const _cdXa3;
         const 0;
         const 30;
 },
 sat_sdWpI_entry() //  [R1]
         { []
         }
     {offset
       cdXac: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXag; else goto cdXaf;
       cdXag: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXaf: // global
           _sdWoi::P64 = P64[R1 + 7];
           _sdWoq::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWpH_info;
           P64[Hp - 8] = _sdWoi::P64;
           P64[Hp] = _sdWoq::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWpI_info" {
     sat_sdWpI_info:
         const sat_sdWpI_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SdWuv_srt+32;
 },
 sat_sdWpR_entry() //  [R1, R2]
         { []
         }
     {offset
       cdXav: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXaw; else goto cdXax;
       cdXaw: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXax: // global
           I64[Sp - 16] = block_cdXat_info;
           R2 = R2;
           _sdWpM::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdWpM::P64;
           Sp = Sp - 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWpR_info" {
     sat_sdWpR_info:
         const sat_sdWpR_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _cdXat() //  []
         { []
         }
     {offset
       cdXat: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call wait_sdWpM_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXat_info" {
     block_cdXat_info:
         const _cdXat;
         const 1;
         const 30;
 },
 wait_sdWpM_entry() //  [R1]
         { []
         }
     {offset
       cdXaz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXaD; else goto cdXaC;
       cdXaD: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXaC: // global
           _sdWou::P64 = P64[R1 + 7];
           _sdWpL::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWpR_info;
           P64[Hp - 8] = _sdWpL::P64;
           P64[Hp] = R1;
           R2 = Hp - 14;
           R1 = _sdWou::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . wait_sdWpM_info" {
     wait_sdWpM_info:
         const wait_sdWpM_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 Control.Concurrent.runInUnboundThread1_entry() //  [R2]
         { []
         }
     {offset
       cdXaH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdXaI; else goto cdXaJ;
       cdXaI: // global
           R2 = R2;
           R1 = Control.Concurrent.runInUnboundThread1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXaJ: // global
           I64[Sp - 16] = block_cdX6N_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_isCurrentThreadBound#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.runInUnboundThread1_info" {
     Control.Concurrent.runInUnboundThread1_info:
         const Control.Concurrent.runInUnboundThread1_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const SdWuv_srt+32;
 },
 _cdX6N() //  [R1]
         { []
         }
     {offset
       cdX6N: // global
           if (R1 == 0) goto cdXaG; else goto cdXaF;
       cdXaG: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       cdXaF: // global
           I64[Sp] = block_cdX6R_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdX6N_info" {
     block_cdX6N_info:
         const _cdX6N;
         const 1;
         const 4294967326;
         const SdWuv_srt+32;
 },
 _cdX6R() //  [R1]
         { []
         }
     {offset
       cdX6R: // global
           I64[Sp - 8] = block_cdX6T_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdX6R_info" {
     block_cdX6R_info:
         const _cdX6R;
         const 1;
         const 4294967326;
         const SdWuv_srt+32;
 },
 _cdX6T() //  [R1]
         { []
         }
     {offset
       cdX6T: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdXaO; else goto cdXaN;
       cdXaO: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXaN: // global
           I64[Hp - 40] = lvl13_sdWou_info;
           _sdWoq::P64 = P64[Sp + 8];
           P64[Hp - 32] = _sdWoq::P64;
           _sdWoi::P64 = P64[Sp + 16];
           _cdX6V::P64 = Hp - 39;
           if (R1 == 0) goto cdXb9; else goto udXbv;
       cdXb9: // global
           I64[Hp - 24] = sat_sdWpu_info;
           P64[Hp - 16] = _sdWoi::P64;
           P64[Hp - 8] = _sdWoq::P64;
           P64[Hp] = _cdX6V::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       udXbv: // global
           if (R1 == 1) goto cdXbd; else goto cdXaT;
       cdXbd: // global
           I64[Hp - 24] = sat_sdWpI_info;
           P64[Hp - 16] = _sdWoi::P64;
           P64[Hp - 8] = _sdWoq::P64;
           _cdX9D::P64 = Hp - 23;
           Hp = Hp - 8;
           I64[Sp + 8] = block_cdXah_info;
           R1 = _cdX9D::P64;
           P64[Sp + 16] = _cdX6V::P64;
           Sp = Sp + 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
       cdXaT: // global
           I64[Hp - 24] = sat_sdWoK_info;
           P64[Hp - 16] = _sdWoi::P64;
           P64[Hp - 8] = _sdWoq::P64;
           _cdX75::P64 = Hp - 23;
           Hp = Hp - 8;
           I64[Sp + 8] = block_cdX7J_info;
           R1 = _cdX75::P64;
           P64[Sp + 16] = _cdX6V::P64;
           Sp = Sp + 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdX6T_info" {
     block_cdX6T_info:
         const _cdX6T;
         const 2;
         const 4294967326;
         const SdWuv_srt+32;
 },
 _cdXah() //  [R1]
         { []
         }
     {offset
       cdXah: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXbg; else goto cdXbf;
       cdXbg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXbf: // global
           I64[Hp - 16] = wait_sdWpM_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cdXba_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call wait_sdWpM_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXah_info" {
     block_cdXah_info:
         const _cdXah;
         const 1;
         const 30;
 },
 _cdXba() //  [R1]
         { []
         }
     {offset
       cdXba: // global
           I64[Sp] = block_cdXbc_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udXbx; else goto cdXbi;
       udXbx: // global
           call _cdXbc(R1) args: 0, res: 0, upd: 0;
       cdXbi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXba_info" {
     block_cdXba_info:
         const _cdXba;
         const 0;
         const 30;
 },
 _cdXbc() //  [R1]
         { []
         }
     {offset
       cdXbc: // global
           if (R1 & 7 == 1) goto cdXbo; else goto cdXbs;
       cdXbo: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXbs: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXbc_info" {
     block_cdXbc_info:
         const _cdXbc;
         const 0;
         const 30;
 },
 _cdX7J() //  [R1]
         { []
         }
     {offset
       cdX7J: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXaW; else goto cdXaV;
       cdXaW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXaV: // global
           I64[Hp - 16] = wait_sdWoO_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cdXaP_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call wait_sdWoO_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdX7J_info" {
     block_cdX7J_info:
         const _cdX7J;
         const 1;
         const 30;
 },
 _cdXaP() //  [R1]
         { []
         }
     {offset
       cdXaP: // global
           I64[Sp] = block_cdXaR_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udXbw; else goto cdXaY;
       udXbw: // global
           call _cdXaR(R1) args: 0, res: 0, upd: 0;
       cdXaY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXaP_info" {
     block_cdXaP_info:
         const _cdXaP;
         const 0;
         const 30;
 },
 _cdXaR() //  [R1]
         { []
         }
     {offset
       cdXaR: // global
           if (R1 & 7 == 1) goto cdXb4; else goto cdXb8;
       cdXb4: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXb8: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXaR_info" {
     block_cdXaR_info:
         const _cdXaR;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.551654056 UTC

[section ""data" . Control.Concurrent.runInUnboundThread_closure" {
     Control.Concurrent.runInUnboundThread_closure:
         const Control.Concurrent.runInUnboundThread_info;
         const 0;
 },
 Control.Concurrent.runInUnboundThread_entry() //  [R2]
         { []
         }
     {offset
       cdXeb: // global
           R2 = R2;
           call Control.Concurrent.runInUnboundThread1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.runInUnboundThread_info" {
     Control.Concurrent.runInUnboundThread_info:
         const Control.Concurrent.runInUnboundThread_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SdWuv_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.555048264 UTC

[section ""cstring" . lvl_rdWnQ_bytes" {
     lvl_rdWnQ_bytes:
         I8[] [82,84,83,32,100,111,101,115,110,39,116,32,115,117,112,112,111,114,116,32,109,117,108,116,105,112,108,101,32,79,83,32,116,104,114,101,97,100,115,32,40,117,115,101,32,103,104,99,32,45,116,104,114,101,97,100,101,100,32,119,104,101,110,32,108,105,110,107,105,110,103,41]
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.558217993 UTC

[section ""data" . Control.Concurrent.forkOS2_closure" {
     Control.Concurrent.forkOS2_closure:
         const Control.Concurrent.forkOS2_info;
         const 0;
 },
 Control.Concurrent.forkOS2_entry() //  []
         { []
         }
     {offset
       cdXep: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXeq; else goto cdXer;
       cdXeq: // global
           R1 = Control.Concurrent.forkOS2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXer: // global
           I64[Sp - 8] = block_cdXen_info;
           R2 = lvl_rdWnQ_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.forkOS2_info" {
     Control.Concurrent.forkOS2_info:
         const Control.Concurrent.forkOS2_entry;
         const 0;
         const 12884901902;
         const 4294967299;
         const SdWuv_srt+48;
 },
 _cdXen() //  [R1]
         { []
         }
     {offset
       cdXen: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXen_info" {
     block_cdXen_info:
         const _cdXen;
         const 0;
         const 4294967326;
         const SdWuv_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.564384663 UTC

[section ""cstring" . lvl1_rdWnR_bytes" {
     lvl1_rdWnR_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.567305425 UTC

[section ""data" . lvl2_rdWnS_closure" {
     lvl2_rdWnS_closure:
         const lvl2_rdWnS_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rdWnS_entry() //  [R1]
         { []
         }
     {offset
       cdXeK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXeL; else goto cdXeM;
       cdXeL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXeM: // global
           (_cdXeH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXeH::I64 == 0) goto cdXeJ; else goto cdXeI;
       cdXeJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXeI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXeH::I64;
           R2 = lvl1_rdWnR_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl2_rdWnS_info" {
     lvl2_rdWnS_info:
         const lvl2_rdWnS_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.572494464 UTC

[section ""data" . lvl3_rdWnT_closure" {
     lvl3_rdWnT_closure:
         const lvl3_rdWnT_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rdWnT_entry() //  [R1]
         { []
         }
     {offset
       cdXf0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXf1; else goto cdXf2;
       cdXf1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXf2: // global
           (_cdXeX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXeX::I64 == 0) goto cdXeZ; else goto cdXeY;
       cdXeZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXeY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXeX::I64;
           R2 = Control.Concurrent.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl3_rdWnT_info" {
     lvl3_rdWnT_info:
         const lvl3_rdWnT_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.578096437 UTC

[section ""data" . lvl4_rdWnU_closure" {
     lvl4_rdWnU_closure:
         const lvl4_rdWnU_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rdWnU_entry() //  [R1]
         { []
         }
     {offset
       cdXfg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXfh; else goto cdXfi;
       cdXfh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXfi: // global
           (_cdXfd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXfd::I64 == 0) goto cdXff; else goto cdXfe;
       cdXff: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXfe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXfd::I64;
           R2 = Control.Concurrent.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl4_rdWnU_info" {
     lvl4_rdWnU_info:
         const lvl4_rdWnU_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.582960919 UTC

[section ""cstring" . lvl5_rdWnV_bytes" {
     lvl5_rdWnV_bytes:
         I8[] [46,47,67,111,110,116,114,111,108,47,67,111,110,99,117,114,114,101,110,116,46,104,115]
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.586146155 UTC

[section ""data" . lvl6_rdWnW_closure" {
     lvl6_rdWnW_closure:
         const lvl6_rdWnW_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rdWnW_entry() //  [R1]
         { []
         }
     {offset
       cdXfx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXfy; else goto cdXfz;
       cdXfy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXfz: // global
           (_cdXfu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXfu::I64 == 0) goto cdXfw; else goto cdXfv;
       cdXfw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXfv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXfu::I64;
           R2 = lvl5_rdWnV_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl6_rdWnW_info" {
     lvl6_rdWnW_info:
         const lvl6_rdWnW_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.589971987 UTC

[section ""data" . lvl7_rdWnX_closure" {
     lvl7_rdWnX_closure:
         const GHC.Types.I#_con_info;
         const 353;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.591757082 UTC

[section ""data" . lvl8_rdWnY_closure" {
     lvl8_rdWnY_closure:
         const GHC.Types.I#_con_info;
         const 33;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.593961688 UTC

[section ""data" . lvl9_rdWnZ_closure" {
     lvl9_rdWnZ_closure:
         const GHC.Types.I#_con_info;
         const 42;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.595822641 UTC

[section ""data" . lvl10_rdWo0_closure" {
     lvl10_rdWo0_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_rdWnT_closure;
         const lvl4_rdWnU_closure;
         const lvl6_rdWnW_closure;
         const lvl7_rdWnX_closure+1;
         const lvl8_rdWnY_closure+1;
         const lvl7_rdWnX_closure+1;
         const lvl9_rdWnZ_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.59781994 UTC

[section ""data" . lvl11_rdWo1_closure" {
     lvl11_rdWo1_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_rdWnS_closure;
         const lvl10_rdWo0_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.600923123 UTC

[section ""data" . Control.Concurrent.runInBoundThread2_closure" {
     Control.Concurrent.runInBoundThread2_closure:
         const Control.Concurrent.runInBoundThread2_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Concurrent.runInBoundThread2_entry() //  [R1]
         { []
         }
     {offset
       cdXfS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXfT; else goto cdXfU;
       cdXfT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXfU: // global
           (_cdXfP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXfP::I64 == 0) goto cdXfR; else goto cdXfQ;
       cdXfR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXfQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXfP::I64;
           R2 = lvl11_rdWo1_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . Control.Concurrent.runInBoundThread2_info" {
     Control.Concurrent.runInBoundThread2_info:
         const Control.Concurrent.runInBoundThread2_entry;
         const 0;
         const 12884901909;
         const SdWuv_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.622143154 UTC

[section ""data" . Control.Concurrent.runInBoundThread1_closure" {
     Control.Concurrent.runInBoundThread1_closure:
         const Control.Concurrent.runInBoundThread1_info;
         const 0;
 },
 sat_sdWqo_entry() //  [R1]
         { []
         }
     {offset
       cdXgx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXgy; else goto cdXgz;
       cdXgy: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXgz: // global
           I64[Sp - 8] = block_cdXgu_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWqo_info" {
     sat_sdWqo_info:
         const sat_sdWqo_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _cdXgu() //  [R1]
         { []
         }
     {offset
       cdXgu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXgC; else goto cdXgB;
       cdXgC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXgB: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXgu_info" {
     block_cdXgu_info:
         const _cdXgu;
         const 0;
         const 30;
 },
 sat_sdWqt_entry() //  [R1]
         { []
         }
     {offset
       cdXgI: // global
           _sdWqt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXgJ; else goto cdXgK;
       cdXgK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXgM; else goto cdXgL;
       cdXgM: // global
           HpAlloc = 16;
           goto cdXgJ;
       cdXgJ: // global
           R1 = _sdWqt::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXgL: // global
           _sdWq0::P64 = P64[_sdWqt::P64 + 7];
           _sdWqd::P64 = P64[_sdWqt::P64 + 15];
           I64[Hp - 8] = sat_sdWqo_info;
           P64[Hp] = _sdWq0::P64;
           I64[Sp - 16] = block_cdXgD_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWqd::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWqt_info" {
     sat_sdWqt_info:
         const sat_sdWqt_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdXgD() //  [R1]
         { []
         }
     {offset
       cdXgD: // global
           _sdWqd::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sdWqd::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sdWqd::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXgD_info" {
     block_cdXgD_info:
         const _cdXgD;
         const 1;
         const 30;
 },
 sat_sdWqI_entry() //  [R1, R2]
         { []
         }
     {offset
       cdXgX: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[R1 + 6]);
           R1 = R2;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWqI_info" {
     sat_sdWqI_info:
         const sat_sdWqI_entry;
         const 4294967296;
         const 10;
         const 8589934597;
 },
 sat_sdWqB_entry() //  [R1]
         { []
         }
     {offset
       cdXha: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXhb; else goto cdXhc;
       cdXhb: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXhc: // global
           I64[Sp - 16] = block_cdXh7_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           _cdXh6::I64 = I64[R1 + 15];
           _udXhg::P64 = CurrentTSO;
           I64[I64[_udXhg::P64 + 24] + 16] = Sp;
           _udXhh::I64 = CurrentNursery;
           P64[_udXhh::I64 + 8] = Hp + 8;
           I64[_udXhg::P64 + 104] = I64[_udXhg::P64 + 104] - ((Hp + 8) - I64[_udXhh::I64]);
           (_udXhe::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] forkOS_entry(_cdXh6::I64);
           (_udXhf::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udXhe::I64);
           BaseReg = _udXhf::I64;
           _udXhi::P64 = CurrentTSO;
           _udXhj::P64 = I64[_udXhi::P64 + 24];
           Sp = I64[_udXhj::P64 + 16];
           SpLim = _udXhj::P64 + 192;
           HpAlloc = 0;
           _udXhk::I64 = CurrentNursery;
           _udXhl::I64 = I64[_udXhk::I64 + 8];
           Hp = _udXhl::I64 - 8;
           _udXhm::I64 = I64[_udXhk::I64];
           HpLim = _udXhm::I64 + ((%MO_SS_Conv_W32_W64(I32[_udXhk::I64 + 48]) << 12) - 1);
           I64[_udXhi::P64 + 104] = I64[_udXhi::P64 + 104] + (_udXhl::I64 - _udXhm::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWqB_info" {
     sat_sdWqB_info:
         const sat_sdWqB_entry;
         const 4294967297;
         const 12;
         const 4294967299;
 },
 _cdXh7() //  []
         { []
         }
     {offset
       cdXh7: // global
           R1 = P64[P64[Sp + 8] + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXh7_info" {
     block_cdXh7_info:
         const _cdXh7;
         const 1;
         const 30;
 },
 sat_sdWqC_entry() //  [R1]
         { []
         }
     {offset
       cdXht: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWqC_info" {
     sat_sdWqC_info:
         const sat_sdWqC_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_sdWqZ_entry() //  [R1]
         { []
         }
     {offset
       cdXhP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXhQ; else goto cdXhR;
       cdXhQ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXhR: // global
           I64[Sp - 8] = block_cdXhM_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWqZ_info" {
     sat_sdWqZ_info:
         const sat_sdWqZ_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _cdXhM() //  [R1]
         { []
         }
     {offset
       cdXhM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXhU; else goto cdXhT;
       cdXhU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXhT: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXhM_info" {
     block_cdXhM_info:
         const _cdXhM;
         const 0;
         const 30;
 },
 sat_sdWr4_entry() //  [R1]
         { []
         }
     {offset
       cdXi0: // global
           _sdWr4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXi1; else goto cdXi2;
       cdXi2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXi4; else goto cdXi3;
       cdXi4: // global
           HpAlloc = 16;
           goto cdXi1;
       cdXi1: // global
           R1 = _sdWr4::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXi3: // global
           _sdWq0::P64 = P64[_sdWr4::P64 + 7];
           _sdWqd::P64 = P64[_sdWr4::P64 + 15];
           I64[Hp - 8] = sat_sdWqZ_info;
           P64[Hp] = _sdWq0::P64;
           I64[Sp - 16] = block_cdXhV_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWqd::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWr4_info" {
     sat_sdWr4_info:
         const sat_sdWr4_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdXhV() //  [R1]
         { []
         }
     {offset
       cdXhV: // global
           _sdWqd::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sdWqd::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sdWqd::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXhV_info" {
     block_cdXhV_info:
         const _cdXhV;
         const 1;
         const 30;
 },
 sat_sdWrj_entry() //  [R1, R2]
         { []
         }
     {offset
       cdXif: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[R1 + 6]);
           R1 = R2;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWrj_info" {
     sat_sdWrj_info:
         const sat_sdWrj_entry;
         const 4294967296;
         const 10;
         const 8589934597;
 },
 sat_sdWrc_entry() //  [R1]
         { []
         }
     {offset
       cdXis: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXit; else goto cdXiu;
       cdXit: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXiu: // global
           I64[Sp - 16] = block_cdXip_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           _cdXio::I64 = I64[R1 + 15];
           _udXiy::P64 = CurrentTSO;
           I64[I64[_udXiy::P64 + 24] + 16] = Sp;
           _udXiz::I64 = CurrentNursery;
           P64[_udXiz::I64 + 8] = Hp + 8;
           I64[_udXiy::P64 + 104] = I64[_udXiy::P64 + 104] - ((Hp + 8) - I64[_udXiz::I64]);
           (_udXiw::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] forkOS_entry(_cdXio::I64);
           (_udXix::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udXiw::I64);
           BaseReg = _udXix::I64;
           _udXiA::P64 = CurrentTSO;
           _udXiB::P64 = I64[_udXiA::P64 + 24];
           Sp = I64[_udXiB::P64 + 16];
           SpLim = _udXiB::P64 + 192;
           HpAlloc = 0;
           _udXiC::I64 = CurrentNursery;
           _udXiD::I64 = I64[_udXiC::I64 + 8];
           Hp = _udXiD::I64 - 8;
           _udXiE::I64 = I64[_udXiC::I64];
           HpLim = _udXiE::I64 + ((%MO_SS_Conv_W32_W64(I32[_udXiC::I64 + 48]) << 12) - 1);
           I64[_udXiA::P64 + 104] = I64[_udXiA::P64 + 104] + (_udXiD::I64 - _udXiE::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWrc_info" {
     sat_sdWrc_info:
         const sat_sdWrc_entry;
         const 4294967297;
         const 12;
         const 4294967299;
 },
 _cdXip() //  []
         { []
         }
     {offset
       cdXip: // global
           R1 = P64[P64[Sp + 8] + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXip_info" {
     block_cdXip_info:
         const _cdXip;
         const 1;
         const 30;
 },
 sat_sdWrd_entry() //  [R1]
         { []
         }
     {offset
       cdXiL: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWrd_info" {
     sat_sdWrd_info:
         const sat_sdWrd_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_sdWrq_entry() //  [R1]
         { []
         }
     {offset
       cdXiS: // global
           _sdWrq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXiT; else goto cdXiU;
       cdXiU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXiW; else goto cdXiV;
       cdXiW: // global
           HpAlloc = 24;
           goto cdXiT;
       cdXiT: // global
           R1 = _sdWrq::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXiV: // global
           _sdWq0::P64 = P64[_sdWrq::P64 + 7];
           _sdWqd::P64 = P64[_sdWrq::P64 + 15];
           I64[Hp - 16] = sat_sdWr4_info;
           P64[Hp - 8] = _sdWq0::P64;
           P64[Hp] = _sdWqd::P64;
           I64[Sp - 16] = block_cdXi6_info;
           R1 = Hp - 15;
           P64[Sp - 8] = _sdWqd::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWrq_info" {
     sat_sdWrq_info:
         const sat_sdWrq_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdXi6() //  [R1]
         { []
         }
     {offset
       cdXi6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdXiZ; else goto cdXiY;
       cdXiZ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXiY: // global
           I64[Hp - 48] = sat_sdWrj_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdWrc_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdWrd_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cdXiO_info;
           R2 = Hp - 46;
           _sdWr7::I64 = R1;
           R1 = Hp - 7;
           I64[Sp + 8] = _sdWr7::I64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXi6_info" {
     block_cdXi6_info:
         const _cdXi6;
         const 1;
         const 30;
 },
 _cdXiO() //  [R1]
         { []
         }
     {offset
       cdXiO: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXiO_info" {
     block_cdXiO_info:
         const _cdXiO;
         const 65;
         const 30;
 },
 sat_sdWrD_entry() //  [R1]
         { []
         }
     {offset
       cdXjf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXjg; else goto cdXjh;
       cdXjg: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXjh: // global
           I64[Sp - 8] = block_cdXjc_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWrD_info" {
     sat_sdWrD_info:
         const sat_sdWrD_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _cdXjc() //  [R1]
         { []
         }
     {offset
       cdXjc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXjk; else goto cdXjj;
       cdXjk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXjj: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXjc_info" {
     block_cdXjc_info:
         const _cdXjc;
         const 0;
         const 30;
 },
 sat_sdWrI_entry() //  [R1]
         { []
         }
     {offset
       cdXjq: // global
           _sdWrI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXjr; else goto cdXjs;
       cdXjs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXju; else goto cdXjt;
       cdXju: // global
           HpAlloc = 16;
           goto cdXjr;
       cdXjr: // global
           R1 = _sdWrI::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXjt: // global
           _sdWq0::P64 = P64[_sdWrI::P64 + 7];
           _sdWqd::P64 = P64[_sdWrI::P64 + 15];
           I64[Hp - 8] = sat_sdWrD_info;
           P64[Hp] = _sdWq0::P64;
           I64[Sp - 16] = block_cdXjl_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWqd::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWrI_info" {
     sat_sdWrI_info:
         const sat_sdWrI_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdXjl() //  [R1]
         { []
         }
     {offset
       cdXjl: // global
           _sdWqd::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sdWqd::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sdWqd::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXjl_info" {
     block_cdXjl_info:
         const _cdXjl;
         const 1;
         const 30;
 },
 sat_sdWrX_entry() //  [R1, R2]
         { []
         }
     {offset
       cdXjF: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[R1 + 6]);
           R1 = R2;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWrX_info" {
     sat_sdWrX_info:
         const sat_sdWrX_entry;
         const 4294967296;
         const 10;
         const 8589934597;
 },
 sat_sdWrQ_entry() //  [R1]
         { []
         }
     {offset
       cdXjS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXjT; else goto cdXjU;
       cdXjT: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXjU: // global
           I64[Sp - 16] = block_cdXjP_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           _cdXjO::I64 = I64[R1 + 15];
           _udXjY::P64 = CurrentTSO;
           I64[I64[_udXjY::P64 + 24] + 16] = Sp;
           _udXjZ::I64 = CurrentNursery;
           P64[_udXjZ::I64 + 8] = Hp + 8;
           I64[_udXjY::P64 + 104] = I64[_udXjY::P64 + 104] - ((Hp + 8) - I64[_udXjZ::I64]);
           (_udXjW::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] forkOS_entry(_cdXjO::I64);
           (_udXjX::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udXjW::I64);
           BaseReg = _udXjX::I64;
           _udXk0::P64 = CurrentTSO;
           _udXk1::P64 = I64[_udXk0::P64 + 24];
           Sp = I64[_udXk1::P64 + 16];
           SpLim = _udXk1::P64 + 192;
           HpAlloc = 0;
           _udXk2::I64 = CurrentNursery;
           _udXk3::I64 = I64[_udXk2::I64 + 8];
           Hp = _udXk3::I64 - 8;
           _udXk4::I64 = I64[_udXk2::I64];
           HpLim = _udXk4::I64 + ((%MO_SS_Conv_W32_W64(I32[_udXk2::I64 + 48]) << 12) - 1);
           I64[_udXk0::P64 + 104] = I64[_udXk0::P64 + 104] + (_udXk3::I64 - _udXk4::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWrQ_info" {
     sat_sdWrQ_info:
         const sat_sdWrQ_entry;
         const 4294967297;
         const 12;
         const 4294967299;
 },
 _cdXjP() //  []
         { []
         }
     {offset
       cdXjP: // global
           R1 = P64[P64[Sp + 8] + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXjP_info" {
     block_cdXjP_info:
         const _cdXjP;
         const 1;
         const 30;
 },
 sat_sdWrR_entry() //  [R1]
         { []
         }
     {offset
       cdXkb: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWrR_info" {
     sat_sdWrR_info:
         const sat_sdWrR_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 Control.Concurrent.runInBoundThread1_entry() //  [R2]
         { []
         }
     {offset
       cdXkh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdXki; else goto cdXkj;
       cdXki: // global
           R2 = R2;
           R1 = Control.Concurrent.runInBoundThread1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXkj: // global
           (_sdWq5::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sdWq5::I64 == 0) goto cdXkg; else goto cdXkf;
       cdXkg: // global
           call Control.Concurrent.forkOS2_entry() args: 8, res: 0, upd: 8;
       cdXkf: // global
           I64[Sp - 16] = block_cdXg9_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_isCurrentThreadBound#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.runInBoundThread1_info" {
     Control.Concurrent.runInBoundThread1_info:
         const Control.Concurrent.runInBoundThread1_entry;
         const 0;
         const 107374182414;
         const 8589934597;
         const SdWuv_srt+56;
 },
 _cdXg9() //  [R1]
         { []
         }
     {offset
       cdXg9: // global
           if (R1 == 0) goto cdXkn; else goto cdXkm;
       cdXkn: // global
           I64[Sp] = block_cdXge_info;
           R1 = Control.Concurrent.runInBoundThread2_closure;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cdXkm: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXg9_info" {
     block_cdXg9_info:
         const _cdXg9;
         const 1;
         const 4294967326;
         const SdWuv_srt+88;
 },
 _cdXge() //  [R1]
         { []
         }
     {offset
       cdXge: // global
           I64[Sp - 8] = block_cdXgg_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXge_info" {
     block_cdXge_info:
         const _cdXge;
         const 1;
         const 30;
 },
 _cdXgg() //  [R1]
         { []
         }
     {offset
       cdXgg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXkr; else goto cdXkq;
       cdXkr: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXkq: // global
           _sdWq0::P64 = P64[Sp + 16];
           _sdWqd::P64 = P64[Sp + 8];
           if (R1 == 0) goto cdXkR; else goto udXls;
       cdXkR: // global
           I64[Hp - 16] = sat_sdWrq_info;
           P64[Hp - 8] = _sdWq0::P64;
           P64[Hp] = _sdWqd::P64;
           I64[Sp + 16] = block_cdXkO_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
       udXls: // global
           if (R1 == 1) goto cdXl9; else goto cdXky;
       cdXl9: // global
           I64[Hp - 16] = sat_sdWrI_info;
           P64[Hp - 8] = _sdWq0::P64;
           P64[Hp] = _sdWqd::P64;
           I64[Sp] = block_cdXjw_info;
           R1 = Hp - 15;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
       cdXky: // global
           I64[Hp - 16] = sat_sdWqt_info;
           P64[Hp - 8] = _sdWq0::P64;
           P64[Hp] = _sdWqd::P64;
           I64[Sp] = block_cdXgO_info;
           R1 = Hp - 15;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXgg_info" {
     block_cdXgg_info:
         const _cdXgg;
         const 2;
         const 30;
 },
 _cdXkO() //  [R1]
         { []
         }
     {offset
       cdXkO: // global
           I64[Sp] = block_cdXkQ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udXlu; else goto cdXkT;
       udXlu: // global
           call _cdXkQ(R1) args: 0, res: 0, upd: 0;
       cdXkT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXkO_info" {
     block_cdXkO_info:
         const _cdXkO;
         const 0;
         const 30;
 },
 _cdXkQ() //  [R1]
         { []
         }
     {offset
       cdXkQ: // global
           if (R1 & 7 == 1) goto cdXkZ; else goto cdXl3;
       cdXkZ: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXl3: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXkQ_info" {
     block_cdXkQ_info:
         const _cdXkQ;
         const 0;
         const 30;
 },
 _cdXjw() //  [R1]
         { []
         }
     {offset
       cdXjw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdXlc; else goto cdXlb;
       cdXlc: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXlb: // global
           I64[Hp - 48] = sat_sdWrX_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdWrQ_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdWrR_info;
           P64[Hp] = Hp - 31;
           I64[Sp + 8] = block_cdXl4_info;
           R2 = Hp - 46;
           _sdWrL::I64 = R1;
           R1 = Hp - 7;
           I64[Sp + 16] = _sdWrL::I64;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXjw_info" {
     block_cdXjw_info:
         const _cdXjw;
         const 130;
         const 30;
 },
 _cdXl4() //  [R1]
         { []
         }
     {offset
       cdXl4: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           I64[Sp + 8] = block_cdXl8_info;
           R1 = R1;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udXlv; else goto cdXle;
       udXlv: // global
           call _cdXl8(R1) args: 0, res: 0, upd: 0;
       cdXle: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXl4_info" {
     block_cdXl4_info:
         const _cdXl4;
         const 65;
         const 30;
 },
 _cdXl8() //  [R1]
         { []
         }
     {offset
       cdXl8: // global
           if (R1 & 7 == 1) goto cdXlk; else goto cdXlo;
       cdXlk: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXlo: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXl8_info" {
     block_cdXl8_info:
         const _cdXl8;
         const 0;
         const 30;
 },
 _cdXgO() //  [R1]
         { []
         }
     {offset
       cdXgO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdXkB; else goto cdXkA;
       cdXkB: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXkA: // global
           I64[Hp - 48] = sat_sdWqI_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdWqB_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdWqC_info;
           P64[Hp] = Hp - 31;
           I64[Sp + 8] = block_cdXks_info;
           R2 = Hp - 46;
           _sdWqw::I64 = R1;
           R1 = Hp - 7;
           I64[Sp + 16] = _sdWqw::I64;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXgO_info" {
     block_cdXgO_info:
         const _cdXgO;
         const 130;
         const 30;
 },
 _cdXks() //  [R1]
         { []
         }
     {offset
       cdXks: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           I64[Sp + 8] = block_cdXkw_info;
           R1 = R1;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udXlt; else goto cdXkD;
       udXlt: // global
           call _cdXkw(R1) args: 0, res: 0, upd: 0;
       cdXkD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXks_info" {
     block_cdXks_info:
         const _cdXks;
         const 65;
         const 30;
 },
 _cdXkw() //  [R1]
         { []
         }
     {offset
       cdXkw: // global
           if (R1 & 7 == 1) goto cdXkJ; else goto cdXkN;
       cdXkJ: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXkN: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXkw_info" {
     block_cdXkw_info:
         const _cdXkw;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.707566542 UTC

[section ""data" . Control.Concurrent.runInBoundThread_closure" {
     Control.Concurrent.runInBoundThread_closure:
         const Control.Concurrent.runInBoundThread_info;
         const 0;
 },
 Control.Concurrent.runInBoundThread_entry() //  [R2]
         { []
         }
     {offset
       cdXoZ: // global
           R2 = R2;
           call Control.Concurrent.runInBoundThread1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.runInBoundThread_info" {
     Control.Concurrent.runInBoundThread_info:
         const Control.Concurrent.runInBoundThread_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SdWuv_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.719608144 UTC

[section ""data" . Control.Concurrent.forkFinally1_closure" {
     Control.Concurrent.forkFinally1_closure:
         const Control.Concurrent.forkFinally1_info;
         const 0;
 },
 sat_sdWsl_entry() //  [R1]
         { []
         }
     {offset
       cdXpw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXpx; else goto cdXpy;
       cdXpx: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXpy: // global
           I64[Sp - 8] = block_cdXpt_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWsl_info" {
     sat_sdWsl_info:
         const sat_sdWsl_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _cdXpt() //  [R1]
         { []
         }
     {offset
       cdXpt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXpB; else goto cdXpA;
       cdXpB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXpA: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXpt_info" {
     block_cdXpt_info:
         const _cdXpt;
         const 0;
         const 30;
 },
 sat_sdWsp_entry() //  [R1]
         { []
         }
     {offset
       cdXpE: // global
           _sdWsp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXpF; else goto cdXpG;
       cdXpG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXpI; else goto cdXpH;
       cdXpI: // global
           HpAlloc = 16;
           goto cdXpF;
       cdXpF: // global
           R1 = _sdWsp::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXpH: // global
           _sdWs7::P64 = P64[_sdWsp::P64 + 7];
           _sdWs8::P64 = P64[_sdWsp::P64 + 15];
           I64[Hp - 8] = sat_sdWsl_info;
           P64[Hp] = _sdWs7::P64;
           I64[Sp - 16] = block_cdXpC_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWs8::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWsp_info" {
     sat_sdWsp_info:
         const sat_sdWsp_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdXpC() //  [R1]
         { []
         }
     {offset
       cdXpC: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXpC_info" {
     block_cdXpC_info:
         const _cdXpC;
         const 1;
         const 30;
 },
 sat_sdWsq_entry() //  [R1]
         { []
         }
     {offset
       cdXpK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXpO; else goto cdXpN;
       cdXpO: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXpN: // global
           _sdWs7::P64 = P64[R1 + 7];
           _sdWs8::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWsp_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWsq_info" {
     sat_sdWsq_info:
         const sat_sdWsq_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SdWuv_srt+32;
 },
 sat_sdWsD_entry() //  [R1]
         { []
         }
     {offset
       cdXqd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXqe; else goto cdXqf;
       cdXqe: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXqf: // global
           I64[Sp - 8] = block_cdXqa_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWsD_info" {
     sat_sdWsD_info:
         const sat_sdWsD_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _cdXqa() //  [R1]
         { []
         }
     {offset
       cdXqa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXqi; else goto cdXqh;
       cdXqi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXqh: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXqa_info" {
     block_cdXqa_info:
         const _cdXqa;
         const 0;
         const 30;
 },
 sat_sdWsH_entry() //  [R1]
         { []
         }
     {offset
       cdXql: // global
           _sdWsH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXqm; else goto cdXqn;
       cdXqn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXqp; else goto cdXqo;
       cdXqp: // global
           HpAlloc = 16;
           goto cdXqm;
       cdXqm: // global
           R1 = _sdWsH::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXqo: // global
           _sdWs7::P64 = P64[_sdWsH::P64 + 7];
           _sdWs8::P64 = P64[_sdWsH::P64 + 15];
           I64[Hp - 8] = sat_sdWsD_info;
           P64[Hp] = _sdWs7::P64;
           I64[Sp - 16] = block_cdXqj_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWs8::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWsH_info" {
     sat_sdWsH_info:
         const sat_sdWsH_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdXqj() //  [R1]
         { []
         }
     {offset
       cdXqj: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXqj_info" {
     block_cdXqj_info:
         const _cdXqj;
         const 1;
         const 30;
 },
 sat_sdWsI_entry() //  [R1]
         { []
         }
     {offset
       cdXqr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXqv; else goto cdXqu;
       cdXqv: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXqu: // global
           _sdWs7::P64 = P64[R1 + 7];
           _sdWs8::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWsH_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWsI_info" {
     sat_sdWsI_info:
         const sat_sdWsI_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SdWuv_srt+32;
 },
 sat_sdWsN_entry() //  [R1]
         { []
         }
     {offset
       cdXqz: // global
           _sdWsN::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdXqA; else goto cdXqB;
       cdXqB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXqD; else goto cdXqC;
       cdXqD: // global
           HpAlloc = 24;
           goto cdXqA;
       cdXqA: // global
           R1 = _sdWsN::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXqC: // global
           _sdWs7::P64 = P64[_sdWsN::P64 + 7];
           _sdWs8::P64 = P64[_sdWsN::P64 + 15];
           I64[Hp - 16] = sat_sdWsI_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           I64[Sp - 8] = block_cdXqw_info;
           R1 = Hp - 15;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWsN_info" {
     sat_sdWsN_info:
         const sat_sdWsN_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SdWuv_srt+32;
 },
 _cdXqw() //  [R1]
         { []
         }
     {offset
       cdXqw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXqG; else goto cdXqF;
       cdXqG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXqF: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXqw_info" {
     block_cdXqw_info:
         const _cdXqw;
         const 0;
         const 30;
 },
 sat_sdWsV_entry() //  [R1]
         { []
         }
     {offset
       cdXr0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXr1; else goto cdXr2;
       cdXr1: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXr2: // global
           I64[Sp - 8] = block_cdXqX_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWsV_info" {
     sat_sdWsV_info:
         const sat_sdWsV_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _cdXqX() //  [R1]
         { []
         }
     {offset
       cdXqX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXr5; else goto cdXr4;
       cdXr5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXr4: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXqX_info" {
     block_cdXqX_info:
         const _cdXqX;
         const 0;
         const 30;
 },
 sat_sdWsZ_entry() //  [R1]
         { []
         }
     {offset
       cdXr8: // global
           _sdWsZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXr9; else goto cdXra;
       cdXra: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXrc; else goto cdXrb;
       cdXrc: // global
           HpAlloc = 16;
           goto cdXr9;
       cdXr9: // global
           R1 = _sdWsZ::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXrb: // global
           _sdWs7::P64 = P64[_sdWsZ::P64 + 7];
           _sdWs8::P64 = P64[_sdWsZ::P64 + 15];
           I64[Hp - 8] = sat_sdWsV_info;
           P64[Hp] = _sdWs7::P64;
           I64[Sp - 16] = block_cdXr6_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWs8::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWsZ_info" {
     sat_sdWsZ_info:
         const sat_sdWsZ_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdXr6() //  [R1]
         { []
         }
     {offset
       cdXr6: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXr6_info" {
     block_cdXr6_info:
         const _cdXr6;
         const 1;
         const 30;
 },
 sat_sdWt0_entry() //  [R1]
         { []
         }
     {offset
       cdXre: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXri; else goto cdXrh;
       cdXri: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXrh: // global
           _sdWs7::P64 = P64[R1 + 7];
           _sdWs8::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWsZ_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWt0_info" {
     sat_sdWt0_info:
         const sat_sdWt0_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SdWuv_srt+32;
 },
 Control.Concurrent.forkFinally1_entry() //  [R2, R3]
         { []
         }
     {offset
       cdXrn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdXro; else goto cdXrp;
       cdXro: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.forkFinally1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdXrp: // global
           I64[Sp - 24] = block_cdXpa_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.forkFinally1_info" {
     Control.Concurrent.forkFinally1_info:
         const Control.Concurrent.forkFinally1_entry;
         const 0;
         const 1103806595086;
         const 12884901903;
         const SdWuv_srt+32;
 },
 _cdXpa() //  [R1]
         { []
         }
     {offset
       cdXpa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXrs; else goto cdXrr;
       cdXrs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXrr: // global
           _sdWs7::P64 = P64[Sp + 8];
           _sdWs8::P64 = P64[Sp + 16];
           if (R1 == 0) goto cdXrl; else goto udXrF;
       cdXrl: // global
           I64[Hp - 16] = sat_sdWsN_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       udXrF: // global
           if (R1 == 1) goto cdXrm; else goto cdXrk;
       cdXrm: // global
           I64[Hp - 16] = sat_sdWt0_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           I64[Sp + 16] = block_cdXrz_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
       cdXrk: // global
           I64[Hp - 16] = sat_sdWsq_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           I64[Sp + 16] = block_cdXrt_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXpa_info" {
     block_cdXpa_info:
         const _cdXpa;
         const 2;
         const 4294967326;
         const SdWuv_srt+32;
 },
 _cdXrz() //  [R1]
         { []
         }
     {offset
       cdXrz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXrE; else goto cdXrD;
       cdXrE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXrD: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXrz_info" {
     block_cdXrz_info:
         const _cdXrz;
         const 0;
         const 30;
 },
 _cdXrt() //  [R1]
         { []
         }
     {offset
       cdXrt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXry; else goto cdXrx;
       cdXry: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXrx: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXrt_info" {
     block_cdXrt_info:
         const _cdXrt;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.765192761 UTC

[section ""data" . Control.Concurrent.forkFinally_closure" {
     Control.Concurrent.forkFinally_closure:
         const Control.Concurrent.forkFinally_info;
         const 0;
 },
 Control.Concurrent.forkFinally_entry() //  [R2, R3]
         { []
         }
     {offset
       cdXt0: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.forkFinally1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.forkFinally_info" {
     Control.Concurrent.forkFinally_info:
         const Control.Concurrent.forkFinally_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const SdWuv_srt+96;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.768611234 UTC

[section ""cstring" . lvl12_rdWo2_bytes" {
     lvl12_rdWo2_bytes:
         I8[] [67,97,110,110,111,116,32,99,114,101,97,116,101,32,79,83,32,116,104,114,101,97,100,46]
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.771154307 UTC

[section ""data" . Control.Concurrent.forkOS3_closure" {
     Control.Concurrent.forkOS3_closure:
         const Control.Concurrent.forkOS3_info;
         const 0;
 },
 Control.Concurrent.forkOS3_entry() //  []
         { []
         }
     {offset
       cdXte: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXtf; else goto cdXtg;
       cdXtf: // global
           R1 = Control.Concurrent.forkOS3_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXtg: // global
           I64[Sp - 8] = block_cdXtc_info;
           R2 = lvl12_rdWo2_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.forkOS3_info" {
     Control.Concurrent.forkOS3_info:
         const Control.Concurrent.forkOS3_entry;
         const 0;
         const 554050781198;
         const 4294967299;
         const SdWuv_srt+48;
 },
 _cdXtc() //  [R1]
         { []
         }
     {offset
       cdXtc: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXtc_info" {
     block_cdXtc_info:
         const _cdXtc;
         const 0;
         const 4294967326;
         const SdWuv_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.780835166 UTC

[section ""data" . Control.Concurrent.forkOS1_closure" {
     Control.Concurrent.forkOS1_closure:
         const Control.Concurrent.forkOS1_info;
         const 0;
 },
 sat_sdWtr_entry() //  [R1]
         { []
         }
     {offset
       cdXtX: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWtr_info" {
     sat_sdWtr_info:
         const sat_sdWtr_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_sdWts_entry() //  [R1]
         { []
         }
     {offset
       cdXu4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXu8; else goto cdXu7;
       cdXu8: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXu7: // global
           _sdWt7::P64 = P64[R1 + 16];
           _sdWtq::I64 = I64[R1 + 24];
           if (_sdWtq::I64 != 0) goto udXu9; else goto cdXu2;
       udXu9: // global
           if (_sdWtq::I64 != 1) goto cdXu1; else goto cdXu3;
       cdXu1: // global
           Hp = Hp - 16;
           R1 = _sdWt7::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdXu3: // global
           Hp = Hp - 16;
           R2 = _sdWt7::P64;
           R1 = GHC.IO.uninterruptibleMask_1_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cdXu2: // global
           I64[Hp - 8] = sat_sdWtr_info;
           P64[Hp] = _sdWt7::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWts_info" {
     sat_sdWts_info:
         const sat_sdWts_entry;
         const 4294967297;
         const 19;
 },
 sat_sdWtt_entry() //  [R1]
         { []
         }
     {offset
       cdXua: // global
           _sdWtt::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdXub; else goto cdXuc;
       cdXuc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXue; else goto cdXud;
       cdXue: // global
           HpAlloc = 16;
           goto cdXub;
       cdXub: // global
           R1 = _sdWtt::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXud: // global
           _sdWt7::P64 = P64[_sdWtt::P64 + 7];
           _sdWtg::P64 = P64[_sdWtt::P64 + 15];
           _sdWtj::I64 = I64[_sdWtt::P64 + 23];
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           I64[Hp] = CurrentTSO;
           I64[Sp - 24] = block_cdXtJ_info;
           R2 = Hp - 7;
           R1 = _sdWtg::P64;
           P64[Sp - 16] = _sdWt7::P64;
           I64[Sp - 8] = _sdWtj::I64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWtt_info" {
     sat_sdWtt_info:
         const sat_sdWtt_entry;
         const 4294967298;
         const 4294967304;
         const 4294967299;
         const SdWuv_srt+112;
 },
 _cdXtJ() //  []
         { []
         }
     {offset
       cdXtJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdXuh; else goto cdXug;
       cdXuh: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdXug: // global
           I64[Hp - 24] = sat_sdWts_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R2 = GHC.Conc.Sync.childHandler1_closure+2;
           R1 = Hp - 24;
           Sp = Sp + 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXtJ_info" {
     block_cdXtJ_info:
         const _cdXtJ;
         const 130;
         const 4294967326;
         const SdWuv_srt+112;
 },
 Control.Concurrent.forkOS1_entry() //  [R2]
         { []
         }
     {offset
       cdXul: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdXum; else goto cdXun;
       cdXum: // global
           R2 = R2;
           R1 = Control.Concurrent.forkOS1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXun: // global
           (_sdWtc::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sdWtc::I64 == 0) goto cdXuk; else goto cdXuj;
       cdXuk: // global
           call Control.Concurrent.forkOS2_entry() args: 8, res: 0, upd: 8;
       cdXuj: // global
           I64[Sp - 16] = block_cdXtz_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.forkOS1_info" {
     Control.Concurrent.forkOS1_info:
         const Control.Concurrent.forkOS1_entry;
         const 0;
         const 1928440315918;
         const 8589934597;
         const SdWuv_srt+56;
 },
 _cdXtz() //  [R1]
         { []
         }
     {offset
       cdXtz: // global
           I64[Sp - 8] = block_cdXtB_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXtz_info" {
     block_cdXtz_info:
         const _cdXtz;
         const 1;
         const 12884901918;
         const SdWuv_srt+104;
 },
 _cdXtB() //  [R1]
         { []
         }
     {offset
       cdXtB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdXus; else goto cdXur;
       cdXus: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXur: // global
           I64[Hp - 24] = sat_sdWtt_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = R1;
           I64[Sp] = block_cdXuo_info;
           R1 = Hp - 23;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXtB_info" {
     block_cdXtB_info:
         const _cdXtB;
         const 2;
         const 12884901918;
         const SdWuv_srt+104;
 },
 _cdXuo() //  [R1]
         { []
         }
     {offset
       cdXuo: // global
           I64[Sp] = block_cdXux_info;
           I64[Sp + 16] = R1;
           _udXuW::P64 = CurrentTSO;
           I64[I64[_udXuW::P64 + 24] + 16] = Sp;
           _udXuX::I64 = CurrentNursery;
           P64[_udXuX::I64 + 8] = Hp + 8;
           I64[_udXuW::P64 + 104] = I64[_udXuW::P64 + 104] - ((Hp + 8) - I64[_udXuX::I64]);
           (_udXuU::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sdWtA::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [‘signed’] forkOS_createThread(R1);
           (_udXuV::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udXuU::I64);
           BaseReg = _udXuV::I64;
           _udXuY::P64 = CurrentTSO;
           _udXuZ::P64 = I64[_udXuY::P64 + 24];
           Sp = I64[_udXuZ::P64 + 16];
           SpLim = _udXuZ::P64 + 192;
           HpAlloc = 0;
           _udXv0::I64 = CurrentNursery;
           _udXv1::I64 = I64[_udXv0::I64 + 8];
           Hp = _udXv1::I64 - 8;
           _udXv2::I64 = I64[_udXv0::I64];
           HpLim = _udXv2::I64 + ((%MO_SS_Conv_W32_W64(I32[_udXv0::I64 + 48]) << 12) - 1);
           I64[_udXuY::P64 + 104] = I64[_udXuY::P64 + 104] + (_udXv1::I64 - _udXv2::I64);
           R1 = _sdWtA::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXuo_info" {
     block_cdXuo_info:
         const _cdXuo;
         const 130;
         const 4294967326;
         const SdWuv_srt+104;
 },
 _cdXux() //  [R1]
         { []
         }
     {offset
       cdXux: // global
           if (%MO_SS_Conv_W64_W32(R1) == 0 :: W32) goto cdXuO; else goto cdXuF;
       cdXuO: // global
           _sdWtg::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdXuN_info;
           R1 = _sdWtg::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdXuF: // global
           Sp = Sp + 24;
           call Control.Concurrent.forkOS3_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXux_info" {
     block_cdXux_info:
         const _cdXux;
         const 130;
         const 4294967326;
         const SdWuv_srt+104;
 },
 _cdXuN() //  [R1]
         { []
         }
     {offset
       cdXuN: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXuN_info" {
     block_cdXuN_info:
         const _cdXuN;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.80232648 UTC

[section ""data" . Control.Concurrent.forkOS_closure" {
     Control.Concurrent.forkOS_closure:
         const Control.Concurrent.forkOS_info;
         const 0;
 },
 Control.Concurrent.forkOS_entry() //  [R2]
         { []
         }
     {offset
       cdXw1: // global
           R2 = R2;
           call Control.Concurrent.forkOS1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.forkOS_info" {
     Control.Concurrent.forkOS_info:
         const Control.Concurrent.forkOS_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SdWuv_srt+120;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.806868208 UTC

[section ""data" . Control.Concurrent.forkOSWithUnmask1_closure" {
     Control.Concurrent.forkOSWithUnmask1_closure:
         const Control.Concurrent.forkOSWithUnmask1_info;
         const 0;
 },
 sat_sdWtL_entry() //  [R2]
         { []
         }
     {offset
       cdXwl: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdWtL_info" {
     sat_sdWtL_info:
         const sat_sdWtL_entry;
         const 4294967296;
         const 10;
         const 8589934597;
 },
 sat_sdWtM_entry() //  [R1]
         { []
         }
     {offset
       cdXwo: // global
           _sdWtM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXwp; else goto cdXwq;
       cdXwq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXws; else goto cdXwr;
       cdXws: // global
           HpAlloc = 16;
           goto cdXwp;
       cdXwp: // global
           R1 = _sdWtM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXwr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdWtM::P64;
           _sdWtJ::P64 = P64[_sdWtM::P64 + 16];
           I64[Hp - 8] = sat_sdWtL_info;
           R2 = Hp - 6;
           R1 = _sdWtJ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdWtM_info" {
     sat_sdWtM_info:
         const sat_sdWtM_entry;
         const 1;
         const 16;
 },
 Control.Concurrent.forkOSWithUnmask1_entry() //  [R2]
         { []
         }
     {offset
       cdXwt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXwx; else goto cdXww;
       cdXwx: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Concurrent.forkOSWithUnmask1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXww: // global
           I64[Hp - 16] = sat_sdWtM_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Concurrent.forkOS1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.forkOSWithUnmask1_info" {
     Control.Concurrent.forkOSWithUnmask1_info:
         const Control.Concurrent.forkOSWithUnmask1_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const SdWuv_srt+120;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.814618187 UTC

[section ""data" . Control.Concurrent.forkOSWithUnmask_closure" {
     Control.Concurrent.forkOSWithUnmask_closure:
         const Control.Concurrent.forkOSWithUnmask_info;
         const 0;
 },
 Control.Concurrent.forkOSWithUnmask_entry() //  [R2]
         { []
         }
     {offset
       cdXwN: // global
           R2 = R2;
           call Control.Concurrent.forkOSWithUnmask1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.forkOSWithUnmask_info" {
     Control.Concurrent.forkOSWithUnmask_info:
         const Control.Concurrent.forkOSWithUnmask_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SdWuv_srt+128;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.818994136 UTC

[section ""data" . Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_closure" {
     Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_closure:
         const Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_info;
 },
 Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_entry() //  [R2]
         { []
         }
     {offset
       cdXx1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXx5; else goto cdXx6;
       cdXx5: // global
           R2 = R2;
           R1 = Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXx6: // global
           I64[Sp - 8] = block_cdXwY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udXxa; else goto cdXwZ;
       udXxa: // global
           call _cdXwY(R1) args: 0, res: 0, upd: 0;
       cdXwZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_info" {
     Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_info:
         const Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cdXwY() //  [R1]
         { []
         }
     {offset
       cdXwY: // global
           I64[Sp] = block_cdXx4_info;
           R1 = I64[R1 + 7];
           call stg_deRefStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXwY_info" {
     block_cdXwY_info:
         const _cdXwY;
         const 0;
         const 30;
 },
 _cdXx4() //  [R1]
         { []
         }
     {offset
       cdXx4: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXx4_info" {
     block_cdXx4_info:
         const _cdXx4;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.826049553 UTC

[section ""data" . Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_closure" {
     Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_closure:
         const Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_info;
 },
 Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_entry() //  [R2]
         { []
         }
     {offset
       cdXxr: // global
           R2 = R2;
           call Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_info" {
     Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_info:
         const Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:12.829465144 UTC

[section ""relreadonly" . SdWuv_srt" {
     SdWuv_srt:
         const GHC.Conc.IO.threadWaitRead1_closure;
         const GHC.Conc.IO.threadWaitWrite1_closure;
         const GHC.Conc.IO.threadWaitReadSTM1_closure;
         const GHC.Conc.IO.threadWaitWriteSTM1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const Control.Concurrent.runInUnboundThread1_closure;
         const GHC.IO.failIO1_closure;
         const Control.Concurrent.forkOS2_closure;
         const GHC.Err.undefined_closure;
         const lvl11_rdWo1_closure;
         const Control.Concurrent.runInBoundThread1_closure;
         const Control.Concurrent.runInBoundThread2_closure;
         const Control.Concurrent.forkFinally1_closure;
         const Control.Concurrent.forkOS3_closure;
         const GHC.Conc.Sync.childHandler1_closure;
         const Control.Concurrent.forkOS1_closure;
         const Control.Concurrent.forkOSWithUnmask1_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:14.900587061 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:09:14.903042461 UTC

[section ""data" . Control.Concurrent.isCurrentThreadBound1_closure" {
     Control.Concurrent.isCurrentThreadBound1_closure:
         const Control.Concurrent.isCurrentThreadBound1_info;
 },
 sat_sdXxE_entry() //  [R1]
         { []
         }
     {offset
       cdXDD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXDE; else goto cdXDF;
       cdXDE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXDF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto cdXDC; else goto cdXDB;
       cdXDC: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdXDB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdXxE_info" {
     sat_sdXxE_info:
         const sat_sdXxE_entry;
         const 4294967296;
         const 17;
 },
 Control.Concurrent.isCurrentThreadBound1_entry() //  []
         { []
         }
     {offset
       cdXDG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXDH; else goto cdXDI;
       cdXDH: // global
           R1 = Control.Concurrent.isCurrentThreadBound1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXDI: // global
           I64[Sp - 8] = block_cdXDt_info;
           Sp = Sp - 8;
           call stg_isCurrentThreadBound#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.isCurrentThreadBound1_info" {
     Control.Concurrent.isCurrentThreadBound1_info:
         const Control.Concurrent.isCurrentThreadBound1_entry;
         const 0;
         const 14;
         const 4294967299;
 },
 _cdXDt() //  [R1]
         { []
         }
     {offset
       cdXDt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXDL; else goto cdXDK;
       cdXDL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXDK: // global
           I64[Hp - 16] = sat_sdXxE_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXDt_info" {
     block_cdXDt_info:
         const _cdXDt;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:14.910196847 UTC

[section ""data" . Control.Concurrent.isCurrentThreadBound_closure" {
     Control.Concurrent.isCurrentThreadBound_closure:
         const Control.Concurrent.isCurrentThreadBound_info;
 },
 Control.Concurrent.isCurrentThreadBound_entry() //  []
         { []
         }
     {offset
       cdXEa: // global
           call Control.Concurrent.isCurrentThreadBound1_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.isCurrentThreadBound_info" {
     Control.Concurrent.isCurrentThreadBound_info:
         const Control.Concurrent.isCurrentThreadBound_entry;
         const 0;
         const 14;
         const 4294967299;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:14.913761232 UTC

[section ""data" . Control.Concurrent.threadWaitRead_closure" {
     Control.Concurrent.threadWaitRead_closure:
         const Control.Concurrent.threadWaitRead_info;
         const 0;
 },
 Control.Concurrent.threadWaitRead_entry() //  [R2]
         { []
         }
     {offset
       cdXEl: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitRead1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.threadWaitRead_info" {
     Control.Concurrent.threadWaitRead_info:
         const Control.Concurrent.threadWaitRead_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SdXEo_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:14.917293827 UTC

[section ""data" . Control.Concurrent.threadWaitWrite_closure" {
     Control.Concurrent.threadWaitWrite_closure:
         const Control.Concurrent.threadWaitWrite_info;
         const 0;
 },
 Control.Concurrent.threadWaitWrite_entry() //  [R2]
         { []
         }
     {offset
       cdXEx: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWrite1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.threadWaitWrite_info" {
     Control.Concurrent.threadWaitWrite_info:
         const Control.Concurrent.threadWaitWrite_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SdXEo_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:14.920751729 UTC

[section ""data" . Control.Concurrent.threadWaitReadSTM_closure" {
     Control.Concurrent.threadWaitReadSTM_closure:
         const Control.Concurrent.threadWaitReadSTM_info;
         const 0;
 },
 Control.Concurrent.threadWaitReadSTM_entry() //  [R2]
         { []
         }
     {offset
       cdXEI: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitReadSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.threadWaitReadSTM_info" {
     Control.Concurrent.threadWaitReadSTM_info:
         const Control.Concurrent.threadWaitReadSTM_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SdXEo_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:14.924434301 UTC

[section ""data" . Control.Concurrent.threadWaitWriteSTM_closure" {
     Control.Concurrent.threadWaitWriteSTM_closure:
         const Control.Concurrent.threadWaitWriteSTM_info;
         const 0;
 },
 Control.Concurrent.threadWaitWriteSTM_entry() //  [R2]
         { []
         }
     {offset
       cdXET: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWriteSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.threadWaitWriteSTM_info" {
     Control.Concurrent.threadWaitWriteSTM_info:
         const Control.Concurrent.threadWaitWriteSTM_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SdXEo_srt+24;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:14.927652126 UTC

[section ""cstring" . Control.Concurrent.$trModule4_bytes" {
     Control.Concurrent.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:14.931027005 UTC

[section ""data" . Control.Concurrent.$trModule3_closure" {
     Control.Concurrent.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:14.932636201 UTC

[section ""cstring" . Control.Concurrent.$trModule2_bytes" {
     Control.Concurrent.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116]
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:14.934448881 UTC

[section ""data" . Control.Concurrent.$trModule1_closure" {
     Control.Concurrent.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:14.936123482 UTC

[section ""data" . Control.Concurrent.$trModule_closure" {
     Control.Concurrent.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.$trModule3_closure+1;
         const Control.Concurrent.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:14.938812526 UTC

[section ""data" . Control.Concurrent.rtsSupportsBoundThreads_closure" {
     Control.Concurrent.rtsSupportsBoundThreads_closure:
         const Control.Concurrent.rtsSupportsBoundThreads_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Concurrent.rtsSupportsBoundThreads_entry() //  [R1]
         { []
         }
     {offset
       cdXFg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXFh; else goto cdXFi;
       cdXFh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXFi: // global
           (_cdXF8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXF8::I64 == 0) goto cdXFa; else goto cdXF9;
       cdXFa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXF9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXF8::I64;
           (_sdXxI::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sdXxI::I64 == 0) goto cdXFf; else goto cdXFe;
       cdXFf: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdXFe: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . Control.Concurrent.rtsSupportsBoundThreads_info" {
     Control.Concurrent.rtsSupportsBoundThreads_info:
         const Control.Concurrent.rtsSupportsBoundThreads_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:14.943672319 UTC

[section ""data" . Control.Concurrent.forkFinally2_closure" {
     Control.Concurrent.forkFinally2_closure:
         const Control.Concurrent.forkFinally2_info;
 },
 Control.Concurrent.forkFinally2_entry() //  [R2]
         { []
         }
     {offset
       cdXFA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXFE; else goto cdXFD;
       cdXFE: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Control.Concurrent.forkFinally2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXFD: // global
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.forkFinally2_info" {
     Control.Concurrent.forkFinally2_info:
         const Control.Concurrent.forkFinally2_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:14.961795438 UTC

[section ""data" . Control.Concurrent.runInUnboundThread1_closure" {
     Control.Concurrent.runInUnboundThread1_closure:
         const Control.Concurrent.runInUnboundThread1_info;
         const 0;
 },
 lvl13_sdXxZ_entry() //  [R1]
         { []
         }
     {offset
       cdXG2: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . lvl13_sdXxZ_info" {
     lvl13_sdXxZ_info:
         const lvl13_sdXxZ_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_sdXy9_entry() //  [R1]
         { []
         }
     {offset
       cdXGp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXGq; else goto cdXGr;
       cdXGq: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXGr: // global
           I64[Sp - 8] = block_cdXGm_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXy9_info" {
     sat_sdXy9_info:
         const sat_sdXy9_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _cdXGm() //  [R1]
         { []
         }
     {offset
       cdXGm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXGu; else goto cdXGt;
       cdXGu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXGt: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXGm_info" {
     block_cdXGm_info:
         const _cdXGm;
         const 0;
         const 30;
 },
 sat_sdXye_entry() //  [R1]
         { []
         }
     {offset
       cdXGz: // global
           _sdXye::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXGA; else goto cdXGB;
       cdXGB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXGD; else goto cdXGC;
       cdXGD: // global
           HpAlloc = 16;
           goto cdXGA;
       cdXGA: // global
           R1 = _sdXye::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXGC: // global
           _sdXxN::P64 = P64[_sdXye::P64 + 7];
           _sdXxV::P64 = P64[_sdXye::P64 + 15];
           I64[Hp - 8] = sat_sdXy9_info;
           P64[Hp] = _sdXxN::P64;
           I64[Sp - 16] = block_cdXGv_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdXxV::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXye_info" {
     sat_sdXye_info:
         const sat_sdXye_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdXGv() //  [R1]
         { []
         }
     {offset
       cdXGv: // global
           _sdXxV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdXGx_info;
           R2 = R1;
           R1 = _sdXxV::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXGv_info" {
     block_cdXGv_info:
         const _cdXGv;
         const 1;
         const 30;
 },
 _cdXGx() //  []
         { []
         }
     {offset
       cdXGx: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXGx_info" {
     block_cdXGx_info:
         const _cdXGx;
         const 0;
         const 30;
 },
 sat_sdXyf_entry() //  [R1]
         { []
         }
     {offset
       cdXGG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXGK; else goto cdXGJ;
       cdXGK: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXGJ: // global
           _sdXxN::P64 = P64[R1 + 7];
           _sdXxV::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdXye_info;
           P64[Hp - 8] = _sdXxN::P64;
           P64[Hp] = _sdXxV::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXyf_info" {
     sat_sdXyf_info:
         const sat_sdXyf_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SdXEo_srt+32;
 },
 sat_sdXyo_entry() //  [R1, R2]
         { []
         }
     {offset
       cdXGZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXH0; else goto cdXH1;
       cdXH0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXH1: // global
           I64[Sp - 16] = block_cdXGX_info;
           R2 = R2;
           _sdXyj::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdXyj::P64;
           Sp = Sp - 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXyo_info" {
     sat_sdXyo_info:
         const sat_sdXyo_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _cdXGX() //  []
         { []
         }
     {offset
       cdXGX: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call wait_sdXyj_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXGX_info" {
     block_cdXGX_info:
         const _cdXGX;
         const 1;
         const 30;
 },
 wait_sdXyj_entry() //  [R1]
         { []
         }
     {offset
       cdXH3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXH7; else goto cdXH6;
       cdXH7: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXH6: // global
           _sdXxZ::P64 = P64[R1 + 7];
           _sdXyi::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdXyo_info;
           P64[Hp - 8] = _sdXyi::P64;
           P64[Hp] = R1;
           R2 = Hp - 14;
           R1 = _sdXxZ::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . wait_sdXyj_info" {
     wait_sdXyj_info:
         const wait_sdXyj_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 sat_sdXyD_entry() //  [R1]
         { []
         }
     {offset
       cdXHw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXHx; else goto cdXHy;
       cdXHx: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXHy: // global
           I64[Sp - 8] = block_cdXHt_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXyD_info" {
     sat_sdXyD_info:
         const sat_sdXyD_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _cdXHt() //  [R1]
         { []
         }
     {offset
       cdXHt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXHB; else goto cdXHA;
       cdXHB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXHA: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXHt_info" {
     block_cdXHt_info:
         const _cdXHt;
         const 0;
         const 30;
 },
 sat_sdXyI_entry() //  [R1]
         { []
         }
     {offset
       cdXHG: // global
           _sdXyI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXHH; else goto cdXHI;
       cdXHI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXHK; else goto cdXHJ;
       cdXHK: // global
           HpAlloc = 16;
           goto cdXHH;
       cdXHH: // global
           R1 = _sdXyI::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXHJ: // global
           _sdXxN::P64 = P64[_sdXyI::P64 + 7];
           _sdXxV::P64 = P64[_sdXyI::P64 + 15];
           I64[Hp - 8] = sat_sdXyD_info;
           P64[Hp] = _sdXxN::P64;
           I64[Sp - 16] = block_cdXHC_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdXxV::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXyI_info" {
     sat_sdXyI_info:
         const sat_sdXyI_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdXHC() //  [R1]
         { []
         }
     {offset
       cdXHC: // global
           _sdXxV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdXHE_info;
           R2 = R1;
           R1 = _sdXxV::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXHC_info" {
     block_cdXHC_info:
         const _cdXHC;
         const 1;
         const 30;
 },
 _cdXHE() //  []
         { []
         }
     {offset
       cdXHE: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXHE_info" {
     block_cdXHE_info:
         const _cdXHE;
         const 0;
         const 30;
 },
 sat_sdXyJ_entry() //  [R1]
         { []
         }
     {offset
       cdXHN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXHR; else goto cdXHQ;
       cdXHR: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXHQ: // global
           _sdXxN::P64 = P64[R1 + 7];
           _sdXxV::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdXyI_info;
           P64[Hp - 8] = _sdXxN::P64;
           P64[Hp] = _sdXxV::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXyJ_info" {
     sat_sdXyJ_info:
         const sat_sdXyJ_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SdXEo_srt+32;
 },
 sat_sdXyS_entry() //  [R1, R2]
         { []
         }
     {offset
       cdXI6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXI7; else goto cdXI8;
       cdXI7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXI8: // global
           I64[Sp - 16] = block_cdXI4_info;
           R2 = R2;
           _sdXyN::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdXyN::P64;
           Sp = Sp - 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXyS_info" {
     sat_sdXyS_info:
         const sat_sdXyS_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _cdXI4() //  []
         { []
         }
     {offset
       cdXI4: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call wait_sdXyN_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXI4_info" {
     block_cdXI4_info:
         const _cdXI4;
         const 1;
         const 30;
 },
 wait_sdXyN_entry() //  [R1]
         { []
         }
     {offset
       cdXIa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXIe; else goto cdXId;
       cdXIe: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXId: // global
           _sdXxZ::P64 = P64[R1 + 7];
           _sdXyM::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdXyS_info;
           P64[Hp - 8] = _sdXyM::P64;
           P64[Hp] = R1;
           R2 = Hp - 14;
           R1 = _sdXxZ::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . wait_sdXyN_info" {
     wait_sdXyN_info:
         const wait_sdXyN_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 sat_sdXyZ_entry() //  [R1]
         { []
         }
     {offset
       cdXIo: // global
           _sdXyZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXIp; else goto cdXIq;
       cdXIq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXIs; else goto cdXIr;
       cdXIs: // global
           HpAlloc = 24;
           goto cdXIp;
       cdXIp: // global
           R1 = _sdXyZ::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXIr: // global
           _sdXxN::P64 = P64[_sdXyZ::P64 + 7];
           _sdXxV::P64 = P64[_sdXyZ::P64 + 15];
           _sdXxZ::P64 = P64[_sdXyZ::P64 + 23];
           I64[Hp - 16] = sat_sdXyJ_info;
           P64[Hp - 8] = _sdXxN::P64;
           P64[Hp] = _sdXxV::P64;
           I64[Sp - 16] = block_cdXHS_info;
           R1 = Hp - 15;
           P64[Sp - 8] = _sdXxZ::P64;
           Sp = Sp - 16;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXyZ_info" {
     sat_sdXyZ_info:
         const sat_sdXyZ_entry;
         const 3;
         const 4294967304;
         const 4294967299;
         const SdXEo_srt+32;
 },
 _cdXHS() //  [R1]
         { []
         }
     {offset
       cdXHS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXIv; else goto cdXIu;
       cdXIv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXIu: // global
           I64[Hp - 16] = wait_sdXyN_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cdXIf_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call wait_sdXyN_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXHS_info" {
     block_cdXHS_info:
         const _cdXHS;
         const 1;
         const 30;
 },
 _cdXIf() //  [R1]
         { []
         }
     {offset
       cdXIf: // global
           I64[Sp] = block_cdXIh_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udXID; else goto cdXIi;
       udXID: // global
           call _cdXIh(R1) args: 0, res: 0, upd: 0;
       cdXIi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXIf_info" {
     block_cdXIf_info:
         const _cdXIf;
         const 0;
         const 30;
 },
 _cdXIh() //  [R1]
         { []
         }
     {offset
       cdXIh: // global
           if (R1 & 7 == 1) goto cdXIl; else goto cdXIm;
       cdXIl: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXIm: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXIh_info" {
     block_cdXIh_info:
         const _cdXIh;
         const 0;
         const 30;
 },
 sat_sdXz7_entry() //  [R1]
         { []
         }
     {offset
       cdXIX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXIY; else goto cdXIZ;
       cdXIY: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXIZ: // global
           I64[Sp - 8] = block_cdXIU_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXz7_info" {
     sat_sdXz7_info:
         const sat_sdXz7_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _cdXIU() //  [R1]
         { []
         }
     {offset
       cdXIU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXJ2; else goto cdXJ1;
       cdXJ2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXJ1: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXIU_info" {
     block_cdXIU_info:
         const _cdXIU;
         const 0;
         const 30;
 },
 sat_sdXzc_entry() //  [R1]
         { []
         }
     {offset
       cdXJ7: // global
           _sdXzc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXJ8; else goto cdXJ9;
       cdXJ9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXJb; else goto cdXJa;
       cdXJb: // global
           HpAlloc = 16;
           goto cdXJ8;
       cdXJ8: // global
           R1 = _sdXzc::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXJa: // global
           _sdXxN::P64 = P64[_sdXzc::P64 + 7];
           _sdXxV::P64 = P64[_sdXzc::P64 + 15];
           I64[Hp - 8] = sat_sdXz7_info;
           P64[Hp] = _sdXxN::P64;
           I64[Sp - 16] = block_cdXJ3_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdXxV::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXzc_info" {
     sat_sdXzc_info:
         const sat_sdXzc_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdXJ3() //  [R1]
         { []
         }
     {offset
       cdXJ3: // global
           _sdXxV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdXJ5_info;
           R2 = R1;
           R1 = _sdXxV::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXJ3_info" {
     block_cdXJ3_info:
         const _cdXJ3;
         const 1;
         const 30;
 },
 _cdXJ5() //  []
         { []
         }
     {offset
       cdXJ5: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXJ5_info" {
     block_cdXJ5_info:
         const _cdXJ5;
         const 0;
         const 30;
 },
 sat_sdXzd_entry() //  [R1]
         { []
         }
     {offset
       cdXJe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXJi; else goto cdXJh;
       cdXJi: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXJh: // global
           _sdXxN::P64 = P64[R1 + 7];
           _sdXxV::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdXzc_info;
           P64[Hp - 8] = _sdXxN::P64;
           P64[Hp] = _sdXxV::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXzd_info" {
     sat_sdXzd_info:
         const sat_sdXzd_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SdXEo_srt+32;
 },
 sat_sdXzm_entry() //  [R1, R2]
         { []
         }
     {offset
       cdXJx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXJy; else goto cdXJz;
       cdXJy: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXJz: // global
           I64[Sp - 16] = block_cdXJv_info;
           R2 = R2;
           _sdXzh::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdXzh::P64;
           Sp = Sp - 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXzm_info" {
     sat_sdXzm_info:
         const sat_sdXzm_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _cdXJv() //  []
         { []
         }
     {offset
       cdXJv: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call wait_sdXzh_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXJv_info" {
     block_cdXJv_info:
         const _cdXJv;
         const 1;
         const 30;
 },
 wait_sdXzh_entry() //  [R1]
         { []
         }
     {offset
       cdXJB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXJF; else goto cdXJE;
       cdXJF: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXJE: // global
           _sdXxZ::P64 = P64[R1 + 7];
           _sdXzg::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdXzm_info;
           P64[Hp - 8] = _sdXzg::P64;
           P64[Hp] = R1;
           R2 = Hp - 14;
           R1 = _sdXxZ::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . wait_sdXzh_info" {
     wait_sdXzh_info:
         const wait_sdXzh_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 Control.Concurrent.runInUnboundThread1_entry() //  [R2]
         { []
         }
     {offset
       cdXJJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdXJK; else goto cdXJL;
       cdXJK: // global
           R2 = R2;
           R1 = Control.Concurrent.runInUnboundThread1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXJL: // global
           I64[Sp - 16] = block_cdXFP_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_isCurrentThreadBound#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.runInUnboundThread1_info" {
     Control.Concurrent.runInUnboundThread1_info:
         const Control.Concurrent.runInUnboundThread1_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const SdXEo_srt+32;
 },
 _cdXFP() //  [R1]
         { []
         }
     {offset
       cdXFP: // global
           if (R1 == 0) goto cdXJI; else goto cdXJH;
       cdXJI: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       cdXJH: // global
           I64[Sp] = block_cdXFT_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXFP_info" {
     block_cdXFP_info:
         const _cdXFP;
         const 1;
         const 4294967326;
         const SdXEo_srt+32;
 },
 _cdXFT() //  [R1]
         { []
         }
     {offset
       cdXFT: // global
           I64[Sp - 8] = block_cdXFV_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXFT_info" {
     block_cdXFT_info:
         const _cdXFT;
         const 1;
         const 4294967326;
         const SdXEo_srt+32;
 },
 _cdXFV() //  [R1]
         { []
         }
     {offset
       cdXFV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdXJQ; else goto cdXJP;
       cdXJQ: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXJP: // global
           I64[Hp - 40] = lvl13_sdXxZ_info;
           _sdXxV::P64 = P64[Sp + 8];
           P64[Hp - 32] = _sdXxV::P64;
           _sdXxN::P64 = P64[Sp + 16];
           _cdXFX::P64 = Hp - 39;
           if (R1 == 0) goto cdXKb; else goto udXKx;
       cdXKb: // global
           I64[Hp - 24] = sat_sdXyZ_info;
           P64[Hp - 16] = _sdXxN::P64;
           P64[Hp - 8] = _sdXxV::P64;
           P64[Hp] = _cdXFX::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       udXKx: // global
           if (R1 == 1) goto cdXKf; else goto cdXJV;
       cdXKf: // global
           I64[Hp - 24] = sat_sdXzd_info;
           P64[Hp - 16] = _sdXxN::P64;
           P64[Hp - 8] = _sdXxV::P64;
           _cdXIF::P64 = Hp - 23;
           Hp = Hp - 8;
           I64[Sp + 8] = block_cdXJj_info;
           R1 = _cdXIF::P64;
           P64[Sp + 16] = _cdXFX::P64;
           Sp = Sp + 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
       cdXJV: // global
           I64[Hp - 24] = sat_sdXyf_info;
           P64[Hp - 16] = _sdXxN::P64;
           P64[Hp - 8] = _sdXxV::P64;
           _cdXG7::P64 = Hp - 23;
           Hp = Hp - 8;
           I64[Sp + 8] = block_cdXGL_info;
           R1 = _cdXG7::P64;
           P64[Sp + 16] = _cdXFX::P64;
           Sp = Sp + 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXFV_info" {
     block_cdXFV_info:
         const _cdXFV;
         const 2;
         const 4294967326;
         const SdXEo_srt+32;
 },
 _cdXJj() //  [R1]
         { []
         }
     {offset
       cdXJj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXKi; else goto cdXKh;
       cdXKi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXKh: // global
           I64[Hp - 16] = wait_sdXzh_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cdXKc_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call wait_sdXzh_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXJj_info" {
     block_cdXJj_info:
         const _cdXJj;
         const 1;
         const 30;
 },
 _cdXKc() //  [R1]
         { []
         }
     {offset
       cdXKc: // global
           I64[Sp] = block_cdXKe_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udXKz; else goto cdXKk;
       udXKz: // global
           call _cdXKe(R1) args: 0, res: 0, upd: 0;
       cdXKk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXKc_info" {
     block_cdXKc_info:
         const _cdXKc;
         const 0;
         const 30;
 },
 _cdXKe() //  [R1]
         { []
         }
     {offset
       cdXKe: // global
           if (R1 & 7 == 1) goto cdXKq; else goto cdXKu;
       cdXKq: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXKu: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXKe_info" {
     block_cdXKe_info:
         const _cdXKe;
         const 0;
         const 30;
 },
 _cdXGL() //  [R1]
         { []
         }
     {offset
       cdXGL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXJY; else goto cdXJX;
       cdXJY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXJX: // global
           I64[Hp - 16] = wait_sdXyj_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cdXJR_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call wait_sdXyj_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXGL_info" {
     block_cdXGL_info:
         const _cdXGL;
         const 1;
         const 30;
 },
 _cdXJR() //  [R1]
         { []
         }
     {offset
       cdXJR: // global
           I64[Sp] = block_cdXJT_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udXKy; else goto cdXK0;
       udXKy: // global
           call _cdXJT(R1) args: 0, res: 0, upd: 0;
       cdXK0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXJR_info" {
     block_cdXJR_info:
         const _cdXJR;
         const 0;
         const 30;
 },
 _cdXJT() //  [R1]
         { []
         }
     {offset
       cdXJT: // global
           if (R1 & 7 == 1) goto cdXK6; else goto cdXKa;
       cdXK6: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXKa: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXJT_info" {
     block_cdXJT_info:
         const _cdXJT;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.030200723 UTC

[section ""data" . Control.Concurrent.runInUnboundThread_closure" {
     Control.Concurrent.runInUnboundThread_closure:
         const Control.Concurrent.runInUnboundThread_info;
         const 0;
 },
 Control.Concurrent.runInUnboundThread_entry() //  [R2]
         { []
         }
     {offset
       cdXO1: // global
           R2 = R2;
           call Control.Concurrent.runInUnboundThread1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.runInUnboundThread_info" {
     Control.Concurrent.runInUnboundThread_info:
         const Control.Concurrent.runInUnboundThread_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SdXEo_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.033701695 UTC

[section ""cstring" . lvl_rdWnQ_bytes" {
     lvl_rdWnQ_bytes:
         I8[] [82,84,83,32,100,111,101,115,110,39,116,32,115,117,112,112,111,114,116,32,109,117,108,116,105,112,108,101,32,79,83,32,116,104,114,101,97,100,115,32,40,117,115,101,32,103,104,99,32,45,116,104,114,101,97,100,101,100,32,119,104,101,110,32,108,105,110,107,105,110,103,41]
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.035919684 UTC

[section ""data" . Control.Concurrent.forkOS2_closure" {
     Control.Concurrent.forkOS2_closure:
         const Control.Concurrent.forkOS2_info;
         const 0;
 },
 Control.Concurrent.forkOS2_entry() //  []
         { []
         }
     {offset
       cdXOf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXOg; else goto cdXOh;
       cdXOg: // global
           R1 = Control.Concurrent.forkOS2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXOh: // global
           I64[Sp - 8] = block_cdXOd_info;
           R2 = lvl_rdWnQ_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.forkOS2_info" {
     Control.Concurrent.forkOS2_info:
         const Control.Concurrent.forkOS2_entry;
         const 0;
         const 12884901902;
         const 4294967299;
         const SdXEo_srt+48;
 },
 _cdXOd() //  [R1]
         { []
         }
     {offset
       cdXOd: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXOd_info" {
     block_cdXOd_info:
         const _cdXOd;
         const 0;
         const 4294967326;
         const SdXEo_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.04041318 UTC

[section ""cstring" . lvl1_rdWnR_bytes" {
     lvl1_rdWnR_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.043131119 UTC

[section ""data" . lvl2_rdWnS_closure" {
     lvl2_rdWnS_closure:
         const lvl2_rdWnS_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rdWnS_entry() //  [R1]
         { []
         }
     {offset
       cdXOB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXOC; else goto cdXOD;
       cdXOC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXOD: // global
           (_cdXOy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXOy::I64 == 0) goto cdXOA; else goto cdXOz;
       cdXOA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXOz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXOy::I64;
           R2 = lvl1_rdWnR_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl2_rdWnS_info" {
     lvl2_rdWnS_info:
         const lvl2_rdWnS_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.0473379 UTC

[section ""data" . lvl3_rdWnT_closure" {
     lvl3_rdWnT_closure:
         const lvl3_rdWnT_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rdWnT_entry() //  [R1]
         { []
         }
     {offset
       cdXOS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXOT; else goto cdXOU;
       cdXOT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXOU: // global
           (_cdXOP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXOP::I64 == 0) goto cdXOR; else goto cdXOQ;
       cdXOR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXOQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXOP::I64;
           R2 = Control.Concurrent.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl3_rdWnT_info" {
     lvl3_rdWnT_info:
         const lvl3_rdWnT_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.051484388 UTC

[section ""data" . lvl4_rdWnU_closure" {
     lvl4_rdWnU_closure:
         const lvl4_rdWnU_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rdWnU_entry() //  [R1]
         { []
         }
     {offset
       cdXP9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXPa; else goto cdXPb;
       cdXPa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXPb: // global
           (_cdXP6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXP6::I64 == 0) goto cdXP8; else goto cdXP7;
       cdXP8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXP7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXP6::I64;
           R2 = Control.Concurrent.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl4_rdWnU_info" {
     lvl4_rdWnU_info:
         const lvl4_rdWnU_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.055832482 UTC

[section ""cstring" . lvl5_rdWnV_bytes" {
     lvl5_rdWnV_bytes:
         I8[] [46,47,67,111,110,116,114,111,108,47,67,111,110,99,117,114,114,101,110,116,46,104,115]
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.058150692 UTC

[section ""data" . lvl6_rdWnW_closure" {
     lvl6_rdWnW_closure:
         const lvl6_rdWnW_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rdWnW_entry() //  [R1]
         { []
         }
     {offset
       cdXPr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXPs; else goto cdXPt;
       cdXPs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXPt: // global
           (_cdXPo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXPo::I64 == 0) goto cdXPq; else goto cdXPp;
       cdXPq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXPp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXPo::I64;
           R2 = lvl5_rdWnV_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl6_rdWnW_info" {
     lvl6_rdWnW_info:
         const lvl6_rdWnW_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.061773208 UTC

[section ""data" . lvl7_rdWnX_closure" {
     lvl7_rdWnX_closure:
         const GHC.Types.I#_con_info;
         const 353;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.063460024 UTC

[section ""data" . lvl8_rdWnY_closure" {
     lvl8_rdWnY_closure:
         const GHC.Types.I#_con_info;
         const 33;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.065128586 UTC

[section ""data" . lvl9_rdWnZ_closure" {
     lvl9_rdWnZ_closure:
         const GHC.Types.I#_con_info;
         const 42;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.066881909 UTC

[section ""data" . lvl10_rdWo0_closure" {
     lvl10_rdWo0_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_rdWnT_closure;
         const lvl4_rdWnU_closure;
         const lvl6_rdWnW_closure;
         const lvl7_rdWnX_closure+1;
         const lvl8_rdWnY_closure+1;
         const lvl7_rdWnX_closure+1;
         const lvl9_rdWnZ_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.068770612 UTC

[section ""data" . lvl11_rdWo1_closure" {
     lvl11_rdWo1_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_rdWnS_closure;
         const lvl10_rdWo0_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.071262371 UTC

[section ""data" . Control.Concurrent.runInBoundThread2_closure" {
     Control.Concurrent.runInBoundThread2_closure:
         const Control.Concurrent.runInBoundThread2_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Concurrent.runInBoundThread2_entry() //  [R1]
         { []
         }
     {offset
       cdXPN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXPO; else goto cdXPP;
       cdXPO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXPP: // global
           (_cdXPK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXPK::I64 == 0) goto cdXPM; else goto cdXPL;
       cdXPM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXPL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXPK::I64;
           R2 = lvl11_rdWo1_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . Control.Concurrent.runInBoundThread2_info" {
     Control.Concurrent.runInBoundThread2_info:
         const Control.Concurrent.runInBoundThread2_entry;
         const 0;
         const 12884901909;
         const SdXEo_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.091229676 UTC

[section ""data" . Control.Concurrent.runInBoundThread1_closure" {
     Control.Concurrent.runInBoundThread1_closure:
         const Control.Concurrent.runInBoundThread1_info;
         const 0;
 },
 sat_sdXzT_entry() //  [R1]
         { []
         }
     {offset
       cdXQt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXQu; else goto cdXQv;
       cdXQu: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXQv: // global
           I64[Sp - 8] = block_cdXQq_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXzT_info" {
     sat_sdXzT_info:
         const sat_sdXzT_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _cdXQq() //  [R1]
         { []
         }
     {offset
       cdXQq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXQy; else goto cdXQx;
       cdXQy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXQx: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXQq_info" {
     block_cdXQq_info:
         const _cdXQq;
         const 0;
         const 30;
 },
 sat_sdXzY_entry() //  [R1]
         { []
         }
     {offset
       cdXQE: // global
           _sdXzY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXQF; else goto cdXQG;
       cdXQG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXQI; else goto cdXQH;
       cdXQI: // global
           HpAlloc = 16;
           goto cdXQF;
       cdXQF: // global
           R1 = _sdXzY::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXQH: // global
           _sdXzv::P64 = P64[_sdXzY::P64 + 7];
           _sdXzI::P64 = P64[_sdXzY::P64 + 15];
           I64[Hp - 8] = sat_sdXzT_info;
           P64[Hp] = _sdXzv::P64;
           I64[Sp - 16] = block_cdXQz_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdXzI::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXzY_info" {
     sat_sdXzY_info:
         const sat_sdXzY_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdXQz() //  [R1]
         { []
         }
     {offset
       cdXQz: // global
           _sdXzI::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sdXzI::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sdXzI::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXQz_info" {
     block_cdXQz_info:
         const _cdXQz;
         const 1;
         const 30;
 },
 sat_sdXAd_entry() //  [R1, R2]
         { []
         }
     {offset
       cdXQT: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[R1 + 6]);
           R1 = R2;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXAd_info" {
     sat_sdXAd_info:
         const sat_sdXAd_entry;
         const 4294967296;
         const 10;
         const 8589934597;
 },
 sat_sdXA6_entry() //  [R1]
         { []
         }
     {offset
       cdXR6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXR7; else goto cdXR8;
       cdXR7: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXR8: // global
           I64[Sp - 16] = block_cdXR3_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           _cdXR2::I64 = I64[R1 + 15];
           _udXRc::P64 = CurrentTSO;
           I64[I64[_udXRc::P64 + 24] + 16] = Sp;
           _udXRd::I64 = CurrentNursery;
           P64[_udXRd::I64 + 8] = Hp + 8;
           I64[_udXRc::P64 + 104] = I64[_udXRc::P64 + 104] - ((Hp + 8) - I64[_udXRd::I64]);
           (_udXRa::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] forkOS_entry(_cdXR2::I64);
           (_udXRb::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udXRa::I64);
           BaseReg = _udXRb::I64;
           _udXRe::P64 = CurrentTSO;
           _udXRf::P64 = I64[_udXRe::P64 + 24];
           Sp = I64[_udXRf::P64 + 16];
           SpLim = _udXRf::P64 + 192;
           HpAlloc = 0;
           _udXRg::I64 = CurrentNursery;
           _udXRh::I64 = I64[_udXRg::I64 + 8];
           Hp = _udXRh::I64 - 8;
           _udXRi::I64 = I64[_udXRg::I64];
           HpLim = _udXRi::I64 + ((%MO_SS_Conv_W32_W64(I32[_udXRg::I64 + 48]) << 12) - 1);
           I64[_udXRe::P64 + 104] = I64[_udXRe::P64 + 104] + (_udXRh::I64 - _udXRi::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXA6_info" {
     sat_sdXA6_info:
         const sat_sdXA6_entry;
         const 4294967297;
         const 12;
         const 4294967299;
 },
 _cdXR3() //  []
         { []
         }
     {offset
       cdXR3: // global
           R1 = P64[P64[Sp + 8] + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXR3_info" {
     block_cdXR3_info:
         const _cdXR3;
         const 1;
         const 30;
 },
 sat_sdXA7_entry() //  [R1]
         { []
         }
     {offset
       cdXRp: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXA7_info" {
     sat_sdXA7_info:
         const sat_sdXA7_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_sdXAu_entry() //  [R1]
         { []
         }
     {offset
       cdXRL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXRM; else goto cdXRN;
       cdXRM: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXRN: // global
           I64[Sp - 8] = block_cdXRI_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXAu_info" {
     sat_sdXAu_info:
         const sat_sdXAu_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _cdXRI() //  [R1]
         { []
         }
     {offset
       cdXRI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXRQ; else goto cdXRP;
       cdXRQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXRP: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXRI_info" {
     block_cdXRI_info:
         const _cdXRI;
         const 0;
         const 30;
 },
 sat_sdXAz_entry() //  [R1]
         { []
         }
     {offset
       cdXRW: // global
           _sdXAz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXRX; else goto cdXRY;
       cdXRY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXS0; else goto cdXRZ;
       cdXS0: // global
           HpAlloc = 16;
           goto cdXRX;
       cdXRX: // global
           R1 = _sdXAz::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXRZ: // global
           _sdXzv::P64 = P64[_sdXAz::P64 + 7];
           _sdXzI::P64 = P64[_sdXAz::P64 + 15];
           I64[Hp - 8] = sat_sdXAu_info;
           P64[Hp] = _sdXzv::P64;
           I64[Sp - 16] = block_cdXRR_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdXzI::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXAz_info" {
     sat_sdXAz_info:
         const sat_sdXAz_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdXRR() //  [R1]
         { []
         }
     {offset
       cdXRR: // global
           _sdXzI::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sdXzI::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sdXzI::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXRR_info" {
     block_cdXRR_info:
         const _cdXRR;
         const 1;
         const 30;
 },
 sat_sdXAO_entry() //  [R1, R2]
         { []
         }
     {offset
       cdXSb: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[R1 + 6]);
           R1 = R2;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXAO_info" {
     sat_sdXAO_info:
         const sat_sdXAO_entry;
         const 4294967296;
         const 10;
         const 8589934597;
 },
 sat_sdXAH_entry() //  [R1]
         { []
         }
     {offset
       cdXSo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXSp; else goto cdXSq;
       cdXSp: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXSq: // global
           I64[Sp - 16] = block_cdXSl_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           _cdXSk::I64 = I64[R1 + 15];
           _udXSu::P64 = CurrentTSO;
           I64[I64[_udXSu::P64 + 24] + 16] = Sp;
           _udXSv::I64 = CurrentNursery;
           P64[_udXSv::I64 + 8] = Hp + 8;
           I64[_udXSu::P64 + 104] = I64[_udXSu::P64 + 104] - ((Hp + 8) - I64[_udXSv::I64]);
           (_udXSs::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] forkOS_entry(_cdXSk::I64);
           (_udXSt::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udXSs::I64);
           BaseReg = _udXSt::I64;
           _udXSw::P64 = CurrentTSO;
           _udXSx::P64 = I64[_udXSw::P64 + 24];
           Sp = I64[_udXSx::P64 + 16];
           SpLim = _udXSx::P64 + 192;
           HpAlloc = 0;
           _udXSy::I64 = CurrentNursery;
           _udXSz::I64 = I64[_udXSy::I64 + 8];
           Hp = _udXSz::I64 - 8;
           _udXSA::I64 = I64[_udXSy::I64];
           HpLim = _udXSA::I64 + ((%MO_SS_Conv_W32_W64(I32[_udXSy::I64 + 48]) << 12) - 1);
           I64[_udXSw::P64 + 104] = I64[_udXSw::P64 + 104] + (_udXSz::I64 - _udXSA::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXAH_info" {
     sat_sdXAH_info:
         const sat_sdXAH_entry;
         const 4294967297;
         const 12;
         const 4294967299;
 },
 _cdXSl() //  []
         { []
         }
     {offset
       cdXSl: // global
           R1 = P64[P64[Sp + 8] + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXSl_info" {
     block_cdXSl_info:
         const _cdXSl;
         const 1;
         const 30;
 },
 sat_sdXAI_entry() //  [R1]
         { []
         }
     {offset
       cdXSH: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXAI_info" {
     sat_sdXAI_info:
         const sat_sdXAI_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_sdXAV_entry() //  [R1]
         { []
         }
     {offset
       cdXSO: // global
           _sdXAV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXSP; else goto cdXSQ;
       cdXSQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXSS; else goto cdXSR;
       cdXSS: // global
           HpAlloc = 24;
           goto cdXSP;
       cdXSP: // global
           R1 = _sdXAV::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXSR: // global
           _sdXzv::P64 = P64[_sdXAV::P64 + 7];
           _sdXzI::P64 = P64[_sdXAV::P64 + 15];
           I64[Hp - 16] = sat_sdXAz_info;
           P64[Hp - 8] = _sdXzv::P64;
           P64[Hp] = _sdXzI::P64;
           I64[Sp - 16] = block_cdXS2_info;
           R1 = Hp - 15;
           P64[Sp - 8] = _sdXzI::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXAV_info" {
     sat_sdXAV_info:
         const sat_sdXAV_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdXS2() //  [R1]
         { []
         }
     {offset
       cdXS2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdXSV; else goto cdXSU;
       cdXSV: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXSU: // global
           I64[Hp - 48] = sat_sdXAO_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdXAH_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdXAI_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cdXSK_info;
           R2 = Hp - 46;
           _sdXAC::I64 = R1;
           R1 = Hp - 7;
           I64[Sp + 8] = _sdXAC::I64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXS2_info" {
     block_cdXS2_info:
         const _cdXS2;
         const 1;
         const 30;
 },
 _cdXSK() //  [R1]
         { []
         }
     {offset
       cdXSK: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXSK_info" {
     block_cdXSK_info:
         const _cdXSK;
         const 65;
         const 30;
 },
 sat_sdXB8_entry() //  [R1]
         { []
         }
     {offset
       cdXTb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXTc; else goto cdXTd;
       cdXTc: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXTd: // global
           I64[Sp - 8] = block_cdXT8_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXB8_info" {
     sat_sdXB8_info:
         const sat_sdXB8_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _cdXT8() //  [R1]
         { []
         }
     {offset
       cdXT8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXTg; else goto cdXTf;
       cdXTg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXTf: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXT8_info" {
     block_cdXT8_info:
         const _cdXT8;
         const 0;
         const 30;
 },
 sat_sdXBd_entry() //  [R1]
         { []
         }
     {offset
       cdXTm: // global
           _sdXBd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXTn; else goto cdXTo;
       cdXTo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXTq; else goto cdXTp;
       cdXTq: // global
           HpAlloc = 16;
           goto cdXTn;
       cdXTn: // global
           R1 = _sdXBd::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXTp: // global
           _sdXzv::P64 = P64[_sdXBd::P64 + 7];
           _sdXzI::P64 = P64[_sdXBd::P64 + 15];
           I64[Hp - 8] = sat_sdXB8_info;
           P64[Hp] = _sdXzv::P64;
           I64[Sp - 16] = block_cdXTh_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdXzI::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXBd_info" {
     sat_sdXBd_info:
         const sat_sdXBd_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdXTh() //  [R1]
         { []
         }
     {offset
       cdXTh: // global
           _sdXzI::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sdXzI::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sdXzI::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXTh_info" {
     block_cdXTh_info:
         const _cdXTh;
         const 1;
         const 30;
 },
 sat_sdXBs_entry() //  [R1, R2]
         { []
         }
     {offset
       cdXTB: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[R1 + 6]);
           R1 = R2;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXBs_info" {
     sat_sdXBs_info:
         const sat_sdXBs_entry;
         const 4294967296;
         const 10;
         const 8589934597;
 },
 sat_sdXBl_entry() //  [R1]
         { []
         }
     {offset
       cdXTO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXTP; else goto cdXTQ;
       cdXTP: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXTQ: // global
           I64[Sp - 16] = block_cdXTL_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           _cdXTK::I64 = I64[R1 + 15];
           _udXTU::P64 = CurrentTSO;
           I64[I64[_udXTU::P64 + 24] + 16] = Sp;
           _udXTV::I64 = CurrentNursery;
           P64[_udXTV::I64 + 8] = Hp + 8;
           I64[_udXTU::P64 + 104] = I64[_udXTU::P64 + 104] - ((Hp + 8) - I64[_udXTV::I64]);
           (_udXTS::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] forkOS_entry(_cdXTK::I64);
           (_udXTT::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udXTS::I64);
           BaseReg = _udXTT::I64;
           _udXTW::P64 = CurrentTSO;
           _udXTX::P64 = I64[_udXTW::P64 + 24];
           Sp = I64[_udXTX::P64 + 16];
           SpLim = _udXTX::P64 + 192;
           HpAlloc = 0;
           _udXTY::I64 = CurrentNursery;
           _udXTZ::I64 = I64[_udXTY::I64 + 8];
           Hp = _udXTZ::I64 - 8;
           _udXU0::I64 = I64[_udXTY::I64];
           HpLim = _udXU0::I64 + ((%MO_SS_Conv_W32_W64(I32[_udXTY::I64 + 48]) << 12) - 1);
           I64[_udXTW::P64 + 104] = I64[_udXTW::P64 + 104] + (_udXTZ::I64 - _udXU0::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXBl_info" {
     sat_sdXBl_info:
         const sat_sdXBl_entry;
         const 4294967297;
         const 12;
         const 4294967299;
 },
 _cdXTL() //  []
         { []
         }
     {offset
       cdXTL: // global
           R1 = P64[P64[Sp + 8] + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXTL_info" {
     block_cdXTL_info:
         const _cdXTL;
         const 1;
         const 30;
 },
 sat_sdXBm_entry() //  [R1]
         { []
         }
     {offset
       cdXU7: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXBm_info" {
     sat_sdXBm_info:
         const sat_sdXBm_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 Control.Concurrent.runInBoundThread1_entry() //  [R2]
         { []
         }
     {offset
       cdXUd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdXUe; else goto cdXUf;
       cdXUe: // global
           R2 = R2;
           R1 = Control.Concurrent.runInBoundThread1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXUf: // global
           (_sdXzA::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sdXzA::I64 == 0) goto cdXUc; else goto cdXUb;
       cdXUc: // global
           call Control.Concurrent.forkOS2_entry() args: 8, res: 0, upd: 8;
       cdXUb: // global
           I64[Sp - 16] = block_cdXQ5_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_isCurrentThreadBound#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.runInBoundThread1_info" {
     Control.Concurrent.runInBoundThread1_info:
         const Control.Concurrent.runInBoundThread1_entry;
         const 0;
         const 107374182414;
         const 8589934597;
         const SdXEo_srt+56;
 },
 _cdXQ5() //  [R1]
         { []
         }
     {offset
       cdXQ5: // global
           if (R1 == 0) goto cdXUj; else goto cdXUi;
       cdXUj: // global
           I64[Sp] = block_cdXQa_info;
           R1 = Control.Concurrent.runInBoundThread2_closure;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cdXUi: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXQ5_info" {
     block_cdXQ5_info:
         const _cdXQ5;
         const 1;
         const 4294967326;
         const SdXEo_srt+88;
 },
 _cdXQa() //  [R1]
         { []
         }
     {offset
       cdXQa: // global
           I64[Sp - 8] = block_cdXQc_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXQa_info" {
     block_cdXQa_info:
         const _cdXQa;
         const 1;
         const 30;
 },
 _cdXQc() //  [R1]
         { []
         }
     {offset
       cdXQc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXUn; else goto cdXUm;
       cdXUn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXUm: // global
           _sdXzv::P64 = P64[Sp + 16];
           _sdXzI::P64 = P64[Sp + 8];
           if (R1 == 0) goto cdXUN; else goto udXVo;
       cdXUN: // global
           I64[Hp - 16] = sat_sdXAV_info;
           P64[Hp - 8] = _sdXzv::P64;
           P64[Hp] = _sdXzI::P64;
           I64[Sp + 16] = block_cdXUK_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
       udXVo: // global
           if (R1 == 1) goto cdXV5; else goto cdXUu;
       cdXV5: // global
           I64[Hp - 16] = sat_sdXBd_info;
           P64[Hp - 8] = _sdXzv::P64;
           P64[Hp] = _sdXzI::P64;
           I64[Sp] = block_cdXTs_info;
           R1 = Hp - 15;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
       cdXUu: // global
           I64[Hp - 16] = sat_sdXzY_info;
           P64[Hp - 8] = _sdXzv::P64;
           P64[Hp] = _sdXzI::P64;
           I64[Sp] = block_cdXQK_info;
           R1 = Hp - 15;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXQc_info" {
     block_cdXQc_info:
         const _cdXQc;
         const 2;
         const 30;
 },
 _cdXUK() //  [R1]
         { []
         }
     {offset
       cdXUK: // global
           I64[Sp] = block_cdXUM_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udXVq; else goto cdXUP;
       udXVq: // global
           call _cdXUM(R1) args: 0, res: 0, upd: 0;
       cdXUP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXUK_info" {
     block_cdXUK_info:
         const _cdXUK;
         const 0;
         const 30;
 },
 _cdXUM() //  [R1]
         { []
         }
     {offset
       cdXUM: // global
           if (R1 & 7 == 1) goto cdXUV; else goto cdXUZ;
       cdXUV: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXUZ: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXUM_info" {
     block_cdXUM_info:
         const _cdXUM;
         const 0;
         const 30;
 },
 _cdXTs() //  [R1]
         { []
         }
     {offset
       cdXTs: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdXV8; else goto cdXV7;
       cdXV8: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXV7: // global
           I64[Hp - 48] = sat_sdXBs_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdXBl_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdXBm_info;
           P64[Hp] = Hp - 31;
           I64[Sp + 8] = block_cdXV0_info;
           R2 = Hp - 46;
           _sdXBg::I64 = R1;
           R1 = Hp - 7;
           I64[Sp + 16] = _sdXBg::I64;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXTs_info" {
     block_cdXTs_info:
         const _cdXTs;
         const 130;
         const 30;
 },
 _cdXV0() //  [R1]
         { []
         }
     {offset
       cdXV0: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           I64[Sp + 8] = block_cdXV4_info;
           R1 = R1;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udXVr; else goto cdXVa;
       udXVr: // global
           call _cdXV4(R1) args: 0, res: 0, upd: 0;
       cdXVa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXV0_info" {
     block_cdXV0_info:
         const _cdXV0;
         const 65;
         const 30;
 },
 _cdXV4() //  [R1]
         { []
         }
     {offset
       cdXV4: // global
           if (R1 & 7 == 1) goto cdXVg; else goto cdXVk;
       cdXVg: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXVk: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXV4_info" {
     block_cdXV4_info:
         const _cdXV4;
         const 0;
         const 30;
 },
 _cdXQK() //  [R1]
         { []
         }
     {offset
       cdXQK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdXUx; else goto cdXUw;
       cdXUx: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXUw: // global
           I64[Hp - 48] = sat_sdXAd_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdXA6_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdXA7_info;
           P64[Hp] = Hp - 31;
           I64[Sp + 8] = block_cdXUo_info;
           R2 = Hp - 46;
           _sdXA1::I64 = R1;
           R1 = Hp - 7;
           I64[Sp + 16] = _sdXA1::I64;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXQK_info" {
     block_cdXQK_info:
         const _cdXQK;
         const 130;
         const 30;
 },
 _cdXUo() //  [R1]
         { []
         }
     {offset
       cdXUo: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           I64[Sp + 8] = block_cdXUs_info;
           R1 = R1;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udXVp; else goto cdXUz;
       udXVp: // global
           call _cdXUs(R1) args: 0, res: 0, upd: 0;
       cdXUz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXUo_info" {
     block_cdXUo_info:
         const _cdXUo;
         const 65;
         const 30;
 },
 _cdXUs() //  [R1]
         { []
         }
     {offset
       cdXUs: // global
           if (R1 & 7 == 1) goto cdXUF; else goto cdXUJ;
       cdXUF: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXUJ: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXUs_info" {
     block_cdXUs_info:
         const _cdXUs;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.160747904 UTC

[section ""data" . Control.Concurrent.runInBoundThread_closure" {
     Control.Concurrent.runInBoundThread_closure:
         const Control.Concurrent.runInBoundThread_info;
         const 0;
 },
 Control.Concurrent.runInBoundThread_entry() //  [R2]
         { []
         }
     {offset
       cdXZD: // global
           R2 = R2;
           call Control.Concurrent.runInBoundThread1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.runInBoundThread_info" {
     Control.Concurrent.runInBoundThread_info:
         const Control.Concurrent.runInBoundThread_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SdXEo_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.173384036 UTC

[section ""data" . Control.Concurrent.forkFinally1_closure" {
     Control.Concurrent.forkFinally1_closure:
         const Control.Concurrent.forkFinally1_info;
         const 0;
 },
 sat_sdXBQ_entry() //  [R1]
         { []
         }
     {offset
       cdY0a: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdY0b; else goto cdY0c;
       cdY0b: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY0c: // global
           I64[Sp - 8] = block_cdY07_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXBQ_info" {
     sat_sdXBQ_info:
         const sat_sdXBQ_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _cdY07() //  [R1]
         { []
         }
     {offset
       cdY07: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY0f; else goto cdY0e;
       cdY0f: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdY0e: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdY07_info" {
     block_cdY07_info:
         const _cdY07;
         const 0;
         const 30;
 },
 sat_sdXBU_entry() //  [R1]
         { []
         }
     {offset
       cdY0i: // global
           _sdXBU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdY0j; else goto cdY0k;
       cdY0k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY0m; else goto cdY0l;
       cdY0m: // global
           HpAlloc = 16;
           goto cdY0j;
       cdY0j: // global
           R1 = _sdXBU::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY0l: // global
           _sdXBC::P64 = P64[_sdXBU::P64 + 7];
           _sdXBD::P64 = P64[_sdXBU::P64 + 15];
           I64[Hp - 8] = sat_sdXBQ_info;
           P64[Hp] = _sdXBC::P64;
           I64[Sp - 16] = block_cdY0g_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdXBD::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXBU_info" {
     sat_sdXBU_info:
         const sat_sdXBU_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdY0g() //  [R1]
         { []
         }
     {offset
       cdY0g: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdY0g_info" {
     block_cdY0g_info:
         const _cdY0g;
         const 1;
         const 30;
 },
 sat_sdXBV_entry() //  [R1]
         { []
         }
     {offset
       cdY0o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdY0s; else goto cdY0r;
       cdY0s: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY0r: // global
           _sdXBC::P64 = P64[R1 + 7];
           _sdXBD::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdXBU_info;
           P64[Hp - 8] = _sdXBC::P64;
           P64[Hp] = _sdXBD::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXBV_info" {
     sat_sdXBV_info:
         const sat_sdXBV_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SdXEo_srt+32;
 },
 sat_sdXC8_entry() //  [R1]
         { []
         }
     {offset
       cdY0R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdY0S; else goto cdY0T;
       cdY0S: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY0T: // global
           I64[Sp - 8] = block_cdY0O_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXC8_info" {
     sat_sdXC8_info:
         const sat_sdXC8_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _cdY0O() //  [R1]
         { []
         }
     {offset
       cdY0O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY0W; else goto cdY0V;
       cdY0W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdY0V: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdY0O_info" {
     block_cdY0O_info:
         const _cdY0O;
         const 0;
         const 30;
 },
 sat_sdXCc_entry() //  [R1]
         { []
         }
     {offset
       cdY0Z: // global
           _sdXCc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdY10; else goto cdY11;
       cdY11: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY13; else goto cdY12;
       cdY13: // global
           HpAlloc = 16;
           goto cdY10;
       cdY10: // global
           R1 = _sdXCc::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY12: // global
           _sdXBC::P64 = P64[_sdXCc::P64 + 7];
           _sdXBD::P64 = P64[_sdXCc::P64 + 15];
           I64[Hp - 8] = sat_sdXC8_info;
           P64[Hp] = _sdXBC::P64;
           I64[Sp - 16] = block_cdY0X_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdXBD::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXCc_info" {
     sat_sdXCc_info:
         const sat_sdXCc_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdY0X() //  [R1]
         { []
         }
     {offset
       cdY0X: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdY0X_info" {
     block_cdY0X_info:
         const _cdY0X;
         const 1;
         const 30;
 },
 sat_sdXCd_entry() //  [R1]
         { []
         }
     {offset
       cdY15: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdY19; else goto cdY18;
       cdY19: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY18: // global
           _sdXBC::P64 = P64[R1 + 7];
           _sdXBD::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdXCc_info;
           P64[Hp - 8] = _sdXBC::P64;
           P64[Hp] = _sdXBD::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXCd_info" {
     sat_sdXCd_info:
         const sat_sdXCd_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SdXEo_srt+32;
 },
 sat_sdXCi_entry() //  [R1]
         { []
         }
     {offset
       cdY1d: // global
           _sdXCi::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdY1e; else goto cdY1f;
       cdY1f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdY1h; else goto cdY1g;
       cdY1h: // global
           HpAlloc = 24;
           goto cdY1e;
       cdY1e: // global
           R1 = _sdXCi::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY1g: // global
           _sdXBC::P64 = P64[_sdXCi::P64 + 7];
           _sdXBD::P64 = P64[_sdXCi::P64 + 15];
           I64[Hp - 16] = sat_sdXCd_info;
           P64[Hp - 8] = _sdXBC::P64;
           P64[Hp] = _sdXBD::P64;
           I64[Sp - 8] = block_cdY1a_info;
           R1 = Hp - 15;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXCi_info" {
     sat_sdXCi_info:
         const sat_sdXCi_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SdXEo_srt+32;
 },
 _cdY1a() //  [R1]
         { []
         }
     {offset
       cdY1a: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY1k; else goto cdY1j;
       cdY1k: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdY1j: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdY1a_info" {
     block_cdY1a_info:
         const _cdY1a;
         const 0;
         const 30;
 },
 sat_sdXCq_entry() //  [R1]
         { []
         }
     {offset
       cdY1E: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdY1F; else goto cdY1G;
       cdY1F: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY1G: // global
           I64[Sp - 8] = block_cdY1B_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXCq_info" {
     sat_sdXCq_info:
         const sat_sdXCq_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _cdY1B() //  [R1]
         { []
         }
     {offset
       cdY1B: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY1J; else goto cdY1I;
       cdY1J: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdY1I: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdY1B_info" {
     block_cdY1B_info:
         const _cdY1B;
         const 0;
         const 30;
 },
 sat_sdXCu_entry() //  [R1]
         { []
         }
     {offset
       cdY1M: // global
           _sdXCu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdY1N; else goto cdY1O;
       cdY1O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY1Q; else goto cdY1P;
       cdY1Q: // global
           HpAlloc = 16;
           goto cdY1N;
       cdY1N: // global
           R1 = _sdXCu::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY1P: // global
           _sdXBC::P64 = P64[_sdXCu::P64 + 7];
           _sdXBD::P64 = P64[_sdXCu::P64 + 15];
           I64[Hp - 8] = sat_sdXCq_info;
           P64[Hp] = _sdXBC::P64;
           I64[Sp - 16] = block_cdY1K_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdXBD::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXCu_info" {
     sat_sdXCu_info:
         const sat_sdXCu_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdY1K() //  [R1]
         { []
         }
     {offset
       cdY1K: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdY1K_info" {
     block_cdY1K_info:
         const _cdY1K;
         const 1;
         const 30;
 },
 sat_sdXCv_entry() //  [R1]
         { []
         }
     {offset
       cdY1S: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdY1W; else goto cdY1V;
       cdY1W: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY1V: // global
           _sdXBC::P64 = P64[R1 + 7];
           _sdXBD::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdXCu_info;
           P64[Hp - 8] = _sdXBC::P64;
           P64[Hp] = _sdXBD::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXCv_info" {
     sat_sdXCv_info:
         const sat_sdXCv_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SdXEo_srt+32;
 },
 Control.Concurrent.forkFinally1_entry() //  [R2, R3]
         { []
         }
     {offset
       cdY21: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdY22; else goto cdY23;
       cdY22: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.forkFinally1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdY23: // global
           I64[Sp - 24] = block_cdXZO_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.forkFinally1_info" {
     Control.Concurrent.forkFinally1_info:
         const Control.Concurrent.forkFinally1_entry;
         const 0;
         const 1103806595086;
         const 12884901903;
         const SdXEo_srt+32;
 },
 _cdXZO() //  [R1]
         { []
         }
     {offset
       cdXZO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdY26; else goto cdY25;
       cdY26: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdY25: // global
           _sdXBC::P64 = P64[Sp + 8];
           _sdXBD::P64 = P64[Sp + 16];
           if (R1 == 0) goto cdY1Z; else goto udY2j;
       cdY1Z: // global
           I64[Hp - 16] = sat_sdXCi_info;
           P64[Hp - 8] = _sdXBC::P64;
           P64[Hp] = _sdXBD::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       udY2j: // global
           if (R1 == 1) goto cdY20; else goto cdY1Y;
       cdY20: // global
           I64[Hp - 16] = sat_sdXCv_info;
           P64[Hp - 8] = _sdXBC::P64;
           P64[Hp] = _sdXBD::P64;
           I64[Sp + 16] = block_cdY2d_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
       cdY1Y: // global
           I64[Hp - 16] = sat_sdXBV_info;
           P64[Hp - 8] = _sdXBC::P64;
           P64[Hp] = _sdXBD::P64;
           I64[Sp + 16] = block_cdY27_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXZO_info" {
     block_cdXZO_info:
         const _cdXZO;
         const 2;
         const 4294967326;
         const SdXEo_srt+32;
 },
 _cdY2d() //  [R1]
         { []
         }
     {offset
       cdY2d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY2i; else goto cdY2h;
       cdY2i: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdY2h: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdY2d_info" {
     block_cdY2d_info:
         const _cdY2d;
         const 0;
         const 30;
 },
 _cdY27() //  [R1]
         { []
         }
     {offset
       cdY27: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY2c; else goto cdY2b;
       cdY2c: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdY2b: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdY27_info" {
     block_cdY27_info:
         const _cdY27;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.212399398 UTC

[section ""data" . Control.Concurrent.forkFinally_closure" {
     Control.Concurrent.forkFinally_closure:
         const Control.Concurrent.forkFinally_info;
         const 0;
 },
 Control.Concurrent.forkFinally_entry() //  [R2, R3]
         { []
         }
     {offset
       cdY47: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.forkFinally1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.forkFinally_info" {
     Control.Concurrent.forkFinally_info:
         const Control.Concurrent.forkFinally_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const SdXEo_srt+96;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.215533234 UTC

[section ""cstring" . lvl12_rdWo2_bytes" {
     lvl12_rdWo2_bytes:
         I8[] [67,97,110,110,111,116,32,99,114,101,97,116,101,32,79,83,32,116,104,114,101,97,100,46]
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.217923527 UTC

[section ""data" . Control.Concurrent.forkOS3_closure" {
     Control.Concurrent.forkOS3_closure:
         const Control.Concurrent.forkOS3_info;
         const 0;
 },
 Control.Concurrent.forkOS3_entry() //  []
         { []
         }
     {offset
       cdY4l: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdY4m; else goto cdY4n;
       cdY4m: // global
           R1 = Control.Concurrent.forkOS3_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY4n: // global
           I64[Sp - 8] = block_cdY4j_info;
           R2 = lvl12_rdWo2_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.forkOS3_info" {
     Control.Concurrent.forkOS3_info:
         const Control.Concurrent.forkOS3_entry;
         const 0;
         const 554050781198;
         const 4294967299;
         const SdXEo_srt+48;
 },
 _cdY4j() //  [R1]
         { []
         }
     {offset
       cdY4j: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdY4j_info" {
     block_cdY4j_info:
         const _cdY4j;
         const 0;
         const 4294967326;
         const SdXEo_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.227605319 UTC

[section ""data" . Control.Concurrent.forkOS1_closure" {
     Control.Concurrent.forkOS1_closure:
         const Control.Concurrent.forkOS1_info;
         const 0;
 },
 sat_sdXCW_entry() //  [R1]
         { []
         }
     {offset
       cdY55: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXCW_info" {
     sat_sdXCW_info:
         const sat_sdXCW_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_sdXCX_entry() //  [R1]
         { []
         }
     {offset
       cdY5c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY5g; else goto cdY5f;
       cdY5g: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdY5f: // global
           _sdXCC::P64 = P64[R1 + 16];
           _sdXCV::I64 = I64[R1 + 24];
           if (_sdXCV::I64 != 0) goto udY5h; else goto cdY5a;
       udY5h: // global
           if (_sdXCV::I64 != 1) goto cdY59; else goto cdY5b;
       cdY59: // global
           Hp = Hp - 16;
           R1 = _sdXCC::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdY5b: // global
           Hp = Hp - 16;
           R2 = _sdXCC::P64;
           R1 = GHC.IO.uninterruptibleMask_1_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cdY5a: // global
           I64[Hp - 8] = sat_sdXCW_info;
           P64[Hp] = _sdXCC::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXCX_info" {
     sat_sdXCX_info:
         const sat_sdXCX_entry;
         const 4294967297;
         const 19;
 },
 sat_sdXCY_entry() //  [R1]
         { []
         }
     {offset
       cdY5i: // global
           _sdXCY::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdY5j; else goto cdY5k;
       cdY5k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY5m; else goto cdY5l;
       cdY5m: // global
           HpAlloc = 16;
           goto cdY5j;
       cdY5j: // global
           R1 = _sdXCY::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY5l: // global
           _sdXCC::P64 = P64[_sdXCY::P64 + 7];
           _sdXCL::P64 = P64[_sdXCY::P64 + 15];
           _sdXCO::I64 = I64[_sdXCY::P64 + 23];
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           I64[Hp] = CurrentTSO;
           I64[Sp - 24] = block_cdY4R_info;
           R2 = Hp - 7;
           R1 = _sdXCL::P64;
           P64[Sp - 16] = _sdXCC::P64;
           I64[Sp - 8] = _sdXCO::I64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXCY_info" {
     sat_sdXCY_info:
         const sat_sdXCY_entry;
         const 4294967298;
         const 4294967304;
         const 4294967299;
         const SdXEo_srt+112;
 },
 _cdY4R() //  []
         { []
         }
     {offset
       cdY4R: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdY5p; else goto cdY5o;
       cdY5p: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdY5o: // global
           I64[Hp - 24] = sat_sdXCX_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R2 = GHC.Conc.Sync.childHandler1_closure+2;
           R1 = Hp - 24;
           Sp = Sp + 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdY4R_info" {
     block_cdY4R_info:
         const _cdY4R;
         const 130;
         const 4294967326;
         const SdXEo_srt+112;
 },
 Control.Concurrent.forkOS1_entry() //  [R2]
         { []
         }
     {offset
       cdY5t: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdY5u; else goto cdY5v;
       cdY5u: // global
           R2 = R2;
           R1 = Control.Concurrent.forkOS1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdY5v: // global
           (_sdXCH::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sdXCH::I64 == 0) goto cdY5s; else goto cdY5r;
       cdY5s: // global
           call Control.Concurrent.forkOS2_entry() args: 8, res: 0, upd: 8;
       cdY5r: // global
           I64[Sp - 16] = block_cdY4H_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.forkOS1_info" {
     Control.Concurrent.forkOS1_info:
         const Control.Concurrent.forkOS1_entry;
         const 0;
         const 1928440315918;
         const 8589934597;
         const SdXEo_srt+56;
 },
 _cdY4H() //  [R1]
         { []
         }
     {offset
       cdY4H: // global
           I64[Sp - 8] = block_cdY4J_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdY4H_info" {
     block_cdY4H_info:
         const _cdY4H;
         const 1;
         const 12884901918;
         const SdXEo_srt+104;
 },
 _cdY4J() //  [R1]
         { []
         }
     {offset
       cdY4J: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdY5A; else goto cdY5z;
       cdY5A: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdY5z: // global
           I64[Hp - 24] = sat_sdXCY_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = R1;
           I64[Sp] = block_cdY5w_info;
           R1 = Hp - 23;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdY4J_info" {
     block_cdY4J_info:
         const _cdY4J;
         const 2;
         const 12884901918;
         const SdXEo_srt+104;
 },
 _cdY5w() //  [R1]
         { []
         }
     {offset
       cdY5w: // global
           I64[Sp] = block_cdY5F_info;
           I64[Sp + 16] = R1;
           _udY64::P64 = CurrentTSO;
           I64[I64[_udY64::P64 + 24] + 16] = Sp;
           _udY65::I64 = CurrentNursery;
           P64[_udY65::I64 + 8] = Hp + 8;
           I64[_udY64::P64 + 104] = I64[_udY64::P64 + 104] - ((Hp + 8) - I64[_udY65::I64]);
           (_udY62::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sdXD5::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [‘signed’] forkOS_createThread(R1);
           (_udY63::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udY62::I64);
           BaseReg = _udY63::I64;
           _udY66::P64 = CurrentTSO;
           _udY67::P64 = I64[_udY66::P64 + 24];
           Sp = I64[_udY67::P64 + 16];
           SpLim = _udY67::P64 + 192;
           HpAlloc = 0;
           _udY68::I64 = CurrentNursery;
           _udY69::I64 = I64[_udY68::I64 + 8];
           Hp = _udY69::I64 - 8;
           _udY6a::I64 = I64[_udY68::I64];
           HpLim = _udY6a::I64 + ((%MO_SS_Conv_W32_W64(I32[_udY68::I64 + 48]) << 12) - 1);
           I64[_udY66::P64 + 104] = I64[_udY66::P64 + 104] + (_udY69::I64 - _udY6a::I64);
           R1 = _sdXD5::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdY5w_info" {
     block_cdY5w_info:
         const _cdY5w;
         const 130;
         const 4294967326;
         const SdXEo_srt+104;
 },
 _cdY5F() //  [R1]
         { []
         }
     {offset
       cdY5F: // global
           if (%MO_SS_Conv_W64_W32(R1) == 0 :: W32) goto cdY5W; else goto cdY5N;
       cdY5W: // global
           _sdXCL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdY5V_info;
           R1 = _sdXCL::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdY5N: // global
           Sp = Sp + 24;
           call Control.Concurrent.forkOS3_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdY5F_info" {
     block_cdY5F_info:
         const _cdY5F;
         const 130;
         const 4294967326;
         const SdXEo_srt+104;
 },
 _cdY5V() //  [R1]
         { []
         }
     {offset
       cdY5V: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdY5V_info" {
     block_cdY5V_info:
         const _cdY5V;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.247727378 UTC

[section ""data" . Control.Concurrent.forkOS_closure" {
     Control.Concurrent.forkOS_closure:
         const Control.Concurrent.forkOS_info;
         const 0;
 },
 Control.Concurrent.forkOS_entry() //  [R2]
         { []
         }
     {offset
       cdY7l: // global
           R2 = R2;
           call Control.Concurrent.forkOS1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.forkOS_info" {
     Control.Concurrent.forkOS_info:
         const Control.Concurrent.forkOS_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SdXEo_srt+120;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.252717836 UTC

[section ""data" . Control.Concurrent.forkOSWithUnmask1_closure" {
     Control.Concurrent.forkOSWithUnmask1_closure:
         const Control.Concurrent.forkOSWithUnmask1_info;
         const 0;
 },
 sat_sdXDg_entry() //  [R2]
         { []
         }
     {offset
       cdY7F: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdXDg_info" {
     sat_sdXDg_info:
         const sat_sdXDg_entry;
         const 4294967296;
         const 10;
         const 8589934597;
 },
 sat_sdXDh_entry() //  [R1]
         { []
         }
     {offset
       cdY7I: // global
           _sdXDh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdY7J; else goto cdY7K;
       cdY7K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY7M; else goto cdY7L;
       cdY7M: // global
           HpAlloc = 16;
           goto cdY7J;
       cdY7J: // global
           R1 = _sdXDh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdY7L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdXDh::P64;
           _sdXDe::P64 = P64[_sdXDh::P64 + 16];
           I64[Hp - 8] = sat_sdXDg_info;
           R2 = Hp - 6;
           R1 = _sdXDe::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdXDh_info" {
     sat_sdXDh_info:
         const sat_sdXDh_entry;
         const 1;
         const 16;
 },
 Control.Concurrent.forkOSWithUnmask1_entry() //  [R2]
         { []
         }
     {offset
       cdY7N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdY7R; else goto cdY7Q;
       cdY7R: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Concurrent.forkOSWithUnmask1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdY7Q: // global
           I64[Hp - 16] = sat_sdXDh_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Concurrent.forkOS1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.forkOSWithUnmask1_info" {
     Control.Concurrent.forkOSWithUnmask1_info:
         const Control.Concurrent.forkOSWithUnmask1_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const SdXEo_srt+120;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.259783885 UTC

[section ""data" . Control.Concurrent.forkOSWithUnmask_closure" {
     Control.Concurrent.forkOSWithUnmask_closure:
         const Control.Concurrent.forkOSWithUnmask_info;
         const 0;
 },
 Control.Concurrent.forkOSWithUnmask_entry() //  [R2]
         { []
         }
     {offset
       cdY8a: // global
           R2 = R2;
           call Control.Concurrent.forkOSWithUnmask1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.forkOSWithUnmask_info" {
     Control.Concurrent.forkOSWithUnmask_info:
         const Control.Concurrent.forkOSWithUnmask_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SdXEo_srt+128;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.264219637 UTC

[section ""data" . Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_closure" {
     Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_closure:
         const Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_info;
 },
 Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_entry() //  [R2]
         { []
         }
     {offset
       cdY8o: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdY8s; else goto cdY8t;
       cdY8s: // global
           R2 = R2;
           R1 = Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdY8t: // global
           I64[Sp - 8] = block_cdY8l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udY8x; else goto cdY8m;
       udY8x: // global
           call _cdY8l(R1) args: 0, res: 0, upd: 0;
       cdY8m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_info" {
     Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_info:
         const Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cdY8l() //  [R1]
         { []
         }
     {offset
       cdY8l: // global
           I64[Sp] = block_cdY8r_info;
           R1 = I64[R1 + 7];
           call stg_deRefStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdY8l_info" {
     block_cdY8l_info:
         const _cdY8l;
         const 0;
         const 30;
 },
 _cdY8r() //  [R1]
         { []
         }
     {offset
       cdY8r: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdY8r_info" {
     block_cdY8r_info:
         const _cdY8r;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.270942257 UTC

[section ""data" . Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_closure" {
     Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_closure:
         const Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_info;
 },
 Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_entry() //  [R2]
         { []
         }
     {offset
       cdY8Q: // global
           R2 = R2;
           call Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_info" {
     Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_info:
         const Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:09:15.274189327 UTC

[section ""relreadonly" . SdXEo_srt" {
     SdXEo_srt:
         const GHC.Conc.IO.threadWaitRead1_closure;
         const GHC.Conc.IO.threadWaitWrite1_closure;
         const GHC.Conc.IO.threadWaitReadSTM1_closure;
         const GHC.Conc.IO.threadWaitWriteSTM1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const Control.Concurrent.runInUnboundThread1_closure;
         const GHC.IO.failIO1_closure;
         const Control.Concurrent.forkOS2_closure;
         const GHC.Err.undefined_closure;
         const lvl11_rdWo1_closure;
         const Control.Concurrent.runInBoundThread1_closure;
         const Control.Concurrent.runInBoundThread2_closure;
         const Control.Concurrent.forkFinally1_closure;
         const Control.Concurrent.forkOS3_closure;
         const GHC.Conc.Sync.childHandler1_closure;
         const Control.Concurrent.forkOS1_closure;
         const Control.Concurrent.forkOSWithUnmask1_closure;
 }]

