
==================== Output Cmm ====================
2018-03-16 16:09:12.194556328 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:12.195782863 UTC

[section ""data" . Control.Concurrent.isCurrentThreadBound1_closure" {
     Control.Concurrent.isCurrentThreadBound1_closure:
         const Control.Concurrent.isCurrentThreadBound1_info;
 },
 sat_sdWo9_entry() //  [R1]
         { info_tbl: [(cdWu8,
                       label: sat_sdWo9_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWu8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWu9; else goto cdWua;
       cdWu9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdWua: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto cdWu7; else goto cdWu6;
       cdWu7: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdWu6: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Concurrent.isCurrentThreadBound1_entry() //  []
         { info_tbl: [(cdWub,
                       label: Control.Concurrent.isCurrentThreadBound1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWub: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWuc; else goto cdWud;
       cdWuc: // global
           R1 = Control.Concurrent.isCurrentThreadBound1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWud: // global
           I64[Sp - 8] = block_cdWtY_info;
           Sp = Sp - 8;
           call stg_isCurrentThreadBound#() args: 8, res: 8, upd: 8;
     }
 },
 _cdWtY() //  [R1]
         { info_tbl: [(cdWtY,
                       label: block_cdWtY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWtY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWug; else goto cdWuf;
       cdWug: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdWuf: // global
           I64[Hp - 16] = sat_sdWo9_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.19736345 UTC

[section ""data" . Control.Concurrent.isCurrentThreadBound_closure" {
     Control.Concurrent.isCurrentThreadBound_closure:
         const Control.Concurrent.isCurrentThreadBound_info;
 },
 Control.Concurrent.isCurrentThreadBound_entry() //  []
         { info_tbl: [(cdWul,
                       label: Control.Concurrent.isCurrentThreadBound_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWul: // global
           call Control.Concurrent.isCurrentThreadBound1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.198248804 UTC

[section ""data" . Control.Concurrent.threadWaitRead_closure" {
     Control.Concurrent.threadWaitRead_closure:
         const Control.Concurrent.threadWaitRead_info;
         const 0;
 },
 Control.Concurrent.threadWaitRead_entry() //  [R2]
         { info_tbl: [(cdWus,
                       label: Control.Concurrent.threadWaitRead_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWus: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitRead1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.199158274 UTC

[section ""data" . Control.Concurrent.threadWaitWrite_closure" {
     Control.Concurrent.threadWaitWrite_closure:
         const Control.Concurrent.threadWaitWrite_info;
         const 0;
 },
 Control.Concurrent.threadWaitWrite_entry() //  [R2]
         { info_tbl: [(cdWuA,
                       label: Control.Concurrent.threadWaitWrite_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWuA: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWrite1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.200014217 UTC

[section ""data" . Control.Concurrent.threadWaitReadSTM_closure" {
     Control.Concurrent.threadWaitReadSTM_closure:
         const Control.Concurrent.threadWaitReadSTM_info;
         const 0;
 },
 Control.Concurrent.threadWaitReadSTM_entry() //  [R2]
         { info_tbl: [(cdWuH,
                       label: Control.Concurrent.threadWaitReadSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWuH: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitReadSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.200897902 UTC

[section ""data" . Control.Concurrent.threadWaitWriteSTM_closure" {
     Control.Concurrent.threadWaitWriteSTM_closure:
         const Control.Concurrent.threadWaitWriteSTM_info;
         const 0;
 },
 Control.Concurrent.threadWaitWriteSTM_entry() //  [R2]
         { info_tbl: [(cdWuO,
                       label: Control.Concurrent.threadWaitWriteSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWuO: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWriteSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.201727423 UTC

[section ""cstring" . Control.Concurrent.$trModule4_bytes" {
     Control.Concurrent.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.20233907 UTC

[section ""data" . Control.Concurrent.$trModule3_closure" {
     Control.Concurrent.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.202950051 UTC

[section ""cstring" . Control.Concurrent.$trModule2_bytes" {
     Control.Concurrent.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.203633203 UTC

[section ""data" . Control.Concurrent.$trModule1_closure" {
     Control.Concurrent.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.204305364 UTC

[section ""data" . Control.Concurrent.$trModule_closure" {
     Control.Concurrent.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.$trModule3_closure+1;
         const Control.Concurrent.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.205328414 UTC

[section ""data" . Control.Concurrent.rtsSupportsBoundThreads_closure" {
     Control.Concurrent.rtsSupportsBoundThreads_closure:
         const Control.Concurrent.rtsSupportsBoundThreads_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Concurrent.rtsSupportsBoundThreads_entry() //  [R1]
         { info_tbl: [(cdWv2,
                       label: Control.Concurrent.rtsSupportsBoundThreads_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWv2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWv3; else goto cdWv4;
       cdWv3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdWv4: // global
           (_cdWuU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdWuU::I64 == 0) goto cdWuW; else goto cdWuV;
       cdWuW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdWuV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdWuU::I64;
           (_sdWod::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sdWod::I64 == 0) goto cdWv1; else goto cdWv0;
       cdWv1: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdWv0: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.206749708 UTC

[section ""data" . Control.Concurrent.forkFinally2_closure" {
     Control.Concurrent.forkFinally2_closure:
         const Control.Concurrent.forkFinally2_info;
 },
 Control.Concurrent.forkFinally2_entry() //  [R2]
         { info_tbl: [(cdWva,
                       label: Control.Concurrent.forkFinally2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWva: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWve; else goto cdWvd;
       cdWve: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Control.Concurrent.forkFinally2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdWvd: // global
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.212380137 UTC

[section ""data" . Control.Concurrent.runInUnboundThread1_closure" {
     Control.Concurrent.runInUnboundThread1_closure:
         const Control.Concurrent.runInUnboundThread1_info;
         const 0;
 },
 lvl13_sdWou_entry() //  [R1]
         { info_tbl: [(cdWvw,
                       label: lvl13_sdWou_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWvw: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWoE_entry() //  [R1]
         { info_tbl: [(cdWvT,
                       label: sat_sdWoE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWvT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWvU; else goto cdWvV;
       cdWvU: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWvV: // global
           I64[Sp - 8] = block_cdWvQ_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWvQ() //  [R1]
         { info_tbl: [(cdWvQ,
                       label: block_cdWvQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWvQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWvY; else goto cdWvX;
       cdWvY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWvX: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWoJ_entry() //  [R1]
         { info_tbl: [(cdWw3,
                       label: sat_sdWoJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWw3: // global
           _sdWoJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWw4; else goto cdWw5;
       cdWw5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWw7; else goto cdWw6;
       cdWw7: // global
           HpAlloc = 16;
           goto cdWw4;
       cdWw4: // global
           R1 = _sdWoJ::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWw6: // global
           _sdWoi::P64 = P64[_sdWoJ::P64 + 7];
           _sdWoq::P64 = P64[_sdWoJ::P64 + 15];
           I64[Hp - 8] = sat_sdWoE_info;
           P64[Hp] = _sdWoi::P64;
           I64[Sp - 16] = block_cdWvZ_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWoq::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWvZ() //  [R1]
         { info_tbl: [(cdWvZ,
                       label: block_cdWvZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWvZ: // global
           _sdWoq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdWw1_info;
           R2 = R1;
           R1 = _sdWoq::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWw1() //  []
         { info_tbl: [(cdWw1,
                       label: block_cdWw1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWw1: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWoK_entry() //  [R1]
         { info_tbl: [(cdWwa,
                       label: sat_sdWoK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWwa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWwe; else goto cdWwd;
       cdWwe: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWwd: // global
           _sdWoi::P64 = P64[R1 + 7];
           _sdWoq::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWoJ_info;
           P64[Hp - 8] = _sdWoi::P64;
           P64[Hp] = _sdWoq::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWoT_entry() //  [R1, R2]
         { info_tbl: [(cdWwt,
                       label: sat_sdWoT_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWwt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWwu; else goto cdWwv;
       cdWwu: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdWwv: // global
           I64[Sp - 16] = block_cdWwr_info;
           R2 = R2;
           _sdWoO::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdWoO::P64;
           Sp = Sp - 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWwr() //  []
         { info_tbl: [(cdWwr,
                       label: block_cdWwr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWwr: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call wait_sdWoO_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 wait_sdWoO_entry() //  [R1]
         { info_tbl: [(cdWwx,
                       label: wait_sdWoO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWwx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWwB; else goto cdWwA;
       cdWwB: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWwA: // global
           _sdWou::P64 = P64[R1 + 7];
           _sdWoN::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWoT_info;
           P64[Hp - 8] = _sdWoN::P64;
           P64[Hp] = R1;
           R2 = Hp - 14;
           R1 = _sdWou::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWp8_entry() //  [R1]
         { info_tbl: [(cdWx0,
                       label: sat_sdWp8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWx0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWx1; else goto cdWx2;
       cdWx1: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWx2: // global
           I64[Sp - 8] = block_cdWwX_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWwX() //  [R1]
         { info_tbl: [(cdWwX,
                       label: block_cdWwX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWwX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWx5; else goto cdWx4;
       cdWx5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWx4: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpd_entry() //  [R1]
         { info_tbl: [(cdWxa,
                       label: sat_sdWpd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWxa: // global
           _sdWpd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWxb; else goto cdWxc;
       cdWxc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWxe; else goto cdWxd;
       cdWxe: // global
           HpAlloc = 16;
           goto cdWxb;
       cdWxb: // global
           R1 = _sdWpd::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWxd: // global
           _sdWoi::P64 = P64[_sdWpd::P64 + 7];
           _sdWoq::P64 = P64[_sdWpd::P64 + 15];
           I64[Hp - 8] = sat_sdWp8_info;
           P64[Hp] = _sdWoi::P64;
           I64[Sp - 16] = block_cdWx6_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWoq::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWx6() //  [R1]
         { info_tbl: [(cdWx6,
                       label: block_cdWx6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWx6: // global
           _sdWoq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdWx8_info;
           R2 = R1;
           R1 = _sdWoq::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWx8() //  []
         { info_tbl: [(cdWx8,
                       label: block_cdWx8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWx8: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpe_entry() //  [R1]
         { info_tbl: [(cdWxh,
                       label: sat_sdWpe_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWxh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWxl; else goto cdWxk;
       cdWxl: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWxk: // global
           _sdWoi::P64 = P64[R1 + 7];
           _sdWoq::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWpd_info;
           P64[Hp - 8] = _sdWoi::P64;
           P64[Hp] = _sdWoq::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpn_entry() //  [R1, R2]
         { info_tbl: [(cdWxA,
                       label: sat_sdWpn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWxA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWxB; else goto cdWxC;
       cdWxB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdWxC: // global
           I64[Sp - 16] = block_cdWxy_info;
           R2 = R2;
           _sdWpi::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdWpi::P64;
           Sp = Sp - 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWxy() //  []
         { info_tbl: [(cdWxy,
                       label: block_cdWxy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWxy: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call wait_sdWpi_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 wait_sdWpi_entry() //  [R1]
         { info_tbl: [(cdWxE,
                       label: wait_sdWpi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWxE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWxI; else goto cdWxH;
       cdWxI: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWxH: // global
           _sdWou::P64 = P64[R1 + 7];
           _sdWph::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWpn_info;
           P64[Hp - 8] = _sdWph::P64;
           P64[Hp] = R1;
           R2 = Hp - 14;
           R1 = _sdWou::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpu_entry() //  [R1]
         { info_tbl: [(cdWxS,
                       label: sat_sdWpu_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWxS: // global
           _sdWpu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWxT; else goto cdWxU;
       cdWxU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWxW; else goto cdWxV;
       cdWxW: // global
           HpAlloc = 24;
           goto cdWxT;
       cdWxT: // global
           R1 = _sdWpu::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWxV: // global
           _sdWoi::P64 = P64[_sdWpu::P64 + 7];
           _sdWoq::P64 = P64[_sdWpu::P64 + 15];
           _sdWou::P64 = P64[_sdWpu::P64 + 23];
           I64[Hp - 16] = sat_sdWpe_info;
           P64[Hp - 8] = _sdWoi::P64;
           P64[Hp] = _sdWoq::P64;
           I64[Sp - 16] = block_cdWxm_info;
           R1 = Hp - 15;
           P64[Sp - 8] = _sdWou::P64;
           Sp = Sp - 16;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWxm() //  [R1]
         { info_tbl: [(cdWxm,
                       label: block_cdWxm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWxm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWxZ; else goto cdWxY;
       cdWxZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWxY: // global
           I64[Hp - 16] = wait_sdWpi_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cdWxJ_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call wait_sdWpi_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWxJ() //  [R1]
         { info_tbl: [(cdWxJ,
                       label: block_cdWxJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWxJ: // global
           I64[Sp] = block_cdWxL_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udWy7; else goto cdWxM;
       udWy7: // global
           call _cdWxL(R1) args: 0, res: 0, upd: 0;
       cdWxM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWxL() //  [R1]
         { info_tbl: [(cdWxL,
                       label: block_cdWxL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWxL: // global
           if (R1 & 7 == 1) goto cdWxP; else goto cdWxQ;
       cdWxP: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdWxQ: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpC_entry() //  [R1]
         { info_tbl: [(cdWyr,
                       label: sat_sdWpC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWyr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWys; else goto cdWyt;
       cdWys: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWyt: // global
           I64[Sp - 8] = block_cdWyo_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWyo() //  [R1]
         { info_tbl: [(cdWyo,
                       label: block_cdWyo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWyo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWyw; else goto cdWyv;
       cdWyw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWyv: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpH_entry() //  [R1]
         { info_tbl: [(cdWyB,
                       label: sat_sdWpH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWyB: // global
           _sdWpH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWyC; else goto cdWyD;
       cdWyD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWyF; else goto cdWyE;
       cdWyF: // global
           HpAlloc = 16;
           goto cdWyC;
       cdWyC: // global
           R1 = _sdWpH::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWyE: // global
           _sdWoi::P64 = P64[_sdWpH::P64 + 7];
           _sdWoq::P64 = P64[_sdWpH::P64 + 15];
           I64[Hp - 8] = sat_sdWpC_info;
           P64[Hp] = _sdWoi::P64;
           I64[Sp - 16] = block_cdWyx_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWoq::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWyx() //  [R1]
         { info_tbl: [(cdWyx,
                       label: block_cdWyx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWyx: // global
           _sdWoq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdWyz_info;
           R2 = R1;
           R1 = _sdWoq::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWyz() //  []
         { info_tbl: [(cdWyz,
                       label: block_cdWyz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWyz: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpI_entry() //  [R1]
         { info_tbl: [(cdWyI,
                       label: sat_sdWpI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWyI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWyM; else goto cdWyL;
       cdWyM: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWyL: // global
           _sdWoi::P64 = P64[R1 + 7];
           _sdWoq::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWpH_info;
           P64[Hp - 8] = _sdWoi::P64;
           P64[Hp] = _sdWoq::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpR_entry() //  [R1, R2]
         { info_tbl: [(cdWz1,
                       label: sat_sdWpR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWz1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWz2; else goto cdWz3;
       cdWz2: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdWz3: // global
           I64[Sp - 16] = block_cdWyZ_info;
           R2 = R2;
           _sdWpM::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdWpM::P64;
           Sp = Sp - 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWyZ() //  []
         { info_tbl: [(cdWyZ,
                       label: block_cdWyZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWyZ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call wait_sdWpM_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 wait_sdWpM_entry() //  [R1]
         { info_tbl: [(cdWz5,
                       label: wait_sdWpM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWz5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWz9; else goto cdWz8;
       cdWz9: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWz8: // global
           _sdWou::P64 = P64[R1 + 7];
           _sdWpL::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWpR_info;
           P64[Hp - 8] = _sdWpL::P64;
           P64[Hp] = R1;
           R2 = Hp - 14;
           R1 = _sdWou::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.runInUnboundThread1_entry() //  [R2]
         { info_tbl: [(cdWzd,
                       label: Control.Concurrent.runInUnboundThread1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWzd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdWze; else goto cdWzf;
       cdWze: // global
           R2 = R2;
           R1 = Control.Concurrent.runInUnboundThread1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdWzf: // global
           I64[Sp - 16] = block_cdWvj_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_isCurrentThreadBound#() args: 8, res: 8, upd: 8;
     }
 },
 _cdWvj() //  [R1]
         { info_tbl: [(cdWvj,
                       label: block_cdWvj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWvj: // global
           if (R1 == 0) goto cdWzc; else goto cdWzb;
       cdWzc: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       cdWzb: // global
           I64[Sp] = block_cdWvn_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdWvn() //  [R1]
         { info_tbl: [(cdWvn,
                       label: block_cdWvn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWvn: // global
           I64[Sp - 8] = block_cdWvp_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdWvp() //  [R1]
         { info_tbl: [(cdWvp,
                       label: block_cdWvp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWvp: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdWzk; else goto cdWzj;
       cdWzk: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdWzj: // global
           I64[Hp - 40] = lvl13_sdWou_info;
           _sdWoq::P64 = P64[Sp + 8];
           P64[Hp - 32] = _sdWoq::P64;
           _sdWoi::P64 = P64[Sp + 16];
           _cdWvr::P64 = Hp - 39;
           if (R1 == 0) goto cdWzF; else goto udWA1;
       cdWzF: // global
           I64[Hp - 24] = sat_sdWpu_info;
           P64[Hp - 16] = _sdWoi::P64;
           P64[Hp - 8] = _sdWoq::P64;
           P64[Hp] = _cdWvr::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       udWA1: // global
           if (R1 == 1) goto cdWzJ; else goto cdWzp;
       cdWzJ: // global
           I64[Hp - 24] = sat_sdWpI_info;
           P64[Hp - 16] = _sdWoi::P64;
           P64[Hp - 8] = _sdWoq::P64;
           _cdWy9::P64 = Hp - 23;
           Hp = Hp - 8;
           I64[Sp + 8] = block_cdWyN_info;
           R1 = _cdWy9::P64;
           P64[Sp + 16] = _cdWvr::P64;
           Sp = Sp + 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
       cdWzp: // global
           I64[Hp - 24] = sat_sdWoK_info;
           P64[Hp - 16] = _sdWoi::P64;
           P64[Hp - 8] = _sdWoq::P64;
           _cdWvB::P64 = Hp - 23;
           Hp = Hp - 8;
           I64[Sp + 8] = block_cdWwf_info;
           R1 = _cdWvB::P64;
           P64[Sp + 16] = _cdWvr::P64;
           Sp = Sp + 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWyN() //  [R1]
         { info_tbl: [(cdWyN,
                       label: block_cdWyN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWyN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWzM; else goto cdWzL;
       cdWzM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWzL: // global
           I64[Hp - 16] = wait_sdWpM_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cdWzG_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call wait_sdWpM_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWzG() //  [R1]
         { info_tbl: [(cdWzG,
                       label: block_cdWzG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWzG: // global
           I64[Sp] = block_cdWzI_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udWA3; else goto cdWzO;
       udWA3: // global
           call _cdWzI(R1) args: 0, res: 0, upd: 0;
       cdWzO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWzI() //  [R1]
         { info_tbl: [(cdWzI,
                       label: block_cdWzI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWzI: // global
           if (R1 & 7 == 1) goto cdWzU; else goto cdWzY;
       cdWzU: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdWzY: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdWwf() //  [R1]
         { info_tbl: [(cdWwf,
                       label: block_cdWwf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWwf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWzs; else goto cdWzr;
       cdWzs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWzr: // global
           I64[Hp - 16] = wait_sdWoO_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cdWzl_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call wait_sdWoO_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWzl() //  [R1]
         { info_tbl: [(cdWzl,
                       label: block_cdWzl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWzl: // global
           I64[Sp] = block_cdWzn_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udWA2; else goto cdWzu;
       udWA2: // global
           call _cdWzn(R1) args: 0, res: 0, upd: 0;
       cdWzu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWzn() //  [R1]
         { info_tbl: [(cdWzn,
                       label: block_cdWzn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWzn: // global
           if (R1 & 7 == 1) goto cdWzA; else goto cdWzE;
       cdWzA: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdWzE: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.224359954 UTC

[section ""data" . Control.Concurrent.runInUnboundThread_closure" {
     Control.Concurrent.runInUnboundThread_closure:
         const Control.Concurrent.runInUnboundThread_info;
         const 0;
 },
 Control.Concurrent.runInUnboundThread_entry() //  [R2]
         { info_tbl: [(cdWA8,
                       label: Control.Concurrent.runInUnboundThread_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWA8: // global
           R2 = R2;
           call Control.Concurrent.runInUnboundThread1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.225192501 UTC

[section ""cstring" . lvl_rdWnQ_bytes" {
     lvl_rdWnQ_bytes:
         I8[] [82,84,83,32,100,111,101,115,110,39,116,32,115,117,112,112,111,114,116,32,109,117,108,116,105,112,108,101,32,79,83,32,116,104,114,101,97,100,115,32,40,117,115,101,32,103,104,99,32,45,116,104,114,101,97,100,101,100,32,119,104,101,110,32,108,105,110,107,105,110,103,41]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.226018289 UTC

[section ""data" . Control.Concurrent.forkOS2_closure" {
     Control.Concurrent.forkOS2_closure:
         const Control.Concurrent.forkOS2_info;
         const 0;
 },
 Control.Concurrent.forkOS2_entry() //  []
         { info_tbl: [(cdWAh,
                       label: Control.Concurrent.forkOS2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWAh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWAi; else goto cdWAj;
       cdWAi: // global
           R1 = Control.Concurrent.forkOS2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWAj: // global
           I64[Sp - 8] = block_cdWAf_info;
           R2 = lvl_rdWnQ_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdWAf() //  [R1]
         { info_tbl: [(cdWAf,
                       label: block_cdWAf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWAf: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.226989238 UTC

[section ""cstring" . lvl1_rdWnR_bytes" {
     lvl1_rdWnR_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.227755916 UTC

[section ""data" . lvl2_rdWnS_closure" {
     lvl2_rdWnS_closure:
         const lvl2_rdWnS_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rdWnS_entry() //  [R1]
         { info_tbl: [(cdWAt,
                       label: lvl2_rdWnS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWAt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWAu; else goto cdWAv;
       cdWAu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdWAv: // global
           (_cdWAq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdWAq::I64 == 0) goto cdWAs; else goto cdWAr;
       cdWAs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdWAr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdWAq::I64;
           R2 = lvl1_rdWnR_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.228875454 UTC

[section ""data" . lvl3_rdWnT_closure" {
     lvl3_rdWnT_closure:
         const lvl3_rdWnT_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rdWnT_entry() //  [R1]
         { info_tbl: [(cdWAC,
                       label: lvl3_rdWnT_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWAC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWAD; else goto cdWAE;
       cdWAD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdWAE: // global
           (_cdWAz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdWAz::I64 == 0) goto cdWAB; else goto cdWAA;
       cdWAB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdWAA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdWAz::I64;
           R2 = Control.Concurrent.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.230353757 UTC

[section ""data" . lvl4_rdWnU_closure" {
     lvl4_rdWnU_closure:
         const lvl4_rdWnU_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rdWnU_entry() //  [R1]
         { info_tbl: [(cdWAL,
                       label: lvl4_rdWnU_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWAL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWAM; else goto cdWAN;
       cdWAM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdWAN: // global
           (_cdWAI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdWAI::I64 == 0) goto cdWAK; else goto cdWAJ;
       cdWAK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdWAJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdWAI::I64;
           R2 = Control.Concurrent.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.231353519 UTC

[section ""cstring" . lvl5_rdWnV_bytes" {
     lvl5_rdWnV_bytes:
         I8[] [46,47,67,111,110,116,114,111,108,47,67,111,110,99,117,114,114,101,110,116,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.232133942 UTC

[section ""data" . lvl6_rdWnW_closure" {
     lvl6_rdWnW_closure:
         const lvl6_rdWnW_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rdWnW_entry() //  [R1]
         { info_tbl: [(cdWAU,
                       label: lvl6_rdWnW_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWAU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWAV; else goto cdWAW;
       cdWAV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdWAW: // global
           (_cdWAR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdWAR::I64 == 0) goto cdWAT; else goto cdWAS;
       cdWAT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdWAS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdWAR::I64;
           R2 = lvl5_rdWnV_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.233100708 UTC

[section ""data" . lvl7_rdWnX_closure" {
     lvl7_rdWnX_closure:
         const GHC.Types.I#_con_info;
         const 353;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.233706465 UTC

[section ""data" . lvl8_rdWnY_closure" {
     lvl8_rdWnY_closure:
         const GHC.Types.I#_con_info;
         const 33;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.234331008 UTC

[section ""data" . lvl9_rdWnZ_closure" {
     lvl9_rdWnZ_closure:
         const GHC.Types.I#_con_info;
         const 42;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.234934448 UTC

[section ""data" . lvl10_rdWo0_closure" {
     lvl10_rdWo0_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_rdWnT_closure;
         const lvl4_rdWnU_closure;
         const lvl6_rdWnW_closure;
         const lvl7_rdWnX_closure+1;
         const lvl8_rdWnY_closure+1;
         const lvl7_rdWnX_closure+1;
         const lvl9_rdWnZ_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.235564829 UTC

[section ""data" . lvl11_rdWo1_closure" {
     lvl11_rdWo1_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_rdWnS_closure;
         const lvl10_rdWo0_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.236374581 UTC

[section ""data" . Control.Concurrent.runInBoundThread2_closure" {
     Control.Concurrent.runInBoundThread2_closure:
         const Control.Concurrent.runInBoundThread2_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Concurrent.runInBoundThread2_entry() //  [R1]
         { info_tbl: [(cdWB3,
                       label: Control.Concurrent.runInBoundThread2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWB3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWB4; else goto cdWB5;
       cdWB4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdWB5: // global
           (_cdWB0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdWB0::I64 == 0) goto cdWB2; else goto cdWB1;
       cdWB2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdWB1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdWB0::I64;
           R2 = lvl11_rdWo1_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.242024769 UTC

[section ""data" . Control.Concurrent.runInBoundThread1_closure" {
     Control.Concurrent.runInBoundThread1_closure:
         const Control.Concurrent.runInBoundThread1_info;
         const 0;
 },
 sat_sdWqo_entry() //  [R1]
         { info_tbl: [(cdWBB,
                       label: sat_sdWqo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWBB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWBC; else goto cdWBD;
       cdWBC: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWBD: // global
           I64[Sp - 8] = block_cdWBy_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWBy() //  [R1]
         { info_tbl: [(cdWBy,
                       label: block_cdWBy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWBy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWBG; else goto cdWBF;
       cdWBG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWBF: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWqt_entry() //  [R1]
         { info_tbl: [(cdWBM,
                       label: sat_sdWqt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWBM: // global
           _sdWqt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWBN; else goto cdWBO;
       cdWBO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWBQ; else goto cdWBP;
       cdWBQ: // global
           HpAlloc = 16;
           goto cdWBN;
       cdWBN: // global
           R1 = _sdWqt::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWBP: // global
           _sdWq0::P64 = P64[_sdWqt::P64 + 7];
           _sdWqd::P64 = P64[_sdWqt::P64 + 15];
           I64[Hp - 8] = sat_sdWqo_info;
           P64[Hp] = _sdWq0::P64;
           I64[Sp - 16] = block_cdWBH_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWqd::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWBH() //  [R1]
         { info_tbl: [(cdWBH,
                       label: block_cdWBH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWBH: // global
           _sdWqd::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sdWqd::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sdWqd::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWqI_entry() //  [R1, R2]
         { info_tbl: [(cdWC1,
                       label: sat_sdWqI_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWC1: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[R1 + 6]);
           R1 = R2;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWqB_entry() //  [R1]
         { info_tbl: [(cdWCe,
                       label: sat_sdWqB_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWCe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWCf; else goto cdWCg;
       cdWCf: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWCg: // global
           I64[Sp - 16] = block_cdWCb_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           _cdWCa::I64 = I64[R1 + 15];
           _udWCk::P64 = CurrentTSO;
           I64[I64[_udWCk::P64 + 24] + 16] = Sp;
           _udWCl::I64 = CurrentNursery;
           P64[_udWCl::I64 + 8] = Hp + 8;
           I64[_udWCk::P64 + 104] = I64[_udWCk::P64 + 104] - ((Hp + 8) - I64[_udWCl::I64]);
           (_udWCi::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] forkOS_entry(_cdWCa::I64);
           (_udWCj::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udWCi::I64);
           BaseReg = _udWCj::I64;
           _udWCm::P64 = CurrentTSO;
           _udWCn::P64 = I64[_udWCm::P64 + 24];
           Sp = I64[_udWCn::P64 + 16];
           SpLim = _udWCn::P64 + 192;
           HpAlloc = 0;
           _udWCo::I64 = CurrentNursery;
           _udWCp::I64 = I64[_udWCo::I64 + 8];
           Hp = _udWCp::I64 - 8;
           _udWCq::I64 = I64[_udWCo::I64];
           HpLim = _udWCq::I64 + ((%MO_SS_Conv_W32_W64(I32[_udWCo::I64 + 48]) << 12) - 1);
           I64[_udWCm::P64 + 104] = I64[_udWCm::P64 + 104] + (_udWCp::I64 - _udWCq::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdWCb() //  []
         { info_tbl: [(cdWCb,
                       label: block_cdWCb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWCb: // global
           R1 = P64[P64[Sp + 8] + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWqC_entry() //  [R1]
         { info_tbl: [(cdWCx,
                       label: sat_sdWqC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWCx: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWqZ_entry() //  [R1]
         { info_tbl: [(cdWCT,
                       label: sat_sdWqZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWCT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWCU; else goto cdWCV;
       cdWCU: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWCV: // global
           I64[Sp - 8] = block_cdWCQ_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWCQ() //  [R1]
         { info_tbl: [(cdWCQ,
                       label: block_cdWCQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWCQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWCY; else goto cdWCX;
       cdWCY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWCX: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWr4_entry() //  [R1]
         { info_tbl: [(cdWD4,
                       label: sat_sdWr4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWD4: // global
           _sdWr4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWD5; else goto cdWD6;
       cdWD6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWD8; else goto cdWD7;
       cdWD8: // global
           HpAlloc = 16;
           goto cdWD5;
       cdWD5: // global
           R1 = _sdWr4::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWD7: // global
           _sdWq0::P64 = P64[_sdWr4::P64 + 7];
           _sdWqd::P64 = P64[_sdWr4::P64 + 15];
           I64[Hp - 8] = sat_sdWqZ_info;
           P64[Hp] = _sdWq0::P64;
           I64[Sp - 16] = block_cdWCZ_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWqd::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWCZ() //  [R1]
         { info_tbl: [(cdWCZ,
                       label: block_cdWCZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWCZ: // global
           _sdWqd::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sdWqd::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sdWqd::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrj_entry() //  [R1, R2]
         { info_tbl: [(cdWDj,
                       label: sat_sdWrj_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWDj: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[R1 + 6]);
           R1 = R2;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrc_entry() //  [R1]
         { info_tbl: [(cdWDw,
                       label: sat_sdWrc_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWDw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWDx; else goto cdWDy;
       cdWDx: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWDy: // global
           I64[Sp - 16] = block_cdWDt_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           _cdWDs::I64 = I64[R1 + 15];
           _udWDC::P64 = CurrentTSO;
           I64[I64[_udWDC::P64 + 24] + 16] = Sp;
           _udWDD::I64 = CurrentNursery;
           P64[_udWDD::I64 + 8] = Hp + 8;
           I64[_udWDC::P64 + 104] = I64[_udWDC::P64 + 104] - ((Hp + 8) - I64[_udWDD::I64]);
           (_udWDA::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] forkOS_entry(_cdWDs::I64);
           (_udWDB::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udWDA::I64);
           BaseReg = _udWDB::I64;
           _udWDE::P64 = CurrentTSO;
           _udWDF::P64 = I64[_udWDE::P64 + 24];
           Sp = I64[_udWDF::P64 + 16];
           SpLim = _udWDF::P64 + 192;
           HpAlloc = 0;
           _udWDG::I64 = CurrentNursery;
           _udWDH::I64 = I64[_udWDG::I64 + 8];
           Hp = _udWDH::I64 - 8;
           _udWDI::I64 = I64[_udWDG::I64];
           HpLim = _udWDI::I64 + ((%MO_SS_Conv_W32_W64(I32[_udWDG::I64 + 48]) << 12) - 1);
           I64[_udWDE::P64 + 104] = I64[_udWDE::P64 + 104] + (_udWDH::I64 - _udWDI::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdWDt() //  []
         { info_tbl: [(cdWDt,
                       label: block_cdWDt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWDt: // global
           R1 = P64[P64[Sp + 8] + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrd_entry() //  [R1]
         { info_tbl: [(cdWDP,
                       label: sat_sdWrd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWDP: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrq_entry() //  [R1]
         { info_tbl: [(cdWDW,
                       label: sat_sdWrq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWDW: // global
           _sdWrq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWDX; else goto cdWDY;
       cdWDY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWE0; else goto cdWDZ;
       cdWE0: // global
           HpAlloc = 24;
           goto cdWDX;
       cdWDX: // global
           R1 = _sdWrq::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWDZ: // global
           _sdWq0::P64 = P64[_sdWrq::P64 + 7];
           _sdWqd::P64 = P64[_sdWrq::P64 + 15];
           I64[Hp - 16] = sat_sdWr4_info;
           P64[Hp - 8] = _sdWq0::P64;
           P64[Hp] = _sdWqd::P64;
           I64[Sp - 16] = block_cdWDa_info;
           R1 = Hp - 15;
           P64[Sp - 8] = _sdWqd::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWDa() //  [R1]
         { info_tbl: [(cdWDa,
                       label: block_cdWDa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWDa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdWE3; else goto cdWE2;
       cdWE3: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdWE2: // global
           I64[Hp - 48] = sat_sdWrj_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdWrc_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdWrd_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cdWDS_info;
           R2 = Hp - 46;
           _sdWr7::I64 = R1;
           R1 = Hp - 7;
           I64[Sp + 8] = _sdWr7::I64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWDS() //  [R1]
         { info_tbl: [(cdWDS,
                       label: block_cdWDS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWDS: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrD_entry() //  [R1]
         { info_tbl: [(cdWEj,
                       label: sat_sdWrD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWEj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWEk; else goto cdWEl;
       cdWEk: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWEl: // global
           I64[Sp - 8] = block_cdWEg_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWEg() //  [R1]
         { info_tbl: [(cdWEg,
                       label: block_cdWEg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWEg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWEo; else goto cdWEn;
       cdWEo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWEn: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrI_entry() //  [R1]
         { info_tbl: [(cdWEu,
                       label: sat_sdWrI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWEu: // global
           _sdWrI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWEv; else goto cdWEw;
       cdWEw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWEy; else goto cdWEx;
       cdWEy: // global
           HpAlloc = 16;
           goto cdWEv;
       cdWEv: // global
           R1 = _sdWrI::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWEx: // global
           _sdWq0::P64 = P64[_sdWrI::P64 + 7];
           _sdWqd::P64 = P64[_sdWrI::P64 + 15];
           I64[Hp - 8] = sat_sdWrD_info;
           P64[Hp] = _sdWq0::P64;
           I64[Sp - 16] = block_cdWEp_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWqd::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWEp() //  [R1]
         { info_tbl: [(cdWEp,
                       label: block_cdWEp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWEp: // global
           _sdWqd::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sdWqd::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sdWqd::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrX_entry() //  [R1, R2]
         { info_tbl: [(cdWEJ,
                       label: sat_sdWrX_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWEJ: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[R1 + 6]);
           R1 = R2;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrQ_entry() //  [R1]
         { info_tbl: [(cdWEW,
                       label: sat_sdWrQ_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWEW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWEX; else goto cdWEY;
       cdWEX: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWEY: // global
           I64[Sp - 16] = block_cdWET_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           _cdWES::I64 = I64[R1 + 15];
           _udWF2::P64 = CurrentTSO;
           I64[I64[_udWF2::P64 + 24] + 16] = Sp;
           _udWF3::I64 = CurrentNursery;
           P64[_udWF3::I64 + 8] = Hp + 8;
           I64[_udWF2::P64 + 104] = I64[_udWF2::P64 + 104] - ((Hp + 8) - I64[_udWF3::I64]);
           (_udWF0::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] forkOS_entry(_cdWES::I64);
           (_udWF1::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udWF0::I64);
           BaseReg = _udWF1::I64;
           _udWF4::P64 = CurrentTSO;
           _udWF5::P64 = I64[_udWF4::P64 + 24];
           Sp = I64[_udWF5::P64 + 16];
           SpLim = _udWF5::P64 + 192;
           HpAlloc = 0;
           _udWF6::I64 = CurrentNursery;
           _udWF7::I64 = I64[_udWF6::I64 + 8];
           Hp = _udWF7::I64 - 8;
           _udWF8::I64 = I64[_udWF6::I64];
           HpLim = _udWF8::I64 + ((%MO_SS_Conv_W32_W64(I32[_udWF6::I64 + 48]) << 12) - 1);
           I64[_udWF4::P64 + 104] = I64[_udWF4::P64 + 104] + (_udWF7::I64 - _udWF8::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdWET() //  []
         { info_tbl: [(cdWET,
                       label: block_cdWET_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWET: // global
           R1 = P64[P64[Sp + 8] + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrR_entry() //  [R1]
         { info_tbl: [(cdWFf,
                       label: sat_sdWrR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWFf: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.runInBoundThread1_entry() //  [R2]
         { info_tbl: [(cdWFl,
                       label: Control.Concurrent.runInBoundThread1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWFl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdWFm; else goto cdWFn;
       cdWFm: // global
           R2 = R2;
           R1 = Control.Concurrent.runInBoundThread1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdWFn: // global
           (_sdWq5::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sdWq5::I64 == 0) goto cdWFk; else goto cdWFj;
       cdWFk: // global
           call Control.Concurrent.forkOS2_entry() args: 8, res: 0, upd: 8;
       cdWFj: // global
           I64[Sp - 16] = block_cdWBd_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_isCurrentThreadBound#() args: 8, res: 8, upd: 8;
     }
 },
 _cdWBd() //  [R1]
         { info_tbl: [(cdWBd,
                       label: block_cdWBd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWBd: // global
           if (R1 == 0) goto cdWFr; else goto cdWFq;
       cdWFr: // global
           I64[Sp] = block_cdWBi_info;
           R1 = Control.Concurrent.runInBoundThread2_closure;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cdWFq: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdWBi() //  [R1]
         { info_tbl: [(cdWBi,
                       label: block_cdWBi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWBi: // global
           I64[Sp - 8] = block_cdWBk_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdWBk() //  [R1]
         { info_tbl: [(cdWBk,
                       label: block_cdWBk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWBk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWFv; else goto cdWFu;
       cdWFv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdWFu: // global
           _sdWq0::P64 = P64[Sp + 16];
           _sdWqd::P64 = P64[Sp + 8];
           if (R1 == 0) goto cdWFV; else goto udWGw;
       cdWFV: // global
           I64[Hp - 16] = sat_sdWrq_info;
           P64[Hp - 8] = _sdWq0::P64;
           P64[Hp] = _sdWqd::P64;
           I64[Sp + 16] = block_cdWFS_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
       udWGw: // global
           if (R1 == 1) goto cdWGd; else goto cdWFC;
       cdWGd: // global
           I64[Hp - 16] = sat_sdWrI_info;
           P64[Hp - 8] = _sdWq0::P64;
           P64[Hp] = _sdWqd::P64;
           I64[Sp] = block_cdWEA_info;
           R1 = Hp - 15;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
       cdWFC: // global
           I64[Hp - 16] = sat_sdWqt_info;
           P64[Hp - 8] = _sdWq0::P64;
           P64[Hp] = _sdWqd::P64;
           I64[Sp] = block_cdWBS_info;
           R1 = Hp - 15;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWFS() //  [R1]
         { info_tbl: [(cdWFS,
                       label: block_cdWFS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWFS: // global
           I64[Sp] = block_cdWFU_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udWGy; else goto cdWFX;
       udWGy: // global
           call _cdWFU(R1) args: 0, res: 0, upd: 0;
       cdWFX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWFU() //  [R1]
         { info_tbl: [(cdWFU,
                       label: block_cdWFU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWFU: // global
           if (R1 & 7 == 1) goto cdWG3; else goto cdWG7;
       cdWG3: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdWG7: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdWEA() //  [R1]
         { info_tbl: [(cdWEA,
                       label: block_cdWEA_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWEA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdWGg; else goto cdWGf;
       cdWGg: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdWGf: // global
           I64[Hp - 48] = sat_sdWrX_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdWrQ_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdWrR_info;
           P64[Hp] = Hp - 31;
           I64[Sp + 8] = block_cdWG8_info;
           R2 = Hp - 46;
           _sdWrL::I64 = R1;
           R1 = Hp - 7;
           I64[Sp + 16] = _sdWrL::I64;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWG8() //  [R1]
         { info_tbl: [(cdWG8,
                       label: block_cdWG8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWG8: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           I64[Sp + 8] = block_cdWGc_info;
           R1 = R1;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udWGz; else goto cdWGi;
       udWGz: // global
           call _cdWGc(R1) args: 0, res: 0, upd: 0;
       cdWGi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWGc() //  [R1]
         { info_tbl: [(cdWGc,
                       label: block_cdWGc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWGc: // global
           if (R1 & 7 == 1) goto cdWGo; else goto cdWGs;
       cdWGo: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdWGs: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdWBS() //  [R1]
         { info_tbl: [(cdWBS,
                       label: block_cdWBS_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWBS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdWFF; else goto cdWFE;
       cdWFF: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdWFE: // global
           I64[Hp - 48] = sat_sdWqI_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdWqB_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdWqC_info;
           P64[Hp] = Hp - 31;
           I64[Sp + 8] = block_cdWFw_info;
           R2 = Hp - 46;
           _sdWqw::I64 = R1;
           R1 = Hp - 7;
           I64[Sp + 16] = _sdWqw::I64;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWFw() //  [R1]
         { info_tbl: [(cdWFw,
                       label: block_cdWFw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWFw: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           I64[Sp + 8] = block_cdWFA_info;
           R1 = R1;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udWGx; else goto cdWFH;
       udWGx: // global
           call _cdWFA(R1) args: 0, res: 0, upd: 0;
       cdWFH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWFA() //  [R1]
         { info_tbl: [(cdWFA,
                       label: block_cdWFA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWFA: // global
           if (R1 & 7 == 1) goto cdWFN; else goto cdWFR;
       cdWFN: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdWFR: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.252905366 UTC

[section ""data" . Control.Concurrent.runInBoundThread_closure" {
     Control.Concurrent.runInBoundThread_closure:
         const Control.Concurrent.runInBoundThread_info;
         const 0;
 },
 Control.Concurrent.runInBoundThread_entry() //  [R2]
         { info_tbl: [(cdWGE,
                       label: Control.Concurrent.runInBoundThread_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWGE: // global
           R2 = R2;
           call Control.Concurrent.runInBoundThread1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.256417653 UTC

[section ""data" . Control.Concurrent.forkFinally1_closure" {
     Control.Concurrent.forkFinally1_closure:
         const Control.Concurrent.forkFinally1_info;
         const 0;
 },
 sat_sdWsl_entry() //  [R1]
         { info_tbl: [(cdWH7,
                       label: sat_sdWsl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWH7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWH8; else goto cdWH9;
       cdWH8: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWH9: // global
           I64[Sp - 8] = block_cdWH4_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWH4() //  [R1]
         { info_tbl: [(cdWH4,
                       label: block_cdWH4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWH4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWHc; else goto cdWHb;
       cdWHc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWHb: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsp_entry() //  [R1]
         { info_tbl: [(cdWHf,
                       label: sat_sdWsp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWHf: // global
           _sdWsp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWHg; else goto cdWHh;
       cdWHh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWHj; else goto cdWHi;
       cdWHj: // global
           HpAlloc = 16;
           goto cdWHg;
       cdWHg: // global
           R1 = _sdWsp::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWHi: // global
           _sdWs7::P64 = P64[_sdWsp::P64 + 7];
           _sdWs8::P64 = P64[_sdWsp::P64 + 15];
           I64[Hp - 8] = sat_sdWsl_info;
           P64[Hp] = _sdWs7::P64;
           I64[Sp - 16] = block_cdWHd_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWs8::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWHd() //  [R1]
         { info_tbl: [(cdWHd,
                       label: block_cdWHd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWHd: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsq_entry() //  [R1]
         { info_tbl: [(cdWHl,
                       label: sat_sdWsq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWHl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWHp; else goto cdWHo;
       cdWHp: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWHo: // global
           _sdWs7::P64 = P64[R1 + 7];
           _sdWs8::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWsp_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsD_entry() //  [R1]
         { info_tbl: [(cdWHO,
                       label: sat_sdWsD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWHO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWHP; else goto cdWHQ;
       cdWHP: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWHQ: // global
           I64[Sp - 8] = block_cdWHL_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWHL() //  [R1]
         { info_tbl: [(cdWHL,
                       label: block_cdWHL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWHL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWHT; else goto cdWHS;
       cdWHT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWHS: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsH_entry() //  [R1]
         { info_tbl: [(cdWHW,
                       label: sat_sdWsH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWHW: // global
           _sdWsH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWHX; else goto cdWHY;
       cdWHY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWI0; else goto cdWHZ;
       cdWI0: // global
           HpAlloc = 16;
           goto cdWHX;
       cdWHX: // global
           R1 = _sdWsH::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWHZ: // global
           _sdWs7::P64 = P64[_sdWsH::P64 + 7];
           _sdWs8::P64 = P64[_sdWsH::P64 + 15];
           I64[Hp - 8] = sat_sdWsD_info;
           P64[Hp] = _sdWs7::P64;
           I64[Sp - 16] = block_cdWHU_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWs8::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWHU() //  [R1]
         { info_tbl: [(cdWHU,
                       label: block_cdWHU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWHU: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsI_entry() //  [R1]
         { info_tbl: [(cdWI2,
                       label: sat_sdWsI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWI2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWI6; else goto cdWI5;
       cdWI6: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWI5: // global
           _sdWs7::P64 = P64[R1 + 7];
           _sdWs8::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWsH_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsN_entry() //  [R1]
         { info_tbl: [(cdWIa,
                       label: sat_sdWsN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWIa: // global
           _sdWsN::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdWIb; else goto cdWIc;
       cdWIc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWIe; else goto cdWId;
       cdWIe: // global
           HpAlloc = 24;
           goto cdWIb;
       cdWIb: // global
           R1 = _sdWsN::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWId: // global
           _sdWs7::P64 = P64[_sdWsN::P64 + 7];
           _sdWs8::P64 = P64[_sdWsN::P64 + 15];
           I64[Hp - 16] = sat_sdWsI_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           I64[Sp - 8] = block_cdWI7_info;
           R1 = Hp - 15;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWI7() //  [R1]
         { info_tbl: [(cdWI7,
                       label: block_cdWI7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWI7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWIh; else goto cdWIg;
       cdWIh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWIg: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsV_entry() //  [R1]
         { info_tbl: [(cdWIB,
                       label: sat_sdWsV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWIB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWIC; else goto cdWID;
       cdWIC: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWID: // global
           I64[Sp - 8] = block_cdWIy_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWIy() //  [R1]
         { info_tbl: [(cdWIy,
                       label: block_cdWIy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWIy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWIG; else goto cdWIF;
       cdWIG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWIF: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsZ_entry() //  [R1]
         { info_tbl: [(cdWIJ,
                       label: sat_sdWsZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWIJ: // global
           _sdWsZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWIK; else goto cdWIL;
       cdWIL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWIN; else goto cdWIM;
       cdWIN: // global
           HpAlloc = 16;
           goto cdWIK;
       cdWIK: // global
           R1 = _sdWsZ::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWIM: // global
           _sdWs7::P64 = P64[_sdWsZ::P64 + 7];
           _sdWs8::P64 = P64[_sdWsZ::P64 + 15];
           I64[Hp - 8] = sat_sdWsV_info;
           P64[Hp] = _sdWs7::P64;
           I64[Sp - 16] = block_cdWIH_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWs8::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWIH() //  [R1]
         { info_tbl: [(cdWIH,
                       label: block_cdWIH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWIH: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWt0_entry() //  [R1]
         { info_tbl: [(cdWIP,
                       label: sat_sdWt0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWIP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWIT; else goto cdWIS;
       cdWIT: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWIS: // global
           _sdWs7::P64 = P64[R1 + 7];
           _sdWs8::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWsZ_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.forkFinally1_entry() //  [R2, R3]
         { info_tbl: [(cdWIY,
                       label: Control.Concurrent.forkFinally1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWIY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdWIZ; else goto cdWJ0;
       cdWIZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.forkFinally1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdWJ0: // global
           I64[Sp - 24] = block_cdWGL_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdWGL() //  [R1]
         { info_tbl: [(cdWGL,
                       label: block_cdWGL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWGL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWJ3; else goto cdWJ2;
       cdWJ3: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdWJ2: // global
           _sdWs7::P64 = P64[Sp + 8];
           _sdWs8::P64 = P64[Sp + 16];
           if (R1 == 0) goto cdWIW; else goto udWJg;
       cdWIW: // global
           I64[Hp - 16] = sat_sdWsN_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       udWJg: // global
           if (R1 == 1) goto cdWIX; else goto cdWIV;
       cdWIX: // global
           I64[Hp - 16] = sat_sdWt0_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           I64[Sp + 16] = block_cdWJa_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
       cdWIV: // global
           I64[Hp - 16] = sat_sdWsq_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           I64[Sp + 16] = block_cdWJ4_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWJa() //  [R1]
         { info_tbl: [(cdWJa,
                       label: block_cdWJa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWJa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWJf; else goto cdWJe;
       cdWJf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWJe: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdWJ4() //  [R1]
         { info_tbl: [(cdWJ4,
                       label: block_cdWJ4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWJ4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWJ9; else goto cdWJ8;
       cdWJ9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWJ8: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.263078928 UTC

[section ""data" . Control.Concurrent.forkFinally_closure" {
     Control.Concurrent.forkFinally_closure:
         const Control.Concurrent.forkFinally_info;
         const 0;
 },
 Control.Concurrent.forkFinally_entry() //  [R2, R3]
         { info_tbl: [(cdWJl,
                       label: Control.Concurrent.forkFinally_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWJl: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.forkFinally1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.263916827 UTC

[section ""cstring" . lvl12_rdWo2_bytes" {
     lvl12_rdWo2_bytes:
         I8[] [67,97,110,110,111,116,32,99,114,101,97,116,101,32,79,83,32,116,104,114,101,97,100,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.264694974 UTC

[section ""data" . Control.Concurrent.forkOS3_closure" {
     Control.Concurrent.forkOS3_closure:
         const Control.Concurrent.forkOS3_info;
         const 0;
 },
 Control.Concurrent.forkOS3_entry() //  []
         { info_tbl: [(cdWJu,
                       label: Control.Concurrent.forkOS3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWJu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWJv; else goto cdWJw;
       cdWJv: // global
           R1 = Control.Concurrent.forkOS3_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWJw: // global
           I64[Sp - 8] = block_cdWJs_info;
           R2 = lvl12_rdWo2_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdWJs() //  [R1]
         { info_tbl: [(cdWJs,
                       label: block_cdWJs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWJs: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.267395115 UTC

[section ""data" . Control.Concurrent.forkOS1_closure" {
     Control.Concurrent.forkOS1_closure:
         const Control.Concurrent.forkOS1_info;
         const 0;
 },
 sat_sdWtr_entry() //  [R1]
         { info_tbl: [(cdWK5,
                       label: sat_sdWtr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWK5: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWts_entry() //  [R1]
         { info_tbl: [(cdWKc,
                       label: sat_sdWts_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWKc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWKg; else goto cdWKf;
       cdWKg: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdWKf: // global
           _sdWt7::P64 = P64[R1 + 16];
           _sdWtq::I64 = I64[R1 + 24];
           if (_sdWtq::I64 != 0) goto udWKh; else goto cdWKa;
       udWKh: // global
           if (_sdWtq::I64 != 1) goto cdWK9; else goto cdWKb;
       cdWK9: // global
           Hp = Hp - 16;
           R1 = _sdWt7::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdWKb: // global
           Hp = Hp - 16;
           R2 = _sdWt7::P64;
           R1 = GHC.IO.uninterruptibleMask_1_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cdWKa: // global
           I64[Hp - 8] = sat_sdWtr_info;
           P64[Hp] = _sdWt7::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWtt_entry() //  [R1]
         { info_tbl: [(cdWKi,
                       label: sat_sdWtt_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWKi: // global
           _sdWtt::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdWKj; else goto cdWKk;
       cdWKk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWKm; else goto cdWKl;
       cdWKm: // global
           HpAlloc = 16;
           goto cdWKj;
       cdWKj: // global
           R1 = _sdWtt::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWKl: // global
           _sdWt7::P64 = P64[_sdWtt::P64 + 7];
           _sdWtg::P64 = P64[_sdWtt::P64 + 15];
           _sdWtj::I64 = I64[_sdWtt::P64 + 23];
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           I64[Hp] = CurrentTSO;
           I64[Sp - 24] = block_cdWJR_info;
           R2 = Hp - 7;
           R1 = _sdWtg::P64;
           P64[Sp - 16] = _sdWt7::P64;
           I64[Sp - 8] = _sdWtj::I64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWJR() //  []
         { info_tbl: [(cdWJR,
                       label: block_cdWJR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWJR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdWKp; else goto cdWKo;
       cdWKp: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdWKo: // global
           I64[Hp - 24] = sat_sdWts_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R2 = GHC.Conc.Sync.childHandler1_closure+2;
           R1 = Hp - 24;
           Sp = Sp + 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.forkOS1_entry() //  [R2]
         { info_tbl: [(cdWKt,
                       label: Control.Concurrent.forkOS1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWKt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdWKu; else goto cdWKv;
       cdWKu: // global
           R2 = R2;
           R1 = Control.Concurrent.forkOS1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdWKv: // global
           (_sdWtc::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sdWtc::I64 == 0) goto cdWKs; else goto cdWKr;
       cdWKs: // global
           call Control.Concurrent.forkOS2_entry() args: 8, res: 0, upd: 8;
       cdWKr: // global
           I64[Sp - 16] = block_cdWJH_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdWJH() //  [R1]
         { info_tbl: [(cdWJH,
                       label: block_cdWJH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWJH: // global
           I64[Sp - 8] = block_cdWJJ_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdWJJ() //  [R1]
         { info_tbl: [(cdWJJ,
                       label: block_cdWJJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWJJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdWKA; else goto cdWKz;
       cdWKA: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdWKz: // global
           I64[Hp - 24] = sat_sdWtt_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = R1;
           I64[Sp] = block_cdWKw_info;
           R1 = Hp - 23;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWKw() //  [R1]
         { info_tbl: [(cdWKw,
                       label: block_cdWKw_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWKw: // global
           I64[Sp] = block_cdWKF_info;
           I64[Sp + 16] = R1;
           _udWL4::P64 = CurrentTSO;
           I64[I64[_udWL4::P64 + 24] + 16] = Sp;
           _udWL5::I64 = CurrentNursery;
           P64[_udWL5::I64 + 8] = Hp + 8;
           I64[_udWL4::P64 + 104] = I64[_udWL4::P64 + 104] - ((Hp + 8) - I64[_udWL5::I64]);
           (_udWL2::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sdWtA::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [‘signed’] forkOS_createThread(R1);
           (_udWL3::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udWL2::I64);
           BaseReg = _udWL3::I64;
           _udWL6::P64 = CurrentTSO;
           _udWL7::P64 = I64[_udWL6::P64 + 24];
           Sp = I64[_udWL7::P64 + 16];
           SpLim = _udWL7::P64 + 192;
           HpAlloc = 0;
           _udWL8::I64 = CurrentNursery;
           _udWL9::I64 = I64[_udWL8::I64 + 8];
           Hp = _udWL9::I64 - 8;
           _udWLa::I64 = I64[_udWL8::I64];
           HpLim = _udWLa::I64 + ((%MO_SS_Conv_W32_W64(I32[_udWL8::I64 + 48]) << 12) - 1);
           I64[_udWL6::P64 + 104] = I64[_udWL6::P64 + 104] + (_udWL9::I64 - _udWLa::I64);
           R1 = _sdWtA::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWKF() //  [R1]
         { info_tbl: [(cdWKF,
                       label: block_cdWKF_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWKF: // global
           if (%MO_SS_Conv_W64_W32(R1) == 0 :: W32) goto cdWKW; else goto cdWKN;
       cdWKW: // global
           _sdWtg::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdWKV_info;
           R1 = _sdWtg::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdWKN: // global
           Sp = Sp + 24;
           call Control.Concurrent.forkOS3_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cdWKV() //  [R1]
         { info_tbl: [(cdWKV,
                       label: block_cdWKV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWKV: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.27112658 UTC

[section ""data" . Control.Concurrent.forkOS_closure" {
     Control.Concurrent.forkOS_closure:
         const Control.Concurrent.forkOS_info;
         const 0;
 },
 Control.Concurrent.forkOS_entry() //  [R2]
         { info_tbl: [(cdWLg,
                       label: Control.Concurrent.forkOS_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWLg: // global
           R2 = R2;
           call Control.Concurrent.forkOS1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.272315727 UTC

[section ""data" . Control.Concurrent.forkOSWithUnmask1_closure" {
     Control.Concurrent.forkOSWithUnmask1_closure:
         const Control.Concurrent.forkOSWithUnmask1_info;
         const 0;
 },
 sat_sdWtL_entry() //  [R2]
         { info_tbl: [(cdWLw,
                       label: sat_sdWtL_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWLw: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWtM_entry() //  [R1]
         { info_tbl: [(cdWLz,
                       label: sat_sdWtM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWLz: // global
           _sdWtM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWLA; else goto cdWLB;
       cdWLB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWLD; else goto cdWLC;
       cdWLD: // global
           HpAlloc = 16;
           goto cdWLA;
       cdWLA: // global
           R1 = _sdWtM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdWLC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdWtM::P64;
           _sdWtJ::P64 = P64[_sdWtM::P64 + 16];
           I64[Hp - 8] = sat_sdWtL_info;
           R2 = Hp - 6;
           R1 = _sdWtJ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Concurrent.forkOSWithUnmask1_entry() //  [R2]
         { info_tbl: [(cdWLE,
                       label: Control.Concurrent.forkOSWithUnmask1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWLE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWLI; else goto cdWLH;
       cdWLI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Concurrent.forkOSWithUnmask1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdWLH: // global
           I64[Hp - 16] = sat_sdWtM_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Concurrent.forkOS1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.273844717 UTC

[section ""data" . Control.Concurrent.forkOSWithUnmask_closure" {
     Control.Concurrent.forkOSWithUnmask_closure:
         const Control.Concurrent.forkOSWithUnmask_info;
         const 0;
 },
 Control.Concurrent.forkOSWithUnmask_entry() //  [R2]
         { info_tbl: [(cdWLN,
                       label: Control.Concurrent.forkOSWithUnmask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWLN: // global
           R2 = R2;
           call Control.Concurrent.forkOSWithUnmask1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.274970107 UTC

[section ""data" . Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_closure" {
     Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_closure:
         const Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_info;
 },
 Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_entry() //  [R2]
         { info_tbl: [(cdWLX,
                       label: Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWLX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWM1; else goto cdWM2;
       cdWM1: // global
           R2 = R2;
           R1 = Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdWM2: // global
           I64[Sp - 8] = block_cdWLU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udWM6; else goto cdWLV;
       udWM6: // global
           call _cdWLU(R1) args: 0, res: 0, upd: 0;
       cdWLV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWLU() //  [R1]
         { info_tbl: [(cdWLU,
                       label: block_cdWLU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWLU: // global
           I64[Sp] = block_cdWM0_info;
           R1 = I64[R1 + 7];
           call stg_deRefStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWM0() //  [R1]
         { info_tbl: [(cdWM0,
                       label: block_cdWM0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWM0: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.276373091 UTC

[section ""data" . Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_closure" {
     Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_closure:
         const Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_info;
 },
 Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_entry() //  [R2]
         { info_tbl: [(cdWMb,
                       label: Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWMb: // global
           R2 = R2;
           call Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.277282064 UTC

[section ""relreadonly" . SdWuv_srt" {
     SdWuv_srt:
         const GHC.Conc.IO.threadWaitRead1_closure;
         const GHC.Conc.IO.threadWaitWrite1_closure;
         const GHC.Conc.IO.threadWaitReadSTM1_closure;
         const GHC.Conc.IO.threadWaitWriteSTM1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const Control.Concurrent.runInUnboundThread1_closure;
         const GHC.IO.failIO1_closure;
         const Control.Concurrent.forkOS2_closure;
         const GHC.Err.undefined_closure;
         const lvl11_rdWo1_closure;
         const Control.Concurrent.runInBoundThread1_closure;
         const Control.Concurrent.runInBoundThread2_closure;
         const Control.Concurrent.forkFinally1_closure;
         const Control.Concurrent.forkOS3_closure;
         const GHC.Conc.Sync.childHandler1_closure;
         const Control.Concurrent.forkOS1_closure;
         const Control.Concurrent.forkOSWithUnmask1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.278080903 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:12.279131965 UTC

[section ""data" . Control.Concurrent.isCurrentThreadBound1_closure" {
     Control.Concurrent.isCurrentThreadBound1_closure:
         const Control.Concurrent.isCurrentThreadBound1_info;
 },
 sat_sdWo9_entry() //  [R1]
         { info_tbl: [(cdWMs,
                       label: sat_sdWo9_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWMs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWMt; else goto cdWMu;
       cdWMt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdWMu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto cdWMr; else goto cdWMq;
       cdWMr: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdWMq: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Concurrent.isCurrentThreadBound1_entry() //  []
         { info_tbl: [(cdWMv,
                       label: Control.Concurrent.isCurrentThreadBound1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWMv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWMw; else goto cdWMx;
       cdWMw: // global
           R1 = Control.Concurrent.isCurrentThreadBound1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWMx: // global
           I64[Sp - 8] = block_cdWMi_info;
           Sp = Sp - 8;
           call stg_isCurrentThreadBound#() args: 8, res: 8, upd: 8;
     }
 },
 _cdWMi() //  [R1]
         { info_tbl: [(cdWMi,
                       label: block_cdWMi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWMi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWMA; else goto cdWMz;
       cdWMA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdWMz: // global
           I64[Hp - 16] = sat_sdWo9_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.28073415 UTC

[section ""data" . Control.Concurrent.isCurrentThreadBound_closure" {
     Control.Concurrent.isCurrentThreadBound_closure:
         const Control.Concurrent.isCurrentThreadBound_info;
 },
 Control.Concurrent.isCurrentThreadBound_entry() //  []
         { info_tbl: [(cdWMF,
                       label: Control.Concurrent.isCurrentThreadBound_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWMF: // global
           call Control.Concurrent.isCurrentThreadBound1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.281688324 UTC

[section ""data" . Control.Concurrent.threadWaitRead_closure" {
     Control.Concurrent.threadWaitRead_closure:
         const Control.Concurrent.threadWaitRead_info;
         const 0;
 },
 Control.Concurrent.threadWaitRead_entry() //  [R2]
         { info_tbl: [(cdWMM,
                       label: Control.Concurrent.threadWaitRead_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWMM: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitRead1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.284775633 UTC

[section ""data" . Control.Concurrent.threadWaitWrite_closure" {
     Control.Concurrent.threadWaitWrite_closure:
         const Control.Concurrent.threadWaitWrite_info;
         const 0;
 },
 Control.Concurrent.threadWaitWrite_entry() //  [R2]
         { info_tbl: [(cdWMT,
                       label: Control.Concurrent.threadWaitWrite_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWMT: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWrite1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.285876677 UTC

[section ""data" . Control.Concurrent.threadWaitReadSTM_closure" {
     Control.Concurrent.threadWaitReadSTM_closure:
         const Control.Concurrent.threadWaitReadSTM_info;
         const 0;
 },
 Control.Concurrent.threadWaitReadSTM_entry() //  [R2]
         { info_tbl: [(cdWN0,
                       label: Control.Concurrent.threadWaitReadSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWN0: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitReadSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.286681862 UTC

[section ""data" . Control.Concurrent.threadWaitWriteSTM_closure" {
     Control.Concurrent.threadWaitWriteSTM_closure:
         const Control.Concurrent.threadWaitWriteSTM_info;
         const 0;
 },
 Control.Concurrent.threadWaitWriteSTM_entry() //  [R2]
         { info_tbl: [(cdWN7,
                       label: Control.Concurrent.threadWaitWriteSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWN7: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWriteSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.287397544 UTC

[section ""cstring" . Control.Concurrent.$trModule4_bytes" {
     Control.Concurrent.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.287960782 UTC

[section ""data" . Control.Concurrent.$trModule3_closure" {
     Control.Concurrent.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.288566927 UTC

[section ""cstring" . Control.Concurrent.$trModule2_bytes" {
     Control.Concurrent.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.289146308 UTC

[section ""data" . Control.Concurrent.$trModule1_closure" {
     Control.Concurrent.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.289757006 UTC

[section ""data" . Control.Concurrent.$trModule_closure" {
     Control.Concurrent.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.$trModule3_closure+1;
         const Control.Concurrent.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.290721132 UTC

[section ""data" . Control.Concurrent.rtsSupportsBoundThreads_closure" {
     Control.Concurrent.rtsSupportsBoundThreads_closure:
         const Control.Concurrent.rtsSupportsBoundThreads_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Concurrent.rtsSupportsBoundThreads_entry() //  [R1]
         { info_tbl: [(cdWNl,
                       label: Control.Concurrent.rtsSupportsBoundThreads_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWNl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWNm; else goto cdWNn;
       cdWNm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdWNn: // global
           (_cdWNd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdWNd::I64 == 0) goto cdWNf; else goto cdWNe;
       cdWNf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdWNe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdWNd::I64;
           (_sdWod::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sdWod::I64 == 0) goto cdWNk; else goto cdWNj;
       cdWNk: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdWNj: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.291949585 UTC

[section ""data" . Control.Concurrent.forkFinally2_closure" {
     Control.Concurrent.forkFinally2_closure:
         const Control.Concurrent.forkFinally2_info;
 },
 Control.Concurrent.forkFinally2_entry() //  [R2]
         { info_tbl: [(cdWNt,
                       label: Control.Concurrent.forkFinally2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWNt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWNx; else goto cdWNw;
       cdWNx: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Control.Concurrent.forkFinally2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdWNw: // global
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.297364138 UTC

[section ""data" . Control.Concurrent.runInUnboundThread1_closure" {
     Control.Concurrent.runInUnboundThread1_closure:
         const Control.Concurrent.runInUnboundThread1_info;
         const 0;
 },
 lvl13_sdWou_entry() //  [R1]
         { info_tbl: [(cdWNP,
                       label: lvl13_sdWou_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWNP: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWoE_entry() //  [R1]
         { info_tbl: [(cdWOc,
                       label: sat_sdWoE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWOc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWOd; else goto cdWOe;
       cdWOd: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWOe: // global
           I64[Sp - 8] = block_cdWO9_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWO9() //  [R1]
         { info_tbl: [(cdWO9,
                       label: block_cdWO9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWO9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWOh; else goto cdWOg;
       cdWOh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWOg: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWoJ_entry() //  [R1]
         { info_tbl: [(cdWOm,
                       label: sat_sdWoJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWOm: // global
           _sdWoJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWOn; else goto cdWOo;
       cdWOo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWOq; else goto cdWOp;
       cdWOq: // global
           HpAlloc = 16;
           goto cdWOn;
       cdWOn: // global
           R1 = _sdWoJ::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWOp: // global
           _sdWoi::P64 = P64[_sdWoJ::P64 + 7];
           _sdWoq::P64 = P64[_sdWoJ::P64 + 15];
           I64[Hp - 8] = sat_sdWoE_info;
           P64[Hp] = _sdWoi::P64;
           I64[Sp - 16] = block_cdWOi_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWoq::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWOi() //  [R1]
         { info_tbl: [(cdWOi,
                       label: block_cdWOi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWOi: // global
           _sdWoq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdWOk_info;
           R2 = R1;
           R1 = _sdWoq::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWOk() //  []
         { info_tbl: [(cdWOk,
                       label: block_cdWOk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWOk: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWoK_entry() //  [R1]
         { info_tbl: [(cdWOt,
                       label: sat_sdWoK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWOt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWOx; else goto cdWOw;
       cdWOx: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWOw: // global
           _sdWoi::P64 = P64[R1 + 7];
           _sdWoq::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWoJ_info;
           P64[Hp - 8] = _sdWoi::P64;
           P64[Hp] = _sdWoq::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWoT_entry() //  [R1, R2]
         { info_tbl: [(cdWOM,
                       label: sat_sdWoT_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWOM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWON; else goto cdWOO;
       cdWON: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdWOO: // global
           I64[Sp - 16] = block_cdWOK_info;
           R2 = R2;
           _sdWoO::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdWoO::P64;
           Sp = Sp - 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWOK() //  []
         { info_tbl: [(cdWOK,
                       label: block_cdWOK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWOK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call wait_sdWoO_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 wait_sdWoO_entry() //  [R1]
         { info_tbl: [(cdWOQ,
                       label: wait_sdWoO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWOQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWOU; else goto cdWOT;
       cdWOU: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWOT: // global
           _sdWou::P64 = P64[R1 + 7];
           _sdWoN::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWoT_info;
           P64[Hp - 8] = _sdWoN::P64;
           P64[Hp] = R1;
           R2 = Hp - 14;
           R1 = _sdWou::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWp8_entry() //  [R1]
         { info_tbl: [(cdWPj,
                       label: sat_sdWp8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWPj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWPk; else goto cdWPl;
       cdWPk: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWPl: // global
           I64[Sp - 8] = block_cdWPg_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWPg() //  [R1]
         { info_tbl: [(cdWPg,
                       label: block_cdWPg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWPg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWPo; else goto cdWPn;
       cdWPo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWPn: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpd_entry() //  [R1]
         { info_tbl: [(cdWPt,
                       label: sat_sdWpd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWPt: // global
           _sdWpd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWPu; else goto cdWPv;
       cdWPv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWPx; else goto cdWPw;
       cdWPx: // global
           HpAlloc = 16;
           goto cdWPu;
       cdWPu: // global
           R1 = _sdWpd::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWPw: // global
           _sdWoi::P64 = P64[_sdWpd::P64 + 7];
           _sdWoq::P64 = P64[_sdWpd::P64 + 15];
           I64[Hp - 8] = sat_sdWp8_info;
           P64[Hp] = _sdWoi::P64;
           I64[Sp - 16] = block_cdWPp_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWoq::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWPp() //  [R1]
         { info_tbl: [(cdWPp,
                       label: block_cdWPp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWPp: // global
           _sdWoq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdWPr_info;
           R2 = R1;
           R1 = _sdWoq::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWPr() //  []
         { info_tbl: [(cdWPr,
                       label: block_cdWPr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWPr: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpe_entry() //  [R1]
         { info_tbl: [(cdWPA,
                       label: sat_sdWpe_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWPA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWPE; else goto cdWPD;
       cdWPE: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWPD: // global
           _sdWoi::P64 = P64[R1 + 7];
           _sdWoq::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWpd_info;
           P64[Hp - 8] = _sdWoi::P64;
           P64[Hp] = _sdWoq::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpn_entry() //  [R1, R2]
         { info_tbl: [(cdWPT,
                       label: sat_sdWpn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWPT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWPU; else goto cdWPV;
       cdWPU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdWPV: // global
           I64[Sp - 16] = block_cdWPR_info;
           R2 = R2;
           _sdWpi::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdWpi::P64;
           Sp = Sp - 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWPR() //  []
         { info_tbl: [(cdWPR,
                       label: block_cdWPR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWPR: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call wait_sdWpi_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 wait_sdWpi_entry() //  [R1]
         { info_tbl: [(cdWPX,
                       label: wait_sdWpi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWPX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWQ1; else goto cdWQ0;
       cdWQ1: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWQ0: // global
           _sdWou::P64 = P64[R1 + 7];
           _sdWph::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWpn_info;
           P64[Hp - 8] = _sdWph::P64;
           P64[Hp] = R1;
           R2 = Hp - 14;
           R1 = _sdWou::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpu_entry() //  [R1]
         { info_tbl: [(cdWQb,
                       label: sat_sdWpu_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWQb: // global
           _sdWpu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWQc; else goto cdWQd;
       cdWQd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWQf; else goto cdWQe;
       cdWQf: // global
           HpAlloc = 24;
           goto cdWQc;
       cdWQc: // global
           R1 = _sdWpu::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWQe: // global
           _sdWoi::P64 = P64[_sdWpu::P64 + 7];
           _sdWoq::P64 = P64[_sdWpu::P64 + 15];
           _sdWou::P64 = P64[_sdWpu::P64 + 23];
           I64[Hp - 16] = sat_sdWpe_info;
           P64[Hp - 8] = _sdWoi::P64;
           P64[Hp] = _sdWoq::P64;
           I64[Sp - 16] = block_cdWPF_info;
           R1 = Hp - 15;
           P64[Sp - 8] = _sdWou::P64;
           Sp = Sp - 16;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWPF() //  [R1]
         { info_tbl: [(cdWPF,
                       label: block_cdWPF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWPF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWQi; else goto cdWQh;
       cdWQi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWQh: // global
           I64[Hp - 16] = wait_sdWpi_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cdWQ2_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call wait_sdWpi_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWQ2() //  [R1]
         { info_tbl: [(cdWQ2,
                       label: block_cdWQ2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWQ2: // global
           I64[Sp] = block_cdWQ4_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udWQq; else goto cdWQ5;
       udWQq: // global
           call _cdWQ4(R1) args: 0, res: 0, upd: 0;
       cdWQ5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWQ4() //  [R1]
         { info_tbl: [(cdWQ4,
                       label: block_cdWQ4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWQ4: // global
           if (R1 & 7 == 1) goto cdWQ8; else goto cdWQ9;
       cdWQ8: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdWQ9: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpC_entry() //  [R1]
         { info_tbl: [(cdWQK,
                       label: sat_sdWpC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWQK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWQL; else goto cdWQM;
       cdWQL: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWQM: // global
           I64[Sp - 8] = block_cdWQH_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWQH() //  [R1]
         { info_tbl: [(cdWQH,
                       label: block_cdWQH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWQH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWQP; else goto cdWQO;
       cdWQP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWQO: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpH_entry() //  [R1]
         { info_tbl: [(cdWQU,
                       label: sat_sdWpH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWQU: // global
           _sdWpH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWQV; else goto cdWQW;
       cdWQW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWQY; else goto cdWQX;
       cdWQY: // global
           HpAlloc = 16;
           goto cdWQV;
       cdWQV: // global
           R1 = _sdWpH::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWQX: // global
           _sdWoi::P64 = P64[_sdWpH::P64 + 7];
           _sdWoq::P64 = P64[_sdWpH::P64 + 15];
           I64[Hp - 8] = sat_sdWpC_info;
           P64[Hp] = _sdWoi::P64;
           I64[Sp - 16] = block_cdWQQ_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWoq::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWQQ() //  [R1]
         { info_tbl: [(cdWQQ,
                       label: block_cdWQQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWQQ: // global
           _sdWoq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdWQS_info;
           R2 = R1;
           R1 = _sdWoq::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWQS() //  []
         { info_tbl: [(cdWQS,
                       label: block_cdWQS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWQS: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpI_entry() //  [R1]
         { info_tbl: [(cdWR1,
                       label: sat_sdWpI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWR1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWR5; else goto cdWR4;
       cdWR5: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWR4: // global
           _sdWoi::P64 = P64[R1 + 7];
           _sdWoq::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWpH_info;
           P64[Hp - 8] = _sdWoi::P64;
           P64[Hp] = _sdWoq::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpR_entry() //  [R1, R2]
         { info_tbl: [(cdWRk,
                       label: sat_sdWpR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWRk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWRl; else goto cdWRm;
       cdWRl: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdWRm: // global
           I64[Sp - 16] = block_cdWRi_info;
           R2 = R2;
           _sdWpM::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdWpM::P64;
           Sp = Sp - 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWRi() //  []
         { info_tbl: [(cdWRi,
                       label: block_cdWRi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWRi: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call wait_sdWpM_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 wait_sdWpM_entry() //  [R1]
         { info_tbl: [(cdWRo,
                       label: wait_sdWpM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWRo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWRs; else goto cdWRr;
       cdWRs: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWRr: // global
           _sdWou::P64 = P64[R1 + 7];
           _sdWpL::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWpR_info;
           P64[Hp - 8] = _sdWpL::P64;
           P64[Hp] = R1;
           R2 = Hp - 14;
           R1 = _sdWou::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.runInUnboundThread1_entry() //  [R2]
         { info_tbl: [(cdWRw,
                       label: Control.Concurrent.runInUnboundThread1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWRw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdWRx; else goto cdWRy;
       cdWRx: // global
           R2 = R2;
           R1 = Control.Concurrent.runInUnboundThread1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdWRy: // global
           I64[Sp - 16] = block_cdWNC_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_isCurrentThreadBound#() args: 8, res: 8, upd: 8;
     }
 },
 _cdWNC() //  [R1]
         { info_tbl: [(cdWNC,
                       label: block_cdWNC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWNC: // global
           if (R1 == 0) goto cdWRv; else goto cdWRu;
       cdWRv: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       cdWRu: // global
           I64[Sp] = block_cdWNG_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdWNG() //  [R1]
         { info_tbl: [(cdWNG,
                       label: block_cdWNG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWNG: // global
           I64[Sp - 8] = block_cdWNI_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdWNI() //  [R1]
         { info_tbl: [(cdWNI,
                       label: block_cdWNI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWNI: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdWRD; else goto cdWRC;
       cdWRD: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdWRC: // global
           I64[Hp - 40] = lvl13_sdWou_info;
           _sdWoq::P64 = P64[Sp + 8];
           P64[Hp - 32] = _sdWoq::P64;
           _sdWoi::P64 = P64[Sp + 16];
           _cdWNK::P64 = Hp - 39;
           if (R1 == 0) goto cdWRY; else goto udWSk;
       cdWRY: // global
           I64[Hp - 24] = sat_sdWpu_info;
           P64[Hp - 16] = _sdWoi::P64;
           P64[Hp - 8] = _sdWoq::P64;
           P64[Hp] = _cdWNK::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       udWSk: // global
           if (R1 == 1) goto cdWS2; else goto cdWRI;
       cdWS2: // global
           I64[Hp - 24] = sat_sdWpI_info;
           P64[Hp - 16] = _sdWoi::P64;
           P64[Hp - 8] = _sdWoq::P64;
           _cdWQs::P64 = Hp - 23;
           Hp = Hp - 8;
           I64[Sp + 8] = block_cdWR6_info;
           R1 = _cdWQs::P64;
           P64[Sp + 16] = _cdWNK::P64;
           Sp = Sp + 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
       cdWRI: // global
           I64[Hp - 24] = sat_sdWoK_info;
           P64[Hp - 16] = _sdWoi::P64;
           P64[Hp - 8] = _sdWoq::P64;
           _cdWNU::P64 = Hp - 23;
           Hp = Hp - 8;
           I64[Sp + 8] = block_cdWOy_info;
           R1 = _cdWNU::P64;
           P64[Sp + 16] = _cdWNK::P64;
           Sp = Sp + 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWR6() //  [R1]
         { info_tbl: [(cdWR6,
                       label: block_cdWR6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWR6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWS5; else goto cdWS4;
       cdWS5: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWS4: // global
           I64[Hp - 16] = wait_sdWpM_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cdWRZ_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call wait_sdWpM_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWRZ() //  [R1]
         { info_tbl: [(cdWRZ,
                       label: block_cdWRZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWRZ: // global
           I64[Sp] = block_cdWS1_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udWSm; else goto cdWS7;
       udWSm: // global
           call _cdWS1(R1) args: 0, res: 0, upd: 0;
       cdWS7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWS1() //  [R1]
         { info_tbl: [(cdWS1,
                       label: block_cdWS1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWS1: // global
           if (R1 & 7 == 1) goto cdWSd; else goto cdWSh;
       cdWSd: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdWSh: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdWOy() //  [R1]
         { info_tbl: [(cdWOy,
                       label: block_cdWOy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWOy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWRL; else goto cdWRK;
       cdWRL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWRK: // global
           I64[Hp - 16] = wait_sdWoO_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cdWRE_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call wait_sdWoO_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWRE() //  [R1]
         { info_tbl: [(cdWRE,
                       label: block_cdWRE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWRE: // global
           I64[Sp] = block_cdWRG_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udWSl; else goto cdWRN;
       udWSl: // global
           call _cdWRG(R1) args: 0, res: 0, upd: 0;
       cdWRN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWRG() //  [R1]
         { info_tbl: [(cdWRG,
                       label: block_cdWRG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWRG: // global
           if (R1 & 7 == 1) goto cdWRT; else goto cdWRX;
       cdWRT: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdWRX: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.30811528 UTC

[section ""data" . Control.Concurrent.runInUnboundThread_closure" {
     Control.Concurrent.runInUnboundThread_closure:
         const Control.Concurrent.runInUnboundThread_info;
         const 0;
 },
 Control.Concurrent.runInUnboundThread_entry() //  [R2]
         { info_tbl: [(cdWSr,
                       label: Control.Concurrent.runInUnboundThread_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWSr: // global
           R2 = R2;
           call Control.Concurrent.runInUnboundThread1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.308913857 UTC

[section ""cstring" . lvl_rdWnQ_bytes" {
     lvl_rdWnQ_bytes:
         I8[] [82,84,83,32,100,111,101,115,110,39,116,32,115,117,112,112,111,114,116,32,109,117,108,116,105,112,108,101,32,79,83,32,116,104,114,101,97,100,115,32,40,117,115,101,32,103,104,99,32,45,116,104,114,101,97,100,101,100,32,119,104,101,110,32,108,105,110,107,105,110,103,41]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.310042415 UTC

[section ""data" . Control.Concurrent.forkOS2_closure" {
     Control.Concurrent.forkOS2_closure:
         const Control.Concurrent.forkOS2_info;
         const 0;
 },
 Control.Concurrent.forkOS2_entry() //  []
         { info_tbl: [(cdWSA,
                       label: Control.Concurrent.forkOS2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWSA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWSB; else goto cdWSC;
       cdWSB: // global
           R1 = Control.Concurrent.forkOS2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWSC: // global
           I64[Sp - 8] = block_cdWSy_info;
           R2 = lvl_rdWnQ_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdWSy() //  [R1]
         { info_tbl: [(cdWSy,
                       label: block_cdWSy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWSy: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.310987036 UTC

[section ""cstring" . lvl1_rdWnR_bytes" {
     lvl1_rdWnR_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.311767407 UTC

[section ""data" . lvl2_rdWnS_closure" {
     lvl2_rdWnS_closure:
         const lvl2_rdWnS_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rdWnS_entry() //  [R1]
         { info_tbl: [(cdWSM,
                       label: lvl2_rdWnS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWSM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWSN; else goto cdWSO;
       cdWSN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdWSO: // global
           (_cdWSJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdWSJ::I64 == 0) goto cdWSL; else goto cdWSK;
       cdWSL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdWSK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdWSJ::I64;
           R2 = lvl1_rdWnR_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.312864879 UTC

[section ""data" . lvl3_rdWnT_closure" {
     lvl3_rdWnT_closure:
         const lvl3_rdWnT_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rdWnT_entry() //  [R1]
         { info_tbl: [(cdWSV,
                       label: lvl3_rdWnT_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWSV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWSW; else goto cdWSX;
       cdWSW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdWSX: // global
           (_cdWSS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdWSS::I64 == 0) goto cdWSU; else goto cdWST;
       cdWSU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdWST: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdWSS::I64;
           R2 = Control.Concurrent.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.313966558 UTC

[section ""data" . lvl4_rdWnU_closure" {
     lvl4_rdWnU_closure:
         const lvl4_rdWnU_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rdWnU_entry() //  [R1]
         { info_tbl: [(cdWT4,
                       label: lvl4_rdWnU_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWT4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWT5; else goto cdWT6;
       cdWT5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdWT6: // global
           (_cdWT1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdWT1::I64 == 0) goto cdWT3; else goto cdWT2;
       cdWT3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdWT2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdWT1::I64;
           R2 = Control.Concurrent.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.314911053 UTC

[section ""cstring" . lvl5_rdWnV_bytes" {
     lvl5_rdWnV_bytes:
         I8[] [46,47,67,111,110,116,114,111,108,47,67,111,110,99,117,114,114,101,110,116,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.315711291 UTC

[section ""data" . lvl6_rdWnW_closure" {
     lvl6_rdWnW_closure:
         const lvl6_rdWnW_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rdWnW_entry() //  [R1]
         { info_tbl: [(cdWTd,
                       label: lvl6_rdWnW_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWTd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWTe; else goto cdWTf;
       cdWTe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdWTf: // global
           (_cdWTa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdWTa::I64 == 0) goto cdWTc; else goto cdWTb;
       cdWTc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdWTb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdWTa::I64;
           R2 = lvl5_rdWnV_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.316623647 UTC

[section ""data" . lvl7_rdWnX_closure" {
     lvl7_rdWnX_closure:
         const GHC.Types.I#_con_info;
         const 353;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.317300142 UTC

[section ""data" . lvl8_rdWnY_closure" {
     lvl8_rdWnY_closure:
         const GHC.Types.I#_con_info;
         const 33;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.317925032 UTC

[section ""data" . lvl9_rdWnZ_closure" {
     lvl9_rdWnZ_closure:
         const GHC.Types.I#_con_info;
         const 42;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.318495646 UTC

[section ""data" . lvl10_rdWo0_closure" {
     lvl10_rdWo0_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_rdWnT_closure;
         const lvl4_rdWnU_closure;
         const lvl6_rdWnW_closure;
         const lvl7_rdWnX_closure+1;
         const lvl8_rdWnY_closure+1;
         const lvl7_rdWnX_closure+1;
         const lvl9_rdWnZ_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.31914876 UTC

[section ""data" . lvl11_rdWo1_closure" {
     lvl11_rdWo1_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_rdWnS_closure;
         const lvl10_rdWo0_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.319986546 UTC

[section ""data" . Control.Concurrent.runInBoundThread2_closure" {
     Control.Concurrent.runInBoundThread2_closure:
         const Control.Concurrent.runInBoundThread2_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Concurrent.runInBoundThread2_entry() //  [R1]
         { info_tbl: [(cdWTm,
                       label: Control.Concurrent.runInBoundThread2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWTm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWTn; else goto cdWTo;
       cdWTn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdWTo: // global
           (_cdWTj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdWTj::I64 == 0) goto cdWTl; else goto cdWTk;
       cdWTl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdWTk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdWTj::I64;
           R2 = lvl11_rdWo1_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.325827491 UTC

[section ""data" . Control.Concurrent.runInBoundThread1_closure" {
     Control.Concurrent.runInBoundThread1_closure:
         const Control.Concurrent.runInBoundThread1_info;
         const 0;
 },
 sat_sdWqo_entry() //  [R1]
         { info_tbl: [(cdWTU,
                       label: sat_sdWqo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWTU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWTV; else goto cdWTW;
       cdWTV: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWTW: // global
           I64[Sp - 8] = block_cdWTR_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWTR() //  [R1]
         { info_tbl: [(cdWTR,
                       label: block_cdWTR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWTR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWTZ; else goto cdWTY;
       cdWTZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWTY: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWqt_entry() //  [R1]
         { info_tbl: [(cdWU5,
                       label: sat_sdWqt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWU5: // global
           _sdWqt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWU6; else goto cdWU7;
       cdWU7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWU9; else goto cdWU8;
       cdWU9: // global
           HpAlloc = 16;
           goto cdWU6;
       cdWU6: // global
           R1 = _sdWqt::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWU8: // global
           _sdWq0::P64 = P64[_sdWqt::P64 + 7];
           _sdWqd::P64 = P64[_sdWqt::P64 + 15];
           I64[Hp - 8] = sat_sdWqo_info;
           P64[Hp] = _sdWq0::P64;
           I64[Sp - 16] = block_cdWU0_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWqd::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWU0() //  [R1]
         { info_tbl: [(cdWU0,
                       label: block_cdWU0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWU0: // global
           _sdWqd::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sdWqd::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sdWqd::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWqI_entry() //  [R1, R2]
         { info_tbl: [(cdWUk,
                       label: sat_sdWqI_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWUk: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[R1 + 6]);
           R1 = R2;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWqB_entry() //  [R1]
         { info_tbl: [(cdWUx,
                       label: sat_sdWqB_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWUx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWUy; else goto cdWUz;
       cdWUy: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWUz: // global
           I64[Sp - 16] = block_cdWUu_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           _cdWUt::I64 = I64[R1 + 15];
           _udWUD::P64 = CurrentTSO;
           I64[I64[_udWUD::P64 + 24] + 16] = Sp;
           _udWUE::I64 = CurrentNursery;
           P64[_udWUE::I64 + 8] = Hp + 8;
           I64[_udWUD::P64 + 104] = I64[_udWUD::P64 + 104] - ((Hp + 8) - I64[_udWUE::I64]);
           (_udWUB::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] forkOS_entry(_cdWUt::I64);
           (_udWUC::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udWUB::I64);
           BaseReg = _udWUC::I64;
           _udWUF::P64 = CurrentTSO;
           _udWUG::P64 = I64[_udWUF::P64 + 24];
           Sp = I64[_udWUG::P64 + 16];
           SpLim = _udWUG::P64 + 192;
           HpAlloc = 0;
           _udWUH::I64 = CurrentNursery;
           _udWUI::I64 = I64[_udWUH::I64 + 8];
           Hp = _udWUI::I64 - 8;
           _udWUJ::I64 = I64[_udWUH::I64];
           HpLim = _udWUJ::I64 + ((%MO_SS_Conv_W32_W64(I32[_udWUH::I64 + 48]) << 12) - 1);
           I64[_udWUF::P64 + 104] = I64[_udWUF::P64 + 104] + (_udWUI::I64 - _udWUJ::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdWUu() //  []
         { info_tbl: [(cdWUu,
                       label: block_cdWUu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWUu: // global
           R1 = P64[P64[Sp + 8] + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWqC_entry() //  [R1]
         { info_tbl: [(cdWUQ,
                       label: sat_sdWqC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWUQ: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWqZ_entry() //  [R1]
         { info_tbl: [(cdWVc,
                       label: sat_sdWqZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWVc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWVd; else goto cdWVe;
       cdWVd: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWVe: // global
           I64[Sp - 8] = block_cdWV9_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWV9() //  [R1]
         { info_tbl: [(cdWV9,
                       label: block_cdWV9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWV9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWVh; else goto cdWVg;
       cdWVh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWVg: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWr4_entry() //  [R1]
         { info_tbl: [(cdWVn,
                       label: sat_sdWr4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWVn: // global
           _sdWr4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWVo; else goto cdWVp;
       cdWVp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWVr; else goto cdWVq;
       cdWVr: // global
           HpAlloc = 16;
           goto cdWVo;
       cdWVo: // global
           R1 = _sdWr4::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWVq: // global
           _sdWq0::P64 = P64[_sdWr4::P64 + 7];
           _sdWqd::P64 = P64[_sdWr4::P64 + 15];
           I64[Hp - 8] = sat_sdWqZ_info;
           P64[Hp] = _sdWq0::P64;
           I64[Sp - 16] = block_cdWVi_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWqd::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWVi() //  [R1]
         { info_tbl: [(cdWVi,
                       label: block_cdWVi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWVi: // global
           _sdWqd::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sdWqd::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sdWqd::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrj_entry() //  [R1, R2]
         { info_tbl: [(cdWVC,
                       label: sat_sdWrj_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWVC: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[R1 + 6]);
           R1 = R2;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrc_entry() //  [R1]
         { info_tbl: [(cdWVP,
                       label: sat_sdWrc_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWVP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWVQ; else goto cdWVR;
       cdWVQ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWVR: // global
           I64[Sp - 16] = block_cdWVM_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           _cdWVL::I64 = I64[R1 + 15];
           _udWVV::P64 = CurrentTSO;
           I64[I64[_udWVV::P64 + 24] + 16] = Sp;
           _udWVW::I64 = CurrentNursery;
           P64[_udWVW::I64 + 8] = Hp + 8;
           I64[_udWVV::P64 + 104] = I64[_udWVV::P64 + 104] - ((Hp + 8) - I64[_udWVW::I64]);
           (_udWVT::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] forkOS_entry(_cdWVL::I64);
           (_udWVU::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udWVT::I64);
           BaseReg = _udWVU::I64;
           _udWVX::P64 = CurrentTSO;
           _udWVY::P64 = I64[_udWVX::P64 + 24];
           Sp = I64[_udWVY::P64 + 16];
           SpLim = _udWVY::P64 + 192;
           HpAlloc = 0;
           _udWVZ::I64 = CurrentNursery;
           _udWW0::I64 = I64[_udWVZ::I64 + 8];
           Hp = _udWW0::I64 - 8;
           _udWW1::I64 = I64[_udWVZ::I64];
           HpLim = _udWW1::I64 + ((%MO_SS_Conv_W32_W64(I32[_udWVZ::I64 + 48]) << 12) - 1);
           I64[_udWVX::P64 + 104] = I64[_udWVX::P64 + 104] + (_udWW0::I64 - _udWW1::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdWVM() //  []
         { info_tbl: [(cdWVM,
                       label: block_cdWVM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWVM: // global
           R1 = P64[P64[Sp + 8] + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrd_entry() //  [R1]
         { info_tbl: [(cdWW8,
                       label: sat_sdWrd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWW8: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrq_entry() //  [R1]
         { info_tbl: [(cdWWf,
                       label: sat_sdWrq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWWf: // global
           _sdWrq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWWg; else goto cdWWh;
       cdWWh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWWj; else goto cdWWi;
       cdWWj: // global
           HpAlloc = 24;
           goto cdWWg;
       cdWWg: // global
           R1 = _sdWrq::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWWi: // global
           _sdWq0::P64 = P64[_sdWrq::P64 + 7];
           _sdWqd::P64 = P64[_sdWrq::P64 + 15];
           I64[Hp - 16] = sat_sdWr4_info;
           P64[Hp - 8] = _sdWq0::P64;
           P64[Hp] = _sdWqd::P64;
           I64[Sp - 16] = block_cdWVt_info;
           R1 = Hp - 15;
           P64[Sp - 8] = _sdWqd::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWVt() //  [R1]
         { info_tbl: [(cdWVt,
                       label: block_cdWVt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWVt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdWWm; else goto cdWWl;
       cdWWm: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdWWl: // global
           I64[Hp - 48] = sat_sdWrj_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdWrc_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdWrd_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cdWWb_info;
           R2 = Hp - 46;
           _sdWr7::I64 = R1;
           R1 = Hp - 7;
           I64[Sp + 8] = _sdWr7::I64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWWb() //  [R1]
         { info_tbl: [(cdWWb,
                       label: block_cdWWb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWWb: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrD_entry() //  [R1]
         { info_tbl: [(cdWWC,
                       label: sat_sdWrD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWWC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWWD; else goto cdWWE;
       cdWWD: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWWE: // global
           I64[Sp - 8] = block_cdWWz_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWWz() //  [R1]
         { info_tbl: [(cdWWz,
                       label: block_cdWWz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWWz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWWH; else goto cdWWG;
       cdWWH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWWG: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrI_entry() //  [R1]
         { info_tbl: [(cdWWN,
                       label: sat_sdWrI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWWN: // global
           _sdWrI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWWO; else goto cdWWP;
       cdWWP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWWR; else goto cdWWQ;
       cdWWR: // global
           HpAlloc = 16;
           goto cdWWO;
       cdWWO: // global
           R1 = _sdWrI::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWWQ: // global
           _sdWq0::P64 = P64[_sdWrI::P64 + 7];
           _sdWqd::P64 = P64[_sdWrI::P64 + 15];
           I64[Hp - 8] = sat_sdWrD_info;
           P64[Hp] = _sdWq0::P64;
           I64[Sp - 16] = block_cdWWI_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWqd::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWWI() //  [R1]
         { info_tbl: [(cdWWI,
                       label: block_cdWWI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWWI: // global
           _sdWqd::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sdWqd::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sdWqd::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrX_entry() //  [R1, R2]
         { info_tbl: [(cdWX2,
                       label: sat_sdWrX_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWX2: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[R1 + 6]);
           R1 = R2;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrQ_entry() //  [R1]
         { info_tbl: [(cdWXf,
                       label: sat_sdWrQ_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWXf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdWXg; else goto cdWXh;
       cdWXg: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWXh: // global
           I64[Sp - 16] = block_cdWXc_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           _cdWXb::I64 = I64[R1 + 15];
           _udWXl::P64 = CurrentTSO;
           I64[I64[_udWXl::P64 + 24] + 16] = Sp;
           _udWXm::I64 = CurrentNursery;
           P64[_udWXm::I64 + 8] = Hp + 8;
           I64[_udWXl::P64 + 104] = I64[_udWXl::P64 + 104] - ((Hp + 8) - I64[_udWXm::I64]);
           (_udWXj::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] forkOS_entry(_cdWXb::I64);
           (_udWXk::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udWXj::I64);
           BaseReg = _udWXk::I64;
           _udWXn::P64 = CurrentTSO;
           _udWXo::P64 = I64[_udWXn::P64 + 24];
           Sp = I64[_udWXo::P64 + 16];
           SpLim = _udWXo::P64 + 192;
           HpAlloc = 0;
           _udWXp::I64 = CurrentNursery;
           _udWXq::I64 = I64[_udWXp::I64 + 8];
           Hp = _udWXq::I64 - 8;
           _udWXr::I64 = I64[_udWXp::I64];
           HpLim = _udWXr::I64 + ((%MO_SS_Conv_W32_W64(I32[_udWXp::I64 + 48]) << 12) - 1);
           I64[_udWXn::P64 + 104] = I64[_udWXn::P64 + 104] + (_udWXq::I64 - _udWXr::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdWXc() //  []
         { info_tbl: [(cdWXc,
                       label: block_cdWXc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWXc: // global
           R1 = P64[P64[Sp + 8] + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrR_entry() //  [R1]
         { info_tbl: [(cdWXy,
                       label: sat_sdWrR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWXy: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.runInBoundThread1_entry() //  [R2]
         { info_tbl: [(cdWXE,
                       label: Control.Concurrent.runInBoundThread1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWXE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdWXF; else goto cdWXG;
       cdWXF: // global
           R2 = R2;
           R1 = Control.Concurrent.runInBoundThread1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdWXG: // global
           (_sdWq5::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sdWq5::I64 == 0) goto cdWXD; else goto cdWXC;
       cdWXD: // global
           call Control.Concurrent.forkOS2_entry() args: 8, res: 0, upd: 8;
       cdWXC: // global
           I64[Sp - 16] = block_cdWTw_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_isCurrentThreadBound#() args: 8, res: 8, upd: 8;
     }
 },
 _cdWTw() //  [R1]
         { info_tbl: [(cdWTw,
                       label: block_cdWTw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWTw: // global
           if (R1 == 0) goto cdWXK; else goto cdWXJ;
       cdWXK: // global
           I64[Sp] = block_cdWTB_info;
           R1 = Control.Concurrent.runInBoundThread2_closure;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cdWXJ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdWTB() //  [R1]
         { info_tbl: [(cdWTB,
                       label: block_cdWTB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWTB: // global
           I64[Sp - 8] = block_cdWTD_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdWTD() //  [R1]
         { info_tbl: [(cdWTD,
                       label: block_cdWTD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWTD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWXO; else goto cdWXN;
       cdWXO: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdWXN: // global
           _sdWq0::P64 = P64[Sp + 16];
           _sdWqd::P64 = P64[Sp + 8];
           if (R1 == 0) goto cdWYe; else goto udWYP;
       cdWYe: // global
           I64[Hp - 16] = sat_sdWrq_info;
           P64[Hp - 8] = _sdWq0::P64;
           P64[Hp] = _sdWqd::P64;
           I64[Sp + 16] = block_cdWYb_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
       udWYP: // global
           if (R1 == 1) goto cdWYw; else goto cdWXV;
       cdWYw: // global
           I64[Hp - 16] = sat_sdWrI_info;
           P64[Hp - 8] = _sdWq0::P64;
           P64[Hp] = _sdWqd::P64;
           I64[Sp] = block_cdWWT_info;
           R1 = Hp - 15;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
       cdWXV: // global
           I64[Hp - 16] = sat_sdWqt_info;
           P64[Hp - 8] = _sdWq0::P64;
           P64[Hp] = _sdWqd::P64;
           I64[Sp] = block_cdWUb_info;
           R1 = Hp - 15;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWYb() //  [R1]
         { info_tbl: [(cdWYb,
                       label: block_cdWYb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWYb: // global
           I64[Sp] = block_cdWYd_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udWYR; else goto cdWYg;
       udWYR: // global
           call _cdWYd(R1) args: 0, res: 0, upd: 0;
       cdWYg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWYd() //  [R1]
         { info_tbl: [(cdWYd,
                       label: block_cdWYd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWYd: // global
           if (R1 & 7 == 1) goto cdWYm; else goto cdWYq;
       cdWYm: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdWYq: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdWWT() //  [R1]
         { info_tbl: [(cdWWT,
                       label: block_cdWWT_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWWT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdWYz; else goto cdWYy;
       cdWYz: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdWYy: // global
           I64[Hp - 48] = sat_sdWrX_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdWrQ_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdWrR_info;
           P64[Hp] = Hp - 31;
           I64[Sp + 8] = block_cdWYr_info;
           R2 = Hp - 46;
           _sdWrL::I64 = R1;
           R1 = Hp - 7;
           I64[Sp + 16] = _sdWrL::I64;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWYr() //  [R1]
         { info_tbl: [(cdWYr,
                       label: block_cdWYr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWYr: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           I64[Sp + 8] = block_cdWYv_info;
           R1 = R1;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udWYS; else goto cdWYB;
       udWYS: // global
           call _cdWYv(R1) args: 0, res: 0, upd: 0;
       cdWYB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWYv() //  [R1]
         { info_tbl: [(cdWYv,
                       label: block_cdWYv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWYv: // global
           if (R1 & 7 == 1) goto cdWYH; else goto cdWYL;
       cdWYH: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdWYL: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdWUb() //  [R1]
         { info_tbl: [(cdWUb,
                       label: block_cdWUb_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWUb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdWXY; else goto cdWXX;
       cdWXY: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdWXX: // global
           I64[Hp - 48] = sat_sdWqI_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdWqB_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdWqC_info;
           P64[Hp] = Hp - 31;
           I64[Sp + 8] = block_cdWXP_info;
           R2 = Hp - 46;
           _sdWqw::I64 = R1;
           R1 = Hp - 7;
           I64[Sp + 16] = _sdWqw::I64;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWXP() //  [R1]
         { info_tbl: [(cdWXP,
                       label: block_cdWXP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWXP: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           I64[Sp + 8] = block_cdWXT_info;
           R1 = R1;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udWYQ; else goto cdWY0;
       udWYQ: // global
           call _cdWXT(R1) args: 0, res: 0, upd: 0;
       cdWY0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWXT() //  [R1]
         { info_tbl: [(cdWXT,
                       label: block_cdWXT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWXT: // global
           if (R1 & 7 == 1) goto cdWY6; else goto cdWYa;
       cdWY6: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdWYa: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.336971328 UTC

[section ""data" . Control.Concurrent.runInBoundThread_closure" {
     Control.Concurrent.runInBoundThread_closure:
         const Control.Concurrent.runInBoundThread_info;
         const 0;
 },
 Control.Concurrent.runInBoundThread_entry() //  [R2]
         { info_tbl: [(cdWYX,
                       label: Control.Concurrent.runInBoundThread_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWYX: // global
           R2 = R2;
           call Control.Concurrent.runInBoundThread1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.340442865 UTC

[section ""data" . Control.Concurrent.forkFinally1_closure" {
     Control.Concurrent.forkFinally1_closure:
         const Control.Concurrent.forkFinally1_info;
         const 0;
 },
 sat_sdWsl_entry() //  [R1]
         { info_tbl: [(cdWZq,
                       label: sat_sdWsl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWZq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdWZr; else goto cdWZs;
       cdWZr: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWZs: // global
           I64[Sp - 8] = block_cdWZn_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWZn() //  [R1]
         { info_tbl: [(cdWZn,
                       label: block_cdWZn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWZn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWZv; else goto cdWZu;
       cdWZv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdWZu: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsp_entry() //  [R1]
         { info_tbl: [(cdWZy,
                       label: sat_sdWsp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWZy: // global
           _sdWsp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdWZz; else goto cdWZA;
       cdWZA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdWZC; else goto cdWZB;
       cdWZC: // global
           HpAlloc = 16;
           goto cdWZz;
       cdWZz: // global
           R1 = _sdWsp::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWZB: // global
           _sdWs7::P64 = P64[_sdWsp::P64 + 7];
           _sdWs8::P64 = P64[_sdWsp::P64 + 15];
           I64[Hp - 8] = sat_sdWsl_info;
           P64[Hp] = _sdWs7::P64;
           I64[Sp - 16] = block_cdWZw_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWs8::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWZw() //  [R1]
         { info_tbl: [(cdWZw,
                       label: block_cdWZw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWZw: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsq_entry() //  [R1]
         { info_tbl: [(cdWZE,
                       label: sat_sdWsq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWZE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdWZI; else goto cdWZH;
       cdWZI: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdWZH: // global
           _sdWs7::P64 = P64[R1 + 7];
           _sdWs8::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWsp_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsD_entry() //  [R1]
         { info_tbl: [(cdX07,
                       label: sat_sdWsD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX07: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdX08; else goto cdX09;
       cdX08: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX09: // global
           I64[Sp - 8] = block_cdX04_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX04() //  [R1]
         { info_tbl: [(cdX04,
                       label: block_cdX04_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX04: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX0c; else goto cdX0b;
       cdX0c: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdX0b: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsH_entry() //  [R1]
         { info_tbl: [(cdX0f,
                       label: sat_sdWsH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX0f: // global
           _sdWsH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdX0g; else goto cdX0h;
       cdX0h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX0j; else goto cdX0i;
       cdX0j: // global
           HpAlloc = 16;
           goto cdX0g;
       cdX0g: // global
           R1 = _sdWsH::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX0i: // global
           _sdWs7::P64 = P64[_sdWsH::P64 + 7];
           _sdWs8::P64 = P64[_sdWsH::P64 + 15];
           I64[Hp - 8] = sat_sdWsD_info;
           P64[Hp] = _sdWs7::P64;
           I64[Sp - 16] = block_cdX0d_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWs8::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX0d() //  [R1]
         { info_tbl: [(cdX0d,
                       label: block_cdX0d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX0d: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsI_entry() //  [R1]
         { info_tbl: [(cdX0l,
                       label: sat_sdWsI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX0l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdX0p; else goto cdX0o;
       cdX0p: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX0o: // global
           _sdWs7::P64 = P64[R1 + 7];
           _sdWs8::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWsH_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsN_entry() //  [R1]
         { info_tbl: [(cdX0t,
                       label: sat_sdWsN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX0t: // global
           _sdWsN::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdX0u; else goto cdX0v;
       cdX0v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdX0x; else goto cdX0w;
       cdX0x: // global
           HpAlloc = 24;
           goto cdX0u;
       cdX0u: // global
           R1 = _sdWsN::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX0w: // global
           _sdWs7::P64 = P64[_sdWsN::P64 + 7];
           _sdWs8::P64 = P64[_sdWsN::P64 + 15];
           I64[Hp - 16] = sat_sdWsI_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           I64[Sp - 8] = block_cdX0q_info;
           R1 = Hp - 15;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX0q() //  [R1]
         { info_tbl: [(cdX0q,
                       label: block_cdX0q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX0q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX0A; else goto cdX0z;
       cdX0A: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdX0z: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsV_entry() //  [R1]
         { info_tbl: [(cdX0U,
                       label: sat_sdWsV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX0U: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdX0V; else goto cdX0W;
       cdX0V: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX0W: // global
           I64[Sp - 8] = block_cdX0R_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX0R() //  [R1]
         { info_tbl: [(cdX0R,
                       label: block_cdX0R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX0R: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX0Z; else goto cdX0Y;
       cdX0Z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdX0Y: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsZ_entry() //  [R1]
         { info_tbl: [(cdX12,
                       label: sat_sdWsZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX12: // global
           _sdWsZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdX13; else goto cdX14;
       cdX14: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX16; else goto cdX15;
       cdX16: // global
           HpAlloc = 16;
           goto cdX13;
       cdX13: // global
           R1 = _sdWsZ::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX15: // global
           _sdWs7::P64 = P64[_sdWsZ::P64 + 7];
           _sdWs8::P64 = P64[_sdWsZ::P64 + 15];
           I64[Hp - 8] = sat_sdWsV_info;
           P64[Hp] = _sdWs7::P64;
           I64[Sp - 16] = block_cdX10_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWs8::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX10() //  [R1]
         { info_tbl: [(cdX10,
                       label: block_cdX10_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX10: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWt0_entry() //  [R1]
         { info_tbl: [(cdX18,
                       label: sat_sdWt0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX18: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdX1c; else goto cdX1b;
       cdX1c: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX1b: // global
           _sdWs7::P64 = P64[R1 + 7];
           _sdWs8::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWsZ_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.forkFinally1_entry() //  [R2, R3]
         { info_tbl: [(cdX1h,
                       label: Control.Concurrent.forkFinally1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX1h: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdX1i; else goto cdX1j;
       cdX1i: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.forkFinally1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdX1j: // global
           I64[Sp - 24] = block_cdWZ4_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdWZ4() //  [R1]
         { info_tbl: [(cdWZ4,
                       label: block_cdWZ4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWZ4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdX1m; else goto cdX1l;
       cdX1m: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdX1l: // global
           _sdWs7::P64 = P64[Sp + 8];
           _sdWs8::P64 = P64[Sp + 16];
           if (R1 == 0) goto cdX1f; else goto udX1z;
       cdX1f: // global
           I64[Hp - 16] = sat_sdWsN_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       udX1z: // global
           if (R1 == 1) goto cdX1g; else goto cdX1e;
       cdX1g: // global
           I64[Hp - 16] = sat_sdWt0_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           I64[Sp + 16] = block_cdX1t_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
       cdX1e: // global
           I64[Hp - 16] = sat_sdWsq_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           I64[Sp + 16] = block_cdX1n_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX1t() //  [R1]
         { info_tbl: [(cdX1t,
                       label: block_cdX1t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX1t: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX1y; else goto cdX1x;
       cdX1y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdX1x: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdX1n() //  [R1]
         { info_tbl: [(cdX1n,
                       label: block_cdX1n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX1n: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX1s; else goto cdX1r;
       cdX1s: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdX1r: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.347582932 UTC

[section ""data" . Control.Concurrent.forkFinally_closure" {
     Control.Concurrent.forkFinally_closure:
         const Control.Concurrent.forkFinally_info;
         const 0;
 },
 Control.Concurrent.forkFinally_entry() //  [R2, R3]
         { info_tbl: [(cdX1E,
                       label: Control.Concurrent.forkFinally_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX1E: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.forkFinally1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.348532678 UTC

[section ""cstring" . lvl12_rdWo2_bytes" {
     lvl12_rdWo2_bytes:
         I8[] [67,97,110,110,111,116,32,99,114,101,97,116,101,32,79,83,32,116,104,114,101,97,100,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.349466963 UTC

[section ""data" . Control.Concurrent.forkOS3_closure" {
     Control.Concurrent.forkOS3_closure:
         const Control.Concurrent.forkOS3_info;
         const 0;
 },
 Control.Concurrent.forkOS3_entry() //  []
         { info_tbl: [(cdX1N,
                       label: Control.Concurrent.forkOS3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX1N: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdX1O; else goto cdX1P;
       cdX1O: // global
           R1 = Control.Concurrent.forkOS3_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX1P: // global
           I64[Sp - 8] = block_cdX1L_info;
           R2 = lvl12_rdWo2_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdX1L() //  [R1]
         { info_tbl: [(cdX1L,
                       label: block_cdX1L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX1L: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.352022036 UTC

[section ""data" . Control.Concurrent.forkOS1_closure" {
     Control.Concurrent.forkOS1_closure:
         const Control.Concurrent.forkOS1_info;
         const 0;
 },
 sat_sdWtr_entry() //  [R1]
         { info_tbl: [(cdX2o,
                       label: sat_sdWtr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX2o: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWts_entry() //  [R1]
         { info_tbl: [(cdX2v,
                       label: sat_sdWts_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX2v: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX2z; else goto cdX2y;
       cdX2z: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdX2y: // global
           _sdWt7::P64 = P64[R1 + 16];
           _sdWtq::I64 = I64[R1 + 24];
           if (_sdWtq::I64 != 0) goto udX2A; else goto cdX2t;
       udX2A: // global
           if (_sdWtq::I64 != 1) goto cdX2s; else goto cdX2u;
       cdX2s: // global
           Hp = Hp - 16;
           R1 = _sdWt7::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdX2u: // global
           Hp = Hp - 16;
           R2 = _sdWt7::P64;
           R1 = GHC.IO.uninterruptibleMask_1_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cdX2t: // global
           I64[Hp - 8] = sat_sdWtr_info;
           P64[Hp] = _sdWt7::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWtt_entry() //  [R1]
         { info_tbl: [(cdX2B,
                       label: sat_sdWtt_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX2B: // global
           _sdWtt::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdX2C; else goto cdX2D;
       cdX2D: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX2F; else goto cdX2E;
       cdX2F: // global
           HpAlloc = 16;
           goto cdX2C;
       cdX2C: // global
           R1 = _sdWtt::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX2E: // global
           _sdWt7::P64 = P64[_sdWtt::P64 + 7];
           _sdWtg::P64 = P64[_sdWtt::P64 + 15];
           _sdWtj::I64 = I64[_sdWtt::P64 + 23];
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           I64[Hp] = CurrentTSO;
           I64[Sp - 24] = block_cdX2a_info;
           R2 = Hp - 7;
           R1 = _sdWtg::P64;
           P64[Sp - 16] = _sdWt7::P64;
           I64[Sp - 8] = _sdWtj::I64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX2a() //  []
         { info_tbl: [(cdX2a,
                       label: block_cdX2a_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX2a: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdX2I; else goto cdX2H;
       cdX2I: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdX2H: // global
           I64[Hp - 24] = sat_sdWts_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R2 = GHC.Conc.Sync.childHandler1_closure+2;
           R1 = Hp - 24;
           Sp = Sp + 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.forkOS1_entry() //  [R2]
         { info_tbl: [(cdX2M,
                       label: Control.Concurrent.forkOS1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX2M: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdX2N; else goto cdX2O;
       cdX2N: // global
           R2 = R2;
           R1 = Control.Concurrent.forkOS1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdX2O: // global
           (_sdWtc::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sdWtc::I64 == 0) goto cdX2L; else goto cdX2K;
       cdX2L: // global
           call Control.Concurrent.forkOS2_entry() args: 8, res: 0, upd: 8;
       cdX2K: // global
           I64[Sp - 16] = block_cdX20_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdX20() //  [R1]
         { info_tbl: [(cdX20,
                       label: block_cdX20_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX20: // global
           I64[Sp - 8] = block_cdX22_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdX22() //  [R1]
         { info_tbl: [(cdX22,
                       label: block_cdX22_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX22: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdX2T; else goto cdX2S;
       cdX2T: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdX2S: // global
           I64[Hp - 24] = sat_sdWtt_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = R1;
           I64[Sp] = block_cdX2P_info;
           R1 = Hp - 23;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX2P() //  [R1]
         { info_tbl: [(cdX2P,
                       label: block_cdX2P_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX2P: // global
           I64[Sp] = block_cdX2Y_info;
           I64[Sp + 16] = R1;
           _udX3n::P64 = CurrentTSO;
           I64[I64[_udX3n::P64 + 24] + 16] = Sp;
           _udX3o::I64 = CurrentNursery;
           P64[_udX3o::I64 + 8] = Hp + 8;
           I64[_udX3n::P64 + 104] = I64[_udX3n::P64 + 104] - ((Hp + 8) - I64[_udX3o::I64]);
           (_udX3l::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sdWtA::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [‘signed’] forkOS_createThread(R1);
           (_udX3m::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udX3l::I64);
           BaseReg = _udX3m::I64;
           _udX3p::P64 = CurrentTSO;
           _udX3q::P64 = I64[_udX3p::P64 + 24];
           Sp = I64[_udX3q::P64 + 16];
           SpLim = _udX3q::P64 + 192;
           HpAlloc = 0;
           _udX3r::I64 = CurrentNursery;
           _udX3s::I64 = I64[_udX3r::I64 + 8];
           Hp = _udX3s::I64 - 8;
           _udX3t::I64 = I64[_udX3r::I64];
           HpLim = _udX3t::I64 + ((%MO_SS_Conv_W32_W64(I32[_udX3r::I64 + 48]) << 12) - 1);
           I64[_udX3p::P64 + 104] = I64[_udX3p::P64 + 104] + (_udX3s::I64 - _udX3t::I64);
           R1 = _sdWtA::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX2Y() //  [R1]
         { info_tbl: [(cdX2Y,
                       label: block_cdX2Y_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX2Y: // global
           if (%MO_SS_Conv_W64_W32(R1) == 0 :: W32) goto cdX3f; else goto cdX36;
       cdX3f: // global
           _sdWtg::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdX3e_info;
           R1 = _sdWtg::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdX36: // global
           Sp = Sp + 24;
           call Control.Concurrent.forkOS3_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cdX3e() //  [R1]
         { info_tbl: [(cdX3e,
                       label: block_cdX3e_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX3e: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.358638292 UTC

[section ""data" . Control.Concurrent.forkOS_closure" {
     Control.Concurrent.forkOS_closure:
         const Control.Concurrent.forkOS_info;
         const 0;
 },
 Control.Concurrent.forkOS_entry() //  [R2]
         { info_tbl: [(cdX3z,
                       label: Control.Concurrent.forkOS_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX3z: // global
           R2 = R2;
           call Control.Concurrent.forkOS1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.359860501 UTC

[section ""data" . Control.Concurrent.forkOSWithUnmask1_closure" {
     Control.Concurrent.forkOSWithUnmask1_closure:
         const Control.Concurrent.forkOSWithUnmask1_info;
         const 0;
 },
 sat_sdWtL_entry() //  [R2]
         { info_tbl: [(cdX3P,
                       label: sat_sdWtL_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX3P: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWtM_entry() //  [R1]
         { info_tbl: [(cdX3S,
                       label: sat_sdWtM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX3S: // global
           _sdWtM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdX3T; else goto cdX3U;
       cdX3U: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX3W; else goto cdX3V;
       cdX3W: // global
           HpAlloc = 16;
           goto cdX3T;
       cdX3T: // global
           R1 = _sdWtM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdX3V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdWtM::P64;
           _sdWtJ::P64 = P64[_sdWtM::P64 + 16];
           I64[Hp - 8] = sat_sdWtL_info;
           R2 = Hp - 6;
           R1 = _sdWtJ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Concurrent.forkOSWithUnmask1_entry() //  [R2]
         { info_tbl: [(cdX3X,
                       label: Control.Concurrent.forkOSWithUnmask1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX3X: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdX41; else goto cdX40;
       cdX41: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Concurrent.forkOSWithUnmask1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdX40: // global
           I64[Hp - 16] = sat_sdWtM_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Concurrent.forkOS1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.361432334 UTC

[section ""data" . Control.Concurrent.forkOSWithUnmask_closure" {
     Control.Concurrent.forkOSWithUnmask_closure:
         const Control.Concurrent.forkOSWithUnmask_info;
         const 0;
 },
 Control.Concurrent.forkOSWithUnmask_entry() //  [R2]
         { info_tbl: [(cdX46,
                       label: Control.Concurrent.forkOSWithUnmask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX46: // global
           R2 = R2;
           call Control.Concurrent.forkOSWithUnmask1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.362456867 UTC

[section ""data" . Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_closure" {
     Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_closure:
         const Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_info;
 },
 Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_entry() //  [R2]
         { info_tbl: [(cdX4g,
                       label: Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX4g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdX4k; else goto cdX4l;
       cdX4k: // global
           R2 = R2;
           R1 = Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdX4l: // global
           I64[Sp - 8] = block_cdX4d_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udX4p; else goto cdX4e;
       udX4p: // global
           call _cdX4d(R1) args: 0, res: 0, upd: 0;
       cdX4e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX4d() //  [R1]
         { info_tbl: [(cdX4d,
                       label: block_cdX4d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX4d: // global
           I64[Sp] = block_cdX4j_info;
           R1 = I64[R1 + 7];
           call stg_deRefStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX4j() //  [R1]
         { info_tbl: [(cdX4j,
                       label: block_cdX4j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX4j: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.36367438 UTC

[section ""data" . Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_closure" {
     Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_closure:
         const Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_info;
 },
 Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_entry() //  [R2]
         { info_tbl: [(cdX4u,
                       label: Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX4u: // global
           R2 = R2;
           call Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.364362818 UTC

[section ""relreadonly" . SdWuv_srt" {
     SdWuv_srt:
         const GHC.Conc.IO.threadWaitRead1_closure;
         const GHC.Conc.IO.threadWaitWrite1_closure;
         const GHC.Conc.IO.threadWaitReadSTM1_closure;
         const GHC.Conc.IO.threadWaitWriteSTM1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const Control.Concurrent.runInUnboundThread1_closure;
         const GHC.IO.failIO1_closure;
         const Control.Concurrent.forkOS2_closure;
         const GHC.Err.undefined_closure;
         const lvl11_rdWo1_closure;
         const Control.Concurrent.runInBoundThread1_closure;
         const Control.Concurrent.runInBoundThread2_closure;
         const Control.Concurrent.forkFinally1_closure;
         const Control.Concurrent.forkOS3_closure;
         const GHC.Conc.Sync.childHandler1_closure;
         const Control.Concurrent.forkOS1_closure;
         const Control.Concurrent.forkOSWithUnmask1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.382398804 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:12.384317446 UTC

[section ""data" . Control.Concurrent.isCurrentThreadBound1_closure" {
     Control.Concurrent.isCurrentThreadBound1_closure:
         const Control.Concurrent.isCurrentThreadBound1_info;
 },
 sat_sdWo9_entry() //  [R1]
         { info_tbl: [(cdX4L,
                       label: sat_sdWo9_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX4L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdX4M; else goto cdX4N;
       cdX4M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdX4N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto cdX4K; else goto cdX4J;
       cdX4K: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdX4J: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Concurrent.isCurrentThreadBound1_entry() //  []
         { info_tbl: [(cdX4O,
                       label: Control.Concurrent.isCurrentThreadBound1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX4O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdX4P; else goto cdX4Q;
       cdX4P: // global
           R1 = Control.Concurrent.isCurrentThreadBound1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX4Q: // global
           I64[Sp - 8] = block_cdX4B_info;
           Sp = Sp - 8;
           call stg_isCurrentThreadBound#() args: 8, res: 8, upd: 8;
     }
 },
 _cdX4B() //  [R1]
         { info_tbl: [(cdX4B,
                       label: block_cdX4B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX4B: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdX4T; else goto cdX4S;
       cdX4T: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdX4S: // global
           I64[Hp - 16] = sat_sdWo9_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.404831392 UTC

[section ""data" . Control.Concurrent.isCurrentThreadBound_closure" {
     Control.Concurrent.isCurrentThreadBound_closure:
         const Control.Concurrent.isCurrentThreadBound_info;
 },
 Control.Concurrent.isCurrentThreadBound_entry() //  []
         { info_tbl: [(cdX5d,
                       label: Control.Concurrent.isCurrentThreadBound_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX5d: // global
           call Control.Concurrent.isCurrentThreadBound1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.411125661 UTC

[section ""data" . Control.Concurrent.threadWaitRead_closure" {
     Control.Concurrent.threadWaitRead_closure:
         const Control.Concurrent.threadWaitRead_info;
         const 0;
 },
 Control.Concurrent.threadWaitRead_entry() //  [R2]
         { info_tbl: [(cdX5o,
                       label: Control.Concurrent.threadWaitRead_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX5o: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitRead1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.417413958 UTC

[section ""data" . Control.Concurrent.threadWaitWrite_closure" {
     Control.Concurrent.threadWaitWrite_closure:
         const Control.Concurrent.threadWaitWrite_info;
         const 0;
 },
 Control.Concurrent.threadWaitWrite_entry() //  [R2]
         { info_tbl: [(cdX5z,
                       label: Control.Concurrent.threadWaitWrite_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX5z: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWrite1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.423642074 UTC

[section ""data" . Control.Concurrent.threadWaitReadSTM_closure" {
     Control.Concurrent.threadWaitReadSTM_closure:
         const Control.Concurrent.threadWaitReadSTM_info;
         const 0;
 },
 Control.Concurrent.threadWaitReadSTM_entry() //  [R2]
         { info_tbl: [(cdX5K,
                       label: Control.Concurrent.threadWaitReadSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX5K: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitReadSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.428101691 UTC

[section ""data" . Control.Concurrent.threadWaitWriteSTM_closure" {
     Control.Concurrent.threadWaitWriteSTM_closure:
         const Control.Concurrent.threadWaitWriteSTM_info;
         const 0;
 },
 Control.Concurrent.threadWaitWriteSTM_entry() //  [R2]
         { info_tbl: [(cdX5V,
                       label: Control.Concurrent.threadWaitWriteSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX5V: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWriteSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.433525169 UTC

[section ""cstring" . Control.Concurrent.$trModule4_bytes" {
     Control.Concurrent.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.43549213 UTC

[section ""data" . Control.Concurrent.$trModule3_closure" {
     Control.Concurrent.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.437520039 UTC

[section ""cstring" . Control.Concurrent.$trModule2_bytes" {
     Control.Concurrent.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.439252493 UTC

[section ""data" . Control.Concurrent.$trModule1_closure" {
     Control.Concurrent.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.441077348 UTC

[section ""data" . Control.Concurrent.$trModule_closure" {
     Control.Concurrent.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.$trModule3_closure+1;
         const Control.Concurrent.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.443485241 UTC

[section ""data" . Control.Concurrent.rtsSupportsBoundThreads_closure" {
     Control.Concurrent.rtsSupportsBoundThreads_closure:
         const Control.Concurrent.rtsSupportsBoundThreads_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Concurrent.rtsSupportsBoundThreads_entry() //  [R1]
         { info_tbl: [(cdX6i,
                       label: Control.Concurrent.rtsSupportsBoundThreads_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX6i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdX6j; else goto cdX6k;
       cdX6j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdX6k: // global
           (_cdX6a::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdX6a::I64 == 0) goto cdX6c; else goto cdX6b;
       cdX6c: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdX6b: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdX6a::I64;
           (_sdWod::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sdWod::I64 == 0) goto cdX6h; else goto cdX6g;
       cdX6h: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdX6g: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.448453788 UTC

[section ""data" . Control.Concurrent.forkFinally2_closure" {
     Control.Concurrent.forkFinally2_closure:
         const Control.Concurrent.forkFinally2_info;
 },
 Control.Concurrent.forkFinally2_entry() //  [R2]
         { info_tbl: [(cdX6z,
                       label: Control.Concurrent.forkFinally2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX6z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX6D; else goto cdX6C;
       cdX6D: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Control.Concurrent.forkFinally2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdX6C: // global
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.457471041 UTC

[section ""data" . Control.Concurrent.runInUnboundThread1_closure" {
     Control.Concurrent.runInUnboundThread1_closure:
         const Control.Concurrent.runInUnboundThread1_info;
         const 0;
 },
 lvl13_sdWou_entry() //  [R1]
         { info_tbl: [(cdX70,
                       label: lvl13_sdWou_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX70: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWoE_entry() //  [R1]
         { info_tbl: [(cdX7n,
                       label: sat_sdWoE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX7n: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdX7o; else goto cdX7p;
       cdX7o: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX7p: // global
           I64[Sp - 8] = block_cdX7k_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX7k() //  [R1]
         { info_tbl: [(cdX7k,
                       label: block_cdX7k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX7k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX7s; else goto cdX7r;
       cdX7s: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdX7r: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWoJ_entry() //  [R1]
         { info_tbl: [(cdX7x,
                       label: sat_sdWoJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX7x: // global
           _sdWoJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdX7y; else goto cdX7z;
       cdX7z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX7B; else goto cdX7A;
       cdX7B: // global
           HpAlloc = 16;
           goto cdX7y;
       cdX7y: // global
           R1 = _sdWoJ::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX7A: // global
           _sdWoi::P64 = P64[_sdWoJ::P64 + 7];
           _sdWoq::P64 = P64[_sdWoJ::P64 + 15];
           I64[Hp - 8] = sat_sdWoE_info;
           P64[Hp] = _sdWoi::P64;
           I64[Sp - 16] = block_cdX7t_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWoq::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX7t() //  [R1]
         { info_tbl: [(cdX7t,
                       label: block_cdX7t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX7t: // global
           _sdWoq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdX7v_info;
           R2 = R1;
           R1 = _sdWoq::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX7v() //  []
         { info_tbl: [(cdX7v,
                       label: block_cdX7v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX7v: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWoK_entry() //  [R1]
         { info_tbl: [(cdX7E,
                       label: sat_sdWoK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX7E: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdX7I; else goto cdX7H;
       cdX7I: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX7H: // global
           _sdWoi::P64 = P64[R1 + 7];
           _sdWoq::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWoJ_info;
           P64[Hp - 8] = _sdWoi::P64;
           P64[Hp] = _sdWoq::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWoT_entry() //  [R1, R2]
         { info_tbl: [(cdX7X,
                       label: sat_sdWoT_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX7X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdX7Y; else goto cdX7Z;
       cdX7Y: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdX7Z: // global
           I64[Sp - 16] = block_cdX7V_info;
           R2 = R2;
           _sdWoO::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdWoO::P64;
           Sp = Sp - 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX7V() //  []
         { info_tbl: [(cdX7V,
                       label: block_cdX7V_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX7V: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call wait_sdWoO_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 wait_sdWoO_entry() //  [R1]
         { info_tbl: [(cdX81,
                       label: wait_sdWoO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX81: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdX85; else goto cdX84;
       cdX85: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX84: // global
           _sdWou::P64 = P64[R1 + 7];
           _sdWoN::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWoT_info;
           P64[Hp - 8] = _sdWoN::P64;
           P64[Hp] = R1;
           R2 = Hp - 14;
           R1 = _sdWou::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWp8_entry() //  [R1]
         { info_tbl: [(cdX8u,
                       label: sat_sdWp8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX8u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdX8v; else goto cdX8w;
       cdX8v: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX8w: // global
           I64[Sp - 8] = block_cdX8r_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX8r() //  [R1]
         { info_tbl: [(cdX8r,
                       label: block_cdX8r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX8r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX8z; else goto cdX8y;
       cdX8z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdX8y: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpd_entry() //  [R1]
         { info_tbl: [(cdX8E,
                       label: sat_sdWpd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX8E: // global
           _sdWpd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdX8F; else goto cdX8G;
       cdX8G: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdX8I; else goto cdX8H;
       cdX8I: // global
           HpAlloc = 16;
           goto cdX8F;
       cdX8F: // global
           R1 = _sdWpd::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX8H: // global
           _sdWoi::P64 = P64[_sdWpd::P64 + 7];
           _sdWoq::P64 = P64[_sdWpd::P64 + 15];
           I64[Hp - 8] = sat_sdWp8_info;
           P64[Hp] = _sdWoi::P64;
           I64[Sp - 16] = block_cdX8A_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWoq::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX8A() //  [R1]
         { info_tbl: [(cdX8A,
                       label: block_cdX8A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX8A: // global
           _sdWoq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdX8C_info;
           R2 = R1;
           R1 = _sdWoq::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX8C() //  []
         { info_tbl: [(cdX8C,
                       label: block_cdX8C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX8C: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpe_entry() //  [R1]
         { info_tbl: [(cdX8L,
                       label: sat_sdWpe_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX8L: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdX8P; else goto cdX8O;
       cdX8P: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX8O: // global
           _sdWoi::P64 = P64[R1 + 7];
           _sdWoq::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWpd_info;
           P64[Hp - 8] = _sdWoi::P64;
           P64[Hp] = _sdWoq::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpn_entry() //  [R1, R2]
         { info_tbl: [(cdX94,
                       label: sat_sdWpn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX94: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdX95; else goto cdX96;
       cdX95: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdX96: // global
           I64[Sp - 16] = block_cdX92_info;
           R2 = R2;
           _sdWpi::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdWpi::P64;
           Sp = Sp - 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX92() //  []
         { info_tbl: [(cdX92,
                       label: block_cdX92_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX92: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call wait_sdWpi_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 wait_sdWpi_entry() //  [R1]
         { info_tbl: [(cdX98,
                       label: wait_sdWpi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX98: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdX9c; else goto cdX9b;
       cdX9c: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX9b: // global
           _sdWou::P64 = P64[R1 + 7];
           _sdWph::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWpn_info;
           P64[Hp - 8] = _sdWph::P64;
           P64[Hp] = R1;
           R2 = Hp - 14;
           R1 = _sdWou::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpu_entry() //  [R1]
         { info_tbl: [(cdX9m,
                       label: sat_sdWpu_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX9m: // global
           _sdWpu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdX9n; else goto cdX9o;
       cdX9o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdX9q; else goto cdX9p;
       cdX9q: // global
           HpAlloc = 24;
           goto cdX9n;
       cdX9n: // global
           R1 = _sdWpu::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX9p: // global
           _sdWoi::P64 = P64[_sdWpu::P64 + 7];
           _sdWoq::P64 = P64[_sdWpu::P64 + 15];
           _sdWou::P64 = P64[_sdWpu::P64 + 23];
           I64[Hp - 16] = sat_sdWpe_info;
           P64[Hp - 8] = _sdWoi::P64;
           P64[Hp] = _sdWoq::P64;
           I64[Sp - 16] = block_cdX8Q_info;
           R1 = Hp - 15;
           P64[Sp - 8] = _sdWou::P64;
           Sp = Sp - 16;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX8Q() //  [R1]
         { info_tbl: [(cdX8Q,
                       label: block_cdX8Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX8Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdX9t; else goto cdX9s;
       cdX9t: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdX9s: // global
           I64[Hp - 16] = wait_sdWpi_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cdX9d_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call wait_sdWpi_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX9d() //  [R1]
         { info_tbl: [(cdX9d,
                       label: block_cdX9d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX9d: // global
           I64[Sp] = block_cdX9f_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udX9B; else goto cdX9g;
       udX9B: // global
           call _cdX9f(R1) args: 0, res: 0, upd: 0;
       cdX9g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX9f() //  [R1]
         { info_tbl: [(cdX9f,
                       label: block_cdX9f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX9f: // global
           if (R1 & 7 == 1) goto cdX9j; else goto cdX9k;
       cdX9j: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdX9k: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpC_entry() //  [R1]
         { info_tbl: [(cdX9V,
                       label: sat_sdWpC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX9V: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdX9W; else goto cdX9X;
       cdX9W: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdX9X: // global
           I64[Sp - 8] = block_cdX9S_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdX9S() //  [R1]
         { info_tbl: [(cdX9S,
                       label: block_cdX9S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX9S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXa0; else goto cdX9Z;
       cdXa0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdX9Z: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpH_entry() //  [R1]
         { info_tbl: [(cdXa5,
                       label: sat_sdWpH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXa5: // global
           _sdWpH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXa6; else goto cdXa7;
       cdXa7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXa9; else goto cdXa8;
       cdXa9: // global
           HpAlloc = 16;
           goto cdXa6;
       cdXa6: // global
           R1 = _sdWpH::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXa8: // global
           _sdWoi::P64 = P64[_sdWpH::P64 + 7];
           _sdWoq::P64 = P64[_sdWpH::P64 + 15];
           I64[Hp - 8] = sat_sdWpC_info;
           P64[Hp] = _sdWoi::P64;
           I64[Sp - 16] = block_cdXa1_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWoq::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXa1() //  [R1]
         { info_tbl: [(cdXa1,
                       label: block_cdXa1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXa1: // global
           _sdWoq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdXa3_info;
           R2 = R1;
           R1 = _sdWoq::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXa3() //  []
         { info_tbl: [(cdXa3,
                       label: block_cdXa3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXa3: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpI_entry() //  [R1]
         { info_tbl: [(cdXac,
                       label: sat_sdWpI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXac: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXag; else goto cdXaf;
       cdXag: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXaf: // global
           _sdWoi::P64 = P64[R1 + 7];
           _sdWoq::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWpH_info;
           P64[Hp - 8] = _sdWoi::P64;
           P64[Hp] = _sdWoq::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWpR_entry() //  [R1, R2]
         { info_tbl: [(cdXav,
                       label: sat_sdWpR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXav: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXaw; else goto cdXax;
       cdXaw: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXax: // global
           I64[Sp - 16] = block_cdXat_info;
           R2 = R2;
           _sdWpM::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdWpM::P64;
           Sp = Sp - 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXat() //  []
         { info_tbl: [(cdXat,
                       label: block_cdXat_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXat: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call wait_sdWpM_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 wait_sdWpM_entry() //  [R1]
         { info_tbl: [(cdXaz,
                       label: wait_sdWpM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXaz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXaD; else goto cdXaC;
       cdXaD: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXaC: // global
           _sdWou::P64 = P64[R1 + 7];
           _sdWpL::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWpR_info;
           P64[Hp - 8] = _sdWpL::P64;
           P64[Hp] = R1;
           R2 = Hp - 14;
           R1 = _sdWou::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.runInUnboundThread1_entry() //  [R2]
         { info_tbl: [(cdXaH,
                       label: Control.Concurrent.runInUnboundThread1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXaH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdXaI; else goto cdXaJ;
       cdXaI: // global
           R2 = R2;
           R1 = Control.Concurrent.runInUnboundThread1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXaJ: // global
           I64[Sp - 16] = block_cdX6N_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_isCurrentThreadBound#() args: 8, res: 8, upd: 8;
     }
 },
 _cdX6N() //  [R1]
         { info_tbl: [(cdX6N,
                       label: block_cdX6N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX6N: // global
           if (R1 == 0) goto cdXaG; else goto cdXaF;
       cdXaG: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       cdXaF: // global
           I64[Sp] = block_cdX6R_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdX6R() //  [R1]
         { info_tbl: [(cdX6R,
                       label: block_cdX6R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX6R: // global
           I64[Sp - 8] = block_cdX6T_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdX6T() //  [R1]
         { info_tbl: [(cdX6T,
                       label: block_cdX6T_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX6T: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdXaO; else goto cdXaN;
       cdXaO: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXaN: // global
           I64[Hp - 40] = lvl13_sdWou_info;
           _sdWoq::P64 = P64[Sp + 8];
           P64[Hp - 32] = _sdWoq::P64;
           _sdWoi::P64 = P64[Sp + 16];
           _cdX6V::P64 = Hp - 39;
           if (R1 == 0) goto cdXb9; else goto udXbv;
       cdXb9: // global
           I64[Hp - 24] = sat_sdWpu_info;
           P64[Hp - 16] = _sdWoi::P64;
           P64[Hp - 8] = _sdWoq::P64;
           P64[Hp] = _cdX6V::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       udXbv: // global
           if (R1 == 1) goto cdXbd; else goto cdXaT;
       cdXbd: // global
           I64[Hp - 24] = sat_sdWpI_info;
           P64[Hp - 16] = _sdWoi::P64;
           P64[Hp - 8] = _sdWoq::P64;
           _cdX9D::P64 = Hp - 23;
           Hp = Hp - 8;
           I64[Sp + 8] = block_cdXah_info;
           R1 = _cdX9D::P64;
           P64[Sp + 16] = _cdX6V::P64;
           Sp = Sp + 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
       cdXaT: // global
           I64[Hp - 24] = sat_sdWoK_info;
           P64[Hp - 16] = _sdWoi::P64;
           P64[Hp - 8] = _sdWoq::P64;
           _cdX75::P64 = Hp - 23;
           Hp = Hp - 8;
           I64[Sp + 8] = block_cdX7J_info;
           R1 = _cdX75::P64;
           P64[Sp + 16] = _cdX6V::P64;
           Sp = Sp + 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXah() //  [R1]
         { info_tbl: [(cdXah,
                       label: block_cdXah_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXah: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXbg; else goto cdXbf;
       cdXbg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXbf: // global
           I64[Hp - 16] = wait_sdWpM_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cdXba_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call wait_sdWpM_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXba() //  [R1]
         { info_tbl: [(cdXba,
                       label: block_cdXba_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXba: // global
           I64[Sp] = block_cdXbc_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udXbx; else goto cdXbi;
       udXbx: // global
           call _cdXbc(R1) args: 0, res: 0, upd: 0;
       cdXbi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXbc() //  [R1]
         { info_tbl: [(cdXbc,
                       label: block_cdXbc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXbc: // global
           if (R1 & 7 == 1) goto cdXbo; else goto cdXbs;
       cdXbo: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXbs: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdX7J() //  [R1]
         { info_tbl: [(cdX7J,
                       label: block_cdX7J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdX7J: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXaW; else goto cdXaV;
       cdXaW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXaV: // global
           I64[Hp - 16] = wait_sdWoO_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cdXaP_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call wait_sdWoO_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXaP() //  [R1]
         { info_tbl: [(cdXaP,
                       label: block_cdXaP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXaP: // global
           I64[Sp] = block_cdXaR_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udXbw; else goto cdXaY;
       udXbw: // global
           call _cdXaR(R1) args: 0, res: 0, upd: 0;
       cdXaY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXaR() //  [R1]
         { info_tbl: [(cdXaR,
                       label: block_cdXaR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXaR: // global
           if (R1 & 7 == 1) goto cdXb4; else goto cdXb8;
       cdXb4: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXb8: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.550717249 UTC

[section ""data" . Control.Concurrent.runInUnboundThread_closure" {
     Control.Concurrent.runInUnboundThread_closure:
         const Control.Concurrent.runInUnboundThread_info;
         const 0;
 },
 Control.Concurrent.runInUnboundThread_entry() //  [R2]
         { info_tbl: [(cdXeb,
                       label: Control.Concurrent.runInUnboundThread_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXeb: // global
           R2 = R2;
           call Control.Concurrent.runInUnboundThread1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.554441334 UTC

[section ""cstring" . lvl_rdWnQ_bytes" {
     lvl_rdWnQ_bytes:
         I8[] [82,84,83,32,100,111,101,115,110,39,116,32,115,117,112,112,111,114,116,32,109,117,108,116,105,112,108,101,32,79,83,32,116,104,114,101,97,100,115,32,40,117,115,101,32,103,104,99,32,45,116,104,114,101,97,100,101,100,32,119,104,101,110,32,108,105,110,107,105,110,103,41]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.556614875 UTC

[section ""data" . Control.Concurrent.forkOS2_closure" {
     Control.Concurrent.forkOS2_closure:
         const Control.Concurrent.forkOS2_info;
         const 0;
 },
 Control.Concurrent.forkOS2_entry() //  []
         { info_tbl: [(cdXep,
                       label: Control.Concurrent.forkOS2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXep: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXeq; else goto cdXer;
       cdXeq: // global
           R1 = Control.Concurrent.forkOS2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXer: // global
           I64[Sp - 8] = block_cdXen_info;
           R2 = lvl_rdWnQ_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdXen() //  [R1]
         { info_tbl: [(cdXen,
                       label: block_cdXen_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXen: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.563742021 UTC

[section ""cstring" . lvl1_rdWnR_bytes" {
     lvl1_rdWnR_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.56593794 UTC

[section ""data" . lvl2_rdWnS_closure" {
     lvl2_rdWnS_closure:
         const lvl2_rdWnS_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rdWnS_entry() //  [R1]
         { info_tbl: [(cdXeK,
                       label: lvl2_rdWnS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXeK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXeL; else goto cdXeM;
       cdXeL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXeM: // global
           (_cdXeH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXeH::I64 == 0) goto cdXeJ; else goto cdXeI;
       cdXeJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXeI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXeH::I64;
           R2 = lvl1_rdWnR_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.571495253 UTC

[section ""data" . lvl3_rdWnT_closure" {
     lvl3_rdWnT_closure:
         const lvl3_rdWnT_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rdWnT_entry() //  [R1]
         { info_tbl: [(cdXf0,
                       label: lvl3_rdWnT_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXf0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXf1; else goto cdXf2;
       cdXf1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXf2: // global
           (_cdXeX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXeX::I64 == 0) goto cdXeZ; else goto cdXeY;
       cdXeZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXeY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXeX::I64;
           R2 = Control.Concurrent.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.57623787 UTC

[section ""data" . lvl4_rdWnU_closure" {
     lvl4_rdWnU_closure:
         const lvl4_rdWnU_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rdWnU_entry() //  [R1]
         { info_tbl: [(cdXfg,
                       label: lvl4_rdWnU_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXfg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXfh; else goto cdXfi;
       cdXfh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXfi: // global
           (_cdXfd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXfd::I64 == 0) goto cdXff; else goto cdXfe;
       cdXff: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXfe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXfd::I64;
           R2 = Control.Concurrent.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.582191758 UTC

[section ""cstring" . lvl5_rdWnV_bytes" {
     lvl5_rdWnV_bytes:
         I8[] [46,47,67,111,110,116,114,111,108,47,67,111,110,99,117,114,114,101,110,116,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.584891886 UTC

[section ""data" . lvl6_rdWnW_closure" {
     lvl6_rdWnW_closure:
         const lvl6_rdWnW_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rdWnW_entry() //  [R1]
         { info_tbl: [(cdXfx,
                       label: lvl6_rdWnW_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXfx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXfy; else goto cdXfz;
       cdXfy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXfz: // global
           (_cdXfu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXfu::I64 == 0) goto cdXfw; else goto cdXfv;
       cdXfw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXfv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXfu::I64;
           R2 = lvl5_rdWnV_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.589404914 UTC

[section ""data" . lvl7_rdWnX_closure" {
     lvl7_rdWnX_closure:
         const GHC.Types.I#_con_info;
         const 353;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.591186394 UTC

[section ""data" . lvl8_rdWnY_closure" {
     lvl8_rdWnY_closure:
         const GHC.Types.I#_con_info;
         const 33;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.592983098 UTC

[section ""data" . lvl9_rdWnZ_closure" {
     lvl9_rdWnZ_closure:
         const GHC.Types.I#_con_info;
         const 42;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.595138687 UTC

[section ""data" . lvl10_rdWo0_closure" {
     lvl10_rdWo0_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_rdWnT_closure;
         const lvl4_rdWnU_closure;
         const lvl6_rdWnW_closure;
         const lvl7_rdWnX_closure+1;
         const lvl8_rdWnY_closure+1;
         const lvl7_rdWnX_closure+1;
         const lvl9_rdWnZ_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.597144416 UTC

[section ""data" . lvl11_rdWo1_closure" {
     lvl11_rdWo1_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_rdWnS_closure;
         const lvl10_rdWo0_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.599947499 UTC

[section ""data" . Control.Concurrent.runInBoundThread2_closure" {
     Control.Concurrent.runInBoundThread2_closure:
         const Control.Concurrent.runInBoundThread2_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Concurrent.runInBoundThread2_entry() //  [R1]
         { info_tbl: [(cdXfS,
                       label: Control.Concurrent.runInBoundThread2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXfS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXfT; else goto cdXfU;
       cdXfT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXfU: // global
           (_cdXfP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXfP::I64 == 0) goto cdXfR; else goto cdXfQ;
       cdXfR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXfQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXfP::I64;
           R2 = lvl11_rdWo1_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.610135378 UTC

[section ""data" . Control.Concurrent.runInBoundThread1_closure" {
     Control.Concurrent.runInBoundThread1_closure:
         const Control.Concurrent.runInBoundThread1_info;
         const 0;
 },
 sat_sdWqo_entry() //  [R1]
         { info_tbl: [(cdXgx,
                       label: sat_sdWqo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXgx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXgy; else goto cdXgz;
       cdXgy: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXgz: // global
           I64[Sp - 8] = block_cdXgu_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXgu() //  [R1]
         { info_tbl: [(cdXgu,
                       label: block_cdXgu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXgu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXgC; else goto cdXgB;
       cdXgC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXgB: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWqt_entry() //  [R1]
         { info_tbl: [(cdXgI,
                       label: sat_sdWqt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXgI: // global
           _sdWqt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXgJ; else goto cdXgK;
       cdXgK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXgM; else goto cdXgL;
       cdXgM: // global
           HpAlloc = 16;
           goto cdXgJ;
       cdXgJ: // global
           R1 = _sdWqt::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXgL: // global
           _sdWq0::P64 = P64[_sdWqt::P64 + 7];
           _sdWqd::P64 = P64[_sdWqt::P64 + 15];
           I64[Hp - 8] = sat_sdWqo_info;
           P64[Hp] = _sdWq0::P64;
           I64[Sp - 16] = block_cdXgD_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWqd::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXgD() //  [R1]
         { info_tbl: [(cdXgD,
                       label: block_cdXgD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXgD: // global
           _sdWqd::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sdWqd::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sdWqd::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWqI_entry() //  [R1, R2]
         { info_tbl: [(cdXgX,
                       label: sat_sdWqI_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXgX: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[R1 + 6]);
           R1 = R2;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWqB_entry() //  [R1]
         { info_tbl: [(cdXha,
                       label: sat_sdWqB_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXha: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXhb; else goto cdXhc;
       cdXhb: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXhc: // global
           I64[Sp - 16] = block_cdXh7_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           _cdXh6::I64 = I64[R1 + 15];
           _udXhg::P64 = CurrentTSO;
           I64[I64[_udXhg::P64 + 24] + 16] = Sp;
           _udXhh::I64 = CurrentNursery;
           P64[_udXhh::I64 + 8] = Hp + 8;
           I64[_udXhg::P64 + 104] = I64[_udXhg::P64 + 104] - ((Hp + 8) - I64[_udXhh::I64]);
           (_udXhe::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] forkOS_entry(_cdXh6::I64);
           (_udXhf::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udXhe::I64);
           BaseReg = _udXhf::I64;
           _udXhi::P64 = CurrentTSO;
           _udXhj::P64 = I64[_udXhi::P64 + 24];
           Sp = I64[_udXhj::P64 + 16];
           SpLim = _udXhj::P64 + 192;
           HpAlloc = 0;
           _udXhk::I64 = CurrentNursery;
           _udXhl::I64 = I64[_udXhk::I64 + 8];
           Hp = _udXhl::I64 - 8;
           _udXhm::I64 = I64[_udXhk::I64];
           HpLim = _udXhm::I64 + ((%MO_SS_Conv_W32_W64(I32[_udXhk::I64 + 48]) << 12) - 1);
           I64[_udXhi::P64 + 104] = I64[_udXhi::P64 + 104] + (_udXhl::I64 - _udXhm::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdXh7() //  []
         { info_tbl: [(cdXh7,
                       label: block_cdXh7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXh7: // global
           R1 = P64[P64[Sp + 8] + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWqC_entry() //  [R1]
         { info_tbl: [(cdXht,
                       label: sat_sdWqC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXht: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWqZ_entry() //  [R1]
         { info_tbl: [(cdXhP,
                       label: sat_sdWqZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXhP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXhQ; else goto cdXhR;
       cdXhQ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXhR: // global
           I64[Sp - 8] = block_cdXhM_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXhM() //  [R1]
         { info_tbl: [(cdXhM,
                       label: block_cdXhM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXhM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXhU; else goto cdXhT;
       cdXhU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXhT: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWr4_entry() //  [R1]
         { info_tbl: [(cdXi0,
                       label: sat_sdWr4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXi0: // global
           _sdWr4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXi1; else goto cdXi2;
       cdXi2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXi4; else goto cdXi3;
       cdXi4: // global
           HpAlloc = 16;
           goto cdXi1;
       cdXi1: // global
           R1 = _sdWr4::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXi3: // global
           _sdWq0::P64 = P64[_sdWr4::P64 + 7];
           _sdWqd::P64 = P64[_sdWr4::P64 + 15];
           I64[Hp - 8] = sat_sdWqZ_info;
           P64[Hp] = _sdWq0::P64;
           I64[Sp - 16] = block_cdXhV_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWqd::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXhV() //  [R1]
         { info_tbl: [(cdXhV,
                       label: block_cdXhV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXhV: // global
           _sdWqd::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sdWqd::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sdWqd::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrj_entry() //  [R1, R2]
         { info_tbl: [(cdXif,
                       label: sat_sdWrj_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXif: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[R1 + 6]);
           R1 = R2;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrc_entry() //  [R1]
         { info_tbl: [(cdXis,
                       label: sat_sdWrc_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXis: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXit; else goto cdXiu;
       cdXit: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXiu: // global
           I64[Sp - 16] = block_cdXip_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           _cdXio::I64 = I64[R1 + 15];
           _udXiy::P64 = CurrentTSO;
           I64[I64[_udXiy::P64 + 24] + 16] = Sp;
           _udXiz::I64 = CurrentNursery;
           P64[_udXiz::I64 + 8] = Hp + 8;
           I64[_udXiy::P64 + 104] = I64[_udXiy::P64 + 104] - ((Hp + 8) - I64[_udXiz::I64]);
           (_udXiw::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] forkOS_entry(_cdXio::I64);
           (_udXix::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udXiw::I64);
           BaseReg = _udXix::I64;
           _udXiA::P64 = CurrentTSO;
           _udXiB::P64 = I64[_udXiA::P64 + 24];
           Sp = I64[_udXiB::P64 + 16];
           SpLim = _udXiB::P64 + 192;
           HpAlloc = 0;
           _udXiC::I64 = CurrentNursery;
           _udXiD::I64 = I64[_udXiC::I64 + 8];
           Hp = _udXiD::I64 - 8;
           _udXiE::I64 = I64[_udXiC::I64];
           HpLim = _udXiE::I64 + ((%MO_SS_Conv_W32_W64(I32[_udXiC::I64 + 48]) << 12) - 1);
           I64[_udXiA::P64 + 104] = I64[_udXiA::P64 + 104] + (_udXiD::I64 - _udXiE::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdXip() //  []
         { info_tbl: [(cdXip,
                       label: block_cdXip_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXip: // global
           R1 = P64[P64[Sp + 8] + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrd_entry() //  [R1]
         { info_tbl: [(cdXiL,
                       label: sat_sdWrd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXiL: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrq_entry() //  [R1]
         { info_tbl: [(cdXiS,
                       label: sat_sdWrq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXiS: // global
           _sdWrq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXiT; else goto cdXiU;
       cdXiU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXiW; else goto cdXiV;
       cdXiW: // global
           HpAlloc = 24;
           goto cdXiT;
       cdXiT: // global
           R1 = _sdWrq::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXiV: // global
           _sdWq0::P64 = P64[_sdWrq::P64 + 7];
           _sdWqd::P64 = P64[_sdWrq::P64 + 15];
           I64[Hp - 16] = sat_sdWr4_info;
           P64[Hp - 8] = _sdWq0::P64;
           P64[Hp] = _sdWqd::P64;
           I64[Sp - 16] = block_cdXi6_info;
           R1 = Hp - 15;
           P64[Sp - 8] = _sdWqd::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXi6() //  [R1]
         { info_tbl: [(cdXi6,
                       label: block_cdXi6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXi6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdXiZ; else goto cdXiY;
       cdXiZ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXiY: // global
           I64[Hp - 48] = sat_sdWrj_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdWrc_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdWrd_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cdXiO_info;
           R2 = Hp - 46;
           _sdWr7::I64 = R1;
           R1 = Hp - 7;
           I64[Sp + 8] = _sdWr7::I64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXiO() //  [R1]
         { info_tbl: [(cdXiO,
                       label: block_cdXiO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXiO: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrD_entry() //  [R1]
         { info_tbl: [(cdXjf,
                       label: sat_sdWrD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXjf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXjg; else goto cdXjh;
       cdXjg: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXjh: // global
           I64[Sp - 8] = block_cdXjc_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXjc() //  [R1]
         { info_tbl: [(cdXjc,
                       label: block_cdXjc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXjc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXjk; else goto cdXjj;
       cdXjk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXjj: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrI_entry() //  [R1]
         { info_tbl: [(cdXjq,
                       label: sat_sdWrI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXjq: // global
           _sdWrI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXjr; else goto cdXjs;
       cdXjs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXju; else goto cdXjt;
       cdXju: // global
           HpAlloc = 16;
           goto cdXjr;
       cdXjr: // global
           R1 = _sdWrI::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXjt: // global
           _sdWq0::P64 = P64[_sdWrI::P64 + 7];
           _sdWqd::P64 = P64[_sdWrI::P64 + 15];
           I64[Hp - 8] = sat_sdWrD_info;
           P64[Hp] = _sdWq0::P64;
           I64[Sp - 16] = block_cdXjl_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWqd::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXjl() //  [R1]
         { info_tbl: [(cdXjl,
                       label: block_cdXjl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXjl: // global
           _sdWqd::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sdWqd::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sdWqd::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrX_entry() //  [R1, R2]
         { info_tbl: [(cdXjF,
                       label: sat_sdWrX_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXjF: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[R1 + 6]);
           R1 = R2;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrQ_entry() //  [R1]
         { info_tbl: [(cdXjS,
                       label: sat_sdWrQ_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXjS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXjT; else goto cdXjU;
       cdXjT: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXjU: // global
           I64[Sp - 16] = block_cdXjP_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           _cdXjO::I64 = I64[R1 + 15];
           _udXjY::P64 = CurrentTSO;
           I64[I64[_udXjY::P64 + 24] + 16] = Sp;
           _udXjZ::I64 = CurrentNursery;
           P64[_udXjZ::I64 + 8] = Hp + 8;
           I64[_udXjY::P64 + 104] = I64[_udXjY::P64 + 104] - ((Hp + 8) - I64[_udXjZ::I64]);
           (_udXjW::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] forkOS_entry(_cdXjO::I64);
           (_udXjX::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udXjW::I64);
           BaseReg = _udXjX::I64;
           _udXk0::P64 = CurrentTSO;
           _udXk1::P64 = I64[_udXk0::P64 + 24];
           Sp = I64[_udXk1::P64 + 16];
           SpLim = _udXk1::P64 + 192;
           HpAlloc = 0;
           _udXk2::I64 = CurrentNursery;
           _udXk3::I64 = I64[_udXk2::I64 + 8];
           Hp = _udXk3::I64 - 8;
           _udXk4::I64 = I64[_udXk2::I64];
           HpLim = _udXk4::I64 + ((%MO_SS_Conv_W32_W64(I32[_udXk2::I64 + 48]) << 12) - 1);
           I64[_udXk0::P64 + 104] = I64[_udXk0::P64 + 104] + (_udXk3::I64 - _udXk4::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdXjP() //  []
         { info_tbl: [(cdXjP,
                       label: block_cdXjP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXjP: // global
           R1 = P64[P64[Sp + 8] + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWrR_entry() //  [R1]
         { info_tbl: [(cdXkb,
                       label: sat_sdWrR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXkb: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.runInBoundThread1_entry() //  [R2]
         { info_tbl: [(cdXkh,
                       label: Control.Concurrent.runInBoundThread1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXkh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdXki; else goto cdXkj;
       cdXki: // global
           R2 = R2;
           R1 = Control.Concurrent.runInBoundThread1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXkj: // global
           (_sdWq5::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sdWq5::I64 == 0) goto cdXkg; else goto cdXkf;
       cdXkg: // global
           call Control.Concurrent.forkOS2_entry() args: 8, res: 0, upd: 8;
       cdXkf: // global
           I64[Sp - 16] = block_cdXg9_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_isCurrentThreadBound#() args: 8, res: 8, upd: 8;
     }
 },
 _cdXg9() //  [R1]
         { info_tbl: [(cdXg9,
                       label: block_cdXg9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXg9: // global
           if (R1 == 0) goto cdXkn; else goto cdXkm;
       cdXkn: // global
           I64[Sp] = block_cdXge_info;
           R1 = Control.Concurrent.runInBoundThread2_closure;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cdXkm: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdXge() //  [R1]
         { info_tbl: [(cdXge,
                       label: block_cdXge_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXge: // global
           I64[Sp - 8] = block_cdXgg_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdXgg() //  [R1]
         { info_tbl: [(cdXgg,
                       label: block_cdXgg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXgg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXkr; else goto cdXkq;
       cdXkr: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXkq: // global
           _sdWq0::P64 = P64[Sp + 16];
           _sdWqd::P64 = P64[Sp + 8];
           if (R1 == 0) goto cdXkR; else goto udXls;
       cdXkR: // global
           I64[Hp - 16] = sat_sdWrq_info;
           P64[Hp - 8] = _sdWq0::P64;
           P64[Hp] = _sdWqd::P64;
           I64[Sp + 16] = block_cdXkO_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
       udXls: // global
           if (R1 == 1) goto cdXl9; else goto cdXky;
       cdXl9: // global
           I64[Hp - 16] = sat_sdWrI_info;
           P64[Hp - 8] = _sdWq0::P64;
           P64[Hp] = _sdWqd::P64;
           I64[Sp] = block_cdXjw_info;
           R1 = Hp - 15;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
       cdXky: // global
           I64[Hp - 16] = sat_sdWqt_info;
           P64[Hp - 8] = _sdWq0::P64;
           P64[Hp] = _sdWqd::P64;
           I64[Sp] = block_cdXgO_info;
           R1 = Hp - 15;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXkO() //  [R1]
         { info_tbl: [(cdXkO,
                       label: block_cdXkO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXkO: // global
           I64[Sp] = block_cdXkQ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udXlu; else goto cdXkT;
       udXlu: // global
           call _cdXkQ(R1) args: 0, res: 0, upd: 0;
       cdXkT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXkQ() //  [R1]
         { info_tbl: [(cdXkQ,
                       label: block_cdXkQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXkQ: // global
           if (R1 & 7 == 1) goto cdXkZ; else goto cdXl3;
       cdXkZ: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXl3: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdXjw() //  [R1]
         { info_tbl: [(cdXjw,
                       label: block_cdXjw_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXjw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdXlc; else goto cdXlb;
       cdXlc: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXlb: // global
           I64[Hp - 48] = sat_sdWrX_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdWrQ_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdWrR_info;
           P64[Hp] = Hp - 31;
           I64[Sp + 8] = block_cdXl4_info;
           R2 = Hp - 46;
           _sdWrL::I64 = R1;
           R1 = Hp - 7;
           I64[Sp + 16] = _sdWrL::I64;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXl4() //  [R1]
         { info_tbl: [(cdXl4,
                       label: block_cdXl4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXl4: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           I64[Sp + 8] = block_cdXl8_info;
           R1 = R1;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udXlv; else goto cdXle;
       udXlv: // global
           call _cdXl8(R1) args: 0, res: 0, upd: 0;
       cdXle: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXl8() //  [R1]
         { info_tbl: [(cdXl8,
                       label: block_cdXl8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXl8: // global
           if (R1 & 7 == 1) goto cdXlk; else goto cdXlo;
       cdXlk: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXlo: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdXgO() //  [R1]
         { info_tbl: [(cdXgO,
                       label: block_cdXgO_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXgO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdXkB; else goto cdXkA;
       cdXkB: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXkA: // global
           I64[Hp - 48] = sat_sdWqI_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdWqB_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdWqC_info;
           P64[Hp] = Hp - 31;
           I64[Sp + 8] = block_cdXks_info;
           R2 = Hp - 46;
           _sdWqw::I64 = R1;
           R1 = Hp - 7;
           I64[Sp + 16] = _sdWqw::I64;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXks() //  [R1]
         { info_tbl: [(cdXks,
                       label: block_cdXks_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXks: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           I64[Sp + 8] = block_cdXkw_info;
           R1 = R1;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udXlt; else goto cdXkD;
       udXlt: // global
           call _cdXkw(R1) args: 0, res: 0, upd: 0;
       cdXkD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXkw() //  [R1]
         { info_tbl: [(cdXkw,
                       label: block_cdXkw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXkw: // global
           if (R1 & 7 == 1) goto cdXkJ; else goto cdXkN;
       cdXkJ: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXkN: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.706731678 UTC

[section ""data" . Control.Concurrent.runInBoundThread_closure" {
     Control.Concurrent.runInBoundThread_closure:
         const Control.Concurrent.runInBoundThread_info;
         const 0;
 },
 Control.Concurrent.runInBoundThread_entry() //  [R2]
         { info_tbl: [(cdXoZ,
                       label: Control.Concurrent.runInBoundThread_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXoZ: // global
           R2 = R2;
           call Control.Concurrent.runInBoundThread1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.712945929 UTC

[section ""data" . Control.Concurrent.forkFinally1_closure" {
     Control.Concurrent.forkFinally1_closure:
         const Control.Concurrent.forkFinally1_info;
         const 0;
 },
 sat_sdWsl_entry() //  [R1]
         { info_tbl: [(cdXpw,
                       label: sat_sdWsl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXpw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXpx; else goto cdXpy;
       cdXpx: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXpy: // global
           I64[Sp - 8] = block_cdXpt_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXpt() //  [R1]
         { info_tbl: [(cdXpt,
                       label: block_cdXpt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXpt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXpB; else goto cdXpA;
       cdXpB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXpA: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsp_entry() //  [R1]
         { info_tbl: [(cdXpE,
                       label: sat_sdWsp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXpE: // global
           _sdWsp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXpF; else goto cdXpG;
       cdXpG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXpI; else goto cdXpH;
       cdXpI: // global
           HpAlloc = 16;
           goto cdXpF;
       cdXpF: // global
           R1 = _sdWsp::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXpH: // global
           _sdWs7::P64 = P64[_sdWsp::P64 + 7];
           _sdWs8::P64 = P64[_sdWsp::P64 + 15];
           I64[Hp - 8] = sat_sdWsl_info;
           P64[Hp] = _sdWs7::P64;
           I64[Sp - 16] = block_cdXpC_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWs8::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXpC() //  [R1]
         { info_tbl: [(cdXpC,
                       label: block_cdXpC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXpC: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsq_entry() //  [R1]
         { info_tbl: [(cdXpK,
                       label: sat_sdWsq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXpK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXpO; else goto cdXpN;
       cdXpO: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXpN: // global
           _sdWs7::P64 = P64[R1 + 7];
           _sdWs8::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWsp_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsD_entry() //  [R1]
         { info_tbl: [(cdXqd,
                       label: sat_sdWsD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXqd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXqe; else goto cdXqf;
       cdXqe: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXqf: // global
           I64[Sp - 8] = block_cdXqa_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXqa() //  [R1]
         { info_tbl: [(cdXqa,
                       label: block_cdXqa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXqa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXqi; else goto cdXqh;
       cdXqi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXqh: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsH_entry() //  [R1]
         { info_tbl: [(cdXql,
                       label: sat_sdWsH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXql: // global
           _sdWsH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXqm; else goto cdXqn;
       cdXqn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXqp; else goto cdXqo;
       cdXqp: // global
           HpAlloc = 16;
           goto cdXqm;
       cdXqm: // global
           R1 = _sdWsH::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXqo: // global
           _sdWs7::P64 = P64[_sdWsH::P64 + 7];
           _sdWs8::P64 = P64[_sdWsH::P64 + 15];
           I64[Hp - 8] = sat_sdWsD_info;
           P64[Hp] = _sdWs7::P64;
           I64[Sp - 16] = block_cdXqj_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWs8::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXqj() //  [R1]
         { info_tbl: [(cdXqj,
                       label: block_cdXqj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXqj: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsI_entry() //  [R1]
         { info_tbl: [(cdXqr,
                       label: sat_sdWsI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXqr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXqv; else goto cdXqu;
       cdXqv: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXqu: // global
           _sdWs7::P64 = P64[R1 + 7];
           _sdWs8::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWsH_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsN_entry() //  [R1]
         { info_tbl: [(cdXqz,
                       label: sat_sdWsN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXqz: // global
           _sdWsN::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdXqA; else goto cdXqB;
       cdXqB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXqD; else goto cdXqC;
       cdXqD: // global
           HpAlloc = 24;
           goto cdXqA;
       cdXqA: // global
           R1 = _sdWsN::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXqC: // global
           _sdWs7::P64 = P64[_sdWsN::P64 + 7];
           _sdWs8::P64 = P64[_sdWsN::P64 + 15];
           I64[Hp - 16] = sat_sdWsI_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           I64[Sp - 8] = block_cdXqw_info;
           R1 = Hp - 15;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXqw() //  [R1]
         { info_tbl: [(cdXqw,
                       label: block_cdXqw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXqw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXqG; else goto cdXqF;
       cdXqG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXqF: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsV_entry() //  [R1]
         { info_tbl: [(cdXr0,
                       label: sat_sdWsV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXr0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXr1; else goto cdXr2;
       cdXr1: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXr2: // global
           I64[Sp - 8] = block_cdXqX_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXqX() //  [R1]
         { info_tbl: [(cdXqX,
                       label: block_cdXqX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXqX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXr5; else goto cdXr4;
       cdXr5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXr4: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWsZ_entry() //  [R1]
         { info_tbl: [(cdXr8,
                       label: sat_sdWsZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXr8: // global
           _sdWsZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXr9; else goto cdXra;
       cdXra: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXrc; else goto cdXrb;
       cdXrc: // global
           HpAlloc = 16;
           goto cdXr9;
       cdXr9: // global
           R1 = _sdWsZ::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXrb: // global
           _sdWs7::P64 = P64[_sdWsZ::P64 + 7];
           _sdWs8::P64 = P64[_sdWsZ::P64 + 15];
           I64[Hp - 8] = sat_sdWsV_info;
           P64[Hp] = _sdWs7::P64;
           I64[Sp - 16] = block_cdXr6_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdWs8::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXr6() //  [R1]
         { info_tbl: [(cdXr6,
                       label: block_cdXr6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXr6: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWt0_entry() //  [R1]
         { info_tbl: [(cdXre,
                       label: sat_sdWt0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXre: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXri; else goto cdXrh;
       cdXri: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXrh: // global
           _sdWs7::P64 = P64[R1 + 7];
           _sdWs8::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdWsZ_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.forkFinally1_entry() //  [R2, R3]
         { info_tbl: [(cdXrn,
                       label: Control.Concurrent.forkFinally1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXrn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdXro; else goto cdXrp;
       cdXro: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.forkFinally1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdXrp: // global
           I64[Sp - 24] = block_cdXpa_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdXpa() //  [R1]
         { info_tbl: [(cdXpa,
                       label: block_cdXpa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXpa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXrs; else goto cdXrr;
       cdXrs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXrr: // global
           _sdWs7::P64 = P64[Sp + 8];
           _sdWs8::P64 = P64[Sp + 16];
           if (R1 == 0) goto cdXrl; else goto udXrF;
       cdXrl: // global
           I64[Hp - 16] = sat_sdWsN_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       udXrF: // global
           if (R1 == 1) goto cdXrm; else goto cdXrk;
       cdXrm: // global
           I64[Hp - 16] = sat_sdWt0_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           I64[Sp + 16] = block_cdXrz_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
       cdXrk: // global
           I64[Hp - 16] = sat_sdWsq_info;
           P64[Hp - 8] = _sdWs7::P64;
           P64[Hp] = _sdWs8::P64;
           I64[Sp + 16] = block_cdXrt_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXrz() //  [R1]
         { info_tbl: [(cdXrz,
                       label: block_cdXrz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXrz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXrE; else goto cdXrD;
       cdXrE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXrD: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdXrt() //  [R1]
         { info_tbl: [(cdXrt,
                       label: block_cdXrt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXrt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXry; else goto cdXrx;
       cdXry: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXrx: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.764419712 UTC

[section ""data" . Control.Concurrent.forkFinally_closure" {
     Control.Concurrent.forkFinally_closure:
         const Control.Concurrent.forkFinally_info;
         const 0;
 },
 Control.Concurrent.forkFinally_entry() //  [R2, R3]
         { info_tbl: [(cdXt0,
                       label: Control.Concurrent.forkFinally_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXt0: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.forkFinally1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.768043 UTC

[section ""cstring" . lvl12_rdWo2_bytes" {
     lvl12_rdWo2_bytes:
         I8[] [67,97,110,110,111,116,32,99,114,101,97,116,101,32,79,83,32,116,104,114,101,97,100,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.770069837 UTC

[section ""data" . Control.Concurrent.forkOS3_closure" {
     Control.Concurrent.forkOS3_closure:
         const Control.Concurrent.forkOS3_info;
         const 0;
 },
 Control.Concurrent.forkOS3_entry() //  []
         { info_tbl: [(cdXte,
                       label: Control.Concurrent.forkOS3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXte: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXtf; else goto cdXtg;
       cdXtf: // global
           R1 = Control.Concurrent.forkOS3_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXtg: // global
           I64[Sp - 8] = block_cdXtc_info;
           R2 = lvl12_rdWo2_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdXtc() //  [R1]
         { info_tbl: [(cdXtc,
                       label: block_cdXtc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXtc: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.777352782 UTC

[section ""data" . Control.Concurrent.forkOS1_closure" {
     Control.Concurrent.forkOS1_closure:
         const Control.Concurrent.forkOS1_info;
         const 0;
 },
 sat_sdWtr_entry() //  [R1]
         { info_tbl: [(cdXtX,
                       label: sat_sdWtr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXtX: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWts_entry() //  [R1]
         { info_tbl: [(cdXu4,
                       label: sat_sdWts_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXu4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXu8; else goto cdXu7;
       cdXu8: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXu7: // global
           _sdWt7::P64 = P64[R1 + 16];
           _sdWtq::I64 = I64[R1 + 24];
           if (_sdWtq::I64 != 0) goto udXu9; else goto cdXu2;
       udXu9: // global
           if (_sdWtq::I64 != 1) goto cdXu1; else goto cdXu3;
       cdXu1: // global
           Hp = Hp - 16;
           R1 = _sdWt7::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdXu3: // global
           Hp = Hp - 16;
           R2 = _sdWt7::P64;
           R1 = GHC.IO.uninterruptibleMask_1_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cdXu2: // global
           I64[Hp - 8] = sat_sdWtr_info;
           P64[Hp] = _sdWt7::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWtt_entry() //  [R1]
         { info_tbl: [(cdXua,
                       label: sat_sdWtt_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXua: // global
           _sdWtt::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdXub; else goto cdXuc;
       cdXuc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXue; else goto cdXud;
       cdXue: // global
           HpAlloc = 16;
           goto cdXub;
       cdXub: // global
           R1 = _sdWtt::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXud: // global
           _sdWt7::P64 = P64[_sdWtt::P64 + 7];
           _sdWtg::P64 = P64[_sdWtt::P64 + 15];
           _sdWtj::I64 = I64[_sdWtt::P64 + 23];
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           I64[Hp] = CurrentTSO;
           I64[Sp - 24] = block_cdXtJ_info;
           R2 = Hp - 7;
           R1 = _sdWtg::P64;
           P64[Sp - 16] = _sdWt7::P64;
           I64[Sp - 8] = _sdWtj::I64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXtJ() //  []
         { info_tbl: [(cdXtJ,
                       label: block_cdXtJ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXtJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdXuh; else goto cdXug;
       cdXuh: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdXug: // global
           I64[Hp - 24] = sat_sdWts_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R2 = GHC.Conc.Sync.childHandler1_closure+2;
           R1 = Hp - 24;
           Sp = Sp + 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.forkOS1_entry() //  [R2]
         { info_tbl: [(cdXul,
                       label: Control.Concurrent.forkOS1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXul: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdXum; else goto cdXun;
       cdXum: // global
           R2 = R2;
           R1 = Control.Concurrent.forkOS1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXun: // global
           (_sdWtc::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sdWtc::I64 == 0) goto cdXuk; else goto cdXuj;
       cdXuk: // global
           call Control.Concurrent.forkOS2_entry() args: 8, res: 0, upd: 8;
       cdXuj: // global
           I64[Sp - 16] = block_cdXtz_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdXtz() //  [R1]
         { info_tbl: [(cdXtz,
                       label: block_cdXtz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXtz: // global
           I64[Sp - 8] = block_cdXtB_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdXtB() //  [R1]
         { info_tbl: [(cdXtB,
                       label: block_cdXtB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXtB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdXus; else goto cdXur;
       cdXus: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXur: // global
           I64[Hp - 24] = sat_sdWtt_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = R1;
           I64[Sp] = block_cdXuo_info;
           R1 = Hp - 23;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXuo() //  [R1]
         { info_tbl: [(cdXuo,
                       label: block_cdXuo_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXuo: // global
           I64[Sp] = block_cdXux_info;
           I64[Sp + 16] = R1;
           _udXuW::P64 = CurrentTSO;
           I64[I64[_udXuW::P64 + 24] + 16] = Sp;
           _udXuX::I64 = CurrentNursery;
           P64[_udXuX::I64 + 8] = Hp + 8;
           I64[_udXuW::P64 + 104] = I64[_udXuW::P64 + 104] - ((Hp + 8) - I64[_udXuX::I64]);
           (_udXuU::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sdWtA::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [‘signed’] forkOS_createThread(R1);
           (_udXuV::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udXuU::I64);
           BaseReg = _udXuV::I64;
           _udXuY::P64 = CurrentTSO;
           _udXuZ::P64 = I64[_udXuY::P64 + 24];
           Sp = I64[_udXuZ::P64 + 16];
           SpLim = _udXuZ::P64 + 192;
           HpAlloc = 0;
           _udXv0::I64 = CurrentNursery;
           _udXv1::I64 = I64[_udXv0::I64 + 8];
           Hp = _udXv1::I64 - 8;
           _udXv2::I64 = I64[_udXv0::I64];
           HpLim = _udXv2::I64 + ((%MO_SS_Conv_W32_W64(I32[_udXv0::I64 + 48]) << 12) - 1);
           I64[_udXuY::P64 + 104] = I64[_udXuY::P64 + 104] + (_udXv1::I64 - _udXv2::I64);
           R1 = _sdWtA::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXux() //  [R1]
         { info_tbl: [(cdXux,
                       label: block_cdXux_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXux: // global
           if (%MO_SS_Conv_W64_W32(R1) == 0 :: W32) goto cdXuO; else goto cdXuF;
       cdXuO: // global
           _sdWtg::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdXuN_info;
           R1 = _sdWtg::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdXuF: // global
           Sp = Sp + 24;
           call Control.Concurrent.forkOS3_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cdXuN() //  [R1]
         { info_tbl: [(cdXuN,
                       label: block_cdXuN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXuN: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.801571074 UTC

[section ""data" . Control.Concurrent.forkOS_closure" {
     Control.Concurrent.forkOS_closure:
         const Control.Concurrent.forkOS_info;
         const 0;
 },
 Control.Concurrent.forkOS_entry() //  [R2]
         { info_tbl: [(cdXw1,
                       label: Control.Concurrent.forkOS_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXw1: // global
           R2 = R2;
           call Control.Concurrent.forkOS1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.805499667 UTC

[section ""data" . Control.Concurrent.forkOSWithUnmask1_closure" {
     Control.Concurrent.forkOSWithUnmask1_closure:
         const Control.Concurrent.forkOSWithUnmask1_info;
         const 0;
 },
 sat_sdWtL_entry() //  [R2]
         { info_tbl: [(cdXwl,
                       label: sat_sdWtL_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXwl: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdWtM_entry() //  [R1]
         { info_tbl: [(cdXwo,
                       label: sat_sdWtM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXwo: // global
           _sdWtM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXwp; else goto cdXwq;
       cdXwq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXws; else goto cdXwr;
       cdXws: // global
           HpAlloc = 16;
           goto cdXwp;
       cdXwp: // global
           R1 = _sdWtM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXwr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdWtM::P64;
           _sdWtJ::P64 = P64[_sdWtM::P64 + 16];
           I64[Hp - 8] = sat_sdWtL_info;
           R2 = Hp - 6;
           R1 = _sdWtJ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Concurrent.forkOSWithUnmask1_entry() //  [R2]
         { info_tbl: [(cdXwt,
                       label: Control.Concurrent.forkOSWithUnmask1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXwt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXwx; else goto cdXww;
       cdXwx: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Concurrent.forkOSWithUnmask1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXww: // global
           I64[Hp - 16] = sat_sdWtM_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Concurrent.forkOS1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.813773727 UTC

[section ""data" . Control.Concurrent.forkOSWithUnmask_closure" {
     Control.Concurrent.forkOSWithUnmask_closure:
         const Control.Concurrent.forkOSWithUnmask_info;
         const 0;
 },
 Control.Concurrent.forkOSWithUnmask_entry() //  [R2]
         { info_tbl: [(cdXwN,
                       label: Control.Concurrent.forkOSWithUnmask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXwN: // global
           R2 = R2;
           call Control.Concurrent.forkOSWithUnmask1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.817765258 UTC

[section ""data" . Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_closure" {
     Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_closure:
         const Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_info;
 },
 Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_entry() //  [R2]
         { info_tbl: [(cdXx1,
                       label: Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXx1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXx5; else goto cdXx6;
       cdXx5: // global
           R2 = R2;
           R1 = Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXx6: // global
           I64[Sp - 8] = block_cdXwY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udXxa; else goto cdXwZ;
       udXxa: // global
           call _cdXwY(R1) args: 0, res: 0, upd: 0;
       cdXwZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXwY() //  [R1]
         { info_tbl: [(cdXwY,
                       label: block_cdXwY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXwY: // global
           I64[Sp] = block_cdXx4_info;
           R1 = I64[R1 + 7];
           call stg_deRefStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXx4() //  [R1]
         { info_tbl: [(cdXx4,
                       label: block_cdXx4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXx4: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.825230392 UTC

[section ""data" . Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_closure" {
     Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_closure:
         const Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_info;
 },
 Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_entry() //  [R2]
         { info_tbl: [(cdXxr,
                       label: Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXxr: // global
           R2 = R2;
           call Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:12.828745368 UTC

[section ""relreadonly" . SdWuv_srt" {
     SdWuv_srt:
         const GHC.Conc.IO.threadWaitRead1_closure;
         const GHC.Conc.IO.threadWaitWrite1_closure;
         const GHC.Conc.IO.threadWaitReadSTM1_closure;
         const GHC.Conc.IO.threadWaitWriteSTM1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const Control.Concurrent.runInUnboundThread1_closure;
         const GHC.IO.failIO1_closure;
         const Control.Concurrent.forkOS2_closure;
         const GHC.Err.undefined_closure;
         const lvl11_rdWo1_closure;
         const Control.Concurrent.runInBoundThread1_closure;
         const Control.Concurrent.runInBoundThread2_closure;
         const Control.Concurrent.forkFinally1_closure;
         const Control.Concurrent.forkOS3_closure;
         const GHC.Conc.Sync.childHandler1_closure;
         const Control.Concurrent.forkOS1_closure;
         const Control.Concurrent.forkOSWithUnmask1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:14.900065746 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:14.901706398 UTC

[section ""data" . Control.Concurrent.isCurrentThreadBound1_closure" {
     Control.Concurrent.isCurrentThreadBound1_closure:
         const Control.Concurrent.isCurrentThreadBound1_info;
 },
 sat_sdXxE_entry() //  [R1]
         { info_tbl: [(cdXDD,
                       label: sat_sdXxE_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXDD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXDE; else goto cdXDF;
       cdXDE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXDF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto cdXDC; else goto cdXDB;
       cdXDC: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdXDB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Concurrent.isCurrentThreadBound1_entry() //  []
         { info_tbl: [(cdXDG,
                       label: Control.Concurrent.isCurrentThreadBound1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXDG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXDH; else goto cdXDI;
       cdXDH: // global
           R1 = Control.Concurrent.isCurrentThreadBound1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXDI: // global
           I64[Sp - 8] = block_cdXDt_info;
           Sp = Sp - 8;
           call stg_isCurrentThreadBound#() args: 8, res: 8, upd: 8;
     }
 },
 _cdXDt() //  [R1]
         { info_tbl: [(cdXDt,
                       label: block_cdXDt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXDt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXDL; else goto cdXDK;
       cdXDL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXDK: // global
           I64[Hp - 16] = sat_sdXxE_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:14.909454382 UTC

[section ""data" . Control.Concurrent.isCurrentThreadBound_closure" {
     Control.Concurrent.isCurrentThreadBound_closure:
         const Control.Concurrent.isCurrentThreadBound_info;
 },
 Control.Concurrent.isCurrentThreadBound_entry() //  []
         { info_tbl: [(cdXEa,
                       label: Control.Concurrent.isCurrentThreadBound_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXEa: // global
           call Control.Concurrent.isCurrentThreadBound1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:14.912956134 UTC

[section ""data" . Control.Concurrent.threadWaitRead_closure" {
     Control.Concurrent.threadWaitRead_closure:
         const Control.Concurrent.threadWaitRead_info;
         const 0;
 },
 Control.Concurrent.threadWaitRead_entry() //  [R2]
         { info_tbl: [(cdXEl,
                       label: Control.Concurrent.threadWaitRead_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXEl: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitRead1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:14.916500217 UTC

[section ""data" . Control.Concurrent.threadWaitWrite_closure" {
     Control.Concurrent.threadWaitWrite_closure:
         const Control.Concurrent.threadWaitWrite_info;
         const 0;
 },
 Control.Concurrent.threadWaitWrite_entry() //  [R2]
         { info_tbl: [(cdXEx,
                       label: Control.Concurrent.threadWaitWrite_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXEx: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWrite1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:14.919991202 UTC

[section ""data" . Control.Concurrent.threadWaitReadSTM_closure" {
     Control.Concurrent.threadWaitReadSTM_closure:
         const Control.Concurrent.threadWaitReadSTM_info;
         const 0;
 },
 Control.Concurrent.threadWaitReadSTM_entry() //  [R2]
         { info_tbl: [(cdXEI,
                       label: Control.Concurrent.threadWaitReadSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXEI: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitReadSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:14.923698022 UTC

[section ""data" . Control.Concurrent.threadWaitWriteSTM_closure" {
     Control.Concurrent.threadWaitWriteSTM_closure:
         const Control.Concurrent.threadWaitWriteSTM_info;
         const 0;
 },
 Control.Concurrent.threadWaitWriteSTM_entry() //  [R2]
         { info_tbl: [(cdXET,
                       label: Control.Concurrent.threadWaitWriteSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXET: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWriteSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:14.927083838 UTC

[section ""cstring" . Control.Concurrent.$trModule4_bytes" {
     Control.Concurrent.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:14.930427567 UTC

[section ""data" . Control.Concurrent.$trModule3_closure" {
     Control.Concurrent.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:14.932126032 UTC

[section ""cstring" . Control.Concurrent.$trModule2_bytes" {
     Control.Concurrent.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:14.933780428 UTC

[section ""data" . Control.Concurrent.$trModule1_closure" {
     Control.Concurrent.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:14.935538063 UTC

[section ""data" . Control.Concurrent.$trModule_closure" {
     Control.Concurrent.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.$trModule3_closure+1;
         const Control.Concurrent.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:14.93770552 UTC

[section ""data" . Control.Concurrent.rtsSupportsBoundThreads_closure" {
     Control.Concurrent.rtsSupportsBoundThreads_closure:
         const Control.Concurrent.rtsSupportsBoundThreads_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Concurrent.rtsSupportsBoundThreads_entry() //  [R1]
         { info_tbl: [(cdXFg,
                       label: Control.Concurrent.rtsSupportsBoundThreads_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXFg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXFh; else goto cdXFi;
       cdXFh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXFi: // global
           (_cdXF8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXF8::I64 == 0) goto cdXFa; else goto cdXF9;
       cdXFa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXF9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXF8::I64;
           (_sdXxI::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sdXxI::I64 == 0) goto cdXFf; else goto cdXFe;
       cdXFf: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdXFe: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:14.942765047 UTC

[section ""data" . Control.Concurrent.forkFinally2_closure" {
     Control.Concurrent.forkFinally2_closure:
         const Control.Concurrent.forkFinally2_info;
 },
 Control.Concurrent.forkFinally2_entry() //  [R2]
         { info_tbl: [(cdXFA,
                       label: Control.Concurrent.forkFinally2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXFA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXFE; else goto cdXFD;
       cdXFE: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Control.Concurrent.forkFinally2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXFD: // global
           I64[Hp - 8] = Data.Either.Left_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:14.951696633 UTC

[section ""data" . Control.Concurrent.runInUnboundThread1_closure" {
     Control.Concurrent.runInUnboundThread1_closure:
         const Control.Concurrent.runInUnboundThread1_info;
         const 0;
 },
 lvl13_sdXxZ_entry() //  [R1]
         { info_tbl: [(cdXG2,
                       label: lvl13_sdXxZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXG2: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXy9_entry() //  [R1]
         { info_tbl: [(cdXGp,
                       label: sat_sdXy9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXGp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXGq; else goto cdXGr;
       cdXGq: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXGr: // global
           I64[Sp - 8] = block_cdXGm_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXGm() //  [R1]
         { info_tbl: [(cdXGm,
                       label: block_cdXGm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXGm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXGu; else goto cdXGt;
       cdXGu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXGt: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXye_entry() //  [R1]
         { info_tbl: [(cdXGz,
                       label: sat_sdXye_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXGz: // global
           _sdXye::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXGA; else goto cdXGB;
       cdXGB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXGD; else goto cdXGC;
       cdXGD: // global
           HpAlloc = 16;
           goto cdXGA;
       cdXGA: // global
           R1 = _sdXye::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXGC: // global
           _sdXxN::P64 = P64[_sdXye::P64 + 7];
           _sdXxV::P64 = P64[_sdXye::P64 + 15];
           I64[Hp - 8] = sat_sdXy9_info;
           P64[Hp] = _sdXxN::P64;
           I64[Sp - 16] = block_cdXGv_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdXxV::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXGv() //  [R1]
         { info_tbl: [(cdXGv,
                       label: block_cdXGv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXGv: // global
           _sdXxV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdXGx_info;
           R2 = R1;
           R1 = _sdXxV::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXGx() //  []
         { info_tbl: [(cdXGx,
                       label: block_cdXGx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXGx: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXyf_entry() //  [R1]
         { info_tbl: [(cdXGG,
                       label: sat_sdXyf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXGG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXGK; else goto cdXGJ;
       cdXGK: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXGJ: // global
           _sdXxN::P64 = P64[R1 + 7];
           _sdXxV::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdXye_info;
           P64[Hp - 8] = _sdXxN::P64;
           P64[Hp] = _sdXxV::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXyo_entry() //  [R1, R2]
         { info_tbl: [(cdXGZ,
                       label: sat_sdXyo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXGZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXH0; else goto cdXH1;
       cdXH0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXH1: // global
           I64[Sp - 16] = block_cdXGX_info;
           R2 = R2;
           _sdXyj::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdXyj::P64;
           Sp = Sp - 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXGX() //  []
         { info_tbl: [(cdXGX,
                       label: block_cdXGX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXGX: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call wait_sdXyj_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 wait_sdXyj_entry() //  [R1]
         { info_tbl: [(cdXH3,
                       label: wait_sdXyj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXH3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXH7; else goto cdXH6;
       cdXH7: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXH6: // global
           _sdXxZ::P64 = P64[R1 + 7];
           _sdXyi::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdXyo_info;
           P64[Hp - 8] = _sdXyi::P64;
           P64[Hp] = R1;
           R2 = Hp - 14;
           R1 = _sdXxZ::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXyD_entry() //  [R1]
         { info_tbl: [(cdXHw,
                       label: sat_sdXyD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXHw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXHx; else goto cdXHy;
       cdXHx: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXHy: // global
           I64[Sp - 8] = block_cdXHt_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXHt() //  [R1]
         { info_tbl: [(cdXHt,
                       label: block_cdXHt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXHt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXHB; else goto cdXHA;
       cdXHB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXHA: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXyI_entry() //  [R1]
         { info_tbl: [(cdXHG,
                       label: sat_sdXyI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXHG: // global
           _sdXyI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXHH; else goto cdXHI;
       cdXHI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXHK; else goto cdXHJ;
       cdXHK: // global
           HpAlloc = 16;
           goto cdXHH;
       cdXHH: // global
           R1 = _sdXyI::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXHJ: // global
           _sdXxN::P64 = P64[_sdXyI::P64 + 7];
           _sdXxV::P64 = P64[_sdXyI::P64 + 15];
           I64[Hp - 8] = sat_sdXyD_info;
           P64[Hp] = _sdXxN::P64;
           I64[Sp - 16] = block_cdXHC_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdXxV::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXHC() //  [R1]
         { info_tbl: [(cdXHC,
                       label: block_cdXHC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXHC: // global
           _sdXxV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdXHE_info;
           R2 = R1;
           R1 = _sdXxV::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXHE() //  []
         { info_tbl: [(cdXHE,
                       label: block_cdXHE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXHE: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXyJ_entry() //  [R1]
         { info_tbl: [(cdXHN,
                       label: sat_sdXyJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXHN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXHR; else goto cdXHQ;
       cdXHR: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXHQ: // global
           _sdXxN::P64 = P64[R1 + 7];
           _sdXxV::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdXyI_info;
           P64[Hp - 8] = _sdXxN::P64;
           P64[Hp] = _sdXxV::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXyS_entry() //  [R1, R2]
         { info_tbl: [(cdXI6,
                       label: sat_sdXyS_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXI6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXI7; else goto cdXI8;
       cdXI7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXI8: // global
           I64[Sp - 16] = block_cdXI4_info;
           R2 = R2;
           _sdXyN::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdXyN::P64;
           Sp = Sp - 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXI4() //  []
         { info_tbl: [(cdXI4,
                       label: block_cdXI4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXI4: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call wait_sdXyN_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 wait_sdXyN_entry() //  [R1]
         { info_tbl: [(cdXIa,
                       label: wait_sdXyN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXIa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXIe; else goto cdXId;
       cdXIe: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXId: // global
           _sdXxZ::P64 = P64[R1 + 7];
           _sdXyM::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdXyS_info;
           P64[Hp - 8] = _sdXyM::P64;
           P64[Hp] = R1;
           R2 = Hp - 14;
           R1 = _sdXxZ::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXyZ_entry() //  [R1]
         { info_tbl: [(cdXIo,
                       label: sat_sdXyZ_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXIo: // global
           _sdXyZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXIp; else goto cdXIq;
       cdXIq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXIs; else goto cdXIr;
       cdXIs: // global
           HpAlloc = 24;
           goto cdXIp;
       cdXIp: // global
           R1 = _sdXyZ::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXIr: // global
           _sdXxN::P64 = P64[_sdXyZ::P64 + 7];
           _sdXxV::P64 = P64[_sdXyZ::P64 + 15];
           _sdXxZ::P64 = P64[_sdXyZ::P64 + 23];
           I64[Hp - 16] = sat_sdXyJ_info;
           P64[Hp - 8] = _sdXxN::P64;
           P64[Hp] = _sdXxV::P64;
           I64[Sp - 16] = block_cdXHS_info;
           R1 = Hp - 15;
           P64[Sp - 8] = _sdXxZ::P64;
           Sp = Sp - 16;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXHS() //  [R1]
         { info_tbl: [(cdXHS,
                       label: block_cdXHS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXHS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXIv; else goto cdXIu;
       cdXIv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXIu: // global
           I64[Hp - 16] = wait_sdXyN_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cdXIf_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call wait_sdXyN_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXIf() //  [R1]
         { info_tbl: [(cdXIf,
                       label: block_cdXIf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXIf: // global
           I64[Sp] = block_cdXIh_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udXID; else goto cdXIi;
       udXID: // global
           call _cdXIh(R1) args: 0, res: 0, upd: 0;
       cdXIi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXIh() //  [R1]
         { info_tbl: [(cdXIh,
                       label: block_cdXIh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXIh: // global
           if (R1 & 7 == 1) goto cdXIl; else goto cdXIm;
       cdXIl: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXIm: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXz7_entry() //  [R1]
         { info_tbl: [(cdXIX,
                       label: sat_sdXz7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXIX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXIY; else goto cdXIZ;
       cdXIY: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXIZ: // global
           I64[Sp - 8] = block_cdXIU_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXIU() //  [R1]
         { info_tbl: [(cdXIU,
                       label: block_cdXIU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXIU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXJ2; else goto cdXJ1;
       cdXJ2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXJ1: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXzc_entry() //  [R1]
         { info_tbl: [(cdXJ7,
                       label: sat_sdXzc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXJ7: // global
           _sdXzc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXJ8; else goto cdXJ9;
       cdXJ9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXJb; else goto cdXJa;
       cdXJb: // global
           HpAlloc = 16;
           goto cdXJ8;
       cdXJ8: // global
           R1 = _sdXzc::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXJa: // global
           _sdXxN::P64 = P64[_sdXzc::P64 + 7];
           _sdXxV::P64 = P64[_sdXzc::P64 + 15];
           I64[Hp - 8] = sat_sdXz7_info;
           P64[Hp] = _sdXxN::P64;
           I64[Sp - 16] = block_cdXJ3_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdXxV::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXJ3() //  [R1]
         { info_tbl: [(cdXJ3,
                       label: block_cdXJ3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXJ3: // global
           _sdXxV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdXJ5_info;
           R2 = R1;
           R1 = _sdXxV::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXJ5() //  []
         { info_tbl: [(cdXJ5,
                       label: block_cdXJ5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXJ5: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXzd_entry() //  [R1]
         { info_tbl: [(cdXJe,
                       label: sat_sdXzd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXJe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXJi; else goto cdXJh;
       cdXJi: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXJh: // global
           _sdXxN::P64 = P64[R1 + 7];
           _sdXxV::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdXzc_info;
           P64[Hp - 8] = _sdXxN::P64;
           P64[Hp] = _sdXxV::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXzm_entry() //  [R1, R2]
         { info_tbl: [(cdXJx,
                       label: sat_sdXzm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXJx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXJy; else goto cdXJz;
       cdXJy: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXJz: // global
           I64[Sp - 16] = block_cdXJv_info;
           R2 = R2;
           _sdXzh::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdXzh::P64;
           Sp = Sp - 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXJv() //  []
         { info_tbl: [(cdXJv,
                       label: block_cdXJv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXJv: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call wait_sdXzh_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 wait_sdXzh_entry() //  [R1]
         { info_tbl: [(cdXJB,
                       label: wait_sdXzh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXJB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXJF; else goto cdXJE;
       cdXJF: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXJE: // global
           _sdXxZ::P64 = P64[R1 + 7];
           _sdXzg::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdXzm_info;
           P64[Hp - 8] = _sdXzg::P64;
           P64[Hp] = R1;
           R2 = Hp - 14;
           R1 = _sdXxZ::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.runInUnboundThread1_entry() //  [R2]
         { info_tbl: [(cdXJJ,
                       label: Control.Concurrent.runInUnboundThread1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXJJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdXJK; else goto cdXJL;
       cdXJK: // global
           R2 = R2;
           R1 = Control.Concurrent.runInUnboundThread1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXJL: // global
           I64[Sp - 16] = block_cdXFP_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_isCurrentThreadBound#() args: 8, res: 8, upd: 8;
     }
 },
 _cdXFP() //  [R1]
         { info_tbl: [(cdXFP,
                       label: block_cdXFP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXFP: // global
           if (R1 == 0) goto cdXJI; else goto cdXJH;
       cdXJI: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       cdXJH: // global
           I64[Sp] = block_cdXFT_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdXFT() //  [R1]
         { info_tbl: [(cdXFT,
                       label: block_cdXFT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXFT: // global
           I64[Sp - 8] = block_cdXFV_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdXFV() //  [R1]
         { info_tbl: [(cdXFV,
                       label: block_cdXFV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXFV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdXJQ; else goto cdXJP;
       cdXJQ: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXJP: // global
           I64[Hp - 40] = lvl13_sdXxZ_info;
           _sdXxV::P64 = P64[Sp + 8];
           P64[Hp - 32] = _sdXxV::P64;
           _sdXxN::P64 = P64[Sp + 16];
           _cdXFX::P64 = Hp - 39;
           if (R1 == 0) goto cdXKb; else goto udXKx;
       cdXKb: // global
           I64[Hp - 24] = sat_sdXyZ_info;
           P64[Hp - 16] = _sdXxN::P64;
           P64[Hp - 8] = _sdXxV::P64;
           P64[Hp] = _cdXFX::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       udXKx: // global
           if (R1 == 1) goto cdXKf; else goto cdXJV;
       cdXKf: // global
           I64[Hp - 24] = sat_sdXzd_info;
           P64[Hp - 16] = _sdXxN::P64;
           P64[Hp - 8] = _sdXxV::P64;
           _cdXIF::P64 = Hp - 23;
           Hp = Hp - 8;
           I64[Sp + 8] = block_cdXJj_info;
           R1 = _cdXIF::P64;
           P64[Sp + 16] = _cdXFX::P64;
           Sp = Sp + 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
       cdXJV: // global
           I64[Hp - 24] = sat_sdXyf_info;
           P64[Hp - 16] = _sdXxN::P64;
           P64[Hp - 8] = _sdXxV::P64;
           _cdXG7::P64 = Hp - 23;
           Hp = Hp - 8;
           I64[Sp + 8] = block_cdXGL_info;
           R1 = _cdXG7::P64;
           P64[Sp + 16] = _cdXFX::P64;
           Sp = Sp + 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXJj() //  [R1]
         { info_tbl: [(cdXJj,
                       label: block_cdXJj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXJj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXKi; else goto cdXKh;
       cdXKi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXKh: // global
           I64[Hp - 16] = wait_sdXzh_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cdXKc_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call wait_sdXzh_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXKc() //  [R1]
         { info_tbl: [(cdXKc,
                       label: block_cdXKc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXKc: // global
           I64[Sp] = block_cdXKe_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udXKz; else goto cdXKk;
       udXKz: // global
           call _cdXKe(R1) args: 0, res: 0, upd: 0;
       cdXKk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXKe() //  [R1]
         { info_tbl: [(cdXKe,
                       label: block_cdXKe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXKe: // global
           if (R1 & 7 == 1) goto cdXKq; else goto cdXKu;
       cdXKq: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXKu: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdXGL() //  [R1]
         { info_tbl: [(cdXGL,
                       label: block_cdXGL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXGL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXJY; else goto cdXJX;
       cdXJY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXJX: // global
           I64[Hp - 16] = wait_sdXyj_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cdXJR_info;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call wait_sdXyj_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXJR() //  [R1]
         { info_tbl: [(cdXJR,
                       label: block_cdXJR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXJR: // global
           I64[Sp] = block_cdXJT_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udXKy; else goto cdXK0;
       udXKy: // global
           call _cdXJT(R1) args: 0, res: 0, upd: 0;
       cdXK0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXJT() //  [R1]
         { info_tbl: [(cdXJT,
                       label: block_cdXJT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXJT: // global
           if (R1 & 7 == 1) goto cdXK6; else goto cdXKa;
       cdXK6: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXKa: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.029449036 UTC

[section ""data" . Control.Concurrent.runInUnboundThread_closure" {
     Control.Concurrent.runInUnboundThread_closure:
         const Control.Concurrent.runInUnboundThread_info;
         const 0;
 },
 Control.Concurrent.runInUnboundThread_entry() //  [R2]
         { info_tbl: [(cdXO1,
                       label: Control.Concurrent.runInUnboundThread_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXO1: // global
           R2 = R2;
           call Control.Concurrent.runInUnboundThread1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.032670541 UTC

[section ""cstring" . lvl_rdWnQ_bytes" {
     lvl_rdWnQ_bytes:
         I8[] [82,84,83,32,100,111,101,115,110,39,116,32,115,117,112,112,111,114,116,32,109,117,108,116,105,112,108,101,32,79,83,32,116,104,114,101,97,100,115,32,40,117,115,101,32,103,104,99,32,45,116,104,114,101,97,100,101,100,32,119,104,101,110,32,108,105,110,107,105,110,103,41]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.035050496 UTC

[section ""data" . Control.Concurrent.forkOS2_closure" {
     Control.Concurrent.forkOS2_closure:
         const Control.Concurrent.forkOS2_info;
         const 0;
 },
 Control.Concurrent.forkOS2_entry() //  []
         { info_tbl: [(cdXOf,
                       label: Control.Concurrent.forkOS2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXOf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXOg; else goto cdXOh;
       cdXOg: // global
           R1 = Control.Concurrent.forkOS2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXOh: // global
           I64[Sp - 8] = block_cdXOd_info;
           R2 = lvl_rdWnQ_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdXOd() //  [R1]
         { info_tbl: [(cdXOd,
                       label: block_cdXOd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXOd: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.039901244 UTC

[section ""cstring" . lvl1_rdWnR_bytes" {
     lvl1_rdWnR_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.041718127 UTC

[section ""data" . lvl2_rdWnS_closure" {
     lvl2_rdWnS_closure:
         const lvl2_rdWnS_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rdWnS_entry() //  [R1]
         { info_tbl: [(cdXOB,
                       label: lvl2_rdWnS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXOB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXOC; else goto cdXOD;
       cdXOC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXOD: // global
           (_cdXOy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXOy::I64 == 0) goto cdXOA; else goto cdXOz;
       cdXOA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXOz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXOy::I64;
           R2 = lvl1_rdWnR_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.046441353 UTC

[section ""data" . lvl3_rdWnT_closure" {
     lvl3_rdWnT_closure:
         const lvl3_rdWnT_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rdWnT_entry() //  [R1]
         { info_tbl: [(cdXOS,
                       label: lvl3_rdWnT_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXOS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXOT; else goto cdXOU;
       cdXOT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXOU: // global
           (_cdXOP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXOP::I64 == 0) goto cdXOR; else goto cdXOQ;
       cdXOR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXOQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXOP::I64;
           R2 = Control.Concurrent.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.050558095 UTC

[section ""data" . lvl4_rdWnU_closure" {
     lvl4_rdWnU_closure:
         const lvl4_rdWnU_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rdWnU_entry() //  [R1]
         { info_tbl: [(cdXP9,
                       label: lvl4_rdWnU_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXP9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXPa; else goto cdXPb;
       cdXPa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXPb: // global
           (_cdXP6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXP6::I64 == 0) goto cdXP8; else goto cdXP7;
       cdXP8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXP7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXP6::I64;
           R2 = Control.Concurrent.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.055292594 UTC

[section ""cstring" . lvl5_rdWnV_bytes" {
     lvl5_rdWnV_bytes:
         I8[] [46,47,67,111,110,116,114,111,108,47,67,111,110,99,117,114,114,101,110,116,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.057210154 UTC

[section ""data" . lvl6_rdWnW_closure" {
     lvl6_rdWnW_closure:
         const lvl6_rdWnW_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rdWnW_entry() //  [R1]
         { info_tbl: [(cdXPr,
                       label: lvl6_rdWnW_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXPr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXPs; else goto cdXPt;
       cdXPs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXPt: // global
           (_cdXPo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXPo::I64 == 0) goto cdXPq; else goto cdXPp;
       cdXPq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXPp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXPo::I64;
           R2 = lvl5_rdWnV_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.061139181 UTC

[section ""data" . lvl7_rdWnX_closure" {
     lvl7_rdWnX_closure:
         const GHC.Types.I#_con_info;
         const 353;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.062898317 UTC

[section ""data" . lvl8_rdWnY_closure" {
     lvl8_rdWnY_closure:
         const GHC.Types.I#_con_info;
         const 33;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.064587622 UTC

[section ""data" . lvl9_rdWnZ_closure" {
     lvl9_rdWnZ_closure:
         const GHC.Types.I#_con_info;
         const 42;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.06632528 UTC

[section ""data" . lvl10_rdWo0_closure" {
     lvl10_rdWo0_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_rdWnT_closure;
         const lvl4_rdWnU_closure;
         const lvl6_rdWnW_closure;
         const lvl7_rdWnX_closure+1;
         const lvl8_rdWnY_closure+1;
         const lvl7_rdWnX_closure+1;
         const lvl9_rdWnZ_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.068097724 UTC

[section ""data" . lvl11_rdWo1_closure" {
     lvl11_rdWo1_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_rdWnS_closure;
         const lvl10_rdWo0_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.070286562 UTC

[section ""data" . Control.Concurrent.runInBoundThread2_closure" {
     Control.Concurrent.runInBoundThread2_closure:
         const Control.Concurrent.runInBoundThread2_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Concurrent.runInBoundThread2_entry() //  [R1]
         { info_tbl: [(cdXPN,
                       label: Control.Concurrent.runInBoundThread2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXPN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXPO; else goto cdXPP;
       cdXPO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdXPP: // global
           (_cdXPK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdXPK::I64 == 0) goto cdXPM; else goto cdXPL;
       cdXPM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdXPL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdXPK::I64;
           R2 = lvl11_rdWo1_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.080575125 UTC

[section ""data" . Control.Concurrent.runInBoundThread1_closure" {
     Control.Concurrent.runInBoundThread1_closure:
         const Control.Concurrent.runInBoundThread1_info;
         const 0;
 },
 sat_sdXzT_entry() //  [R1]
         { info_tbl: [(cdXQt,
                       label: sat_sdXzT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXQt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXQu; else goto cdXQv;
       cdXQu: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXQv: // global
           I64[Sp - 8] = block_cdXQq_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXQq() //  [R1]
         { info_tbl: [(cdXQq,
                       label: block_cdXQq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXQq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXQy; else goto cdXQx;
       cdXQy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXQx: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXzY_entry() //  [R1]
         { info_tbl: [(cdXQE,
                       label: sat_sdXzY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXQE: // global
           _sdXzY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXQF; else goto cdXQG;
       cdXQG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXQI; else goto cdXQH;
       cdXQI: // global
           HpAlloc = 16;
           goto cdXQF;
       cdXQF: // global
           R1 = _sdXzY::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXQH: // global
           _sdXzv::P64 = P64[_sdXzY::P64 + 7];
           _sdXzI::P64 = P64[_sdXzY::P64 + 15];
           I64[Hp - 8] = sat_sdXzT_info;
           P64[Hp] = _sdXzv::P64;
           I64[Sp - 16] = block_cdXQz_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdXzI::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXQz() //  [R1]
         { info_tbl: [(cdXQz,
                       label: block_cdXQz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXQz: // global
           _sdXzI::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sdXzI::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sdXzI::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXAd_entry() //  [R1, R2]
         { info_tbl: [(cdXQT,
                       label: sat_sdXAd_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXQT: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[R1 + 6]);
           R1 = R2;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXA6_entry() //  [R1]
         { info_tbl: [(cdXR6,
                       label: sat_sdXA6_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXR6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXR7; else goto cdXR8;
       cdXR7: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXR8: // global
           I64[Sp - 16] = block_cdXR3_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           _cdXR2::I64 = I64[R1 + 15];
           _udXRc::P64 = CurrentTSO;
           I64[I64[_udXRc::P64 + 24] + 16] = Sp;
           _udXRd::I64 = CurrentNursery;
           P64[_udXRd::I64 + 8] = Hp + 8;
           I64[_udXRc::P64 + 104] = I64[_udXRc::P64 + 104] - ((Hp + 8) - I64[_udXRd::I64]);
           (_udXRa::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] forkOS_entry(_cdXR2::I64);
           (_udXRb::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udXRa::I64);
           BaseReg = _udXRb::I64;
           _udXRe::P64 = CurrentTSO;
           _udXRf::P64 = I64[_udXRe::P64 + 24];
           Sp = I64[_udXRf::P64 + 16];
           SpLim = _udXRf::P64 + 192;
           HpAlloc = 0;
           _udXRg::I64 = CurrentNursery;
           _udXRh::I64 = I64[_udXRg::I64 + 8];
           Hp = _udXRh::I64 - 8;
           _udXRi::I64 = I64[_udXRg::I64];
           HpLim = _udXRi::I64 + ((%MO_SS_Conv_W32_W64(I32[_udXRg::I64 + 48]) << 12) - 1);
           I64[_udXRe::P64 + 104] = I64[_udXRe::P64 + 104] + (_udXRh::I64 - _udXRi::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdXR3() //  []
         { info_tbl: [(cdXR3,
                       label: block_cdXR3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXR3: // global
           R1 = P64[P64[Sp + 8] + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXA7_entry() //  [R1]
         { info_tbl: [(cdXRp,
                       label: sat_sdXA7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXRp: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXAu_entry() //  [R1]
         { info_tbl: [(cdXRL,
                       label: sat_sdXAu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXRL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXRM; else goto cdXRN;
       cdXRM: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXRN: // global
           I64[Sp - 8] = block_cdXRI_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXRI() //  [R1]
         { info_tbl: [(cdXRI,
                       label: block_cdXRI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXRI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXRQ; else goto cdXRP;
       cdXRQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXRP: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXAz_entry() //  [R1]
         { info_tbl: [(cdXRW,
                       label: sat_sdXAz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXRW: // global
           _sdXAz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXRX; else goto cdXRY;
       cdXRY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXS0; else goto cdXRZ;
       cdXS0: // global
           HpAlloc = 16;
           goto cdXRX;
       cdXRX: // global
           R1 = _sdXAz::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXRZ: // global
           _sdXzv::P64 = P64[_sdXAz::P64 + 7];
           _sdXzI::P64 = P64[_sdXAz::P64 + 15];
           I64[Hp - 8] = sat_sdXAu_info;
           P64[Hp] = _sdXzv::P64;
           I64[Sp - 16] = block_cdXRR_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdXzI::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXRR() //  [R1]
         { info_tbl: [(cdXRR,
                       label: block_cdXRR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXRR: // global
           _sdXzI::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sdXzI::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sdXzI::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXAO_entry() //  [R1, R2]
         { info_tbl: [(cdXSb,
                       label: sat_sdXAO_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXSb: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[R1 + 6]);
           R1 = R2;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXAH_entry() //  [R1]
         { info_tbl: [(cdXSo,
                       label: sat_sdXAH_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXSo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXSp; else goto cdXSq;
       cdXSp: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXSq: // global
           I64[Sp - 16] = block_cdXSl_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           _cdXSk::I64 = I64[R1 + 15];
           _udXSu::P64 = CurrentTSO;
           I64[I64[_udXSu::P64 + 24] + 16] = Sp;
           _udXSv::I64 = CurrentNursery;
           P64[_udXSv::I64 + 8] = Hp + 8;
           I64[_udXSu::P64 + 104] = I64[_udXSu::P64 + 104] - ((Hp + 8) - I64[_udXSv::I64]);
           (_udXSs::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] forkOS_entry(_cdXSk::I64);
           (_udXSt::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udXSs::I64);
           BaseReg = _udXSt::I64;
           _udXSw::P64 = CurrentTSO;
           _udXSx::P64 = I64[_udXSw::P64 + 24];
           Sp = I64[_udXSx::P64 + 16];
           SpLim = _udXSx::P64 + 192;
           HpAlloc = 0;
           _udXSy::I64 = CurrentNursery;
           _udXSz::I64 = I64[_udXSy::I64 + 8];
           Hp = _udXSz::I64 - 8;
           _udXSA::I64 = I64[_udXSy::I64];
           HpLim = _udXSA::I64 + ((%MO_SS_Conv_W32_W64(I32[_udXSy::I64 + 48]) << 12) - 1);
           I64[_udXSw::P64 + 104] = I64[_udXSw::P64 + 104] + (_udXSz::I64 - _udXSA::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdXSl() //  []
         { info_tbl: [(cdXSl,
                       label: block_cdXSl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXSl: // global
           R1 = P64[P64[Sp + 8] + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXAI_entry() //  [R1]
         { info_tbl: [(cdXSH,
                       label: sat_sdXAI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXSH: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXAV_entry() //  [R1]
         { info_tbl: [(cdXSO,
                       label: sat_sdXAV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXSO: // global
           _sdXAV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXSP; else goto cdXSQ;
       cdXSQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXSS; else goto cdXSR;
       cdXSS: // global
           HpAlloc = 24;
           goto cdXSP;
       cdXSP: // global
           R1 = _sdXAV::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXSR: // global
           _sdXzv::P64 = P64[_sdXAV::P64 + 7];
           _sdXzI::P64 = P64[_sdXAV::P64 + 15];
           I64[Hp - 16] = sat_sdXAz_info;
           P64[Hp - 8] = _sdXzv::P64;
           P64[Hp] = _sdXzI::P64;
           I64[Sp - 16] = block_cdXS2_info;
           R1 = Hp - 15;
           P64[Sp - 8] = _sdXzI::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXS2() //  [R1]
         { info_tbl: [(cdXS2,
                       label: block_cdXS2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXS2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdXSV; else goto cdXSU;
       cdXSV: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXSU: // global
           I64[Hp - 48] = sat_sdXAO_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdXAH_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdXAI_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cdXSK_info;
           R2 = Hp - 46;
           _sdXAC::I64 = R1;
           R1 = Hp - 7;
           I64[Sp + 8] = _sdXAC::I64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXSK() //  [R1]
         { info_tbl: [(cdXSK,
                       label: block_cdXSK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXSK: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXB8_entry() //  [R1]
         { info_tbl: [(cdXTb,
                       label: sat_sdXB8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXTb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXTc; else goto cdXTd;
       cdXTc: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXTd: // global
           I64[Sp - 8] = block_cdXT8_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXT8() //  [R1]
         { info_tbl: [(cdXT8,
                       label: block_cdXT8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXT8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXTg; else goto cdXTf;
       cdXTg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdXTf: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXBd_entry() //  [R1]
         { info_tbl: [(cdXTm,
                       label: sat_sdXBd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXTm: // global
           _sdXBd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdXTn; else goto cdXTo;
       cdXTo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdXTq; else goto cdXTp;
       cdXTq: // global
           HpAlloc = 16;
           goto cdXTn;
       cdXTn: // global
           R1 = _sdXBd::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXTp: // global
           _sdXzv::P64 = P64[_sdXBd::P64 + 7];
           _sdXzI::P64 = P64[_sdXBd::P64 + 15];
           I64[Hp - 8] = sat_sdXB8_info;
           P64[Hp] = _sdXzv::P64;
           I64[Sp - 16] = block_cdXTh_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdXzI::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXTh() //  [R1]
         { info_tbl: [(cdXTh,
                       label: block_cdXTh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXTh: // global
           _sdXzI::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sdXzI::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sdXzI::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXBs_entry() //  [R1, R2]
         { info_tbl: [(cdXTB,
                       label: sat_sdXBs_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXTB: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[R1 + 6]);
           R1 = R2;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXBl_entry() //  [R1]
         { info_tbl: [(cdXTO,
                       label: sat_sdXBl_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXTO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdXTP; else goto cdXTQ;
       cdXTP: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdXTQ: // global
           I64[Sp - 16] = block_cdXTL_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           _cdXTK::I64 = I64[R1 + 15];
           _udXTU::P64 = CurrentTSO;
           I64[I64[_udXTU::P64 + 24] + 16] = Sp;
           _udXTV::I64 = CurrentNursery;
           P64[_udXTV::I64 + 8] = Hp + 8;
           I64[_udXTU::P64 + 104] = I64[_udXTU::P64 + 104] - ((Hp + 8) - I64[_udXTV::I64]);
           (_udXTS::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] forkOS_entry(_cdXTK::I64);
           (_udXTT::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udXTS::I64);
           BaseReg = _udXTT::I64;
           _udXTW::P64 = CurrentTSO;
           _udXTX::P64 = I64[_udXTW::P64 + 24];
           Sp = I64[_udXTX::P64 + 16];
           SpLim = _udXTX::P64 + 192;
           HpAlloc = 0;
           _udXTY::I64 = CurrentNursery;
           _udXTZ::I64 = I64[_udXTY::I64 + 8];
           Hp = _udXTZ::I64 - 8;
           _udXU0::I64 = I64[_udXTY::I64];
           HpLim = _udXU0::I64 + ((%MO_SS_Conv_W32_W64(I32[_udXTY::I64 + 48]) << 12) - 1);
           I64[_udXTW::P64 + 104] = I64[_udXTW::P64 + 104] + (_udXTZ::I64 - _udXU0::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdXTL() //  []
         { info_tbl: [(cdXTL,
                       label: block_cdXTL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXTL: // global
           R1 = P64[P64[Sp + 8] + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXBm_entry() //  [R1]
         { info_tbl: [(cdXU7,
                       label: sat_sdXBm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXU7: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.runInBoundThread1_entry() //  [R2]
         { info_tbl: [(cdXUd,
                       label: Control.Concurrent.runInBoundThread1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXUd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdXUe; else goto cdXUf;
       cdXUe: // global
           R2 = R2;
           R1 = Control.Concurrent.runInBoundThread1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXUf: // global
           (_sdXzA::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sdXzA::I64 == 0) goto cdXUc; else goto cdXUb;
       cdXUc: // global
           call Control.Concurrent.forkOS2_entry() args: 8, res: 0, upd: 8;
       cdXUb: // global
           I64[Sp - 16] = block_cdXQ5_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_isCurrentThreadBound#() args: 8, res: 8, upd: 8;
     }
 },
 _cdXQ5() //  [R1]
         { info_tbl: [(cdXQ5,
                       label: block_cdXQ5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXQ5: // global
           if (R1 == 0) goto cdXUj; else goto cdXUi;
       cdXUj: // global
           I64[Sp] = block_cdXQa_info;
           R1 = Control.Concurrent.runInBoundThread2_closure;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cdXUi: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdXQa() //  [R1]
         { info_tbl: [(cdXQa,
                       label: block_cdXQa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXQa: // global
           I64[Sp - 8] = block_cdXQc_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdXQc() //  [R1]
         { info_tbl: [(cdXQc,
                       label: block_cdXQc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXQc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdXUn; else goto cdXUm;
       cdXUn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXUm: // global
           _sdXzv::P64 = P64[Sp + 16];
           _sdXzI::P64 = P64[Sp + 8];
           if (R1 == 0) goto cdXUN; else goto udXVo;
       cdXUN: // global
           I64[Hp - 16] = sat_sdXAV_info;
           P64[Hp - 8] = _sdXzv::P64;
           P64[Hp] = _sdXzI::P64;
           I64[Sp + 16] = block_cdXUK_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
       udXVo: // global
           if (R1 == 1) goto cdXV5; else goto cdXUu;
       cdXV5: // global
           I64[Hp - 16] = sat_sdXBd_info;
           P64[Hp - 8] = _sdXzv::P64;
           P64[Hp] = _sdXzI::P64;
           I64[Sp] = block_cdXTs_info;
           R1 = Hp - 15;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
       cdXUu: // global
           I64[Hp - 16] = sat_sdXzY_info;
           P64[Hp - 8] = _sdXzv::P64;
           P64[Hp] = _sdXzI::P64;
           I64[Sp] = block_cdXQK_info;
           R1 = Hp - 15;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXUK() //  [R1]
         { info_tbl: [(cdXUK,
                       label: block_cdXUK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXUK: // global
           I64[Sp] = block_cdXUM_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udXVq; else goto cdXUP;
       udXVq: // global
           call _cdXUM(R1) args: 0, res: 0, upd: 0;
       cdXUP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXUM() //  [R1]
         { info_tbl: [(cdXUM,
                       label: block_cdXUM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXUM: // global
           if (R1 & 7 == 1) goto cdXUV; else goto cdXUZ;
       cdXUV: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXUZ: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdXTs() //  [R1]
         { info_tbl: [(cdXTs,
                       label: block_cdXTs_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXTs: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdXV8; else goto cdXV7;
       cdXV8: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXV7: // global
           I64[Hp - 48] = sat_sdXBs_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdXBl_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdXBm_info;
           P64[Hp] = Hp - 31;
           I64[Sp + 8] = block_cdXV0_info;
           R2 = Hp - 46;
           _sdXBg::I64 = R1;
           R1 = Hp - 7;
           I64[Sp + 16] = _sdXBg::I64;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXV0() //  [R1]
         { info_tbl: [(cdXV0,
                       label: block_cdXV0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXV0: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           I64[Sp + 8] = block_cdXV4_info;
           R1 = R1;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udXVr; else goto cdXVa;
       udXVr: // global
           call _cdXV4(R1) args: 0, res: 0, upd: 0;
       cdXVa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXV4() //  [R1]
         { info_tbl: [(cdXV4,
                       label: block_cdXV4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXV4: // global
           if (R1 & 7 == 1) goto cdXVg; else goto cdXVk;
       cdXVg: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXVk: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdXQK() //  [R1]
         { info_tbl: [(cdXQK,
                       label: block_cdXQK_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXQK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdXUx; else goto cdXUw;
       cdXUx: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdXUw: // global
           I64[Hp - 48] = sat_sdXAd_info;
           I64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdXA6_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdXA7_info;
           P64[Hp] = Hp - 31;
           I64[Sp + 8] = block_cdXUo_info;
           R2 = Hp - 46;
           _sdXA1::I64 = R1;
           R1 = Hp - 7;
           I64[Sp + 16] = _sdXA1::I64;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXUo() //  [R1]
         { info_tbl: [(cdXUo,
                       label: block_cdXUo_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXUo: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           I64[Sp + 8] = block_cdXUs_info;
           R1 = R1;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udXVp; else goto cdXUz;
       udXVp: // global
           call _cdXUs(R1) args: 0, res: 0, upd: 0;
       cdXUz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXUs() //  [R1]
         { info_tbl: [(cdXUs,
                       label: block_cdXUs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXUs: // global
           if (R1 & 7 == 1) goto cdXUF; else goto cdXUJ;
       cdXUF: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdXUJ: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.15995156 UTC

[section ""data" . Control.Concurrent.runInBoundThread_closure" {
     Control.Concurrent.runInBoundThread_closure:
         const Control.Concurrent.runInBoundThread_info;
         const 0;
 },
 Control.Concurrent.runInBoundThread_entry() //  [R2]
         { info_tbl: [(cdXZD,
                       label: Control.Concurrent.runInBoundThread_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXZD: // global
           R2 = R2;
           call Control.Concurrent.runInBoundThread1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.167366159 UTC

[section ""data" . Control.Concurrent.forkFinally1_closure" {
     Control.Concurrent.forkFinally1_closure:
         const Control.Concurrent.forkFinally1_info;
         const 0;
 },
 sat_sdXBQ_entry() //  [R1]
         { info_tbl: [(cdY0a,
                       label: sat_sdXBQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY0a: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdY0b; else goto cdY0c;
       cdY0b: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY0c: // global
           I64[Sp - 8] = block_cdY07_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdY07() //  [R1]
         { info_tbl: [(cdY07,
                       label: block_cdY07_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY07: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY0f; else goto cdY0e;
       cdY0f: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdY0e: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXBU_entry() //  [R1]
         { info_tbl: [(cdY0i,
                       label: sat_sdXBU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY0i: // global
           _sdXBU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdY0j; else goto cdY0k;
       cdY0k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY0m; else goto cdY0l;
       cdY0m: // global
           HpAlloc = 16;
           goto cdY0j;
       cdY0j: // global
           R1 = _sdXBU::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY0l: // global
           _sdXBC::P64 = P64[_sdXBU::P64 + 7];
           _sdXBD::P64 = P64[_sdXBU::P64 + 15];
           I64[Hp - 8] = sat_sdXBQ_info;
           P64[Hp] = _sdXBC::P64;
           I64[Sp - 16] = block_cdY0g_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdXBD::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdY0g() //  [R1]
         { info_tbl: [(cdY0g,
                       label: block_cdY0g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY0g: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXBV_entry() //  [R1]
         { info_tbl: [(cdY0o,
                       label: sat_sdXBV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY0o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdY0s; else goto cdY0r;
       cdY0s: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY0r: // global
           _sdXBC::P64 = P64[R1 + 7];
           _sdXBD::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdXBU_info;
           P64[Hp - 8] = _sdXBC::P64;
           P64[Hp] = _sdXBD::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXC8_entry() //  [R1]
         { info_tbl: [(cdY0R,
                       label: sat_sdXC8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY0R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdY0S; else goto cdY0T;
       cdY0S: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY0T: // global
           I64[Sp - 8] = block_cdY0O_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdY0O() //  [R1]
         { info_tbl: [(cdY0O,
                       label: block_cdY0O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY0O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY0W; else goto cdY0V;
       cdY0W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdY0V: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXCc_entry() //  [R1]
         { info_tbl: [(cdY0Z,
                       label: sat_sdXCc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY0Z: // global
           _sdXCc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdY10; else goto cdY11;
       cdY11: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY13; else goto cdY12;
       cdY13: // global
           HpAlloc = 16;
           goto cdY10;
       cdY10: // global
           R1 = _sdXCc::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY12: // global
           _sdXBC::P64 = P64[_sdXCc::P64 + 7];
           _sdXBD::P64 = P64[_sdXCc::P64 + 15];
           I64[Hp - 8] = sat_sdXC8_info;
           P64[Hp] = _sdXBC::P64;
           I64[Sp - 16] = block_cdY0X_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdXBD::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdY0X() //  [R1]
         { info_tbl: [(cdY0X,
                       label: block_cdY0X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY0X: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXCd_entry() //  [R1]
         { info_tbl: [(cdY15,
                       label: sat_sdXCd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY15: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdY19; else goto cdY18;
       cdY19: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY18: // global
           _sdXBC::P64 = P64[R1 + 7];
           _sdXBD::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdXCc_info;
           P64[Hp - 8] = _sdXBC::P64;
           P64[Hp] = _sdXBD::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXCi_entry() //  [R1]
         { info_tbl: [(cdY1d,
                       label: sat_sdXCi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY1d: // global
           _sdXCi::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cdY1e; else goto cdY1f;
       cdY1f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdY1h; else goto cdY1g;
       cdY1h: // global
           HpAlloc = 24;
           goto cdY1e;
       cdY1e: // global
           R1 = _sdXCi::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY1g: // global
           _sdXBC::P64 = P64[_sdXCi::P64 + 7];
           _sdXBD::P64 = P64[_sdXCi::P64 + 15];
           I64[Hp - 16] = sat_sdXCd_info;
           P64[Hp - 8] = _sdXBC::P64;
           P64[Hp] = _sdXBD::P64;
           I64[Sp - 8] = block_cdY1a_info;
           R1 = Hp - 15;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdY1a() //  [R1]
         { info_tbl: [(cdY1a,
                       label: block_cdY1a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY1a: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY1k; else goto cdY1j;
       cdY1k: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdY1j: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXCq_entry() //  [R1]
         { info_tbl: [(cdY1E,
                       label: sat_sdXCq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY1E: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdY1F; else goto cdY1G;
       cdY1F: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY1G: // global
           I64[Sp - 8] = block_cdY1B_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdY1B() //  [R1]
         { info_tbl: [(cdY1B,
                       label: block_cdY1B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY1B: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY1J; else goto cdY1I;
       cdY1J: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdY1I: // global
           I64[Hp - 8] = Data.Either.Right_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXCu_entry() //  [R1]
         { info_tbl: [(cdY1M,
                       label: sat_sdXCu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY1M: // global
           _sdXCu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdY1N; else goto cdY1O;
       cdY1O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY1Q; else goto cdY1P;
       cdY1Q: // global
           HpAlloc = 16;
           goto cdY1N;
       cdY1N: // global
           R1 = _sdXCu::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY1P: // global
           _sdXBC::P64 = P64[_sdXCu::P64 + 7];
           _sdXBD::P64 = P64[_sdXCu::P64 + 15];
           I64[Hp - 8] = sat_sdXCq_info;
           P64[Hp] = _sdXBC::P64;
           I64[Sp - 16] = block_cdY1K_info;
           R2 = Control.Concurrent.forkFinally2_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sdXBD::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdY1K() //  [R1]
         { info_tbl: [(cdY1K,
                       label: block_cdY1K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY1K: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXCv_entry() //  [R1]
         { info_tbl: [(cdY1S,
                       label: sat_sdXCv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY1S: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdY1W; else goto cdY1V;
       cdY1W: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY1V: // global
           _sdXBC::P64 = P64[R1 + 7];
           _sdXBD::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sdXCu_info;
           P64[Hp - 8] = _sdXBC::P64;
           P64[Hp] = _sdXBD::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.forkFinally1_entry() //  [R2, R3]
         { info_tbl: [(cdY21,
                       label: Control.Concurrent.forkFinally1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY21: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdY22; else goto cdY23;
       cdY22: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.forkFinally1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdY23: // global
           I64[Sp - 24] = block_cdXZO_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdXZO() //  [R1]
         { info_tbl: [(cdXZO,
                       label: block_cdXZO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXZO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdY26; else goto cdY25;
       cdY26: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdY25: // global
           _sdXBC::P64 = P64[Sp + 8];
           _sdXBD::P64 = P64[Sp + 16];
           if (R1 == 0) goto cdY1Z; else goto udY2j;
       cdY1Z: // global
           I64[Hp - 16] = sat_sdXCi_info;
           P64[Hp - 8] = _sdXBC::P64;
           P64[Hp] = _sdXBD::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       udY2j: // global
           if (R1 == 1) goto cdY20; else goto cdY1Y;
       cdY20: // global
           I64[Hp - 16] = sat_sdXCv_info;
           P64[Hp - 8] = _sdXBC::P64;
           P64[Hp] = _sdXBD::P64;
           I64[Sp + 16] = block_cdY2d_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
       cdY1Y: // global
           I64[Hp - 16] = sat_sdXBV_info;
           P64[Hp - 8] = _sdXBC::P64;
           P64[Hp] = _sdXBD::P64;
           I64[Sp + 16] = block_cdY27_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdY2d() //  [R1]
         { info_tbl: [(cdY2d,
                       label: block_cdY2d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY2d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY2i; else goto cdY2h;
       cdY2i: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdY2h: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdY27() //  [R1]
         { info_tbl: [(cdY27,
                       label: block_cdY27_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY27: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY2c; else goto cdY2b;
       cdY2c: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdY2b: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.211617443 UTC

[section ""data" . Control.Concurrent.forkFinally_closure" {
     Control.Concurrent.forkFinally_closure:
         const Control.Concurrent.forkFinally_info;
         const 0;
 },
 Control.Concurrent.forkFinally_entry() //  [R2, R3]
         { info_tbl: [(cdY47,
                       label: Control.Concurrent.forkFinally_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY47: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.forkFinally1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.21498902 UTC

[section ""cstring" . lvl12_rdWo2_bytes" {
     lvl12_rdWo2_bytes:
         I8[] [67,97,110,110,111,116,32,99,114,101,97,116,101,32,79,83,32,116,104,114,101,97,100,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.216917834 UTC

[section ""data" . Control.Concurrent.forkOS3_closure" {
     Control.Concurrent.forkOS3_closure:
         const Control.Concurrent.forkOS3_info;
         const 0;
 },
 Control.Concurrent.forkOS3_entry() //  []
         { info_tbl: [(cdY4l,
                       label: Control.Concurrent.forkOS3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY4l: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdY4m; else goto cdY4n;
       cdY4m: // global
           R1 = Control.Concurrent.forkOS3_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY4n: // global
           I64[Sp - 8] = block_cdY4j_info;
           R2 = lvl12_rdWo2_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdY4j() //  [R1]
         { info_tbl: [(cdY4j,
                       label: block_cdY4j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY4j: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.223792864 UTC

[section ""data" . Control.Concurrent.forkOS1_closure" {
     Control.Concurrent.forkOS1_closure:
         const Control.Concurrent.forkOS1_info;
         const 0;
 },
 sat_sdXCW_entry() //  [R1]
         { info_tbl: [(cdY55,
                       label: sat_sdXCW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY55: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXCX_entry() //  [R1]
         { info_tbl: [(cdY5c,
                       label: sat_sdXCX_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY5c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY5g; else goto cdY5f;
       cdY5g: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdY5f: // global
           _sdXCC::P64 = P64[R1 + 16];
           _sdXCV::I64 = I64[R1 + 24];
           if (_sdXCV::I64 != 0) goto udY5h; else goto cdY5a;
       udY5h: // global
           if (_sdXCV::I64 != 1) goto cdY59; else goto cdY5b;
       cdY59: // global
           Hp = Hp - 16;
           R1 = _sdXCC::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdY5b: // global
           Hp = Hp - 16;
           R2 = _sdXCC::P64;
           R1 = GHC.IO.uninterruptibleMask_1_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cdY5a: // global
           I64[Hp - 8] = sat_sdXCW_info;
           P64[Hp] = _sdXCC::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXCY_entry() //  [R1]
         { info_tbl: [(cdY5i,
                       label: sat_sdXCY_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY5i: // global
           _sdXCY::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdY5j; else goto cdY5k;
       cdY5k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY5m; else goto cdY5l;
       cdY5m: // global
           HpAlloc = 16;
           goto cdY5j;
       cdY5j: // global
           R1 = _sdXCY::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdY5l: // global
           _sdXCC::P64 = P64[_sdXCY::P64 + 7];
           _sdXCL::P64 = P64[_sdXCY::P64 + 15];
           _sdXCO::I64 = I64[_sdXCY::P64 + 23];
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           I64[Hp] = CurrentTSO;
           I64[Sp - 24] = block_cdY4R_info;
           R2 = Hp - 7;
           R1 = _sdXCL::P64;
           P64[Sp - 16] = _sdXCC::P64;
           I64[Sp - 8] = _sdXCO::I64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdY4R() //  []
         { info_tbl: [(cdY4R,
                       label: block_cdY4R_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY4R: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdY5p; else goto cdY5o;
       cdY5p: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdY5o: // global
           I64[Hp - 24] = sat_sdXCX_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R2 = GHC.Conc.Sync.childHandler1_closure+2;
           R1 = Hp - 24;
           Sp = Sp + 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.forkOS1_entry() //  [R2]
         { info_tbl: [(cdY5t,
                       label: Control.Concurrent.forkOS1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY5t: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdY5u; else goto cdY5v;
       cdY5u: // global
           R2 = R2;
           R1 = Control.Concurrent.forkOS1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdY5v: // global
           (_sdXCH::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_sdXCH::I64 == 0) goto cdY5s; else goto cdY5r;
       cdY5s: // global
           call Control.Concurrent.forkOS2_entry() args: 8, res: 0, upd: 8;
       cdY5r: // global
           I64[Sp - 16] = block_cdY4H_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdY4H() //  [R1]
         { info_tbl: [(cdY4H,
                       label: block_cdY4H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY4H: // global
           I64[Sp - 8] = block_cdY4J_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdY4J() //  [R1]
         { info_tbl: [(cdY4J,
                       label: block_cdY4J_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY4J: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdY5A; else goto cdY5z;
       cdY5A: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdY5z: // global
           I64[Hp - 24] = sat_sdXCY_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = R1;
           I64[Sp] = block_cdY5w_info;
           R1 = Hp - 23;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdY5w() //  [R1]
         { info_tbl: [(cdY5w,
                       label: block_cdY5w_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY5w: // global
           I64[Sp] = block_cdY5F_info;
           I64[Sp + 16] = R1;
           _udY64::P64 = CurrentTSO;
           I64[I64[_udY64::P64 + 24] + 16] = Sp;
           _udY65::I64 = CurrentNursery;
           P64[_udY65::I64 + 8] = Hp + 8;
           I64[_udY64::P64 + 104] = I64[_udY64::P64 + 104] - ((Hp + 8) - I64[_udY65::I64]);
           (_udY62::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_sdXD5::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [‘signed’] forkOS_createThread(R1);
           (_udY63::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udY62::I64);
           BaseReg = _udY63::I64;
           _udY66::P64 = CurrentTSO;
           _udY67::P64 = I64[_udY66::P64 + 24];
           Sp = I64[_udY67::P64 + 16];
           SpLim = _udY67::P64 + 192;
           HpAlloc = 0;
           _udY68::I64 = CurrentNursery;
           _udY69::I64 = I64[_udY68::I64 + 8];
           Hp = _udY69::I64 - 8;
           _udY6a::I64 = I64[_udY68::I64];
           HpLim = _udY6a::I64 + ((%MO_SS_Conv_W32_W64(I32[_udY68::I64 + 48]) << 12) - 1);
           I64[_udY66::P64 + 104] = I64[_udY66::P64 + 104] + (_udY69::I64 - _udY6a::I64);
           R1 = _sdXD5::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdY5F() //  [R1]
         { info_tbl: [(cdY5F,
                       label: block_cdY5F_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY5F: // global
           if (%MO_SS_Conv_W64_W32(R1) == 0 :: W32) goto cdY5W; else goto cdY5N;
       cdY5W: // global
           _sdXCL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdY5V_info;
           R1 = _sdXCL::P64;
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdY5N: // global
           Sp = Sp + 24;
           call Control.Concurrent.forkOS3_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cdY5V() //  [R1]
         { info_tbl: [(cdY5V,
                       label: block_cdY5V_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY5V: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(I64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.246946275 UTC

[section ""data" . Control.Concurrent.forkOS_closure" {
     Control.Concurrent.forkOS_closure:
         const Control.Concurrent.forkOS_info;
         const 0;
 },
 Control.Concurrent.forkOS_entry() //  [R2]
         { info_tbl: [(cdY7l,
                       label: Control.Concurrent.forkOS_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY7l: // global
           R2 = R2;
           call Control.Concurrent.forkOS1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.251378891 UTC

[section ""data" . Control.Concurrent.forkOSWithUnmask1_closure" {
     Control.Concurrent.forkOSWithUnmask1_closure:
         const Control.Concurrent.forkOSWithUnmask1_info;
         const 0;
 },
 sat_sdXDg_entry() //  [R2]
         { info_tbl: [(cdY7F,
                       label: sat_sdXDg_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY7F: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdXDh_entry() //  [R1]
         { info_tbl: [(cdY7I,
                       label: sat_sdXDh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY7I: // global
           _sdXDh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdY7J; else goto cdY7K;
       cdY7K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdY7M; else goto cdY7L;
       cdY7M: // global
           HpAlloc = 16;
           goto cdY7J;
       cdY7J: // global
           R1 = _sdXDh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdY7L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdXDh::P64;
           _sdXDe::P64 = P64[_sdXDh::P64 + 16];
           I64[Hp - 8] = sat_sdXDg_info;
           R2 = Hp - 6;
           R1 = _sdXDe::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Concurrent.forkOSWithUnmask1_entry() //  [R2]
         { info_tbl: [(cdY7N,
                       label: Control.Concurrent.forkOSWithUnmask1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY7N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdY7R; else goto cdY7Q;
       cdY7R: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Concurrent.forkOSWithUnmask1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdY7Q: // global
           I64[Hp - 16] = sat_sdXDh_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Concurrent.forkOS1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.259028582 UTC

[section ""data" . Control.Concurrent.forkOSWithUnmask_closure" {
     Control.Concurrent.forkOSWithUnmask_closure:
         const Control.Concurrent.forkOSWithUnmask_info;
         const 0;
 },
 Control.Concurrent.forkOSWithUnmask_entry() //  [R2]
         { info_tbl: [(cdY8a,
                       label: Control.Concurrent.forkOSWithUnmask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY8a: // global
           R2 = R2;
           call Control.Concurrent.forkOSWithUnmask1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.263099226 UTC

[section ""data" . Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_closure" {
     Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_closure:
         const Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_info;
 },
 Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_entry() //  [R2]
         { info_tbl: [(cdY8o,
                       label: Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY8o: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdY8s; else goto cdY8t;
       cdY8s: // global
           R2 = R2;
           R1 = Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdY8t: // global
           I64[Sp - 8] = block_cdY8l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udY8x; else goto cdY8m;
       udY8x: // global
           call _cdY8l(R1) args: 0, res: 0, upd: 0;
       cdY8m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdY8l() //  [R1]
         { info_tbl: [(cdY8l,
                       label: block_cdY8l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY8l: // global
           I64[Sp] = block_cdY8r_info;
           R1 = I64[R1 + 7];
           call stg_deRefStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdY8r() //  [R1]
         { info_tbl: [(cdY8r,
                       label: block_cdY8r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY8r: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.270186134 UTC

[section ""data" . Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_closure" {
     Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_closure:
         const Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_info;
 },
 Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_entry() //  [R2]
         { info_tbl: [(cdY8Q,
                       label: Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY8Q: // global
           R2 = R2;
           call Control.Concurrent.$fstableZC0ZCbaseZCControlziConcurrentZCforkOSzuentry1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:15.273511993 UTC

[section ""relreadonly" . SdXEo_srt" {
     SdXEo_srt:
         const GHC.Conc.IO.threadWaitRead1_closure;
         const GHC.Conc.IO.threadWaitWrite1_closure;
         const GHC.Conc.IO.threadWaitReadSTM1_closure;
         const GHC.Conc.IO.threadWaitWriteSTM1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const Control.Concurrent.runInUnboundThread1_closure;
         const GHC.IO.failIO1_closure;
         const Control.Concurrent.forkOS2_closure;
         const GHC.Err.undefined_closure;
         const lvl11_rdWo1_closure;
         const Control.Concurrent.runInBoundThread1_closure;
         const Control.Concurrent.runInBoundThread2_closure;
         const Control.Concurrent.forkFinally1_closure;
         const Control.Concurrent.forkOS3_closure;
         const GHC.Conc.Sync.childHandler1_closure;
         const Control.Concurrent.forkOS1_closure;
         const Control.Concurrent.forkOSWithUnmask1_closure;
 }]

