
==================== Output Cmm ====================
2018-03-16 16:05:17.144407872 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:17.145744691 UTC

[section ""data" . Control.Concurrent.MVar.$wswapMVar_closure" {
     Control.Concurrent.MVar.$wswapMVar_closure:
         const Control.Concurrent.MVar.$wswapMVar_info;
 },
 sat_sagkm_entry() //  [R1]
         { info_tbl: [(cagpa,
                       label: sat_sagkm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagpa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagpb; else goto cagpc;
       cagpb: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagpc: // global
           I64[Sp - 24] = block_cagp6_info;
           _sagk6::P64 = P64[R1 + 7];
           _sagk7::P64 = P64[R1 + 15];
           R1 = _sagk6::P64;
           P64[Sp - 16] = _sagk6::P64;
           P64[Sp - 8] = _sagk7::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagp6() //  [R1]
         { info_tbl: [(cagp6,
                       label: block_cagp6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagp6: // global
           _sagk6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagp8_info;
           R2 = P64[Sp + 16];
           _sagkk::P64 = R1;
           R1 = _sagk6::P64;
           P64[Sp + 16] = _sagkk::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagp8() //  []
         { info_tbl: [(cagp8,
                       label: block_cagp8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagp8: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.MVar.$wswapMVar_entry() //  [R2, R3]
         { info_tbl: [(cagpi,
                       label: Control.Concurrent.MVar.$wswapMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagpi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagpj; else goto cagpk;
       cagpj: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.MVar.$wswapMVar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagpk: // global
           I64[Sp - 24] = block_cagoW_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cagoW() //  [R1]
         { info_tbl: [(cagoW,
                       label: block_cagoW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagoW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cagpn; else goto cagpm;
       cagpn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cagpm: // global
           _sagk6::P64 = P64[Sp + 8];
           if (R1 == 0) goto cagph; else goto cagpg;
       cagph: // global
           I64[Hp - 16] = sat_sagkm_info;
           P64[Hp - 8] = _sagk6::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cagpg: // global
           Hp = Hp - 24;
           I64[Sp] = block_cagpo_info;
           R1 = _sagk6::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagpo() //  [R1]
         { info_tbl: [(cagpo,
                       label: block_cagpo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagpo: // global
           _sagk6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagpq_info;
           R2 = P64[Sp + 16];
           _sagkf::P64 = R1;
           R1 = _sagk6::P64;
           P64[Sp + 16] = _sagkf::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagpq() //  []
         { info_tbl: [(cagpq,
                       label: block_cagpq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagpq: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.147932941 UTC

[section ""data" . Control.Concurrent.MVar.swapMVar1_closure" {
     Control.Concurrent.MVar.swapMVar1_closure:
         const Control.Concurrent.MVar.swapMVar1_info;
 },
 Control.Concurrent.MVar.swapMVar1_entry() //  [R2, R3]
         { info_tbl: [(cagpB,
                       label: Control.Concurrent.MVar.swapMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagpB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagpC; else goto cagpD;
       cagpC: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.MVar.swapMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagpD: // global
           I64[Sp - 16] = block_cagpy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uagpH; else goto cagpz;
       uagpH: // global
           call _cagpy(R1) args: 0, res: 0, upd: 0;
       cagpz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagpy() //  [R1]
         { info_tbl: [(cagpy,
                       label: block_cagpy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagpy: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call Control.Concurrent.MVar.$wswapMVar_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.149023071 UTC

[section ""data" . Control.Concurrent.MVar.swapMVar_closure" {
     Control.Concurrent.MVar.swapMVar_closure:
         const Control.Concurrent.MVar.swapMVar_info;
 },
 Control.Concurrent.MVar.swapMVar_entry() //  [R2, R3]
         { info_tbl: [(cagpM,
                       label: Control.Concurrent.MVar.swapMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagpM: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.MVar.swapMVar1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.151643979 UTC

[section ""data" . $wwithMVar_ragjT_closure" {
     $wwithMVar_ragjT_closure:
         const $wwithMVar_ragjT_info;
 },
 sat_sagkH_entry() //  [R1, R2]
         { info_tbl: [(cagq6,
                       label: sat_sagkH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagq6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagq7; else goto cagq8;
       cagq7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagq8: // global
           I64[Sp - 16] = block_cagq4_info;
           _sagkE::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagkE::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagq4() //  []
         { info_tbl: [(cagq4,
                       label: block_cagq4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagq4: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagkD_entry() //  [R1]
         { info_tbl: [(cagqg,
                       label: sat_sagkD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagqg: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagkV_entry() //  [R1, R2]
         { info_tbl: [(cagqy,
                       label: sat_sagkV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagqy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagqz; else goto cagqA;
       cagqz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagqA: // global
           I64[Sp - 16] = block_cagqw_info;
           _sagkS::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagkS::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagqw() //  []
         { info_tbl: [(cagqw,
                       label: block_cagqw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagqw: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagkR_entry() //  [R1]
         { info_tbl: [(cagqI,
                       label: sat_sagkR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagqI: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagl0_entry() //  [R1]
         { info_tbl: [(cagqP,
                       label: sat_sagl0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagqP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagqQ; else goto cagqR;
       cagqQ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagqR: // global
           I64[Sp - 24] = block_cagqp_info;
           _sagks::P64 = P64[R1 + 7];
           _sagkt::P64 = P64[R1 + 15];
           R1 = _sagks::P64;
           P64[Sp - 16] = _sagks::P64;
           P64[Sp - 8] = _sagkt::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagqp() //  [R1]
         { info_tbl: [(cagqp,
                       label: block_cagqp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagqp: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cagqU; else goto cagqT;
       cagqU: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagqT: // global
           I64[Hp - 64] = sat_sagkV_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagkR_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cagqL_info;
           R2 = Hp - 62;
           _sagkP::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sagkP::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagqL() //  [R1]
         { info_tbl: [(cagqL,
                       label: block_cagqL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagqL: // global
           _sagks::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagqN_info;
           R2 = P64[Sp + 16];
           _sagkY::P64 = R1;
           R1 = _sagks::P64;
           P64[Sp + 16] = _sagkY::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagqN() //  []
         { info_tbl: [(cagqN,
                       label: block_cagqN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagqN: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagl9_entry() //  [R1, R2]
         { info_tbl: [(cagr7,
                       label: sat_sagl9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagr7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagr8; else goto cagr9;
       cagr8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagr9: // global
           I64[Sp - 16] = block_cagr5_info;
           _sagl6::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagl6::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagr5() //  []
         { info_tbl: [(cagr5,
                       label: block_cagr5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagr5: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagl5_entry() //  [R1]
         { info_tbl: [(cagrh,
                       label: sat_sagl5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagrh: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wwithMVar_ragjT_entry() //  [R2, R3]
         { info_tbl: [(cagro,
                       label: $wwithMVar_ragjT_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagro: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagrp; else goto cagrq;
       cagrp: // global
           R3 = R3;
           R2 = R2;
           R1 = $wwithMVar_ragjT_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagrq: // global
           I64[Sp - 24] = block_cagpT_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cagpT() //  [R1]
         { info_tbl: [(cagpT,
                       label: block_cagpT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagpT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cagrt; else goto cagrs;
       cagrt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cagrs: // global
           _sagks::P64 = P64[Sp + 8];
           if (R1 == 0) goto cagrm; else goto uagrM;
       cagrm: // global
           I64[Hp - 16] = sat_sagl0_info;
           P64[Hp - 8] = _sagks::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uagrM: // global
           if (R1 == 1) goto cagrn; else goto cagrl;
       cagrn: // global
           Hp = Hp - 24;
           I64[Sp] = block_cagqY_info;
           R1 = _sagks::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cagrl: // global
           Hp = Hp - 24;
           I64[Sp] = block_cagpX_info;
           R1 = _sagks::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagqY() //  [R1]
         { info_tbl: [(cagqY,
                       label: block_cagqY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagqY: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cagrI; else goto cagrH;
       cagrI: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagrH: // global
           I64[Hp - 64] = sat_sagl9_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagl5_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cagrD_info;
           R2 = Hp - 62;
           _sagl3::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sagl3::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagrD() //  [R1]
         { info_tbl: [(cagrD,
                       label: block_cagrD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagrD: // global
           _sagks::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagrF_info;
           R2 = P64[Sp + 16];
           _saglc::P64 = R1;
           R1 = _sagks::P64;
           P64[Sp + 16] = _saglc::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagrF() //  []
         { info_tbl: [(cagrF,
                       label: block_cagrF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagrF: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cagpX() //  [R1]
         { info_tbl: [(cagpX,
                       label: block_cagpX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagpX: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cagrz; else goto cagry;
       cagrz: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagry: // global
           I64[Hp - 64] = sat_sagkH_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagkD_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cagru_info;
           R2 = Hp - 62;
           _sagkB::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sagkB::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagru() //  [R1]
         { info_tbl: [(cagru,
                       label: block_cagru_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagru: // global
           _sagks::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagrw_info;
           R2 = P64[Sp + 16];
           _sagkK::P64 = R1;
           R1 = _sagks::P64;
           P64[Sp + 16] = _sagkK::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagrw() //  []
         { info_tbl: [(cagrw,
                       label: block_cagrw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagrw: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.156443324 UTC

[section ""data" . withMVar1_ragjU_closure" {
     withMVar1_ragjU_closure:
         const withMVar1_ragjU_info;
 },
 withMVar1_ragjU_entry() //  [R2, R3]
         { info_tbl: [(cagrU,
                       label: withMVar1_ragjU_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagrU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagrV; else goto cagrW;
       cagrV: // global
           R3 = R3;
           R2 = R2;
           R1 = withMVar1_ragjU_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagrW: // global
           I64[Sp - 16] = block_cagrR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uags0; else goto cagrS;
       uags0: // global
           call _cagrR(R1) args: 0, res: 0, upd: 0;
       cagrS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagrR() //  [R1]
         { info_tbl: [(cagrR,
                       label: block_cagrR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagrR: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wwithMVar_ragjT_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.157571304 UTC

[section ""data" . Control.Concurrent.MVar.withMVar_closure" {
     Control.Concurrent.MVar.withMVar_closure:
         const Control.Concurrent.MVar.withMVar_info;
 },
 Control.Concurrent.MVar.withMVar_entry() //  [R2, R3]
         { info_tbl: [(cags5,
                       label: Control.Concurrent.MVar.withMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cags5: // global
           R3 = R3;
           R2 = R2;
           call withMVar1_ragjU_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.159201117 UTC

[section ""data" . $wwithMVarMasked_ragjV_closure" {
     $wwithMVarMasked_ragjV_closure:
         const $wwithMVarMasked_ragjV_info;
 },
 sat_sagly_entry() //  [R1, R2]
         { info_tbl: [(cagss,
                       label: sat_sagly_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagss: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagst; else goto cagsu;
       cagst: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagsu: // global
           I64[Sp - 16] = block_cagsq_info;
           _saglv::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saglv::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagsq() //  []
         { info_tbl: [(cagsq,
                       label: block_cagsq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagsq: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saglu_entry() //  [R1]
         { info_tbl: [(cagsA,
                       label: sat_saglu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagsA: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saglp_entry() //  [R1]
         { info_tbl: [(cagsH,
                       label: io_saglp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagsH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagsI; else goto cagsJ;
       cagsI: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagsJ: // global
           I64[Sp - 24] = block_cagsj_info;
           _saglj::P64 = P64[R1 + 7];
           _saglk::P64 = P64[R1 + 15];
           R1 = _saglj::P64;
           P64[Sp - 16] = _saglj::P64;
           P64[Sp - 8] = _saglk::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagsj() //  [R1]
         { info_tbl: [(cagsj,
                       label: block_cagsj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagsj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cagsM; else goto cagsL;
       cagsM: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagsL: // global
           I64[Hp - 48] = sat_sagly_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = R1;
           I64[Hp - 24] = sat_saglu_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp] = block_cagsD_info;
           R2 = Hp - 46;
           _saglt::P64 = R1;
           R1 = Hp - 24;
           P64[Sp + 16] = _saglt::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagsD() //  [R1]
         { info_tbl: [(cagsD,
                       label: block_cagsD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagsD: // global
           _saglj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagsF_info;
           R2 = P64[Sp + 16];
           _saglB::P64 = R1;
           R1 = _saglj::P64;
           P64[Sp + 16] = _saglB::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagsF() //  []
         { info_tbl: [(cagsF,
                       label: block_cagsF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagsF: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wwithMVarMasked_ragjV_entry() //  [R2, R3]
         { info_tbl: [(cagsT,
                       label: $wwithMVarMasked_ragjV_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagsT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagsU; else goto cagsV;
       cagsU: // global
           R3 = R3;
           R2 = R2;
           R1 = $wwithMVarMasked_ragjV_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagsV: // global
           I64[Sp - 24] = block_cagsc_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cagsc() //  [R1]
         { info_tbl: [(cagsc,
                       label: block_cagsc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagsc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cagsY; else goto cagsX;
       cagsY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cagsX: // global
           I64[Hp - 16] = io_saglp_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _cagse::P64 = Hp - 15;
           if (R1 == 0) goto cagsS; else goto cagsR;
       cagsS: // global
           R1 = _cagse::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cagsR: // global
           R1 = _cagse::P64;
           Sp = Sp + 24;
           call io_saglp_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.161906585 UTC

[section ""data" . withMVarMasked1_ragjW_closure" {
     withMVarMasked1_ragjW_closure:
         const withMVarMasked1_ragjW_info;
 },
 withMVarMasked1_ragjW_entry() //  [R2, R3]
         { info_tbl: [(cagt6,
                       label: withMVarMasked1_ragjW_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagt6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagt7; else goto cagt8;
       cagt7: // global
           R3 = R3;
           R2 = R2;
           R1 = withMVarMasked1_ragjW_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagt8: // global
           I64[Sp - 16] = block_cagt3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uagtc; else goto cagt4;
       uagtc: // global
           call _cagt3(R1) args: 0, res: 0, upd: 0;
       cagt4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagt3() //  [R1]
         { info_tbl: [(cagt3,
                       label: block_cagt3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagt3: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wwithMVarMasked_ragjV_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.162986579 UTC

[section ""data" . Control.Concurrent.MVar.withMVarMasked_closure" {
     Control.Concurrent.MVar.withMVarMasked_closure:
         const Control.Concurrent.MVar.withMVarMasked_info;
 },
 Control.Concurrent.MVar.withMVarMasked_entry() //  [R2, R3]
         { info_tbl: [(cagth,
                       label: Control.Concurrent.MVar.withMVarMasked_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagth: // global
           R3 = R3;
           R2 = R2;
           call withMVarMasked1_ragjW_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.165604127 UTC

[section ""data" . $wmodifyMVar__ragjX_closure" {
     $wmodifyMVar__ragjX_closure:
         const $wmodifyMVar__ragjX_info;
 },
 sat_saglY_entry() //  [R1, R2]
         { info_tbl: [(cagtB,
                       label: sat_saglY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagtB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagtC; else goto cagtD;
       cagtC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagtD: // global
           I64[Sp - 16] = block_cagtz_info;
           _saglV::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saglV::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagtz() //  []
         { info_tbl: [(cagtz,
                       label: block_cagtz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagtz: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saglU_entry() //  [R1]
         { info_tbl: [(cagtL,
                       label: sat_saglU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagtL: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagmc_entry() //  [R1, R2]
         { info_tbl: [(cagu3,
                       label: sat_sagmc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagu3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagu4; else goto cagu5;
       cagu4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagu5: // global
           I64[Sp - 16] = block_cagu1_info;
           _sagm9::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagm9::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagu1() //  []
         { info_tbl: [(cagu1,
                       label: block_cagu1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagu1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagm8_entry() //  [R1]
         { info_tbl: [(cagud,
                       label: sat_sagm8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagud: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagmh_entry() //  [R1]
         { info_tbl: [(caguk,
                       label: sat_sagmh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caguk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagul; else goto cagum;
       cagul: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagum: // global
           I64[Sp - 24] = block_cagtU_info;
           _saglJ::P64 = P64[R1 + 7];
           _saglK::P64 = P64[R1 + 15];
           R1 = _saglJ::P64;
           P64[Sp - 16] = _saglJ::P64;
           P64[Sp - 8] = _saglK::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagtU() //  [R1]
         { info_tbl: [(cagtU,
                       label: block_cagtU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagtU: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cagup; else goto caguo;
       cagup: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caguo: // global
           I64[Hp - 64] = sat_sagmc_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagm8_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cagug_info;
           R2 = Hp - 62;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagug() //  [R1]
         { info_tbl: [(cagug,
                       label: block_cagug_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagug: // global
           I64[Sp + 16] = block_cagui_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagui() //  []
         { info_tbl: [(cagui,
                       label: block_cagui_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagui: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagmq_entry() //  [R1, R2]
         { info_tbl: [(caguC,
                       label: sat_sagmq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caguC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caguD; else goto caguE;
       caguD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caguE: // global
           I64[Sp - 16] = block_caguA_info;
           _sagmn::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagmn::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caguA() //  []
         { info_tbl: [(caguA,
                       label: block_caguA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caguA: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagmm_entry() //  [R1]
         { info_tbl: [(caguM,
                       label: sat_sagmm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caguM: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wmodifyMVar__ragjX_entry() //  [R2, R3]
         { info_tbl: [(caguT,
                       label: $wmodifyMVar__ragjX_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caguT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caguU; else goto caguV;
       caguU: // global
           R3 = R3;
           R2 = R2;
           R1 = $wmodifyMVar__ragjX_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caguV: // global
           I64[Sp - 24] = block_cagto_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cagto() //  [R1]
         { info_tbl: [(cagto,
                       label: block_cagto_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagto: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caguY; else goto caguX;
       caguY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caguX: // global
           _saglJ::P64 = P64[Sp + 8];
           if (R1 == 0) goto caguR; else goto uagvh;
       caguR: // global
           I64[Hp - 16] = sat_sagmh_info;
           P64[Hp - 8] = _saglJ::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uagvh: // global
           if (R1 == 1) goto caguS; else goto caguQ;
       caguS: // global
           Hp = Hp - 24;
           I64[Sp] = block_cagut_info;
           R1 = _saglJ::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       caguQ: // global
           Hp = Hp - 24;
           I64[Sp] = block_cagts_info;
           R1 = _saglJ::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagut() //  [R1]
         { info_tbl: [(cagut,
                       label: block_cagut_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagut: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cagvd; else goto cagvc;
       cagvd: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagvc: // global
           I64[Hp - 64] = sat_sagmq_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagmm_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cagv8_info;
           R2 = Hp - 62;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagv8() //  [R1]
         { info_tbl: [(cagv8,
                       label: block_cagv8_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagv8: // global
           I64[Sp + 16] = block_cagva_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagts() //  [R1]
         { info_tbl: [(cagts,
                       label: block_cagts_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagts: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cagv4; else goto cagv3;
       cagv4: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagv3: // global
           I64[Hp - 64] = sat_saglY_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saglU_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_caguZ_info;
           R2 = Hp - 62;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caguZ() //  [R1]
         { info_tbl: [(caguZ,
                       label: block_caguZ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caguZ: // global
           I64[Sp + 16] = block_cagva_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagva() //  []
         { info_tbl: [(cagva,
                       label: block_cagva_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagva: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.170094792 UTC

[section ""data" . modifyMVar_1_ragjY_closure" {
     modifyMVar_1_ragjY_closure:
         const modifyMVar_1_ragjY_info;
 },
 modifyMVar_1_ragjY_entry() //  [R2, R3]
         { info_tbl: [(cagvp,
                       label: modifyMVar_1_ragjY_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagvp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagvq; else goto cagvr;
       cagvq: // global
           R3 = R3;
           R2 = R2;
           R1 = modifyMVar_1_ragjY_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagvr: // global
           I64[Sp - 16] = block_cagvm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uagvv; else goto cagvn;
       uagvv: // global
           call _cagvm(R1) args: 0, res: 0, upd: 0;
       cagvn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagvm() //  [R1]
         { info_tbl: [(cagvm,
                       label: block_cagvm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagvm: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wmodifyMVar__ragjX_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.171214911 UTC

[section ""data" . Control.Concurrent.MVar.modifyMVar__closure" {
     Control.Concurrent.MVar.modifyMVar__closure:
         const Control.Concurrent.MVar.modifyMVar__info;
 },
 Control.Concurrent.MVar.modifyMVar__entry() //  [R2, R3]
         { info_tbl: [(cagvA,
                       label: Control.Concurrent.MVar.modifyMVar__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagvA: // global
           R3 = R3;
           R2 = R2;
           call modifyMVar_1_ragjY_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.174561139 UTC

[section ""data" . $wmodifyMVar_ragjZ_closure" {
     $wmodifyMVar_ragjZ_closure:
         const $wmodifyMVar_ragjZ_info;
 },
 sat_sagmT_entry() //  [R1, R2]
         { info_tbl: [(cagvU,
                       label: sat_sagmT_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagvU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagvV; else goto cagvW;
       cagvV: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagvW: // global
           I64[Sp - 16] = block_cagvS_info;
           _sagmQ::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagmQ::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagvS() //  []
         { info_tbl: [(cagvS,
                       label: block_cagvS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagvS: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagmO_entry() //  [R1]
         { info_tbl: [(cagw5,
                       label: sat_sagmO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagw5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cagw6; else goto cagw7;
       cagw6: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagw7: // global
           I64[Sp - 8] = block_cagw3_info;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagw3() //  [R1]
         { info_tbl: [(cagw3,
                       label: block_cagw3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagw3: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagmP_entry() //  [R1]
         { info_tbl: [(cagwe,
                       label: sat_sagmP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagwe: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagne_entry() //  [R1, R2]
         { info_tbl: [(cagww,
                       label: sat_sagne_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagww: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagwx; else goto cagwy;
       cagwx: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagwy: // global
           I64[Sp - 16] = block_cagwu_info;
           _sagnb::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagnb::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagwu() //  []
         { info_tbl: [(cagwu,
                       label: block_cagwu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagwu: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagn9_entry() //  [R1]
         { info_tbl: [(cagwH,
                       label: sat_sagn9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagwH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cagwI; else goto cagwJ;
       cagwI: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagwJ: // global
           I64[Sp - 8] = block_cagwF_info;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagwF() //  [R1]
         { info_tbl: [(cagwF,
                       label: block_cagwF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagwF: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagna_entry() //  [R1]
         { info_tbl: [(cagwQ,
                       label: sat_sagna_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagwQ: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagnm_entry() //  [R1]
         { info_tbl: [(cagwY,
                       label: sat_sagnm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagwY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagx2; else goto cagx3;
       cagx2: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagx3: // global
           I64[Sp - 24] = block_cagwn_info;
           _sagmA::P64 = P64[R1 + 7];
           _sagmB::P64 = P64[R1 + 15];
           R1 = _sagmA::P64;
           P64[Sp - 16] = _sagmA::P64;
           P64[Sp - 8] = _sagmB::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagwn() //  [R1]
         { info_tbl: [(cagwn,
                       label: block_cagwn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagwn: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cagx6; else goto cagx5;
       cagx6: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagx5: // global
           I64[Hp - 56] = sat_sagne_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sagn9_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagna_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cagwT_info;
           R2 = Hp - 54;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagwT() //  [R1]
         { info_tbl: [(cagwT,
                       label: block_cagwT_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagwT: // global
           I64[Sp] = block_cagwV_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uagxb; else goto cagwW;
       uagxb: // global
           call _cagwV(R1) args: 0, res: 0, upd: 0;
       cagwW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagwV() //  [R1]
         { info_tbl: [(cagwV,
                       label: block_cagwV_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagwV: // global
           _sagmA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagx1_info;
           R2 = P64[R1 + 7];
           _sagnk::P64 = P64[R1 + 15];
           R1 = _sagmA::P64;
           P64[Sp + 16] = _sagnk::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagx1() //  []
         { info_tbl: [(cagx1,
                       label: block_cagx1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagx1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagnz_entry() //  [R1, R2]
         { info_tbl: [(cagxm,
                       label: sat_sagnz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagxm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagxn; else goto cagxo;
       cagxn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagxo: // global
           I64[Sp - 16] = block_cagxk_info;
           _sagnw::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagnw::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagxk() //  []
         { info_tbl: [(cagxk,
                       label: block_cagxk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagxk: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagnu_entry() //  [R1]
         { info_tbl: [(cagxx,
                       label: sat_sagnu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagxx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cagxy; else goto cagxz;
       cagxy: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagxz: // global
           I64[Sp - 8] = block_cagxv_info;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagxv() //  [R1]
         { info_tbl: [(cagxv,
                       label: block_cagxv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagxv: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagnv_entry() //  [R1]
         { info_tbl: [(cagxG,
                       label: sat_sagnv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagxG: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wmodifyMVar_ragjZ_entry() //  [R2, R3]
         { info_tbl: [(cagxN,
                       label: $wmodifyMVar_ragjZ_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagxN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagxO; else goto cagxP;
       cagxO: // global
           R3 = R3;
           R2 = R2;
           R1 = $wmodifyMVar_ragjZ_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagxP: // global
           I64[Sp - 24] = block_cagvH_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cagvH() //  [R1]
         { info_tbl: [(cagvH,
                       label: block_cagvH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagvH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cagxS; else goto cagxR;
       cagxS: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cagxR: // global
           _sagmA::P64 = P64[Sp + 8];
           if (R1 == 0) goto cagxL; else goto uagyn;
       cagxL: // global
           I64[Hp - 16] = sat_sagnm_info;
           P64[Hp - 8] = _sagmA::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uagyn: // global
           if (R1 == 1) goto cagxM; else goto cagxK;
       cagxM: // global
           Hp = Hp - 24;
           I64[Sp] = block_cagxd_info;
           R1 = _sagmA::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cagxK: // global
           Hp = Hp - 24;
           I64[Sp] = block_cagvL_info;
           R1 = _sagmA::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagxd() //  [R1]
         { info_tbl: [(cagxd,
                       label: block_cagxd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagxd: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cagyi; else goto cagyh;
       cagyi: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagyh: // global
           I64[Hp - 56] = sat_sagnz_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sagnu_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagnv_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cagy8_info;
           R2 = Hp - 54;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagy8() //  [R1]
         { info_tbl: [(cagy8,
                       label: block_cagy8_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagy8: // global
           I64[Sp] = block_cagya_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uagyp; else goto cagyb;
       uagyp: // global
           call _cagya(R1) args: 0, res: 0, upd: 0;
       cagyb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagya() //  [R1]
         { info_tbl: [(cagya,
                       label: block_cagya_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagya: // global
           _sagmA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagyf_info;
           R2 = P64[R1 + 7];
           _sagnF::P64 = P64[R1 + 15];
           R1 = _sagmA::P64;
           P64[Sp + 16] = _sagnF::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagyf() //  []
         { info_tbl: [(cagyf,
                       label: block_cagyf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagyf: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cagvL() //  [R1]
         { info_tbl: [(cagvL,
                       label: block_cagvL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagvL: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cagy3; else goto cagy2;
       cagy3: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagy2: // global
           I64[Hp - 56] = sat_sagmT_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sagmO_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagmP_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cagxT_info;
           R2 = Hp - 54;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagxT() //  [R1]
         { info_tbl: [(cagxT,
                       label: block_cagxT_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagxT: // global
           I64[Sp] = block_cagxV_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uagyo; else goto cagxW;
       uagyo: // global
           call _cagxV(R1) args: 0, res: 0, upd: 0;
       cagxW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagxV() //  [R1]
         { info_tbl: [(cagxV,
                       label: block_cagxV_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagxV: // global
           _sagmA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagy0_info;
           R2 = P64[R1 + 7];
           _sagmZ::P64 = P64[R1 + 15];
           R1 = _sagmA::P64;
           P64[Sp + 16] = _sagmZ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagy0() //  []
         { info_tbl: [(cagy0,
                       label: block_cagy0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagy0: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.180881388 UTC

[section ""data" . modifyMVar1_ragk0_closure" {
     modifyMVar1_ragk0_closure:
         const modifyMVar1_ragk0_info;
 },
 modifyMVar1_ragk0_entry() //  [R2, R3]
         { info_tbl: [(cagyx,
                       label: modifyMVar1_ragk0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagyx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagyy; else goto cagyz;
       cagyy: // global
           R3 = R3;
           R2 = R2;
           R1 = modifyMVar1_ragk0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagyz: // global
           I64[Sp - 16] = block_cagyu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uagyD; else goto cagyv;
       uagyD: // global
           call _cagyu(R1) args: 0, res: 0, upd: 0;
       cagyv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagyu() //  [R1]
         { info_tbl: [(cagyu,
                       label: block_cagyu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagyu: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wmodifyMVar_ragjZ_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.182030272 UTC

[section ""data" . Control.Concurrent.MVar.modifyMVar_closure" {
     Control.Concurrent.MVar.modifyMVar_closure:
         const Control.Concurrent.MVar.modifyMVar_info;
 },
 Control.Concurrent.MVar.modifyMVar_entry() //  [R2, R3]
         { info_tbl: [(cagyI,
                       label: Control.Concurrent.MVar.modifyMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagyI: // global
           R3 = R3;
           R2 = R2;
           call modifyMVar1_ragk0_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.18362523 UTC

[section ""data" . $wmodifyMVarMasked__ragk1_closure" {
     $wmodifyMVarMasked__ragk1_closure:
         const $wmodifyMVarMasked__ragk1_info;
 },
 sat_sago1_entry() //  [R1, R2]
         { info_tbl: [(cagz5,
                       label: sat_sago1_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagz5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagz6; else goto cagz7;
       cagz6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagz7: // global
           I64[Sp - 16] = block_cagz3_info;
           _sagnY::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagnY::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagz3() //  []
         { info_tbl: [(cagz3,
                       label: block_cagz3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagz3: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagnX_entry() //  [R1]
         { info_tbl: [(cagzd,
                       label: sat_sagnX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagzd: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sagnS_entry() //  [R1]
         { info_tbl: [(cagzk,
                       label: io_sagnS_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagzk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagzl; else goto cagzm;
       cagzl: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagzm: // global
           I64[Sp - 24] = block_cagyW_info;
           _sagnM::P64 = P64[R1 + 7];
           _sagnN::P64 = P64[R1 + 15];
           R1 = _sagnM::P64;
           P64[Sp - 16] = _sagnM::P64;
           P64[Sp - 8] = _sagnN::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagyW() //  [R1]
         { info_tbl: [(cagyW,
                       label: block_cagyW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagyW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cagzp; else goto cagzo;
       cagzp: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagzo: // global
           I64[Hp - 48] = sat_sago1_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = R1;
           I64[Hp - 24] = sat_sagnX_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp] = block_cagzg_info;
           R2 = Hp - 46;
           R1 = Hp - 24;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagzg() //  [R1]
         { info_tbl: [(cagzg,
                       label: block_cagzg_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagzg: // global
           I64[Sp + 16] = block_cagzi_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagzi() //  []
         { info_tbl: [(cagzi,
                       label: block_cagzi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagzi: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wmodifyMVarMasked__ragk1_entry() //  [R2, R3]
         { info_tbl: [(cagzw,
                       label: $wmodifyMVarMasked__ragk1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagzw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagzx; else goto cagzy;
       cagzx: // global
           R3 = R3;
           R2 = R2;
           R1 = $wmodifyMVarMasked__ragk1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagzy: // global
           I64[Sp - 24] = block_cagyP_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cagyP() //  [R1]
         { info_tbl: [(cagyP,
                       label: block_cagyP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagyP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cagzB; else goto cagzA;
       cagzB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cagzA: // global
           I64[Hp - 16] = io_sagnS_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _cagyR::P64 = Hp - 15;
           if (R1 == 0) goto cagzv; else goto cagzu;
       cagzv: // global
           R1 = _cagyR::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cagzu: // global
           R1 = _cagyR::P64;
           Sp = Sp + 24;
           call io_sagnS_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.186444882 UTC

[section ""data" . modifyMVarMasked_1_ragk2_closure" {
     modifyMVarMasked_1_ragk2_closure:
         const modifyMVarMasked_1_ragk2_info;
 },
 modifyMVarMasked_1_ragk2_entry() //  [R2, R3]
         { info_tbl: [(cagzJ,
                       label: modifyMVarMasked_1_ragk2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagzJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagzK; else goto cagzL;
       cagzK: // global
           R3 = R3;
           R2 = R2;
           R1 = modifyMVarMasked_1_ragk2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagzL: // global
           I64[Sp - 16] = block_cagzG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uagzP; else goto cagzH;
       uagzP: // global
           call _cagzG(R1) args: 0, res: 0, upd: 0;
       cagzH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagzG() //  [R1]
         { info_tbl: [(cagzG,
                       label: block_cagzG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagzG: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wmodifyMVarMasked__ragk1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.187600019 UTC

[section ""data" . Control.Concurrent.MVar.modifyMVarMasked__closure" {
     Control.Concurrent.MVar.modifyMVarMasked__closure:
         const Control.Concurrent.MVar.modifyMVarMasked__info;
 },
 Control.Concurrent.MVar.modifyMVarMasked__entry() //  [R2, R3]
         { info_tbl: [(cagzU,
                       label: Control.Concurrent.MVar.modifyMVarMasked__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagzU: // global
           R3 = R3;
           R2 = R2;
           call modifyMVarMasked_1_ragk2_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.189416963 UTC

[section ""data" . $wmodifyMVarMasked_ragk3_closure" {
     $wmodifyMVarMasked_ragk3_closure:
         const $wmodifyMVarMasked_ragk3_info;
 },
 sat_sagov_entry() //  [R1, R2]
         { info_tbl: [(cagAh,
                       label: sat_sagov_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagAh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagAi; else goto cagAj;
       cagAi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagAj: // global
           I64[Sp - 16] = block_cagAf_info;
           _sagos::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagos::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagAf() //  []
         { info_tbl: [(cagAf,
                       label: block_cagAf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagAf: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagor_entry() //  [R1]
         { info_tbl: [(cagAs,
                       label: sat_sagor_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagAs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cagAt; else goto cagAu;
       cagAt: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagAu: // global
           I64[Sp - 8] = block_cagAq_info;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagAq() //  [R1]
         { info_tbl: [(cagAq,
                       label: block_cagAq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagAq: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sagoi_entry() //  [R1]
         { info_tbl: [(cagAB,
                       label: io_sagoi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagAB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagAF; else goto cagAG;
       cagAF: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagAG: // global
           I64[Sp - 24] = block_cagA8_info;
           _sagoc::P64 = P64[R1 + 7];
           _sagod::P64 = P64[R1 + 15];
           R1 = _sagoc::P64;
           P64[Sp - 16] = _sagoc::P64;
           P64[Sp - 8] = _sagod::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagA8() //  [R1]
         { info_tbl: [(cagA8,
                       label: block_cagA8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagA8: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cagAJ; else goto cagAI;
       cagAJ: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagAI: // global
           I64[Hp - 40] = sat_sagov_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sagor_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp] = block_cagAw_info;
           R2 = Hp - 38;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagAw() //  [R1]
         { info_tbl: [(cagAw,
                       label: block_cagAw_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagAw: // global
           I64[Sp] = block_cagAy_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uagAO; else goto cagAz;
       uagAO: // global
           call _cagAy(R1) args: 0, res: 0, upd: 0;
       cagAz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagAy() //  [R1]
         { info_tbl: [(cagAy,
                       label: block_cagAy_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagAy: // global
           _sagoc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagAE_info;
           R2 = P64[R1 + 7];
           _sagoB::P64 = P64[R1 + 15];
           R1 = _sagoc::P64;
           P64[Sp + 16] = _sagoB::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagAE() //  []
         { info_tbl: [(cagAE,
                       label: block_cagAE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagAE: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wmodifyMVarMasked_ragk3_entry() //  [R2, R3]
         { info_tbl: [(cagAT,
                       label: $wmodifyMVarMasked_ragk3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagAT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagAU; else goto cagAV;
       cagAU: // global
           R3 = R3;
           R2 = R2;
           R1 = $wmodifyMVarMasked_ragk3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagAV: // global
           I64[Sp - 24] = block_cagA1_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cagA1() //  [R1]
         { info_tbl: [(cagA1,
                       label: block_cagA1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagA1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cagAY; else goto cagAX;
       cagAY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cagAX: // global
           I64[Hp - 16] = io_sagoi_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _cagA3::P64 = Hp - 15;
           if (R1 == 0) goto cagAS; else goto cagAR;
       cagAS: // global
           R1 = _cagA3::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cagAR: // global
           R1 = _cagA3::P64;
           Sp = Sp + 24;
           call io_sagoi_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.194474101 UTC

[section ""data" . modifyMVarMasked1_ragk4_closure" {
     modifyMVarMasked1_ragk4_closure:
         const modifyMVarMasked1_ragk4_info;
 },
 modifyMVarMasked1_ragk4_entry() //  [R2, R3]
         { info_tbl: [(cagB6,
                       label: modifyMVarMasked1_ragk4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagB6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagB7; else goto cagB8;
       cagB7: // global
           R3 = R3;
           R2 = R2;
           R1 = modifyMVarMasked1_ragk4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagB8: // global
           I64[Sp - 16] = block_cagB3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uagBc; else goto cagB4;
       uagBc: // global
           call _cagB3(R1) args: 0, res: 0, upd: 0;
       cagB4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagB3() //  [R1]
         { info_tbl: [(cagB3,
                       label: block_cagB3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagB3: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wmodifyMVarMasked_ragk3_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.195559945 UTC

[section ""data" . Control.Concurrent.MVar.modifyMVarMasked_closure" {
     Control.Concurrent.MVar.modifyMVarMasked_closure:
         const Control.Concurrent.MVar.modifyMVarMasked_info;
 },
 Control.Concurrent.MVar.modifyMVarMasked_entry() //  [R2, R3]
         { info_tbl: [(cagBh,
                       label: Control.Concurrent.MVar.modifyMVarMasked_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagBh: // global
           R3 = R3;
           R2 = R2;
           call modifyMVarMasked1_ragk4_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.196385346 UTC

[section ""data" . Control.Concurrent.MVar.addMVarFinalizer_closure" {
     Control.Concurrent.MVar.addMVarFinalizer_closure:
         const Control.Concurrent.MVar.addMVarFinalizer_info;
 },
 Control.Concurrent.MVar.addMVarFinalizer_entry() //  [R2, R3]
         { info_tbl: [(cagBo,
                       label: Control.Concurrent.MVar.addMVarFinalizer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagBo: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.addMVarFinalizer1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.197523629 UTC

[section ""data" . Control.Concurrent.MVar.mkWeakMVar1_closure" {
     Control.Concurrent.MVar.mkWeakMVar1_closure:
         const Control.Concurrent.MVar.mkWeakMVar1_info;
 },
 Control.Concurrent.MVar.mkWeakMVar1_entry() //  [R2, R3]
         { info_tbl: [(cagBy,
                       label: Control.Concurrent.MVar.mkWeakMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagBy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagBE; else goto cagBF;
       cagBE: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.MVar.mkWeakMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagBF: // global
           I64[Sp - 16] = block_cagBv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uagBK; else goto cagBw;
       uagBK: // global
           call _cagBv(R1) args: 0, res: 0, upd: 0;
       cagBw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagBv() //  [R1]
         { info_tbl: [(cagBv,
                       label: block_cagBv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagBv: // global
           _sagoK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagBB_info;
           R3 = _sagoK::P64;
           R2 = R1;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagBB() //  [R1]
         { info_tbl: [(cagBB,
                       label: block_cagBB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagBB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cagBJ; else goto cagBI;
       cagBJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagBI: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.198840476 UTC

[section ""data" . Control.Concurrent.MVar.mkWeakMVar_closure" {
     Control.Concurrent.MVar.mkWeakMVar_closure:
         const Control.Concurrent.MVar.mkWeakMVar_info;
 },
 Control.Concurrent.MVar.mkWeakMVar_entry() //  [R2, R3]
         { info_tbl: [(cagBP,
                       label: Control.Concurrent.MVar.mkWeakMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagBP: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.MVar.mkWeakMVar1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.19954028 UTC

[section ""cstring" . Control.Concurrent.MVar.$trModule4_bytes" {
     Control.Concurrent.MVar.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.200045978 UTC

[section ""data" . Control.Concurrent.MVar.$trModule3_closure" {
     Control.Concurrent.MVar.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.MVar.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.20055662 UTC

[section ""cstring" . Control.Concurrent.MVar.$trModule2_bytes" {
     Control.Concurrent.MVar.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.201067472 UTC

[section ""data" . Control.Concurrent.MVar.$trModule1_closure" {
     Control.Concurrent.MVar.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.MVar.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.201632922 UTC

[section ""data" . Control.Concurrent.MVar.$trModule_closure" {
     Control.Concurrent.MVar.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.MVar.$trModule3_closure+1;
         const Control.Concurrent.MVar.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.202214517 UTC

[section ""relreadonly" . SagBS_srt" { SagBS_srt:
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.202756846 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:17.203856679 UTC

[section ""data" . Control.Concurrent.MVar.$wswapMVar_closure" {
     Control.Concurrent.MVar.$wswapMVar_closure:
         const Control.Concurrent.MVar.$wswapMVar_info;
 },
 sat_sagkm_entry() //  [R1]
         { info_tbl: [(cagCb,
                       label: sat_sagkm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagCb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagCc; else goto cagCd;
       cagCc: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagCd: // global
           I64[Sp - 24] = block_cagC7_info;
           _sagk6::P64 = P64[R1 + 7];
           _sagk7::P64 = P64[R1 + 15];
           R1 = _sagk6::P64;
           P64[Sp - 16] = _sagk6::P64;
           P64[Sp - 8] = _sagk7::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagC7() //  [R1]
         { info_tbl: [(cagC7,
                       label: block_cagC7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagC7: // global
           _sagk6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagC9_info;
           R2 = P64[Sp + 16];
           _sagkk::P64 = R1;
           R1 = _sagk6::P64;
           P64[Sp + 16] = _sagkk::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagC9() //  []
         { info_tbl: [(cagC9,
                       label: block_cagC9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagC9: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.MVar.$wswapMVar_entry() //  [R2, R3]
         { info_tbl: [(cagCj,
                       label: Control.Concurrent.MVar.$wswapMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagCj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagCk; else goto cagCl;
       cagCk: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.MVar.$wswapMVar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagCl: // global
           I64[Sp - 24] = block_cagBX_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cagBX() //  [R1]
         { info_tbl: [(cagBX,
                       label: block_cagBX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagBX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cagCo; else goto cagCn;
       cagCo: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cagCn: // global
           _sagk6::P64 = P64[Sp + 8];
           if (R1 == 0) goto cagCi; else goto cagCh;
       cagCi: // global
           I64[Hp - 16] = sat_sagkm_info;
           P64[Hp - 8] = _sagk6::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cagCh: // global
           Hp = Hp - 24;
           I64[Sp] = block_cagCp_info;
           R1 = _sagk6::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagCp() //  [R1]
         { info_tbl: [(cagCp,
                       label: block_cagCp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagCp: // global
           _sagk6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagCr_info;
           R2 = P64[Sp + 16];
           _sagkf::P64 = R1;
           R1 = _sagk6::P64;
           P64[Sp + 16] = _sagkf::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagCr() //  []
         { info_tbl: [(cagCr,
                       label: block_cagCr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagCr: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.206019874 UTC

[section ""data" . Control.Concurrent.MVar.swapMVar1_closure" {
     Control.Concurrent.MVar.swapMVar1_closure:
         const Control.Concurrent.MVar.swapMVar1_info;
 },
 Control.Concurrent.MVar.swapMVar1_entry() //  [R2, R3]
         { info_tbl: [(cagCC,
                       label: Control.Concurrent.MVar.swapMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagCC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagCD; else goto cagCE;
       cagCD: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.MVar.swapMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagCE: // global
           I64[Sp - 16] = block_cagCz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uagCI; else goto cagCA;
       uagCI: // global
           call _cagCz(R1) args: 0, res: 0, upd: 0;
       cagCA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagCz() //  [R1]
         { info_tbl: [(cagCz,
                       label: block_cagCz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagCz: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call Control.Concurrent.MVar.$wswapMVar_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.207142677 UTC

[section ""data" . Control.Concurrent.MVar.swapMVar_closure" {
     Control.Concurrent.MVar.swapMVar_closure:
         const Control.Concurrent.MVar.swapMVar_info;
 },
 Control.Concurrent.MVar.swapMVar_entry() //  [R2, R3]
         { info_tbl: [(cagCN,
                       label: Control.Concurrent.MVar.swapMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagCN: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.MVar.swapMVar1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.209828476 UTC

[section ""data" . $wwithMVar_ragjT_closure" {
     $wwithMVar_ragjT_closure:
         const $wwithMVar_ragjT_info;
 },
 sat_sagkH_entry() //  [R1, R2]
         { info_tbl: [(cagD7,
                       label: sat_sagkH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagD7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagD8; else goto cagD9;
       cagD8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagD9: // global
           I64[Sp - 16] = block_cagD5_info;
           _sagkE::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagkE::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagD5() //  []
         { info_tbl: [(cagD5,
                       label: block_cagD5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagD5: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagkD_entry() //  [R1]
         { info_tbl: [(cagDh,
                       label: sat_sagkD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagDh: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagkV_entry() //  [R1, R2]
         { info_tbl: [(cagDz,
                       label: sat_sagkV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagDz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagDA; else goto cagDB;
       cagDA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagDB: // global
           I64[Sp - 16] = block_cagDx_info;
           _sagkS::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagkS::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagDx() //  []
         { info_tbl: [(cagDx,
                       label: block_cagDx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagDx: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagkR_entry() //  [R1]
         { info_tbl: [(cagDJ,
                       label: sat_sagkR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagDJ: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagl0_entry() //  [R1]
         { info_tbl: [(cagDQ,
                       label: sat_sagl0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagDQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagDR; else goto cagDS;
       cagDR: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagDS: // global
           I64[Sp - 24] = block_cagDq_info;
           _sagks::P64 = P64[R1 + 7];
           _sagkt::P64 = P64[R1 + 15];
           R1 = _sagks::P64;
           P64[Sp - 16] = _sagks::P64;
           P64[Sp - 8] = _sagkt::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagDq() //  [R1]
         { info_tbl: [(cagDq,
                       label: block_cagDq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagDq: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cagDV; else goto cagDU;
       cagDV: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagDU: // global
           I64[Hp - 64] = sat_sagkV_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagkR_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cagDM_info;
           R2 = Hp - 62;
           _sagkP::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sagkP::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagDM() //  [R1]
         { info_tbl: [(cagDM,
                       label: block_cagDM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagDM: // global
           _sagks::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagDO_info;
           R2 = P64[Sp + 16];
           _sagkY::P64 = R1;
           R1 = _sagks::P64;
           P64[Sp + 16] = _sagkY::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagDO() //  []
         { info_tbl: [(cagDO,
                       label: block_cagDO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagDO: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagl9_entry() //  [R1, R2]
         { info_tbl: [(cagE8,
                       label: sat_sagl9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagE8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagE9; else goto cagEa;
       cagE9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagEa: // global
           I64[Sp - 16] = block_cagE6_info;
           _sagl6::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagl6::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagE6() //  []
         { info_tbl: [(cagE6,
                       label: block_cagE6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagE6: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagl5_entry() //  [R1]
         { info_tbl: [(cagEi,
                       label: sat_sagl5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagEi: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wwithMVar_ragjT_entry() //  [R2, R3]
         { info_tbl: [(cagEp,
                       label: $wwithMVar_ragjT_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagEp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagEq; else goto cagEr;
       cagEq: // global
           R3 = R3;
           R2 = R2;
           R1 = $wwithMVar_ragjT_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagEr: // global
           I64[Sp - 24] = block_cagCU_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cagCU() //  [R1]
         { info_tbl: [(cagCU,
                       label: block_cagCU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagCU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cagEu; else goto cagEt;
       cagEu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cagEt: // global
           _sagks::P64 = P64[Sp + 8];
           if (R1 == 0) goto cagEn; else goto uagEN;
       cagEn: // global
           I64[Hp - 16] = sat_sagl0_info;
           P64[Hp - 8] = _sagks::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uagEN: // global
           if (R1 == 1) goto cagEo; else goto cagEm;
       cagEo: // global
           Hp = Hp - 24;
           I64[Sp] = block_cagDZ_info;
           R1 = _sagks::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cagEm: // global
           Hp = Hp - 24;
           I64[Sp] = block_cagCY_info;
           R1 = _sagks::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagDZ() //  [R1]
         { info_tbl: [(cagDZ,
                       label: block_cagDZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagDZ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cagEJ; else goto cagEI;
       cagEJ: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagEI: // global
           I64[Hp - 64] = sat_sagl9_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagl5_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cagEE_info;
           R2 = Hp - 62;
           _sagl3::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sagl3::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagEE() //  [R1]
         { info_tbl: [(cagEE,
                       label: block_cagEE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagEE: // global
           _sagks::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagEG_info;
           R2 = P64[Sp + 16];
           _saglc::P64 = R1;
           R1 = _sagks::P64;
           P64[Sp + 16] = _saglc::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagEG() //  []
         { info_tbl: [(cagEG,
                       label: block_cagEG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagEG: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cagCY() //  [R1]
         { info_tbl: [(cagCY,
                       label: block_cagCY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagCY: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cagEA; else goto cagEz;
       cagEA: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagEz: // global
           I64[Hp - 64] = sat_sagkH_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagkD_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cagEv_info;
           R2 = Hp - 62;
           _sagkB::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sagkB::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagEv() //  [R1]
         { info_tbl: [(cagEv,
                       label: block_cagEv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagEv: // global
           _sagks::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagEx_info;
           R2 = P64[Sp + 16];
           _sagkK::P64 = R1;
           R1 = _sagks::P64;
           P64[Sp + 16] = _sagkK::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagEx() //  []
         { info_tbl: [(cagEx,
                       label: block_cagEx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagEx: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.214600584 UTC

[section ""data" . withMVar1_ragjU_closure" {
     withMVar1_ragjU_closure:
         const withMVar1_ragjU_info;
 },
 withMVar1_ragjU_entry() //  [R2, R3]
         { info_tbl: [(cagEV,
                       label: withMVar1_ragjU_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagEV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagEW; else goto cagEX;
       cagEW: // global
           R3 = R3;
           R2 = R2;
           R1 = withMVar1_ragjU_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagEX: // global
           I64[Sp - 16] = block_cagES_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uagF1; else goto cagET;
       uagF1: // global
           call _cagES(R1) args: 0, res: 0, upd: 0;
       cagET: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagES() //  [R1]
         { info_tbl: [(cagES,
                       label: block_cagES_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagES: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wwithMVar_ragjT_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.215723974 UTC

[section ""data" . Control.Concurrent.MVar.withMVar_closure" {
     Control.Concurrent.MVar.withMVar_closure:
         const Control.Concurrent.MVar.withMVar_info;
 },
 Control.Concurrent.MVar.withMVar_entry() //  [R2, R3]
         { info_tbl: [(cagF6,
                       label: Control.Concurrent.MVar.withMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagF6: // global
           R3 = R3;
           R2 = R2;
           call withMVar1_ragjU_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.217393611 UTC

[section ""data" . $wwithMVarMasked_ragjV_closure" {
     $wwithMVarMasked_ragjV_closure:
         const $wwithMVarMasked_ragjV_info;
 },
 sat_sagly_entry() //  [R1, R2]
         { info_tbl: [(cagFt,
                       label: sat_sagly_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagFt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagFu; else goto cagFv;
       cagFu: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagFv: // global
           I64[Sp - 16] = block_cagFr_info;
           _saglv::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saglv::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagFr() //  []
         { info_tbl: [(cagFr,
                       label: block_cagFr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagFr: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saglu_entry() //  [R1]
         { info_tbl: [(cagFB,
                       label: sat_saglu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagFB: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saglp_entry() //  [R1]
         { info_tbl: [(cagFI,
                       label: io_saglp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagFI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagFJ; else goto cagFK;
       cagFJ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagFK: // global
           I64[Sp - 24] = block_cagFk_info;
           _saglj::P64 = P64[R1 + 7];
           _saglk::P64 = P64[R1 + 15];
           R1 = _saglj::P64;
           P64[Sp - 16] = _saglj::P64;
           P64[Sp - 8] = _saglk::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagFk() //  [R1]
         { info_tbl: [(cagFk,
                       label: block_cagFk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagFk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cagFN; else goto cagFM;
       cagFN: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagFM: // global
           I64[Hp - 48] = sat_sagly_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = R1;
           I64[Hp - 24] = sat_saglu_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp] = block_cagFE_info;
           R2 = Hp - 46;
           _saglt::P64 = R1;
           R1 = Hp - 24;
           P64[Sp + 16] = _saglt::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagFE() //  [R1]
         { info_tbl: [(cagFE,
                       label: block_cagFE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagFE: // global
           _saglj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagFG_info;
           R2 = P64[Sp + 16];
           _saglB::P64 = R1;
           R1 = _saglj::P64;
           P64[Sp + 16] = _saglB::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagFG() //  []
         { info_tbl: [(cagFG,
                       label: block_cagFG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagFG: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wwithMVarMasked_ragjV_entry() //  [R2, R3]
         { info_tbl: [(cagFU,
                       label: $wwithMVarMasked_ragjV_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagFU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagFV; else goto cagFW;
       cagFV: // global
           R3 = R3;
           R2 = R2;
           R1 = $wwithMVarMasked_ragjV_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagFW: // global
           I64[Sp - 24] = block_cagFd_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cagFd() //  [R1]
         { info_tbl: [(cagFd,
                       label: block_cagFd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagFd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cagFZ; else goto cagFY;
       cagFZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cagFY: // global
           I64[Hp - 16] = io_saglp_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _cagFf::P64 = Hp - 15;
           if (R1 == 0) goto cagFT; else goto cagFS;
       cagFT: // global
           R1 = _cagFf::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cagFS: // global
           R1 = _cagFf::P64;
           Sp = Sp + 24;
           call io_saglp_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.219957254 UTC

[section ""data" . withMVarMasked1_ragjW_closure" {
     withMVarMasked1_ragjW_closure:
         const withMVarMasked1_ragjW_info;
 },
 withMVarMasked1_ragjW_entry() //  [R2, R3]
         { info_tbl: [(cagG7,
                       label: withMVarMasked1_ragjW_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagG7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagG8; else goto cagG9;
       cagG8: // global
           R3 = R3;
           R2 = R2;
           R1 = withMVarMasked1_ragjW_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagG9: // global
           I64[Sp - 16] = block_cagG4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uagGd; else goto cagG5;
       uagGd: // global
           call _cagG4(R1) args: 0, res: 0, upd: 0;
       cagG5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagG4() //  [R1]
         { info_tbl: [(cagG4,
                       label: block_cagG4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagG4: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wwithMVarMasked_ragjV_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.221083654 UTC

[section ""data" . Control.Concurrent.MVar.withMVarMasked_closure" {
     Control.Concurrent.MVar.withMVarMasked_closure:
         const Control.Concurrent.MVar.withMVarMasked_info;
 },
 Control.Concurrent.MVar.withMVarMasked_entry() //  [R2, R3]
         { info_tbl: [(cagGi,
                       label: Control.Concurrent.MVar.withMVarMasked_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagGi: // global
           R3 = R3;
           R2 = R2;
           call withMVarMasked1_ragjW_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.223916516 UTC

[section ""data" . $wmodifyMVar__ragjX_closure" {
     $wmodifyMVar__ragjX_closure:
         const $wmodifyMVar__ragjX_info;
 },
 sat_saglY_entry() //  [R1, R2]
         { info_tbl: [(cagGC,
                       label: sat_saglY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagGC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagGD; else goto cagGE;
       cagGD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagGE: // global
           I64[Sp - 16] = block_cagGA_info;
           _saglV::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saglV::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagGA() //  []
         { info_tbl: [(cagGA,
                       label: block_cagGA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagGA: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saglU_entry() //  [R1]
         { info_tbl: [(cagGM,
                       label: sat_saglU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagGM: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagmc_entry() //  [R1, R2]
         { info_tbl: [(cagH4,
                       label: sat_sagmc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagH4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagH5; else goto cagH6;
       cagH5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagH6: // global
           I64[Sp - 16] = block_cagH2_info;
           _sagm9::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagm9::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagH2() //  []
         { info_tbl: [(cagH2,
                       label: block_cagH2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagH2: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagm8_entry() //  [R1]
         { info_tbl: [(cagHe,
                       label: sat_sagm8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagHe: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagmh_entry() //  [R1]
         { info_tbl: [(cagHl,
                       label: sat_sagmh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagHl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagHm; else goto cagHn;
       cagHm: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagHn: // global
           I64[Sp - 24] = block_cagGV_info;
           _saglJ::P64 = P64[R1 + 7];
           _saglK::P64 = P64[R1 + 15];
           R1 = _saglJ::P64;
           P64[Sp - 16] = _saglJ::P64;
           P64[Sp - 8] = _saglK::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagGV() //  [R1]
         { info_tbl: [(cagGV,
                       label: block_cagGV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagGV: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cagHq; else goto cagHp;
       cagHq: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagHp: // global
           I64[Hp - 64] = sat_sagmc_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagm8_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cagHh_info;
           R2 = Hp - 62;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagHh() //  [R1]
         { info_tbl: [(cagHh,
                       label: block_cagHh_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagHh: // global
           I64[Sp + 16] = block_cagHj_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagHj() //  []
         { info_tbl: [(cagHj,
                       label: block_cagHj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagHj: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagmq_entry() //  [R1, R2]
         { info_tbl: [(cagHD,
                       label: sat_sagmq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagHD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagHE; else goto cagHF;
       cagHE: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagHF: // global
           I64[Sp - 16] = block_cagHB_info;
           _sagmn::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagmn::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagHB() //  []
         { info_tbl: [(cagHB,
                       label: block_cagHB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagHB: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagmm_entry() //  [R1]
         { info_tbl: [(cagHN,
                       label: sat_sagmm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagHN: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wmodifyMVar__ragjX_entry() //  [R2, R3]
         { info_tbl: [(cagHU,
                       label: $wmodifyMVar__ragjX_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagHU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagHV; else goto cagHW;
       cagHV: // global
           R3 = R3;
           R2 = R2;
           R1 = $wmodifyMVar__ragjX_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagHW: // global
           I64[Sp - 24] = block_cagGp_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cagGp() //  [R1]
         { info_tbl: [(cagGp,
                       label: block_cagGp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagGp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cagHZ; else goto cagHY;
       cagHZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cagHY: // global
           _saglJ::P64 = P64[Sp + 8];
           if (R1 == 0) goto cagHS; else goto uagIi;
       cagHS: // global
           I64[Hp - 16] = sat_sagmh_info;
           P64[Hp - 8] = _saglJ::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uagIi: // global
           if (R1 == 1) goto cagHT; else goto cagHR;
       cagHT: // global
           Hp = Hp - 24;
           I64[Sp] = block_cagHu_info;
           R1 = _saglJ::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cagHR: // global
           Hp = Hp - 24;
           I64[Sp] = block_cagGt_info;
           R1 = _saglJ::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagHu() //  [R1]
         { info_tbl: [(cagHu,
                       label: block_cagHu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagHu: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cagIe; else goto cagId;
       cagIe: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagId: // global
           I64[Hp - 64] = sat_sagmq_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagmm_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cagI9_info;
           R2 = Hp - 62;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagI9() //  [R1]
         { info_tbl: [(cagI9,
                       label: block_cagI9_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagI9: // global
           I64[Sp + 16] = block_cagIb_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagGt() //  [R1]
         { info_tbl: [(cagGt,
                       label: block_cagGt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagGt: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cagI5; else goto cagI4;
       cagI5: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagI4: // global
           I64[Hp - 64] = sat_saglY_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saglU_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cagI0_info;
           R2 = Hp - 62;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagI0() //  [R1]
         { info_tbl: [(cagI0,
                       label: block_cagI0_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagI0: // global
           I64[Sp + 16] = block_cagIb_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagIb() //  []
         { info_tbl: [(cagIb,
                       label: block_cagIb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagIb: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.228403917 UTC

[section ""data" . modifyMVar_1_ragjY_closure" {
     modifyMVar_1_ragjY_closure:
         const modifyMVar_1_ragjY_info;
 },
 modifyMVar_1_ragjY_entry() //  [R2, R3]
         { info_tbl: [(cagIq,
                       label: modifyMVar_1_ragjY_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagIq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagIr; else goto cagIs;
       cagIr: // global
           R3 = R3;
           R2 = R2;
           R1 = modifyMVar_1_ragjY_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagIs: // global
           I64[Sp - 16] = block_cagIn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uagIw; else goto cagIo;
       uagIw: // global
           call _cagIn(R1) args: 0, res: 0, upd: 0;
       cagIo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagIn() //  [R1]
         { info_tbl: [(cagIn,
                       label: block_cagIn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagIn: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wmodifyMVar__ragjX_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.229553693 UTC

[section ""data" . Control.Concurrent.MVar.modifyMVar__closure" {
     Control.Concurrent.MVar.modifyMVar__closure:
         const Control.Concurrent.MVar.modifyMVar__info;
 },
 Control.Concurrent.MVar.modifyMVar__entry() //  [R2, R3]
         { info_tbl: [(cagIB,
                       label: Control.Concurrent.MVar.modifyMVar__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagIB: // global
           R3 = R3;
           R2 = R2;
           call modifyMVar_1_ragjY_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.232761217 UTC

[section ""data" . $wmodifyMVar_ragjZ_closure" {
     $wmodifyMVar_ragjZ_closure:
         const $wmodifyMVar_ragjZ_info;
 },
 sat_sagmT_entry() //  [R1, R2]
         { info_tbl: [(cagIV,
                       label: sat_sagmT_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagIV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagIW; else goto cagIX;
       cagIW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagIX: // global
           I64[Sp - 16] = block_cagIT_info;
           _sagmQ::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagmQ::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagIT() //  []
         { info_tbl: [(cagIT,
                       label: block_cagIT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagIT: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagmO_entry() //  [R1]
         { info_tbl: [(cagJ6,
                       label: sat_sagmO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagJ6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cagJ7; else goto cagJ8;
       cagJ7: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagJ8: // global
           I64[Sp - 8] = block_cagJ4_info;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagJ4() //  [R1]
         { info_tbl: [(cagJ4,
                       label: block_cagJ4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagJ4: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagmP_entry() //  [R1]
         { info_tbl: [(cagJf,
                       label: sat_sagmP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagJf: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagne_entry() //  [R1, R2]
         { info_tbl: [(cagJx,
                       label: sat_sagne_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagJx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagJy; else goto cagJz;
       cagJy: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagJz: // global
           I64[Sp - 16] = block_cagJv_info;
           _sagnb::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagnb::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagJv() //  []
         { info_tbl: [(cagJv,
                       label: block_cagJv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagJv: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagn9_entry() //  [R1]
         { info_tbl: [(cagJI,
                       label: sat_sagn9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagJI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cagJJ; else goto cagJK;
       cagJJ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagJK: // global
           I64[Sp - 8] = block_cagJG_info;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagJG() //  [R1]
         { info_tbl: [(cagJG,
                       label: block_cagJG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagJG: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagna_entry() //  [R1]
         { info_tbl: [(cagJR,
                       label: sat_sagna_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagJR: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagnm_entry() //  [R1]
         { info_tbl: [(cagJZ,
                       label: sat_sagnm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagJZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagK3; else goto cagK4;
       cagK3: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagK4: // global
           I64[Sp - 24] = block_cagJo_info;
           _sagmA::P64 = P64[R1 + 7];
           _sagmB::P64 = P64[R1 + 15];
           R1 = _sagmA::P64;
           P64[Sp - 16] = _sagmA::P64;
           P64[Sp - 8] = _sagmB::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagJo() //  [R1]
         { info_tbl: [(cagJo,
                       label: block_cagJo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagJo: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cagK7; else goto cagK6;
       cagK7: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagK6: // global
           I64[Hp - 56] = sat_sagne_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sagn9_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagna_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cagJU_info;
           R2 = Hp - 54;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagJU() //  [R1]
         { info_tbl: [(cagJU,
                       label: block_cagJU_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagJU: // global
           I64[Sp] = block_cagJW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uagKc; else goto cagJX;
       uagKc: // global
           call _cagJW(R1) args: 0, res: 0, upd: 0;
       cagJX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagJW() //  [R1]
         { info_tbl: [(cagJW,
                       label: block_cagJW_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagJW: // global
           _sagmA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagK2_info;
           R2 = P64[R1 + 7];
           _sagnk::P64 = P64[R1 + 15];
           R1 = _sagmA::P64;
           P64[Sp + 16] = _sagnk::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagK2() //  []
         { info_tbl: [(cagK2,
                       label: block_cagK2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagK2: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagnz_entry() //  [R1, R2]
         { info_tbl: [(cagKn,
                       label: sat_sagnz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagKn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagKo; else goto cagKp;
       cagKo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagKp: // global
           I64[Sp - 16] = block_cagKl_info;
           _sagnw::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagnw::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagKl() //  []
         { info_tbl: [(cagKl,
                       label: block_cagKl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagKl: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagnu_entry() //  [R1]
         { info_tbl: [(cagKy,
                       label: sat_sagnu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagKy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cagKz; else goto cagKA;
       cagKz: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagKA: // global
           I64[Sp - 8] = block_cagKw_info;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagKw() //  [R1]
         { info_tbl: [(cagKw,
                       label: block_cagKw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagKw: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagnv_entry() //  [R1]
         { info_tbl: [(cagKH,
                       label: sat_sagnv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagKH: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wmodifyMVar_ragjZ_entry() //  [R2, R3]
         { info_tbl: [(cagKO,
                       label: $wmodifyMVar_ragjZ_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagKO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagKP; else goto cagKQ;
       cagKP: // global
           R3 = R3;
           R2 = R2;
           R1 = $wmodifyMVar_ragjZ_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagKQ: // global
           I64[Sp - 24] = block_cagII_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cagII() //  [R1]
         { info_tbl: [(cagII,
                       label: block_cagII_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagII: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cagKT; else goto cagKS;
       cagKT: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cagKS: // global
           _sagmA::P64 = P64[Sp + 8];
           if (R1 == 0) goto cagKM; else goto uagLo;
       cagKM: // global
           I64[Hp - 16] = sat_sagnm_info;
           P64[Hp - 8] = _sagmA::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uagLo: // global
           if (R1 == 1) goto cagKN; else goto cagKL;
       cagKN: // global
           Hp = Hp - 24;
           I64[Sp] = block_cagKe_info;
           R1 = _sagmA::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cagKL: // global
           Hp = Hp - 24;
           I64[Sp] = block_cagIM_info;
           R1 = _sagmA::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagKe() //  [R1]
         { info_tbl: [(cagKe,
                       label: block_cagKe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagKe: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cagLj; else goto cagLi;
       cagLj: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagLi: // global
           I64[Hp - 56] = sat_sagnz_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sagnu_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagnv_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cagL9_info;
           R2 = Hp - 54;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagL9() //  [R1]
         { info_tbl: [(cagL9,
                       label: block_cagL9_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagL9: // global
           I64[Sp] = block_cagLb_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uagLq; else goto cagLc;
       uagLq: // global
           call _cagLb(R1) args: 0, res: 0, upd: 0;
       cagLc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagLb() //  [R1]
         { info_tbl: [(cagLb,
                       label: block_cagLb_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagLb: // global
           _sagmA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagLg_info;
           R2 = P64[R1 + 7];
           _sagnF::P64 = P64[R1 + 15];
           R1 = _sagmA::P64;
           P64[Sp + 16] = _sagnF::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagLg() //  []
         { info_tbl: [(cagLg,
                       label: block_cagLg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagLg: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cagIM() //  [R1]
         { info_tbl: [(cagIM,
                       label: block_cagIM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagIM: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cagL4; else goto cagL3;
       cagL4: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagL3: // global
           I64[Hp - 56] = sat_sagmT_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sagmO_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagmP_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cagKU_info;
           R2 = Hp - 54;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagKU() //  [R1]
         { info_tbl: [(cagKU,
                       label: block_cagKU_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagKU: // global
           I64[Sp] = block_cagKW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uagLp; else goto cagKX;
       uagLp: // global
           call _cagKW(R1) args: 0, res: 0, upd: 0;
       cagKX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagKW() //  [R1]
         { info_tbl: [(cagKW,
                       label: block_cagKW_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagKW: // global
           _sagmA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagL1_info;
           R2 = P64[R1 + 7];
           _sagmZ::P64 = P64[R1 + 15];
           R1 = _sagmA::P64;
           P64[Sp + 16] = _sagmZ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagL1() //  []
         { info_tbl: [(cagL1,
                       label: block_cagL1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagL1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.239100745 UTC

[section ""data" . modifyMVar1_ragk0_closure" {
     modifyMVar1_ragk0_closure:
         const modifyMVar1_ragk0_info;
 },
 modifyMVar1_ragk0_entry() //  [R2, R3]
         { info_tbl: [(cagLy,
                       label: modifyMVar1_ragk0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagLy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagLz; else goto cagLA;
       cagLz: // global
           R3 = R3;
           R2 = R2;
           R1 = modifyMVar1_ragk0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagLA: // global
           I64[Sp - 16] = block_cagLv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uagLE; else goto cagLw;
       uagLE: // global
           call _cagLv(R1) args: 0, res: 0, upd: 0;
       cagLw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagLv() //  [R1]
         { info_tbl: [(cagLv,
                       label: block_cagLv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagLv: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wmodifyMVar_ragjZ_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.240170988 UTC

[section ""data" . Control.Concurrent.MVar.modifyMVar_closure" {
     Control.Concurrent.MVar.modifyMVar_closure:
         const Control.Concurrent.MVar.modifyMVar_info;
 },
 Control.Concurrent.MVar.modifyMVar_entry() //  [R2, R3]
         { info_tbl: [(cagLJ,
                       label: Control.Concurrent.MVar.modifyMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagLJ: // global
           R3 = R3;
           R2 = R2;
           call modifyMVar1_ragk0_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.241781041 UTC

[section ""data" . $wmodifyMVarMasked__ragk1_closure" {
     $wmodifyMVarMasked__ragk1_closure:
         const $wmodifyMVarMasked__ragk1_info;
 },
 sat_sago1_entry() //  [R1, R2]
         { info_tbl: [(cagM6,
                       label: sat_sago1_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagM6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagM7; else goto cagM8;
       cagM7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagM8: // global
           I64[Sp - 16] = block_cagM4_info;
           _sagnY::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagnY::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagM4() //  []
         { info_tbl: [(cagM4,
                       label: block_cagM4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagM4: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagnX_entry() //  [R1]
         { info_tbl: [(cagMe,
                       label: sat_sagnX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagMe: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sagnS_entry() //  [R1]
         { info_tbl: [(cagMl,
                       label: io_sagnS_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagMl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagMm; else goto cagMn;
       cagMm: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagMn: // global
           I64[Sp - 24] = block_cagLX_info;
           _sagnM::P64 = P64[R1 + 7];
           _sagnN::P64 = P64[R1 + 15];
           R1 = _sagnM::P64;
           P64[Sp - 16] = _sagnM::P64;
           P64[Sp - 8] = _sagnN::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagLX() //  [R1]
         { info_tbl: [(cagLX,
                       label: block_cagLX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagLX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cagMq; else goto cagMp;
       cagMq: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagMp: // global
           I64[Hp - 48] = sat_sago1_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = R1;
           I64[Hp - 24] = sat_sagnX_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp] = block_cagMh_info;
           R2 = Hp - 46;
           R1 = Hp - 24;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagMh() //  [R1]
         { info_tbl: [(cagMh,
                       label: block_cagMh_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagMh: // global
           I64[Sp + 16] = block_cagMj_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagMj() //  []
         { info_tbl: [(cagMj,
                       label: block_cagMj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagMj: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wmodifyMVarMasked__ragk1_entry() //  [R2, R3]
         { info_tbl: [(cagMx,
                       label: $wmodifyMVarMasked__ragk1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagMx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagMy; else goto cagMz;
       cagMy: // global
           R3 = R3;
           R2 = R2;
           R1 = $wmodifyMVarMasked__ragk1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagMz: // global
           I64[Sp - 24] = block_cagLQ_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cagLQ() //  [R1]
         { info_tbl: [(cagLQ,
                       label: block_cagLQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagLQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cagMC; else goto cagMB;
       cagMC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cagMB: // global
           I64[Hp - 16] = io_sagnS_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _cagLS::P64 = Hp - 15;
           if (R1 == 0) goto cagMw; else goto cagMv;
       cagMw: // global
           R1 = _cagLS::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cagMv: // global
           R1 = _cagLS::P64;
           Sp = Sp + 24;
           call io_sagnS_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.244367974 UTC

[section ""data" . modifyMVarMasked_1_ragk2_closure" {
     modifyMVarMasked_1_ragk2_closure:
         const modifyMVarMasked_1_ragk2_info;
 },
 modifyMVarMasked_1_ragk2_entry() //  [R2, R3]
         { info_tbl: [(cagMK,
                       label: modifyMVarMasked_1_ragk2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagMK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagML; else goto cagMM;
       cagML: // global
           R3 = R3;
           R2 = R2;
           R1 = modifyMVarMasked_1_ragk2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagMM: // global
           I64[Sp - 16] = block_cagMH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uagMQ; else goto cagMI;
       uagMQ: // global
           call _cagMH(R1) args: 0, res: 0, upd: 0;
       cagMI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagMH() //  [R1]
         { info_tbl: [(cagMH,
                       label: block_cagMH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagMH: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wmodifyMVarMasked__ragk1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.245620799 UTC

[section ""data" . Control.Concurrent.MVar.modifyMVarMasked__closure" {
     Control.Concurrent.MVar.modifyMVarMasked__closure:
         const Control.Concurrent.MVar.modifyMVarMasked__info;
 },
 Control.Concurrent.MVar.modifyMVarMasked__entry() //  [R2, R3]
         { info_tbl: [(cagMV,
                       label: Control.Concurrent.MVar.modifyMVarMasked__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagMV: // global
           R3 = R3;
           R2 = R2;
           call modifyMVarMasked_1_ragk2_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.24735214 UTC

[section ""data" . $wmodifyMVarMasked_ragk3_closure" {
     $wmodifyMVarMasked_ragk3_closure:
         const $wmodifyMVarMasked_ragk3_info;
 },
 sat_sagov_entry() //  [R1, R2]
         { info_tbl: [(cagNi,
                       label: sat_sagov_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagNi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagNj; else goto cagNk;
       cagNj: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagNk: // global
           I64[Sp - 16] = block_cagNg_info;
           _sagos::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagos::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagNg() //  []
         { info_tbl: [(cagNg,
                       label: block_cagNg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagNg: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagor_entry() //  [R1]
         { info_tbl: [(cagNt,
                       label: sat_sagor_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagNt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cagNu; else goto cagNv;
       cagNu: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagNv: // global
           I64[Sp - 8] = block_cagNr_info;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagNr() //  [R1]
         { info_tbl: [(cagNr,
                       label: block_cagNr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagNr: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sagoi_entry() //  [R1]
         { info_tbl: [(cagNC,
                       label: io_sagoi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagNC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagNG; else goto cagNH;
       cagNG: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagNH: // global
           I64[Sp - 24] = block_cagN9_info;
           _sagoc::P64 = P64[R1 + 7];
           _sagod::P64 = P64[R1 + 15];
           R1 = _sagoc::P64;
           P64[Sp - 16] = _sagoc::P64;
           P64[Sp - 8] = _sagod::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagN9() //  [R1]
         { info_tbl: [(cagN9,
                       label: block_cagN9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagN9: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cagNK; else goto cagNJ;
       cagNK: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagNJ: // global
           I64[Hp - 40] = sat_sagov_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sagor_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp] = block_cagNx_info;
           R2 = Hp - 38;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagNx() //  [R1]
         { info_tbl: [(cagNx,
                       label: block_cagNx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagNx: // global
           I64[Sp] = block_cagNz_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uagNP; else goto cagNA;
       uagNP: // global
           call _cagNz(R1) args: 0, res: 0, upd: 0;
       cagNA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagNz() //  [R1]
         { info_tbl: [(cagNz,
                       label: block_cagNz_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagNz: // global
           _sagoc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagNF_info;
           R2 = P64[R1 + 7];
           _sagoB::P64 = P64[R1 + 15];
           R1 = _sagoc::P64;
           P64[Sp + 16] = _sagoB::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagNF() //  []
         { info_tbl: [(cagNF,
                       label: block_cagNF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagNF: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wmodifyMVarMasked_ragk3_entry() //  [R2, R3]
         { info_tbl: [(cagNU,
                       label: $wmodifyMVarMasked_ragk3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagNU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagNV; else goto cagNW;
       cagNV: // global
           R3 = R3;
           R2 = R2;
           R1 = $wmodifyMVarMasked_ragk3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagNW: // global
           I64[Sp - 24] = block_cagN2_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cagN2() //  [R1]
         { info_tbl: [(cagN2,
                       label: block_cagN2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagN2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cagNZ; else goto cagNY;
       cagNZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cagNY: // global
           I64[Hp - 16] = io_sagoi_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _cagN4::P64 = Hp - 15;
           if (R1 == 0) goto cagNT; else goto cagNS;
       cagNT: // global
           R1 = _cagN4::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cagNS: // global
           R1 = _cagN4::P64;
           Sp = Sp + 24;
           call io_sagoi_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.250333259 UTC

[section ""data" . modifyMVarMasked1_ragk4_closure" {
     modifyMVarMasked1_ragk4_closure:
         const modifyMVarMasked1_ragk4_info;
 },
 modifyMVarMasked1_ragk4_entry() //  [R2, R3]
         { info_tbl: [(cagO7,
                       label: modifyMVarMasked1_ragk4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagO7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagO8; else goto cagO9;
       cagO8: // global
           R3 = R3;
           R2 = R2;
           R1 = modifyMVarMasked1_ragk4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagO9: // global
           I64[Sp - 16] = block_cagO4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uagOd; else goto cagO5;
       uagOd: // global
           call _cagO4(R1) args: 0, res: 0, upd: 0;
       cagO5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagO4() //  [R1]
         { info_tbl: [(cagO4,
                       label: block_cagO4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagO4: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wmodifyMVarMasked_ragk3_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.251417296 UTC

[section ""data" . Control.Concurrent.MVar.modifyMVarMasked_closure" {
     Control.Concurrent.MVar.modifyMVarMasked_closure:
         const Control.Concurrent.MVar.modifyMVarMasked_info;
 },
 Control.Concurrent.MVar.modifyMVarMasked_entry() //  [R2, R3]
         { info_tbl: [(cagOi,
                       label: Control.Concurrent.MVar.modifyMVarMasked_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagOi: // global
           R3 = R3;
           R2 = R2;
           call modifyMVarMasked1_ragk4_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.252241107 UTC

[section ""data" . Control.Concurrent.MVar.addMVarFinalizer_closure" {
     Control.Concurrent.MVar.addMVarFinalizer_closure:
         const Control.Concurrent.MVar.addMVarFinalizer_info;
 },
 Control.Concurrent.MVar.addMVarFinalizer_entry() //  [R2, R3]
         { info_tbl: [(cagOp,
                       label: Control.Concurrent.MVar.addMVarFinalizer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagOp: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.addMVarFinalizer1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.253305037 UTC

[section ""data" . Control.Concurrent.MVar.mkWeakMVar1_closure" {
     Control.Concurrent.MVar.mkWeakMVar1_closure:
         const Control.Concurrent.MVar.mkWeakMVar1_info;
 },
 Control.Concurrent.MVar.mkWeakMVar1_entry() //  [R2, R3]
         { info_tbl: [(cagOz,
                       label: Control.Concurrent.MVar.mkWeakMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagOz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagOF; else goto cagOG;
       cagOF: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.MVar.mkWeakMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagOG: // global
           I64[Sp - 16] = block_cagOw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uagOL; else goto cagOx;
       uagOL: // global
           call _cagOw(R1) args: 0, res: 0, upd: 0;
       cagOx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagOw() //  [R1]
         { info_tbl: [(cagOw,
                       label: block_cagOw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagOw: // global
           _sagoK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagOC_info;
           R3 = _sagoK::P64;
           R2 = R1;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagOC() //  [R1]
         { info_tbl: [(cagOC,
                       label: block_cagOC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagOC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cagOK; else goto cagOJ;
       cagOK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagOJ: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.254715365 UTC

[section ""data" . Control.Concurrent.MVar.mkWeakMVar_closure" {
     Control.Concurrent.MVar.mkWeakMVar_closure:
         const Control.Concurrent.MVar.mkWeakMVar_info;
 },
 Control.Concurrent.MVar.mkWeakMVar_entry() //  [R2, R3]
         { info_tbl: [(cagOQ,
                       label: Control.Concurrent.MVar.mkWeakMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagOQ: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.MVar.mkWeakMVar1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.255433489 UTC

[section ""cstring" . Control.Concurrent.MVar.$trModule4_bytes" {
     Control.Concurrent.MVar.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.25603734 UTC

[section ""data" . Control.Concurrent.MVar.$trModule3_closure" {
     Control.Concurrent.MVar.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.MVar.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.256596828 UTC

[section ""cstring" . Control.Concurrent.MVar.$trModule2_bytes" {
     Control.Concurrent.MVar.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.257156892 UTC

[section ""data" . Control.Concurrent.MVar.$trModule1_closure" {
     Control.Concurrent.MVar.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.MVar.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.257842629 UTC

[section ""data" . Control.Concurrent.MVar.$trModule_closure" {
     Control.Concurrent.MVar.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.MVar.$trModule3_closure+1;
         const Control.Concurrent.MVar.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.258454115 UTC

[section ""relreadonly" . SagBS_srt" { SagBS_srt:
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.261480518 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:17.263269243 UTC

[section ""data" . Control.Concurrent.MVar.$wswapMVar_closure" {
     Control.Concurrent.MVar.$wswapMVar_closure:
         const Control.Concurrent.MVar.$wswapMVar_info;
 },
 sat_sagkm_entry() //  [R1]
         { info_tbl: [(cagPb,
                       label: sat_sagkm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagPb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagPc; else goto cagPd;
       cagPc: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagPd: // global
           I64[Sp - 24] = block_cagP7_info;
           _sagk6::P64 = P64[R1 + 7];
           _sagk7::P64 = P64[R1 + 15];
           R1 = _sagk6::P64;
           P64[Sp - 16] = _sagk6::P64;
           P64[Sp - 8] = _sagk7::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagP7() //  [R1]
         { info_tbl: [(cagP7,
                       label: block_cagP7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagP7: // global
           _sagk6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagP9_info;
           R2 = P64[Sp + 16];
           _sagkk::P64 = R1;
           R1 = _sagk6::P64;
           P64[Sp + 16] = _sagkk::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagP9() //  []
         { info_tbl: [(cagP9,
                       label: block_cagP9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagP9: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.MVar.$wswapMVar_entry() //  [R2, R3]
         { info_tbl: [(cagPj,
                       label: Control.Concurrent.MVar.$wswapMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagPj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagPk; else goto cagPl;
       cagPk: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.MVar.$wswapMVar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagPl: // global
           I64[Sp - 24] = block_cagOX_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cagOX() //  [R1]
         { info_tbl: [(cagOX,
                       label: block_cagOX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagOX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cagPo; else goto cagPn;
       cagPo: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cagPn: // global
           _sagk6::P64 = P64[Sp + 8];
           if (R1 == 0) goto cagPi; else goto cagPh;
       cagPi: // global
           I64[Hp - 16] = sat_sagkm_info;
           P64[Hp - 8] = _sagk6::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cagPh: // global
           Hp = Hp - 24;
           I64[Sp] = block_cagPp_info;
           R1 = _sagk6::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagPp() //  [R1]
         { info_tbl: [(cagPp,
                       label: block_cagPp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagPp: // global
           _sagk6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagPr_info;
           R2 = P64[Sp + 16];
           _sagkf::P64 = R1;
           R1 = _sagk6::P64;
           P64[Sp + 16] = _sagkf::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagPr() //  []
         { info_tbl: [(cagPr,
                       label: block_cagPr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagPr: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.277117215 UTC

[section ""data" . Control.Concurrent.MVar.swapMVar1_closure" {
     Control.Concurrent.MVar.swapMVar1_closure:
         const Control.Concurrent.MVar.swapMVar1_info;
 },
 Control.Concurrent.MVar.swapMVar1_entry() //  [R2, R3]
         { info_tbl: [(cagQ3,
                       label: Control.Concurrent.MVar.swapMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagQ3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagQ4; else goto cagQ5;
       cagQ4: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.MVar.swapMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagQ5: // global
           I64[Sp - 16] = block_cagQ0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uagQ9; else goto cagQ1;
       uagQ9: // global
           call _cagQ0(R1) args: 0, res: 0, upd: 0;
       cagQ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagQ0() //  [R1]
         { info_tbl: [(cagQ0,
                       label: block_cagQ0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagQ0: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call Control.Concurrent.MVar.$wswapMVar_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.282879529 UTC

[section ""data" . Control.Concurrent.MVar.swapMVar_closure" {
     Control.Concurrent.MVar.swapMVar_closure:
         const Control.Concurrent.MVar.swapMVar_info;
 },
 Control.Concurrent.MVar.swapMVar_entry() //  [R2, R3]
         { info_tbl: [(cagQn,
                       label: Control.Concurrent.MVar.swapMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagQn: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.MVar.swapMVar1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.287940239 UTC

[section ""data" . $wwithMVar_ragjT_closure" {
     $wwithMVar_ragjT_closure:
         const $wwithMVar_ragjT_info;
 },
 sat_sagkH_entry() //  [R1, R2]
         { info_tbl: [(cagQL,
                       label: sat_sagkH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagQL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagQM; else goto cagQN;
       cagQM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagQN: // global
           I64[Sp - 16] = block_cagQJ_info;
           _sagkE::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagkE::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagQJ() //  []
         { info_tbl: [(cagQJ,
                       label: block_cagQJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagQJ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagkD_entry() //  [R1]
         { info_tbl: [(cagQV,
                       label: sat_sagkD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagQV: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagkV_entry() //  [R1, R2]
         { info_tbl: [(cagRd,
                       label: sat_sagkV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagRd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagRe; else goto cagRf;
       cagRe: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagRf: // global
           I64[Sp - 16] = block_cagRb_info;
           _sagkS::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagkS::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagRb() //  []
         { info_tbl: [(cagRb,
                       label: block_cagRb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagRb: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagkR_entry() //  [R1]
         { info_tbl: [(cagRn,
                       label: sat_sagkR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagRn: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagl0_entry() //  [R1]
         { info_tbl: [(cagRu,
                       label: sat_sagl0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagRu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagRv; else goto cagRw;
       cagRv: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagRw: // global
           I64[Sp - 24] = block_cagR4_info;
           _sagks::P64 = P64[R1 + 7];
           _sagkt::P64 = P64[R1 + 15];
           R1 = _sagks::P64;
           P64[Sp - 16] = _sagks::P64;
           P64[Sp - 8] = _sagkt::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagR4() //  [R1]
         { info_tbl: [(cagR4,
                       label: block_cagR4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagR4: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cagRz; else goto cagRy;
       cagRz: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagRy: // global
           I64[Hp - 64] = sat_sagkV_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagkR_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cagRq_info;
           R2 = Hp - 62;
           _sagkP::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sagkP::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagRq() //  [R1]
         { info_tbl: [(cagRq,
                       label: block_cagRq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagRq: // global
           _sagks::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagRs_info;
           R2 = P64[Sp + 16];
           _sagkY::P64 = R1;
           R1 = _sagks::P64;
           P64[Sp + 16] = _sagkY::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagRs() //  []
         { info_tbl: [(cagRs,
                       label: block_cagRs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagRs: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagl9_entry() //  [R1, R2]
         { info_tbl: [(cagRM,
                       label: sat_sagl9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagRM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagRN; else goto cagRO;
       cagRN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagRO: // global
           I64[Sp - 16] = block_cagRK_info;
           _sagl6::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagl6::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagRK() //  []
         { info_tbl: [(cagRK,
                       label: block_cagRK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagRK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagl5_entry() //  [R1]
         { info_tbl: [(cagRW,
                       label: sat_sagl5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagRW: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wwithMVar_ragjT_entry() //  [R2, R3]
         { info_tbl: [(cagS3,
                       label: $wwithMVar_ragjT_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagS3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagS4; else goto cagS5;
       cagS4: // global
           R3 = R3;
           R2 = R2;
           R1 = $wwithMVar_ragjT_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagS5: // global
           I64[Sp - 24] = block_cagQy_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cagQy() //  [R1]
         { info_tbl: [(cagQy,
                       label: block_cagQy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagQy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cagS8; else goto cagS7;
       cagS8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cagS7: // global
           _sagks::P64 = P64[Sp + 8];
           if (R1 == 0) goto cagS1; else goto uagSr;
       cagS1: // global
           I64[Hp - 16] = sat_sagl0_info;
           P64[Hp - 8] = _sagks::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uagSr: // global
           if (R1 == 1) goto cagS2; else goto cagS0;
       cagS2: // global
           Hp = Hp - 24;
           I64[Sp] = block_cagRD_info;
           R1 = _sagks::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cagS0: // global
           Hp = Hp - 24;
           I64[Sp] = block_cagQC_info;
           R1 = _sagks::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagRD() //  [R1]
         { info_tbl: [(cagRD,
                       label: block_cagRD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagRD: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cagSn; else goto cagSm;
       cagSn: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagSm: // global
           I64[Hp - 64] = sat_sagl9_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagl5_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cagSi_info;
           R2 = Hp - 62;
           _sagl3::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sagl3::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagSi() //  [R1]
         { info_tbl: [(cagSi,
                       label: block_cagSi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagSi: // global
           _sagks::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagSk_info;
           R2 = P64[Sp + 16];
           _saglc::P64 = R1;
           R1 = _sagks::P64;
           P64[Sp + 16] = _saglc::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagSk() //  []
         { info_tbl: [(cagSk,
                       label: block_cagSk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagSk: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cagQC() //  [R1]
         { info_tbl: [(cagQC,
                       label: block_cagQC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagQC: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cagSe; else goto cagSd;
       cagSe: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagSd: // global
           I64[Hp - 64] = sat_sagkH_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagkD_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cagS9_info;
           R2 = Hp - 62;
           _sagkB::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sagkB::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagS9() //  [R1]
         { info_tbl: [(cagS9,
                       label: block_cagS9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagS9: // global
           _sagks::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagSb_info;
           R2 = P64[Sp + 16];
           _sagkK::P64 = R1;
           R1 = _sagks::P64;
           P64[Sp + 16] = _sagkK::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagSb() //  []
         { info_tbl: [(cagSb,
                       label: block_cagSb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagSb: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.327329215 UTC

[section ""data" . withMVar1_ragjU_closure" {
     withMVar1_ragjU_closure:
         const withMVar1_ragjU_info;
 },
 withMVar1_ragjU_entry() //  [R2, R3]
         { info_tbl: [(cagTT,
                       label: withMVar1_ragjU_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagTT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagTU; else goto cagTV;
       cagTU: // global
           R3 = R3;
           R2 = R2;
           R1 = withMVar1_ragjU_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagTV: // global
           I64[Sp - 16] = block_cagTQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uagTZ; else goto cagTR;
       uagTZ: // global
           call _cagTQ(R1) args: 0, res: 0, upd: 0;
       cagTR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagTQ() //  [R1]
         { info_tbl: [(cagTQ,
                       label: block_cagTQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagTQ: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wwithMVar_ragjT_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.332598547 UTC

[section ""data" . Control.Concurrent.MVar.withMVar_closure" {
     Control.Concurrent.MVar.withMVar_closure:
         const Control.Concurrent.MVar.withMVar_info;
 },
 Control.Concurrent.MVar.withMVar_entry() //  [R2, R3]
         { info_tbl: [(cagUd,
                       label: Control.Concurrent.MVar.withMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagUd: // global
           R3 = R3;
           R2 = R2;
           call withMVar1_ragjU_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.337095925 UTC

[section ""data" . $wwithMVarMasked_ragjV_closure" {
     $wwithMVarMasked_ragjV_closure:
         const $wwithMVarMasked_ragjV_info;
 },
 sat_sagly_entry() //  [R1, R2]
         { info_tbl: [(cagUE,
                       label: sat_sagly_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagUE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagUF; else goto cagUG;
       cagUF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagUG: // global
           I64[Sp - 16] = block_cagUC_info;
           _saglv::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saglv::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagUC() //  []
         { info_tbl: [(cagUC,
                       label: block_cagUC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagUC: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saglu_entry() //  [R1]
         { info_tbl: [(cagUM,
                       label: sat_saglu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagUM: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saglp_entry() //  [R1]
         { info_tbl: [(cagUT,
                       label: io_saglp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagUT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagUU; else goto cagUV;
       cagUU: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagUV: // global
           I64[Sp - 24] = block_cagUv_info;
           _saglj::P64 = P64[R1 + 7];
           _saglk::P64 = P64[R1 + 15];
           R1 = _saglj::P64;
           P64[Sp - 16] = _saglj::P64;
           P64[Sp - 8] = _saglk::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagUv() //  [R1]
         { info_tbl: [(cagUv,
                       label: block_cagUv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagUv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cagUY; else goto cagUX;
       cagUY: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagUX: // global
           I64[Hp - 48] = sat_sagly_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = R1;
           I64[Hp - 24] = sat_saglu_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp] = block_cagUP_info;
           R2 = Hp - 46;
           _saglt::P64 = R1;
           R1 = Hp - 24;
           P64[Sp + 16] = _saglt::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagUP() //  [R1]
         { info_tbl: [(cagUP,
                       label: block_cagUP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagUP: // global
           _saglj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cagUR_info;
           R2 = P64[Sp + 16];
           _saglB::P64 = R1;
           R1 = _saglj::P64;
           P64[Sp + 16] = _saglB::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagUR() //  []
         { info_tbl: [(cagUR,
                       label: block_cagUR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagUR: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wwithMVarMasked_ragjV_entry() //  [R2, R3]
         { info_tbl: [(cagV5,
                       label: $wwithMVarMasked_ragjV_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagV5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagV6; else goto cagV7;
       cagV6: // global
           R3 = R3;
           R2 = R2;
           R1 = $wwithMVarMasked_ragjV_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagV7: // global
           I64[Sp - 24] = block_cagUo_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cagUo() //  [R1]
         { info_tbl: [(cagUo,
                       label: block_cagUo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagUo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cagVa; else goto cagV9;
       cagVa: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cagV9: // global
           I64[Hp - 16] = io_saglp_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _cagUq::P64 = Hp - 15;
           if (R1 == 0) goto cagV4; else goto cagV3;
       cagV4: // global
           R1 = _cagUq::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cagV3: // global
           R1 = _cagUq::P64;
           Sp = Sp + 24;
           call io_saglp_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.355037993 UTC

[section ""data" . withMVarMasked1_ragjW_closure" {
     withMVarMasked1_ragjW_closure:
         const withMVarMasked1_ragjW_info;
 },
 withMVarMasked1_ragjW_entry() //  [R2, R3]
         { info_tbl: [(cagVS,
                       label: withMVarMasked1_ragjW_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagVS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagVT; else goto cagVU;
       cagVT: // global
           R3 = R3;
           R2 = R2;
           R1 = withMVarMasked1_ragjW_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagVU: // global
           I64[Sp - 16] = block_cagVP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uagVY; else goto cagVQ;
       uagVY: // global
           call _cagVP(R1) args: 0, res: 0, upd: 0;
       cagVQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagVP() //  [R1]
         { info_tbl: [(cagVP,
                       label: block_cagVP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagVP: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wwithMVarMasked_ragjV_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.360340818 UTC

[section ""data" . Control.Concurrent.MVar.withMVarMasked_closure" {
     Control.Concurrent.MVar.withMVarMasked_closure:
         const Control.Concurrent.MVar.withMVarMasked_info;
 },
 Control.Concurrent.MVar.withMVarMasked_entry() //  [R2, R3]
         { info_tbl: [(cagWc,
                       label: Control.Concurrent.MVar.withMVarMasked_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagWc: // global
           R3 = R3;
           R2 = R2;
           call withMVarMasked1_ragjW_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.365775028 UTC

[section ""data" . $wmodifyMVar__ragjX_closure" {
     $wmodifyMVar__ragjX_closure:
         const $wmodifyMVar__ragjX_info;
 },
 sat_saglY_entry() //  [R1, R2]
         { info_tbl: [(cagWA,
                       label: sat_saglY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagWA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagWB; else goto cagWC;
       cagWB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagWC: // global
           I64[Sp - 16] = block_cagWy_info;
           _saglV::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _saglV::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagWy() //  []
         { info_tbl: [(cagWy,
                       label: block_cagWy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagWy: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saglU_entry() //  [R1]
         { info_tbl: [(cagWK,
                       label: sat_saglU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagWK: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagmc_entry() //  [R1, R2]
         { info_tbl: [(cagX2,
                       label: sat_sagmc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagX2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagX3; else goto cagX4;
       cagX3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagX4: // global
           I64[Sp - 16] = block_cagX0_info;
           _sagm9::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagm9::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagX0() //  []
         { info_tbl: [(cagX0,
                       label: block_cagX0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagX0: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagm8_entry() //  [R1]
         { info_tbl: [(cagXc,
                       label: sat_sagm8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagXc: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagmh_entry() //  [R1]
         { info_tbl: [(cagXj,
                       label: sat_sagmh_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagXj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagXk; else goto cagXl;
       cagXk: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cagXl: // global
           I64[Sp - 24] = block_cagWT_info;
           _saglJ::P64 = P64[R1 + 7];
           _saglK::P64 = P64[R1 + 15];
           R1 = _saglJ::P64;
           P64[Sp - 16] = _saglJ::P64;
           P64[Sp - 8] = _saglK::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagWT() //  [R1]
         { info_tbl: [(cagWT,
                       label: block_cagWT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagWT: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cagXo; else goto cagXn;
       cagXo: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagXn: // global
           I64[Hp - 64] = sat_sagmc_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagm8_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cagXf_info;
           R2 = Hp - 62;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagXf() //  [R1]
         { info_tbl: [(cagXf,
                       label: block_cagXf_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagXf: // global
           I64[Sp + 16] = block_cagXh_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagXh() //  []
         { info_tbl: [(cagXh,
                       label: block_cagXh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagXh: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagmq_entry() //  [R1, R2]
         { info_tbl: [(cagXB,
                       label: sat_sagmq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagXB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagXC; else goto cagXD;
       cagXC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cagXD: // global
           I64[Sp - 16] = block_cagXz_info;
           _sagmn::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagmn::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagXz() //  []
         { info_tbl: [(cagXz,
                       label: block_cagXz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagXz: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagmm_entry() //  [R1]
         { info_tbl: [(cagXL,
                       label: sat_sagmm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagXL: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wmodifyMVar__ragjX_entry() //  [R2, R3]
         { info_tbl: [(cagXS,
                       label: $wmodifyMVar__ragjX_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagXS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cagXT; else goto cagXU;
       cagXT: // global
           R3 = R3;
           R2 = R2;
           R1 = $wmodifyMVar__ragjX_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagXU: // global
           I64[Sp - 24] = block_cagWn_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cagWn() //  [R1]
         { info_tbl: [(cagWn,
                       label: block_cagWn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagWn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cagXX; else goto cagXW;
       cagXX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cagXW: // global
           _saglJ::P64 = P64[Sp + 8];
           if (R1 == 0) goto cagXQ; else goto uagYg;
       cagXQ: // global
           I64[Hp - 16] = sat_sagmh_info;
           P64[Hp - 8] = _saglJ::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uagYg: // global
           if (R1 == 1) goto cagXR; else goto cagXP;
       cagXR: // global
           Hp = Hp - 24;
           I64[Sp] = block_cagXs_info;
           R1 = _saglJ::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cagXP: // global
           Hp = Hp - 24;
           I64[Sp] = block_cagWr_info;
           R1 = _saglJ::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagXs() //  [R1]
         { info_tbl: [(cagXs,
                       label: block_cagXs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagXs: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cagYc; else goto cagYb;
       cagYc: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagYb: // global
           I64[Hp - 64] = sat_sagmq_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagmm_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cagY7_info;
           R2 = Hp - 62;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagY7() //  [R1]
         { info_tbl: [(cagY7,
                       label: block_cagY7_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagY7: // global
           I64[Sp + 16] = block_cagY9_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagWr() //  [R1]
         { info_tbl: [(cagWr,
                       label: block_cagWr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagWr: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cagY3; else goto cagY2;
       cagY3: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cagY2: // global
           I64[Hp - 64] = sat_saglY_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_saglU_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cagXY_info;
           R2 = Hp - 62;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagXY() //  [R1]
         { info_tbl: [(cagXY,
                       label: block_cagXY_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagXY: // global
           I64[Sp + 16] = block_cagY9_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagY9() //  []
         { info_tbl: [(cagY9,
                       label: block_cagY9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagY9: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.402799415 UTC

[section ""data" . modifyMVar_1_ragjY_closure" {
     modifyMVar_1_ragjY_closure:
         const modifyMVar_1_ragjY_info;
 },
 modifyMVar_1_ragjY_entry() //  [R2, R3]
         { info_tbl: [(cagZE,
                       label: modifyMVar_1_ragjY_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagZE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagZF; else goto cagZG;
       cagZF: // global
           R3 = R3;
           R2 = R2;
           R1 = modifyMVar_1_ragjY_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cagZG: // global
           I64[Sp - 16] = block_cagZB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uagZK; else goto cagZC;
       uagZK: // global
           call _cagZB(R1) args: 0, res: 0, upd: 0;
       cagZC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cagZB() //  [R1]
         { info_tbl: [(cagZB,
                       label: block_cagZB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagZB: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wmodifyMVar__ragjX_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.408437833 UTC

[section ""data" . Control.Concurrent.MVar.modifyMVar__closure" {
     Control.Concurrent.MVar.modifyMVar__closure:
         const Control.Concurrent.MVar.modifyMVar__info;
 },
 Control.Concurrent.MVar.modifyMVar__entry() //  [R2, R3]
         { info_tbl: [(cagZY,
                       label: Control.Concurrent.MVar.modifyMVar__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagZY: // global
           R3 = R3;
           R2 = R2;
           call modifyMVar_1_ragjY_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.414584863 UTC

[section ""data" . $wmodifyMVar_ragjZ_closure" {
     $wmodifyMVar_ragjZ_closure:
         const $wmodifyMVar_ragjZ_info;
 },
 sat_sagmT_entry() //  [R1, R2]
         { info_tbl: [(cah0m,
                       label: sat_sagmT_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah0m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cah0n; else goto cah0o;
       cah0n: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cah0o: // global
           I64[Sp - 16] = block_cah0k_info;
           _sagmQ::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagmQ::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah0k() //  []
         { info_tbl: [(cah0k,
                       label: block_cah0k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah0k: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagmO_entry() //  [R1]
         { info_tbl: [(cah0x,
                       label: sat_sagmO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah0x: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cah0y; else goto cah0z;
       cah0y: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cah0z: // global
           I64[Sp - 8] = block_cah0v_info;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah0v() //  [R1]
         { info_tbl: [(cah0v,
                       label: block_cah0v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah0v: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagmP_entry() //  [R1]
         { info_tbl: [(cah0G,
                       label: sat_sagmP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah0G: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagne_entry() //  [R1, R2]
         { info_tbl: [(cah0Y,
                       label: sat_sagne_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah0Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cah0Z; else goto cah10;
       cah0Z: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cah10: // global
           I64[Sp - 16] = block_cah0W_info;
           _sagnb::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagnb::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah0W() //  []
         { info_tbl: [(cah0W,
                       label: block_cah0W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah0W: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagn9_entry() //  [R1]
         { info_tbl: [(cah19,
                       label: sat_sagn9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah19: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cah1a; else goto cah1b;
       cah1a: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cah1b: // global
           I64[Sp - 8] = block_cah17_info;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah17() //  [R1]
         { info_tbl: [(cah17,
                       label: block_cah17_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah17: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagna_entry() //  [R1]
         { info_tbl: [(cah1i,
                       label: sat_sagna_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah1i: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagnm_entry() //  [R1]
         { info_tbl: [(cah1q,
                       label: sat_sagnm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah1q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cah1u; else goto cah1v;
       cah1u: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cah1v: // global
           I64[Sp - 24] = block_cah0P_info;
           _sagmA::P64 = P64[R1 + 7];
           _sagmB::P64 = P64[R1 + 15];
           R1 = _sagmA::P64;
           P64[Sp - 16] = _sagmA::P64;
           P64[Sp - 8] = _sagmB::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah0P() //  [R1]
         { info_tbl: [(cah0P,
                       label: block_cah0P_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah0P: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cah1y; else goto cah1x;
       cah1y: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cah1x: // global
           I64[Hp - 56] = sat_sagne_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sagn9_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagna_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cah1l_info;
           R2 = Hp - 54;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah1l() //  [R1]
         { info_tbl: [(cah1l,
                       label: block_cah1l_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah1l: // global
           I64[Sp] = block_cah1n_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uah1D; else goto cah1o;
       uah1D: // global
           call _cah1n(R1) args: 0, res: 0, upd: 0;
       cah1o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah1n() //  [R1]
         { info_tbl: [(cah1n,
                       label: block_cah1n_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah1n: // global
           _sagmA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cah1t_info;
           R2 = P64[R1 + 7];
           _sagnk::P64 = P64[R1 + 15];
           R1 = _sagmA::P64;
           P64[Sp + 16] = _sagnk::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah1t() //  []
         { info_tbl: [(cah1t,
                       label: block_cah1t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah1t: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagnz_entry() //  [R1, R2]
         { info_tbl: [(cah1O,
                       label: sat_sagnz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah1O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cah1P; else goto cah1Q;
       cah1P: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cah1Q: // global
           I64[Sp - 16] = block_cah1M_info;
           _sagnw::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagnw::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah1M() //  []
         { info_tbl: [(cah1M,
                       label: block_cah1M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah1M: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagnu_entry() //  [R1]
         { info_tbl: [(cah1Z,
                       label: sat_sagnu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah1Z: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cah20; else goto cah21;
       cah20: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cah21: // global
           I64[Sp - 8] = block_cah1X_info;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah1X() //  [R1]
         { info_tbl: [(cah1X,
                       label: block_cah1X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah1X: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagnv_entry() //  [R1]
         { info_tbl: [(cah28,
                       label: sat_sagnv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah28: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wmodifyMVar_ragjZ_entry() //  [R2, R3]
         { info_tbl: [(cah2f,
                       label: $wmodifyMVar_ragjZ_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah2f: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cah2g; else goto cah2h;
       cah2g: // global
           R3 = R3;
           R2 = R2;
           R1 = $wmodifyMVar_ragjZ_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cah2h: // global
           I64[Sp - 24] = block_cah09_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cah09() //  [R1]
         { info_tbl: [(cah09,
                       label: block_cah09_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah09: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cah2k; else goto cah2j;
       cah2k: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cah2j: // global
           _sagmA::P64 = P64[Sp + 8];
           if (R1 == 0) goto cah2d; else goto uah2P;
       cah2d: // global
           I64[Hp - 16] = sat_sagnm_info;
           P64[Hp - 8] = _sagmA::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uah2P: // global
           if (R1 == 1) goto cah2e; else goto cah2c;
       cah2e: // global
           Hp = Hp - 24;
           I64[Sp] = block_cah1F_info;
           R1 = _sagmA::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cah2c: // global
           Hp = Hp - 24;
           I64[Sp] = block_cah0d_info;
           R1 = _sagmA::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah1F() //  [R1]
         { info_tbl: [(cah1F,
                       label: block_cah1F_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah1F: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cah2K; else goto cah2J;
       cah2K: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cah2J: // global
           I64[Hp - 56] = sat_sagnz_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sagnu_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagnv_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cah2A_info;
           R2 = Hp - 54;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah2A() //  [R1]
         { info_tbl: [(cah2A,
                       label: block_cah2A_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah2A: // global
           I64[Sp] = block_cah2C_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uah2R; else goto cah2D;
       uah2R: // global
           call _cah2C(R1) args: 0, res: 0, upd: 0;
       cah2D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah2C() //  [R1]
         { info_tbl: [(cah2C,
                       label: block_cah2C_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah2C: // global
           _sagmA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cah2H_info;
           R2 = P64[R1 + 7];
           _sagnF::P64 = P64[R1 + 15];
           R1 = _sagmA::P64;
           P64[Sp + 16] = _sagnF::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah2H() //  []
         { info_tbl: [(cah2H,
                       label: block_cah2H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah2H: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cah0d() //  [R1]
         { info_tbl: [(cah0d,
                       label: block_cah0d_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah0d: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cah2v; else goto cah2u;
       cah2v: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cah2u: // global
           I64[Hp - 56] = sat_sagmT_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sagmO_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sagmP_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cah2l_info;
           R2 = Hp - 54;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah2l() //  [R1]
         { info_tbl: [(cah2l,
                       label: block_cah2l_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah2l: // global
           I64[Sp] = block_cah2n_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uah2Q; else goto cah2o;
       uah2Q: // global
           call _cah2n(R1) args: 0, res: 0, upd: 0;
       cah2o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah2n() //  [R1]
         { info_tbl: [(cah2n,
                       label: block_cah2n_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah2n: // global
           _sagmA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cah2s_info;
           R2 = P64[R1 + 7];
           _sagmZ::P64 = P64[R1 + 15];
           R1 = _sagmA::P64;
           P64[Sp + 16] = _sagmZ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah2s() //  []
         { info_tbl: [(cah2s,
                       label: block_cah2s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah2s: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.467271882 UTC

[section ""data" . modifyMVar1_ragk0_closure" {
     modifyMVar1_ragk0_closure:
         const modifyMVar1_ragk0_info;
 },
 modifyMVar1_ragk0_entry() //  [R2, R3]
         { info_tbl: [(cah4W,
                       label: modifyMVar1_ragk0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah4W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cah4X; else goto cah4Y;
       cah4X: // global
           R3 = R3;
           R2 = R2;
           R1 = modifyMVar1_ragk0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cah4Y: // global
           I64[Sp - 16] = block_cah4T_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uah52; else goto cah4U;
       uah52: // global
           call _cah4T(R1) args: 0, res: 0, upd: 0;
       cah4U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah4T() //  [R1]
         { info_tbl: [(cah4T,
                       label: block_cah4T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah4T: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wmodifyMVar_ragjZ_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.47287291 UTC

[section ""data" . Control.Concurrent.MVar.modifyMVar_closure" {
     Control.Concurrent.MVar.modifyMVar_closure:
         const Control.Concurrent.MVar.modifyMVar_info;
 },
 Control.Concurrent.MVar.modifyMVar_entry() //  [R2, R3]
         { info_tbl: [(cah5g,
                       label: Control.Concurrent.MVar.modifyMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah5g: // global
           R3 = R3;
           R2 = R2;
           call modifyMVar1_ragk0_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.476999981 UTC

[section ""data" . $wmodifyMVarMasked__ragk1_closure" {
     $wmodifyMVarMasked__ragk1_closure:
         const $wmodifyMVarMasked__ragk1_info;
 },
 sat_sago1_entry() //  [R1, R2]
         { info_tbl: [(cah5H,
                       label: sat_sago1_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah5H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cah5I; else goto cah5J;
       cah5I: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cah5J: // global
           I64[Sp - 16] = block_cah5F_info;
           _sagnY::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagnY::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah5F() //  []
         { info_tbl: [(cah5F,
                       label: block_cah5F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah5F: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagnX_entry() //  [R1]
         { info_tbl: [(cah5P,
                       label: sat_sagnX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah5P: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sagnS_entry() //  [R1]
         { info_tbl: [(cah5W,
                       label: io_sagnS_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah5W: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cah5X; else goto cah5Y;
       cah5X: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cah5Y: // global
           I64[Sp - 24] = block_cah5y_info;
           _sagnM::P64 = P64[R1 + 7];
           _sagnN::P64 = P64[R1 + 15];
           R1 = _sagnM::P64;
           P64[Sp - 16] = _sagnM::P64;
           P64[Sp - 8] = _sagnN::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah5y() //  [R1]
         { info_tbl: [(cah5y,
                       label: block_cah5y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah5y: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cah61; else goto cah60;
       cah61: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cah60: // global
           I64[Hp - 48] = sat_sago1_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = R1;
           I64[Hp - 24] = sat_sagnX_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp] = block_cah5S_info;
           R2 = Hp - 46;
           R1 = Hp - 24;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah5S() //  [R1]
         { info_tbl: [(cah5S,
                       label: block_cah5S_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah5S: // global
           I64[Sp + 16] = block_cah5U_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah5U() //  []
         { info_tbl: [(cah5U,
                       label: block_cah5U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah5U: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wmodifyMVarMasked__ragk1_entry() //  [R2, R3]
         { info_tbl: [(cah68,
                       label: $wmodifyMVarMasked__ragk1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah68: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cah69; else goto cah6a;
       cah69: // global
           R3 = R3;
           R2 = R2;
           R1 = $wmodifyMVarMasked__ragk1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cah6a: // global
           I64[Sp - 24] = block_cah5r_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cah5r() //  [R1]
         { info_tbl: [(cah5r,
                       label: block_cah5r_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah5r: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cah6d; else goto cah6c;
       cah6d: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cah6c: // global
           I64[Hp - 16] = io_sagnS_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _cah5t::P64 = Hp - 15;
           if (R1 == 0) goto cah67; else goto cah66;
       cah67: // global
           R1 = _cah5t::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cah66: // global
           R1 = _cah5t::P64;
           Sp = Sp + 24;
           call io_sagnS_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.495251536 UTC

[section ""data" . modifyMVarMasked_1_ragk2_closure" {
     modifyMVarMasked_1_ragk2_closure:
         const modifyMVarMasked_1_ragk2_info;
 },
 modifyMVarMasked_1_ragk2_entry() //  [R2, R3]
         { info_tbl: [(cah6V,
                       label: modifyMVarMasked_1_ragk2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah6V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cah6W; else goto cah6X;
       cah6W: // global
           R3 = R3;
           R2 = R2;
           R1 = modifyMVarMasked_1_ragk2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cah6X: // global
           I64[Sp - 16] = block_cah6S_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uah71; else goto cah6T;
       uah71: // global
           call _cah6S(R1) args: 0, res: 0, upd: 0;
       cah6T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah6S() //  [R1]
         { info_tbl: [(cah6S,
                       label: block_cah6S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah6S: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wmodifyMVarMasked__ragk1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.500412398 UTC

[section ""data" . Control.Concurrent.MVar.modifyMVarMasked__closure" {
     Control.Concurrent.MVar.modifyMVarMasked__closure:
         const Control.Concurrent.MVar.modifyMVarMasked__info;
 },
 Control.Concurrent.MVar.modifyMVarMasked__entry() //  [R2, R3]
         { info_tbl: [(cah7f,
                       label: Control.Concurrent.MVar.modifyMVarMasked__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah7f: // global
           R3 = R3;
           R2 = R2;
           call modifyMVarMasked_1_ragk2_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.504598663 UTC

[section ""data" . $wmodifyMVarMasked_ragk3_closure" {
     $wmodifyMVarMasked_ragk3_closure:
         const $wmodifyMVarMasked_ragk3_info;
 },
 sat_sagov_entry() //  [R1, R2]
         { info_tbl: [(cah7G,
                       label: sat_sagov_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah7G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cah7H; else goto cah7I;
       cah7H: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cah7I: // global
           I64[Sp - 16] = block_cah7E_info;
           _sagos::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sagos::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah7E() //  []
         { info_tbl: [(cah7E,
                       label: block_cah7E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah7E: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sagor_entry() //  [R1]
         { info_tbl: [(cah7R,
                       label: sat_sagor_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah7R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cah7S; else goto cah7T;
       cah7S: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cah7T: // global
           I64[Sp - 8] = block_cah7P_info;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah7P() //  [R1]
         { info_tbl: [(cah7P,
                       label: block_cah7P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah7P: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sagoi_entry() //  [R1]
         { info_tbl: [(cah80,
                       label: io_sagoi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah80: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cah84; else goto cah85;
       cah84: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cah85: // global
           I64[Sp - 24] = block_cah7x_info;
           _sagoc::P64 = P64[R1 + 7];
           _sagod::P64 = P64[R1 + 15];
           R1 = _sagoc::P64;
           P64[Sp - 16] = _sagoc::P64;
           P64[Sp - 8] = _sagod::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah7x() //  [R1]
         { info_tbl: [(cah7x,
                       label: block_cah7x_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah7x: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cah88; else goto cah87;
       cah88: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cah87: // global
           I64[Hp - 40] = sat_sagov_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sagor_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp] = block_cah7V_info;
           R2 = Hp - 38;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah7V() //  [R1]
         { info_tbl: [(cah7V,
                       label: block_cah7V_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah7V: // global
           I64[Sp] = block_cah7X_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uah8d; else goto cah7Y;
       uah8d: // global
           call _cah7X(R1) args: 0, res: 0, upd: 0;
       cah7Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah7X() //  [R1]
         { info_tbl: [(cah7X,
                       label: block_cah7X_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah7X: // global
           _sagoc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cah83_info;
           R2 = P64[R1 + 7];
           _sagoB::P64 = P64[R1 + 15];
           R1 = _sagoc::P64;
           P64[Sp + 16] = _sagoB::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah83() //  []
         { info_tbl: [(cah83,
                       label: block_cah83_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah83: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wmodifyMVarMasked_ragk3_entry() //  [R2, R3]
         { info_tbl: [(cah8i,
                       label: $wmodifyMVarMasked_ragk3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah8i: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cah8j; else goto cah8k;
       cah8j: // global
           R3 = R3;
           R2 = R2;
           R1 = $wmodifyMVarMasked_ragk3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cah8k: // global
           I64[Sp - 24] = block_cah7q_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cah7q() //  [R1]
         { info_tbl: [(cah7q,
                       label: block_cah7q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah7q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cah8n; else goto cah8m;
       cah8n: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cah8m: // global
           I64[Hp - 16] = io_sagoi_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _cah7s::P64 = Hp - 15;
           if (R1 == 0) goto cah8h; else goto cah8g;
       cah8h: // global
           R1 = _cah7s::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cah8g: // global
           R1 = _cah7s::P64;
           Sp = Sp + 24;
           call io_sagoi_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.526550142 UTC

[section ""data" . modifyMVarMasked1_ragk4_closure" {
     modifyMVarMasked1_ragk4_closure:
         const modifyMVarMasked1_ragk4_info;
 },
 modifyMVarMasked1_ragk4_entry() //  [R2, R3]
         { info_tbl: [(cah9f,
                       label: modifyMVarMasked1_ragk4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah9f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cah9g; else goto cah9h;
       cah9g: // global
           R3 = R3;
           R2 = R2;
           R1 = modifyMVarMasked1_ragk4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cah9h: // global
           I64[Sp - 16] = block_cah9c_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uah9l; else goto cah9d;
       uah9l: // global
           call _cah9c(R1) args: 0, res: 0, upd: 0;
       cah9d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah9c() //  [R1]
         { info_tbl: [(cah9c,
                       label: block_cah9c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah9c: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wmodifyMVarMasked_ragk3_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.532254961 UTC

[section ""data" . Control.Concurrent.MVar.modifyMVarMasked_closure" {
     Control.Concurrent.MVar.modifyMVarMasked_closure:
         const Control.Concurrent.MVar.modifyMVarMasked_info;
 },
 Control.Concurrent.MVar.modifyMVarMasked_entry() //  [R2, R3]
         { info_tbl: [(cah9z,
                       label: Control.Concurrent.MVar.modifyMVarMasked_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah9z: // global
           R3 = R3;
           R2 = R2;
           call modifyMVarMasked1_ragk4_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.535672292 UTC

[section ""data" . Control.Concurrent.MVar.addMVarFinalizer_closure" {
     Control.Concurrent.MVar.addMVarFinalizer_closure:
         const Control.Concurrent.MVar.addMVarFinalizer_info;
 },
 Control.Concurrent.MVar.addMVarFinalizer_entry() //  [R2, R3]
         { info_tbl: [(cah9K,
                       label: Control.Concurrent.MVar.addMVarFinalizer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah9K: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.addMVarFinalizer1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.539218532 UTC

[section ""data" . Control.Concurrent.MVar.mkWeakMVar1_closure" {
     Control.Concurrent.MVar.mkWeakMVar1_closure:
         const Control.Concurrent.MVar.mkWeakMVar1_info;
 },
 Control.Concurrent.MVar.mkWeakMVar1_entry() //  [R2, R3]
         { info_tbl: [(cah9Y,
                       label: Control.Concurrent.MVar.mkWeakMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah9Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caha4; else goto caha5;
       caha4: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.MVar.mkWeakMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caha5: // global
           I64[Sp - 16] = block_cah9V_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uahaa; else goto cah9W;
       uahaa: // global
           call _cah9V(R1) args: 0, res: 0, upd: 0;
       cah9W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cah9V() //  [R1]
         { info_tbl: [(cah9V,
                       label: block_cah9V_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah9V: // global
           _sagoK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caha1_info;
           R3 = _sagoK::P64;
           R2 = R1;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caha1() //  [R1]
         { info_tbl: [(caha1,
                       label: block_caha1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caha1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caha9; else goto caha8;
       caha9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caha8: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.546881691 UTC

[section ""data" . Control.Concurrent.MVar.mkWeakMVar_closure" {
     Control.Concurrent.MVar.mkWeakMVar_closure:
         const Control.Concurrent.MVar.mkWeakMVar_info;
 },
 Control.Concurrent.MVar.mkWeakMVar_entry() //  [R2, R3]
         { info_tbl: [(cahas,
                       label: Control.Concurrent.MVar.mkWeakMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahas: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.MVar.mkWeakMVar1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.550171595 UTC

[section ""cstring" . Control.Concurrent.MVar.$trModule4_bytes" {
     Control.Concurrent.MVar.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.552359271 UTC

[section ""data" . Control.Concurrent.MVar.$trModule3_closure" {
     Control.Concurrent.MVar.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.MVar.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.554507234 UTC

[section ""cstring" . Control.Concurrent.MVar.$trModule2_bytes" {
     Control.Concurrent.MVar.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.556212344 UTC

[section ""data" . Control.Concurrent.MVar.$trModule1_closure" {
     Control.Concurrent.MVar.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.MVar.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.557900408 UTC

[section ""data" . Control.Concurrent.MVar.$trModule_closure" {
     Control.Concurrent.MVar.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.MVar.$trModule3_closure+1;
         const Control.Concurrent.MVar.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:17.559646817 UTC

[section ""relreadonly" . SagBS_srt" { SagBS_srt:
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.257896011 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:18.259760938 UTC

[section ""data" . Control.Concurrent.MVar.$wswapMVar_closure" {
     Control.Concurrent.MVar.$wswapMVar_closure:
         const Control.Concurrent.MVar.$wswapMVar_info;
 },
 sat_sahaV_entry() //  [R1]
         { info_tbl: [(cahfJ,
                       label: sat_sahaV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahfJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cahfK; else goto cahfL;
       cahfK: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cahfL: // global
           I64[Sp - 24] = block_cahfF_info;
           _sahaF::P64 = P64[R1 + 7];
           _sahaG::P64 = P64[R1 + 15];
           R1 = _sahaF::P64;
           P64[Sp - 16] = _sahaF::P64;
           P64[Sp - 8] = _sahaG::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahfF() //  [R1]
         { info_tbl: [(cahfF,
                       label: block_cahfF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahfF: // global
           _sahaF::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cahfH_info;
           R2 = P64[Sp + 16];
           _sahaT::P64 = R1;
           R1 = _sahaF::P64;
           P64[Sp + 16] = _sahaT::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahfH() //  []
         { info_tbl: [(cahfH,
                       label: block_cahfH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahfH: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.MVar.$wswapMVar_entry() //  [R2, R3]
         { info_tbl: [(cahfR,
                       label: Control.Concurrent.MVar.$wswapMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahfR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cahfS; else goto cahfT;
       cahfS: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.MVar.$wswapMVar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cahfT: // global
           I64[Sp - 24] = block_cahfv_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cahfv() //  [R1]
         { info_tbl: [(cahfv,
                       label: block_cahfv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahfv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cahfW; else goto cahfV;
       cahfW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cahfV: // global
           _sahaF::P64 = P64[Sp + 8];
           if (R1 == 0) goto cahfQ; else goto cahfP;
       cahfQ: // global
           I64[Hp - 16] = sat_sahaV_info;
           P64[Hp - 8] = _sahaF::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cahfP: // global
           Hp = Hp - 24;
           I64[Sp] = block_cahfX_info;
           R1 = _sahaF::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahfX() //  [R1]
         { info_tbl: [(cahfX,
                       label: block_cahfX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahfX: // global
           _sahaF::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cahfZ_info;
           R2 = P64[Sp + 16];
           _sahaO::P64 = R1;
           R1 = _sahaF::P64;
           P64[Sp + 16] = _sahaO::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahfZ() //  []
         { info_tbl: [(cahfZ,
                       label: block_cahfZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahfZ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.273794802 UTC

[section ""data" . Control.Concurrent.MVar.swapMVar1_closure" {
     Control.Concurrent.MVar.swapMVar1_closure:
         const Control.Concurrent.MVar.swapMVar1_info;
 },
 Control.Concurrent.MVar.swapMVar1_entry() //  [R2, R3]
         { info_tbl: [(cahgH,
                       label: Control.Concurrent.MVar.swapMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahgH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahgI; else goto cahgJ;
       cahgI: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.MVar.swapMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cahgJ: // global
           I64[Sp - 16] = block_cahgE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uahgN; else goto cahgF;
       uahgN: // global
           call _cahgE(R1) args: 0, res: 0, upd: 0;
       cahgF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahgE() //  [R1]
         { info_tbl: [(cahgE,
                       label: block_cahgE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahgE: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call Control.Concurrent.MVar.$wswapMVar_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.279275067 UTC

[section ""data" . Control.Concurrent.MVar.swapMVar_closure" {
     Control.Concurrent.MVar.swapMVar_closure:
         const Control.Concurrent.MVar.swapMVar_info;
 },
 Control.Concurrent.MVar.swapMVar_entry() //  [R2, R3]
         { info_tbl: [(cahh2,
                       label: Control.Concurrent.MVar.swapMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahh2: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.MVar.swapMVar1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.284481962 UTC

[section ""data" . $wwithMVar_ragjT_closure" {
     $wwithMVar_ragjT_closure:
         const $wwithMVar_ragjT_info;
 },
 sat_sahbg_entry() //  [R1, R2]
         { info_tbl: [(cahhq,
                       label: sat_sahbg_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahhq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahhr; else goto cahhs;
       cahhr: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cahhs: // global
           I64[Sp - 16] = block_cahho_info;
           _sahbd::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sahbd::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahho() //  []
         { info_tbl: [(cahho,
                       label: block_cahho_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahho: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahbc_entry() //  [R1]
         { info_tbl: [(cahhA,
                       label: sat_sahbc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahhA: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahbu_entry() //  [R1, R2]
         { info_tbl: [(cahhS,
                       label: sat_sahbu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahhS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahhT; else goto cahhU;
       cahhT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cahhU: // global
           I64[Sp - 16] = block_cahhQ_info;
           _sahbr::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sahbr::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahhQ() //  []
         { info_tbl: [(cahhQ,
                       label: block_cahhQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahhQ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahbq_entry() //  [R1]
         { info_tbl: [(cahi2,
                       label: sat_sahbq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahi2: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahbz_entry() //  [R1]
         { info_tbl: [(cahi9,
                       label: sat_sahbz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahi9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cahia; else goto cahib;
       cahia: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cahib: // global
           I64[Sp - 24] = block_cahhJ_info;
           _sahb1::P64 = P64[R1 + 7];
           _sahb2::P64 = P64[R1 + 15];
           R1 = _sahb1::P64;
           P64[Sp - 16] = _sahb1::P64;
           P64[Sp - 8] = _sahb2::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahhJ() //  [R1]
         { info_tbl: [(cahhJ,
                       label: block_cahhJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahhJ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cahie; else goto cahid;
       cahie: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cahid: // global
           I64[Hp - 64] = sat_sahbu_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sahbq_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cahi5_info;
           R2 = Hp - 62;
           _sahbo::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sahbo::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahi5() //  [R1]
         { info_tbl: [(cahi5,
                       label: block_cahi5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahi5: // global
           _sahb1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cahi7_info;
           R2 = P64[Sp + 16];
           _sahbx::P64 = R1;
           R1 = _sahb1::P64;
           P64[Sp + 16] = _sahbx::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahi7() //  []
         { info_tbl: [(cahi7,
                       label: block_cahi7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahi7: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahbI_entry() //  [R1, R2]
         { info_tbl: [(cahir,
                       label: sat_sahbI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahir: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahis; else goto cahit;
       cahis: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cahit: // global
           I64[Sp - 16] = block_cahip_info;
           _sahbF::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sahbF::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahip() //  []
         { info_tbl: [(cahip,
                       label: block_cahip_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahip: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahbE_entry() //  [R1]
         { info_tbl: [(cahiB,
                       label: sat_sahbE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahiB: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wwithMVar_ragjT_entry() //  [R2, R3]
         { info_tbl: [(cahiI,
                       label: $wwithMVar_ragjT_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahiI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cahiJ; else goto cahiK;
       cahiJ: // global
           R3 = R3;
           R2 = R2;
           R1 = $wwithMVar_ragjT_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cahiK: // global
           I64[Sp - 24] = block_cahhd_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cahhd() //  [R1]
         { info_tbl: [(cahhd,
                       label: block_cahhd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahhd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cahiN; else goto cahiM;
       cahiN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cahiM: // global
           _sahb1::P64 = P64[Sp + 8];
           if (R1 == 0) goto cahiG; else goto uahj6;
       cahiG: // global
           I64[Hp - 16] = sat_sahbz_info;
           P64[Hp - 8] = _sahb1::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uahj6: // global
           if (R1 == 1) goto cahiH; else goto cahiF;
       cahiH: // global
           Hp = Hp - 24;
           I64[Sp] = block_cahii_info;
           R1 = _sahb1::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cahiF: // global
           Hp = Hp - 24;
           I64[Sp] = block_cahhh_info;
           R1 = _sahb1::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahii() //  [R1]
         { info_tbl: [(cahii,
                       label: block_cahii_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahii: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cahj2; else goto cahj1;
       cahj2: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cahj1: // global
           I64[Hp - 64] = sat_sahbI_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sahbE_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cahiX_info;
           R2 = Hp - 62;
           _sahbC::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sahbC::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahiX() //  [R1]
         { info_tbl: [(cahiX,
                       label: block_cahiX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahiX: // global
           _sahb1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cahiZ_info;
           R2 = P64[Sp + 16];
           _sahbL::P64 = R1;
           R1 = _sahb1::P64;
           P64[Sp + 16] = _sahbL::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahiZ() //  []
         { info_tbl: [(cahiZ,
                       label: block_cahiZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahiZ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cahhh() //  [R1]
         { info_tbl: [(cahhh,
                       label: block_cahhh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahhh: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cahiT; else goto cahiS;
       cahiT: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cahiS: // global
           I64[Hp - 64] = sat_sahbg_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sahbc_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cahiO_info;
           R2 = Hp - 62;
           _sahba::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sahba::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahiO() //  [R1]
         { info_tbl: [(cahiO,
                       label: block_cahiO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahiO: // global
           _sahb1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cahiQ_info;
           R2 = P64[Sp + 16];
           _sahbj::P64 = R1;
           R1 = _sahb1::P64;
           P64[Sp + 16] = _sahbj::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahiQ() //  []
         { info_tbl: [(cahiQ,
                       label: block_cahiQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahiQ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.324187414 UTC

[section ""data" . withMVar1_ragjU_closure" {
     withMVar1_ragjU_closure:
         const withMVar1_ragjU_info;
 },
 withMVar1_ragjU_entry() //  [R2, R3]
         { info_tbl: [(cahkV,
                       label: withMVar1_ragjU_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahkV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahkW; else goto cahkX;
       cahkW: // global
           R3 = R3;
           R2 = R2;
           R1 = withMVar1_ragjU_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cahkX: // global
           I64[Sp - 16] = block_cahkS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uahl1; else goto cahkT;
       uahl1: // global
           call _cahkS(R1) args: 0, res: 0, upd: 0;
       cahkT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahkS() //  [R1]
         { info_tbl: [(cahkS,
                       label: block_cahkS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahkS: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wwithMVar_ragjT_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.3295533 UTC

[section ""data" . Control.Concurrent.MVar.withMVar_closure" {
     Control.Concurrent.MVar.withMVar_closure:
         const Control.Concurrent.MVar.withMVar_info;
 },
 Control.Concurrent.MVar.withMVar_entry() //  [R2, R3]
         { info_tbl: [(cahlg,
                       label: Control.Concurrent.MVar.withMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahlg: // global
           R3 = R3;
           R2 = R2;
           call withMVar1_ragjU_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.334123634 UTC

[section ""data" . $wwithMVarMasked_ragjV_closure" {
     $wwithMVarMasked_ragjV_closure:
         const $wwithMVarMasked_ragjV_info;
 },
 sat_sahc7_entry() //  [R1, R2]
         { info_tbl: [(cahlH,
                       label: sat_sahc7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahlH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahlI; else goto cahlJ;
       cahlI: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cahlJ: // global
           I64[Sp - 16] = block_cahlF_info;
           _sahc4::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sahc4::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahlF() //  []
         { info_tbl: [(cahlF,
                       label: block_cahlF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahlF: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahc3_entry() //  [R1]
         { info_tbl: [(cahlP,
                       label: sat_sahc3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahlP: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sahbY_entry() //  [R1]
         { info_tbl: [(cahlW,
                       label: io_sahbY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahlW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cahlX; else goto cahlY;
       cahlX: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cahlY: // global
           I64[Sp - 24] = block_cahly_info;
           _sahbS::P64 = P64[R1 + 7];
           _sahbT::P64 = P64[R1 + 15];
           R1 = _sahbS::P64;
           P64[Sp - 16] = _sahbS::P64;
           P64[Sp - 8] = _sahbT::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahly() //  [R1]
         { info_tbl: [(cahly,
                       label: block_cahly_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahly: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cahm1; else goto cahm0;
       cahm1: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cahm0: // global
           I64[Hp - 48] = sat_sahc7_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = R1;
           I64[Hp - 24] = sat_sahc3_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp] = block_cahlS_info;
           R2 = Hp - 46;
           _sahc2::P64 = R1;
           R1 = Hp - 24;
           P64[Sp + 16] = _sahc2::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahlS() //  [R1]
         { info_tbl: [(cahlS,
                       label: block_cahlS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahlS: // global
           _sahbS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cahlU_info;
           R2 = P64[Sp + 16];
           _sahca::P64 = R1;
           R1 = _sahbS::P64;
           P64[Sp + 16] = _sahca::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahlU() //  []
         { info_tbl: [(cahlU,
                       label: block_cahlU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahlU: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wwithMVarMasked_ragjV_entry() //  [R2, R3]
         { info_tbl: [(cahm8,
                       label: $wwithMVarMasked_ragjV_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahm8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cahm9; else goto cahma;
       cahm9: // global
           R3 = R3;
           R2 = R2;
           R1 = $wwithMVarMasked_ragjV_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cahma: // global
           I64[Sp - 24] = block_cahlr_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cahlr() //  [R1]
         { info_tbl: [(cahlr,
                       label: block_cahlr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahlr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cahmd; else goto cahmc;
       cahmd: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cahmc: // global
           I64[Hp - 16] = io_sahbY_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _cahlt::P64 = Hp - 15;
           if (R1 == 0) goto cahm7; else goto cahm6;
       cahm7: // global
           R1 = _cahlt::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cahm6: // global
           R1 = _cahlt::P64;
           Sp = Sp + 24;
           call io_sahbY_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.352398401 UTC

[section ""data" . withMVarMasked1_ragjW_closure" {
     withMVarMasked1_ragjW_closure:
         const withMVarMasked1_ragjW_info;
 },
 withMVarMasked1_ragjW_entry() //  [R2, R3]
         { info_tbl: [(cahn3,
                       label: withMVarMasked1_ragjW_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahn3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahn4; else goto cahn5;
       cahn4: // global
           R3 = R3;
           R2 = R2;
           R1 = withMVarMasked1_ragjW_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cahn5: // global
           I64[Sp - 16] = block_cahn0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uahn9; else goto cahn1;
       uahn9: // global
           call _cahn0(R1) args: 0, res: 0, upd: 0;
       cahn1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahn0() //  [R1]
         { info_tbl: [(cahn0,
                       label: block_cahn0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahn0: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wwithMVarMasked_ragjV_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.358202745 UTC

[section ""data" . Control.Concurrent.MVar.withMVarMasked_closure" {
     Control.Concurrent.MVar.withMVarMasked_closure:
         const Control.Concurrent.MVar.withMVarMasked_info;
 },
 Control.Concurrent.MVar.withMVarMasked_entry() //  [R2, R3]
         { info_tbl: [(cahno,
                       label: Control.Concurrent.MVar.withMVarMasked_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahno: // global
           R3 = R3;
           R2 = R2;
           call withMVarMasked1_ragjW_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.363297528 UTC

[section ""data" . $wmodifyMVar__ragjX_closure" {
     $wmodifyMVar__ragjX_closure:
         const $wmodifyMVar__ragjX_info;
 },
 sat_sahcx_entry() //  [R1, R2]
         { info_tbl: [(cahnM,
                       label: sat_sahcx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahnM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahnN; else goto cahnO;
       cahnN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cahnO: // global
           I64[Sp - 16] = block_cahnK_info;
           _sahcu::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sahcu::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahnK() //  []
         { info_tbl: [(cahnK,
                       label: block_cahnK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahnK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahct_entry() //  [R1]
         { info_tbl: [(cahnW,
                       label: sat_sahct_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahnW: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahcL_entry() //  [R1, R2]
         { info_tbl: [(cahoe,
                       label: sat_sahcL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahoe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahof; else goto cahog;
       cahof: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cahog: // global
           I64[Sp - 16] = block_cahoc_info;
           _sahcI::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sahcI::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahoc() //  []
         { info_tbl: [(cahoc,
                       label: block_cahoc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahoc: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahcH_entry() //  [R1]
         { info_tbl: [(cahoo,
                       label: sat_sahcH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahoo: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahcQ_entry() //  [R1]
         { info_tbl: [(cahov,
                       label: sat_sahcQ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahov: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cahow; else goto cahox;
       cahow: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cahox: // global
           I64[Sp - 24] = block_caho5_info;
           _sahci::P64 = P64[R1 + 7];
           _sahcj::P64 = P64[R1 + 15];
           R1 = _sahci::P64;
           P64[Sp - 16] = _sahci::P64;
           P64[Sp - 8] = _sahcj::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caho5() //  [R1]
         { info_tbl: [(caho5,
                       label: block_caho5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caho5: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cahoA; else goto cahoz;
       cahoA: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cahoz: // global
           I64[Hp - 64] = sat_sahcL_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sahcH_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cahor_info;
           R2 = Hp - 62;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahor() //  [R1]
         { info_tbl: [(cahor,
                       label: block_cahor_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahor: // global
           I64[Sp + 16] = block_cahot_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahot() //  []
         { info_tbl: [(cahot,
                       label: block_cahot_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahot: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahcZ_entry() //  [R1, R2]
         { info_tbl: [(cahoN,
                       label: sat_sahcZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahoN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahoO; else goto cahoP;
       cahoO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cahoP: // global
           I64[Sp - 16] = block_cahoL_info;
           _sahcW::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sahcW::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahoL() //  []
         { info_tbl: [(cahoL,
                       label: block_cahoL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahoL: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahcV_entry() //  [R1]
         { info_tbl: [(cahoX,
                       label: sat_sahcV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahoX: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wmodifyMVar__ragjX_entry() //  [R2, R3]
         { info_tbl: [(cahp4,
                       label: $wmodifyMVar__ragjX_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahp4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cahp5; else goto cahp6;
       cahp5: // global
           R3 = R3;
           R2 = R2;
           R1 = $wmodifyMVar__ragjX_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cahp6: // global
           I64[Sp - 24] = block_cahnz_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cahnz() //  [R1]
         { info_tbl: [(cahnz,
                       label: block_cahnz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahnz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cahp9; else goto cahp8;
       cahp9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cahp8: // global
           _sahci::P64 = P64[Sp + 8];
           if (R1 == 0) goto cahp2; else goto uahps;
       cahp2: // global
           I64[Hp - 16] = sat_sahcQ_info;
           P64[Hp - 8] = _sahci::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uahps: // global
           if (R1 == 1) goto cahp3; else goto cahp1;
       cahp3: // global
           Hp = Hp - 24;
           I64[Sp] = block_cahoE_info;
           R1 = _sahci::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cahp1: // global
           Hp = Hp - 24;
           I64[Sp] = block_cahnD_info;
           R1 = _sahci::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahoE() //  [R1]
         { info_tbl: [(cahoE,
                       label: block_cahoE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahoE: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cahpo; else goto cahpn;
       cahpo: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cahpn: // global
           I64[Hp - 64] = sat_sahcZ_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sahcV_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cahpj_info;
           R2 = Hp - 62;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahpj() //  [R1]
         { info_tbl: [(cahpj,
                       label: block_cahpj_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahpj: // global
           I64[Sp + 16] = block_cahpl_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahnD() //  [R1]
         { info_tbl: [(cahnD,
                       label: block_cahnD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahnD: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cahpf; else goto cahpe;
       cahpf: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cahpe: // global
           I64[Hp - 64] = sat_sahcx_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sahct_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cahpa_info;
           R2 = Hp - 62;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahpa() //  [R1]
         { info_tbl: [(cahpa,
                       label: block_cahpa_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahpa: // global
           I64[Sp + 16] = block_cahpl_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahpl() //  []
         { info_tbl: [(cahpl,
                       label: block_cahpl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahpl: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.400600403 UTC

[section ""data" . modifyMVar_1_ragjY_closure" {
     modifyMVar_1_ragjY_closure:
         const modifyMVar_1_ragjY_info;
 },
 modifyMVar_1_ragjY_entry() //  [R2, R3]
         { info_tbl: [(cahrf,
                       label: modifyMVar_1_ragjY_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahrf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahrg; else goto cahrh;
       cahrg: // global
           R3 = R3;
           R2 = R2;
           R1 = modifyMVar_1_ragjY_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cahrh: // global
           I64[Sp - 16] = block_cahrc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uahrl; else goto cahrd;
       uahrl: // global
           call _cahrc(R1) args: 0, res: 0, upd: 0;
       cahrd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahrc() //  [R1]
         { info_tbl: [(cahrc,
                       label: block_cahrc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahrc: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wmodifyMVar__ragjX_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.407000248 UTC

[section ""data" . Control.Concurrent.MVar.modifyMVar__closure" {
     Control.Concurrent.MVar.modifyMVar__closure:
         const Control.Concurrent.MVar.modifyMVar__info;
 },
 Control.Concurrent.MVar.modifyMVar__entry() //  [R2, R3]
         { info_tbl: [(cahrA,
                       label: Control.Concurrent.MVar.modifyMVar__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahrA: // global
           R3 = R3;
           R2 = R2;
           call modifyMVar_1_ragjY_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.412638774 UTC

[section ""data" . $wmodifyMVar_ragjZ_closure" {
     $wmodifyMVar_ragjZ_closure:
         const $wmodifyMVar_ragjZ_info;
 },
 sat_sahds_entry() //  [R1, R2]
         { info_tbl: [(cahrY,
                       label: sat_sahds_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahrY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahrZ; else goto cahs0;
       cahrZ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cahs0: // global
           I64[Sp - 16] = block_cahrW_info;
           _sahdp::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sahdp::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahrW() //  []
         { info_tbl: [(cahrW,
                       label: block_cahrW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahrW: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahdn_entry() //  [R1]
         { info_tbl: [(cahs9,
                       label: sat_sahdn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahs9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cahsa; else goto cahsb;
       cahsa: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cahsb: // global
           I64[Sp - 8] = block_cahs7_info;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahs7() //  [R1]
         { info_tbl: [(cahs7,
                       label: block_cahs7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahs7: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahdo_entry() //  [R1]
         { info_tbl: [(cahsi,
                       label: sat_sahdo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahsi: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahdN_entry() //  [R1, R2]
         { info_tbl: [(cahsA,
                       label: sat_sahdN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahsA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahsB; else goto cahsC;
       cahsB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cahsC: // global
           I64[Sp - 16] = block_cahsy_info;
           _sahdK::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sahdK::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahsy() //  []
         { info_tbl: [(cahsy,
                       label: block_cahsy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahsy: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahdI_entry() //  [R1]
         { info_tbl: [(cahsL,
                       label: sat_sahdI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahsL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cahsM; else goto cahsN;
       cahsM: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cahsN: // global
           I64[Sp - 8] = block_cahsJ_info;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahsJ() //  [R1]
         { info_tbl: [(cahsJ,
                       label: block_cahsJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahsJ: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahdJ_entry() //  [R1]
         { info_tbl: [(cahsU,
                       label: sat_sahdJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahsU: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahdV_entry() //  [R1]
         { info_tbl: [(caht2,
                       label: sat_sahdV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caht2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caht6; else goto caht7;
       caht6: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caht7: // global
           I64[Sp - 24] = block_cahsr_info;
           _sahd9::P64 = P64[R1 + 7];
           _sahda::P64 = P64[R1 + 15];
           R1 = _sahd9::P64;
           P64[Sp - 16] = _sahd9::P64;
           P64[Sp - 8] = _sahda::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahsr() //  [R1]
         { info_tbl: [(cahsr,
                       label: block_cahsr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahsr: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cahta; else goto caht9;
       cahta: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caht9: // global
           I64[Hp - 56] = sat_sahdN_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sahdI_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sahdJ_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cahsX_info;
           R2 = Hp - 54;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahsX() //  [R1]
         { info_tbl: [(cahsX,
                       label: block_cahsX_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahsX: // global
           I64[Sp] = block_cahsZ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uahtf; else goto caht0;
       uahtf: // global
           call _cahsZ(R1) args: 0, res: 0, upd: 0;
       caht0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahsZ() //  [R1]
         { info_tbl: [(cahsZ,
                       label: block_cahsZ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahsZ: // global
           _sahd9::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caht5_info;
           R2 = P64[R1 + 7];
           _sahdT::P64 = P64[R1 + 15];
           R1 = _sahd9::P64;
           P64[Sp + 16] = _sahdT::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caht5() //  []
         { info_tbl: [(caht5,
                       label: block_caht5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caht5: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahe8_entry() //  [R1, R2]
         { info_tbl: [(cahtq,
                       label: sat_sahe8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahtq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahtr; else goto cahts;
       cahtr: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cahts: // global
           I64[Sp - 16] = block_cahto_info;
           _sahe5::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sahe5::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahto() //  []
         { info_tbl: [(cahto,
                       label: block_cahto_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahto: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahe3_entry() //  [R1]
         { info_tbl: [(cahtB,
                       label: sat_sahe3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahtB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cahtC; else goto cahtD;
       cahtC: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cahtD: // global
           I64[Sp - 8] = block_cahtz_info;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahtz() //  [R1]
         { info_tbl: [(cahtz,
                       label: block_cahtz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahtz: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahe4_entry() //  [R1]
         { info_tbl: [(cahtK,
                       label: sat_sahe4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahtK: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wmodifyMVar_ragjZ_entry() //  [R2, R3]
         { info_tbl: [(cahtR,
                       label: $wmodifyMVar_ragjZ_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahtR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cahtS; else goto cahtT;
       cahtS: // global
           R3 = R3;
           R2 = R2;
           R1 = $wmodifyMVar_ragjZ_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cahtT: // global
           I64[Sp - 24] = block_cahrL_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cahrL() //  [R1]
         { info_tbl: [(cahrL,
                       label: block_cahrL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahrL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cahtW; else goto cahtV;
       cahtW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cahtV: // global
           _sahd9::P64 = P64[Sp + 8];
           if (R1 == 0) goto cahtP; else goto uahur;
       cahtP: // global
           I64[Hp - 16] = sat_sahdV_info;
           P64[Hp - 8] = _sahd9::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uahur: // global
           if (R1 == 1) goto cahtQ; else goto cahtO;
       cahtQ: // global
           Hp = Hp - 24;
           I64[Sp] = block_cahth_info;
           R1 = _sahd9::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cahtO: // global
           Hp = Hp - 24;
           I64[Sp] = block_cahrP_info;
           R1 = _sahd9::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahth() //  [R1]
         { info_tbl: [(cahth,
                       label: block_cahth_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahth: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cahum; else goto cahul;
       cahum: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cahul: // global
           I64[Hp - 56] = sat_sahe8_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sahe3_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sahe4_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cahuc_info;
           R2 = Hp - 54;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahuc() //  [R1]
         { info_tbl: [(cahuc,
                       label: block_cahuc_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahuc: // global
           I64[Sp] = block_cahue_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uahut; else goto cahuf;
       uahut: // global
           call _cahue(R1) args: 0, res: 0, upd: 0;
       cahuf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahue() //  [R1]
         { info_tbl: [(cahue,
                       label: block_cahue_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahue: // global
           _sahd9::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cahuj_info;
           R2 = P64[R1 + 7];
           _sahee::P64 = P64[R1 + 15];
           R1 = _sahd9::P64;
           P64[Sp + 16] = _sahee::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahuj() //  []
         { info_tbl: [(cahuj,
                       label: block_cahuj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahuj: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cahrP() //  [R1]
         { info_tbl: [(cahrP,
                       label: block_cahrP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahrP: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cahu7; else goto cahu6;
       cahu7: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cahu6: // global
           I64[Hp - 56] = sat_sahds_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sahdn_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sahdo_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cahtX_info;
           R2 = Hp - 54;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahtX() //  [R1]
         { info_tbl: [(cahtX,
                       label: block_cahtX_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahtX: // global
           I64[Sp] = block_cahtZ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uahus; else goto cahu0;
       uahus: // global
           call _cahtZ(R1) args: 0, res: 0, upd: 0;
       cahu0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahtZ() //  [R1]
         { info_tbl: [(cahtZ,
                       label: block_cahtZ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahtZ: // global
           _sahd9::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cahu4_info;
           R2 = P64[R1 + 7];
           _sahdy::P64 = P64[R1 + 15];
           R1 = _sahd9::P64;
           P64[Sp + 16] = _sahdy::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahu4() //  []
         { info_tbl: [(cahu4,
                       label: block_cahu4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahu4: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.466423665 UTC

[section ""data" . modifyMVar1_ragk0_closure" {
     modifyMVar1_ragk0_closure:
         const modifyMVar1_ragk0_info;
 },
 modifyMVar1_ragk0_entry() //  [R2, R3]
         { info_tbl: [(cahx1,
                       label: modifyMVar1_ragk0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahx1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahx2; else goto cahx3;
       cahx2: // global
           R3 = R3;
           R2 = R2;
           R1 = modifyMVar1_ragk0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cahx3: // global
           I64[Sp - 16] = block_cahwY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uahx7; else goto cahwZ;
       uahx7: // global
           call _cahwY(R1) args: 0, res: 0, upd: 0;
       cahwZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahwY() //  [R1]
         { info_tbl: [(cahwY,
                       label: block_cahwY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahwY: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wmodifyMVar_ragjZ_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.471677984 UTC

[section ""data" . Control.Concurrent.MVar.modifyMVar_closure" {
     Control.Concurrent.MVar.modifyMVar_closure:
         const Control.Concurrent.MVar.modifyMVar_info;
 },
 Control.Concurrent.MVar.modifyMVar_entry() //  [R2, R3]
         { info_tbl: [(cahxm,
                       label: Control.Concurrent.MVar.modifyMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahxm: // global
           R3 = R3;
           R2 = R2;
           call modifyMVar1_ragk0_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.475741909 UTC

[section ""data" . $wmodifyMVarMasked__ragk1_closure" {
     $wmodifyMVarMasked__ragk1_closure:
         const $wmodifyMVarMasked__ragk1_info;
 },
 sat_saheA_entry() //  [R1, R2]
         { info_tbl: [(cahxN,
                       label: sat_saheA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahxN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahxO; else goto cahxP;
       cahxO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cahxP: // global
           I64[Sp - 16] = block_cahxL_info;
           _sahex::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sahex::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahxL() //  []
         { info_tbl: [(cahxL,
                       label: block_cahxL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahxL: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahew_entry() //  [R1]
         { info_tbl: [(cahxV,
                       label: sat_sahew_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahxV: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saher_entry() //  [R1]
         { info_tbl: [(cahy2,
                       label: io_saher_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahy2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cahy3; else goto cahy4;
       cahy3: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cahy4: // global
           I64[Sp - 24] = block_cahxE_info;
           _sahel::P64 = P64[R1 + 7];
           _sahem::P64 = P64[R1 + 15];
           R1 = _sahel::P64;
           P64[Sp - 16] = _sahel::P64;
           P64[Sp - 8] = _sahem::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahxE() //  [R1]
         { info_tbl: [(cahxE,
                       label: block_cahxE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahxE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cahy7; else goto cahy6;
       cahy7: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cahy6: // global
           I64[Hp - 48] = sat_saheA_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = R1;
           I64[Hp - 24] = sat_sahew_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp] = block_cahxY_info;
           R2 = Hp - 46;
           R1 = Hp - 24;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahxY() //  [R1]
         { info_tbl: [(cahxY,
                       label: block_cahxY_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahxY: // global
           I64[Sp + 16] = block_cahy0_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahy0() //  []
         { info_tbl: [(cahy0,
                       label: block_cahy0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahy0: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wmodifyMVarMasked__ragk1_entry() //  [R2, R3]
         { info_tbl: [(cahye,
                       label: $wmodifyMVarMasked__ragk1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahye: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cahyf; else goto cahyg;
       cahyf: // global
           R3 = R3;
           R2 = R2;
           R1 = $wmodifyMVarMasked__ragk1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cahyg: // global
           I64[Sp - 24] = block_cahxx_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cahxx() //  [R1]
         { info_tbl: [(cahxx,
                       label: block_cahxx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahxx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cahyj; else goto cahyi;
       cahyj: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cahyi: // global
           I64[Hp - 16] = io_saher_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _cahxz::P64 = Hp - 15;
           if (R1 == 0) goto cahyd; else goto cahyc;
       cahyd: // global
           R1 = _cahxz::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cahyc: // global
           R1 = _cahxz::P64;
           Sp = Sp + 24;
           call io_saher_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.494528148 UTC

[section ""data" . modifyMVarMasked_1_ragk2_closure" {
     modifyMVarMasked_1_ragk2_closure:
         const modifyMVarMasked_1_ragk2_info;
 },
 modifyMVarMasked_1_ragk2_entry() //  [R2, R3]
         { info_tbl: [(cahza,
                       label: modifyMVarMasked_1_ragk2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahza: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahzb; else goto cahzc;
       cahzb: // global
           R3 = R3;
           R2 = R2;
           R1 = modifyMVarMasked_1_ragk2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cahzc: // global
           I64[Sp - 16] = block_cahz7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uahzg; else goto cahz8;
       uahzg: // global
           call _cahz7(R1) args: 0, res: 0, upd: 0;
       cahz8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahz7() //  [R1]
         { info_tbl: [(cahz7,
                       label: block_cahz7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahz7: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wmodifyMVarMasked__ragk1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.499625237 UTC

[section ""data" . Control.Concurrent.MVar.modifyMVarMasked__closure" {
     Control.Concurrent.MVar.modifyMVarMasked__closure:
         const Control.Concurrent.MVar.modifyMVarMasked__info;
 },
 Control.Concurrent.MVar.modifyMVarMasked__entry() //  [R2, R3]
         { info_tbl: [(cahzv,
                       label: Control.Concurrent.MVar.modifyMVarMasked__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahzv: // global
           R3 = R3;
           R2 = R2;
           call modifyMVarMasked_1_ragk2_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.503816881 UTC

[section ""data" . $wmodifyMVarMasked_ragk3_closure" {
     $wmodifyMVarMasked_ragk3_closure:
         const $wmodifyMVarMasked_ragk3_info;
 },
 sat_sahf4_entry() //  [R1, R2]
         { info_tbl: [(cahzW,
                       label: sat_sahf4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahzW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahzX; else goto cahzY;
       cahzX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cahzY: // global
           I64[Sp - 16] = block_cahzU_info;
           _sahf1::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sahf1::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahzU() //  []
         { info_tbl: [(cahzU,
                       label: block_cahzU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahzU: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sahf0_entry() //  [R1]
         { info_tbl: [(cahA7,
                       label: sat_sahf0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahA7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cahA8; else goto cahA9;
       cahA8: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cahA9: // global
           I64[Sp - 8] = block_cahA5_info;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahA5() //  [R1]
         { info_tbl: [(cahA5,
                       label: block_cahA5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahA5: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_saheR_entry() //  [R1]
         { info_tbl: [(cahAg,
                       label: io_saheR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahAg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cahAk; else goto cahAl;
       cahAk: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cahAl: // global
           I64[Sp - 24] = block_cahzN_info;
           _saheL::P64 = P64[R1 + 7];
           _saheM::P64 = P64[R1 + 15];
           R1 = _saheL::P64;
           P64[Sp - 16] = _saheL::P64;
           P64[Sp - 8] = _saheM::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahzN() //  [R1]
         { info_tbl: [(cahzN,
                       label: block_cahzN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahzN: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cahAo; else goto cahAn;
       cahAo: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cahAn: // global
           I64[Hp - 40] = sat_sahf4_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = R1;
           I64[Hp - 16] = sat_sahf0_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp] = block_cahAb_info;
           R2 = Hp - 38;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahAb() //  [R1]
         { info_tbl: [(cahAb,
                       label: block_cahAb_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahAb: // global
           I64[Sp] = block_cahAd_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uahAt; else goto cahAe;
       uahAt: // global
           call _cahAd(R1) args: 0, res: 0, upd: 0;
       cahAe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahAd() //  [R1]
         { info_tbl: [(cahAd,
                       label: block_cahAd_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahAd: // global
           _saheL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cahAj_info;
           R2 = P64[R1 + 7];
           _sahfa::P64 = P64[R1 + 15];
           R1 = _saheL::P64;
           P64[Sp + 16] = _sahfa::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahAj() //  []
         { info_tbl: [(cahAj,
                       label: block_cahAj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahAj: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wmodifyMVarMasked_ragk3_entry() //  [R2, R3]
         { info_tbl: [(cahAy,
                       label: $wmodifyMVarMasked_ragk3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahAy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cahAz; else goto cahAA;
       cahAz: // global
           R3 = R3;
           R2 = R2;
           R1 = $wmodifyMVarMasked_ragk3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cahAA: // global
           I64[Sp - 24] = block_cahzG_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cahzG() //  [R1]
         { info_tbl: [(cahzG,
                       label: block_cahzG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahzG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cahAD; else goto cahAC;
       cahAD: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cahAC: // global
           I64[Hp - 16] = io_saheR_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _cahzI::P64 = Hp - 15;
           if (R1 == 0) goto cahAx; else goto cahAw;
       cahAx: // global
           R1 = _cahzI::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cahAw: // global
           R1 = _cahzI::P64;
           Sp = Sp + 24;
           call io_saheR_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.525877734 UTC

[section ""data" . modifyMVarMasked1_ragk4_closure" {
     modifyMVarMasked1_ragk4_closure:
         const modifyMVarMasked1_ragk4_info;
 },
 modifyMVarMasked1_ragk4_entry() //  [R2, R3]
         { info_tbl: [(cahBF,
                       label: modifyMVarMasked1_ragk4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahBF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahBG; else goto cahBH;
       cahBG: // global
           R3 = R3;
           R2 = R2;
           R1 = modifyMVarMasked1_ragk4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cahBH: // global
           I64[Sp - 16] = block_cahBC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uahBL; else goto cahBD;
       uahBL: // global
           call _cahBC(R1) args: 0, res: 0, upd: 0;
       cahBD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahBC() //  [R1]
         { info_tbl: [(cahBC,
                       label: block_cahBC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahBC: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call $wmodifyMVarMasked_ragk3_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.531395097 UTC

[section ""data" . Control.Concurrent.MVar.modifyMVarMasked_closure" {
     Control.Concurrent.MVar.modifyMVarMasked_closure:
         const Control.Concurrent.MVar.modifyMVarMasked_info;
 },
 Control.Concurrent.MVar.modifyMVarMasked_entry() //  [R2, R3]
         { info_tbl: [(cahC0,
                       label: Control.Concurrent.MVar.modifyMVarMasked_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahC0: // global
           R3 = R3;
           R2 = R2;
           call modifyMVarMasked1_ragk4_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.534692594 UTC

[section ""data" . Control.Concurrent.MVar.addMVarFinalizer_closure" {
     Control.Concurrent.MVar.addMVarFinalizer_closure:
         const Control.Concurrent.MVar.addMVarFinalizer_info;
 },
 Control.Concurrent.MVar.addMVarFinalizer_entry() //  [R2, R3]
         { info_tbl: [(cahCb,
                       label: Control.Concurrent.MVar.addMVarFinalizer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahCb: // global
           R3 = R3;
           R2 = R2;
           call GHC.MVar.addMVarFinalizer1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.538318883 UTC

[section ""data" . Control.Concurrent.MVar.mkWeakMVar1_closure" {
     Control.Concurrent.MVar.mkWeakMVar1_closure:
         const Control.Concurrent.MVar.mkWeakMVar1_info;
 },
 Control.Concurrent.MVar.mkWeakMVar1_entry() //  [R2, R3]
         { info_tbl: [(cahCp,
                       label: Control.Concurrent.MVar.mkWeakMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahCp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahCv; else goto cahCw;
       cahCv: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.MVar.mkWeakMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cahCw: // global
           I64[Sp - 16] = block_cahCm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uahCB; else goto cahCn;
       uahCB: // global
           call _cahCm(R1) args: 0, res: 0, upd: 0;
       cahCn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahCm() //  [R1]
         { info_tbl: [(cahCm,
                       label: block_cahCm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahCm: // global
           _sahfj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cahCs_info;
           R3 = _sahfj::P64;
           R2 = R1;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahCs() //  [R1]
         { info_tbl: [(cahCs,
                       label: block_cahCs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahCs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cahCA; else goto cahCz;
       cahCA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cahCz: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.545956806 UTC

[section ""data" . Control.Concurrent.MVar.mkWeakMVar_closure" {
     Control.Concurrent.MVar.mkWeakMVar_closure:
         const Control.Concurrent.MVar.mkWeakMVar_info;
 },
 Control.Concurrent.MVar.mkWeakMVar_entry() //  [R2, R3]
         { info_tbl: [(cahCW,
                       label: Control.Concurrent.MVar.mkWeakMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahCW: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.MVar.mkWeakMVar1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.549623413 UTC

[section ""cstring" . Control.Concurrent.MVar.$trModule4_bytes" {
     Control.Concurrent.MVar.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.551343899 UTC

[section ""data" . Control.Concurrent.MVar.$trModule3_closure" {
     Control.Concurrent.MVar.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.MVar.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.55312615 UTC

[section ""cstring" . Control.Concurrent.MVar.$trModule2_bytes" {
     Control.Concurrent.MVar.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.554874012 UTC

[section ""data" . Control.Concurrent.MVar.$trModule1_closure" {
     Control.Concurrent.MVar.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.MVar.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.556514672 UTC

[section ""data" . Control.Concurrent.MVar.$trModule_closure" {
     Control.Concurrent.MVar.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.MVar.$trModule3_closure+1;
         const Control.Concurrent.MVar.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:18.558226026 UTC

[section ""relreadonly" . SahD8_srt" { SahD8_srt:
 }]

