
==================== Output Cmm ====================
2018-03-16 16:09:09.253347614 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:09.254536958 UTC

[section ""data" . Control.Concurrent.QSem.$WQSem_closure" {
     Control.Concurrent.QSem.$WQSem_closure:
         const Control.Concurrent.QSem.$WQSem_info;
 },
 Control.Concurrent.QSem.$WQSem_entry() //  [R2]
         { info_tbl: [(cdTS0,
                       label: Control.Concurrent.QSem.$WQSem_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTS0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdTS4; else goto cdTS5;
       cdTS4: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.$WQSem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdTS5: // global
           I64[Sp - 8] = block_cdTRX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udTS9; else goto cdTRY;
       udTS9: // global
           call _cdTRX(R1) args: 0, res: 0, upd: 0;
       cdTRY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTRX() //  [R1]
         { info_tbl: [(cdTRX,
                       label: block_cdTRX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTRX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdTS8; else goto cdTS7;
       cdTS8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdTS7: // global
           _sdTOZ::P64 = P64[R1 + 7];
           I64[Hp - 8] = Control.Concurrent.QSem.QSem_con_info;
           P64[Hp] = _sdTOZ::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.255838562 UTC

[section ""cstring" . Control.Concurrent.QSem.$trModule4_bytes" {
     Control.Concurrent.QSem.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.256447464 UTC

[section ""data" . Control.Concurrent.QSem.$trModule3_closure" {
     Control.Concurrent.QSem.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSem.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.257056567 UTC

[section ""cstring" . Control.Concurrent.QSem.$trModule2_bytes" {
     Control.Concurrent.QSem.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,81,83,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.257766428 UTC

[section ""data" . Control.Concurrent.QSem.$trModule1_closure" {
     Control.Concurrent.QSem.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSem.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.258392469 UTC

[section ""data" . Control.Concurrent.QSem.$trModule_closure" {
     Control.Concurrent.QSem.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.QSem.$trModule3_closure+1;
         const Control.Concurrent.QSem.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.259061068 UTC

[section ""data" . $krep_rdTOF_closure" {
     $krep_rdTOF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.259721561 UTC

[section ""data" . $krep1_rdTOG_closure" {
     $krep1_rdTOG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.260378371 UTC

[section ""data" . $krep2_rdTOH_closure" {
     $krep2_rdTOH_closure:
         const :_con_info;
         const $krep_rdTOF_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.261022588 UTC

[section ""data" . $krep3_rdTOI_closure" {
     $krep3_rdTOI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep2_rdTOH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.261705604 UTC

[section ""data" . $krep4_rdTOJ_closure" {
     $krep4_rdTOJ_closure:
         const :_con_info;
         const $krep3_rdTOI_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.262327649 UTC

[section ""data" . $krep5_rdTOK_closure" {
     $krep5_rdTOK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep4_rdTOJ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.263006573 UTC

[section ""data" . $krep6_rdTOL_closure" {
     $krep6_rdTOL_closure:
         const :_con_info;
         const $krep5_rdTOK_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.263662056 UTC

[section ""data" . $krep7_rdTOM_closure" {
     $krep7_rdTOM_closure:
         const :_con_info;
         const $krep5_rdTOK_closure+1;
         const $krep6_rdTOL_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.264293398 UTC

[section ""data" . $krep8_rdTON_closure" {
     $krep8_rdTON_closure:
         const :_con_info;
         const $krep1_rdTOG_closure+1;
         const $krep7_rdTOM_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.264932663 UTC

[section ""data" . $krep9_rdTOO_closure" {
     $krep9_rdTOO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,,)_closure;
         const $krep8_rdTON_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.265627513 UTC

[section ""data" . $krep10_rdTOP_closure" {
     $krep10_rdTOP_closure:
         const :_con_info;
         const $krep9_rdTOO_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.266239292 UTC

[section ""data" . $krep11_rdTOQ_closure" {
     $krep11_rdTOQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep10_rdTOP_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.266834721 UTC

[section ""cstring" . Control.Concurrent.QSem.$tcQSem2_bytes" {
     Control.Concurrent.QSem.$tcQSem2_bytes:
         I8[] [81,83,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.267471492 UTC

[section ""data" . Control.Concurrent.QSem.$tcQSem1_closure" {
     Control.Concurrent.QSem.$tcQSem1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSem.$tcQSem2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.268129665 UTC

[section ""data" . Control.Concurrent.QSem.$tcQSem_closure" {
     Control.Concurrent.QSem.$tcQSem_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.QSem.$trModule_closure+1;
         const Control.Concurrent.QSem.$tcQSem1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9564161763912145234;
         const 3945938196429110556;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.268756038 UTC

[section ""data" . $krep12_rdTOR_closure" {
     $krep12_rdTOR_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Concurrent.QSem.$tcQSem_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.269452205 UTC

[section ""data" . Control.Concurrent.QSem.$tc'QSem1_closure" {
     Control.Concurrent.QSem.$tc'QSem1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_rdTOQ_closure+1;
         const $krep12_rdTOR_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.270073896 UTC

[section ""cstring" . Control.Concurrent.QSem.$tc'QSem3_bytes" {
     Control.Concurrent.QSem.$tc'QSem3_bytes:
         I8[] [39,81,83,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.270653574 UTC

[section ""data" . Control.Concurrent.QSem.$tc'QSem2_closure" {
     Control.Concurrent.QSem.$tc'QSem2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSem.$tc'QSem3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.271336708 UTC

[section ""data" . Control.Concurrent.QSem.$tc'QSem_closure" {
     Control.Concurrent.QSem.$tc'QSem_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.QSem.$trModule_closure+1;
         const Control.Concurrent.QSem.$tc'QSem2_closure+1;
         const Control.Concurrent.QSem.$tc'QSem1_closure+4;
         const 16012040391974534726;
         const 6627878139257558952;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.272039667 UTC

[section ""cstring" . lvl_rdTOS_bytes" {
     lvl_rdTOS_bytes:
         I8[] [110,101,119,81,83,101,109,58,32,73,110,105,116,105,97,108,32,113,117,97,110,116,105,116,121,32,109,117,115,116,32,98,101,32,110,111,110,45,110,101,103,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.273048109 UTC

[section ""data" . Control.Concurrent.QSem.newQSem2_closure" {
     Control.Concurrent.QSem.newQSem2_closure:
         const Control.Concurrent.QSem.newQSem2_info;
         const 0;
 },
 Control.Concurrent.QSem.newQSem2_entry() //  []
         { info_tbl: [(cdTSg,
                       label: Control.Concurrent.QSem.newQSem2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTSg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdTSh; else goto cdTSi;
       cdTSh: // global
           R1 = Control.Concurrent.QSem.newQSem2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdTSi: // global
           I64[Sp - 8] = block_cdTSe_info;
           R2 = lvl_rdTOS_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdTSe() //  [R1]
         { info_tbl: [(cdTSe,
                       label: block_cdTSe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTSe: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.274849469 UTC

[section ""data" . Control.Concurrent.QSem.newQSem1_closure" {
     Control.Concurrent.QSem.newQSem1_closure:
         const Control.Concurrent.QSem.newQSem1_info;
         const 0;
 },
 Control.Concurrent.QSem.newQSem1_entry() //  [R2]
         { info_tbl: [(cdTSu,
                       label: Control.Concurrent.QSem.newQSem1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTSu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdTSv; else goto cdTSw;
       cdTSv: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.newQSem1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdTSw: // global
           I64[Sp - 8] = block_cdTSr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udTSS; else goto cdTSs;
       udTSS: // global
           call _cdTSr(R1) args: 0, res: 0, upd: 0;
       cdTSs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTSr() //  [R1]
         { info_tbl: [(cdTSr,
                       label: block_cdTSr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTSr: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto cdTSK; else goto cdTSR;
       cdTSK: // global
           I64[Sp - 8] = block_cdTSD_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
       cdTSR: // global
           Sp = Sp + 8;
           call Control.Concurrent.QSem.newQSem2_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cdTSD() //  [R1]
         { info_tbl: [(cdTSD,
                       label: block_cdTSD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTSD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdTSN; else goto cdTSM;
       cdTSN: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdTSM: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp] = block_cdTSG_info;
           R2 = Hp - 23;
           _sdTP9::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _sdTP9::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTSG() //  []
         { info_tbl: [(cdTSG,
                       label: block_cdTSG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTSG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdTSQ; else goto cdTSP;
       cdTSQ: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdTSP: // global
           I64[Hp - 8] = Control.Concurrent.QSem.QSem_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.276666697 UTC

[section ""data" . Control.Concurrent.QSem.newQSem_closure" {
     Control.Concurrent.QSem.newQSem_closure:
         const Control.Concurrent.QSem.newQSem_info;
         const 0;
 },
 Control.Concurrent.QSem.newQSem_entry() //  [R2]
         { info_tbl: [(cdTSX,
                       label: Control.Concurrent.QSem.newQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTSX: // global
           R2 = R2;
           call Control.Concurrent.QSem.newQSem1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.277512942 UTC

[section ""data" . lvl1_rdTOT_closure" {
     lvl1_rdTOT_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.278134755 UTC

[section ""data" . lvl2_rdTOU_closure" {
     lvl2_rdTOU_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.278739002 UTC

[section ""data" . lvl3_rdTOV_closure" {
     lvl3_rdTOV_closure:
         const (,,)_con_info;
         const lvl2_rdTOU_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.280329306 UTC

[section ""data" . Control.Concurrent.QSem.signalQSem2_closure" {
     Control.Concurrent.QSem.signalQSem2_closure:
         const Control.Concurrent.QSem.signalQSem2_info;
 },
 Control.Concurrent.QSem.signalQSem2_entry() //  [R2, R3]
         { info_tbl: [(cdTTb,
                       label: Control.Concurrent.QSem.signalQSem2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTTb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdTTc; else goto udTTT;
       cdTTc: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSem.signalQSem2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       udTTT: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cdTT1() args: 0, res: 0, upd: 0;
     }
 },
 _cdTT1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTT1: // global
           _sdTPd::P64 = P64[Sp];
           I64[Sp] = block_cdTT4_info;
           R1 = _sdTPd::P64;
           if (R1 & 7 != 0) goto udTTW; else goto cdTT5;
       udTTW: // global
           call _cdTT4(R1) args: 0, res: 0, upd: 0;
       cdTT5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTT4() //  [R1]
         { info_tbl: [(cdTT4,
                       label: block_cdTT4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTT4: // global
           if (R1 & 7 == 1) goto cdTT8; else goto cdTT9;
       cdTT8: // global
           _sdTPe::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdTTg_info;
           R1 = _sdTPe::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udTTX; else goto cdTTi;
       udTTX: // global
           call _cdTTg(R1) args: 0, res: 0, upd: 0;
       cdTTi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdTT9: // global
           I64[Sp - 8] = block_cdTTA_info;
           _sdTPm::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdTPm::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udTTY; else goto cdTTC;
       udTTY: // global
           call _cdTTA(R1) args: 0, res: 0, upd: 0;
       cdTTC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTTg() //  [R1]
         { info_tbl: [(cdTTg,
                       label: block_cdTTg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTTg: // global
           if (R1 & 7 == 1) goto cdTTo; else goto cdTTt;
       cdTTo: // global
           R1 = lvl3_rdTOV_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdTTt: // global
           I64[Sp] = block_cdTTr_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = R1;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdTTr() //  [R1]
         { info_tbl: [(cdTTr,
                       label: block_cdTTr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTTr: // global
           P64[Sp - 8] = R1;
           P64[Sp] = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call _cdTT1() args: 0, res: 0, upd: 0;
     }
 },
 _cdTTA() //  [R1]
         { info_tbl: [(cdTTA,
                       label: block_cdTTA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTTA: // global
           I64[Sp] = block_cdTTG_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[R1 + 7];
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTTG() //  [R1]
         { info_tbl: [(cdTTG,
                       label: block_cdTTG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTTG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdTTL; else goto cdTTK;
       cdTTL: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdTTK: // global
           _sdTPe::P64 = P64[Sp + 16];
           _sdTPm::P64 = P64[Sp + 8];
           if (R1 == 0) goto cdTTR; else goto cdTTQ;
       cdTTR: // global
           Hp = Hp - 32;
           P64[Sp + 8] = _sdTPm::P64;
           P64[Sp + 16] = _sdTPe::P64;
           Sp = Sp + 8;
           call _cdTT1() args: 0, res: 0, upd: 0;
       cdTTQ: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl1_rdTOT_closure+1;
           P64[Hp - 8] = _sdTPm::P64;
           P64[Hp] = _sdTPe::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.284141554 UTC

[section ""data" . Control.Concurrent.QSem.$wsignalQSem_closure" {
     Control.Concurrent.QSem.$wsignalQSem_closure:
         const Control.Concurrent.QSem.$wsignalQSem_info;
 },
 sat_sdTPT_entry() //  [R1]
         { info_tbl: [(cdTUk,
                       label: sat_sdTPT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTUk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdTUo; else goto cdTUp;
       cdTUo: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdTUp: // global
           I64[Sp - 16] = block_cdTUf_info;
           _sdTPu::P64 = P64[R1 + 7];
           R1 = _sdTPu::P64;
           P64[Sp - 8] = _sdTPu::P64;
           Sp = Sp - 16;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTUf() //  [R1]
         { info_tbl: [(cdTUf,
                       label: block_cdTUf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTUf: // global
           I64[Sp] = block_cdTUh_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udTUT; else goto cdTUi;
       udTUT: // global
           call _cdTUh(R1) args: 0, res: 0, upd: 0;
       cdTUi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTUh() //  [R1]
         { info_tbl: [(cdTUh,
                       label: block_cdTUh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTUh: // global
           I64[Sp - 16] = block_cdTUn_info;
           _sdTPG::P64 = P64[R1 + 15];
           _sdTPH::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdTPH::P64;
           P64[Sp] = _sdTPG::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udTUU; else goto cdTUs;
       udTUU: // global
           call _cdTUn(R1) args: 0, res: 0, upd: 0;
       cdTUs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTUn() //  [R1]
         { info_tbl: [(cdTUn,
                       label: block_cdTUn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTUn: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdTUy; else goto cdTUx;
       cdTUy: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdTUx: // global
           _sdTPG::P64 = P64[Sp + 16];
           _sdTPH::P64 = P64[Sp + 8];
           _sdTPK::I64 = I64[R1 + 7];
           if (_sdTPK::I64 != 0) goto cdTUI; else goto cdTUP;
       cdTUI: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdTPK::I64 + 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = _sdTPG::P64;
           P64[Hp] = _sdTPH::P64;
           _sdTPu::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdTUO_info;
           R2 = Hp - 23;
           R1 = _sdTPu::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdTUP: // global
           Hp = Hp - 48;
           I64[Sp + 16] = block_cdTUM_info;
           R3 = _sdTPH::P64;
           R2 = _sdTPG::P64;
           Sp = Sp + 16;
           call Control.Concurrent.QSem.signalQSem2_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdTUM() //  [R1]
         { info_tbl: [(cdTUM,
                       label: block_cdTUM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTUM: // global
           _sdTPu::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdTUO_info;
           R2 = R1;
           R1 = _sdTPu::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTUO() //  []
         { info_tbl: [(cdTUO,
                       label: block_cdTUO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTUO: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSem.$wsignalQSem_entry() //  [R2]
         { info_tbl: [(cdTUY,
                       label: Control.Concurrent.QSem.$wsignalQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTUY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdTUZ; else goto cdTV0;
       cdTUZ: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.$wsignalQSem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdTV0: // global
           I64[Sp - 16] = block_cdTU6_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdTU6() //  [R1]
         { info_tbl: [(cdTU6,
                       label: block_cdTU6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTU6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdTV3; else goto cdTV2;
       cdTV3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdTV2: // global
           _sdTPu::P64 = P64[Sp + 8];
           if (R1 == 1) goto cdTUX; else goto cdTUW;
       cdTUX: // global
           Hp = Hp - 16;
           I64[Sp] = block_cdTV5_info;
           R1 = _sdTPu::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdTUW: // global
           I64[Hp - 8] = sat_sdTPT_info;
           P64[Hp] = _sdTPu::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdTV5() //  [R1]
         { info_tbl: [(cdTV5,
                       label: block_cdTV5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTV5: // global
           I64[Sp] = block_cdTV7_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udTVG; else goto cdTV8;
       udTVG: // global
           call _cdTV7(R1) args: 0, res: 0, upd: 0;
       cdTV8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTV7() //  [R1]
         { info_tbl: [(cdTV7,
                       label: block_cdTV7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTV7: // global
           I64[Sp - 16] = block_cdTVc_info;
           _sdTPZ::P64 = P64[R1 + 15];
           _sdTQ0::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdTQ0::P64;
           P64[Sp] = _sdTPZ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udTVH; else goto cdTVf;
       udTVH: // global
           call _cdTVc(R1) args: 0, res: 0, upd: 0;
       cdTVf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTVc() //  [R1]
         { info_tbl: [(cdTVc,
                       label: block_cdTVc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTVc: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdTVl; else goto cdTVk;
       cdTVl: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdTVk: // global
           _sdTPZ::P64 = P64[Sp + 16];
           _sdTQ0::P64 = P64[Sp + 8];
           _sdTQ3::I64 = I64[R1 + 7];
           if (_sdTQ3::I64 != 0) goto cdTVv; else goto cdTVC;
       cdTVv: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdTQ3::I64 + 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = _sdTPZ::P64;
           P64[Hp] = _sdTQ0::P64;
           _sdTPu::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdTVB_info;
           R2 = Hp - 23;
           R1 = _sdTPu::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdTVC: // global
           Hp = Hp - 48;
           I64[Sp + 16] = block_cdTVz_info;
           R3 = _sdTQ0::P64;
           R2 = _sdTPZ::P64;
           Sp = Sp + 16;
           call Control.Concurrent.QSem.signalQSem2_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdTVz() //  [R1]
         { info_tbl: [(cdTVz,
                       label: block_cdTVz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTVz: // global
           _sdTPu::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdTVB_info;
           R2 = R1;
           R1 = _sdTPu::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTVB() //  []
         { info_tbl: [(cdTVB,
                       label: block_cdTVB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTVB: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.288909794 UTC

[section ""data" . Control.Concurrent.QSem.signalQSem1_closure" {
     Control.Concurrent.QSem.signalQSem1_closure:
         const Control.Concurrent.QSem.signalQSem1_info;
 },
 Control.Concurrent.QSem.signalQSem1_entry() //  [R2]
         { info_tbl: [(cdTVP,
                       label: Control.Concurrent.QSem.signalQSem1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTVP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdTVQ; else goto cdTVR;
       cdTVQ: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.signalQSem1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdTVR: // global
           I64[Sp - 8] = block_cdTVM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udTVV; else goto cdTVN;
       udTVV: // global
           call _cdTVM(R1) args: 0, res: 0, upd: 0;
       cdTVN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTVM() //  [R1]
         { info_tbl: [(cdTVM,
                       label: block_cdTVM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTVM: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Control.Concurrent.QSem.$wsignalQSem_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.290189039 UTC

[section ""data" . Control.Concurrent.QSem.signalQSem_closure" {
     Control.Concurrent.QSem.signalQSem_closure:
         const Control.Concurrent.QSem.signalQSem_info;
 },
 Control.Concurrent.QSem.signalQSem_entry() //  [R2]
         { info_tbl: [(cdTW0,
                       label: Control.Concurrent.QSem.signalQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTW0: // global
           R2 = R2;
           call Control.Concurrent.QSem.signalQSem1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.293200521 UTC

[section ""data" . Control.Concurrent.QSem.$wlvl_closure" {
     Control.Concurrent.QSem.$wlvl_closure:
         const Control.Concurrent.QSem.$wlvl_info;
 },
 sat_sdTQO_entry() //  [R1]
         { info_tbl: [(cdTWl,
                       label: sat_sdTQO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTWl: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cdTWm; else goto cdTWn;
       cdTWm: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdTWn: // global
           I64[Sp - 24] = block_cdTWg_info;
           _sdTQg::P64 = P64[R1 + 7];
           _sdTQh::P64 = P64[R1 + 15];
           R1 = _sdTQh::P64;
           P64[Sp - 16] = _sdTQg::P64;
           P64[Sp - 8] = _sdTQh::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTWg() //  [R1]
         { info_tbl: [(cdTWg,
                       label: block_cdTWg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTWg: // global
           I64[Sp] = block_cdTWi_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udTXb; else goto cdTWj;
       udTXb: // global
           call _cdTWi(R1) args: 0, res: 0, upd: 0;
       cdTWj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTWi() //  [R1]
         { info_tbl: [(cdTWi,
                       label: block_cdTWi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTWi: // global
           I64[Sp - 32] = block_cdTWr_info;
           _sdTQs::P64 = R1;
           _sdTQt::P64 = P64[R1 + 7];
           _sdTQu::P64 = P64[R1 + 15];
           _sdTQv::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _sdTQt::P64;
           P64[Sp - 16] = _sdTQu::P64;
           P64[Sp - 8] = _sdTQv::P64;
           P64[Sp] = _sdTQs::P64;
           Sp = Sp - 32;
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTWr() //  [R1]
         { info_tbl: [(cdTWr,
                       label: block_cdTWr_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTWr: // global
           if (R1 == 0) goto cdTX7; else goto cdTWB;
       cdTX7: // global
           I64[Sp + 24] = block_cdTX4_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 40];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdTWB: // global
           _sdTQt::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdTWz_info;
           R1 = _sdTQt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udTXc; else goto cdTWC;
       udTXc: // global
           call _cdTWz(R1) args: 0, res: 0, upd: 0;
       cdTWC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTX4() //  []
         { info_tbl: [(cdTX4,
                       label: block_cdTX4_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTX4: // global
           _sdTQh::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdTX6_info;
           R2 = P64[Sp + 8];
           R1 = _sdTQh::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTWz() //  [R1]
         { info_tbl: [(cdTWz,
                       label: block_cdTWz_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTWz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdTWI; else goto cdTWH;
       cdTWI: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdTWH: // global
           _sdTQu::P64 = P64[Sp + 8];
           _sdTQv::P64 = P64[Sp + 16];
           _sdTQD::I64 = I64[R1 + 7];
           if (_sdTQD::I64 != 0) goto cdTWS; else goto cdTWZ;
       cdTWS: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdTQD::I64 + 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = _sdTQu::P64;
           P64[Hp] = _sdTQv::P64;
           _sdTQh::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cdTX6_info;
           R2 = Hp - 23;
           R1 = _sdTQh::P64;
           Sp = Sp + 40;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdTWZ: // global
           Hp = Hp - 48;
           I64[Sp + 32] = block_cdTWW_info;
           R3 = _sdTQv::P64;
           R2 = _sdTQu::P64;
           Sp = Sp + 32;
           call Control.Concurrent.QSem.signalQSem2_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdTWW() //  [R1]
         { info_tbl: [(cdTWW,
                       label: block_cdTWW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTWW: // global
           _sdTQh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdTX6_info;
           R2 = R1;
           R1 = _sdTQh::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTX6() //  []
         { info_tbl: [(cdTX6,
                       label: block_cdTX6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTX6: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSem.$wlvl_entry() //  [R2, R3, R4]
         { info_tbl: [(cdTXg,
                       label: Control.Concurrent.QSem.$wlvl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTXg: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdTXh; else goto cdTXi;
       cdTXh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSem.$wlvl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdTXi: // global
           I64[Sp - 32] = block_cdTW7_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdTW7() //  [R1]
         { info_tbl: [(cdTW7,
                       label: block_cdTW7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTW7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdTXl; else goto cdTXk;
       cdTXl: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdTXk: // global
           _sdTQh::P64 = P64[Sp + 16];
           if (R1 == 1) goto cdTXf; else goto cdTXe;
       cdTXf: // global
           Hp = Hp - 24;
           I64[Sp] = block_cdTXq_info;
           R1 = _sdTQh::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdTXe: // global
           I64[Hp - 16] = sat_sdTQO_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sdTQh::P64;
           I64[Sp + 16] = block_cdTXm_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTXq() //  [R1]
         { info_tbl: [(cdTXq,
                       label: block_cdTXq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTXq: // global
           I64[Sp] = block_cdTXs_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udTYi; else goto cdTXu;
       udTYi: // global
           call _cdTXs(R1) args: 0, res: 0, upd: 0;
       cdTXu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTXs() //  [R1]
         { info_tbl: [(cdTXs,
                       label: block_cdTXs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTXs: // global
           I64[Sp - 32] = block_cdTXy_info;
           _sdTQV::P64 = R1;
           _sdTQW::P64 = P64[R1 + 7];
           _sdTQX::P64 = P64[R1 + 15];
           _sdTQY::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _sdTQW::P64;
           P64[Sp - 16] = _sdTQX::P64;
           P64[Sp - 8] = _sdTQY::P64;
           P64[Sp] = _sdTQV::P64;
           Sp = Sp - 32;
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTXy() //  [R1]
         { info_tbl: [(cdTXy,
                       label: block_cdTXy_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTXy: // global
           if (R1 == 0) goto cdTYe; else goto cdTXI;
       cdTYe: // global
           I64[Sp + 24] = block_cdTYb_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 40];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdTXI: // global
           _sdTQW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdTXG_info;
           R1 = _sdTQW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udTYj; else goto cdTXJ;
       udTYj: // global
           call _cdTXG(R1) args: 0, res: 0, upd: 0;
       cdTXJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTYb() //  []
         { info_tbl: [(cdTYb,
                       label: block_cdTYb_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTYb: // global
           _sdTQh::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdTYd_info;
           R2 = P64[Sp + 8];
           R1 = _sdTQh::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTXG() //  [R1]
         { info_tbl: [(cdTXG,
                       label: block_cdTXG_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTXG: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdTXP; else goto cdTXO;
       cdTXP: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdTXO: // global
           _sdTQX::P64 = P64[Sp + 8];
           _sdTQY::P64 = P64[Sp + 16];
           _sdTR6::I64 = I64[R1 + 7];
           if (_sdTR6::I64 != 0) goto cdTXZ; else goto cdTY6;
       cdTXZ: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdTR6::I64 + 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = _sdTQX::P64;
           P64[Hp] = _sdTQY::P64;
           _sdTQh::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cdTYd_info;
           R2 = Hp - 23;
           R1 = _sdTQh::P64;
           Sp = Sp + 40;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdTY6: // global
           Hp = Hp - 48;
           I64[Sp + 32] = block_cdTY3_info;
           R3 = _sdTQY::P64;
           R2 = _sdTQX::P64;
           Sp = Sp + 32;
           call Control.Concurrent.QSem.signalQSem2_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdTY3() //  [R1]
         { info_tbl: [(cdTY3,
                       label: block_cdTY3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTY3: // global
           _sdTQh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdTYd_info;
           R2 = R1;
           R1 = _sdTQh::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTYd() //  []
         { info_tbl: [(cdTYd,
                       label: block_cdTYd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTYd: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdTXm() //  []
         { info_tbl: [(cdTXm,
                       label: block_cdTXm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTXm: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.302708238 UTC

[section ""data" . Control.Concurrent.QSem.$wwaitQSem_closure" {
     Control.Concurrent.QSem.$wwaitQSem_closure:
         const Control.Concurrent.QSem.$wwaitQSem_info;
 },
 sat_sdTRN_entry() //  [R1, R2]
         { info_tbl: [(cdTYW,
                       label: sat_sdTRN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTYW: // global
           R4 = R2;
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           call Control.Concurrent.QSem.$wlvl_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdTRK_entry() //  [R1]
         { info_tbl: [(cdTZ4,
                       label: sat_sdTRK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTZ4: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sdTRm_entry() //  [R1]
         { info_tbl: [(cdTZ7,
                       label: io_sdTRm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTZ7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdTZ8; else goto cdTZ9;
       cdTZ8: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdTZ9: // global
           I64[Sp - 16] = block_cdTYv_info;
           _sdTRh::P64 = P64[R1 + 7];
           R1 = _sdTRh::P64;
           P64[Sp - 8] = _sdTRh::P64;
           Sp = Sp - 16;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTYv() //  [R1]
         { info_tbl: [(cdTYv,
                       label: block_cdTYv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTYv: // global
           I64[Sp] = block_cdTYx_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udTZw; else goto cdTYy;
       udTZw: // global
           call _cdTYx(R1) args: 0, res: 0, upd: 0;
       cdTYy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTYx() //  [R1]
         { info_tbl: [(cdTYx,
                       label: block_cdTYx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTYx: // global
           I64[Sp - 16] = block_cdTYC_info;
           _sdTRt::P64 = P64[R1 + 15];
           _sdTRu::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdTRu::P64;
           P64[Sp] = _sdTRt::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udTZx; else goto cdTYD;
       udTZx: // global
           call _cdTYC(R1) args: 0, res: 0, upd: 0;
       cdTYD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTYC() //  [R1]
         { info_tbl: [(cdTYC,
                       label: block_cdTYC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTYC: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdTZe; else goto cdTZd;
       cdTZe: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdTZd: // global
           _sdTRx::I64 = I64[R1 + 7];
           if (_sdTRx::I64 == 0) goto cdTZp; else goto cdTZm;
       cdTZp: // global
           Hp = Hp - 48;
           I64[Sp - 8] = block_cdTYK_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
       cdTZm: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdTRx::I64 - 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _sdTRh::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdTZk_info;
           R2 = Hp - 23;
           R1 = _sdTRh::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTYK() //  [R1]
         { info_tbl: [(cdTYK,
                       label: block_cdTYK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTYK: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdTZs; else goto cdTZr;
       cdTZs: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdTZr: // global
           I64[Hp - 64] = GHC.MVar.MVar_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = Hp - 46;
           I64[Sp + 16] = block_cdTYP_info;
           R2 = Hp - 23;
           _sdTRE::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 24] = _sdTRE::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTYP() //  []
         { info_tbl: [(cdTYP,
                       label: block_cdTYP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTYP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdTZv; else goto cdTZu;
       cdTZv: // global
           HpAlloc = 40;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdTZu: // global
           I64[Hp - 32] = sat_sdTRN_info;
           P64[Hp - 24] = P64[Sp + 16];
           _sdTRE::P64 = P64[Sp + 8];
           P64[Hp - 16] = _sdTRE::P64;
           I64[Hp - 8] = sat_sdTRK_info;
           P64[Hp] = _sdTRE::P64;
           R2 = Hp - 30;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdTZk() //  []
         { info_tbl: [(cdTZk,
                       label: block_cdTZk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTZk: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSem.$wwaitQSem_entry() //  [R2]
         { info_tbl: [(cdTZC,
                       label: Control.Concurrent.QSem.$wwaitQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTZC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdTZD; else goto cdTZE;
       cdTZD: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.$wwaitQSem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdTZE: // global
           I64[Sp - 16] = block_cdTYo_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdTYo() //  [R1]
         { info_tbl: [(cdTYo,
                       label: block_cdTYo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTYo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdTZH; else goto cdTZG;
       cdTZH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdTZG: // global
           I64[Hp - 8] = io_sdTRm_info;
           P64[Hp] = P64[Sp + 8];
           _cdTYq::P64 = Hp - 7;
           if (R1 == 0) goto cdTZB; else goto cdTZA;
       cdTZB: // global
           R1 = _cdTYq::P64;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cdTZA: // global
           R1 = _cdTYq::P64;
           Sp = Sp + 16;
           call io_sdTRm_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.312691355 UTC

[section ""data" . Control.Concurrent.QSem.waitQSem1_closure" {
     Control.Concurrent.QSem.waitQSem1_closure:
         const Control.Concurrent.QSem.waitQSem1_info;
 },
 Control.Concurrent.QSem.waitQSem1_entry() //  [R2]
         { info_tbl: [(cdTZP,
                       label: Control.Concurrent.QSem.waitQSem1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTZP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdTZQ; else goto cdTZR;
       cdTZQ: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.waitQSem1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdTZR: // global
           I64[Sp - 8] = block_cdTZM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udTZV; else goto cdTZN;
       udTZV: // global
           call _cdTZM(R1) args: 0, res: 0, upd: 0;
       cdTZN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTZM() //  [R1]
         { info_tbl: [(cdTZM,
                       label: block_cdTZM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTZM: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Control.Concurrent.QSem.$wwaitQSem_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.314644751 UTC

[section ""data" . Control.Concurrent.QSem.waitQSem_closure" {
     Control.Concurrent.QSem.waitQSem_closure:
         const Control.Concurrent.QSem.waitQSem_info;
 },
 Control.Concurrent.QSem.waitQSem_entry() //  [R2]
         { info_tbl: [(cdU00,
                       label: Control.Concurrent.QSem.waitQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU00: // global
           R2 = R2;
           call Control.Concurrent.QSem.waitQSem1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.316424706 UTC

[section ""data" . Control.Concurrent.QSem.QSem_closure" {
     Control.Concurrent.QSem.QSem_closure:
         const Control.Concurrent.QSem.QSem_info;
 },
 Control.Concurrent.QSem.QSem_entry() //  [R2]
         { info_tbl: [(cdU08,
                       label: Control.Concurrent.QSem.QSem_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU08: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdU0c; else goto cdU0b;
       cdU0c: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Control.Concurrent.QSem.QSem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdU0b: // global
           I64[Hp - 8] = Control.Concurrent.QSem.QSem_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.318087656 UTC

[Control.Concurrent.QSem.QSem_con_entry() //  [R1]
         { info_tbl: [(cdU0d,
                       label: Control.Concurrent.QSem.QSem_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,81,83,101,109,46,81,83,101,109]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU0d: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.319278987 UTC

[section ""relreadonly" . SdTSm_srt" {
     SdTSm_srt:
         const GHC.IO.failIO1_closure;
         const Control.Concurrent.QSem.newQSem2_closure;
         const Control.Concurrent.QSem.newQSem1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.319969444 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:09.320921078 UTC

[section ""data" . Control.Concurrent.QSem.$WQSem_closure" {
     Control.Concurrent.QSem.$WQSem_closure:
         const Control.Concurrent.QSem.$WQSem_info;
 },
 Control.Concurrent.QSem.$WQSem_entry() //  [R2]
         { info_tbl: [(cdU0l,
                       label: Control.Concurrent.QSem.$WQSem_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU0l: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdU0p; else goto cdU0q;
       cdU0p: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.$WQSem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdU0q: // global
           I64[Sp - 8] = block_cdU0i_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udU0u; else goto cdU0j;
       udU0u: // global
           call _cdU0i(R1) args: 0, res: 0, upd: 0;
       cdU0j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU0i() //  [R1]
         { info_tbl: [(cdU0i,
                       label: block_cdU0i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU0i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdU0t; else goto cdU0s;
       cdU0t: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdU0s: // global
           _sdTOZ::P64 = P64[R1 + 7];
           I64[Hp - 8] = Control.Concurrent.QSem.QSem_con_info;
           P64[Hp] = _sdTOZ::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.322238691 UTC

[section ""cstring" . Control.Concurrent.QSem.$trModule4_bytes" {
     Control.Concurrent.QSem.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.322916337 UTC

[section ""data" . Control.Concurrent.QSem.$trModule3_closure" {
     Control.Concurrent.QSem.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSem.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.323533817 UTC

[section ""cstring" . Control.Concurrent.QSem.$trModule2_bytes" {
     Control.Concurrent.QSem.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,81,83,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.324149788 UTC

[section ""data" . Control.Concurrent.QSem.$trModule1_closure" {
     Control.Concurrent.QSem.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSem.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.324776857 UTC

[section ""data" . Control.Concurrent.QSem.$trModule_closure" {
     Control.Concurrent.QSem.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.QSem.$trModule3_closure+1;
         const Control.Concurrent.QSem.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.325532805 UTC

[section ""data" . $krep_rdTOF_closure" {
     $krep_rdTOF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.326189837 UTC

[section ""data" . $krep1_rdTOG_closure" {
     $krep1_rdTOG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.326854091 UTC

[section ""data" . $krep2_rdTOH_closure" {
     $krep2_rdTOH_closure:
         const :_con_info;
         const $krep_rdTOF_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.327539783 UTC

[section ""data" . $krep3_rdTOI_closure" {
     $krep3_rdTOI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep2_rdTOH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.328450362 UTC

[section ""data" . $krep4_rdTOJ_closure" {
     $krep4_rdTOJ_closure:
         const :_con_info;
         const $krep3_rdTOI_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.329404843 UTC

[section ""data" . $krep5_rdTOK_closure" {
     $krep5_rdTOK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep4_rdTOJ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.330292068 UTC

[section ""data" . $krep6_rdTOL_closure" {
     $krep6_rdTOL_closure:
         const :_con_info;
         const $krep5_rdTOK_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.331059625 UTC

[section ""data" . $krep7_rdTOM_closure" {
     $krep7_rdTOM_closure:
         const :_con_info;
         const $krep5_rdTOK_closure+1;
         const $krep6_rdTOL_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.331665802 UTC

[section ""data" . $krep8_rdTON_closure" {
     $krep8_rdTON_closure:
         const :_con_info;
         const $krep1_rdTOG_closure+1;
         const $krep7_rdTOM_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.332300611 UTC

[section ""data" . $krep9_rdTOO_closure" {
     $krep9_rdTOO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,,)_closure;
         const $krep8_rdTON_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.332870724 UTC

[section ""data" . $krep10_rdTOP_closure" {
     $krep10_rdTOP_closure:
         const :_con_info;
         const $krep9_rdTOO_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.333514758 UTC

[section ""data" . $krep11_rdTOQ_closure" {
     $krep11_rdTOQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep10_rdTOP_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.334133244 UTC

[section ""cstring" . Control.Concurrent.QSem.$tcQSem2_bytes" {
     Control.Concurrent.QSem.$tcQSem2_bytes:
         I8[] [81,83,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.334720566 UTC

[section ""data" . Control.Concurrent.QSem.$tcQSem1_closure" {
     Control.Concurrent.QSem.$tcQSem1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSem.$tcQSem2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.335317049 UTC

[section ""data" . Control.Concurrent.QSem.$tcQSem_closure" {
     Control.Concurrent.QSem.$tcQSem_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.QSem.$trModule_closure+1;
         const Control.Concurrent.QSem.$tcQSem1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9564161763912145234;
         const 3945938196429110556;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.335962738 UTC

[section ""data" . $krep12_rdTOR_closure" {
     $krep12_rdTOR_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Concurrent.QSem.$tcQSem_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.336628946 UTC

[section ""data" . Control.Concurrent.QSem.$tc'QSem1_closure" {
     Control.Concurrent.QSem.$tc'QSem1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_rdTOQ_closure+1;
         const $krep12_rdTOR_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.337400587 UTC

[section ""cstring" . Control.Concurrent.QSem.$tc'QSem3_bytes" {
     Control.Concurrent.QSem.$tc'QSem3_bytes:
         I8[] [39,81,83,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.33803092 UTC

[section ""data" . Control.Concurrent.QSem.$tc'QSem2_closure" {
     Control.Concurrent.QSem.$tc'QSem2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSem.$tc'QSem3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.338631122 UTC

[section ""data" . Control.Concurrent.QSem.$tc'QSem_closure" {
     Control.Concurrent.QSem.$tc'QSem_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.QSem.$trModule_closure+1;
         const Control.Concurrent.QSem.$tc'QSem2_closure+1;
         const Control.Concurrent.QSem.$tc'QSem1_closure+4;
         const 16012040391974534726;
         const 6627878139257558952;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.3392597 UTC

[section ""cstring" . lvl_rdTOS_bytes" {
     lvl_rdTOS_bytes:
         I8[] [110,101,119,81,83,101,109,58,32,73,110,105,116,105,97,108,32,113,117,97,110,116,105,116,121,32,109,117,115,116,32,98,101,32,110,111,110,45,110,101,103,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.340223875 UTC

[section ""data" . Control.Concurrent.QSem.newQSem2_closure" {
     Control.Concurrent.QSem.newQSem2_closure:
         const Control.Concurrent.QSem.newQSem2_info;
         const 0;
 },
 Control.Concurrent.QSem.newQSem2_entry() //  []
         { info_tbl: [(cdU0B,
                       label: Control.Concurrent.QSem.newQSem2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU0B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdU0C; else goto cdU0D;
       cdU0C: // global
           R1 = Control.Concurrent.QSem.newQSem2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdU0D: // global
           I64[Sp - 8] = block_cdU0z_info;
           R2 = lvl_rdTOS_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdU0z() //  [R1]
         { info_tbl: [(cdU0z,
                       label: block_cdU0z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU0z: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.341905485 UTC

[section ""data" . Control.Concurrent.QSem.newQSem1_closure" {
     Control.Concurrent.QSem.newQSem1_closure:
         const Control.Concurrent.QSem.newQSem1_info;
         const 0;
 },
 Control.Concurrent.QSem.newQSem1_entry() //  [R2]
         { info_tbl: [(cdU0O,
                       label: Control.Concurrent.QSem.newQSem1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU0O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdU0P; else goto cdU0Q;
       cdU0P: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.newQSem1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdU0Q: // global
           I64[Sp - 8] = block_cdU0L_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udU1c; else goto cdU0M;
       udU1c: // global
           call _cdU0L(R1) args: 0, res: 0, upd: 0;
       cdU0M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU0L() //  [R1]
         { info_tbl: [(cdU0L,
                       label: block_cdU0L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU0L: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto cdU14; else goto cdU1b;
       cdU14: // global
           I64[Sp - 8] = block_cdU0X_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
       cdU1b: // global
           Sp = Sp + 8;
           call Control.Concurrent.QSem.newQSem2_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cdU0X() //  [R1]
         { info_tbl: [(cdU0X,
                       label: block_cdU0X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU0X: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdU17; else goto cdU16;
       cdU17: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdU16: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp] = block_cdU10_info;
           R2 = Hp - 23;
           _sdTP9::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _sdTP9::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU10() //  []
         { info_tbl: [(cdU10,
                       label: block_cdU10_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU10: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdU1a; else goto cdU19;
       cdU1a: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdU19: // global
           I64[Hp - 8] = Control.Concurrent.QSem.QSem_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.343695551 UTC

[section ""data" . Control.Concurrent.QSem.newQSem_closure" {
     Control.Concurrent.QSem.newQSem_closure:
         const Control.Concurrent.QSem.newQSem_info;
         const 0;
 },
 Control.Concurrent.QSem.newQSem_entry() //  [R2]
         { info_tbl: [(cdU1h,
                       label: Control.Concurrent.QSem.newQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU1h: // global
           R2 = R2;
           call Control.Concurrent.QSem.newQSem1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.344505903 UTC

[section ""data" . lvl1_rdTOT_closure" {
     lvl1_rdTOT_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.34514971 UTC

[section ""data" . lvl2_rdTOU_closure" {
     lvl2_rdTOU_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.345829929 UTC

[section ""data" . lvl3_rdTOV_closure" {
     lvl3_rdTOV_closure:
         const (,,)_con_info;
         const lvl2_rdTOU_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.347385738 UTC

[section ""data" . Control.Concurrent.QSem.signalQSem2_closure" {
     Control.Concurrent.QSem.signalQSem2_closure:
         const Control.Concurrent.QSem.signalQSem2_info;
 },
 Control.Concurrent.QSem.signalQSem2_entry() //  [R2, R3]
         { info_tbl: [(cdU1v,
                       label: Control.Concurrent.QSem.signalQSem2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU1v: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdU1w; else goto udU2d;
       cdU1w: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSem.signalQSem2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       udU2d: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cdU1l() args: 0, res: 0, upd: 0;
     }
 },
 _cdU1l() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU1l: // global
           _sdTPd::P64 = P64[Sp];
           I64[Sp] = block_cdU1o_info;
           R1 = _sdTPd::P64;
           if (R1 & 7 != 0) goto udU2g; else goto cdU1p;
       udU2g: // global
           call _cdU1o(R1) args: 0, res: 0, upd: 0;
       cdU1p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU1o() //  [R1]
         { info_tbl: [(cdU1o,
                       label: block_cdU1o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU1o: // global
           if (R1 & 7 == 1) goto cdU1s; else goto cdU1t;
       cdU1s: // global
           _sdTPe::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdU1A_info;
           R1 = _sdTPe::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udU2h; else goto cdU1C;
       udU2h: // global
           call _cdU1A(R1) args: 0, res: 0, upd: 0;
       cdU1C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdU1t: // global
           I64[Sp - 8] = block_cdU1U_info;
           _sdTPm::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdTPm::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udU2i; else goto cdU1W;
       udU2i: // global
           call _cdU1U(R1) args: 0, res: 0, upd: 0;
       cdU1W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU1A() //  [R1]
         { info_tbl: [(cdU1A,
                       label: block_cdU1A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU1A: // global
           if (R1 & 7 == 1) goto cdU1I; else goto cdU1N;
       cdU1I: // global
           R1 = lvl3_rdTOV_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdU1N: // global
           I64[Sp] = block_cdU1L_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = R1;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdU1L() //  [R1]
         { info_tbl: [(cdU1L,
                       label: block_cdU1L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU1L: // global
           P64[Sp - 8] = R1;
           P64[Sp] = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call _cdU1l() args: 0, res: 0, upd: 0;
     }
 },
 _cdU1U() //  [R1]
         { info_tbl: [(cdU1U,
                       label: block_cdU1U_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU1U: // global
           I64[Sp] = block_cdU20_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[R1 + 7];
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU20() //  [R1]
         { info_tbl: [(cdU20,
                       label: block_cdU20_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU20: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdU25; else goto cdU24;
       cdU25: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdU24: // global
           _sdTPe::P64 = P64[Sp + 16];
           _sdTPm::P64 = P64[Sp + 8];
           if (R1 == 0) goto cdU2b; else goto cdU2a;
       cdU2b: // global
           Hp = Hp - 32;
           P64[Sp + 8] = _sdTPm::P64;
           P64[Sp + 16] = _sdTPe::P64;
           Sp = Sp + 8;
           call _cdU1l() args: 0, res: 0, upd: 0;
       cdU2a: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl1_rdTOT_closure+1;
           P64[Hp - 8] = _sdTPm::P64;
           P64[Hp] = _sdTPe::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.351917405 UTC

[section ""data" . Control.Concurrent.QSem.$wsignalQSem_closure" {
     Control.Concurrent.QSem.$wsignalQSem_closure:
         const Control.Concurrent.QSem.$wsignalQSem_info;
 },
 sat_sdTPT_entry() //  [R1]
         { info_tbl: [(cdU2E,
                       label: sat_sdTPT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU2E: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdU2I; else goto cdU2J;
       cdU2I: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdU2J: // global
           I64[Sp - 16] = block_cdU2z_info;
           _sdTPu::P64 = P64[R1 + 7];
           R1 = _sdTPu::P64;
           P64[Sp - 8] = _sdTPu::P64;
           Sp = Sp - 16;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU2z() //  [R1]
         { info_tbl: [(cdU2z,
                       label: block_cdU2z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU2z: // global
           I64[Sp] = block_cdU2B_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udU3d; else goto cdU2C;
       udU3d: // global
           call _cdU2B(R1) args: 0, res: 0, upd: 0;
       cdU2C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU2B() //  [R1]
         { info_tbl: [(cdU2B,
                       label: block_cdU2B_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU2B: // global
           I64[Sp - 16] = block_cdU2H_info;
           _sdTPG::P64 = P64[R1 + 15];
           _sdTPH::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdTPH::P64;
           P64[Sp] = _sdTPG::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udU3e; else goto cdU2M;
       udU3e: // global
           call _cdU2H(R1) args: 0, res: 0, upd: 0;
       cdU2M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU2H() //  [R1]
         { info_tbl: [(cdU2H,
                       label: block_cdU2H_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU2H: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdU2S; else goto cdU2R;
       cdU2S: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdU2R: // global
           _sdTPG::P64 = P64[Sp + 16];
           _sdTPH::P64 = P64[Sp + 8];
           _sdTPK::I64 = I64[R1 + 7];
           if (_sdTPK::I64 != 0) goto cdU32; else goto cdU39;
       cdU32: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdTPK::I64 + 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = _sdTPG::P64;
           P64[Hp] = _sdTPH::P64;
           _sdTPu::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdU38_info;
           R2 = Hp - 23;
           R1 = _sdTPu::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdU39: // global
           Hp = Hp - 48;
           I64[Sp + 16] = block_cdU36_info;
           R3 = _sdTPH::P64;
           R2 = _sdTPG::P64;
           Sp = Sp + 16;
           call Control.Concurrent.QSem.signalQSem2_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdU36() //  [R1]
         { info_tbl: [(cdU36,
                       label: block_cdU36_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU36: // global
           _sdTPu::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdU38_info;
           R2 = R1;
           R1 = _sdTPu::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU38() //  []
         { info_tbl: [(cdU38,
                       label: block_cdU38_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU38: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSem.$wsignalQSem_entry() //  [R2]
         { info_tbl: [(cdU3i,
                       label: Control.Concurrent.QSem.$wsignalQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU3i: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdU3j; else goto cdU3k;
       cdU3j: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.$wsignalQSem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdU3k: // global
           I64[Sp - 16] = block_cdU2q_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdU2q() //  [R1]
         { info_tbl: [(cdU2q,
                       label: block_cdU2q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU2q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdU3n; else goto cdU3m;
       cdU3n: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdU3m: // global
           _sdTPu::P64 = P64[Sp + 8];
           if (R1 == 1) goto cdU3h; else goto cdU3g;
       cdU3h: // global
           Hp = Hp - 16;
           I64[Sp] = block_cdU3p_info;
           R1 = _sdTPu::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdU3g: // global
           I64[Hp - 8] = sat_sdTPT_info;
           P64[Hp] = _sdTPu::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdU3p() //  [R1]
         { info_tbl: [(cdU3p,
                       label: block_cdU3p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU3p: // global
           I64[Sp] = block_cdU3r_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udU40; else goto cdU3s;
       udU40: // global
           call _cdU3r(R1) args: 0, res: 0, upd: 0;
       cdU3s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU3r() //  [R1]
         { info_tbl: [(cdU3r,
                       label: block_cdU3r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU3r: // global
           I64[Sp - 16] = block_cdU3w_info;
           _sdTPZ::P64 = P64[R1 + 15];
           _sdTQ0::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdTQ0::P64;
           P64[Sp] = _sdTPZ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udU41; else goto cdU3z;
       udU41: // global
           call _cdU3w(R1) args: 0, res: 0, upd: 0;
       cdU3z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU3w() //  [R1]
         { info_tbl: [(cdU3w,
                       label: block_cdU3w_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU3w: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdU3F; else goto cdU3E;
       cdU3F: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdU3E: // global
           _sdTPZ::P64 = P64[Sp + 16];
           _sdTQ0::P64 = P64[Sp + 8];
           _sdTQ3::I64 = I64[R1 + 7];
           if (_sdTQ3::I64 != 0) goto cdU3P; else goto cdU3W;
       cdU3P: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdTQ3::I64 + 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = _sdTPZ::P64;
           P64[Hp] = _sdTQ0::P64;
           _sdTPu::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdU3V_info;
           R2 = Hp - 23;
           R1 = _sdTPu::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdU3W: // global
           Hp = Hp - 48;
           I64[Sp + 16] = block_cdU3T_info;
           R3 = _sdTQ0::P64;
           R2 = _sdTPZ::P64;
           Sp = Sp + 16;
           call Control.Concurrent.QSem.signalQSem2_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdU3T() //  [R1]
         { info_tbl: [(cdU3T,
                       label: block_cdU3T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU3T: // global
           _sdTPu::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdU3V_info;
           R2 = R1;
           R1 = _sdTPu::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU3V() //  []
         { info_tbl: [(cdU3V,
                       label: block_cdU3V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU3V: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.356132669 UTC

[section ""data" . Control.Concurrent.QSem.signalQSem1_closure" {
     Control.Concurrent.QSem.signalQSem1_closure:
         const Control.Concurrent.QSem.signalQSem1_info;
 },
 Control.Concurrent.QSem.signalQSem1_entry() //  [R2]
         { info_tbl: [(cdU49,
                       label: Control.Concurrent.QSem.signalQSem1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU49: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdU4a; else goto cdU4b;
       cdU4a: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.signalQSem1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdU4b: // global
           I64[Sp - 8] = block_cdU46_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udU4f; else goto cdU47;
       udU4f: // global
           call _cdU46(R1) args: 0, res: 0, upd: 0;
       cdU47: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU46() //  [R1]
         { info_tbl: [(cdU46,
                       label: block_cdU46_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU46: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Control.Concurrent.QSem.$wsignalQSem_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.359139122 UTC

[section ""data" . Control.Concurrent.QSem.signalQSem_closure" {
     Control.Concurrent.QSem.signalQSem_closure:
         const Control.Concurrent.QSem.signalQSem_info;
 },
 Control.Concurrent.QSem.signalQSem_entry() //  [R2]
         { info_tbl: [(cdU4k,
                       label: Control.Concurrent.QSem.signalQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU4k: // global
           R2 = R2;
           call Control.Concurrent.QSem.signalQSem1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.361947081 UTC

[section ""data" . Control.Concurrent.QSem.$wlvl_closure" {
     Control.Concurrent.QSem.$wlvl_closure:
         const Control.Concurrent.QSem.$wlvl_info;
 },
 sat_sdTQO_entry() //  [R1]
         { info_tbl: [(cdU4F,
                       label: sat_sdTQO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU4F: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cdU4G; else goto cdU4H;
       cdU4G: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdU4H: // global
           I64[Sp - 24] = block_cdU4A_info;
           _sdTQg::P64 = P64[R1 + 7];
           _sdTQh::P64 = P64[R1 + 15];
           R1 = _sdTQh::P64;
           P64[Sp - 16] = _sdTQg::P64;
           P64[Sp - 8] = _sdTQh::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU4A() //  [R1]
         { info_tbl: [(cdU4A,
                       label: block_cdU4A_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU4A: // global
           I64[Sp] = block_cdU4C_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udU5v; else goto cdU4D;
       udU5v: // global
           call _cdU4C(R1) args: 0, res: 0, upd: 0;
       cdU4D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU4C() //  [R1]
         { info_tbl: [(cdU4C,
                       label: block_cdU4C_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU4C: // global
           I64[Sp - 32] = block_cdU4L_info;
           _sdTQs::P64 = R1;
           _sdTQt::P64 = P64[R1 + 7];
           _sdTQu::P64 = P64[R1 + 15];
           _sdTQv::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _sdTQt::P64;
           P64[Sp - 16] = _sdTQu::P64;
           P64[Sp - 8] = _sdTQv::P64;
           P64[Sp] = _sdTQs::P64;
           Sp = Sp - 32;
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU4L() //  [R1]
         { info_tbl: [(cdU4L,
                       label: block_cdU4L_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU4L: // global
           if (R1 == 0) goto cdU5r; else goto cdU4V;
       cdU5r: // global
           I64[Sp + 24] = block_cdU5o_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 40];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdU4V: // global
           _sdTQt::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdU4T_info;
           R1 = _sdTQt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udU5w; else goto cdU4W;
       udU5w: // global
           call _cdU4T(R1) args: 0, res: 0, upd: 0;
       cdU4W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU5o() //  []
         { info_tbl: [(cdU5o,
                       label: block_cdU5o_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU5o: // global
           _sdTQh::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdU5q_info;
           R2 = P64[Sp + 8];
           R1 = _sdTQh::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU4T() //  [R1]
         { info_tbl: [(cdU4T,
                       label: block_cdU4T_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU4T: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdU52; else goto cdU51;
       cdU52: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdU51: // global
           _sdTQu::P64 = P64[Sp + 8];
           _sdTQv::P64 = P64[Sp + 16];
           _sdTQD::I64 = I64[R1 + 7];
           if (_sdTQD::I64 != 0) goto cdU5c; else goto cdU5j;
       cdU5c: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdTQD::I64 + 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = _sdTQu::P64;
           P64[Hp] = _sdTQv::P64;
           _sdTQh::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cdU5q_info;
           R2 = Hp - 23;
           R1 = _sdTQh::P64;
           Sp = Sp + 40;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdU5j: // global
           Hp = Hp - 48;
           I64[Sp + 32] = block_cdU5g_info;
           R3 = _sdTQv::P64;
           R2 = _sdTQu::P64;
           Sp = Sp + 32;
           call Control.Concurrent.QSem.signalQSem2_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdU5g() //  [R1]
         { info_tbl: [(cdU5g,
                       label: block_cdU5g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU5g: // global
           _sdTQh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdU5q_info;
           R2 = R1;
           R1 = _sdTQh::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU5q() //  []
         { info_tbl: [(cdU5q,
                       label: block_cdU5q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU5q: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSem.$wlvl_entry() //  [R2, R3, R4]
         { info_tbl: [(cdU5A,
                       label: Control.Concurrent.QSem.$wlvl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU5A: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdU5B; else goto cdU5C;
       cdU5B: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSem.$wlvl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdU5C: // global
           I64[Sp - 32] = block_cdU4r_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdU4r() //  [R1]
         { info_tbl: [(cdU4r,
                       label: block_cdU4r_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU4r: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdU5F; else goto cdU5E;
       cdU5F: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdU5E: // global
           _sdTQh::P64 = P64[Sp + 16];
           if (R1 == 1) goto cdU5z; else goto cdU5y;
       cdU5z: // global
           Hp = Hp - 24;
           I64[Sp] = block_cdU5K_info;
           R1 = _sdTQh::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdU5y: // global
           I64[Hp - 16] = sat_sdTQO_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sdTQh::P64;
           I64[Sp + 16] = block_cdU5G_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU5K() //  [R1]
         { info_tbl: [(cdU5K,
                       label: block_cdU5K_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU5K: // global
           I64[Sp] = block_cdU5M_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udU6C; else goto cdU5O;
       udU6C: // global
           call _cdU5M(R1) args: 0, res: 0, upd: 0;
       cdU5O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU5M() //  [R1]
         { info_tbl: [(cdU5M,
                       label: block_cdU5M_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU5M: // global
           I64[Sp - 32] = block_cdU5S_info;
           _sdTQV::P64 = R1;
           _sdTQW::P64 = P64[R1 + 7];
           _sdTQX::P64 = P64[R1 + 15];
           _sdTQY::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _sdTQW::P64;
           P64[Sp - 16] = _sdTQX::P64;
           P64[Sp - 8] = _sdTQY::P64;
           P64[Sp] = _sdTQV::P64;
           Sp = Sp - 32;
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU5S() //  [R1]
         { info_tbl: [(cdU5S,
                       label: block_cdU5S_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU5S: // global
           if (R1 == 0) goto cdU6y; else goto cdU62;
       cdU6y: // global
           I64[Sp + 24] = block_cdU6v_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 40];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdU62: // global
           _sdTQW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdU60_info;
           R1 = _sdTQW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udU6D; else goto cdU63;
       udU6D: // global
           call _cdU60(R1) args: 0, res: 0, upd: 0;
       cdU63: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU6v() //  []
         { info_tbl: [(cdU6v,
                       label: block_cdU6v_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU6v: // global
           _sdTQh::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdU6x_info;
           R2 = P64[Sp + 8];
           R1 = _sdTQh::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU60() //  [R1]
         { info_tbl: [(cdU60,
                       label: block_cdU60_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU60: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdU69; else goto cdU68;
       cdU69: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdU68: // global
           _sdTQX::P64 = P64[Sp + 8];
           _sdTQY::P64 = P64[Sp + 16];
           _sdTR6::I64 = I64[R1 + 7];
           if (_sdTR6::I64 != 0) goto cdU6j; else goto cdU6q;
       cdU6j: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdTR6::I64 + 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = _sdTQX::P64;
           P64[Hp] = _sdTQY::P64;
           _sdTQh::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cdU6x_info;
           R2 = Hp - 23;
           R1 = _sdTQh::P64;
           Sp = Sp + 40;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdU6q: // global
           Hp = Hp - 48;
           I64[Sp + 32] = block_cdU6n_info;
           R3 = _sdTQY::P64;
           R2 = _sdTQX::P64;
           Sp = Sp + 32;
           call Control.Concurrent.QSem.signalQSem2_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdU6n() //  [R1]
         { info_tbl: [(cdU6n,
                       label: block_cdU6n_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU6n: // global
           _sdTQh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdU6x_info;
           R2 = R1;
           R1 = _sdTQh::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU6x() //  []
         { info_tbl: [(cdU6x,
                       label: block_cdU6x_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU6x: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdU5G() //  []
         { info_tbl: [(cdU5G,
                       label: block_cdU5G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU5G: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.368585679 UTC

[section ""data" . Control.Concurrent.QSem.$wwaitQSem_closure" {
     Control.Concurrent.QSem.$wwaitQSem_closure:
         const Control.Concurrent.QSem.$wwaitQSem_info;
 },
 sat_sdTRN_entry() //  [R1, R2]
         { info_tbl: [(cdU7g,
                       label: sat_sdTRN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU7g: // global
           R4 = R2;
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           call Control.Concurrent.QSem.$wlvl_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdTRK_entry() //  [R1]
         { info_tbl: [(cdU7o,
                       label: sat_sdTRK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU7o: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sdTRm_entry() //  [R1]
         { info_tbl: [(cdU7r,
                       label: io_sdTRm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU7r: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdU7s; else goto cdU7t;
       cdU7s: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdU7t: // global
           I64[Sp - 16] = block_cdU6P_info;
           _sdTRh::P64 = P64[R1 + 7];
           R1 = _sdTRh::P64;
           P64[Sp - 8] = _sdTRh::P64;
           Sp = Sp - 16;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU6P() //  [R1]
         { info_tbl: [(cdU6P,
                       label: block_cdU6P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU6P: // global
           I64[Sp] = block_cdU6R_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udU7Q; else goto cdU6S;
       udU7Q: // global
           call _cdU6R(R1) args: 0, res: 0, upd: 0;
       cdU6S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU6R() //  [R1]
         { info_tbl: [(cdU6R,
                       label: block_cdU6R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU6R: // global
           I64[Sp - 16] = block_cdU6W_info;
           _sdTRt::P64 = P64[R1 + 15];
           _sdTRu::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdTRu::P64;
           P64[Sp] = _sdTRt::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udU7R; else goto cdU6X;
       udU7R: // global
           call _cdU6W(R1) args: 0, res: 0, upd: 0;
       cdU6X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU6W() //  [R1]
         { info_tbl: [(cdU6W,
                       label: block_cdU6W_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU6W: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdU7y; else goto cdU7x;
       cdU7y: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdU7x: // global
           _sdTRx::I64 = I64[R1 + 7];
           if (_sdTRx::I64 == 0) goto cdU7J; else goto cdU7G;
       cdU7J: // global
           Hp = Hp - 48;
           I64[Sp - 8] = block_cdU74_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
       cdU7G: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdTRx::I64 - 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _sdTRh::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdU7E_info;
           R2 = Hp - 23;
           R1 = _sdTRh::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU74() //  [R1]
         { info_tbl: [(cdU74,
                       label: block_cdU74_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU74: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdU7M; else goto cdU7L;
       cdU7M: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdU7L: // global
           I64[Hp - 64] = GHC.MVar.MVar_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = Hp - 46;
           I64[Sp + 16] = block_cdU79_info;
           R2 = Hp - 23;
           _sdTRE::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 24] = _sdTRE::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU79() //  []
         { info_tbl: [(cdU79,
                       label: block_cdU79_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU79: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdU7P; else goto cdU7O;
       cdU7P: // global
           HpAlloc = 40;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdU7O: // global
           I64[Hp - 32] = sat_sdTRN_info;
           P64[Hp - 24] = P64[Sp + 16];
           _sdTRE::P64 = P64[Sp + 8];
           P64[Hp - 16] = _sdTRE::P64;
           I64[Hp - 8] = sat_sdTRK_info;
           P64[Hp] = _sdTRE::P64;
           R2 = Hp - 30;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdU7E() //  []
         { info_tbl: [(cdU7E,
                       label: block_cdU7E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU7E: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSem.$wwaitQSem_entry() //  [R2]
         { info_tbl: [(cdU7W,
                       label: Control.Concurrent.QSem.$wwaitQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU7W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdU7X; else goto cdU7Y;
       cdU7X: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.$wwaitQSem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdU7Y: // global
           I64[Sp - 16] = block_cdU6I_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdU6I() //  [R1]
         { info_tbl: [(cdU6I,
                       label: block_cdU6I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU6I: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdU81; else goto cdU80;
       cdU81: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdU80: // global
           I64[Hp - 8] = io_sdTRm_info;
           P64[Hp] = P64[Sp + 8];
           _cdU6K::P64 = Hp - 7;
           if (R1 == 0) goto cdU7V; else goto cdU7U;
       cdU7V: // global
           R1 = _cdU6K::P64;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cdU7U: // global
           R1 = _cdU6K::P64;
           Sp = Sp + 16;
           call io_sdTRm_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.372678596 UTC

[section ""data" . Control.Concurrent.QSem.waitQSem1_closure" {
     Control.Concurrent.QSem.waitQSem1_closure:
         const Control.Concurrent.QSem.waitQSem1_info;
 },
 Control.Concurrent.QSem.waitQSem1_entry() //  [R2]
         { info_tbl: [(cdU89,
                       label: Control.Concurrent.QSem.waitQSem1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU89: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdU8a; else goto cdU8b;
       cdU8a: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.waitQSem1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdU8b: // global
           I64[Sp - 8] = block_cdU86_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udU8f; else goto cdU87;
       udU8f: // global
           call _cdU86(R1) args: 0, res: 0, upd: 0;
       cdU87: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU86() //  [R1]
         { info_tbl: [(cdU86,
                       label: block_cdU86_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU86: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Control.Concurrent.QSem.$wwaitQSem_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.374045342 UTC

[section ""data" . Control.Concurrent.QSem.waitQSem_closure" {
     Control.Concurrent.QSem.waitQSem_closure:
         const Control.Concurrent.QSem.waitQSem_info;
 },
 Control.Concurrent.QSem.waitQSem_entry() //  [R2]
         { info_tbl: [(cdU8k,
                       label: Control.Concurrent.QSem.waitQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU8k: // global
           R2 = R2;
           call Control.Concurrent.QSem.waitQSem1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.37501503 UTC

[section ""data" . Control.Concurrent.QSem.QSem_closure" {
     Control.Concurrent.QSem.QSem_closure:
         const Control.Concurrent.QSem.QSem_info;
 },
 Control.Concurrent.QSem.QSem_entry() //  [R2]
         { info_tbl: [(cdU8s,
                       label: Control.Concurrent.QSem.QSem_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU8s: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdU8w; else goto cdU8v;
       cdU8w: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Control.Concurrent.QSem.QSem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdU8v: // global
           I64[Hp - 8] = Control.Concurrent.QSem.QSem_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.375892803 UTC

[Control.Concurrent.QSem.QSem_con_entry() //  [R1]
         { info_tbl: [(cdU8x,
                       label: Control.Concurrent.QSem.QSem_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,81,83,101,109,46,81,83,101,109]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU8x: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.376664133 UTC

[section ""relreadonly" . SdTSm_srt" {
     SdTSm_srt:
         const GHC.IO.failIO1_closure;
         const Control.Concurrent.QSem.newQSem2_closure;
         const Control.Concurrent.QSem.newQSem1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.377627284 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:09.379300278 UTC

[section ""data" . Control.Concurrent.QSem.$WQSem_closure" {
     Control.Concurrent.QSem.$WQSem_closure:
         const Control.Concurrent.QSem.$WQSem_info;
 },
 Control.Concurrent.QSem.$WQSem_entry() //  [R2]
         { info_tbl: [(cdU8G,
                       label: Control.Concurrent.QSem.$WQSem_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU8G: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdU8K; else goto cdU8L;
       cdU8K: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.$WQSem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdU8L: // global
           I64[Sp - 8] = block_cdU8D_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udU8P; else goto cdU8E;
       udU8P: // global
           call _cdU8D(R1) args: 0, res: 0, upd: 0;
       cdU8E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU8D() //  [R1]
         { info_tbl: [(cdU8D,
                       label: block_cdU8D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU8D: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdU8O; else goto cdU8N;
       cdU8O: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdU8N: // global
           _sdTOZ::P64 = P64[R1 + 7];
           I64[Hp - 8] = Control.Concurrent.QSem.QSem_con_info;
           P64[Hp] = _sdTOZ::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.386235235 UTC

[section ""cstring" . Control.Concurrent.QSem.$trModule4_bytes" {
     Control.Concurrent.QSem.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.388116181 UTC

[section ""data" . Control.Concurrent.QSem.$trModule3_closure" {
     Control.Concurrent.QSem.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSem.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.390085591 UTC

[section ""cstring" . Control.Concurrent.QSem.$trModule2_bytes" {
     Control.Concurrent.QSem.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,81,83,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.39198444 UTC

[section ""data" . Control.Concurrent.QSem.$trModule1_closure" {
     Control.Concurrent.QSem.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSem.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.393935102 UTC

[section ""data" . Control.Concurrent.QSem.$trModule_closure" {
     Control.Concurrent.QSem.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.QSem.$trModule3_closure+1;
         const Control.Concurrent.QSem.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.39583595 UTC

[section ""data" . $krep_rdTOF_closure" {
     $krep_rdTOF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.397766394 UTC

[section ""data" . $krep1_rdTOG_closure" {
     $krep1_rdTOG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.39969164 UTC

[section ""data" . $krep2_rdTOH_closure" {
     $krep2_rdTOH_closure:
         const :_con_info;
         const $krep_rdTOF_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.401677698 UTC

[section ""data" . $krep3_rdTOI_closure" {
     $krep3_rdTOI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep2_rdTOH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.405013443 UTC

[section ""data" . $krep4_rdTOJ_closure" {
     $krep4_rdTOJ_closure:
         const :_con_info;
         const $krep3_rdTOI_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.407231951 UTC

[section ""data" . $krep5_rdTOK_closure" {
     $krep5_rdTOK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep4_rdTOJ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.40916219 UTC

[section ""data" . $krep6_rdTOL_closure" {
     $krep6_rdTOL_closure:
         const :_con_info;
         const $krep5_rdTOK_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.411105119 UTC

[section ""data" . $krep7_rdTOM_closure" {
     $krep7_rdTOM_closure:
         const :_con_info;
         const $krep5_rdTOK_closure+1;
         const $krep6_rdTOL_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.412944949 UTC

[section ""data" . $krep8_rdTON_closure" {
     $krep8_rdTON_closure:
         const :_con_info;
         const $krep1_rdTOG_closure+1;
         const $krep7_rdTOM_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.415313766 UTC

[section ""data" . $krep9_rdTOO_closure" {
     $krep9_rdTOO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,,)_closure;
         const $krep8_rdTON_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.417170959 UTC

[section ""data" . $krep10_rdTOP_closure" {
     $krep10_rdTOP_closure:
         const :_con_info;
         const $krep9_rdTOO_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.419126845 UTC

[section ""data" . $krep11_rdTOQ_closure" {
     $krep11_rdTOQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep10_rdTOP_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.421059108 UTC

[section ""cstring" . Control.Concurrent.QSem.$tcQSem2_bytes" {
     Control.Concurrent.QSem.$tcQSem2_bytes:
         I8[] [81,83,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.422895561 UTC

[section ""data" . Control.Concurrent.QSem.$tcQSem1_closure" {
     Control.Concurrent.QSem.$tcQSem1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSem.$tcQSem2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.424942219 UTC

[section ""data" . Control.Concurrent.QSem.$tcQSem_closure" {
     Control.Concurrent.QSem.$tcQSem_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.QSem.$trModule_closure+1;
         const Control.Concurrent.QSem.$tcQSem1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9564161763912145234;
         const 3945938196429110556;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.427958232 UTC

[section ""data" . $krep12_rdTOR_closure" {
     $krep12_rdTOR_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Concurrent.QSem.$tcQSem_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.429864023 UTC

[section ""data" . Control.Concurrent.QSem.$tc'QSem1_closure" {
     Control.Concurrent.QSem.$tc'QSem1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_rdTOQ_closure+1;
         const $krep12_rdTOR_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.431833432 UTC

[section ""cstring" . Control.Concurrent.QSem.$tc'QSem3_bytes" {
     Control.Concurrent.QSem.$tc'QSem3_bytes:
         I8[] [39,81,83,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.434836216 UTC

[section ""data" . Control.Concurrent.QSem.$tc'QSem2_closure" {
     Control.Concurrent.QSem.$tc'QSem2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSem.$tc'QSem3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.43696002 UTC

[section ""data" . Control.Concurrent.QSem.$tc'QSem_closure" {
     Control.Concurrent.QSem.$tc'QSem_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.QSem.$trModule_closure+1;
         const Control.Concurrent.QSem.$tc'QSem2_closure+1;
         const Control.Concurrent.QSem.$tc'QSem1_closure+4;
         const 16012040391974534726;
         const 6627878139257558952;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.439708782 UTC

[section ""cstring" . lvl_rdTOS_bytes" {
     lvl_rdTOS_bytes:
         I8[] [110,101,119,81,83,101,109,58,32,73,110,105,116,105,97,108,32,113,117,97,110,116,105,116,121,32,109,117,115,116,32,98,101,32,110,111,110,45,110,101,103,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.442019318 UTC

[section ""data" . Control.Concurrent.QSem.newQSem2_closure" {
     Control.Concurrent.QSem.newQSem2_closure:
         const Control.Concurrent.QSem.newQSem2_info;
         const 0;
 },
 Control.Concurrent.QSem.newQSem2_entry() //  []
         { info_tbl: [(cdU9w,
                       label: Control.Concurrent.QSem.newQSem2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU9w: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdU9x; else goto cdU9y;
       cdU9x: // global
           R1 = Control.Concurrent.QSem.newQSem2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdU9y: // global
           I64[Sp - 8] = block_cdU9u_info;
           R2 = lvl_rdTOS_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdU9u() //  [R1]
         { info_tbl: [(cdU9u,
                       label: block_cdU9u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU9u: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.448526199 UTC

[section ""data" . Control.Concurrent.QSem.newQSem1_closure" {
     Control.Concurrent.QSem.newQSem1_closure:
         const Control.Concurrent.QSem.newQSem1_info;
         const 0;
 },
 Control.Concurrent.QSem.newQSem1_entry() //  [R2]
         { info_tbl: [(cdU9R,
                       label: Control.Concurrent.QSem.newQSem1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU9R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdU9S; else goto cdU9T;
       cdU9S: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.newQSem1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdU9T: // global
           I64[Sp - 8] = block_cdU9O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udUaf; else goto cdU9P;
       udUaf: // global
           call _cdU9O(R1) args: 0, res: 0, upd: 0;
       cdU9P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdU9O() //  [R1]
         { info_tbl: [(cdU9O,
                       label: block_cdU9O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdU9O: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto cdUa7; else goto cdUae;
       cdUa7: // global
           I64[Sp - 8] = block_cdUa0_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
       cdUae: // global
           Sp = Sp + 8;
           call Control.Concurrent.QSem.newQSem2_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cdUa0() //  [R1]
         { info_tbl: [(cdUa0,
                       label: block_cdUa0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUa0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdUaa; else goto cdUa9;
       cdUaa: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdUa9: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp] = block_cdUa3_info;
           R2 = Hp - 23;
           _sdTP9::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _sdTP9::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUa3() //  []
         { info_tbl: [(cdUa3,
                       label: block_cdUa3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUa3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdUad; else goto cdUac;
       cdUad: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdUac: // global
           I64[Hp - 8] = Control.Concurrent.QSem.QSem_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.460929316 UTC

[section ""data" . Control.Concurrent.QSem.newQSem_closure" {
     Control.Concurrent.QSem.newQSem_closure:
         const Control.Concurrent.QSem.newQSem_info;
         const 0;
 },
 Control.Concurrent.QSem.newQSem_entry() //  [R2]
         { info_tbl: [(cdUaC,
                       label: Control.Concurrent.QSem.newQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUaC: // global
           R2 = R2;
           call Control.Concurrent.QSem.newQSem1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.466262217 UTC

[section ""data" . lvl1_rdTOT_closure" {
     lvl1_rdTOT_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.468794767 UTC

[section ""data" . lvl2_rdTOU_closure" {
     lvl2_rdTOU_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.471287631 UTC

[section ""data" . lvl3_rdTOV_closure" {
     lvl3_rdTOV_closure:
         const (,,)_con_info;
         const lvl2_rdTOU_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.475837102 UTC

[section ""data" . Control.Concurrent.QSem.signalQSem2_closure" {
     Control.Concurrent.QSem.signalQSem2_closure:
         const Control.Concurrent.QSem.signalQSem2_info;
 },
 Control.Concurrent.QSem.signalQSem2_entry() //  [R2, R3]
         { info_tbl: [(cdUaX,
                       label: Control.Concurrent.QSem.signalQSem2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUaX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdUaY; else goto udUbF;
       cdUaY: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSem.signalQSem2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       udUbF: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cdUaN() args: 0, res: 0, upd: 0;
     }
 },
 _cdUaN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUaN: // global
           _sdTPd::P64 = P64[Sp];
           I64[Sp] = block_cdUaQ_info;
           R1 = _sdTPd::P64;
           if (R1 & 7 != 0) goto udUbI; else goto cdUaR;
       udUbI: // global
           call _cdUaQ(R1) args: 0, res: 0, upd: 0;
       cdUaR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUaQ() //  [R1]
         { info_tbl: [(cdUaQ,
                       label: block_cdUaQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUaQ: // global
           if (R1 & 7 == 1) goto cdUaU; else goto cdUaV;
       cdUaU: // global
           _sdTPe::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdUb2_info;
           R1 = _sdTPe::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udUbJ; else goto cdUb4;
       udUbJ: // global
           call _cdUb2(R1) args: 0, res: 0, upd: 0;
       cdUb4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdUaV: // global
           I64[Sp - 8] = block_cdUbm_info;
           _sdTPm::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdTPm::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udUbK; else goto cdUbo;
       udUbK: // global
           call _cdUbm(R1) args: 0, res: 0, upd: 0;
       cdUbo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUb2() //  [R1]
         { info_tbl: [(cdUb2,
                       label: block_cdUb2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUb2: // global
           if (R1 & 7 == 1) goto cdUba; else goto cdUbf;
       cdUba: // global
           R1 = lvl3_rdTOV_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdUbf: // global
           I64[Sp] = block_cdUbd_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = R1;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdUbd() //  [R1]
         { info_tbl: [(cdUbd,
                       label: block_cdUbd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUbd: // global
           P64[Sp - 8] = R1;
           P64[Sp] = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call _cdUaN() args: 0, res: 0, upd: 0;
     }
 },
 _cdUbm() //  [R1]
         { info_tbl: [(cdUbm,
                       label: block_cdUbm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUbm: // global
           I64[Sp] = block_cdUbs_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[R1 + 7];
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUbs() //  [R1]
         { info_tbl: [(cdUbs,
                       label: block_cdUbs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUbs: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdUbx; else goto cdUbw;
       cdUbx: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdUbw: // global
           _sdTPe::P64 = P64[Sp + 16];
           _sdTPm::P64 = P64[Sp + 8];
           if (R1 == 0) goto cdUbD; else goto cdUbC;
       cdUbD: // global
           Hp = Hp - 32;
           P64[Sp + 8] = _sdTPm::P64;
           P64[Sp + 16] = _sdTPe::P64;
           Sp = Sp + 8;
           call _cdUaN() args: 0, res: 0, upd: 0;
       cdUbC: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl1_rdTOT_closure+1;
           P64[Hp - 8] = _sdTPm::P64;
           P64[Hp] = _sdTPe::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.492987757 UTC

[section ""data" . Control.Concurrent.QSem.$wsignalQSem_closure" {
     Control.Concurrent.QSem.$wsignalQSem_closure:
         const Control.Concurrent.QSem.$wsignalQSem_info;
 },
 sat_sdTPT_entry() //  [R1]
         { info_tbl: [(cdUcB,
                       label: sat_sdTPT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUcB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdUcF; else goto cdUcG;
       cdUcF: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdUcG: // global
           I64[Sp - 16] = block_cdUcw_info;
           _sdTPu::P64 = P64[R1 + 7];
           R1 = _sdTPu::P64;
           P64[Sp - 8] = _sdTPu::P64;
           Sp = Sp - 16;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUcw() //  [R1]
         { info_tbl: [(cdUcw,
                       label: block_cdUcw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUcw: // global
           I64[Sp] = block_cdUcy_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udUda; else goto cdUcz;
       udUda: // global
           call _cdUcy(R1) args: 0, res: 0, upd: 0;
       cdUcz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUcy() //  [R1]
         { info_tbl: [(cdUcy,
                       label: block_cdUcy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUcy: // global
           I64[Sp - 16] = block_cdUcE_info;
           _sdTPG::P64 = P64[R1 + 15];
           _sdTPH::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdTPH::P64;
           P64[Sp] = _sdTPG::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udUdb; else goto cdUcJ;
       udUdb: // global
           call _cdUcE(R1) args: 0, res: 0, upd: 0;
       cdUcJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUcE() //  [R1]
         { info_tbl: [(cdUcE,
                       label: block_cdUcE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUcE: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdUcP; else goto cdUcO;
       cdUcP: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdUcO: // global
           _sdTPG::P64 = P64[Sp + 16];
           _sdTPH::P64 = P64[Sp + 8];
           _sdTPK::I64 = I64[R1 + 7];
           if (_sdTPK::I64 != 0) goto cdUcZ; else goto cdUd6;
       cdUcZ: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdTPK::I64 + 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = _sdTPG::P64;
           P64[Hp] = _sdTPH::P64;
           _sdTPu::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdUd5_info;
           R2 = Hp - 23;
           R1 = _sdTPu::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdUd6: // global
           Hp = Hp - 48;
           I64[Sp + 16] = block_cdUd3_info;
           R3 = _sdTPH::P64;
           R2 = _sdTPG::P64;
           Sp = Sp + 16;
           call Control.Concurrent.QSem.signalQSem2_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdUd3() //  [R1]
         { info_tbl: [(cdUd3,
                       label: block_cdUd3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUd3: // global
           _sdTPu::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdUd5_info;
           R2 = R1;
           R1 = _sdTPu::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUd5() //  []
         { info_tbl: [(cdUd5,
                       label: block_cdUd5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUd5: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSem.$wsignalQSem_entry() //  [R2]
         { info_tbl: [(cdUdf,
                       label: Control.Concurrent.QSem.$wsignalQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUdf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdUdg; else goto cdUdh;
       cdUdg: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.$wsignalQSem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdUdh: // global
           I64[Sp - 16] = block_cdUcn_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdUcn() //  [R1]
         { info_tbl: [(cdUcn,
                       label: block_cdUcn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUcn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdUdk; else goto cdUdj;
       cdUdk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdUdj: // global
           _sdTPu::P64 = P64[Sp + 8];
           if (R1 == 1) goto cdUde; else goto cdUdd;
       cdUde: // global
           Hp = Hp - 16;
           I64[Sp] = block_cdUdm_info;
           R1 = _sdTPu::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdUdd: // global
           I64[Hp - 8] = sat_sdTPT_info;
           P64[Hp] = _sdTPu::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdUdm() //  [R1]
         { info_tbl: [(cdUdm,
                       label: block_cdUdm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUdm: // global
           I64[Sp] = block_cdUdo_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udUdX; else goto cdUdp;
       udUdX: // global
           call _cdUdo(R1) args: 0, res: 0, upd: 0;
       cdUdp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUdo() //  [R1]
         { info_tbl: [(cdUdo,
                       label: block_cdUdo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUdo: // global
           I64[Sp - 16] = block_cdUdt_info;
           _sdTPZ::P64 = P64[R1 + 15];
           _sdTQ0::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdTQ0::P64;
           P64[Sp] = _sdTPZ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udUdY; else goto cdUdw;
       udUdY: // global
           call _cdUdt(R1) args: 0, res: 0, upd: 0;
       cdUdw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUdt() //  [R1]
         { info_tbl: [(cdUdt,
                       label: block_cdUdt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUdt: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdUdC; else goto cdUdB;
       cdUdC: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdUdB: // global
           _sdTPZ::P64 = P64[Sp + 16];
           _sdTQ0::P64 = P64[Sp + 8];
           _sdTQ3::I64 = I64[R1 + 7];
           if (_sdTQ3::I64 != 0) goto cdUdM; else goto cdUdT;
       cdUdM: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdTQ3::I64 + 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = _sdTPZ::P64;
           P64[Hp] = _sdTQ0::P64;
           _sdTPu::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdUdS_info;
           R2 = Hp - 23;
           R1 = _sdTPu::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdUdT: // global
           Hp = Hp - 48;
           I64[Sp + 16] = block_cdUdQ_info;
           R3 = _sdTQ0::P64;
           R2 = _sdTPZ::P64;
           Sp = Sp + 16;
           call Control.Concurrent.QSem.signalQSem2_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdUdQ() //  [R1]
         { info_tbl: [(cdUdQ,
                       label: block_cdUdQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUdQ: // global
           _sdTPu::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdUdS_info;
           R2 = R1;
           R1 = _sdTPu::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUdS() //  []
         { info_tbl: [(cdUdS,
                       label: block_cdUdS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUdS: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.520019118 UTC

[section ""data" . Control.Concurrent.QSem.signalQSem1_closure" {
     Control.Concurrent.QSem.signalQSem1_closure:
         const Control.Concurrent.QSem.signalQSem1_info;
 },
 Control.Concurrent.QSem.signalQSem1_entry() //  [R2]
         { info_tbl: [(cdUeW,
                       label: Control.Concurrent.QSem.signalQSem1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUeW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdUeX; else goto cdUeY;
       cdUeX: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.signalQSem1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdUeY: // global
           I64[Sp - 8] = block_cdUeT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udUf2; else goto cdUeU;
       udUf2: // global
           call _cdUeT(R1) args: 0, res: 0, upd: 0;
       cdUeU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUeT() //  [R1]
         { info_tbl: [(cdUeT,
                       label: block_cdUeT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUeT: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Control.Concurrent.QSem.$wsignalQSem_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.526053882 UTC

[section ""data" . Control.Concurrent.QSem.signalQSem_closure" {
     Control.Concurrent.QSem.signalQSem_closure:
         const Control.Concurrent.QSem.signalQSem_info;
 },
 Control.Concurrent.QSem.signalQSem_entry() //  [R2]
         { info_tbl: [(cdUfg,
                       label: Control.Concurrent.QSem.signalQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUfg: // global
           R2 = R2;
           call Control.Concurrent.QSem.signalQSem1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.531269289 UTC

[section ""data" . Control.Concurrent.QSem.$wlvl_closure" {
     Control.Concurrent.QSem.$wlvl_closure:
         const Control.Concurrent.QSem.$wlvl_info;
 },
 sat_sdTQO_entry() //  [R1]
         { info_tbl: [(cdUfF,
                       label: sat_sdTQO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUfF: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cdUfG; else goto cdUfH;
       cdUfG: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdUfH: // global
           I64[Sp - 24] = block_cdUfA_info;
           _sdTQg::P64 = P64[R1 + 7];
           _sdTQh::P64 = P64[R1 + 15];
           R1 = _sdTQh::P64;
           P64[Sp - 16] = _sdTQg::P64;
           P64[Sp - 8] = _sdTQh::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUfA() //  [R1]
         { info_tbl: [(cdUfA,
                       label: block_cdUfA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUfA: // global
           I64[Sp] = block_cdUfC_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udUgv; else goto cdUfD;
       udUgv: // global
           call _cdUfC(R1) args: 0, res: 0, upd: 0;
       cdUfD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUfC() //  [R1]
         { info_tbl: [(cdUfC,
                       label: block_cdUfC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUfC: // global
           I64[Sp - 32] = block_cdUfL_info;
           _sdTQs::P64 = R1;
           _sdTQt::P64 = P64[R1 + 7];
           _sdTQu::P64 = P64[R1 + 15];
           _sdTQv::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _sdTQt::P64;
           P64[Sp - 16] = _sdTQu::P64;
           P64[Sp - 8] = _sdTQv::P64;
           P64[Sp] = _sdTQs::P64;
           Sp = Sp - 32;
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUfL() //  [R1]
         { info_tbl: [(cdUfL,
                       label: block_cdUfL_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUfL: // global
           if (R1 == 0) goto cdUgr; else goto cdUfV;
       cdUgr: // global
           I64[Sp + 24] = block_cdUgo_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 40];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdUfV: // global
           _sdTQt::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdUfT_info;
           R1 = _sdTQt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udUgw; else goto cdUfW;
       udUgw: // global
           call _cdUfT(R1) args: 0, res: 0, upd: 0;
       cdUfW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUgo() //  []
         { info_tbl: [(cdUgo,
                       label: block_cdUgo_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUgo: // global
           _sdTQh::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdUgq_info;
           R2 = P64[Sp + 8];
           R1 = _sdTQh::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUfT() //  [R1]
         { info_tbl: [(cdUfT,
                       label: block_cdUfT_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUfT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdUg2; else goto cdUg1;
       cdUg2: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdUg1: // global
           _sdTQu::P64 = P64[Sp + 8];
           _sdTQv::P64 = P64[Sp + 16];
           _sdTQD::I64 = I64[R1 + 7];
           if (_sdTQD::I64 != 0) goto cdUgc; else goto cdUgj;
       cdUgc: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdTQD::I64 + 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = _sdTQu::P64;
           P64[Hp] = _sdTQv::P64;
           _sdTQh::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cdUgq_info;
           R2 = Hp - 23;
           R1 = _sdTQh::P64;
           Sp = Sp + 40;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdUgj: // global
           Hp = Hp - 48;
           I64[Sp + 32] = block_cdUgg_info;
           R3 = _sdTQv::P64;
           R2 = _sdTQu::P64;
           Sp = Sp + 32;
           call Control.Concurrent.QSem.signalQSem2_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdUgg() //  [R1]
         { info_tbl: [(cdUgg,
                       label: block_cdUgg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUgg: // global
           _sdTQh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdUgq_info;
           R2 = R1;
           R1 = _sdTQh::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUgq() //  []
         { info_tbl: [(cdUgq,
                       label: block_cdUgq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUgq: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSem.$wlvl_entry() //  [R2, R3, R4]
         { info_tbl: [(cdUgA,
                       label: Control.Concurrent.QSem.$wlvl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUgA: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdUgB; else goto cdUgC;
       cdUgB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSem.$wlvl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdUgC: // global
           I64[Sp - 32] = block_cdUfr_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdUfr() //  [R1]
         { info_tbl: [(cdUfr,
                       label: block_cdUfr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUfr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdUgF; else goto cdUgE;
       cdUgF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdUgE: // global
           _sdTQh::P64 = P64[Sp + 16];
           if (R1 == 1) goto cdUgz; else goto cdUgy;
       cdUgz: // global
           Hp = Hp - 24;
           I64[Sp] = block_cdUgK_info;
           R1 = _sdTQh::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdUgy: // global
           I64[Hp - 16] = sat_sdTQO_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sdTQh::P64;
           I64[Sp + 16] = block_cdUgG_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUgK() //  [R1]
         { info_tbl: [(cdUgK,
                       label: block_cdUgK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUgK: // global
           I64[Sp] = block_cdUgM_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udUhC; else goto cdUgO;
       udUhC: // global
           call _cdUgM(R1) args: 0, res: 0, upd: 0;
       cdUgO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUgM() //  [R1]
         { info_tbl: [(cdUgM,
                       label: block_cdUgM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUgM: // global
           I64[Sp - 32] = block_cdUgS_info;
           _sdTQV::P64 = R1;
           _sdTQW::P64 = P64[R1 + 7];
           _sdTQX::P64 = P64[R1 + 15];
           _sdTQY::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _sdTQW::P64;
           P64[Sp - 16] = _sdTQX::P64;
           P64[Sp - 8] = _sdTQY::P64;
           P64[Sp] = _sdTQV::P64;
           Sp = Sp - 32;
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUgS() //  [R1]
         { info_tbl: [(cdUgS,
                       label: block_cdUgS_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUgS: // global
           if (R1 == 0) goto cdUhy; else goto cdUh2;
       cdUhy: // global
           I64[Sp + 24] = block_cdUhv_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 40];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdUh2: // global
           _sdTQW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdUh0_info;
           R1 = _sdTQW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udUhD; else goto cdUh3;
       udUhD: // global
           call _cdUh0(R1) args: 0, res: 0, upd: 0;
       cdUh3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUhv() //  []
         { info_tbl: [(cdUhv,
                       label: block_cdUhv_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUhv: // global
           _sdTQh::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdUhx_info;
           R2 = P64[Sp + 8];
           R1 = _sdTQh::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUh0() //  [R1]
         { info_tbl: [(cdUh0,
                       label: block_cdUh0_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUh0: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdUh9; else goto cdUh8;
       cdUh9: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdUh8: // global
           _sdTQX::P64 = P64[Sp + 8];
           _sdTQY::P64 = P64[Sp + 16];
           _sdTR6::I64 = I64[R1 + 7];
           if (_sdTR6::I64 != 0) goto cdUhj; else goto cdUhq;
       cdUhj: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdTR6::I64 + 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = _sdTQX::P64;
           P64[Hp] = _sdTQY::P64;
           _sdTQh::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cdUhx_info;
           R2 = Hp - 23;
           R1 = _sdTQh::P64;
           Sp = Sp + 40;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdUhq: // global
           Hp = Hp - 48;
           I64[Sp + 32] = block_cdUhn_info;
           R3 = _sdTQY::P64;
           R2 = _sdTQX::P64;
           Sp = Sp + 32;
           call Control.Concurrent.QSem.signalQSem2_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdUhn() //  [R1]
         { info_tbl: [(cdUhn,
                       label: block_cdUhn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUhn: // global
           _sdTQh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdUhx_info;
           R2 = R1;
           R1 = _sdTQh::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUhx() //  []
         { info_tbl: [(cdUhx,
                       label: block_cdUhx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUhx: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdUgG() //  []
         { info_tbl: [(cdUgG,
                       label: block_cdUgG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUgG: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.569570692 UTC

[section ""data" . Control.Concurrent.QSem.$wwaitQSem_closure" {
     Control.Concurrent.QSem.$wwaitQSem_closure:
         const Control.Concurrent.QSem.$wwaitQSem_info;
 },
 sat_sdTRN_entry() //  [R1, R2]
         { info_tbl: [(cdUjl,
                       label: sat_sdTRN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUjl: // global
           R4 = R2;
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           call Control.Concurrent.QSem.$wlvl_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdTRK_entry() //  [R1]
         { info_tbl: [(cdUjt,
                       label: sat_sdTRK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUjt: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sdTRm_entry() //  [R1]
         { info_tbl: [(cdUjw,
                       label: io_sdTRm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUjw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdUjx; else goto cdUjy;
       cdUjx: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdUjy: // global
           I64[Sp - 16] = block_cdUiU_info;
           _sdTRh::P64 = P64[R1 + 7];
           R1 = _sdTRh::P64;
           P64[Sp - 8] = _sdTRh::P64;
           Sp = Sp - 16;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUiU() //  [R1]
         { info_tbl: [(cdUiU,
                       label: block_cdUiU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUiU: // global
           I64[Sp] = block_cdUiW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udUjV; else goto cdUiX;
       udUjV: // global
           call _cdUiW(R1) args: 0, res: 0, upd: 0;
       cdUiX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUiW() //  [R1]
         { info_tbl: [(cdUiW,
                       label: block_cdUiW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUiW: // global
           I64[Sp - 16] = block_cdUj1_info;
           _sdTRt::P64 = P64[R1 + 15];
           _sdTRu::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdTRu::P64;
           P64[Sp] = _sdTRt::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udUjW; else goto cdUj2;
       udUjW: // global
           call _cdUj1(R1) args: 0, res: 0, upd: 0;
       cdUj2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUj1() //  [R1]
         { info_tbl: [(cdUj1,
                       label: block_cdUj1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUj1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdUjD; else goto cdUjC;
       cdUjD: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdUjC: // global
           _sdTRx::I64 = I64[R1 + 7];
           if (_sdTRx::I64 == 0) goto cdUjO; else goto cdUjL;
       cdUjO: // global
           Hp = Hp - 48;
           I64[Sp - 8] = block_cdUj9_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
       cdUjL: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdTRx::I64 - 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _sdTRh::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdUjJ_info;
           R2 = Hp - 23;
           R1 = _sdTRh::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUj9() //  [R1]
         { info_tbl: [(cdUj9,
                       label: block_cdUj9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUj9: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdUjR; else goto cdUjQ;
       cdUjR: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdUjQ: // global
           I64[Hp - 64] = GHC.MVar.MVar_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = Hp - 46;
           I64[Sp + 16] = block_cdUje_info;
           R2 = Hp - 23;
           _sdTRE::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 24] = _sdTRE::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUje() //  []
         { info_tbl: [(cdUje,
                       label: block_cdUje_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUje: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdUjU; else goto cdUjT;
       cdUjU: // global
           HpAlloc = 40;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdUjT: // global
           I64[Hp - 32] = sat_sdTRN_info;
           P64[Hp - 24] = P64[Sp + 16];
           _sdTRE::P64 = P64[Sp + 8];
           P64[Hp - 16] = _sdTRE::P64;
           I64[Hp - 8] = sat_sdTRK_info;
           P64[Hp] = _sdTRE::P64;
           R2 = Hp - 30;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdUjJ() //  []
         { info_tbl: [(cdUjJ,
                       label: block_cdUjJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUjJ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSem.$wwaitQSem_entry() //  [R2]
         { info_tbl: [(cdUk1,
                       label: Control.Concurrent.QSem.$wwaitQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUk1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdUk2; else goto cdUk3;
       cdUk2: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.$wwaitQSem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdUk3: // global
           I64[Sp - 16] = block_cdUiN_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdUiN() //  [R1]
         { info_tbl: [(cdUiN,
                       label: block_cdUiN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUiN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdUk6; else goto cdUk5;
       cdUk6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdUk5: // global
           I64[Hp - 8] = io_sdTRm_info;
           P64[Hp] = P64[Sp + 8];
           _cdUiP::P64 = Hp - 7;
           if (R1 == 0) goto cdUk0; else goto cdUjZ;
       cdUk0: // global
           R1 = _cdUiP::P64;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cdUjZ: // global
           R1 = _cdUiP::P64;
           Sp = Sp + 16;
           call io_sdTRm_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.59293488 UTC

[section ""data" . Control.Concurrent.QSem.waitQSem1_closure" {
     Control.Concurrent.QSem.waitQSem1_closure:
         const Control.Concurrent.QSem.waitQSem1_info;
 },
 Control.Concurrent.QSem.waitQSem1_entry() //  [R2]
         { info_tbl: [(cdUl2,
                       label: Control.Concurrent.QSem.waitQSem1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUl2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdUl3; else goto cdUl4;
       cdUl3: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.waitQSem1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdUl4: // global
           I64[Sp - 8] = block_cdUkZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udUl8; else goto cdUl0;
       udUl8: // global
           call _cdUkZ(R1) args: 0, res: 0, upd: 0;
       cdUl0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUkZ() //  [R1]
         { info_tbl: [(cdUkZ,
                       label: block_cdUkZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUkZ: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Control.Concurrent.QSem.$wwaitQSem_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.599082981 UTC

[section ""data" . Control.Concurrent.QSem.waitQSem_closure" {
     Control.Concurrent.QSem.waitQSem_closure:
         const Control.Concurrent.QSem.waitQSem_info;
 },
 Control.Concurrent.QSem.waitQSem_entry() //  [R2]
         { info_tbl: [(cdUlm,
                       label: Control.Concurrent.QSem.waitQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUlm: // global
           R2 = R2;
           call Control.Concurrent.QSem.waitQSem1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.603131539 UTC

[section ""data" . Control.Concurrent.QSem.QSem_closure" {
     Control.Concurrent.QSem.QSem_closure:
         const Control.Concurrent.QSem.QSem_info;
 },
 Control.Concurrent.QSem.QSem_entry() //  [R2]
         { info_tbl: [(cdUly,
                       label: Control.Concurrent.QSem.QSem_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUly: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdUlC; else goto cdUlB;
       cdUlC: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Control.Concurrent.QSem.QSem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdUlB: // global
           I64[Hp - 8] = Control.Concurrent.QSem.QSem_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.607455082 UTC

[Control.Concurrent.QSem.QSem_con_entry() //  [R1]
         { info_tbl: [(cdUlI,
                       label: Control.Concurrent.QSem.QSem_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,81,83,101,109,46,81,83,101,109]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUlI: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.610770793 UTC

[section ""relreadonly" . SdTSm_srt" {
     SdTSm_srt:
         const GHC.IO.failIO1_closure;
         const Control.Concurrent.QSem.newQSem2_closure;
         const Control.Concurrent.QSem.newQSem1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.162791986 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:10.1644483 UTC

[section ""data" . Control.Concurrent.QSem.$WQSem_closure" {
     Control.Concurrent.QSem.$WQSem_closure:
         const Control.Concurrent.QSem.$WQSem_info;
 },
 Control.Concurrent.QSem.$WQSem_entry() //  [R2]
         { info_tbl: [(cdUoS,
                       label: Control.Concurrent.QSem.$WQSem_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUoS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdUoW; else goto cdUoX;
       cdUoW: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.$WQSem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdUoX: // global
           I64[Sp - 8] = block_cdUoP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udUp1; else goto cdUoQ;
       udUp1: // global
           call _cdUoP(R1) args: 0, res: 0, upd: 0;
       cdUoQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUoP() //  [R1]
         { info_tbl: [(cdUoP,
                       label: block_cdUoP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUoP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdUp0; else goto cdUoZ;
       cdUp0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdUoZ: // global
           _sdUlR::P64 = P64[R1 + 7];
           I64[Hp - 8] = Control.Concurrent.QSem.QSem_con_info;
           P64[Hp] = _sdUlR::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.17052797 UTC

[section ""cstring" . Control.Concurrent.QSem.$trModule4_bytes" {
     Control.Concurrent.QSem.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.172683716 UTC

[section ""data" . Control.Concurrent.QSem.$trModule3_closure" {
     Control.Concurrent.QSem.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSem.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.175676232 UTC

[section ""cstring" . Control.Concurrent.QSem.$trModule2_bytes" {
     Control.Concurrent.QSem.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,81,83,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.178372907 UTC

[section ""data" . Control.Concurrent.QSem.$trModule1_closure" {
     Control.Concurrent.QSem.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSem.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.180490428 UTC

[section ""data" . Control.Concurrent.QSem.$trModule_closure" {
     Control.Concurrent.QSem.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.QSem.$trModule3_closure+1;
         const Control.Concurrent.QSem.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.182588306 UTC

[section ""data" . $krep_rdTOF_closure" {
     $krep_rdTOF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.186991691 UTC

[section ""data" . $krep1_rdTOG_closure" {
     $krep1_rdTOG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.18950537 UTC

[section ""data" . $krep2_rdTOH_closure" {
     $krep2_rdTOH_closure:
         const :_con_info;
         const $krep_rdTOF_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.192095269 UTC

[section ""data" . $krep3_rdTOI_closure" {
     $krep3_rdTOI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep2_rdTOH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.194911339 UTC

[section ""data" . $krep4_rdTOJ_closure" {
     $krep4_rdTOJ_closure:
         const :_con_info;
         const $krep3_rdTOI_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.197780894 UTC

[section ""data" . $krep5_rdTOK_closure" {
     $krep5_rdTOK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep4_rdTOJ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.2003726 UTC

[section ""data" . $krep6_rdTOL_closure" {
     $krep6_rdTOL_closure:
         const :_con_info;
         const $krep5_rdTOK_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.203117443 UTC

[section ""data" . $krep7_rdTOM_closure" {
     $krep7_rdTOM_closure:
         const :_con_info;
         const $krep5_rdTOK_closure+1;
         const $krep6_rdTOL_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.206022412 UTC

[section ""data" . $krep8_rdTON_closure" {
     $krep8_rdTON_closure:
         const :_con_info;
         const $krep1_rdTOG_closure+1;
         const $krep7_rdTOM_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.208815963 UTC

[section ""data" . $krep9_rdTOO_closure" {
     $krep9_rdTOO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,,)_closure;
         const $krep8_rdTON_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.21209659 UTC

[section ""data" . $krep10_rdTOP_closure" {
     $krep10_rdTOP_closure:
         const :_con_info;
         const $krep9_rdTOO_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.21487203 UTC

[section ""data" . $krep11_rdTOQ_closure" {
     $krep11_rdTOQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep10_rdTOP_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.216872604 UTC

[section ""cstring" . Control.Concurrent.QSem.$tcQSem2_bytes" {
     Control.Concurrent.QSem.$tcQSem2_bytes:
         I8[] [81,83,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.218833035 UTC

[section ""data" . Control.Concurrent.QSem.$tcQSem1_closure" {
     Control.Concurrent.QSem.$tcQSem1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSem.$tcQSem2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.220680936 UTC

[section ""data" . Control.Concurrent.QSem.$tcQSem_closure" {
     Control.Concurrent.QSem.$tcQSem_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.QSem.$trModule_closure+1;
         const Control.Concurrent.QSem.$tcQSem1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9564161763912145234;
         const 3945938196429110556;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.223517784 UTC

[section ""data" . $krep12_rdTOR_closure" {
     $krep12_rdTOR_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Concurrent.QSem.$tcQSem_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.225329871 UTC

[section ""data" . Control.Concurrent.QSem.$tc'QSem1_closure" {
     Control.Concurrent.QSem.$tc'QSem1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_rdTOQ_closure+1;
         const $krep12_rdTOR_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.227148127 UTC

[section ""cstring" . Control.Concurrent.QSem.$tc'QSem3_bytes" {
     Control.Concurrent.QSem.$tc'QSem3_bytes:
         I8[] [39,81,83,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.228858819 UTC

[section ""data" . Control.Concurrent.QSem.$tc'QSem2_closure" {
     Control.Concurrent.QSem.$tc'QSem2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSem.$tc'QSem3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.23136758 UTC

[section ""data" . Control.Concurrent.QSem.$tc'QSem_closure" {
     Control.Concurrent.QSem.$tc'QSem_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.QSem.$trModule_closure+1;
         const Control.Concurrent.QSem.$tc'QSem2_closure+1;
         const Control.Concurrent.QSem.$tc'QSem1_closure+4;
         const 16012040391974534726;
         const 6627878139257558952;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.233312511 UTC

[section ""cstring" . lvl_rdTOS_bytes" {
     lvl_rdTOS_bytes:
         I8[] [110,101,119,81,83,101,109,58,32,73,110,105,116,105,97,108,32,113,117,97,110,116,105,116,121,32,109,117,115,116,32,98,101,32,110,111,110,45,110,101,103,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.235369108 UTC

[section ""data" . Control.Concurrent.QSem.newQSem2_closure" {
     Control.Concurrent.QSem.newQSem2_closure:
         const Control.Concurrent.QSem.newQSem2_info;
         const 0;
 },
 Control.Concurrent.QSem.newQSem2_entry() //  []
         { info_tbl: [(cdUpK,
                       label: Control.Concurrent.QSem.newQSem2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUpK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdUpL; else goto cdUpM;
       cdUpL: // global
           R1 = Control.Concurrent.QSem.newQSem2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdUpM: // global
           I64[Sp - 8] = block_cdUpI_info;
           R2 = lvl_rdTOS_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdUpI() //  [R1]
         { info_tbl: [(cdUpI,
                       label: block_cdUpI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUpI: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.241605651 UTC

[section ""data" . Control.Concurrent.QSem.newQSem1_closure" {
     Control.Concurrent.QSem.newQSem1_closure:
         const Control.Concurrent.QSem.newQSem1_info;
         const 0;
 },
 Control.Concurrent.QSem.newQSem1_entry() //  [R2]
         { info_tbl: [(cdUq7,
                       label: Control.Concurrent.QSem.newQSem1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUq7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdUq8; else goto cdUq9;
       cdUq8: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.newQSem1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdUq9: // global
           I64[Sp - 8] = block_cdUq4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udUqv; else goto cdUq5;
       udUqv: // global
           call _cdUq4(R1) args: 0, res: 0, upd: 0;
       cdUq5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUq4() //  [R1]
         { info_tbl: [(cdUq4,
                       label: block_cdUq4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUq4: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto cdUqn; else goto cdUqu;
       cdUqn: // global
           I64[Sp - 8] = block_cdUqg_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
       cdUqu: // global
           Sp = Sp + 8;
           call Control.Concurrent.QSem.newQSem2_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cdUqg() //  [R1]
         { info_tbl: [(cdUqg,
                       label: block_cdUqg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUqg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdUqq; else goto cdUqp;
       cdUqq: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdUqp: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp] = block_cdUqj_info;
           R2 = Hp - 23;
           _sdUm1::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _sdUm1::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUqj() //  []
         { info_tbl: [(cdUqj,
                       label: block_cdUqj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUqj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdUqt; else goto cdUqs;
       cdUqt: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdUqs: // global
           I64[Hp - 8] = Control.Concurrent.QSem.QSem_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.252018453 UTC

[section ""data" . Control.Concurrent.QSem.newQSem_closure" {
     Control.Concurrent.QSem.newQSem_closure:
         const Control.Concurrent.QSem.newQSem_info;
         const 0;
 },
 Control.Concurrent.QSem.newQSem_entry() //  [R2]
         { info_tbl: [(cdUr1,
                       label: Control.Concurrent.QSem.newQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUr1: // global
           R2 = R2;
           call Control.Concurrent.QSem.newQSem1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.256084567 UTC

[section ""data" . lvl1_rdTOT_closure" {
     lvl1_rdTOT_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.257909125 UTC

[section ""data" . lvl2_rdTOU_closure" {
     lvl2_rdTOU_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.259727906 UTC

[section ""data" . lvl3_rdTOV_closure" {
     lvl3_rdTOV_closure:
         const (,,)_con_info;
         const lvl2_rdTOU_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.262573745 UTC

[section ""data" . Control.Concurrent.QSem.signalQSem2_closure" {
     Control.Concurrent.QSem.signalQSem2_closure:
         const Control.Concurrent.QSem.signalQSem2_info;
 },
 Control.Concurrent.QSem.signalQSem2_entry() //  [R2, R3]
         { info_tbl: [(cdUrm,
                       label: Control.Concurrent.QSem.signalQSem2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUrm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdUrn; else goto udUs4;
       cdUrn: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSem.signalQSem2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       udUs4: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cdUrc() args: 0, res: 0, upd: 0;
     }
 },
 _cdUrc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUrc: // global
           _sdUm5::P64 = P64[Sp];
           I64[Sp] = block_cdUrf_info;
           R1 = _sdUm5::P64;
           if (R1 & 7 != 0) goto udUs7; else goto cdUrg;
       udUs7: // global
           call _cdUrf(R1) args: 0, res: 0, upd: 0;
       cdUrg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUrf() //  [R1]
         { info_tbl: [(cdUrf,
                       label: block_cdUrf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUrf: // global
           if (R1 & 7 == 1) goto cdUrj; else goto cdUrk;
       cdUrj: // global
           _sdUm6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdUrr_info;
           R1 = _sdUm6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udUs8; else goto cdUrt;
       udUs8: // global
           call _cdUrr(R1) args: 0, res: 0, upd: 0;
       cdUrt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdUrk: // global
           I64[Sp - 8] = block_cdUrL_info;
           _sdUme::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sdUme::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udUs9; else goto cdUrN;
       udUs9: // global
           call _cdUrL(R1) args: 0, res: 0, upd: 0;
       cdUrN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUrr() //  [R1]
         { info_tbl: [(cdUrr,
                       label: block_cdUrr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUrr: // global
           if (R1 & 7 == 1) goto cdUrz; else goto cdUrE;
       cdUrz: // global
           R1 = lvl3_rdTOV_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdUrE: // global
           I64[Sp] = block_cdUrC_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = R1;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdUrC() //  [R1]
         { info_tbl: [(cdUrC,
                       label: block_cdUrC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUrC: // global
           P64[Sp - 8] = R1;
           P64[Sp] = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call _cdUrc() args: 0, res: 0, upd: 0;
     }
 },
 _cdUrL() //  [R1]
         { info_tbl: [(cdUrL,
                       label: block_cdUrL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUrL: // global
           I64[Sp] = block_cdUrR_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[R1 + 7];
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUrR() //  [R1]
         { info_tbl: [(cdUrR,
                       label: block_cdUrR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUrR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdUrW; else goto cdUrV;
       cdUrW: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdUrV: // global
           _sdUm6::P64 = P64[Sp + 16];
           _sdUme::P64 = P64[Sp + 8];
           if (R1 == 0) goto cdUs2; else goto cdUs1;
       cdUs2: // global
           Hp = Hp - 32;
           P64[Sp + 8] = _sdUme::P64;
           P64[Sp + 16] = _sdUm6::P64;
           Sp = Sp + 8;
           call _cdUrc() args: 0, res: 0, upd: 0;
       cdUs1: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl1_rdTOT_closure+1;
           P64[Hp - 8] = _sdUme::P64;
           P64[Hp] = _sdUm6::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.279441863 UTC

[section ""data" . Control.Concurrent.QSem.$wsignalQSem_closure" {
     Control.Concurrent.QSem.$wsignalQSem_closure:
         const Control.Concurrent.QSem.$wsignalQSem_info;
 },
 sat_sdUmL_entry() //  [R1]
         { info_tbl: [(cdUtb,
                       label: sat_sdUmL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUtb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdUtf; else goto cdUtg;
       cdUtf: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdUtg: // global
           I64[Sp - 16] = block_cdUt6_info;
           _sdUmm::P64 = P64[R1 + 7];
           R1 = _sdUmm::P64;
           P64[Sp - 8] = _sdUmm::P64;
           Sp = Sp - 16;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUt6() //  [R1]
         { info_tbl: [(cdUt6,
                       label: block_cdUt6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUt6: // global
           I64[Sp] = block_cdUt8_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udUtK; else goto cdUt9;
       udUtK: // global
           call _cdUt8(R1) args: 0, res: 0, upd: 0;
       cdUt9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUt8() //  [R1]
         { info_tbl: [(cdUt8,
                       label: block_cdUt8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUt8: // global
           I64[Sp - 16] = block_cdUte_info;
           _sdUmy::P64 = P64[R1 + 15];
           _sdUmz::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdUmz::P64;
           P64[Sp] = _sdUmy::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udUtL; else goto cdUtj;
       udUtL: // global
           call _cdUte(R1) args: 0, res: 0, upd: 0;
       cdUtj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUte() //  [R1]
         { info_tbl: [(cdUte,
                       label: block_cdUte_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUte: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdUtp; else goto cdUto;
       cdUtp: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdUto: // global
           _sdUmy::P64 = P64[Sp + 16];
           _sdUmz::P64 = P64[Sp + 8];
           _sdUmC::I64 = I64[R1 + 7];
           if (_sdUmC::I64 != 0) goto cdUtz; else goto cdUtG;
       cdUtz: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdUmC::I64 + 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = _sdUmy::P64;
           P64[Hp] = _sdUmz::P64;
           _sdUmm::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdUtF_info;
           R2 = Hp - 23;
           R1 = _sdUmm::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdUtG: // global
           Hp = Hp - 48;
           I64[Sp + 16] = block_cdUtD_info;
           R3 = _sdUmz::P64;
           R2 = _sdUmy::P64;
           Sp = Sp + 16;
           call Control.Concurrent.QSem.signalQSem2_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdUtD() //  [R1]
         { info_tbl: [(cdUtD,
                       label: block_cdUtD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUtD: // global
           _sdUmm::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdUtF_info;
           R2 = R1;
           R1 = _sdUmm::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUtF() //  []
         { info_tbl: [(cdUtF,
                       label: block_cdUtF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUtF: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSem.$wsignalQSem_entry() //  [R2]
         { info_tbl: [(cdUtP,
                       label: Control.Concurrent.QSem.$wsignalQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUtP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdUtQ; else goto cdUtR;
       cdUtQ: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.$wsignalQSem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdUtR: // global
           I64[Sp - 16] = block_cdUsX_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdUsX() //  [R1]
         { info_tbl: [(cdUsX,
                       label: block_cdUsX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUsX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdUtU; else goto cdUtT;
       cdUtU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdUtT: // global
           _sdUmm::P64 = P64[Sp + 8];
           if (R1 == 1) goto cdUtO; else goto cdUtN;
       cdUtO: // global
           Hp = Hp - 16;
           I64[Sp] = block_cdUtW_info;
           R1 = _sdUmm::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdUtN: // global
           I64[Hp - 8] = sat_sdUmL_info;
           P64[Hp] = _sdUmm::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdUtW() //  [R1]
         { info_tbl: [(cdUtW,
                       label: block_cdUtW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUtW: // global
           I64[Sp] = block_cdUtY_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udUux; else goto cdUtZ;
       udUux: // global
           call _cdUtY(R1) args: 0, res: 0, upd: 0;
       cdUtZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUtY() //  [R1]
         { info_tbl: [(cdUtY,
                       label: block_cdUtY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUtY: // global
           I64[Sp - 16] = block_cdUu3_info;
           _sdUmR::P64 = P64[R1 + 15];
           _sdUmS::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdUmS::P64;
           P64[Sp] = _sdUmR::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udUuy; else goto cdUu6;
       udUuy: // global
           call _cdUu3(R1) args: 0, res: 0, upd: 0;
       cdUu6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUu3() //  [R1]
         { info_tbl: [(cdUu3,
                       label: block_cdUu3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUu3: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdUuc; else goto cdUub;
       cdUuc: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdUub: // global
           _sdUmR::P64 = P64[Sp + 16];
           _sdUmS::P64 = P64[Sp + 8];
           _sdUmV::I64 = I64[R1 + 7];
           if (_sdUmV::I64 != 0) goto cdUum; else goto cdUut;
       cdUum: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdUmV::I64 + 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = _sdUmR::P64;
           P64[Hp] = _sdUmS::P64;
           _sdUmm::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdUus_info;
           R2 = Hp - 23;
           R1 = _sdUmm::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdUut: // global
           Hp = Hp - 48;
           I64[Sp + 16] = block_cdUuq_info;
           R3 = _sdUmS::P64;
           R2 = _sdUmR::P64;
           Sp = Sp + 16;
           call Control.Concurrent.QSem.signalQSem2_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdUuq() //  [R1]
         { info_tbl: [(cdUuq,
                       label: block_cdUuq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUuq: // global
           _sdUmm::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdUus_info;
           R2 = R1;
           R1 = _sdUmm::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUus() //  []
         { info_tbl: [(cdUus,
                       label: block_cdUus_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUus: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.307864548 UTC

[section ""data" . Control.Concurrent.QSem.signalQSem1_closure" {
     Control.Concurrent.QSem.signalQSem1_closure:
         const Control.Concurrent.QSem.signalQSem1_info;
 },
 Control.Concurrent.QSem.signalQSem1_entry() //  [R2]
         { info_tbl: [(cdUvQ,
                       label: Control.Concurrent.QSem.signalQSem1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUvQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdUvR; else goto cdUvS;
       cdUvR: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.signalQSem1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdUvS: // global
           I64[Sp - 8] = block_cdUvN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udUvW; else goto cdUvO;
       udUvW: // global
           call _cdUvN(R1) args: 0, res: 0, upd: 0;
       cdUvO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUvN() //  [R1]
         { info_tbl: [(cdUvN,
                       label: block_cdUvN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUvN: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Control.Concurrent.QSem.$wsignalQSem_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.313570821 UTC

[section ""data" . Control.Concurrent.QSem.signalQSem_closure" {
     Control.Concurrent.QSem.signalQSem_closure:
         const Control.Concurrent.QSem.signalQSem_info;
 },
 Control.Concurrent.QSem.signalQSem_entry() //  [R2]
         { info_tbl: [(cdUwb,
                       label: Control.Concurrent.QSem.signalQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUwb: // global
           R2 = R2;
           call Control.Concurrent.QSem.signalQSem1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.318847722 UTC

[section ""data" . Control.Concurrent.QSem.$wlvl_closure" {
     Control.Concurrent.QSem.$wlvl_closure:
         const Control.Concurrent.QSem.$wlvl_info;
 },
 sat_sdUnG_entry() //  [R1]
         { info_tbl: [(cdUwA,
                       label: sat_sdUnG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUwA: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cdUwB; else goto cdUwC;
       cdUwB: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdUwC: // global
           I64[Sp - 24] = block_cdUwv_info;
           _sdUn8::P64 = P64[R1 + 7];
           _sdUn9::P64 = P64[R1 + 15];
           R1 = _sdUn9::P64;
           P64[Sp - 16] = _sdUn8::P64;
           P64[Sp - 8] = _sdUn9::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUwv() //  [R1]
         { info_tbl: [(cdUwv,
                       label: block_cdUwv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUwv: // global
           I64[Sp] = block_cdUwx_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udUxq; else goto cdUwy;
       udUxq: // global
           call _cdUwx(R1) args: 0, res: 0, upd: 0;
       cdUwy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUwx() //  [R1]
         { info_tbl: [(cdUwx,
                       label: block_cdUwx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUwx: // global
           I64[Sp - 32] = block_cdUwG_info;
           _sdUnk::P64 = R1;
           _sdUnl::P64 = P64[R1 + 7];
           _sdUnm::P64 = P64[R1 + 15];
           _sdUnn::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _sdUnl::P64;
           P64[Sp - 16] = _sdUnm::P64;
           P64[Sp - 8] = _sdUnn::P64;
           P64[Sp] = _sdUnk::P64;
           Sp = Sp - 32;
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUwG() //  [R1]
         { info_tbl: [(cdUwG,
                       label: block_cdUwG_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUwG: // global
           if (R1 == 0) goto cdUxm; else goto cdUwQ;
       cdUxm: // global
           I64[Sp + 24] = block_cdUxj_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 40];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdUwQ: // global
           _sdUnl::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdUwO_info;
           R1 = _sdUnl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udUxr; else goto cdUwR;
       udUxr: // global
           call _cdUwO(R1) args: 0, res: 0, upd: 0;
       cdUwR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUxj() //  []
         { info_tbl: [(cdUxj,
                       label: block_cdUxj_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUxj: // global
           _sdUn9::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdUxl_info;
           R2 = P64[Sp + 8];
           R1 = _sdUn9::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUwO() //  [R1]
         { info_tbl: [(cdUwO,
                       label: block_cdUwO_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUwO: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdUwX; else goto cdUwW;
       cdUwX: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdUwW: // global
           _sdUnm::P64 = P64[Sp + 8];
           _sdUnn::P64 = P64[Sp + 16];
           _sdUnv::I64 = I64[R1 + 7];
           if (_sdUnv::I64 != 0) goto cdUx7; else goto cdUxe;
       cdUx7: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdUnv::I64 + 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = _sdUnm::P64;
           P64[Hp] = _sdUnn::P64;
           _sdUn9::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cdUxl_info;
           R2 = Hp - 23;
           R1 = _sdUn9::P64;
           Sp = Sp + 40;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdUxe: // global
           Hp = Hp - 48;
           I64[Sp + 32] = block_cdUxb_info;
           R3 = _sdUnn::P64;
           R2 = _sdUnm::P64;
           Sp = Sp + 32;
           call Control.Concurrent.QSem.signalQSem2_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdUxb() //  [R1]
         { info_tbl: [(cdUxb,
                       label: block_cdUxb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUxb: // global
           _sdUn9::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdUxl_info;
           R2 = R1;
           R1 = _sdUn9::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUxl() //  []
         { info_tbl: [(cdUxl,
                       label: block_cdUxl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUxl: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSem.$wlvl_entry() //  [R2, R3, R4]
         { info_tbl: [(cdUxv,
                       label: Control.Concurrent.QSem.$wlvl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUxv: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdUxw; else goto cdUxx;
       cdUxw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSem.$wlvl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdUxx: // global
           I64[Sp - 32] = block_cdUwm_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdUwm() //  [R1]
         { info_tbl: [(cdUwm,
                       label: block_cdUwm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUwm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdUxA; else goto cdUxz;
       cdUxA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdUxz: // global
           _sdUn9::P64 = P64[Sp + 16];
           if (R1 == 1) goto cdUxu; else goto cdUxt;
       cdUxu: // global
           Hp = Hp - 24;
           I64[Sp] = block_cdUxF_info;
           R1 = _sdUn9::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdUxt: // global
           I64[Hp - 16] = sat_sdUnG_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sdUn9::P64;
           I64[Sp + 16] = block_cdUxB_info;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUxF() //  [R1]
         { info_tbl: [(cdUxF,
                       label: block_cdUxF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUxF: // global
           I64[Sp] = block_cdUxH_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udUyx; else goto cdUxJ;
       udUyx: // global
           call _cdUxH(R1) args: 0, res: 0, upd: 0;
       cdUxJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUxH() //  [R1]
         { info_tbl: [(cdUxH,
                       label: block_cdUxH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUxH: // global
           I64[Sp - 32] = block_cdUxN_info;
           _sdUnN::P64 = R1;
           _sdUnO::P64 = P64[R1 + 7];
           _sdUnP::P64 = P64[R1 + 15];
           _sdUnQ::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _sdUnO::P64;
           P64[Sp - 16] = _sdUnP::P64;
           P64[Sp - 8] = _sdUnQ::P64;
           P64[Sp] = _sdUnN::P64;
           Sp = Sp - 32;
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUxN() //  [R1]
         { info_tbl: [(cdUxN,
                       label: block_cdUxN_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUxN: // global
           if (R1 == 0) goto cdUyt; else goto cdUxX;
       cdUyt: // global
           I64[Sp + 24] = block_cdUyq_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 40];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdUxX: // global
           _sdUnO::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdUxV_info;
           R1 = _sdUnO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udUyy; else goto cdUxY;
       udUyy: // global
           call _cdUxV(R1) args: 0, res: 0, upd: 0;
       cdUxY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUyq() //  []
         { info_tbl: [(cdUyq,
                       label: block_cdUyq_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUyq: // global
           _sdUn9::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdUys_info;
           R2 = P64[Sp + 8];
           R1 = _sdUn9::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUxV() //  [R1]
         { info_tbl: [(cdUxV,
                       label: block_cdUxV_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUxV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdUy4; else goto cdUy3;
       cdUy4: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdUy3: // global
           _sdUnP::P64 = P64[Sp + 8];
           _sdUnQ::P64 = P64[Sp + 16];
           _sdUnY::I64 = I64[R1 + 7];
           if (_sdUnY::I64 != 0) goto cdUye; else goto cdUyl;
       cdUye: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdUnY::I64 + 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = _sdUnP::P64;
           P64[Hp] = _sdUnQ::P64;
           _sdUn9::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cdUys_info;
           R2 = Hp - 23;
           R1 = _sdUn9::P64;
           Sp = Sp + 40;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdUyl: // global
           Hp = Hp - 48;
           I64[Sp + 32] = block_cdUyi_info;
           R3 = _sdUnQ::P64;
           R2 = _sdUnP::P64;
           Sp = Sp + 32;
           call Control.Concurrent.QSem.signalQSem2_entry(R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdUyi() //  [R1]
         { info_tbl: [(cdUyi,
                       label: block_cdUyi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUyi: // global
           _sdUn9::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdUys_info;
           R2 = R1;
           R1 = _sdUn9::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUys() //  []
         { info_tbl: [(cdUys,
                       label: block_cdUys_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUys: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdUxB() //  []
         { info_tbl: [(cdUxB,
                       label: block_cdUxB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUxB: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.35792159 UTC

[section ""data" . Control.Concurrent.QSem.$wwaitQSem_closure" {
     Control.Concurrent.QSem.$wwaitQSem_closure:
         const Control.Concurrent.QSem.$wwaitQSem_info;
 },
 sat_sdUoF_entry() //  [R1, R2]
         { info_tbl: [(cdUAI,
                       label: sat_sdUoF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUAI: // global
           R4 = R2;
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           call Control.Concurrent.QSem.$wlvl_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdUoC_entry() //  [R1]
         { info_tbl: [(cdUAQ,
                       label: sat_sdUoC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUAQ: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sdUoe_entry() //  [R1]
         { info_tbl: [(cdUAT,
                       label: io_sdUoe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUAT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdUAU; else goto cdUAV;
       cdUAU: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdUAV: // global
           I64[Sp - 16] = block_cdUAh_info;
           _sdUo9::P64 = P64[R1 + 7];
           R1 = _sdUo9::P64;
           P64[Sp - 8] = _sdUo9::P64;
           Sp = Sp - 16;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUAh() //  [R1]
         { info_tbl: [(cdUAh,
                       label: block_cdUAh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUAh: // global
           I64[Sp] = block_cdUAj_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udUBi; else goto cdUAk;
       udUBi: // global
           call _cdUAj(R1) args: 0, res: 0, upd: 0;
       cdUAk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUAj() //  [R1]
         { info_tbl: [(cdUAj,
                       label: block_cdUAj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUAj: // global
           I64[Sp - 16] = block_cdUAo_info;
           _sdUol::P64 = P64[R1 + 15];
           _sdUom::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdUom::P64;
           P64[Sp] = _sdUol::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udUBj; else goto cdUAp;
       udUBj: // global
           call _cdUAo(R1) args: 0, res: 0, upd: 0;
       cdUAp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUAo() //  [R1]
         { info_tbl: [(cdUAo,
                       label: block_cdUAo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUAo: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdUB0; else goto cdUAZ;
       cdUB0: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdUAZ: // global
           _sdUop::I64 = I64[R1 + 7];
           if (_sdUop::I64 == 0) goto cdUBb; else goto cdUB8;
       cdUBb: // global
           Hp = Hp - 48;
           I64[Sp - 8] = block_cdUAw_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
       cdUB8: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdUop::I64 - 1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _sdUo9::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cdUB6_info;
           R2 = Hp - 23;
           R1 = _sdUo9::P64;
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUAw() //  [R1]
         { info_tbl: [(cdUAw,
                       label: block_cdUAw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUAw: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdUBe; else goto cdUBd;
       cdUBe: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdUBd: // global
           I64[Hp - 64] = GHC.MVar.MVar_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = Hp - 46;
           I64[Sp + 16] = block_cdUAB_info;
           R2 = Hp - 23;
           _sdUow::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 24] = _sdUow::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUAB() //  []
         { info_tbl: [(cdUAB,
                       label: block_cdUAB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUAB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdUBh; else goto cdUBg;
       cdUBh: // global
           HpAlloc = 40;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdUBg: // global
           I64[Hp - 32] = sat_sdUoF_info;
           P64[Hp - 24] = P64[Sp + 16];
           _sdUow::P64 = P64[Sp + 8];
           P64[Hp - 16] = _sdUow::P64;
           I64[Hp - 8] = sat_sdUoC_info;
           P64[Hp] = _sdUow::P64;
           R2 = Hp - 30;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdUB6() //  []
         { info_tbl: [(cdUB6,
                       label: block_cdUB6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUB6: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSem.$wwaitQSem_entry() //  [R2]
         { info_tbl: [(cdUBo,
                       label: Control.Concurrent.QSem.$wwaitQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUBo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdUBp; else goto cdUBq;
       cdUBp: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.$wwaitQSem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdUBq: // global
           I64[Sp - 16] = block_cdUAa_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdUAa() //  [R1]
         { info_tbl: [(cdUAa,
                       label: block_cdUAa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUAa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdUBt; else goto cdUBs;
       cdUBt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdUBs: // global
           I64[Hp - 8] = io_sdUoe_info;
           P64[Hp] = P64[Sp + 8];
           _cdUAc::P64 = Hp - 7;
           if (R1 == 0) goto cdUBn; else goto cdUBm;
       cdUBn: // global
           R1 = _cdUAc::P64;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cdUBm: // global
           R1 = _cdUAc::P64;
           Sp = Sp + 16;
           call io_sdUoe_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.382947681 UTC

[section ""data" . Control.Concurrent.QSem.waitQSem1_closure" {
     Control.Concurrent.QSem.waitQSem1_closure:
         const Control.Concurrent.QSem.waitQSem1_info;
 },
 Control.Concurrent.QSem.waitQSem1_entry() //  [R2]
         { info_tbl: [(cdUCF,
                       label: Control.Concurrent.QSem.waitQSem1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUCF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdUCG; else goto cdUCH;
       cdUCG: // global
           R2 = R2;
           R1 = Control.Concurrent.QSem.waitQSem1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdUCH: // global
           I64[Sp - 8] = block_cdUCC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udUCL; else goto cdUCD;
       udUCL: // global
           call _cdUCC(R1) args: 0, res: 0, upd: 0;
       cdUCD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdUCC() //  [R1]
         { info_tbl: [(cdUCC,
                       label: block_cdUCC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUCC: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Control.Concurrent.QSem.$wwaitQSem_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.389237168 UTC

[section ""data" . Control.Concurrent.QSem.waitQSem_closure" {
     Control.Concurrent.QSem.waitQSem_closure:
         const Control.Concurrent.QSem.waitQSem_info;
 },
 Control.Concurrent.QSem.waitQSem_entry() //  [R2]
         { info_tbl: [(cdUD0,
                       label: Control.Concurrent.QSem.waitQSem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUD0: // global
           R2 = R2;
           call Control.Concurrent.QSem.waitQSem1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.392978485 UTC

[section ""data" . Control.Concurrent.QSem.QSem_closure" {
     Control.Concurrent.QSem.QSem_closure:
         const Control.Concurrent.QSem.QSem_info;
 },
 Control.Concurrent.QSem.QSem_entry() //  [R2]
         { info_tbl: [(cdUDc,
                       label: Control.Concurrent.QSem.QSem_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUDc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdUDg; else goto cdUDf;
       cdUDg: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Control.Concurrent.QSem.QSem_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdUDf: // global
           I64[Hp - 8] = Control.Concurrent.QSem.QSem_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.396962072 UTC

[Control.Concurrent.QSem.QSem_con_entry() //  [R1]
         { info_tbl: [(cdUDn,
                       label: Control.Concurrent.QSem.QSem_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,81,83,101,109,46,81,83,101,109]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUDn: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.40041379 UTC

[section ""relreadonly" . SdUpQ_srt" {
     SdUpQ_srt:
         const GHC.IO.failIO1_closure;
         const Control.Concurrent.QSem.newQSem2_closure;
         const Control.Concurrent.QSem.newQSem1_closure;
 }]

