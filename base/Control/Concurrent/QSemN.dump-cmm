
==================== Output Cmm ====================
2018-03-16 16:09:07.653194083 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:07.662279347 UTC

[section ""data" . Control.Concurrent.QSemN.$WQSemN_closure" {
     Control.Concurrent.QSemN.$WQSemN_closure:
         const Control.Concurrent.QSemN.$WQSemN_info;
 },
 Control.Concurrent.QSemN.$WQSemN_entry() //  [R2]
         { info_tbl: [(cdSzh,
                       label: Control.Concurrent.QSemN.$WQSemN_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSzh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdSzl; else goto cdSzm;
       cdSzl: // global
           R2 = R2;
           R1 = Control.Concurrent.QSemN.$WQSemN_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdSzm: // global
           I64[Sp - 8] = block_cdSze_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udSzq; else goto cdSzf;
       udSzq: // global
           call _cdSze(R1) args: 0, res: 0, upd: 0;
       cdSzf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSze() //  [R1]
         { info_tbl: [(cdSze,
                       label: block_cdSze_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSze: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdSzp; else goto cdSzo;
       cdSzp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdSzo: // global
           _sdSvS::P64 = P64[R1 + 7];
           I64[Hp - 8] = Control.Concurrent.QSemN.QSemN_con_info;
           P64[Hp] = _sdSvS::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.663615113 UTC

[section ""cstring" . Control.Concurrent.QSemN.$trModule4_bytes" {
     Control.Concurrent.QSemN.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.664227654 UTC

[section ""data" . Control.Concurrent.QSemN.$trModule3_closure" {
     Control.Concurrent.QSemN.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSemN.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.664815716 UTC

[section ""cstring" . Control.Concurrent.QSemN.$trModule2_bytes" {
     Control.Concurrent.QSemN.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,81,83,101,109,78]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.665449962 UTC

[section ""data" . Control.Concurrent.QSemN.$trModule1_closure" {
     Control.Concurrent.QSemN.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSemN.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.666087376 UTC

[section ""data" . Control.Concurrent.QSemN.$trModule_closure" {
     Control.Concurrent.QSemN.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.QSemN.$trModule3_closure+1;
         const Control.Concurrent.QSemN.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.66667991 UTC

[section ""data" . $krep_rdSvw_closure" {
     $krep_rdSvw_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.667268736 UTC

[section ""data" . $krep1_rdSvx_closure" {
     $krep1_rdSvx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.667852899 UTC

[section ""data" . $krep2_rdSvy_closure" {
     $krep2_rdSvy_closure:
         const :_con_info;
         const $krep_rdSvw_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.668463157 UTC

[section ""data" . $krep3_rdSvz_closure" {
     $krep3_rdSvz_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep2_rdSvy_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.669099132 UTC

[section ""data" . $krep4_rdSvA_closure" {
     $krep4_rdSvA_closure:
         const :_con_info;
         const $krep3_rdSvz_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.669730217 UTC

[section ""data" . $krep5_rdSvB_closure" {
     $krep5_rdSvB_closure:
         const :_con_info;
         const $krep1_rdSvx_closure+1;
         const $krep4_rdSvA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.670348179 UTC

[section ""data" . $krep6_rdSvC_closure" {
     $krep6_rdSvC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep5_rdSvB_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.670981774 UTC

[section ""data" . $krep7_rdSvD_closure" {
     $krep7_rdSvD_closure:
         const :_con_info;
         const $krep6_rdSvC_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.67160711 UTC

[section ""data" . $krep8_rdSvE_closure" {
     $krep8_rdSvE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep7_rdSvD_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.672207745 UTC

[section ""data" . $krep9_rdSvF_closure" {
     $krep9_rdSvF_closure:
         const :_con_info;
         const $krep8_rdSvE_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.672831889 UTC

[section ""data" . $krep10_rdSvG_closure" {
     $krep10_rdSvG_closure:
         const :_con_info;
         const $krep8_rdSvE_closure+1;
         const $krep9_rdSvF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.673509337 UTC

[section ""data" . $krep11_rdSvH_closure" {
     $krep11_rdSvH_closure:
         const :_con_info;
         const $krep1_rdSvx_closure+1;
         const $krep10_rdSvG_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.674127533 UTC

[section ""data" . $krep12_rdSvI_closure" {
     $krep12_rdSvI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,,)_closure;
         const $krep11_rdSvH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.674764795 UTC

[section ""data" . $krep13_rdSvJ_closure" {
     $krep13_rdSvJ_closure:
         const :_con_info;
         const $krep12_rdSvI_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.675369629 UTC

[section ""data" . $krep14_rdSvK_closure" {
     $krep14_rdSvK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep13_rdSvJ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.675950977 UTC

[section ""cstring" . Control.Concurrent.QSemN.$tcQSemN2_bytes" {
     Control.Concurrent.QSemN.$tcQSemN2_bytes:
         I8[] [81,83,101,109,78]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.67657884 UTC

[section ""data" . Control.Concurrent.QSemN.$tcQSemN1_closure" {
     Control.Concurrent.QSemN.$tcQSemN1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSemN.$tcQSemN2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.677132536 UTC

[section ""data" . Control.Concurrent.QSemN.$tcQSemN_closure" {
     Control.Concurrent.QSemN.$tcQSemN_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.QSemN.$trModule_closure+1;
         const Control.Concurrent.QSemN.$tcQSemN1_closure+1;
         const GHC.Types.krep$*_closure;
         const 8650881979471817661;
         const 11033619023634057930;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.677771068 UTC

[section ""data" . $krep15_rdSvL_closure" {
     $krep15_rdSvL_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Concurrent.QSemN.$tcQSemN_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.678366149 UTC

[section ""data" . Control.Concurrent.QSemN.$tc'QSemN1_closure" {
     Control.Concurrent.QSemN.$tc'QSemN1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_rdSvK_closure+1;
         const $krep15_rdSvL_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.67896308 UTC

[section ""cstring" . Control.Concurrent.QSemN.$tc'QSemN3_bytes" {
     Control.Concurrent.QSemN.$tc'QSemN3_bytes:
         I8[] [39,81,83,101,109,78]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.679531522 UTC

[section ""data" . Control.Concurrent.QSemN.$tc'QSemN2_closure" {
     Control.Concurrent.QSemN.$tc'QSemN2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSemN.$tc'QSemN3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.680119276 UTC

[section ""data" . Control.Concurrent.QSemN.$tc'QSemN_closure" {
     Control.Concurrent.QSemN.$tc'QSemN_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.QSemN.$trModule_closure+1;
         const Control.Concurrent.QSemN.$tc'QSemN2_closure+1;
         const Control.Concurrent.QSemN.$tc'QSemN1_closure+4;
         const 15878277071781304355;
         const 273080421945023395;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.680725156 UTC

[section ""cstring" . lvl_rdSvM_bytes" {
     lvl_rdSvM_bytes:
         I8[] [110,101,119,81,83,101,109,78,58,32,73,110,105,116,105,97,108,32,113,117,97,110,116,105,116,121,32,109,117,115,116,32,98,101,32,110,111,110,45,110,101,103,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.681719482 UTC

[section ""data" . Control.Concurrent.QSemN.newQSemN2_closure" {
     Control.Concurrent.QSemN.newQSemN2_closure:
         const Control.Concurrent.QSemN.newQSemN2_info;
         const 0;
 },
 Control.Concurrent.QSemN.newQSemN2_entry() //  []
         { info_tbl: [(cdSzx,
                       label: Control.Concurrent.QSemN.newQSemN2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSzx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdSzy; else goto cdSzz;
       cdSzy: // global
           R1 = Control.Concurrent.QSemN.newQSemN2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdSzz: // global
           I64[Sp - 8] = block_cdSzv_info;
           R2 = lvl_rdSvM_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdSzv() //  [R1]
         { info_tbl: [(cdSzv,
                       label: block_cdSzv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSzv: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.683279651 UTC

[section ""data" . Control.Concurrent.QSemN.newQSemN1_closure" {
     Control.Concurrent.QSemN.newQSemN1_closure:
         const Control.Concurrent.QSemN.newQSemN1_info;
         const 0;
 },
 Control.Concurrent.QSemN.newQSemN1_entry() //  [R2]
         { info_tbl: [(cdSzL,
                       label: Control.Concurrent.QSemN.newQSemN1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSzL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdSzM; else goto cdSzN;
       cdSzM: // global
           R2 = R2;
           R1 = Control.Concurrent.QSemN.newQSemN1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdSzN: // global
           I64[Sp - 8] = block_cdSzI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udSA9; else goto cdSzJ;
       udSA9: // global
           call _cdSzI(R1) args: 0, res: 0, upd: 0;
       cdSzJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSzI() //  [R1]
         { info_tbl: [(cdSzI,
                       label: block_cdSzI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSzI: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto cdSA1; else goto cdSA8;
       cdSA1: // global
           I64[Sp - 8] = block_cdSzU_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
       cdSA8: // global
           Sp = Sp + 8;
           call Control.Concurrent.QSemN.newQSemN2_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cdSzU() //  [R1]
         { info_tbl: [(cdSzU,
                       label: block_cdSzU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSzU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdSA4; else goto cdSA3;
       cdSA4: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdSA3: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp] = block_cdSzX_info;
           R2 = Hp - 23;
           _sdSw2::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _sdSw2::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSzX() //  []
         { info_tbl: [(cdSzX,
                       label: block_cdSzX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSzX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdSA7; else goto cdSA6;
       cdSA7: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdSA6: // global
           I64[Hp - 8] = Control.Concurrent.QSemN.QSemN_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.685068986 UTC

[section ""data" . Control.Concurrent.QSemN.newQSemN_closure" {
     Control.Concurrent.QSemN.newQSemN_closure:
         const Control.Concurrent.QSemN.newQSemN_info;
         const 0;
 },
 Control.Concurrent.QSemN.newQSemN_entry() //  [R2]
         { info_tbl: [(cdSAe,
                       label: Control.Concurrent.QSemN.newQSemN_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSAe: // global
           R2 = R2;
           call Control.Concurrent.QSemN.newQSemN1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.685906819 UTC

[section ""data" . lvl1_rdSvN_closure" {
     lvl1_rdSvN_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.68843861 UTC

[section ""data" . Control.Concurrent.QSemN.$wloop_closure" {
     Control.Concurrent.QSemN.$wloop_closure:
         const Control.Concurrent.QSemN.$wloop_info;
 },
 sat_sdSwh_entry() //  [R1]
         { info_tbl: [(cdSAC,
                       label: sat_sdSwh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSAC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdSAD; else goto cdSAE;
       cdSAD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdSAE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse1_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Concurrent.QSemN.$wloop_entry() //  [R2, R3, R4]
         { info_tbl: [(cdSAI,
                       label: Control.Concurrent.QSemN.$wloop_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSAI: // global
           if ((Sp + -48) < SpLim) (likely: False) goto udSC1; else goto udSC0;
       udSC1: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cdSAJ() args: 0, res: 0, upd: 0;
       udSC0: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cdSAi() args: 0, res: 0, upd: 0;
     }
 },
 _cdSAi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSAi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdSAM; else goto cdSAL;
       cdSAM: // global
           HpAlloc = 32;
           call _cdSAJ() args: 0, res: 0, upd: 0;
       cdSAL: // global
           _sdSw7::P64 = P64[Sp + 8];
           _sdSwa::I64 = I64[Sp];
           if (_sdSwa::I64 != 0) goto cdSAG; else goto cdSAH;
       cdSAG: // global
           Hp = Hp - 32;
           I64[Sp] = block_cdSAn_info;
           R1 = _sdSw7::P64;
           I64[Sp + 8] = _sdSwa::I64;
           if (R1 & 7 != 0) goto udSC6; else goto cdSAo;
       udSC6: // global
           call _cdSAn(R1) args: 0, res: 0, upd: 0;
       cdSAo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdSAH: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl1_rdSvN_closure+1;
           P64[Hp - 8] = _sdSw7::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdSAJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSAJ: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = Control.Concurrent.QSemN.$wloop_closure;
           Sp = Sp + 24;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdSAn() //  [R1]
         { info_tbl: [(cdSAn,
                       label: block_cdSAn_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSAn: // global
           if (R1 & 7 == 1) goto cdSAP; else goto cdSBb;
       cdSAP: // global
           I64[Sp] = block_cdSAs_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto udSC8; else goto cdSAt;
       udSC8: // global
           call _cdSAs(R1) args: 0, res: 0, upd: 0;
       cdSAt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdSBb: // global
           I64[Sp - 16] = block_cdSB4_info;
           _sdSwb::P64 = R1;
           _sdSwj::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdSwj::P64;
           P64[Sp] = _sdSwb::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udSC9; else goto cdSB5;
       udSC9: // global
           call _cdSB4(R1) args: 0, res: 0, upd: 0;
       cdSB5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSAs() //  [R1]
         { info_tbl: [(cdSAs,
                       label: block_cdSAs_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSAs: // global
           _sdSwa::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cdSAU; else goto cdSAY;
       cdSAU: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdSAX; else goto cdSAW;
       cdSAX: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdSAW: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdSwa::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdSAY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdSB1; else goto cdSB0;
       cdSB1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdSB0: // global
           I64[Hp - 16] = sat_sdSwh_info;
           P64[Hp] = R1;
           I64[Sp] = _sdSwa::I64;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = GHC.Types.[]_closure+1;
           call _cdSAi() args: 0, res: 0, upd: 0;
     }
 },
 _cdSB4() //  [R1]
         { info_tbl: [(cdSB4,
                       label: block_cdSB4_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSB4: // global
           I64[Sp - 8] = block_cdSB9_info;
           _sdSwm::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sdSwm::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udSCd; else goto cdSBd;
       udSCd: // global
           call _cdSB9(R1) args: 0, res: 0, upd: 0;
       cdSBd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSB9() //  [R1]
         { info_tbl: [(cdSB9,
                       label: block_cdSB9_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSB9: // global
           _sdSwm::P64 = P64[Sp + 8];
           _sdSwo::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_sdSwo::I64,
                            I64[Sp + 32])) goto cdSBn; else goto cdSBC;
       cdSBn: // global
           I64[Sp + 8] = block_cdSBl_info;
           R1 = _sdSwm::P64;
           I64[Sp + 24] = _sdSwo::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udSCe; else goto cdSBo;
       udSCe: // global
           call _cdSBl(R1) args: 0, res: 0, upd: 0;
       cdSBo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdSBC: // global
           I64[Sp + 8] = block_cdSBB_info;
           R1 = _sdSwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udSCf; else goto cdSBD;
       udSCf: // global
           call _cdSBB(R1) args: 0, res: 0, upd: 0;
       cdSBD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSBl() //  [R1]
         { info_tbl: [(cdSBl,
                       label: block_cdSBl_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSBl: // global
           I64[Sp] = block_cdSBs_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[R1 + 7];
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSBs() //  [R1]
         { info_tbl: [(cdSBs,
                       label: block_cdSBs_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSBs: // global
           _sdSw8::P64 = P64[Sp + 32];
           _sdSwa::I64 = I64[Sp + 24];
           _sdSwj::P64 = P64[Sp + 8];
           if (R1 == 0) goto cdSBz; else goto cdSBy;
       cdSBz: // global
           I64[Sp + 16] = _sdSwa::I64;
           P64[Sp + 24] = _sdSwj::P64;
           P64[Sp + 32] = _sdSw8::P64;
           Sp = Sp + 16;
           goto udSCh;
       cdSBy: // global
           I64[Sp + 16] = _sdSwa::I64 - I64[Sp + 16];
           P64[Sp + 24] = _sdSwj::P64;
           P64[Sp + 32] = _sdSw8::P64;
           Sp = Sp + 16;
           goto udSCh;
       udSCh: // global
           call _cdSAi() args: 0, res: 0, upd: 0;
     }
 },
 _cdSBB() //  [R1]
         { info_tbl: [(cdSBB,
                       label: block_cdSBB_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSBB: // global
           I64[Sp] = block_cdSBH_info;
           R1 = P64[R1 + 7];
           call stg_isEmptyMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSBH() //  [R1]
         { info_tbl: [(cdSBH,
                       label: block_cdSBH_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSBH: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdSBM; else goto cdSBL;
       cdSBM: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdSBL: // global
           _sdSw8::P64 = P64[Sp + 32];
           _sdSwa::I64 = I64[Sp + 24];
           if (R1 == 0) goto cdSBT; else goto cdSBS;
       cdSBT: // global
           Hp = Hp - 48;
           I64[Sp + 16] = _sdSwa::I64;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = _sdSw8::P64;
           Sp = Sp + 16;
           call _cdSAi() args: 0, res: 0, upd: 0;
       cdSBS: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdSwa::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sdSw8::P64;
           R1 = Hp - 23;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.694333181 UTC

[section ""data" . Control.Concurrent.QSemN.$wsignalQSemN_closure" {
     Control.Concurrent.QSemN.$wsignalQSemN_closure:
         const Control.Concurrent.QSemN.$wsignalQSemN_info;
 },
 sat_sdSx2_entry() //  [R1]
         { info_tbl: [(cdSCB,
                       label: sat_sdSx2_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSCB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdSCP; else goto cdSCQ;
       cdSCP: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdSCQ: // global
           I64[Sp - 24] = block_cdSCw_info;
           _sdSwG::P64 = P64[R1 + 7];
           _sdSwH::I64 = I64[R1 + 15];
           R1 = _sdSwG::P64;
           P64[Sp - 16] = _sdSwG::P64;
           I64[Sp - 8] = _sdSwH::I64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSCw() //  [R1]
         { info_tbl: [(cdSCw,
                       label: block_cdSCw_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSCw: // global
           I64[Sp] = block_cdSCy_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udSCX; else goto cdSCz;
       udSCX: // global
           call _cdSCy(R1) args: 0, res: 0, upd: 0;
       cdSCz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSCy() //  [R1]
         { info_tbl: [(cdSCy,
                       label: block_cdSCy_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSCy: // global
           I64[Sp - 16] = block_cdSCE_info;
           _sdSwT::P64 = P64[R1 + 15];
           _sdSwU::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdSwU::P64;
           P64[Sp] = _sdSwT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udSCY; else goto cdSCF;
       udSCY: // global
           call _cdSCE(R1) args: 0, res: 0, upd: 0;
       cdSCF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSCE() //  [R1]
         { info_tbl: [(cdSCE,
                       label: block_cdSCE_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSCE: // global
           _sdSwT::P64 = P64[Sp + 16];
           _sdSwX::I64 = I64[Sp + 32] + I64[R1 + 7];
           I64[Sp + 16] = block_cdSCM_info;
           R4 = P64[Sp + 8];
           R3 = _sdSwT::P64;
           R2 = _sdSwX::I64;
           Sp = Sp + 16;
           call Control.Concurrent.QSemN.$wloop_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdSCM() //  [R1]
         { info_tbl: [(cdSCM,
                       label: block_cdSCM_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSCM: // global
           I64[Sp + 16] = block_cdSCO_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSCO() //  []
         { info_tbl: [(cdSCO,
                       label: block_cdSCO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSCO: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSemN.$wsignalQSemN_entry() //  [R2, R3]
         { info_tbl: [(cdSD2,
                       label: Control.Concurrent.QSemN.$wsignalQSemN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSD2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdSD3; else goto cdSD4;
       cdSD3: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.$wsignalQSemN_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdSD4: // global
           I64[Sp - 24] = block_cdSCn_info;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdSCn() //  [R1]
         { info_tbl: [(cdSCn,
                       label: block_cdSCn_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSCn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdSD7; else goto cdSD6;
       cdSD7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdSD6: // global
           _sdSwG::P64 = P64[Sp + 8];
           if (R1 == 1) goto cdSD1; else goto cdSD0;
       cdSD1: // global
           Hp = Hp - 24;
           I64[Sp] = block_cdSD9_info;
           R1 = _sdSwG::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdSD0: // global
           I64[Hp - 16] = sat_sdSx2_info;
           P64[Hp - 8] = _sdSwG::P64;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdSD9() //  [R1]
         { info_tbl: [(cdSD9,
                       label: block_cdSD9_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSD9: // global
           I64[Sp] = block_cdSDb_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udSDx; else goto cdSDc;
       udSDx: // global
           call _cdSDb(R1) args: 0, res: 0, upd: 0;
       cdSDc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSDb() //  [R1]
         { info_tbl: [(cdSDb,
                       label: block_cdSDb_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSDb: // global
           I64[Sp - 16] = block_cdSDg_info;
           _sdSx8::P64 = P64[R1 + 15];
           _sdSx9::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdSx9::P64;
           P64[Sp] = _sdSx8::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udSDy; else goto cdSDh;
       udSDy: // global
           call _cdSDg(R1) args: 0, res: 0, upd: 0;
       cdSDh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSDg() //  [R1]
         { info_tbl: [(cdSDg,
                       label: block_cdSDg_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSDg: // global
           _sdSx8::P64 = P64[Sp + 16];
           _sdSxc::I64 = I64[Sp + 32] + I64[R1 + 7];
           I64[Sp + 16] = block_cdSDo_info;
           R4 = P64[Sp + 8];
           R3 = _sdSx8::P64;
           R2 = _sdSxc::I64;
           Sp = Sp + 16;
           call Control.Concurrent.QSemN.$wloop_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdSDo() //  [R1]
         { info_tbl: [(cdSDo,
                       label: block_cdSDo_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSDo: // global
           I64[Sp + 16] = block_cdSDq_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSDq() //  []
         { info_tbl: [(cdSDq,
                       label: block_cdSDq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSDq: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.69882226 UTC

[section ""data" . Control.Concurrent.QSemN.signalQSemN1_closure" {
     Control.Concurrent.QSemN.signalQSemN1_closure:
         const Control.Concurrent.QSemN.signalQSemN1_info;
 },
 Control.Concurrent.QSemN.signalQSemN1_entry() //  [R2, R3]
         { info_tbl: [(cdSDG,
                       label: Control.Concurrent.QSemN.signalQSemN1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSDG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdSDK; else goto cdSDL;
       cdSDK: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.signalQSemN1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdSDL: // global
           I64[Sp - 16] = block_cdSDD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udSDT; else goto cdSDE;
       udSDT: // global
           call _cdSDD(R1) args: 0, res: 0, upd: 0;
       cdSDE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSDD() //  [R1]
         { info_tbl: [(cdSDD,
                       label: block_cdSDD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSDD: // global
           I64[Sp] = block_cdSDJ_info;
           _sdSxl::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdSxl::P64;
           if (R1 & 7 != 0) goto udSDS; else goto cdSDN;
       udSDS: // global
           call _cdSDJ(R1) args: 0, res: 0, upd: 0;
       cdSDN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSDJ() //  [R1]
         { info_tbl: [(cdSDJ,
                       label: block_cdSDJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSDJ: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Control.Concurrent.QSemN.$wsignalQSemN_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.70031991 UTC

[section ""data" . Control.Concurrent.QSemN.signalQSemN_closure" {
     Control.Concurrent.QSemN.signalQSemN_closure:
         const Control.Concurrent.QSemN.signalQSemN_info;
 },
 Control.Concurrent.QSemN.signalQSemN_entry() //  [R2, R3]
         { info_tbl: [(cdSDY,
                       label: Control.Concurrent.QSemN.signalQSemN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSDY: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.QSemN.signalQSemN1_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.702868956 UTC

[section ""data" . lvl2_rdSvO_closure" {
     lvl2_rdSvO_closure:
         const lvl2_rdSvO_info;
 },
 lvl2_rdSvO_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSE2: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call lvl2_rdSvO_entry(R6,
                                 R5,
                                 R4,
                                 R3,
                                 R2,
                                 R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdSxT_entry() //  [R1]
         { info_tbl: [(cdSEi,
                       label: sat_sdSxT_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSEi: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdSEj; else goto cdSEk;
       cdSEj: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdSEk: // global
           I64[Sp - 32] = block_cdSEd_info;
           _sdSxo::P64 = P64[R1 + 7];
           _sdSxp::P64 = P64[R1 + 15];
           _sdSxq::P64 = P64[R1 + 23];
           R1 = _sdSxo::P64;
           P64[Sp - 24] = _sdSxo::P64;
           P64[Sp - 16] = _sdSxp::P64;
           P64[Sp - 8] = _sdSxq::P64;
           Sp = Sp - 32;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSEd() //  [R1]
         { info_tbl: [(cdSEd,
                       label: block_cdSEd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSEd: // global
           I64[Sp] = block_cdSEf_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udSF1; else goto cdSEg;
       udSF1: // global
           call _cdSEf(R1) args: 0, res: 0, upd: 0;
       cdSEg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSEf() //  [R1]
         { info_tbl: [(cdSEf,
                       label: block_cdSEf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSEf: // global
           I64[Sp - 32] = block_cdSEo_info;
           _sdSxz::P64 = R1;
           _sdSxA::P64 = P64[R1 + 7];
           _sdSxB::P64 = P64[R1 + 15];
           _sdSxC::P64 = P64[R1 + 23];
           R1 = P64[Sp + 24];
           P64[Sp - 24] = _sdSxA::P64;
           P64[Sp - 16] = _sdSxB::P64;
           P64[Sp - 8] = _sdSxC::P64;
           P64[Sp] = _sdSxz::P64;
           Sp = Sp - 32;
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSEo() //  [R1]
         { info_tbl: [(cdSEo,
                       label: block_cdSEo_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSEo: // global
           if (R1 == 0) goto cdSEX; else goto cdSEN;
       cdSEX: // global
           I64[Sp + 24] = block_cdSEU_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 56];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdSEN: // global
           I64[Sp] = block_cdSEw_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto udSF2; else goto cdSEx;
       udSF2: // global
           call _cdSEw(R1) args: 0, res: 0, upd: 0;
       cdSEx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSEU() //  []
         { info_tbl: [(cdSEU,
                       label: block_cdSEU_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSEU: // global
           I64[Sp + 32] = block_cdSEW_info;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSEw() //  [R1]
         { info_tbl: [(cdSEw,
                       label: block_cdSEw_info
                       rep:StackRep [False, False, False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSEw: // global
           _sdSxA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdSEB_info;
           _sdSxJ::I64 = I64[R1 + 7];
           R1 = _sdSxA::P64;
           I64[Sp + 56] = _sdSxJ::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udSF3; else goto cdSEC;
       udSF3: // global
           call _cdSEB(R1) args: 0, res: 0, upd: 0;
       cdSEC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSEB() //  [R1]
         { info_tbl: [(cdSEB,
                       label: block_cdSEB_info
                       rep:StackRep [False, False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSEB: // global
           _sdSxM::I64 = I64[Sp + 48] + I64[R1 + 7];
           I64[Sp + 24] = block_cdSEJ_info;
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = _sdSxM::I64;
           Sp = Sp + 24;
           call Control.Concurrent.QSemN.$wloop_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdSEJ() //  [R1]
         { info_tbl: [(cdSEJ,
                       label: block_cdSEJ_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSEJ: // global
           I64[Sp + 24] = block_cdSEW_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSEW() //  []
         { info_tbl: [(cdSEW,
                       label: block_cdSEW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSEW: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl2_rdSvO_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdSF7,
                       label: lvl2_rdSvO_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSF7: // global
           _sdSxt::I64 = R6;
           _sdSxs::P64 = R5;
           _sdSxq::P64 = R4;
           _sdSxp::P64 = R3;
           _sdSxo::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto cdSF8; else goto cdSF9;
       cdSF9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdSFb; else goto cdSFa;
       cdSFb: // global
           HpAlloc = 32;
           goto cdSF8;
       cdSF8: // global
           R1 = lvl2_rdSvO_closure;
           P64[Sp - 40] = _sdSxo::P64;
           P64[Sp - 32] = _sdSxp::P64;
           P64[Sp - 24] = _sdSxq::P64;
           P64[Sp - 16] = _sdSxs::P64;
           I64[Sp - 8] = _sdSxt::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cdSFa: // global
           if (_sdSxt::I64 == 1) goto cdSF6; else goto cdSF5;
       cdSF6: // global
           Hp = Hp - 32;
           I64[Sp - 40] = block_cdSFg_info;
           R1 = _sdSxo::P64;
           P64[Sp - 32] = _sdSxo::P64;
           P64[Sp - 24] = _sdSxp::P64;
           P64[Sp - 16] = _sdSxq::P64;
           P64[Sp - 8] = _sdSxs::P64;
           Sp = Sp - 40;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdSF5: // global
           I64[Hp - 24] = sat_sdSxT_info;
           P64[Hp - 16] = _sdSxo::P64;
           P64[Hp - 8] = _sdSxp::P64;
           P64[Hp] = _sdSxq::P64;
           I64[Sp - 16] = block_cdSFc_info;
           R1 = Hp - 23;
           P64[Sp - 8] = _sdSxs::P64;
           Sp = Sp - 16;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSFg() //  [R1]
         { info_tbl: [(cdSFg,
                       label: block_cdSFg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSFg: // global
           I64[Sp] = block_cdSFi_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udSG1; else goto cdSFk;
       udSG1: // global
           call _cdSFi(R1) args: 0, res: 0, upd: 0;
       cdSFk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSFi() //  [R1]
         { info_tbl: [(cdSFi,
                       label: block_cdSFi_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSFi: // global
           I64[Sp - 32] = block_cdSFo_info;
           _sdSy0::P64 = R1;
           _sdSy1::P64 = P64[R1 + 7];
           _sdSy2::P64 = P64[R1 + 15];
           _sdSy3::P64 = P64[R1 + 23];
           R1 = P64[Sp + 24];
           P64[Sp - 24] = _sdSy1::P64;
           P64[Sp - 16] = _sdSy2::P64;
           P64[Sp - 8] = _sdSy3::P64;
           P64[Sp] = _sdSy0::P64;
           Sp = Sp - 32;
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSFo() //  [R1]
         { info_tbl: [(cdSFo,
                       label: block_cdSFo_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSFo: // global
           if (R1 == 0) goto cdSFX; else goto cdSFN;
       cdSFX: // global
           I64[Sp + 24] = block_cdSFU_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 56];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdSFN: // global
           I64[Sp] = block_cdSFw_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto udSG2; else goto cdSFx;
       udSG2: // global
           call _cdSFw(R1) args: 0, res: 0, upd: 0;
       cdSFx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSFU() //  []
         { info_tbl: [(cdSFU,
                       label: block_cdSFU_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSFU: // global
           I64[Sp + 32] = block_cdSFW_info;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSFw() //  [R1]
         { info_tbl: [(cdSFw,
                       label: block_cdSFw_info
                       rep:StackRep [False, False, False, True, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSFw: // global
           _sdSy1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdSFB_info;
           _sdSya::I64 = I64[R1 + 7];
           R1 = _sdSy1::P64;
           I64[Sp + 56] = _sdSya::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udSG3; else goto cdSFC;
       udSG3: // global
           call _cdSFB(R1) args: 0, res: 0, upd: 0;
       cdSFC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSFB() //  [R1]
         { info_tbl: [(cdSFB,
                       label: block_cdSFB_info
                       rep:StackRep [False, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSFB: // global
           _sdSyd::I64 = I64[Sp + 48] + I64[R1 + 7];
           I64[Sp + 24] = block_cdSFJ_info;
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = _sdSyd::I64;
           Sp = Sp + 24;
           call Control.Concurrent.QSemN.$wloop_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdSFJ() //  [R1]
         { info_tbl: [(cdSFJ,
                       label: block_cdSFJ_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSFJ: // global
           I64[Sp + 24] = block_cdSFW_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSFW() //  []
         { info_tbl: [(cdSFW,
                       label: block_cdSFW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSFW: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdSFc() //  []
         { info_tbl: [(cdSFc,
                       label: block_cdSFc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSFc: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.709760064 UTC

[section ""data" . Control.Concurrent.QSemN.$wlvl_closure" {
     Control.Concurrent.QSemN.$wlvl_closure:
         const Control.Concurrent.QSemN.$wlvl_info;
 },
 Control.Concurrent.QSemN.$wlvl_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdSGa,
                       label: Control.Concurrent.QSemN.$wlvl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSGa: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdSGb; else goto cdSGc;
       cdSGb: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.$wlvl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdSGc: // global
           I64[Sp - 40] = block_cdSG8_info;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdSG8() //  [R1]
         { info_tbl: [(cdSG8,
                       label: block_cdSG8_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSG8: // global
           R6 = R1;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           Sp = Sp + 40;
           call lvl2_rdSvO_entry(R6, R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.712329301 UTC

[section ""data" . Control.Concurrent.QSemN.$wwaitQSemN_closure" {
     Control.Concurrent.QSemN.$wwaitQSemN_closure:
         const Control.Concurrent.QSemN.$wwaitQSemN_info;
 },
 sat_sdSz1_entry() //  [R1, R2]
         { info_tbl: [(cdSGW,
                       label: sat_sdSz1_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSGW: // global
           R5 = R2;
           R4 = P64[R1 + 6];
           R3 = P64[R1 + 22];
           R2 = P64[R1 + 14];
           call Control.Concurrent.QSemN.$wlvl_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdSyY_entry() //  [R1]
         { info_tbl: [(cdSH4,
                       label: sat_sdSyY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSH4: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sdSyy_entry() //  [R1]
         { info_tbl: [(cdSH7,
                       label: io_sdSyy_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSH7: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdSH8; else goto cdSH9;
       cdSH8: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdSH9: // global
           I64[Sp - 24] = block_cdSGp_info;
           _sdSys::P64 = P64[R1 + 7];
           _sdSyt::I64 = I64[R1 + 15];
           R1 = _sdSys::P64;
           P64[Sp - 16] = _sdSys::P64;
           I64[Sp - 8] = _sdSyt::I64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSGp() //  [R1]
         { info_tbl: [(cdSGp,
                       label: block_cdSGp_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSGp: // global
           I64[Sp] = block_cdSGr_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udSHt; else goto cdSGs;
       udSHt: // global
           call _cdSGr(R1) args: 0, res: 0, upd: 0;
       cdSGs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSGr() //  [R1]
         { info_tbl: [(cdSGr,
                       label: block_cdSGr_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSGr: // global
           I64[Sp - 16] = block_cdSGw_info;
           _sdSyF::P64 = P64[R1 + 15];
           _sdSyG::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdSyG::P64;
           P64[Sp] = _sdSyF::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udSHu; else goto cdSGx;
       udSHu: // global
           call _cdSGw(R1) args: 0, res: 0, upd: 0;
       cdSGx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSGw() //  [R1]
         { info_tbl: [(cdSGw,
                       label: block_cdSGw_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSGw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdSHe; else goto cdSHd;
       cdSHe: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdSHd: // global
           _sdSyJ::I64 = I64[R1 + 7] - I64[Sp + 32];
           if (%MO_S_Ge_W64(_sdSyJ::I64, 0)) goto cdSHj; else goto cdSHm;
       cdSHj: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdSyJ::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 32] = block_cdSHh_info;
           R2 = Hp - 23;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdSHm: // global
           Hp = Hp - 48;
           I64[Sp - 8] = block_cdSGI_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdSHh() //  []
         { info_tbl: [(cdSHh,
                       label: block_cdSHh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSHh: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdSGI() //  [R1]
         { info_tbl: [(cdSGI,
                       label: block_cdSGI_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSGI: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdSHp; else goto cdSHo;
       cdSHp: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdSHo: // global
           I64[Hp - 104] = GHC.Types.I#_con_info;
           I64[Hp - 96] = I64[Sp + 40];
           I64[Hp - 88] = GHC.MVar.MVar_con_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = (,)_con_info;
           _cdSGK::P64 = Hp - 103;
           P64[Hp - 64] = _cdSGK::P64;
           P64[Hp - 56] = Hp - 87;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 71;
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = Hp - 46;
           I64[Sp + 16] = block_cdSGP_info;
           R2 = Hp - 23;
           _sdSyQ::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 24] = _sdSyQ::P64;
           P64[Sp + 40] = _cdSGK::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSGP() //  []
         { info_tbl: [(cdSGP,
                       label: block_cdSGP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSGP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdSHs; else goto cdSHr;
       cdSHs: // global
           HpAlloc = 48;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdSHr: // global
           I64[Hp - 40] = sat_sdSz1_info;
           P64[Hp - 32] = P64[Sp + 16];
           _sdSyQ::P64 = P64[Sp + 8];
           P64[Hp - 24] = _sdSyQ::P64;
           P64[Hp - 16] = P64[Sp + 24];
           I64[Hp - 8] = sat_sdSyY_info;
           P64[Hp] = _sdSyQ::P64;
           R2 = Hp - 38;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSemN.$wwaitQSemN_entry() //  [R2, R3]
         { info_tbl: [(cdSHz,
                       label: Control.Concurrent.QSemN.$wwaitQSemN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSHz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdSHA; else goto cdSHB;
       cdSHA: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.$wwaitQSemN_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdSHB: // global
           I64[Sp - 24] = block_cdSGi_info;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdSGi() //  [R1]
         { info_tbl: [(cdSGi,
                       label: block_cdSGi_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSGi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdSHE; else goto cdSHD;
       cdSHE: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdSHD: // global
           I64[Hp - 16] = io_sdSyy_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           _cdSGk::P64 = Hp - 15;
           if (R1 == 0) goto cdSHy; else goto cdSHx;
       cdSHy: // global
           R1 = _cdSGk::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cdSHx: // global
           R1 = _cdSGk::P64;
           Sp = Sp + 24;
           call io_sdSyy_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.716200019 UTC

[section ""data" . Control.Concurrent.QSemN.waitQSemN1_closure" {
     Control.Concurrent.QSemN.waitQSemN1_closure:
         const Control.Concurrent.QSemN.waitQSemN1_info;
 },
 Control.Concurrent.QSemN.waitQSemN1_entry() //  [R2, R3]
         { info_tbl: [(cdSHM,
                       label: Control.Concurrent.QSemN.waitQSemN1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSHM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdSHQ; else goto cdSHR;
       cdSHQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.waitQSemN1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdSHR: // global
           I64[Sp - 16] = block_cdSHJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udSHZ; else goto cdSHK;
       udSHZ: // global
           call _cdSHJ(R1) args: 0, res: 0, upd: 0;
       cdSHK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSHJ() //  [R1]
         { info_tbl: [(cdSHJ,
                       label: block_cdSHJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSHJ: // global
           I64[Sp] = block_cdSHP_info;
           _sdSz7::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdSz7::P64;
           if (R1 & 7 != 0) goto udSHY; else goto cdSHT;
       udSHY: // global
           call _cdSHP(R1) args: 0, res: 0, upd: 0;
       cdSHT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSHP() //  [R1]
         { info_tbl: [(cdSHP,
                       label: block_cdSHP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSHP: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Control.Concurrent.QSemN.$wwaitQSemN_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.717801178 UTC

[section ""data" . Control.Concurrent.QSemN.waitQSemN_closure" {
     Control.Concurrent.QSemN.waitQSemN_closure:
         const Control.Concurrent.QSemN.waitQSemN_info;
 },
 Control.Concurrent.QSemN.waitQSemN_entry() //  [R2, R3]
         { info_tbl: [(cdSI4,
                       label: Control.Concurrent.QSemN.waitQSemN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSI4: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.QSemN.waitQSemN1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.718736416 UTC

[section ""data" . Control.Concurrent.QSemN.QSemN_closure" {
     Control.Concurrent.QSemN.QSemN_closure:
         const Control.Concurrent.QSemN.QSemN_info;
 },
 Control.Concurrent.QSemN.QSemN_entry() //  [R2]
         { info_tbl: [(cdSIc,
                       label: Control.Concurrent.QSemN.QSemN_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSIc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdSIg; else goto cdSIf;
       cdSIg: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.QSemN_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdSIf: // global
           I64[Hp - 8] = Control.Concurrent.QSemN.QSemN_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.719622332 UTC

[Control.Concurrent.QSemN.QSemN_con_entry() //  [R1]
         { info_tbl: [(cdSIh,
                       label: Control.Concurrent.QSemN.QSemN_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,81,83,101,109,78,46,81,83,101,109,78]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSIh: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.720309417 UTC

[section ""relreadonly" . SdSzD_srt" {
     SdSzD_srt:
         const GHC.IO.failIO1_closure;
         const Control.Concurrent.QSemN.newQSemN2_closure;
         const Control.Concurrent.QSemN.newQSemN1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.720944799 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:07.721862732 UTC

[section ""data" . Control.Concurrent.QSemN.$WQSemN_closure" {
     Control.Concurrent.QSemN.$WQSemN_closure:
         const Control.Concurrent.QSemN.$WQSemN_info;
 },
 Control.Concurrent.QSemN.$WQSemN_entry() //  [R2]
         { info_tbl: [(cdSIp,
                       label: Control.Concurrent.QSemN.$WQSemN_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSIp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdSIt; else goto cdSIu;
       cdSIt: // global
           R2 = R2;
           R1 = Control.Concurrent.QSemN.$WQSemN_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdSIu: // global
           I64[Sp - 8] = block_cdSIm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udSIy; else goto cdSIn;
       udSIy: // global
           call _cdSIm(R1) args: 0, res: 0, upd: 0;
       cdSIn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSIm() //  [R1]
         { info_tbl: [(cdSIm,
                       label: block_cdSIm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSIm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdSIx; else goto cdSIw;
       cdSIx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdSIw: // global
           _sdSvS::P64 = P64[R1 + 7];
           I64[Hp - 8] = Control.Concurrent.QSemN.QSemN_con_info;
           P64[Hp] = _sdSvS::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.723017005 UTC

[section ""cstring" . Control.Concurrent.QSemN.$trModule4_bytes" {
     Control.Concurrent.QSemN.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.723636773 UTC

[section ""data" . Control.Concurrent.QSemN.$trModule3_closure" {
     Control.Concurrent.QSemN.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSemN.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.724196425 UTC

[section ""cstring" . Control.Concurrent.QSemN.$trModule2_bytes" {
     Control.Concurrent.QSemN.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,81,83,101,109,78]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.72475924 UTC

[section ""data" . Control.Concurrent.QSemN.$trModule1_closure" {
     Control.Concurrent.QSemN.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSemN.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.72542085 UTC

[section ""data" . Control.Concurrent.QSemN.$trModule_closure" {
     Control.Concurrent.QSemN.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.QSemN.$trModule3_closure+1;
         const Control.Concurrent.QSemN.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.726061145 UTC

[section ""data" . $krep_rdSvw_closure" {
     $krep_rdSvw_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.726660655 UTC

[section ""data" . $krep1_rdSvx_closure" {
     $krep1_rdSvx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.727263586 UTC

[section ""data" . $krep2_rdSvy_closure" {
     $krep2_rdSvy_closure:
         const :_con_info;
         const $krep_rdSvw_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.72785776 UTC

[section ""data" . $krep3_rdSvz_closure" {
     $krep3_rdSvz_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep2_rdSvy_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.728455435 UTC

[section ""data" . $krep4_rdSvA_closure" {
     $krep4_rdSvA_closure:
         const :_con_info;
         const $krep3_rdSvz_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.729078567 UTC

[section ""data" . $krep5_rdSvB_closure" {
     $krep5_rdSvB_closure:
         const :_con_info;
         const $krep1_rdSvx_closure+1;
         const $krep4_rdSvA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.729753636 UTC

[section ""data" . $krep6_rdSvC_closure" {
     $krep6_rdSvC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep5_rdSvB_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.730384412 UTC

[section ""data" . $krep7_rdSvD_closure" {
     $krep7_rdSvD_closure:
         const :_con_info;
         const $krep6_rdSvC_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.730954847 UTC

[section ""data" . $krep8_rdSvE_closure" {
     $krep8_rdSvE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep7_rdSvD_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.731579929 UTC

[section ""data" . $krep9_rdSvF_closure" {
     $krep9_rdSvF_closure:
         const :_con_info;
         const $krep8_rdSvE_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.732218574 UTC

[section ""data" . $krep10_rdSvG_closure" {
     $krep10_rdSvG_closure:
         const :_con_info;
         const $krep8_rdSvE_closure+1;
         const $krep9_rdSvF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.732832894 UTC

[section ""data" . $krep11_rdSvH_closure" {
     $krep11_rdSvH_closure:
         const :_con_info;
         const $krep1_rdSvx_closure+1;
         const $krep10_rdSvG_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.733647117 UTC

[section ""data" . $krep12_rdSvI_closure" {
     $krep12_rdSvI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,,)_closure;
         const $krep11_rdSvH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.734282746 UTC

[section ""data" . $krep13_rdSvJ_closure" {
     $krep13_rdSvJ_closure:
         const :_con_info;
         const $krep12_rdSvI_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.734886694 UTC

[section ""data" . $krep14_rdSvK_closure" {
     $krep14_rdSvK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep13_rdSvJ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.735533826 UTC

[section ""cstring" . Control.Concurrent.QSemN.$tcQSemN2_bytes" {
     Control.Concurrent.QSemN.$tcQSemN2_bytes:
         I8[] [81,83,101,109,78]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.736075211 UTC

[section ""data" . Control.Concurrent.QSemN.$tcQSemN1_closure" {
     Control.Concurrent.QSemN.$tcQSemN1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSemN.$tcQSemN2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.736697587 UTC

[section ""data" . Control.Concurrent.QSemN.$tcQSemN_closure" {
     Control.Concurrent.QSemN.$tcQSemN_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.QSemN.$trModule_closure+1;
         const Control.Concurrent.QSemN.$tcQSemN1_closure+1;
         const GHC.Types.krep$*_closure;
         const 8650881979471817661;
         const 11033619023634057930;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.737438511 UTC

[section ""data" . $krep15_rdSvL_closure" {
     $krep15_rdSvL_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Concurrent.QSemN.$tcQSemN_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.73806848 UTC

[section ""data" . Control.Concurrent.QSemN.$tc'QSemN1_closure" {
     Control.Concurrent.QSemN.$tc'QSemN1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_rdSvK_closure+1;
         const $krep15_rdSvL_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.738576621 UTC

[section ""cstring" . Control.Concurrent.QSemN.$tc'QSemN3_bytes" {
     Control.Concurrent.QSemN.$tc'QSemN3_bytes:
         I8[] [39,81,83,101,109,78]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.739190379 UTC

[section ""data" . Control.Concurrent.QSemN.$tc'QSemN2_closure" {
     Control.Concurrent.QSemN.$tc'QSemN2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSemN.$tc'QSemN3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.739770924 UTC

[section ""data" . Control.Concurrent.QSemN.$tc'QSemN_closure" {
     Control.Concurrent.QSemN.$tc'QSemN_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.QSemN.$trModule_closure+1;
         const Control.Concurrent.QSemN.$tc'QSemN2_closure+1;
         const Control.Concurrent.QSemN.$tc'QSemN1_closure+4;
         const 15878277071781304355;
         const 273080421945023395;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.740397152 UTC

[section ""cstring" . lvl_rdSvM_bytes" {
     lvl_rdSvM_bytes:
         I8[] [110,101,119,81,83,101,109,78,58,32,73,110,105,116,105,97,108,32,113,117,97,110,116,105,116,121,32,109,117,115,116,32,98,101,32,110,111,110,45,110,101,103,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.741225602 UTC

[section ""data" . Control.Concurrent.QSemN.newQSemN2_closure" {
     Control.Concurrent.QSemN.newQSemN2_closure:
         const Control.Concurrent.QSemN.newQSemN2_info;
         const 0;
 },
 Control.Concurrent.QSemN.newQSemN2_entry() //  []
         { info_tbl: [(cdSIF,
                       label: Control.Concurrent.QSemN.newQSemN2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSIF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdSIG; else goto cdSIH;
       cdSIG: // global
           R1 = Control.Concurrent.QSemN.newQSemN2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdSIH: // global
           I64[Sp - 8] = block_cdSID_info;
           R2 = lvl_rdSvM_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdSID() //  [R1]
         { info_tbl: [(cdSID,
                       label: block_cdSID_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSID: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.742879617 UTC

[section ""data" . Control.Concurrent.QSemN.newQSemN1_closure" {
     Control.Concurrent.QSemN.newQSemN1_closure:
         const Control.Concurrent.QSemN.newQSemN1_info;
         const 0;
 },
 Control.Concurrent.QSemN.newQSemN1_entry() //  [R2]
         { info_tbl: [(cdSIS,
                       label: Control.Concurrent.QSemN.newQSemN1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSIS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdSIT; else goto cdSIU;
       cdSIT: // global
           R2 = R2;
           R1 = Control.Concurrent.QSemN.newQSemN1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdSIU: // global
           I64[Sp - 8] = block_cdSIP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udSJg; else goto cdSIQ;
       udSJg: // global
           call _cdSIP(R1) args: 0, res: 0, upd: 0;
       cdSIQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSIP() //  [R1]
         { info_tbl: [(cdSIP,
                       label: block_cdSIP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSIP: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto cdSJ8; else goto cdSJf;
       cdSJ8: // global
           I64[Sp - 8] = block_cdSJ1_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
       cdSJf: // global
           Sp = Sp + 8;
           call Control.Concurrent.QSemN.newQSemN2_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cdSJ1() //  [R1]
         { info_tbl: [(cdSJ1,
                       label: block_cdSJ1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSJ1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdSJb; else goto cdSJa;
       cdSJb: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdSJa: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp] = block_cdSJ4_info;
           R2 = Hp - 23;
           _sdSw2::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _sdSw2::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSJ4() //  []
         { info_tbl: [(cdSJ4,
                       label: block_cdSJ4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSJ4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdSJe; else goto cdSJd;
       cdSJe: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdSJd: // global
           I64[Hp - 8] = Control.Concurrent.QSemN.QSemN_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.744552537 UTC

[section ""data" . Control.Concurrent.QSemN.newQSemN_closure" {
     Control.Concurrent.QSemN.newQSemN_closure:
         const Control.Concurrent.QSemN.newQSemN_info;
         const 0;
 },
 Control.Concurrent.QSemN.newQSemN_entry() //  [R2]
         { info_tbl: [(cdSJl,
                       label: Control.Concurrent.QSemN.newQSemN_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSJl: // global
           R2 = R2;
           call Control.Concurrent.QSemN.newQSemN1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.745354314 UTC

[section ""data" . lvl1_rdSvN_closure" {
     lvl1_rdSvN_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.749337041 UTC

[section ""data" . Control.Concurrent.QSemN.$wloop_closure" {
     Control.Concurrent.QSemN.$wloop_closure:
         const Control.Concurrent.QSemN.$wloop_info;
 },
 sat_sdSwh_entry() //  [R1]
         { info_tbl: [(cdSJJ,
                       label: sat_sdSwh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSJJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdSJK; else goto cdSJL;
       cdSJK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdSJL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse1_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Concurrent.QSemN.$wloop_entry() //  [R2, R3, R4]
         { info_tbl: [(cdSJP,
                       label: Control.Concurrent.QSemN.$wloop_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSJP: // global
           if ((Sp + -48) < SpLim) (likely: False) goto udSL8; else goto udSL7;
       udSL8: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cdSJQ() args: 0, res: 0, upd: 0;
       udSL7: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cdSJp() args: 0, res: 0, upd: 0;
     }
 },
 _cdSJp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSJp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdSJT; else goto cdSJS;
       cdSJT: // global
           HpAlloc = 32;
           call _cdSJQ() args: 0, res: 0, upd: 0;
       cdSJS: // global
           _sdSw7::P64 = P64[Sp + 8];
           _sdSwa::I64 = I64[Sp];
           if (_sdSwa::I64 != 0) goto cdSJN; else goto cdSJO;
       cdSJN: // global
           Hp = Hp - 32;
           I64[Sp] = block_cdSJu_info;
           R1 = _sdSw7::P64;
           I64[Sp + 8] = _sdSwa::I64;
           if (R1 & 7 != 0) goto udSLd; else goto cdSJv;
       udSLd: // global
           call _cdSJu(R1) args: 0, res: 0, upd: 0;
       cdSJv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdSJO: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl1_rdSvN_closure+1;
           P64[Hp - 8] = _sdSw7::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdSJQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSJQ: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = Control.Concurrent.QSemN.$wloop_closure;
           Sp = Sp + 24;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdSJu() //  [R1]
         { info_tbl: [(cdSJu,
                       label: block_cdSJu_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSJu: // global
           if (R1 & 7 == 1) goto cdSJW; else goto cdSKi;
       cdSJW: // global
           I64[Sp] = block_cdSJz_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto udSLf; else goto cdSJA;
       udSLf: // global
           call _cdSJz(R1) args: 0, res: 0, upd: 0;
       cdSJA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdSKi: // global
           I64[Sp - 16] = block_cdSKb_info;
           _sdSwb::P64 = R1;
           _sdSwj::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdSwj::P64;
           P64[Sp] = _sdSwb::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udSLg; else goto cdSKc;
       udSLg: // global
           call _cdSKb(R1) args: 0, res: 0, upd: 0;
       cdSKc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSJz() //  [R1]
         { info_tbl: [(cdSJz,
                       label: block_cdSJz_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSJz: // global
           _sdSwa::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cdSK1; else goto cdSK5;
       cdSK1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdSK4; else goto cdSK3;
       cdSK4: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdSK3: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdSwa::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdSK5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdSK8; else goto cdSK7;
       cdSK8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdSK7: // global
           I64[Hp - 16] = sat_sdSwh_info;
           P64[Hp] = R1;
           I64[Sp] = _sdSwa::I64;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = GHC.Types.[]_closure+1;
           call _cdSJp() args: 0, res: 0, upd: 0;
     }
 },
 _cdSKb() //  [R1]
         { info_tbl: [(cdSKb,
                       label: block_cdSKb_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSKb: // global
           I64[Sp - 8] = block_cdSKg_info;
           _sdSwm::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sdSwm::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udSLk; else goto cdSKk;
       udSLk: // global
           call _cdSKg(R1) args: 0, res: 0, upd: 0;
       cdSKk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSKg() //  [R1]
         { info_tbl: [(cdSKg,
                       label: block_cdSKg_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSKg: // global
           _sdSwm::P64 = P64[Sp + 8];
           _sdSwo::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_sdSwo::I64,
                            I64[Sp + 32])) goto cdSKu; else goto cdSKJ;
       cdSKu: // global
           I64[Sp + 8] = block_cdSKs_info;
           R1 = _sdSwm::P64;
           I64[Sp + 24] = _sdSwo::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udSLl; else goto cdSKv;
       udSLl: // global
           call _cdSKs(R1) args: 0, res: 0, upd: 0;
       cdSKv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdSKJ: // global
           I64[Sp + 8] = block_cdSKI_info;
           R1 = _sdSwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udSLm; else goto cdSKK;
       udSLm: // global
           call _cdSKI(R1) args: 0, res: 0, upd: 0;
       cdSKK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSKs() //  [R1]
         { info_tbl: [(cdSKs,
                       label: block_cdSKs_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSKs: // global
           I64[Sp] = block_cdSKz_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[R1 + 7];
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSKz() //  [R1]
         { info_tbl: [(cdSKz,
                       label: block_cdSKz_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSKz: // global
           _sdSw8::P64 = P64[Sp + 32];
           _sdSwa::I64 = I64[Sp + 24];
           _sdSwj::P64 = P64[Sp + 8];
           if (R1 == 0) goto cdSKG; else goto cdSKF;
       cdSKG: // global
           I64[Sp + 16] = _sdSwa::I64;
           P64[Sp + 24] = _sdSwj::P64;
           P64[Sp + 32] = _sdSw8::P64;
           Sp = Sp + 16;
           goto udSLo;
       cdSKF: // global
           I64[Sp + 16] = _sdSwa::I64 - I64[Sp + 16];
           P64[Sp + 24] = _sdSwj::P64;
           P64[Sp + 32] = _sdSw8::P64;
           Sp = Sp + 16;
           goto udSLo;
       udSLo: // global
           call _cdSJp() args: 0, res: 0, upd: 0;
     }
 },
 _cdSKI() //  [R1]
         { info_tbl: [(cdSKI,
                       label: block_cdSKI_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSKI: // global
           I64[Sp] = block_cdSKO_info;
           R1 = P64[R1 + 7];
           call stg_isEmptyMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSKO() //  [R1]
         { info_tbl: [(cdSKO,
                       label: block_cdSKO_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSKO: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdSKT; else goto cdSKS;
       cdSKT: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdSKS: // global
           _sdSw8::P64 = P64[Sp + 32];
           _sdSwa::I64 = I64[Sp + 24];
           if (R1 == 0) goto cdSL0; else goto cdSKZ;
       cdSL0: // global
           Hp = Hp - 48;
           I64[Sp + 16] = _sdSwa::I64;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = _sdSw8::P64;
           Sp = Sp + 16;
           call _cdSJp() args: 0, res: 0, upd: 0;
       cdSKZ: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdSwa::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sdSw8::P64;
           R1 = Hp - 23;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.755535806 UTC

[section ""data" . Control.Concurrent.QSemN.$wsignalQSemN_closure" {
     Control.Concurrent.QSemN.$wsignalQSemN_closure:
         const Control.Concurrent.QSemN.$wsignalQSemN_info;
 },
 sat_sdSx2_entry() //  [R1]
         { info_tbl: [(cdSLI,
                       label: sat_sdSx2_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSLI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdSLW; else goto cdSLX;
       cdSLW: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdSLX: // global
           I64[Sp - 24] = block_cdSLD_info;
           _sdSwG::P64 = P64[R1 + 7];
           _sdSwH::I64 = I64[R1 + 15];
           R1 = _sdSwG::P64;
           P64[Sp - 16] = _sdSwG::P64;
           I64[Sp - 8] = _sdSwH::I64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSLD() //  [R1]
         { info_tbl: [(cdSLD,
                       label: block_cdSLD_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSLD: // global
           I64[Sp] = block_cdSLF_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udSM4; else goto cdSLG;
       udSM4: // global
           call _cdSLF(R1) args: 0, res: 0, upd: 0;
       cdSLG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSLF() //  [R1]
         { info_tbl: [(cdSLF,
                       label: block_cdSLF_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSLF: // global
           I64[Sp - 16] = block_cdSLL_info;
           _sdSwT::P64 = P64[R1 + 15];
           _sdSwU::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdSwU::P64;
           P64[Sp] = _sdSwT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udSM5; else goto cdSLM;
       udSM5: // global
           call _cdSLL(R1) args: 0, res: 0, upd: 0;
       cdSLM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSLL() //  [R1]
         { info_tbl: [(cdSLL,
                       label: block_cdSLL_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSLL: // global
           _sdSwT::P64 = P64[Sp + 16];
           _sdSwX::I64 = I64[Sp + 32] + I64[R1 + 7];
           I64[Sp + 16] = block_cdSLT_info;
           R4 = P64[Sp + 8];
           R3 = _sdSwT::P64;
           R2 = _sdSwX::I64;
           Sp = Sp + 16;
           call Control.Concurrent.QSemN.$wloop_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdSLT() //  [R1]
         { info_tbl: [(cdSLT,
                       label: block_cdSLT_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSLT: // global
           I64[Sp + 16] = block_cdSLV_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSLV() //  []
         { info_tbl: [(cdSLV,
                       label: block_cdSLV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSLV: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSemN.$wsignalQSemN_entry() //  [R2, R3]
         { info_tbl: [(cdSM9,
                       label: Control.Concurrent.QSemN.$wsignalQSemN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSM9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdSMa; else goto cdSMb;
       cdSMa: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.$wsignalQSemN_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdSMb: // global
           I64[Sp - 24] = block_cdSLu_info;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdSLu() //  [R1]
         { info_tbl: [(cdSLu,
                       label: block_cdSLu_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSLu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdSMe; else goto cdSMd;
       cdSMe: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdSMd: // global
           _sdSwG::P64 = P64[Sp + 8];
           if (R1 == 1) goto cdSM8; else goto cdSM7;
       cdSM8: // global
           Hp = Hp - 24;
           I64[Sp] = block_cdSMg_info;
           R1 = _sdSwG::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdSM7: // global
           I64[Hp - 16] = sat_sdSx2_info;
           P64[Hp - 8] = _sdSwG::P64;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdSMg() //  [R1]
         { info_tbl: [(cdSMg,
                       label: block_cdSMg_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSMg: // global
           I64[Sp] = block_cdSMi_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udSME; else goto cdSMj;
       udSME: // global
           call _cdSMi(R1) args: 0, res: 0, upd: 0;
       cdSMj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSMi() //  [R1]
         { info_tbl: [(cdSMi,
                       label: block_cdSMi_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSMi: // global
           I64[Sp - 16] = block_cdSMn_info;
           _sdSx8::P64 = P64[R1 + 15];
           _sdSx9::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdSx9::P64;
           P64[Sp] = _sdSx8::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udSMF; else goto cdSMo;
       udSMF: // global
           call _cdSMn(R1) args: 0, res: 0, upd: 0;
       cdSMo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSMn() //  [R1]
         { info_tbl: [(cdSMn,
                       label: block_cdSMn_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSMn: // global
           _sdSx8::P64 = P64[Sp + 16];
           _sdSxc::I64 = I64[Sp + 32] + I64[R1 + 7];
           I64[Sp + 16] = block_cdSMv_info;
           R4 = P64[Sp + 8];
           R3 = _sdSx8::P64;
           R2 = _sdSxc::I64;
           Sp = Sp + 16;
           call Control.Concurrent.QSemN.$wloop_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdSMv() //  [R1]
         { info_tbl: [(cdSMv,
                       label: block_cdSMv_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSMv: // global
           I64[Sp + 16] = block_cdSMx_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSMx() //  []
         { info_tbl: [(cdSMx,
                       label: block_cdSMx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSMx: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.759141693 UTC

[section ""data" . Control.Concurrent.QSemN.signalQSemN1_closure" {
     Control.Concurrent.QSemN.signalQSemN1_closure:
         const Control.Concurrent.QSemN.signalQSemN1_info;
 },
 Control.Concurrent.QSemN.signalQSemN1_entry() //  [R2, R3]
         { info_tbl: [(cdSMN,
                       label: Control.Concurrent.QSemN.signalQSemN1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSMN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdSMR; else goto cdSMS;
       cdSMR: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.signalQSemN1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdSMS: // global
           I64[Sp - 16] = block_cdSMK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udSN0; else goto cdSML;
       udSN0: // global
           call _cdSMK(R1) args: 0, res: 0, upd: 0;
       cdSML: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSMK() //  [R1]
         { info_tbl: [(cdSMK,
                       label: block_cdSMK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSMK: // global
           I64[Sp] = block_cdSMQ_info;
           _sdSxl::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdSxl::P64;
           if (R1 & 7 != 0) goto udSMZ; else goto cdSMU;
       udSMZ: // global
           call _cdSMQ(R1) args: 0, res: 0, upd: 0;
       cdSMU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSMQ() //  [R1]
         { info_tbl: [(cdSMQ,
                       label: block_cdSMQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSMQ: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Control.Concurrent.QSemN.$wsignalQSemN_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.760536916 UTC

[section ""data" . Control.Concurrent.QSemN.signalQSemN_closure" {
     Control.Concurrent.QSemN.signalQSemN_closure:
         const Control.Concurrent.QSemN.signalQSemN_info;
 },
 Control.Concurrent.QSemN.signalQSemN_entry() //  [R2, R3]
         { info_tbl: [(cdSN5,
                       label: Control.Concurrent.QSemN.signalQSemN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSN5: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.QSemN.signalQSemN1_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.762910903 UTC

[section ""data" . lvl2_rdSvO_closure" {
     lvl2_rdSvO_closure:
         const lvl2_rdSvO_info;
 },
 lvl2_rdSvO_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSN9: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call lvl2_rdSvO_entry(R6,
                                 R5,
                                 R4,
                                 R3,
                                 R2,
                                 R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdSxT_entry() //  [R1]
         { info_tbl: [(cdSNp,
                       label: sat_sdSxT_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSNp: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdSNq; else goto cdSNr;
       cdSNq: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdSNr: // global
           I64[Sp - 32] = block_cdSNk_info;
           _sdSxo::P64 = P64[R1 + 7];
           _sdSxp::P64 = P64[R1 + 15];
           _sdSxq::P64 = P64[R1 + 23];
           R1 = _sdSxo::P64;
           P64[Sp - 24] = _sdSxo::P64;
           P64[Sp - 16] = _sdSxp::P64;
           P64[Sp - 8] = _sdSxq::P64;
           Sp = Sp - 32;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSNk() //  [R1]
         { info_tbl: [(cdSNk,
                       label: block_cdSNk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSNk: // global
           I64[Sp] = block_cdSNm_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udSO8; else goto cdSNn;
       udSO8: // global
           call _cdSNm(R1) args: 0, res: 0, upd: 0;
       cdSNn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSNm() //  [R1]
         { info_tbl: [(cdSNm,
                       label: block_cdSNm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSNm: // global
           I64[Sp - 32] = block_cdSNv_info;
           _sdSxz::P64 = R1;
           _sdSxA::P64 = P64[R1 + 7];
           _sdSxB::P64 = P64[R1 + 15];
           _sdSxC::P64 = P64[R1 + 23];
           R1 = P64[Sp + 24];
           P64[Sp - 24] = _sdSxA::P64;
           P64[Sp - 16] = _sdSxB::P64;
           P64[Sp - 8] = _sdSxC::P64;
           P64[Sp] = _sdSxz::P64;
           Sp = Sp - 32;
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSNv() //  [R1]
         { info_tbl: [(cdSNv,
                       label: block_cdSNv_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSNv: // global
           if (R1 == 0) goto cdSO4; else goto cdSNU;
       cdSO4: // global
           I64[Sp + 24] = block_cdSO1_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 56];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdSNU: // global
           I64[Sp] = block_cdSND_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto udSO9; else goto cdSNE;
       udSO9: // global
           call _cdSND(R1) args: 0, res: 0, upd: 0;
       cdSNE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSO1() //  []
         { info_tbl: [(cdSO1,
                       label: block_cdSO1_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSO1: // global
           I64[Sp + 32] = block_cdSO3_info;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSND() //  [R1]
         { info_tbl: [(cdSND,
                       label: block_cdSND_info
                       rep:StackRep [False, False, False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSND: // global
           _sdSxA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdSNI_info;
           _sdSxJ::I64 = I64[R1 + 7];
           R1 = _sdSxA::P64;
           I64[Sp + 56] = _sdSxJ::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udSOa; else goto cdSNJ;
       udSOa: // global
           call _cdSNI(R1) args: 0, res: 0, upd: 0;
       cdSNJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSNI() //  [R1]
         { info_tbl: [(cdSNI,
                       label: block_cdSNI_info
                       rep:StackRep [False, False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSNI: // global
           _sdSxM::I64 = I64[Sp + 48] + I64[R1 + 7];
           I64[Sp + 24] = block_cdSNQ_info;
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = _sdSxM::I64;
           Sp = Sp + 24;
           call Control.Concurrent.QSemN.$wloop_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdSNQ() //  [R1]
         { info_tbl: [(cdSNQ,
                       label: block_cdSNQ_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSNQ: // global
           I64[Sp + 24] = block_cdSO3_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSO3() //  []
         { info_tbl: [(cdSO3,
                       label: block_cdSO3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSO3: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl2_rdSvO_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdSOe,
                       label: lvl2_rdSvO_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSOe: // global
           _sdSxt::I64 = R6;
           _sdSxs::P64 = R5;
           _sdSxq::P64 = R4;
           _sdSxp::P64 = R3;
           _sdSxo::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto cdSOf; else goto cdSOg;
       cdSOg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdSOi; else goto cdSOh;
       cdSOi: // global
           HpAlloc = 32;
           goto cdSOf;
       cdSOf: // global
           R1 = lvl2_rdSvO_closure;
           P64[Sp - 40] = _sdSxo::P64;
           P64[Sp - 32] = _sdSxp::P64;
           P64[Sp - 24] = _sdSxq::P64;
           P64[Sp - 16] = _sdSxs::P64;
           I64[Sp - 8] = _sdSxt::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cdSOh: // global
           if (_sdSxt::I64 == 1) goto cdSOd; else goto cdSOc;
       cdSOd: // global
           Hp = Hp - 32;
           I64[Sp - 40] = block_cdSOn_info;
           R1 = _sdSxo::P64;
           P64[Sp - 32] = _sdSxo::P64;
           P64[Sp - 24] = _sdSxp::P64;
           P64[Sp - 16] = _sdSxq::P64;
           P64[Sp - 8] = _sdSxs::P64;
           Sp = Sp - 40;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdSOc: // global
           I64[Hp - 24] = sat_sdSxT_info;
           P64[Hp - 16] = _sdSxo::P64;
           P64[Hp - 8] = _sdSxp::P64;
           P64[Hp] = _sdSxq::P64;
           I64[Sp - 16] = block_cdSOj_info;
           R1 = Hp - 23;
           P64[Sp - 8] = _sdSxs::P64;
           Sp = Sp - 16;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSOn() //  [R1]
         { info_tbl: [(cdSOn,
                       label: block_cdSOn_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSOn: // global
           I64[Sp] = block_cdSOp_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udSP8; else goto cdSOr;
       udSP8: // global
           call _cdSOp(R1) args: 0, res: 0, upd: 0;
       cdSOr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSOp() //  [R1]
         { info_tbl: [(cdSOp,
                       label: block_cdSOp_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSOp: // global
           I64[Sp - 32] = block_cdSOv_info;
           _sdSy0::P64 = R1;
           _sdSy1::P64 = P64[R1 + 7];
           _sdSy2::P64 = P64[R1 + 15];
           _sdSy3::P64 = P64[R1 + 23];
           R1 = P64[Sp + 24];
           P64[Sp - 24] = _sdSy1::P64;
           P64[Sp - 16] = _sdSy2::P64;
           P64[Sp - 8] = _sdSy3::P64;
           P64[Sp] = _sdSy0::P64;
           Sp = Sp - 32;
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSOv() //  [R1]
         { info_tbl: [(cdSOv,
                       label: block_cdSOv_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSOv: // global
           if (R1 == 0) goto cdSP4; else goto cdSOU;
       cdSP4: // global
           I64[Sp + 24] = block_cdSP1_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 56];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdSOU: // global
           I64[Sp] = block_cdSOD_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto udSP9; else goto cdSOE;
       udSP9: // global
           call _cdSOD(R1) args: 0, res: 0, upd: 0;
       cdSOE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSP1() //  []
         { info_tbl: [(cdSP1,
                       label: block_cdSP1_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSP1: // global
           I64[Sp + 32] = block_cdSP3_info;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSOD() //  [R1]
         { info_tbl: [(cdSOD,
                       label: block_cdSOD_info
                       rep:StackRep [False, False, False, True, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSOD: // global
           _sdSy1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdSOI_info;
           _sdSya::I64 = I64[R1 + 7];
           R1 = _sdSy1::P64;
           I64[Sp + 56] = _sdSya::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udSPa; else goto cdSOJ;
       udSPa: // global
           call _cdSOI(R1) args: 0, res: 0, upd: 0;
       cdSOJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSOI() //  [R1]
         { info_tbl: [(cdSOI,
                       label: block_cdSOI_info
                       rep:StackRep [False, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSOI: // global
           _sdSyd::I64 = I64[Sp + 48] + I64[R1 + 7];
           I64[Sp + 24] = block_cdSOQ_info;
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = _sdSyd::I64;
           Sp = Sp + 24;
           call Control.Concurrent.QSemN.$wloop_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdSOQ() //  [R1]
         { info_tbl: [(cdSOQ,
                       label: block_cdSOQ_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSOQ: // global
           I64[Sp + 24] = block_cdSP3_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSP3() //  []
         { info_tbl: [(cdSP3,
                       label: block_cdSP3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSP3: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdSOj() //  []
         { info_tbl: [(cdSOj,
                       label: block_cdSOj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSOj: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.768046424 UTC

[section ""data" . Control.Concurrent.QSemN.$wlvl_closure" {
     Control.Concurrent.QSemN.$wlvl_closure:
         const Control.Concurrent.QSemN.$wlvl_info;
 },
 Control.Concurrent.QSemN.$wlvl_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdSPh,
                       label: Control.Concurrent.QSemN.$wlvl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSPh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdSPi; else goto cdSPj;
       cdSPi: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.$wlvl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdSPj: // global
           I64[Sp - 40] = block_cdSPf_info;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdSPf() //  [R1]
         { info_tbl: [(cdSPf,
                       label: block_cdSPf_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSPf: // global
           R6 = R1;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           Sp = Sp + 40;
           call lvl2_rdSvO_entry(R6, R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.771053298 UTC

[section ""data" . Control.Concurrent.QSemN.$wwaitQSemN_closure" {
     Control.Concurrent.QSemN.$wwaitQSemN_closure:
         const Control.Concurrent.QSemN.$wwaitQSemN_info;
 },
 sat_sdSz1_entry() //  [R1, R2]
         { info_tbl: [(cdSQ3,
                       label: sat_sdSz1_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSQ3: // global
           R5 = R2;
           R4 = P64[R1 + 6];
           R3 = P64[R1 + 22];
           R2 = P64[R1 + 14];
           call Control.Concurrent.QSemN.$wlvl_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdSyY_entry() //  [R1]
         { info_tbl: [(cdSQb,
                       label: sat_sdSyY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSQb: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sdSyy_entry() //  [R1]
         { info_tbl: [(cdSQe,
                       label: io_sdSyy_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSQe: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdSQf; else goto cdSQg;
       cdSQf: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdSQg: // global
           I64[Sp - 24] = block_cdSPw_info;
           _sdSys::P64 = P64[R1 + 7];
           _sdSyt::I64 = I64[R1 + 15];
           R1 = _sdSys::P64;
           P64[Sp - 16] = _sdSys::P64;
           I64[Sp - 8] = _sdSyt::I64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSPw() //  [R1]
         { info_tbl: [(cdSPw,
                       label: block_cdSPw_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSPw: // global
           I64[Sp] = block_cdSPy_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udSQA; else goto cdSPz;
       udSQA: // global
           call _cdSPy(R1) args: 0, res: 0, upd: 0;
       cdSPz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSPy() //  [R1]
         { info_tbl: [(cdSPy,
                       label: block_cdSPy_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSPy: // global
           I64[Sp - 16] = block_cdSPD_info;
           _sdSyF::P64 = P64[R1 + 15];
           _sdSyG::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdSyG::P64;
           P64[Sp] = _sdSyF::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udSQB; else goto cdSPE;
       udSQB: // global
           call _cdSPD(R1) args: 0, res: 0, upd: 0;
       cdSPE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSPD() //  [R1]
         { info_tbl: [(cdSPD,
                       label: block_cdSPD_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSPD: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdSQl; else goto cdSQk;
       cdSQl: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdSQk: // global
           _sdSyJ::I64 = I64[R1 + 7] - I64[Sp + 32];
           if (%MO_S_Ge_W64(_sdSyJ::I64, 0)) goto cdSQq; else goto cdSQt;
       cdSQq: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdSyJ::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 32] = block_cdSQo_info;
           R2 = Hp - 23;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdSQt: // global
           Hp = Hp - 48;
           I64[Sp - 8] = block_cdSPP_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdSQo() //  []
         { info_tbl: [(cdSQo,
                       label: block_cdSQo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSQo: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdSPP() //  [R1]
         { info_tbl: [(cdSPP,
                       label: block_cdSPP_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSPP: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdSQw; else goto cdSQv;
       cdSQw: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdSQv: // global
           I64[Hp - 104] = GHC.Types.I#_con_info;
           I64[Hp - 96] = I64[Sp + 40];
           I64[Hp - 88] = GHC.MVar.MVar_con_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = (,)_con_info;
           _cdSPR::P64 = Hp - 103;
           P64[Hp - 64] = _cdSPR::P64;
           P64[Hp - 56] = Hp - 87;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 71;
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = Hp - 46;
           I64[Sp + 16] = block_cdSPW_info;
           R2 = Hp - 23;
           _sdSyQ::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 24] = _sdSyQ::P64;
           P64[Sp + 40] = _cdSPR::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSPW() //  []
         { info_tbl: [(cdSPW,
                       label: block_cdSPW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSPW: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdSQz; else goto cdSQy;
       cdSQz: // global
           HpAlloc = 48;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdSQy: // global
           I64[Hp - 40] = sat_sdSz1_info;
           P64[Hp - 32] = P64[Sp + 16];
           _sdSyQ::P64 = P64[Sp + 8];
           P64[Hp - 24] = _sdSyQ::P64;
           P64[Hp - 16] = P64[Sp + 24];
           I64[Hp - 8] = sat_sdSyY_info;
           P64[Hp] = _sdSyQ::P64;
           R2 = Hp - 38;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSemN.$wwaitQSemN_entry() //  [R2, R3]
         { info_tbl: [(cdSQG,
                       label: Control.Concurrent.QSemN.$wwaitQSemN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSQG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdSQH; else goto cdSQI;
       cdSQH: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.$wwaitQSemN_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdSQI: // global
           I64[Sp - 24] = block_cdSPp_info;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdSPp() //  [R1]
         { info_tbl: [(cdSPp,
                       label: block_cdSPp_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSPp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdSQL; else goto cdSQK;
       cdSQL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdSQK: // global
           I64[Hp - 16] = io_sdSyy_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           _cdSPr::P64 = Hp - 15;
           if (R1 == 0) goto cdSQF; else goto cdSQE;
       cdSQF: // global
           R1 = _cdSPr::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cdSQE: // global
           R1 = _cdSPr::P64;
           Sp = Sp + 24;
           call io_sdSyy_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.775141314 UTC

[section ""data" . Control.Concurrent.QSemN.waitQSemN1_closure" {
     Control.Concurrent.QSemN.waitQSemN1_closure:
         const Control.Concurrent.QSemN.waitQSemN1_info;
 },
 Control.Concurrent.QSemN.waitQSemN1_entry() //  [R2, R3]
         { info_tbl: [(cdSQT,
                       label: Control.Concurrent.QSemN.waitQSemN1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSQT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdSQX; else goto cdSQY;
       cdSQX: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.waitQSemN1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdSQY: // global
           I64[Sp - 16] = block_cdSQQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udSR6; else goto cdSQR;
       udSR6: // global
           call _cdSQQ(R1) args: 0, res: 0, upd: 0;
       cdSQR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSQQ() //  [R1]
         { info_tbl: [(cdSQQ,
                       label: block_cdSQQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSQQ: // global
           I64[Sp] = block_cdSQW_info;
           _sdSz7::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdSz7::P64;
           if (R1 & 7 != 0) goto udSR5; else goto cdSR0;
       udSR5: // global
           call _cdSQW(R1) args: 0, res: 0, upd: 0;
       cdSR0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSQW() //  [R1]
         { info_tbl: [(cdSQW,
                       label: block_cdSQW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSQW: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Control.Concurrent.QSemN.$wwaitQSemN_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.776600453 UTC

[section ""data" . Control.Concurrent.QSemN.waitQSemN_closure" {
     Control.Concurrent.QSemN.waitQSemN_closure:
         const Control.Concurrent.QSemN.waitQSemN_info;
 },
 Control.Concurrent.QSemN.waitQSemN_entry() //  [R2, R3]
         { info_tbl: [(cdSRb,
                       label: Control.Concurrent.QSemN.waitQSemN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSRb: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.QSemN.waitQSemN1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.777547851 UTC

[section ""data" . Control.Concurrent.QSemN.QSemN_closure" {
     Control.Concurrent.QSemN.QSemN_closure:
         const Control.Concurrent.QSemN.QSemN_info;
 },
 Control.Concurrent.QSemN.QSemN_entry() //  [R2]
         { info_tbl: [(cdSRj,
                       label: Control.Concurrent.QSemN.QSemN_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSRj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdSRn; else goto cdSRm;
       cdSRn: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.QSemN_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdSRm: // global
           I64[Hp - 8] = Control.Concurrent.QSemN.QSemN_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.778430908 UTC

[Control.Concurrent.QSemN.QSemN_con_entry() //  [R1]
         { info_tbl: [(cdSRo,
                       label: Control.Concurrent.QSemN.QSemN_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,81,83,101,109,78,46,81,83,101,109,78]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSRo: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.779157927 UTC

[section ""relreadonly" . SdSzD_srt" {
     SdSzD_srt:
         const GHC.IO.failIO1_closure;
         const Control.Concurrent.QSemN.newQSemN2_closure;
         const Control.Concurrent.QSemN.newQSemN1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.780030994 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:07.792543311 UTC

[section ""data" . Control.Concurrent.QSemN.$WQSemN_closure" {
     Control.Concurrent.QSemN.$WQSemN_closure:
         const Control.Concurrent.QSemN.$WQSemN_info;
 },
 Control.Concurrent.QSemN.$WQSemN_entry() //  [R2]
         { info_tbl: [(cdSRx,
                       label: Control.Concurrent.QSemN.$WQSemN_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSRx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdSRB; else goto cdSRC;
       cdSRB: // global
           R2 = R2;
           R1 = Control.Concurrent.QSemN.$WQSemN_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdSRC: // global
           I64[Sp - 8] = block_cdSRu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udSRG; else goto cdSRv;
       udSRG: // global
           call _cdSRu(R1) args: 0, res: 0, upd: 0;
       cdSRv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSRu() //  [R1]
         { info_tbl: [(cdSRu,
                       label: block_cdSRu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSRu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdSRF; else goto cdSRE;
       cdSRF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdSRE: // global
           _sdSvS::P64 = P64[R1 + 7];
           I64[Hp - 8] = Control.Concurrent.QSemN.QSemN_con_info;
           P64[Hp] = _sdSvS::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.801909718 UTC

[section ""cstring" . Control.Concurrent.QSemN.$trModule4_bytes" {
     Control.Concurrent.QSemN.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.804607614 UTC

[section ""data" . Control.Concurrent.QSemN.$trModule3_closure" {
     Control.Concurrent.QSemN.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSemN.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.807399285 UTC

[section ""cstring" . Control.Concurrent.QSemN.$trModule2_bytes" {
     Control.Concurrent.QSemN.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,81,83,101,109,78]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.810089319 UTC

[section ""data" . Control.Concurrent.QSemN.$trModule1_closure" {
     Control.Concurrent.QSemN.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSemN.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.812266173 UTC

[section ""data" . Control.Concurrent.QSemN.$trModule_closure" {
     Control.Concurrent.QSemN.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.QSemN.$trModule3_closure+1;
         const Control.Concurrent.QSemN.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.814414077 UTC

[section ""data" . $krep_rdSvw_closure" {
     $krep_rdSvw_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.816453264 UTC

[section ""data" . $krep1_rdSvx_closure" {
     $krep1_rdSvx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.820224039 UTC

[section ""data" . $krep2_rdSvy_closure" {
     $krep2_rdSvy_closure:
         const :_con_info;
         const $krep_rdSvw_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.822287724 UTC

[section ""data" . $krep3_rdSvz_closure" {
     $krep3_rdSvz_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep2_rdSvy_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.824099759 UTC

[section ""data" . $krep4_rdSvA_closure" {
     $krep4_rdSvA_closure:
         const :_con_info;
         const $krep3_rdSvz_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.826386655 UTC

[section ""data" . $krep5_rdSvB_closure" {
     $krep5_rdSvB_closure:
         const :_con_info;
         const $krep1_rdSvx_closure+1;
         const $krep4_rdSvA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.828256783 UTC

[section ""data" . $krep6_rdSvC_closure" {
     $krep6_rdSvC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep5_rdSvB_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.830283284 UTC

[section ""data" . $krep7_rdSvD_closure" {
     $krep7_rdSvD_closure:
         const :_con_info;
         const $krep6_rdSvC_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.832302422 UTC

[section ""data" . $krep8_rdSvE_closure" {
     $krep8_rdSvE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep7_rdSvD_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.834314815 UTC

[section ""data" . $krep9_rdSvF_closure" {
     $krep9_rdSvF_closure:
         const :_con_info;
         const $krep8_rdSvE_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.836286617 UTC

[section ""data" . $krep10_rdSvG_closure" {
     $krep10_rdSvG_closure:
         const :_con_info;
         const $krep8_rdSvE_closure+1;
         const $krep9_rdSvF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.838192668 UTC

[section ""data" . $krep11_rdSvH_closure" {
     $krep11_rdSvH_closure:
         const :_con_info;
         const $krep1_rdSvx_closure+1;
         const $krep10_rdSvG_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.840085856 UTC

[section ""data" . $krep12_rdSvI_closure" {
     $krep12_rdSvI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,,)_closure;
         const $krep11_rdSvH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.842404993 UTC

[section ""data" . $krep13_rdSvJ_closure" {
     $krep13_rdSvJ_closure:
         const :_con_info;
         const $krep12_rdSvI_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.844449757 UTC

[section ""data" . $krep14_rdSvK_closure" {
     $krep14_rdSvK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep13_rdSvJ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.846512947 UTC

[section ""cstring" . Control.Concurrent.QSemN.$tcQSemN2_bytes" {
     Control.Concurrent.QSemN.$tcQSemN2_bytes:
         I8[] [81,83,101,109,78]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.849487412 UTC

[section ""data" . Control.Concurrent.QSemN.$tcQSemN1_closure" {
     Control.Concurrent.QSemN.$tcQSemN1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSemN.$tcQSemN2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.853113986 UTC

[section ""data" . Control.Concurrent.QSemN.$tcQSemN_closure" {
     Control.Concurrent.QSemN.$tcQSemN_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.QSemN.$trModule_closure+1;
         const Control.Concurrent.QSemN.$tcQSemN1_closure+1;
         const GHC.Types.krep$*_closure;
         const 8650881979471817661;
         const 11033619023634057930;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.856135751 UTC

[section ""data" . $krep15_rdSvL_closure" {
     $krep15_rdSvL_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Concurrent.QSemN.$tcQSemN_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.858850521 UTC

[section ""data" . Control.Concurrent.QSemN.$tc'QSemN1_closure" {
     Control.Concurrent.QSemN.$tc'QSemN1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_rdSvK_closure+1;
         const $krep15_rdSvL_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.861129657 UTC

[section ""cstring" . Control.Concurrent.QSemN.$tc'QSemN3_bytes" {
     Control.Concurrent.QSemN.$tc'QSemN3_bytes:
         I8[] [39,81,83,101,109,78]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.863512597 UTC

[section ""data" . Control.Concurrent.QSemN.$tc'QSemN2_closure" {
     Control.Concurrent.QSemN.$tc'QSemN2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSemN.$tc'QSemN3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.865530721 UTC

[section ""data" . Control.Concurrent.QSemN.$tc'QSemN_closure" {
     Control.Concurrent.QSemN.$tc'QSemN_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.QSemN.$trModule_closure+1;
         const Control.Concurrent.QSemN.$tc'QSemN2_closure+1;
         const Control.Concurrent.QSemN.$tc'QSemN1_closure+4;
         const 15878277071781304355;
         const 273080421945023395;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.867631225 UTC

[section ""cstring" . lvl_rdSvM_bytes" {
     lvl_rdSvM_bytes:
         I8[] [110,101,119,81,83,101,109,78,58,32,73,110,105,116,105,97,108,32,113,117,97,110,116,105,116,121,32,109,117,115,116,32,98,101,32,110,111,110,45,110,101,103,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.869979352 UTC

[section ""data" . Control.Concurrent.QSemN.newQSemN2_closure" {
     Control.Concurrent.QSemN.newQSemN2_closure:
         const Control.Concurrent.QSemN.newQSemN2_info;
         const 0;
 },
 Control.Concurrent.QSemN.newQSemN2_entry() //  []
         { info_tbl: [(cdSSq,
                       label: Control.Concurrent.QSemN.newQSemN2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSSq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdSSr; else goto cdSSs;
       cdSSr: // global
           R1 = Control.Concurrent.QSemN.newQSemN2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdSSs: // global
           I64[Sp - 8] = block_cdSSo_info;
           R2 = lvl_rdSvM_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdSSo() //  [R1]
         { info_tbl: [(cdSSo,
                       label: block_cdSSo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSSo: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.877453403 UTC

[section ""data" . Control.Concurrent.QSemN.newQSemN1_closure" {
     Control.Concurrent.QSemN.newQSemN1_closure:
         const Control.Concurrent.QSemN.newQSemN1_info;
         const 0;
 },
 Control.Concurrent.QSemN.newQSemN1_entry() //  [R2]
         { info_tbl: [(cdSSL,
                       label: Control.Concurrent.QSemN.newQSemN1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSSL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdSSM; else goto cdSSN;
       cdSSM: // global
           R2 = R2;
           R1 = Control.Concurrent.QSemN.newQSemN1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdSSN: // global
           I64[Sp - 8] = block_cdSSI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udST9; else goto cdSSJ;
       udST9: // global
           call _cdSSI(R1) args: 0, res: 0, upd: 0;
       cdSSJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSSI() //  [R1]
         { info_tbl: [(cdSSI,
                       label: block_cdSSI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSSI: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto cdST1; else goto cdST8;
       cdST1: // global
           I64[Sp - 8] = block_cdSSU_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
       cdST8: // global
           Sp = Sp + 8;
           call Control.Concurrent.QSemN.newQSemN2_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cdSSU() //  [R1]
         { info_tbl: [(cdSSU,
                       label: block_cdSSU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSSU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdST4; else goto cdST3;
       cdST4: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdST3: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp] = block_cdSSX_info;
           R2 = Hp - 23;
           _sdSw2::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _sdSw2::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSSX() //  []
         { info_tbl: [(cdSSX,
                       label: block_cdSSX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSSX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdST7; else goto cdST6;
       cdST7: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdST6: // global
           I64[Hp - 8] = Control.Concurrent.QSemN.QSemN_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.88970917 UTC

[section ""data" . Control.Concurrent.QSemN.newQSemN_closure" {
     Control.Concurrent.QSemN.newQSemN_closure:
         const Control.Concurrent.QSemN.newQSemN_info;
         const 0;
 },
 Control.Concurrent.QSemN.newQSemN_entry() //  [R2]
         { info_tbl: [(cdSTw,
                       label: Control.Concurrent.QSemN.newQSemN_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSTw: // global
           R2 = R2;
           call Control.Concurrent.QSemN.newQSemN1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.893840911 UTC

[section ""data" . lvl1_rdSvN_closure" {
     lvl1_rdSvN_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.897571168 UTC

[section ""data" . Control.Concurrent.QSemN.$wloop_closure" {
     Control.Concurrent.QSemN.$wloop_closure:
         const Control.Concurrent.QSemN.$wloop_info;
 },
 sat_sdSwh_entry() //  [R1]
         { info_tbl: [(cdSTZ,
                       label: sat_sdSwh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSTZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdSU0; else goto cdSU1;
       cdSU0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdSU1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse1_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Concurrent.QSemN.$wloop_entry() //  [R2, R3, R4]
         { info_tbl: [(cdSU5,
                       label: Control.Concurrent.QSemN.$wloop_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSU5: // global
           if ((Sp + -48) < SpLim) (likely: False) goto udSVo; else goto udSVn;
       udSVo: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cdSU6() args: 0, res: 0, upd: 0;
       udSVn: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cdSTF() args: 0, res: 0, upd: 0;
     }
 },
 _cdSTF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSTF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdSU9; else goto cdSU8;
       cdSU9: // global
           HpAlloc = 32;
           call _cdSU6() args: 0, res: 0, upd: 0;
       cdSU8: // global
           _sdSw7::P64 = P64[Sp + 8];
           _sdSwa::I64 = I64[Sp];
           if (_sdSwa::I64 != 0) goto cdSU3; else goto cdSU4;
       cdSU3: // global
           Hp = Hp - 32;
           I64[Sp] = block_cdSTK_info;
           R1 = _sdSw7::P64;
           I64[Sp + 8] = _sdSwa::I64;
           if (R1 & 7 != 0) goto udSVt; else goto cdSTL;
       udSVt: // global
           call _cdSTK(R1) args: 0, res: 0, upd: 0;
       cdSTL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdSU4: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl1_rdSvN_closure+1;
           P64[Hp - 8] = _sdSw7::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdSU6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSU6: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = Control.Concurrent.QSemN.$wloop_closure;
           Sp = Sp + 24;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdSTK() //  [R1]
         { info_tbl: [(cdSTK,
                       label: block_cdSTK_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSTK: // global
           if (R1 & 7 == 1) goto cdSUc; else goto cdSUy;
       cdSUc: // global
           I64[Sp] = block_cdSTP_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto udSVv; else goto cdSTQ;
       udSVv: // global
           call _cdSTP(R1) args: 0, res: 0, upd: 0;
       cdSTQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdSUy: // global
           I64[Sp - 16] = block_cdSUr_info;
           _sdSwb::P64 = R1;
           _sdSwj::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdSwj::P64;
           P64[Sp] = _sdSwb::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udSVw; else goto cdSUs;
       udSVw: // global
           call _cdSUr(R1) args: 0, res: 0, upd: 0;
       cdSUs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSTP() //  [R1]
         { info_tbl: [(cdSTP,
                       label: block_cdSTP_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSTP: // global
           _sdSwa::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cdSUh; else goto cdSUl;
       cdSUh: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdSUk; else goto cdSUj;
       cdSUk: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdSUj: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdSwa::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdSUl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdSUo; else goto cdSUn;
       cdSUo: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdSUn: // global
           I64[Hp - 16] = sat_sdSwh_info;
           P64[Hp] = R1;
           I64[Sp] = _sdSwa::I64;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = GHC.Types.[]_closure+1;
           call _cdSTF() args: 0, res: 0, upd: 0;
     }
 },
 _cdSUr() //  [R1]
         { info_tbl: [(cdSUr,
                       label: block_cdSUr_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSUr: // global
           I64[Sp - 8] = block_cdSUw_info;
           _sdSwm::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sdSwm::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udSVA; else goto cdSUA;
       udSVA: // global
           call _cdSUw(R1) args: 0, res: 0, upd: 0;
       cdSUA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSUw() //  [R1]
         { info_tbl: [(cdSUw,
                       label: block_cdSUw_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSUw: // global
           _sdSwm::P64 = P64[Sp + 8];
           _sdSwo::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_sdSwo::I64,
                            I64[Sp + 32])) goto cdSUK; else goto cdSUZ;
       cdSUK: // global
           I64[Sp + 8] = block_cdSUI_info;
           R1 = _sdSwm::P64;
           I64[Sp + 24] = _sdSwo::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udSVB; else goto cdSUL;
       udSVB: // global
           call _cdSUI(R1) args: 0, res: 0, upd: 0;
       cdSUL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdSUZ: // global
           I64[Sp + 8] = block_cdSUY_info;
           R1 = _sdSwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udSVC; else goto cdSV0;
       udSVC: // global
           call _cdSUY(R1) args: 0, res: 0, upd: 0;
       cdSV0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSUI() //  [R1]
         { info_tbl: [(cdSUI,
                       label: block_cdSUI_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSUI: // global
           I64[Sp] = block_cdSUP_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[R1 + 7];
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSUP() //  [R1]
         { info_tbl: [(cdSUP,
                       label: block_cdSUP_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSUP: // global
           _sdSw8::P64 = P64[Sp + 32];
           _sdSwa::I64 = I64[Sp + 24];
           _sdSwj::P64 = P64[Sp + 8];
           if (R1 == 0) goto cdSUW; else goto cdSUV;
       cdSUW: // global
           I64[Sp + 16] = _sdSwa::I64;
           P64[Sp + 24] = _sdSwj::P64;
           P64[Sp + 32] = _sdSw8::P64;
           Sp = Sp + 16;
           goto udSVE;
       cdSUV: // global
           I64[Sp + 16] = _sdSwa::I64 - I64[Sp + 16];
           P64[Sp + 24] = _sdSwj::P64;
           P64[Sp + 32] = _sdSw8::P64;
           Sp = Sp + 16;
           goto udSVE;
       udSVE: // global
           call _cdSTF() args: 0, res: 0, upd: 0;
     }
 },
 _cdSUY() //  [R1]
         { info_tbl: [(cdSUY,
                       label: block_cdSUY_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSUY: // global
           I64[Sp] = block_cdSV4_info;
           R1 = P64[R1 + 7];
           call stg_isEmptyMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSV4() //  [R1]
         { info_tbl: [(cdSV4,
                       label: block_cdSV4_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSV4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdSV9; else goto cdSV8;
       cdSV9: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdSV8: // global
           _sdSw8::P64 = P64[Sp + 32];
           _sdSwa::I64 = I64[Sp + 24];
           if (R1 == 0) goto cdSVg; else goto cdSVf;
       cdSVg: // global
           Hp = Hp - 48;
           I64[Sp + 16] = _sdSwa::I64;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = _sdSw8::P64;
           Sp = Sp + 16;
           call _cdSTF() args: 0, res: 0, upd: 0;
       cdSVf: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdSwa::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sdSw8::P64;
           R1 = Hp - 23;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.927327259 UTC

[section ""data" . Control.Concurrent.QSemN.$wsignalQSemN_closure" {
     Control.Concurrent.QSemN.$wsignalQSemN_closure:
         const Control.Concurrent.QSemN.$wsignalQSemN_info;
 },
 sat_sdSx2_entry() //  [R1]
         { info_tbl: [(cdSWU,
                       label: sat_sdSx2_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSWU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdSX8; else goto cdSX9;
       cdSX8: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdSX9: // global
           I64[Sp - 24] = block_cdSWP_info;
           _sdSwG::P64 = P64[R1 + 7];
           _sdSwH::I64 = I64[R1 + 15];
           R1 = _sdSwG::P64;
           P64[Sp - 16] = _sdSwG::P64;
           I64[Sp - 8] = _sdSwH::I64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSWP() //  [R1]
         { info_tbl: [(cdSWP,
                       label: block_cdSWP_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSWP: // global
           I64[Sp] = block_cdSWR_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udSXg; else goto cdSWS;
       udSXg: // global
           call _cdSWR(R1) args: 0, res: 0, upd: 0;
       cdSWS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSWR() //  [R1]
         { info_tbl: [(cdSWR,
                       label: block_cdSWR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSWR: // global
           I64[Sp - 16] = block_cdSWX_info;
           _sdSwT::P64 = P64[R1 + 15];
           _sdSwU::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdSwU::P64;
           P64[Sp] = _sdSwT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udSXh; else goto cdSWY;
       udSXh: // global
           call _cdSWX(R1) args: 0, res: 0, upd: 0;
       cdSWY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSWX() //  [R1]
         { info_tbl: [(cdSWX,
                       label: block_cdSWX_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSWX: // global
           _sdSwT::P64 = P64[Sp + 16];
           _sdSwX::I64 = I64[Sp + 32] + I64[R1 + 7];
           I64[Sp + 16] = block_cdSX5_info;
           R4 = P64[Sp + 8];
           R3 = _sdSwT::P64;
           R2 = _sdSwX::I64;
           Sp = Sp + 16;
           call Control.Concurrent.QSemN.$wloop_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdSX5() //  [R1]
         { info_tbl: [(cdSX5,
                       label: block_cdSX5_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSX5: // global
           I64[Sp + 16] = block_cdSX7_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSX7() //  []
         { info_tbl: [(cdSX7,
                       label: block_cdSX7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSX7: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSemN.$wsignalQSemN_entry() //  [R2, R3]
         { info_tbl: [(cdSXl,
                       label: Control.Concurrent.QSemN.$wsignalQSemN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSXl: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdSXm; else goto cdSXn;
       cdSXm: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.$wsignalQSemN_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdSXn: // global
           I64[Sp - 24] = block_cdSWG_info;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdSWG() //  [R1]
         { info_tbl: [(cdSWG,
                       label: block_cdSWG_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSWG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdSXq; else goto cdSXp;
       cdSXq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdSXp: // global
           _sdSwG::P64 = P64[Sp + 8];
           if (R1 == 1) goto cdSXk; else goto cdSXj;
       cdSXk: // global
           Hp = Hp - 24;
           I64[Sp] = block_cdSXs_info;
           R1 = _sdSwG::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdSXj: // global
           I64[Hp - 16] = sat_sdSx2_info;
           P64[Hp - 8] = _sdSwG::P64;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdSXs() //  [R1]
         { info_tbl: [(cdSXs,
                       label: block_cdSXs_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSXs: // global
           I64[Sp] = block_cdSXu_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udSXQ; else goto cdSXv;
       udSXQ: // global
           call _cdSXu(R1) args: 0, res: 0, upd: 0;
       cdSXv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSXu() //  [R1]
         { info_tbl: [(cdSXu,
                       label: block_cdSXu_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSXu: // global
           I64[Sp - 16] = block_cdSXz_info;
           _sdSx8::P64 = P64[R1 + 15];
           _sdSx9::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdSx9::P64;
           P64[Sp] = _sdSx8::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udSXR; else goto cdSXA;
       udSXR: // global
           call _cdSXz(R1) args: 0, res: 0, upd: 0;
       cdSXA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSXz() //  [R1]
         { info_tbl: [(cdSXz,
                       label: block_cdSXz_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSXz: // global
           _sdSx8::P64 = P64[Sp + 16];
           _sdSxc::I64 = I64[Sp + 32] + I64[R1 + 7];
           I64[Sp + 16] = block_cdSXH_info;
           R4 = P64[Sp + 8];
           R3 = _sdSx8::P64;
           R2 = _sdSxc::I64;
           Sp = Sp + 16;
           call Control.Concurrent.QSemN.$wloop_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdSXH() //  [R1]
         { info_tbl: [(cdSXH,
                       label: block_cdSXH_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSXH: // global
           I64[Sp + 16] = block_cdSXJ_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSXJ() //  []
         { info_tbl: [(cdSXJ,
                       label: block_cdSXJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSXJ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.960607508 UTC

[section ""data" . Control.Concurrent.QSemN.signalQSemN1_closure" {
     Control.Concurrent.QSemN.signalQSemN1_closure:
         const Control.Concurrent.QSemN.signalQSemN1_info;
 },
 Control.Concurrent.QSemN.signalQSemN1_entry() //  [R2, R3]
         { info_tbl: [(cdSYQ,
                       label: Control.Concurrent.QSemN.signalQSemN1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSYQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdSYU; else goto cdSYV;
       cdSYU: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.signalQSemN1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdSYV: // global
           I64[Sp - 16] = block_cdSYN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udSZ3; else goto cdSYO;
       udSZ3: // global
           call _cdSYN(R1) args: 0, res: 0, upd: 0;
       cdSYO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSYN() //  [R1]
         { info_tbl: [(cdSYN,
                       label: block_cdSYN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSYN: // global
           I64[Sp] = block_cdSYT_info;
           _sdSxl::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdSxl::P64;
           if (R1 & 7 != 0) goto udSZ2; else goto cdSYX;
       udSZ2: // global
           call _cdSYT(R1) args: 0, res: 0, upd: 0;
       cdSYX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSYT() //  [R1]
         { info_tbl: [(cdSYT,
                       label: block_cdSYT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSYT: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Control.Concurrent.QSemN.$wsignalQSemN_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.968709377 UTC

[section ""data" . Control.Concurrent.QSemN.signalQSemN_closure" {
     Control.Concurrent.QSemN.signalQSemN_closure:
         const Control.Concurrent.QSemN.signalQSemN_info;
 },
 Control.Concurrent.QSemN.signalQSemN_entry() //  [R2, R3]
         { info_tbl: [(cdSZl,
                       label: Control.Concurrent.QSemN.signalQSemN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSZl: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.QSemN.signalQSemN1_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.980615391 UTC

[section ""data" . lvl2_rdSvO_closure" {
     lvl2_rdSvO_closure:
         const lvl2_rdSvO_info;
 },
 lvl2_rdSvO_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSZt: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call lvl2_rdSvO_entry(R6,
                                 R5,
                                 R4,
                                 R3,
                                 R2,
                                 R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdSxT_entry() //  [R1]
         { info_tbl: [(cdSZJ,
                       label: sat_sdSxT_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSZJ: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdSZK; else goto cdSZL;
       cdSZK: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdSZL: // global
           I64[Sp - 32] = block_cdSZE_info;
           _sdSxo::P64 = P64[R1 + 7];
           _sdSxp::P64 = P64[R1 + 15];
           _sdSxq::P64 = P64[R1 + 23];
           R1 = _sdSxo::P64;
           P64[Sp - 24] = _sdSxo::P64;
           P64[Sp - 16] = _sdSxp::P64;
           P64[Sp - 8] = _sdSxq::P64;
           Sp = Sp - 32;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSZE() //  [R1]
         { info_tbl: [(cdSZE,
                       label: block_cdSZE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSZE: // global
           I64[Sp] = block_cdSZG_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udT0s; else goto cdSZH;
       udT0s: // global
           call _cdSZG(R1) args: 0, res: 0, upd: 0;
       cdSZH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSZG() //  [R1]
         { info_tbl: [(cdSZG,
                       label: block_cdSZG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSZG: // global
           I64[Sp - 32] = block_cdSZP_info;
           _sdSxz::P64 = R1;
           _sdSxA::P64 = P64[R1 + 7];
           _sdSxB::P64 = P64[R1 + 15];
           _sdSxC::P64 = P64[R1 + 23];
           R1 = P64[Sp + 24];
           P64[Sp - 24] = _sdSxA::P64;
           P64[Sp - 16] = _sdSxB::P64;
           P64[Sp - 8] = _sdSxC::P64;
           P64[Sp] = _sdSxz::P64;
           Sp = Sp - 32;
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSZP() //  [R1]
         { info_tbl: [(cdSZP,
                       label: block_cdSZP_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSZP: // global
           if (R1 == 0) goto cdT0o; else goto cdT0e;
       cdT0o: // global
           I64[Sp + 24] = block_cdT0l_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 56];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdT0e: // global
           I64[Sp] = block_cdSZX_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto udT0t; else goto cdSZY;
       udT0t: // global
           call _cdSZX(R1) args: 0, res: 0, upd: 0;
       cdSZY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdT0l() //  []
         { info_tbl: [(cdT0l,
                       label: block_cdT0l_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT0l: // global
           I64[Sp + 32] = block_cdT0n_info;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSZX() //  [R1]
         { info_tbl: [(cdSZX,
                       label: block_cdSZX_info
                       rep:StackRep [False, False, False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSZX: // global
           _sdSxA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdT02_info;
           _sdSxJ::I64 = I64[R1 + 7];
           R1 = _sdSxA::P64;
           I64[Sp + 56] = _sdSxJ::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udT0u; else goto cdT03;
       udT0u: // global
           call _cdT02(R1) args: 0, res: 0, upd: 0;
       cdT03: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdT02() //  [R1]
         { info_tbl: [(cdT02,
                       label: block_cdT02_info
                       rep:StackRep [False, False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT02: // global
           _sdSxM::I64 = I64[Sp + 48] + I64[R1 + 7];
           I64[Sp + 24] = block_cdT0a_info;
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = _sdSxM::I64;
           Sp = Sp + 24;
           call Control.Concurrent.QSemN.$wloop_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdT0a() //  [R1]
         { info_tbl: [(cdT0a,
                       label: block_cdT0a_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT0a: // global
           I64[Sp + 24] = block_cdT0n_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdT0n() //  []
         { info_tbl: [(cdT0n,
                       label: block_cdT0n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT0n: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl2_rdSvO_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdT0y,
                       label: lvl2_rdSvO_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT0y: // global
           _sdSxt::I64 = R6;
           _sdSxs::P64 = R5;
           _sdSxq::P64 = R4;
           _sdSxp::P64 = R3;
           _sdSxo::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto cdT0z; else goto cdT0A;
       cdT0A: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdT0C; else goto cdT0B;
       cdT0C: // global
           HpAlloc = 32;
           goto cdT0z;
       cdT0z: // global
           R1 = lvl2_rdSvO_closure;
           P64[Sp - 40] = _sdSxo::P64;
           P64[Sp - 32] = _sdSxp::P64;
           P64[Sp - 24] = _sdSxq::P64;
           P64[Sp - 16] = _sdSxs::P64;
           I64[Sp - 8] = _sdSxt::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cdT0B: // global
           if (_sdSxt::I64 == 1) goto cdT0x; else goto cdT0w;
       cdT0x: // global
           Hp = Hp - 32;
           I64[Sp - 40] = block_cdT0H_info;
           R1 = _sdSxo::P64;
           P64[Sp - 32] = _sdSxo::P64;
           P64[Sp - 24] = _sdSxp::P64;
           P64[Sp - 16] = _sdSxq::P64;
           P64[Sp - 8] = _sdSxs::P64;
           Sp = Sp - 40;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdT0w: // global
           I64[Hp - 24] = sat_sdSxT_info;
           P64[Hp - 16] = _sdSxo::P64;
           P64[Hp - 8] = _sdSxp::P64;
           P64[Hp] = _sdSxq::P64;
           I64[Sp - 16] = block_cdT0D_info;
           R1 = Hp - 23;
           P64[Sp - 8] = _sdSxs::P64;
           Sp = Sp - 16;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdT0H() //  [R1]
         { info_tbl: [(cdT0H,
                       label: block_cdT0H_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT0H: // global
           I64[Sp] = block_cdT0J_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udT1s; else goto cdT0L;
       udT1s: // global
           call _cdT0J(R1) args: 0, res: 0, upd: 0;
       cdT0L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdT0J() //  [R1]
         { info_tbl: [(cdT0J,
                       label: block_cdT0J_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT0J: // global
           I64[Sp - 32] = block_cdT0P_info;
           _sdSy0::P64 = R1;
           _sdSy1::P64 = P64[R1 + 7];
           _sdSy2::P64 = P64[R1 + 15];
           _sdSy3::P64 = P64[R1 + 23];
           R1 = P64[Sp + 24];
           P64[Sp - 24] = _sdSy1::P64;
           P64[Sp - 16] = _sdSy2::P64;
           P64[Sp - 8] = _sdSy3::P64;
           P64[Sp] = _sdSy0::P64;
           Sp = Sp - 32;
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdT0P() //  [R1]
         { info_tbl: [(cdT0P,
                       label: block_cdT0P_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT0P: // global
           if (R1 == 0) goto cdT1o; else goto cdT1e;
       cdT1o: // global
           I64[Sp + 24] = block_cdT1l_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 56];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdT1e: // global
           I64[Sp] = block_cdT0X_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto udT1t; else goto cdT0Y;
       udT1t: // global
           call _cdT0X(R1) args: 0, res: 0, upd: 0;
       cdT0Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdT1l() //  []
         { info_tbl: [(cdT1l,
                       label: block_cdT1l_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT1l: // global
           I64[Sp + 32] = block_cdT1n_info;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdT0X() //  [R1]
         { info_tbl: [(cdT0X,
                       label: block_cdT0X_info
                       rep:StackRep [False, False, False, True, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT0X: // global
           _sdSy1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdT12_info;
           _sdSya::I64 = I64[R1 + 7];
           R1 = _sdSy1::P64;
           I64[Sp + 56] = _sdSya::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udT1u; else goto cdT13;
       udT1u: // global
           call _cdT12(R1) args: 0, res: 0, upd: 0;
       cdT13: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdT12() //  [R1]
         { info_tbl: [(cdT12,
                       label: block_cdT12_info
                       rep:StackRep [False, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT12: // global
           _sdSyd::I64 = I64[Sp + 48] + I64[R1 + 7];
           I64[Sp + 24] = block_cdT1a_info;
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = _sdSyd::I64;
           Sp = Sp + 24;
           call Control.Concurrent.QSemN.$wloop_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdT1a() //  [R1]
         { info_tbl: [(cdT1a,
                       label: block_cdT1a_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT1a: // global
           I64[Sp + 24] = block_cdT1n_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdT1n() //  []
         { info_tbl: [(cdT1n,
                       label: block_cdT1n_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT1n: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdT0D() //  []
         { info_tbl: [(cdT0D,
                       label: block_cdT0D_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT0D: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.042706309 UTC

[section ""data" . Control.Concurrent.QSemN.$wlvl_closure" {
     Control.Concurrent.QSemN.$wlvl_closure:
         const Control.Concurrent.QSemN.$wlvl_info;
 },
 Control.Concurrent.QSemN.$wlvl_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdT2M,
                       label: Control.Concurrent.QSemN.$wlvl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT2M: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdT2N; else goto cdT2O;
       cdT2N: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.$wlvl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdT2O: // global
           I64[Sp - 40] = block_cdT2K_info;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdT2K() //  [R1]
         { info_tbl: [(cdT2K,
                       label: block_cdT2K_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT2K: // global
           R6 = R1;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           Sp = Sp + 40;
           call lvl2_rdSvO_entry(R6, R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.051241296 UTC

[section ""data" . Control.Concurrent.QSemN.$wwaitQSemN_closure" {
     Control.Concurrent.QSemN.$wwaitQSemN_closure:
         const Control.Concurrent.QSemN.$wwaitQSemN_info;
 },
 sat_sdSz1_entry() //  [R1, R2]
         { info_tbl: [(cdT3G,
                       label: sat_sdSz1_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT3G: // global
           R5 = R2;
           R4 = P64[R1 + 6];
           R3 = P64[R1 + 22];
           R2 = P64[R1 + 14];
           call Control.Concurrent.QSemN.$wlvl_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdSyY_entry() //  [R1]
         { info_tbl: [(cdT3O,
                       label: sat_sdSyY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT3O: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sdSyy_entry() //  [R1]
         { info_tbl: [(cdT3R,
                       label: io_sdSyy_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT3R: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdT3S; else goto cdT3T;
       cdT3S: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdT3T: // global
           I64[Sp - 24] = block_cdT39_info;
           _sdSys::P64 = P64[R1 + 7];
           _sdSyt::I64 = I64[R1 + 15];
           R1 = _sdSys::P64;
           P64[Sp - 16] = _sdSys::P64;
           I64[Sp - 8] = _sdSyt::I64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdT39() //  [R1]
         { info_tbl: [(cdT39,
                       label: block_cdT39_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT39: // global
           I64[Sp] = block_cdT3b_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udT4d; else goto cdT3c;
       udT4d: // global
           call _cdT3b(R1) args: 0, res: 0, upd: 0;
       cdT3c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdT3b() //  [R1]
         { info_tbl: [(cdT3b,
                       label: block_cdT3b_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT3b: // global
           I64[Sp - 16] = block_cdT3g_info;
           _sdSyF::P64 = P64[R1 + 15];
           _sdSyG::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdSyG::P64;
           P64[Sp] = _sdSyF::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udT4e; else goto cdT3h;
       udT4e: // global
           call _cdT3g(R1) args: 0, res: 0, upd: 0;
       cdT3h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdT3g() //  [R1]
         { info_tbl: [(cdT3g,
                       label: block_cdT3g_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT3g: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdT3Y; else goto cdT3X;
       cdT3Y: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdT3X: // global
           _sdSyJ::I64 = I64[R1 + 7] - I64[Sp + 32];
           if (%MO_S_Ge_W64(_sdSyJ::I64, 0)) goto cdT43; else goto cdT46;
       cdT43: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdSyJ::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 32] = block_cdT41_info;
           R2 = Hp - 23;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdT46: // global
           Hp = Hp - 48;
           I64[Sp - 8] = block_cdT3s_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdT41() //  []
         { info_tbl: [(cdT41,
                       label: block_cdT41_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT41: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdT3s() //  [R1]
         { info_tbl: [(cdT3s,
                       label: block_cdT3s_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT3s: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdT49; else goto cdT48;
       cdT49: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdT48: // global
           I64[Hp - 104] = GHC.Types.I#_con_info;
           I64[Hp - 96] = I64[Sp + 40];
           I64[Hp - 88] = GHC.MVar.MVar_con_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = (,)_con_info;
           _cdT3u::P64 = Hp - 103;
           P64[Hp - 64] = _cdT3u::P64;
           P64[Hp - 56] = Hp - 87;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 71;
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = Hp - 46;
           I64[Sp + 16] = block_cdT3z_info;
           R2 = Hp - 23;
           _sdSyQ::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 24] = _sdSyQ::P64;
           P64[Sp + 40] = _cdT3u::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdT3z() //  []
         { info_tbl: [(cdT3z,
                       label: block_cdT3z_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT3z: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdT4c; else goto cdT4b;
       cdT4c: // global
           HpAlloc = 48;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdT4b: // global
           I64[Hp - 40] = sat_sdSz1_info;
           P64[Hp - 32] = P64[Sp + 16];
           _sdSyQ::P64 = P64[Sp + 8];
           P64[Hp - 24] = _sdSyQ::P64;
           P64[Hp - 16] = P64[Sp + 24];
           I64[Hp - 8] = sat_sdSyY_info;
           P64[Hp] = _sdSyQ::P64;
           R2 = Hp - 38;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSemN.$wwaitQSemN_entry() //  [R2, R3]
         { info_tbl: [(cdT4j,
                       label: Control.Concurrent.QSemN.$wwaitQSemN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT4j: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdT4k; else goto cdT4l;
       cdT4k: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.$wwaitQSemN_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdT4l: // global
           I64[Sp - 24] = block_cdT32_info;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdT32() //  [R1]
         { info_tbl: [(cdT32,
                       label: block_cdT32_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT32: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdT4o; else goto cdT4n;
       cdT4o: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdT4n: // global
           I64[Hp - 16] = io_sdSyy_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           _cdT34::P64 = Hp - 15;
           if (R1 == 0) goto cdT4i; else goto cdT4h;
       cdT4i: // global
           R1 = _cdT34::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cdT4h: // global
           R1 = _cdT34::P64;
           Sp = Sp + 24;
           call io_sdSyy_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.076948047 UTC

[section ""data" . Control.Concurrent.QSemN.waitQSemN1_closure" {
     Control.Concurrent.QSemN.waitQSemN1_closure:
         const Control.Concurrent.QSemN.waitQSemN1_info;
 },
 Control.Concurrent.QSemN.waitQSemN1_entry() //  [R2, R3]
         { info_tbl: [(cdT5o,
                       label: Control.Concurrent.QSemN.waitQSemN1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT5o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdT5s; else goto cdT5t;
       cdT5s: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.waitQSemN1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdT5t: // global
           I64[Sp - 16] = block_cdT5l_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udT5B; else goto cdT5m;
       udT5B: // global
           call _cdT5l(R1) args: 0, res: 0, upd: 0;
       cdT5m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdT5l() //  [R1]
         { info_tbl: [(cdT5l,
                       label: block_cdT5l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT5l: // global
           I64[Sp] = block_cdT5r_info;
           _sdSz7::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdSz7::P64;
           if (R1 & 7 != 0) goto udT5A; else goto cdT5v;
       udT5A: // global
           call _cdT5r(R1) args: 0, res: 0, upd: 0;
       cdT5v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdT5r() //  [R1]
         { info_tbl: [(cdT5r,
                       label: block_cdT5r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT5r: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Control.Concurrent.QSemN.$wwaitQSemN_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.085002946 UTC

[section ""data" . Control.Concurrent.QSemN.waitQSemN_closure" {
     Control.Concurrent.QSemN.waitQSemN_closure:
         const Control.Concurrent.QSemN.waitQSemN_info;
 },
 Control.Concurrent.QSemN.waitQSemN_entry() //  [R2, R3]
         { info_tbl: [(cdT5T,
                       label: Control.Concurrent.QSemN.waitQSemN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT5T: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.QSemN.waitQSemN1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.088843449 UTC

[section ""data" . Control.Concurrent.QSemN.QSemN_closure" {
     Control.Concurrent.QSemN.QSemN_closure:
         const Control.Concurrent.QSemN.QSemN_info;
 },
 Control.Concurrent.QSemN.QSemN_entry() //  [R2]
         { info_tbl: [(cdT65,
                       label: Control.Concurrent.QSemN.QSemN_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT65: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdT69; else goto cdT68;
       cdT69: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.QSemN_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdT68: // global
           I64[Hp - 8] = Control.Concurrent.QSemN.QSemN_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.092720519 UTC

[Control.Concurrent.QSemN.QSemN_con_entry() //  [R1]
         { info_tbl: [(cdT6f,
                       label: Control.Concurrent.QSemN.QSemN_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,81,83,101,109,78,46,81,83,101,109,78]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT6f: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.096720436 UTC

[section ""relreadonly" . SdSzD_srt" {
     SdSzD_srt:
         const GHC.IO.failIO1_closure;
         const Control.Concurrent.QSemN.newQSemN2_closure;
         const Control.Concurrent.QSemN.newQSemN1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.773955307 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:08.775524652 UTC

[section ""data" . Control.Concurrent.QSemN.$WQSemN_closure" {
     Control.Concurrent.QSemN.$WQSemN_closure:
         const Control.Concurrent.QSemN.$WQSemN_info;
 },
 Control.Concurrent.QSemN.$WQSemN_entry() //  [R2]
         { info_tbl: [(cdT9N,
                       label: Control.Concurrent.QSemN.$WQSemN_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT9N: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdT9R; else goto cdT9S;
       cdT9R: // global
           R2 = R2;
           R1 = Control.Concurrent.QSemN.$WQSemN_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdT9S: // global
           I64[Sp - 8] = block_cdT9K_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udT9W; else goto cdT9L;
       udT9W: // global
           call _cdT9K(R1) args: 0, res: 0, upd: 0;
       cdT9L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdT9K() //  [R1]
         { info_tbl: [(cdT9K,
                       label: block_cdT9K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdT9K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdT9V; else goto cdT9U;
       cdT9V: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdT9U: // global
           _sdT6o::P64 = P64[R1 + 7];
           I64[Hp - 8] = Control.Concurrent.QSemN.QSemN_con_info;
           P64[Hp] = _sdT6o::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.7814517 UTC

[section ""cstring" . Control.Concurrent.QSemN.$trModule4_bytes" {
     Control.Concurrent.QSemN.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.783219114 UTC

[section ""data" . Control.Concurrent.QSemN.$trModule3_closure" {
     Control.Concurrent.QSemN.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSemN.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.785093046 UTC

[section ""cstring" . Control.Concurrent.QSemN.$trModule2_bytes" {
     Control.Concurrent.QSemN.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,81,83,101,109,78]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.786869467 UTC

[section ""data" . Control.Concurrent.QSemN.$trModule1_closure" {
     Control.Concurrent.QSemN.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSemN.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.788712595 UTC

[section ""data" . Control.Concurrent.QSemN.$trModule_closure" {
     Control.Concurrent.QSemN.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.QSemN.$trModule3_closure+1;
         const Control.Concurrent.QSemN.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.790635225 UTC

[section ""data" . $krep_rdSvw_closure" {
     $krep_rdSvw_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.792544922 UTC

[section ""data" . $krep1_rdSvx_closure" {
     $krep1_rdSvx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.794517466 UTC

[section ""data" . $krep2_rdSvy_closure" {
     $krep2_rdSvy_closure:
         const :_con_info;
         const $krep_rdSvw_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.796357464 UTC

[section ""data" . $krep3_rdSvz_closure" {
     $krep3_rdSvz_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep2_rdSvy_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.798564363 UTC

[section ""data" . $krep4_rdSvA_closure" {
     $krep4_rdSvA_closure:
         const :_con_info;
         const $krep3_rdSvz_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.800378691 UTC

[section ""data" . $krep5_rdSvB_closure" {
     $krep5_rdSvB_closure:
         const :_con_info;
         const $krep1_rdSvx_closure+1;
         const $krep4_rdSvA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.802901105 UTC

[section ""data" . $krep6_rdSvC_closure" {
     $krep6_rdSvC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep5_rdSvB_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.80467134 UTC

[section ""data" . $krep7_rdSvD_closure" {
     $krep7_rdSvD_closure:
         const :_con_info;
         const $krep6_rdSvC_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.806498757 UTC

[section ""data" . $krep8_rdSvE_closure" {
     $krep8_rdSvE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep7_rdSvD_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.808214148 UTC

[section ""data" . $krep9_rdSvF_closure" {
     $krep9_rdSvF_closure:
         const :_con_info;
         const $krep8_rdSvE_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.810602738 UTC

[section ""data" . $krep10_rdSvG_closure" {
     $krep10_rdSvG_closure:
         const :_con_info;
         const $krep8_rdSvE_closure+1;
         const $krep9_rdSvF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.812603694 UTC

[section ""data" . $krep11_rdSvH_closure" {
     $krep11_rdSvH_closure:
         const :_con_info;
         const $krep1_rdSvx_closure+1;
         const $krep10_rdSvG_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.814485929 UTC

[section ""data" . $krep12_rdSvI_closure" {
     $krep12_rdSvI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,,)_closure;
         const $krep11_rdSvH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.816293574 UTC

[section ""data" . $krep13_rdSvJ_closure" {
     $krep13_rdSvJ_closure:
         const :_con_info;
         const $krep12_rdSvI_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.8182315 UTC

[section ""data" . $krep14_rdSvK_closure" {
     $krep14_rdSvK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep13_rdSvJ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.820693775 UTC

[section ""cstring" . Control.Concurrent.QSemN.$tcQSemN2_bytes" {
     Control.Concurrent.QSemN.$tcQSemN2_bytes:
         I8[] [81,83,101,109,78]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.823111469 UTC

[section ""data" . Control.Concurrent.QSemN.$tcQSemN1_closure" {
     Control.Concurrent.QSemN.$tcQSemN1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSemN.$tcQSemN2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.826147612 UTC

[section ""data" . Control.Concurrent.QSemN.$tcQSemN_closure" {
     Control.Concurrent.QSemN.$tcQSemN_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.QSemN.$trModule_closure+1;
         const Control.Concurrent.QSemN.$tcQSemN1_closure+1;
         const GHC.Types.krep$*_closure;
         const 8650881979471817661;
         const 11033619023634057930;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.828108429 UTC

[section ""data" . $krep15_rdSvL_closure" {
     $krep15_rdSvL_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Concurrent.QSemN.$tcQSemN_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.830127464 UTC

[section ""data" . Control.Concurrent.QSemN.$tc'QSemN1_closure" {
     Control.Concurrent.QSemN.$tc'QSemN1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_rdSvK_closure+1;
         const $krep15_rdSvL_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.832673027 UTC

[section ""cstring" . Control.Concurrent.QSemN.$tc'QSemN3_bytes" {
     Control.Concurrent.QSemN.$tc'QSemN3_bytes:
         I8[] [39,81,83,101,109,78]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.834469486 UTC

[section ""data" . Control.Concurrent.QSemN.$tc'QSemN2_closure" {
     Control.Concurrent.QSemN.$tc'QSemN2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.QSemN.$tc'QSemN3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.836194971 UTC

[section ""data" . Control.Concurrent.QSemN.$tc'QSemN_closure" {
     Control.Concurrent.QSemN.$tc'QSemN_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.QSemN.$trModule_closure+1;
         const Control.Concurrent.QSemN.$tc'QSemN2_closure+1;
         const Control.Concurrent.QSemN.$tc'QSemN1_closure+4;
         const 15878277071781304355;
         const 273080421945023395;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.838654034 UTC

[section ""cstring" . lvl_rdSvM_bytes" {
     lvl_rdSvM_bytes:
         I8[] [110,101,119,81,83,101,109,78,58,32,73,110,105,116,105,97,108,32,113,117,97,110,116,105,116,121,32,109,117,115,116,32,98,101,32,110,111,110,45,110,101,103,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.841213749 UTC

[section ""data" . Control.Concurrent.QSemN.newQSemN2_closure" {
     Control.Concurrent.QSemN.newQSemN2_closure:
         const Control.Concurrent.QSemN.newQSemN2_info;
         const 0;
 },
 Control.Concurrent.QSemN.newQSemN2_entry() //  []
         { info_tbl: [(cdTaI,
                       label: Control.Concurrent.QSemN.newQSemN2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTaI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdTaJ; else goto cdTaK;
       cdTaJ: // global
           R1 = Control.Concurrent.QSemN.newQSemN2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdTaK: // global
           I64[Sp - 8] = block_cdTaG_info;
           R2 = lvl_rdSvM_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdTaG() //  [R1]
         { info_tbl: [(cdTaG,
                       label: block_cdTaG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTaG: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.847463953 UTC

[section ""data" . Control.Concurrent.QSemN.newQSemN1_closure" {
     Control.Concurrent.QSemN.newQSemN1_closure:
         const Control.Concurrent.QSemN.newQSemN1_info;
         const 0;
 },
 Control.Concurrent.QSemN.newQSemN1_entry() //  [R2]
         { info_tbl: [(cdTb5,
                       label: Control.Concurrent.QSemN.newQSemN1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTb5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdTb6; else goto cdTb7;
       cdTb6: // global
           R2 = R2;
           R1 = Control.Concurrent.QSemN.newQSemN1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdTb7: // global
           I64[Sp - 8] = block_cdTb2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udTbt; else goto cdTb3;
       udTbt: // global
           call _cdTb2(R1) args: 0, res: 0, upd: 0;
       cdTb3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTb2() //  [R1]
         { info_tbl: [(cdTb2,
                       label: block_cdTb2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTb2: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto cdTbl; else goto cdTbs;
       cdTbl: // global
           I64[Sp - 8] = block_cdTbe_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
       cdTbs: // global
           Sp = Sp + 8;
           call Control.Concurrent.QSemN.newQSemN2_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cdTbe() //  [R1]
         { info_tbl: [(cdTbe,
                       label: block_cdTbe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTbe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdTbo; else goto cdTbn;
       cdTbo: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdTbn: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = GHC.Types.[]_closure+1;
           I64[Sp] = block_cdTbh_info;
           R2 = Hp - 23;
           _sdT6y::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _sdT6y::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTbh() //  []
         { info_tbl: [(cdTbh,
                       label: block_cdTbh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTbh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdTbr; else goto cdTbq;
       cdTbr: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdTbq: // global
           I64[Hp - 8] = Control.Concurrent.QSemN.QSemN_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.857868661 UTC

[section ""data" . Control.Concurrent.QSemN.newQSemN_closure" {
     Control.Concurrent.QSemN.newQSemN_closure:
         const Control.Concurrent.QSemN.newQSemN_info;
         const 0;
 },
 Control.Concurrent.QSemN.newQSemN_entry() //  [R2]
         { info_tbl: [(cdTbZ,
                       label: Control.Concurrent.QSemN.newQSemN_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTbZ: // global
           R2 = R2;
           call Control.Concurrent.QSemN.newQSemN1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.86151422 UTC

[section ""data" . lvl1_rdSvN_closure" {
     lvl1_rdSvN_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.86528688 UTC

[section ""data" . Control.Concurrent.QSemN.$wloop_closure" {
     Control.Concurrent.QSemN.$wloop_closure:
         const Control.Concurrent.QSemN.$wloop_info;
 },
 sat_sdT6N_entry() //  [R1]
         { info_tbl: [(cdTcs,
                       label: sat_sdT6N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTcs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdTct; else goto cdTcu;
       cdTct: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdTcu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse1_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Concurrent.QSemN.$wloop_entry() //  [R2, R3, R4]
         { info_tbl: [(cdTcy,
                       label: Control.Concurrent.QSemN.$wloop_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTcy: // global
           if ((Sp + -48) < SpLim) (likely: False) goto udTdR; else goto udTdQ;
       udTdR: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cdTcz() args: 0, res: 0, upd: 0;
       udTdQ: // global
           I64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cdTc8() args: 0, res: 0, upd: 0;
     }
 },
 _cdTc8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTc8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdTcC; else goto cdTcB;
       cdTcC: // global
           HpAlloc = 32;
           call _cdTcz() args: 0, res: 0, upd: 0;
       cdTcB: // global
           _sdT6D::P64 = P64[Sp + 8];
           _sdT6G::I64 = I64[Sp];
           if (_sdT6G::I64 != 0) goto cdTcw; else goto cdTcx;
       cdTcw: // global
           Hp = Hp - 32;
           I64[Sp] = block_cdTcd_info;
           R1 = _sdT6D::P64;
           I64[Sp + 8] = _sdT6G::I64;
           if (R1 & 7 != 0) goto udTdW; else goto cdTce;
       udTdW: // global
           call _cdTcd(R1) args: 0, res: 0, upd: 0;
       cdTce: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdTcx: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl1_rdSvN_closure+1;
           P64[Hp - 8] = _sdT6D::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdTcz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTcz: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = Control.Concurrent.QSemN.$wloop_closure;
           Sp = Sp + 24;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdTcd() //  [R1]
         { info_tbl: [(cdTcd,
                       label: block_cdTcd_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTcd: // global
           if (R1 & 7 == 1) goto cdTcF; else goto cdTd1;
       cdTcF: // global
           I64[Sp] = block_cdTci_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto udTdY; else goto cdTcj;
       udTdY: // global
           call _cdTci(R1) args: 0, res: 0, upd: 0;
       cdTcj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdTd1: // global
           I64[Sp - 16] = block_cdTcU_info;
           _sdT6H::P64 = R1;
           _sdT6P::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdT6P::P64;
           P64[Sp] = _sdT6H::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udTdZ; else goto cdTcV;
       udTdZ: // global
           call _cdTcU(R1) args: 0, res: 0, upd: 0;
       cdTcV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTci() //  [R1]
         { info_tbl: [(cdTci,
                       label: block_cdTci_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTci: // global
           _sdT6G::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cdTcK; else goto cdTcO;
       cdTcK: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdTcN; else goto cdTcM;
       cdTcN: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdTcM: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdT6G::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdTcO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdTcR; else goto cdTcQ;
       cdTcR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdTcQ: // global
           I64[Hp - 16] = sat_sdT6N_info;
           P64[Hp] = R1;
           I64[Sp] = _sdT6G::I64;
           P64[Sp + 8] = Hp - 16;
           P64[Sp + 16] = GHC.Types.[]_closure+1;
           call _cdTc8() args: 0, res: 0, upd: 0;
     }
 },
 _cdTcU() //  [R1]
         { info_tbl: [(cdTcU,
                       label: block_cdTcU_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTcU: // global
           I64[Sp - 8] = block_cdTcZ_info;
           _sdT6S::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sdT6S::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udTe3; else goto cdTd3;
       udTe3: // global
           call _cdTcZ(R1) args: 0, res: 0, upd: 0;
       cdTd3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTcZ() //  [R1]
         { info_tbl: [(cdTcZ,
                       label: block_cdTcZ_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTcZ: // global
           _sdT6S::P64 = P64[Sp + 8];
           _sdT6U::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_sdT6U::I64,
                            I64[Sp + 32])) goto cdTdd; else goto cdTds;
       cdTdd: // global
           I64[Sp + 8] = block_cdTdb_info;
           R1 = _sdT6S::P64;
           I64[Sp + 24] = _sdT6U::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udTe4; else goto cdTde;
       udTe4: // global
           call _cdTdb(R1) args: 0, res: 0, upd: 0;
       cdTde: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdTds: // global
           I64[Sp + 8] = block_cdTdr_info;
           R1 = _sdT6S::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udTe5; else goto cdTdt;
       udTe5: // global
           call _cdTdr(R1) args: 0, res: 0, upd: 0;
       cdTdt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTdb() //  [R1]
         { info_tbl: [(cdTdb,
                       label: block_cdTdb_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTdb: // global
           I64[Sp] = block_cdTdi_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[R1 + 7];
           call stg_tryPutMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTdi() //  [R1]
         { info_tbl: [(cdTdi,
                       label: block_cdTdi_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTdi: // global
           _sdT6E::P64 = P64[Sp + 32];
           _sdT6G::I64 = I64[Sp + 24];
           _sdT6P::P64 = P64[Sp + 8];
           if (R1 == 0) goto cdTdp; else goto cdTdo;
       cdTdp: // global
           I64[Sp + 16] = _sdT6G::I64;
           P64[Sp + 24] = _sdT6P::P64;
           P64[Sp + 32] = _sdT6E::P64;
           Sp = Sp + 16;
           goto udTe7;
       cdTdo: // global
           I64[Sp + 16] = _sdT6G::I64 - I64[Sp + 16];
           P64[Sp + 24] = _sdT6P::P64;
           P64[Sp + 32] = _sdT6E::P64;
           Sp = Sp + 16;
           goto udTe7;
       udTe7: // global
           call _cdTc8() args: 0, res: 0, upd: 0;
     }
 },
 _cdTdr() //  [R1]
         { info_tbl: [(cdTdr,
                       label: block_cdTdr_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTdr: // global
           I64[Sp] = block_cdTdx_info;
           R1 = P64[R1 + 7];
           call stg_isEmptyMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTdx() //  [R1]
         { info_tbl: [(cdTdx,
                       label: block_cdTdx_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTdx: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdTdC; else goto cdTdB;
       cdTdC: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdTdB: // global
           _sdT6E::P64 = P64[Sp + 32];
           _sdT6G::I64 = I64[Sp + 24];
           if (R1 == 0) goto cdTdJ; else goto cdTdI;
       cdTdJ: // global
           Hp = Hp - 48;
           I64[Sp + 16] = _sdT6G::I64;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = _sdT6E::P64;
           Sp = Sp + 16;
           call _cdTc8() args: 0, res: 0, upd: 0;
       cdTdI: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdT6G::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sdT6E::P64;
           R1 = Hp - 23;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.892800243 UTC

[section ""data" . Control.Concurrent.QSemN.$wsignalQSemN_closure" {
     Control.Concurrent.QSemN.$wsignalQSemN_closure:
         const Control.Concurrent.QSemN.$wsignalQSemN_info;
 },
 sat_sdT7y_entry() //  [R1]
         { info_tbl: [(cdTfL,
                       label: sat_sdT7y_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTfL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdTfZ; else goto cdTg0;
       cdTfZ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdTg0: // global
           I64[Sp - 24] = block_cdTfG_info;
           _sdT7c::P64 = P64[R1 + 7];
           _sdT7d::I64 = I64[R1 + 15];
           R1 = _sdT7c::P64;
           P64[Sp - 16] = _sdT7c::P64;
           I64[Sp - 8] = _sdT7d::I64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTfG() //  [R1]
         { info_tbl: [(cdTfG,
                       label: block_cdTfG_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTfG: // global
           I64[Sp] = block_cdTfI_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udTg7; else goto cdTfJ;
       udTg7: // global
           call _cdTfI(R1) args: 0, res: 0, upd: 0;
       cdTfJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTfI() //  [R1]
         { info_tbl: [(cdTfI,
                       label: block_cdTfI_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTfI: // global
           I64[Sp - 16] = block_cdTfO_info;
           _sdT7p::P64 = P64[R1 + 15];
           _sdT7q::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdT7q::P64;
           P64[Sp] = _sdT7p::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udTg8; else goto cdTfP;
       udTg8: // global
           call _cdTfO(R1) args: 0, res: 0, upd: 0;
       cdTfP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTfO() //  [R1]
         { info_tbl: [(cdTfO,
                       label: block_cdTfO_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTfO: // global
           _sdT7p::P64 = P64[Sp + 16];
           _sdT7t::I64 = I64[Sp + 32] + I64[R1 + 7];
           I64[Sp + 16] = block_cdTfW_info;
           R4 = P64[Sp + 8];
           R3 = _sdT7p::P64;
           R2 = _sdT7t::I64;
           Sp = Sp + 16;
           call Control.Concurrent.QSemN.$wloop_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdTfW() //  [R1]
         { info_tbl: [(cdTfW,
                       label: block_cdTfW_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTfW: // global
           I64[Sp + 16] = block_cdTfY_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTfY() //  []
         { info_tbl: [(cdTfY,
                       label: block_cdTfY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTfY: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSemN.$wsignalQSemN_entry() //  [R2, R3]
         { info_tbl: [(cdTgc,
                       label: Control.Concurrent.QSemN.$wsignalQSemN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTgc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdTgd; else goto cdTge;
       cdTgd: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.$wsignalQSemN_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdTge: // global
           I64[Sp - 24] = block_cdTfx_info;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdTfx() //  [R1]
         { info_tbl: [(cdTfx,
                       label: block_cdTfx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTfx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdTgh; else goto cdTgg;
       cdTgh: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdTgg: // global
           _sdT7c::P64 = P64[Sp + 8];
           if (R1 == 1) goto cdTgb; else goto cdTga;
       cdTgb: // global
           Hp = Hp - 24;
           I64[Sp] = block_cdTgj_info;
           R1 = _sdT7c::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdTga: // global
           I64[Hp - 16] = sat_sdT7y_info;
           P64[Hp - 8] = _sdT7c::P64;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdTgj() //  [R1]
         { info_tbl: [(cdTgj,
                       label: block_cdTgj_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTgj: // global
           I64[Sp] = block_cdTgl_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udTgH; else goto cdTgm;
       udTgH: // global
           call _cdTgl(R1) args: 0, res: 0, upd: 0;
       cdTgm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTgl() //  [R1]
         { info_tbl: [(cdTgl,
                       label: block_cdTgl_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTgl: // global
           I64[Sp - 16] = block_cdTgq_info;
           _sdT7E::P64 = P64[R1 + 15];
           _sdT7F::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdT7F::P64;
           P64[Sp] = _sdT7E::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udTgI; else goto cdTgr;
       udTgI: // global
           call _cdTgq(R1) args: 0, res: 0, upd: 0;
       cdTgr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTgq() //  [R1]
         { info_tbl: [(cdTgq,
                       label: block_cdTgq_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTgq: // global
           _sdT7E::P64 = P64[Sp + 16];
           _sdT7I::I64 = I64[Sp + 32] + I64[R1 + 7];
           I64[Sp + 16] = block_cdTgy_info;
           R4 = P64[Sp + 8];
           R3 = _sdT7E::P64;
           R2 = _sdT7I::I64;
           Sp = Sp + 16;
           call Control.Concurrent.QSemN.$wloop_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdTgy() //  [R1]
         { info_tbl: [(cdTgy,
                       label: block_cdTgy_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTgy: // global
           I64[Sp + 16] = block_cdTgA_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTgA() //  []
         { info_tbl: [(cdTgA,
                       label: block_cdTgA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTgA: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.919877491 UTC

[section ""data" . Control.Concurrent.QSemN.signalQSemN1_closure" {
     Control.Concurrent.QSemN.signalQSemN1_closure:
         const Control.Concurrent.QSemN.signalQSemN1_info;
 },
 Control.Concurrent.QSemN.signalQSemN1_entry() //  [R2, R3]
         { info_tbl: [(cdThV,
                       label: Control.Concurrent.QSemN.signalQSemN1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdThV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdThZ; else goto cdTi0;
       cdThZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.signalQSemN1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdTi0: // global
           I64[Sp - 16] = block_cdThS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udTi8; else goto cdThT;
       udTi8: // global
           call _cdThS(R1) args: 0, res: 0, upd: 0;
       cdThT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdThS() //  [R1]
         { info_tbl: [(cdThS,
                       label: block_cdThS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdThS: // global
           I64[Sp] = block_cdThY_info;
           _sdT7R::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdT7R::P64;
           if (R1 & 7 != 0) goto udTi7; else goto cdTi2;
       udTi7: // global
           call _cdThY(R1) args: 0, res: 0, upd: 0;
       cdTi2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdThY() //  [R1]
         { info_tbl: [(cdThY,
                       label: block_cdThY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdThY: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Control.Concurrent.QSemN.$wsignalQSemN_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.927231286 UTC

[section ""data" . Control.Concurrent.QSemN.signalQSemN_closure" {
     Control.Concurrent.QSemN.signalQSemN_closure:
         const Control.Concurrent.QSemN.signalQSemN_info;
 },
 Control.Concurrent.QSemN.signalQSemN_entry() //  [R2, R3]
         { info_tbl: [(cdTis,
                       label: Control.Concurrent.QSemN.signalQSemN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTis: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.QSemN.signalQSemN1_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.932484669 UTC

[section ""data" . lvl2_rdSvO_closure" {
     lvl2_rdSvO_closure:
         const lvl2_rdSvO_info;
 },
 lvl2_rdSvO_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTiA: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call lvl2_rdSvO_entry(R6,
                                 R5,
                                 R4,
                                 R3,
                                 R2,
                                 R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdT8p_entry() //  [R1]
         { info_tbl: [(cdTiQ,
                       label: sat_sdT8p_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTiQ: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdTiR; else goto cdTiS;
       cdTiR: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdTiS: // global
           I64[Sp - 32] = block_cdTiL_info;
           _sdT7U::P64 = P64[R1 + 7];
           _sdT7V::P64 = P64[R1 + 15];
           _sdT7W::P64 = P64[R1 + 23];
           R1 = _sdT7U::P64;
           P64[Sp - 24] = _sdT7U::P64;
           P64[Sp - 16] = _sdT7V::P64;
           P64[Sp - 8] = _sdT7W::P64;
           Sp = Sp - 32;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTiL() //  [R1]
         { info_tbl: [(cdTiL,
                       label: block_cdTiL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTiL: // global
           I64[Sp] = block_cdTiN_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udTjz; else goto cdTiO;
       udTjz: // global
           call _cdTiN(R1) args: 0, res: 0, upd: 0;
       cdTiO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTiN() //  [R1]
         { info_tbl: [(cdTiN,
                       label: block_cdTiN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTiN: // global
           I64[Sp - 32] = block_cdTiW_info;
           _sdT85::P64 = R1;
           _sdT86::P64 = P64[R1 + 7];
           _sdT87::P64 = P64[R1 + 15];
           _sdT88::P64 = P64[R1 + 23];
           R1 = P64[Sp + 24];
           P64[Sp - 24] = _sdT86::P64;
           P64[Sp - 16] = _sdT87::P64;
           P64[Sp - 8] = _sdT88::P64;
           P64[Sp] = _sdT85::P64;
           Sp = Sp - 32;
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTiW() //  [R1]
         { info_tbl: [(cdTiW,
                       label: block_cdTiW_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTiW: // global
           if (R1 == 0) goto cdTjv; else goto cdTjl;
       cdTjv: // global
           I64[Sp + 24] = block_cdTjs_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 56];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdTjl: // global
           I64[Sp] = block_cdTj4_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto udTjA; else goto cdTj5;
       udTjA: // global
           call _cdTj4(R1) args: 0, res: 0, upd: 0;
       cdTj5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTjs() //  []
         { info_tbl: [(cdTjs,
                       label: block_cdTjs_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTjs: // global
           I64[Sp + 32] = block_cdTju_info;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTj4() //  [R1]
         { info_tbl: [(cdTj4,
                       label: block_cdTj4_info
                       rep:StackRep [False, False, False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTj4: // global
           _sdT86::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdTj9_info;
           _sdT8f::I64 = I64[R1 + 7];
           R1 = _sdT86::P64;
           I64[Sp + 56] = _sdT8f::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udTjB; else goto cdTja;
       udTjB: // global
           call _cdTj9(R1) args: 0, res: 0, upd: 0;
       cdTja: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTj9() //  [R1]
         { info_tbl: [(cdTj9,
                       label: block_cdTj9_info
                       rep:StackRep [False, False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTj9: // global
           _sdT8i::I64 = I64[Sp + 48] + I64[R1 + 7];
           I64[Sp + 24] = block_cdTjh_info;
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = _sdT8i::I64;
           Sp = Sp + 24;
           call Control.Concurrent.QSemN.$wloop_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdTjh() //  [R1]
         { info_tbl: [(cdTjh,
                       label: block_cdTjh_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTjh: // global
           I64[Sp + 24] = block_cdTju_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTju() //  []
         { info_tbl: [(cdTju,
                       label: block_cdTju_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTju: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl2_rdSvO_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdTjF,
                       label: lvl2_rdSvO_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTjF: // global
           _sdT7Z::I64 = R6;
           _sdT7Y::P64 = R5;
           _sdT7W::P64 = R4;
           _sdT7V::P64 = R3;
           _sdT7U::P64 = R2;
           if ((Sp + -72) < SpLim) (likely: False) goto cdTjG; else goto cdTjH;
       cdTjH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdTjJ; else goto cdTjI;
       cdTjJ: // global
           HpAlloc = 32;
           goto cdTjG;
       cdTjG: // global
           R1 = lvl2_rdSvO_closure;
           P64[Sp - 40] = _sdT7U::P64;
           P64[Sp - 32] = _sdT7V::P64;
           P64[Sp - 24] = _sdT7W::P64;
           P64[Sp - 16] = _sdT7Y::P64;
           I64[Sp - 8] = _sdT7Z::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cdTjI: // global
           if (_sdT7Z::I64 == 1) goto cdTjE; else goto cdTjD;
       cdTjE: // global
           Hp = Hp - 32;
           I64[Sp - 40] = block_cdTjO_info;
           R1 = _sdT7U::P64;
           P64[Sp - 32] = _sdT7U::P64;
           P64[Sp - 24] = _sdT7V::P64;
           P64[Sp - 16] = _sdT7W::P64;
           P64[Sp - 8] = _sdT7Y::P64;
           Sp = Sp - 40;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       cdTjD: // global
           I64[Hp - 24] = sat_sdT8p_info;
           P64[Hp - 16] = _sdT7U::P64;
           P64[Hp - 8] = _sdT7V::P64;
           P64[Hp] = _sdT7W::P64;
           I64[Sp - 16] = block_cdTjK_info;
           R1 = Hp - 23;
           P64[Sp - 8] = _sdT7Y::P64;
           Sp = Sp - 16;
           call stg_maskUninterruptible#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTjO() //  [R1]
         { info_tbl: [(cdTjO,
                       label: block_cdTjO_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTjO: // global
           I64[Sp] = block_cdTjQ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udTkz; else goto cdTjS;
       udTkz: // global
           call _cdTjQ(R1) args: 0, res: 0, upd: 0;
       cdTjS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTjQ() //  [R1]
         { info_tbl: [(cdTjQ,
                       label: block_cdTjQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTjQ: // global
           I64[Sp - 32] = block_cdTjW_info;
           _sdT8w::P64 = R1;
           _sdT8x::P64 = P64[R1 + 7];
           _sdT8y::P64 = P64[R1 + 15];
           _sdT8z::P64 = P64[R1 + 23];
           R1 = P64[Sp + 24];
           P64[Sp - 24] = _sdT8x::P64;
           P64[Sp - 16] = _sdT8y::P64;
           P64[Sp - 8] = _sdT8z::P64;
           P64[Sp] = _sdT8w::P64;
           Sp = Sp - 32;
           call stg_tryTakeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTjW() //  [R1]
         { info_tbl: [(cdTjW,
                       label: block_cdTjW_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTjW: // global
           if (R1 == 0) goto cdTkv; else goto cdTkl;
       cdTkv: // global
           I64[Sp + 24] = block_cdTks_info;
           R2 = GHC.Tuple.()_closure+1;
           R1 = P64[Sp + 56];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdTkl: // global
           I64[Sp] = block_cdTk4_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto udTkA; else goto cdTk5;
       udTkA: // global
           call _cdTk4(R1) args: 0, res: 0, upd: 0;
       cdTk5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTks() //  []
         { info_tbl: [(cdTks,
                       label: block_cdTks_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTks: // global
           I64[Sp + 32] = block_cdTku_info;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTk4() //  [R1]
         { info_tbl: [(cdTk4,
                       label: block_cdTk4_info
                       rep:StackRep [False, False, False, True, False, True, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTk4: // global
           _sdT8x::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdTk9_info;
           _sdT8G::I64 = I64[R1 + 7];
           R1 = _sdT8x::P64;
           I64[Sp + 56] = _sdT8G::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udTkB; else goto cdTka;
       udTkB: // global
           call _cdTk9(R1) args: 0, res: 0, upd: 0;
       cdTka: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTk9() //  [R1]
         { info_tbl: [(cdTk9,
                       label: block_cdTk9_info
                       rep:StackRep [False, False, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTk9: // global
           _sdT8J::I64 = I64[Sp + 48] + I64[R1 + 7];
           I64[Sp + 24] = block_cdTkh_info;
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = _sdT8J::I64;
           Sp = Sp + 24;
           call Control.Concurrent.QSemN.$wloop_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdTkh() //  [R1]
         { info_tbl: [(cdTkh,
                       label: block_cdTkh_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTkh: // global
           I64[Sp + 24] = block_cdTku_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTku() //  []
         { info_tbl: [(cdTku,
                       label: block_cdTku_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTku: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdTjK() //  []
         { info_tbl: [(cdTjK,
                       label: block_cdTjK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTjK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.970997836 UTC

[section ""data" . Control.Concurrent.QSemN.$wlvl_closure" {
     Control.Concurrent.QSemN.$wlvl_closure:
         const Control.Concurrent.QSemN.$wlvl_info;
 },
 Control.Concurrent.QSemN.$wlvl_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdTmg,
                       label: Control.Concurrent.QSemN.$wlvl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTmg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdTmh; else goto cdTmi;
       cdTmh: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.$wlvl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdTmi: // global
           I64[Sp - 40] = block_cdTme_info;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdTme() //  [R1]
         { info_tbl: [(cdTme,
                       label: block_cdTme_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTme: // global
           R6 = R1;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           Sp = Sp + 40;
           call lvl2_rdSvO_entry(R6, R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:08.978407303 UTC

[section ""data" . Control.Concurrent.QSemN.$wwaitQSemN_closure" {
     Control.Concurrent.QSemN.$wwaitQSemN_closure:
         const Control.Concurrent.QSemN.$wwaitQSemN_info;
 },
 sat_sdT9x_entry() //  [R1, R2]
         { info_tbl: [(cdTnb,
                       label: sat_sdT9x_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTnb: // global
           R5 = R2;
           R4 = P64[R1 + 6];
           R3 = P64[R1 + 22];
           R2 = P64[R1 + 14];
           call Control.Concurrent.QSemN.$wlvl_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdT9u_entry() //  [R1]
         { info_tbl: [(cdTnj,
                       label: sat_sdT9u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTnj: // global
           R1 = P64[R1 + 7];
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sdT94_entry() //  [R1]
         { info_tbl: [(cdTnm,
                       label: io_sdT94_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTnm: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdTnn; else goto cdTno;
       cdTnn: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdTno: // global
           I64[Sp - 24] = block_cdTmE_info;
           _sdT8Y::P64 = P64[R1 + 7];
           _sdT8Z::I64 = I64[R1 + 15];
           R1 = _sdT8Y::P64;
           P64[Sp - 16] = _sdT8Y::P64;
           I64[Sp - 8] = _sdT8Z::I64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTmE() //  [R1]
         { info_tbl: [(cdTmE,
                       label: block_cdTmE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTmE: // global
           I64[Sp] = block_cdTmG_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udTnI; else goto cdTmH;
       udTnI: // global
           call _cdTmG(R1) args: 0, res: 0, upd: 0;
       cdTmH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTmG() //  [R1]
         { info_tbl: [(cdTmG,
                       label: block_cdTmG_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTmG: // global
           I64[Sp - 16] = block_cdTmL_info;
           _sdT9b::P64 = P64[R1 + 15];
           _sdT9c::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdT9c::P64;
           P64[Sp] = _sdT9b::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udTnJ; else goto cdTmM;
       udTnJ: // global
           call _cdTmL(R1) args: 0, res: 0, upd: 0;
       cdTmM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTmL() //  [R1]
         { info_tbl: [(cdTmL,
                       label: block_cdTmL_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTmL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdTnt; else goto cdTns;
       cdTnt: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdTns: // global
           _sdT9f::I64 = I64[R1 + 7] - I64[Sp + 32];
           if (%MO_S_Ge_W64(_sdT9f::I64, 0)) goto cdTny; else goto cdTnB;
       cdTny: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sdT9f::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 39;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 32] = block_cdTnw_info;
           R2 = Hp - 23;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cdTnB: // global
           Hp = Hp - 48;
           I64[Sp - 8] = block_cdTmX_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdTnw() //  []
         { info_tbl: [(cdTnw,
                       label: block_cdTnw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTnw: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdTmX() //  [R1]
         { info_tbl: [(cdTmX,
                       label: block_cdTmX_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTmX: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdTnE; else goto cdTnD;
       cdTnE: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdTnD: // global
           I64[Hp - 104] = GHC.Types.I#_con_info;
           I64[Hp - 96] = I64[Sp + 40];
           I64[Hp - 88] = GHC.MVar.MVar_con_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = (,)_con_info;
           _cdTmZ::P64 = Hp - 103;
           P64[Hp - 64] = _cdTmZ::P64;
           P64[Hp - 56] = Hp - 87;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 71;
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = Hp - 46;
           I64[Sp + 16] = block_cdTn4_info;
           R2 = Hp - 23;
           _sdT9m::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 24] = _sdT9m::P64;
           P64[Sp + 40] = _cdTmZ::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTn4() //  []
         { info_tbl: [(cdTn4,
                       label: block_cdTn4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTn4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdTnH; else goto cdTnG;
       cdTnH: // global
           HpAlloc = 48;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdTnG: // global
           I64[Hp - 40] = sat_sdT9x_info;
           P64[Hp - 32] = P64[Sp + 16];
           _sdT9m::P64 = P64[Sp + 8];
           P64[Hp - 24] = _sdT9m::P64;
           P64[Hp - 16] = P64[Sp + 24];
           I64[Hp - 8] = sat_sdT9u_info;
           P64[Hp] = _sdT9m::P64;
           R2 = Hp - 38;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.QSemN.$wwaitQSemN_entry() //  [R2, R3]
         { info_tbl: [(cdTnO,
                       label: Control.Concurrent.QSemN.$wwaitQSemN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTnO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdTnP; else goto cdTnQ;
       cdTnP: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.$wwaitQSemN_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdTnQ: // global
           I64[Sp - 24] = block_cdTmx_info;
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdTmx() //  [R1]
         { info_tbl: [(cdTmx,
                       label: block_cdTmx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTmx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdTnT; else goto cdTnS;
       cdTnT: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdTnS: // global
           I64[Hp - 16] = io_sdT94_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           _cdTmz::P64 = Hp - 15;
           if (R1 == 0) goto cdTnN; else goto cdTnM;
       cdTnN: // global
           R1 = _cdTmz::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cdTnM: // global
           R1 = _cdTmz::P64;
           Sp = Sp + 24;
           call io_sdT94_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.00344067 UTC

[section ""data" . Control.Concurrent.QSemN.waitQSemN1_closure" {
     Control.Concurrent.QSemN.waitQSemN1_closure:
         const Control.Concurrent.QSemN.waitQSemN1_info;
 },
 Control.Concurrent.QSemN.waitQSemN1_entry() //  [R2, R3]
         { info_tbl: [(cdTpb,
                       label: Control.Concurrent.QSemN.waitQSemN1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTpb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdTpf; else goto cdTpg;
       cdTpf: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.waitQSemN1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdTpg: // global
           I64[Sp - 16] = block_cdTp8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udTpo; else goto cdTp9;
       udTpo: // global
           call _cdTp8(R1) args: 0, res: 0, upd: 0;
       cdTp9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTp8() //  [R1]
         { info_tbl: [(cdTp8,
                       label: block_cdTp8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTp8: // global
           I64[Sp] = block_cdTpe_info;
           _sdT9D::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdT9D::P64;
           if (R1 & 7 != 0) goto udTpn; else goto cdTpi;
       udTpn: // global
           call _cdTpe(R1) args: 0, res: 0, upd: 0;
       cdTpi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTpe() //  [R1]
         { info_tbl: [(cdTpe,
                       label: block_cdTpe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTpe: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Control.Concurrent.QSemN.$wwaitQSemN_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.011303824 UTC

[section ""data" . Control.Concurrent.QSemN.waitQSemN_closure" {
     Control.Concurrent.QSemN.waitQSemN_closure:
         const Control.Concurrent.QSemN.waitQSemN_info;
 },
 Control.Concurrent.QSemN.waitQSemN_entry() //  [R2, R3]
         { info_tbl: [(cdTpI,
                       label: Control.Concurrent.QSemN.waitQSemN_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTpI: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.QSemN.waitQSemN1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.014812062 UTC

[section ""data" . Control.Concurrent.QSemN.QSemN_closure" {
     Control.Concurrent.QSemN.QSemN_closure:
         const Control.Concurrent.QSemN.QSemN_info;
 },
 Control.Concurrent.QSemN.QSemN_entry() //  [R2]
         { info_tbl: [(cdTpU,
                       label: Control.Concurrent.QSemN.QSemN_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTpU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdTpY; else goto cdTpX;
       cdTpY: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Control.Concurrent.QSemN.QSemN_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdTpX: // global
           I64[Hp - 8] = Control.Concurrent.QSemN.QSemN_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.018669085 UTC

[Control.Concurrent.QSemN.QSemN_con_entry() //  [R1]
         { info_tbl: [(cdTq5,
                       label: Control.Concurrent.QSemN.QSemN_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,81,83,101,109,78,46,81,83,101,109,78]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTq5: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:09.022005631 UTC

[section ""relreadonly" . SdTaO_srt" {
     SdTaO_srt:
         const GHC.IO.failIO1_closure;
         const Control.Concurrent.QSemN.newQSemN2_closure;
         const Control.Concurrent.QSemN.newQSemN1_closure;
 }]

