
==================== Output Cmm ====================
2018-03-16 16:09:10.63438465 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:10.635898886 UTC

[section ""data" . Control.Concurrent.Chan.$WChItem_closure" {
     Control.Concurrent.Chan.$WChItem_closure:
         const Control.Concurrent.Chan.$WChItem_info;
 },
 Control.Concurrent.Chan.$WChItem_entry() //  [R2, R3]
         { info_tbl: [(cdV3N,
                       label: Control.Concurrent.Chan.$WChItem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV3N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdV3R; else goto cdV3S;
       cdV3R: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$WChItem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdV3S: // global
           I64[Sp - 16] = block_cdV3K_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udV3W; else goto cdV3L;
       udV3W: // global
           call _cdV3K(R1) args: 0, res: 0, upd: 0;
       cdV3L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV3K() //  [R1]
         { info_tbl: [(cdV3K,
                       label: block_cdV3K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV3K: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdV3V; else goto cdV3U;
       cdV3V: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdV3U: // global
           _sdV15::P64 = P64[R1 + 7];
           I64[Hp - 16] = Control.Concurrent.Chan.ChItem_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sdV15::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.637948241 UTC

[section ""data" . Control.Concurrent.Chan.$WChan_closure" {
     Control.Concurrent.Chan.$WChan_closure:
         const Control.Concurrent.Chan.$WChan_info;
 },
 Control.Concurrent.Chan.$WChan_entry() //  [R2, R3]
         { info_tbl: [(cdV44,
                       label: Control.Concurrent.Chan.$WChan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV44: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdV4d; else goto cdV4e;
       cdV4d: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$WChan_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdV4e: // global
           I64[Sp - 16] = block_cdV41_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udV4k; else goto cdV42;
       udV4k: // global
           call _cdV41(R1) args: 0, res: 0, upd: 0;
       cdV42: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV41() //  [R1]
         { info_tbl: [(cdV41,
                       label: block_cdV41_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV41: // global
           I64[Sp] = block_cdV47_info;
           _sdV19::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdV19::P64;
           if (R1 & 7 != 0) goto udV4j; else goto cdV48;
       udV4j: // global
           call _cdV47(R1) args: 0, res: 0, upd: 0;
       cdV48: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV47() //  [R1]
         { info_tbl: [(cdV47,
                       label: block_cdV47_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV47: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdV4i; else goto cdV4h;
       cdV4i: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdV4h: // global
           _sdV1b::P64 = P64[R1 + 7];
           I64[Hp - 16] = Control.Concurrent.Chan.Chan_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sdV1b::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.64097736 UTC

[section ""data" . Control.Concurrent.Chan.$fEqChan_$c==_closure" {
     Control.Concurrent.Chan.$fEqChan_$c==_closure:
         const Control.Concurrent.Chan.$fEqChan_$c==_info;
 },
 Control.Concurrent.Chan.$fEqChan_$c==_entry() //  [R2, R3]
         { info_tbl: [(cdV4s,
                       label: Control.Concurrent.Chan.$fEqChan_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV4s: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdV4w; else goto cdV4x;
       cdV4w: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$fEqChan_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdV4x: // global
           I64[Sp - 16] = block_cdV4p_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udV4V; else goto cdV4q;
       udV4V: // global
           call _cdV4p(R1) args: 0, res: 0, upd: 0;
       cdV4q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV4p() //  [R1]
         { info_tbl: [(cdV4p,
                       label: block_cdV4p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV4p: // global
           I64[Sp - 8] = block_cdV4v_info;
           _sdV1f::P64 = P64[R1 + 7];
           _sdV1g::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sdV1g::P64;
           P64[Sp + 8] = _sdV1f::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udV4U; else goto cdV4z;
       udV4U: // global
           call _cdV4v(R1) args: 0, res: 0, upd: 0;
       cdV4z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV4v() //  [R1]
         { info_tbl: [(cdV4v,
                       label: block_cdV4v_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV4v: // global
           if (P64[Sp + 16] == P64[R1 + 7]) goto cdV4P; else goto cdV4J;
       cdV4P: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdV4J: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.643981429 UTC

[section ""data" . Control.Concurrent.Chan.$fEqChan_$c/=_closure" {
     Control.Concurrent.Chan.$fEqChan_$c/=_closure:
         const Control.Concurrent.Chan.$fEqChan_$c/=_info;
 },
 Control.Concurrent.Chan.$fEqChan_$c/=_entry() //  [R2, R3]
         { info_tbl: [(cdV53,
                       label: Control.Concurrent.Chan.$fEqChan_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV53: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdV57; else goto cdV58;
       cdV57: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$fEqChan_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdV58: // global
           I64[Sp - 16] = block_cdV50_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udV5K; else goto cdV51;
       udV5K: // global
           call _cdV50(R1) args: 0, res: 0, upd: 0;
       cdV51: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV50() //  [R1]
         { info_tbl: [(cdV50,
                       label: block_cdV50_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV50: // global
           I64[Sp - 8] = block_cdV56_info;
           _sdV1p::P64 = P64[R1 + 7];
           _sdV1q::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sdV1q::P64;
           P64[Sp + 8] = _sdV1p::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udV5J; else goto cdV5a;
       udV5J: // global
           call _cdV56(R1) args: 0, res: 0, upd: 0;
       cdV5a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV56() //  [R1]
         { info_tbl: [(cdV56,
                       label: block_cdV56_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV56: // global
           if (P64[Sp + 16] != P64[R1 + 7]) goto cdV5z; else goto cdV5q;
       cdV5q: // global
           if (P64[Sp + 8] != P64[R1 + 15]) goto cdV5z; else goto cdV5F;
       cdV5z: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdV5F: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.645512741 UTC

[section ""data" . Control.Concurrent.Chan.$fEqChan_closure" {
     Control.Concurrent.Chan.$fEqChan_closure:
         const GHC.Classes.C:Eq_con_info;
         const Control.Concurrent.Chan.$fEqChan_$c==_closure+2;
         const Control.Concurrent.Chan.$fEqChan_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.646701009 UTC

[section ""data" . Control.Concurrent.Chan.newChan1_closure" {
     Control.Concurrent.Chan.newChan1_closure:
         const Control.Concurrent.Chan.newChan1_info;
 },
 Control.Concurrent.Chan.newChan1_entry() //  []
         { info_tbl: [(cdV61,
                       label: Control.Concurrent.Chan.newChan1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV61: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdV62; else goto cdV63;
       cdV62: // global
           R1 = Control.Concurrent.Chan.newChan1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdV63: // global
           I64[Sp - 8] = block_cdV5P_info;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdV5P() //  [R1]
         { info_tbl: [(cdV5P,
                       label: block_cdV5P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV5P: // global
           I64[Sp - 8] = block_cdV5R_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdV5R() //  [R1]
         { info_tbl: [(cdV5R,
                       label: block_cdV5R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV5R: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdV67; else goto cdV66;
       cdV67: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdV66: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_cdV5U_info;
           _cdV5T::P64 = Hp - 7;
           R2 = _cdV5T::P64;
           _sdV1C::P64 = R1;
           R1 = R1;
           P64[Sp] = _sdV1C::P64;
           P64[Sp + 8] = _cdV5T::P64;
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV5U() //  []
         { info_tbl: [(cdV5U,
                       label: block_cdV5U_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV5U: // global
           I64[Sp] = block_cdV5W_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdV5W() //  [R1]
         { info_tbl: [(cdV5W,
                       label: block_cdV5W_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV5W: // global
           I64[Sp] = block_cdV5Y_info;
           R2 = P64[Sp + 16];
           _sdV1H::P64 = R1;
           R1 = R1;
           P64[Sp + 16] = _sdV1H::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV5Y() //  []
         { info_tbl: [(cdV5Y,
                       label: block_cdV5Y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV5Y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdV6c; else goto cdV6b;
       cdV6c: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdV6b: // global
           I64[Hp - 16] = Control.Concurrent.Chan.Chan_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.648643004 UTC

[section ""data" . Control.Concurrent.Chan.newChan_closure" {
     Control.Concurrent.Chan.newChan_closure:
         const Control.Concurrent.Chan.newChan_info;
 },
 Control.Concurrent.Chan.newChan_entry() //  []
         { info_tbl: [(cdV6h,
                       label: Control.Concurrent.Chan.newChan_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV6h: // global
           call Control.Concurrent.Chan.newChan1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.65065961 UTC

[section ""data" . Control.Concurrent.Chan.$wwriteChan_closure" {
     Control.Concurrent.Chan.$wwriteChan_closure:
         const Control.Concurrent.Chan.$wwriteChan_info;
 },
 sat_sdV2e_entry() //  [R1]
         { info_tbl: [(cdV6F,
                       label: sat_sdV2e_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV6F: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdV6N; else goto cdV6O;
       cdV6N: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdV6O: // global
           I64[Sp - 32] = block_cdV6A_info;
           _sdV1L::P64 = P64[R1 + 7];
           _sdV1M::P64 = P64[R1 + 15];
           _sdV1Q::P64 = P64[R1 + 23];
           R1 = _sdV1L::P64;
           P64[Sp - 24] = _sdV1L::P64;
           P64[Sp - 16] = _sdV1M::P64;
           P64[Sp - 8] = _sdV1Q::P64;
           Sp = Sp - 32;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV6A() //  [R1]
         { info_tbl: [(cdV6A,
                       label: block_cdV6A_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV6A: // global
           I64[Sp] = block_cdV6C_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udV6Y; else goto cdV6D;
       udV6Y: // global
           call _cdV6C(R1) args: 0, res: 0, upd: 0;
       cdV6D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV6C() //  [R1]
         { info_tbl: [(cdV6C,
                       label: block_cdV6C_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV6C: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdV6S; else goto cdV6R;
       cdV6S: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdV6R: // global
           _sdV29::P64 = P64[R1 + 7];
           I64[Hp - 16] = Control.Concurrent.Chan.ChItem_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_cdV6J_info;
           R2 = Hp - 15;
           R1 = _sdV29::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV6J() //  []
         { info_tbl: [(cdV6J,
                       label: block_cdV6J_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV6J: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdV6V; else goto cdV6U;
       cdV6V: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdV6U: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_cdV6M_info;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV6M() //  []
         { info_tbl: [(cdV6M,
                       label: block_cdV6M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV6M: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.Chan.$wwriteChan_entry() //  [R2, R3, R4]
         { info_tbl: [(cdV72,
                       label: Control.Concurrent.Chan.$wwriteChan_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV72: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdV73; else goto cdV74;
       cdV73: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$wwriteChan_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdV74: // global
           I64[Sp - 24] = block_cdV6o_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdV6o() //  [R1]
         { info_tbl: [(cdV6o,
                       label: block_cdV6o_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV6o: // global
           I64[Sp - 8] = block_cdV6q_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdV6q() //  [R1]
         { info_tbl: [(cdV6q,
                       label: block_cdV6q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV6q: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdV78; else goto cdV77;
       cdV78: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdV77: // global
           _sdV1L::P64 = P64[Sp + 16];
           if (R1 == 0) goto cdV71; else goto cdV70;
       cdV71: // global
           I64[Hp - 24] = sat_sdV2e_info;
           P64[Hp - 16] = _sdV1L::P64;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cdV70: // global
           Hp = Hp - 32;
           I64[Sp] = block_cdV79_info;
           R1 = _sdV1L::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV79() //  [R1]
         { info_tbl: [(cdV79,
                       label: block_cdV79_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV79: // global
           I64[Sp] = block_cdV7b_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udV7u; else goto cdV7c;
       udV7u: // global
           call _cdV7b(R1) args: 0, res: 0, upd: 0;
       cdV7c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV7b() //  [R1]
         { info_tbl: [(cdV7b,
                       label: block_cdV7b_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV7b: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdV7o; else goto cdV7n;
       cdV7o: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdV7n: // global
           _sdV1Z::P64 = P64[R1 + 7];
           I64[Hp - 16] = Control.Concurrent.Chan.ChItem_con_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_cdV7h_info;
           R2 = Hp - 15;
           R1 = _sdV1Z::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV7h() //  []
         { info_tbl: [(cdV7h,
                       label: block_cdV7h_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV7h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdV7r; else goto cdV7q;
       cdV7r: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdV7q: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 24] = block_cdV7k_info;
           R2 = Hp - 7;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV7k() //  []
         { info_tbl: [(cdV7k,
                       label: block_cdV7k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV7k: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.656592034 UTC

[section ""data" . Control.Concurrent.Chan.writeChan1_closure" {
     Control.Concurrent.Chan.writeChan1_closure:
         const Control.Concurrent.Chan.writeChan1_info;
 },
 Control.Concurrent.Chan.writeChan1_entry() //  [R2, R3]
         { info_tbl: [(cdV7C,
                       label: Control.Concurrent.Chan.writeChan1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV7C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdV7D; else goto cdV7E;
       cdV7D: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.writeChan1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdV7E: // global
           I64[Sp - 16] = block_cdV7z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udV7I; else goto cdV7A;
       udV7I: // global
           call _cdV7z(R1) args: 0, res: 0, upd: 0;
       cdV7A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV7z() //  [R1]
         { info_tbl: [(cdV7z,
                       label: block_cdV7z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV7z: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call Control.Concurrent.Chan.$wwriteChan_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.658884274 UTC

[section ""data" . Control.Concurrent.Chan.writeChan_closure" {
     Control.Concurrent.Chan.writeChan_closure:
         const Control.Concurrent.Chan.writeChan_info;
 },
 Control.Concurrent.Chan.writeChan_entry() //  [R2, R3]
         { info_tbl: [(cdV7N,
                       label: Control.Concurrent.Chan.writeChan_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV7N: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.Chan.writeChan1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.660257526 UTC

[section ""data" . Control.Concurrent.Chan.writeList2Chan1_closure" {
     Control.Concurrent.Chan.writeList2Chan1_closure:
         const Control.Concurrent.Chan.writeList2Chan1_info;
 },
 Control.Concurrent.Chan.writeList2Chan1_entry() //  [R2, R3]
         { info_tbl: [(cdV7W,
                       label: Control.Concurrent.Chan.writeList2Chan1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV7W: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdV7X; else goto cdV7Y;
       cdV7X: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.writeList2Chan1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdV7Y: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cdV80() args: 0, res: 0, upd: 0;
     }
 },
 _cdV80() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV80: // global
           I64[Sp - 8] = block_cdV82_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udV8s; else goto cdV84;
       udV8s: // global
           call _cdV82(R1) args: 0, res: 0, upd: 0;
       cdV84: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV82() //  [R1]
         { info_tbl: [(cdV82,
                       label: block_cdV82_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV82: // global
           if (R1 & 7 == 1) goto cdV8a; else goto cdV8f;
       cdV8a: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdV8f: // global
           I64[Sp - 8] = block_cdV8d_info;
           _sdV2s::P64 = P64[R1 + 6];
           _sdV2t::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sdV2t::P64;
           P64[Sp + 16] = _sdV2s::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udV8t; else goto cdV8g;
       udV8t: // global
           call _cdV8d(R1) args: 0, res: 0, upd: 0;
       cdV8g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV8d() //  [R1]
         { info_tbl: [(cdV8d,
                       label: block_cdV8d_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV8d: // global
           I64[Sp] = block_cdV8k_info;
           R4 = P64[Sp + 24];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Concurrent.Chan.$wwriteChan_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdV8k() //  []
         { info_tbl: [(cdV8k,
                       label: block_cdV8k_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV8k: // global
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cdV80() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.662121315 UTC

[section ""data" . Control.Concurrent.Chan.writeList2Chan_closure" {
     Control.Concurrent.Chan.writeList2Chan_closure:
         const Control.Concurrent.Chan.writeList2Chan_info;
 },
 Control.Concurrent.Chan.writeList2Chan_entry() //  [R2, R3]
         { info_tbl: [(cdV8z,
                       label: Control.Concurrent.Chan.writeList2Chan_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV8z: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.Chan.writeList2Chan1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.664201234 UTC

[section ""data" . Control.Concurrent.Chan.$wreadChan_closure" {
     Control.Concurrent.Chan.$wreadChan_closure:
         const Control.Concurrent.Chan.$wreadChan_info;
 },
 sat_sdV30_entry() //  [R1, R2]
         { info_tbl: [(cdV8W,
                       label: sat_sdV30_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV8W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdV8X; else goto cdV8Y;
       cdV8X: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdV8Y: // global
           I64[Sp - 16] = block_cdV8U_info;
           _sdV2X::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdV2X::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV8U() //  []
         { info_tbl: [(cdV8U,
                       label: block_cdV8U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV8U: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdV2W_entry() //  [R1]
         { info_tbl: [(cdV98,
                       label: sat_sdV2W_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV98: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdV9k; else goto cdV9l;
       cdV9k: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdV9l: // global
           I64[Sp - 8] = block_cdV95_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udV9r; else goto cdV96;
       udV9r: // global
           call _cdV95(R1) args: 0, res: 0, upd: 0;
       cdV96: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV95() //  [R1]
         { info_tbl: [(cdV95,
                       label: block_cdV95_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV95: // global
           I64[Sp] = block_cdV9b_info;
           R1 = P64[R1 + 7];
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV9b() //  [R1]
         { info_tbl: [(cdV9b,
                       label: block_cdV9b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV9b: // global
           I64[Sp] = block_cdV9d_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udV9s; else goto cdV9e;
       udV9s: // global
           call _cdV9d(R1) args: 0, res: 0, upd: 0;
       cdV9e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV9d() //  [R1]
         { info_tbl: [(cdV9d,
                       label: block_cdV9d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV9d: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdV9q; else goto cdV9p;
       cdV9q: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdV9p: // global
           _sdV2S::P64 = P64[R1 + 7];
           _sdV2T::P64 = P64[R1 + 15];
           I64[Hp - 32] = GHC.MVar.MVar_con_info;
           P64[Hp - 24] = _sdV2T::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sdV2S::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io1_sdV2G_entry() //  [R1]
         { info_tbl: [(cdV9y,
                       label: io1_sdV2G_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV9y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdV9C; else goto cdV9D;
       cdV9C: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdV9D: // global
           I64[Sp - 16] = block_cdV8N_info;
           _sdV2A::P64 = P64[R1 + 7];
           R1 = _sdV2A::P64;
           P64[Sp - 8] = _sdV2A::P64;
           Sp = Sp - 16;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV8N() //  [R1]
         { info_tbl: [(cdV8N,
                       label: block_cdV8N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV8N: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdV9G; else goto cdV9F;
       cdV9G: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdV9F: // global
           I64[Hp - 32] = sat_sdV30_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdV2W_info;
           P64[Hp] = R1;
           I64[Sp] = block_cdV9t_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV9t() //  [R1]
         { info_tbl: [(cdV9t,
                       label: block_cdV9t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV9t: // global
           I64[Sp] = block_cdV9v_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udV9L; else goto cdV9w;
       udV9L: // global
           call _cdV9v(R1) args: 0, res: 0, upd: 0;
       cdV9w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV9v() //  [R1]
         { info_tbl: [(cdV9v,
                       label: block_cdV9v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV9v: // global
           I64[Sp] = block_cdV9B_info;
           R2 = P64[R1 + 7];
           _sdV36::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdV36::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdV9B() //  []
         { info_tbl: [(cdV9B,
                       label: block_cdV9B_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV9B: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.Chan.$wreadChan_entry() //  [R2, R3]
         { info_tbl: [(cdV9Q,
                       label: Control.Concurrent.Chan.$wreadChan_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV9Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdV9R; else goto cdV9S;
       cdV9R: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$wreadChan_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdV9S: // global
           I64[Sp - 16] = block_cdV8G_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdV8G() //  [R1]
         { info_tbl: [(cdV8G,
                       label: block_cdV8G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdV8G: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdV9V; else goto cdV9U;
       cdV9V: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdV9U: // global
           I64[Hp - 8] = io1_sdV2G_info;
           P64[Hp] = P64[Sp + 8];
           _cdV8I::P64 = Hp - 7;
           if (R1 == 0) goto cdV9P; else goto cdV9O;
       cdV9P: // global
           R1 = _cdV8I::P64;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cdV9O: // global
           R1 = _cdV8I::P64;
           Sp = Sp + 16;
           call io1_sdV2G_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.668257296 UTC

[section ""data" . Control.Concurrent.Chan.readChan1_closure" {
     Control.Concurrent.Chan.readChan1_closure:
         const Control.Concurrent.Chan.readChan1_info;
 },
 Control.Concurrent.Chan.readChan1_entry() //  [R2]
         { info_tbl: [(cdVa3,
                       label: Control.Concurrent.Chan.readChan1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVa3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdVa4; else goto cdVa5;
       cdVa4: // global
           R2 = R2;
           R1 = Control.Concurrent.Chan.readChan1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdVa5: // global
           I64[Sp - 8] = block_cdVa0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVa9; else goto cdVa1;
       udVa9: // global
           call _cdVa0(R1) args: 0, res: 0, upd: 0;
       cdVa1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVa0() //  [R1]
         { info_tbl: [(cdVa0,
                       label: block_cdVa0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVa0: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Control.Concurrent.Chan.$wreadChan_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.670167721 UTC

[section ""data" . Control.Concurrent.Chan.readChan_closure" {
     Control.Concurrent.Chan.readChan_closure:
         const Control.Concurrent.Chan.readChan_info;
 },
 Control.Concurrent.Chan.readChan_entry() //  [R2]
         { info_tbl: [(cdVae,
                       label: Control.Concurrent.Chan.readChan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVae: // global
           R2 = R2;
           call Control.Concurrent.Chan.readChan1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.671751307 UTC

[section ""data" . Control.Concurrent.Chan.getChanContents1_closure" {
     Control.Concurrent.Chan.getChanContents1_closure:
         const Control.Concurrent.Chan.getChanContents1_info;
 },
 sat_sdV3s_entry() //  [R1]
         { info_tbl: [(cdVav,
                       label: sat_sdV3s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVav: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVaD; else goto cdVaE;
       cdVaD: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdVaE: // global
           I64[Sp - 16] = block_cdVaq_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVaq() //  []
         { info_tbl: [(cdVaq,
                       label: block_cdVaq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVaq: // global
           _sdV3e::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdVas_info;
           R1 = _sdV3e::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udVaL; else goto cdVat;
       udVaL: // global
           call _cdVas(R1) args: 0, res: 0, upd: 0;
       cdVat: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVas() //  [R1]
         { info_tbl: [(cdVas,
                       label: block_cdVas_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVas: // global
           I64[Sp - 8] = block_cdVay_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Control.Concurrent.Chan.$wreadChan_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdVay() //  [R1]
         { info_tbl: [(cdVay,
                       label: block_cdVay_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVay: // global
           I64[Sp] = block_cdVaA_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call Control.Concurrent.Chan.getChanContents1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdVaA() //  [R1]
         { info_tbl: [(cdVaA,
                       label: block_cdVaA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVaA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVaK; else goto cdVaJ;
       cdVaK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVaJ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.Chan.getChanContents1_entry() //  [R2]
         { info_tbl: [(cdVaM,
                       label: Control.Concurrent.Chan.getChanContents1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVaM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdVaQ; else goto cdVaP;
       cdVaQ: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Control.Concurrent.Chan.getChanContents1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdVaP: // global
           I64[Hp - 8] = sat_sdV3s_info;
           P64[Hp] = R2;
           R2 = Hp - 7;
           call GHC.IO.Unsafe.unsafeDupableInterleaveIO_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.674239044 UTC

[section ""data" . Control.Concurrent.Chan.getChanContents_closure" {
     Control.Concurrent.Chan.getChanContents_closure:
         const Control.Concurrent.Chan.getChanContents_info;
 },
 Control.Concurrent.Chan.getChanContents_entry() //  [R2]
         { info_tbl: [(cdVaV,
                       label: Control.Concurrent.Chan.getChanContents_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVaV: // global
           R2 = R2;
           call Control.Concurrent.Chan.getChanContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.675585258 UTC

[section ""data" . Control.Concurrent.Chan.dupChan1_closure" {
     Control.Concurrent.Chan.dupChan1_closure:
         const Control.Concurrent.Chan.dupChan1_info;
 },
 Control.Concurrent.Chan.dupChan1_entry() //  [R2]
         { info_tbl: [(cdVb5,
                       label: Control.Concurrent.Chan.dupChan1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVb5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdVbf; else goto cdVbg;
       cdVbf: // global
           R2 = R2;
           R1 = Control.Concurrent.Chan.dupChan1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdVbg: // global
           I64[Sp - 8] = block_cdVb2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVbn; else goto cdVb3;
       udVbn: // global
           call _cdVb2(R1) args: 0, res: 0, upd: 0;
       cdVb3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVb2() //  [R1]
         { info_tbl: [(cdVb2,
                       label: block_cdVb2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVb2: // global
           I64[Sp - 8] = block_cdVb8_info;
           _sdV3x::P64 = P64[R1 + 15];
           R1 = _sdV3x::P64;
           P64[Sp] = _sdV3x::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVb8() //  [R1]
         { info_tbl: [(cdVb8,
                       label: block_cdVb8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVb8: // global
           I64[Sp - 8] = block_cdVba_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVba() //  [R1]
         { info_tbl: [(cdVba,
                       label: block_cdVba_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVba: // global
           I64[Sp] = block_cdVbc_info;
           R2 = P64[Sp + 8];
           _sdV3D::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _sdV3D::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVbc() //  []
         { info_tbl: [(cdVbc,
                       label: block_cdVbc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVbc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVbm; else goto cdVbl;
       cdVbm: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdVbl: // global
           I64[Hp - 16] = Control.Concurrent.Chan.Chan_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.677556756 UTC

[section ""data" . Control.Concurrent.Chan.dupChan_closure" {
     Control.Concurrent.Chan.dupChan_closure:
         const Control.Concurrent.Chan.dupChan_info;
 },
 Control.Concurrent.Chan.dupChan_entry() //  [R2]
         { info_tbl: [(cdVbs,
                       label: Control.Concurrent.Chan.dupChan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVbs: // global
           R2 = R2;
           call Control.Concurrent.Chan.dupChan1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.678343337 UTC

[section ""cstring" . Control.Concurrent.Chan.$trModule4_bytes" {
     Control.Concurrent.Chan.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.678977071 UTC

[section ""data" . Control.Concurrent.Chan.$trModule3_closure" {
     Control.Concurrent.Chan.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.679615984 UTC

[section ""cstring" . Control.Concurrent.Chan.$trModule2_bytes" {
     Control.Concurrent.Chan.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,67,104,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.680267962 UTC

[section ""data" . Control.Concurrent.Chan.$trModule1_closure" {
     Control.Concurrent.Chan.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.680910426 UTC

[section ""data" . Control.Concurrent.Chan.$trModule_closure" {
     Control.Concurrent.Chan.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.Chan.$trModule3_closure+1;
         const Control.Concurrent.Chan.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.681640962 UTC

[section ""data" . $krep_rdV0R_closure" {
     $krep_rdV0R_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.682288645 UTC

[section ""cstring" . Control.Concurrent.Chan.$tcChItem2_bytes" {
     Control.Concurrent.Chan.$tcChItem2_bytes:
         I8[] [67,104,73,116,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.682932904 UTC

[section ""data" . Control.Concurrent.Chan.$tcChItem1_closure" {
     Control.Concurrent.Chan.$tcChItem1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$tcChItem2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.68358595 UTC

[section ""data" . Control.Concurrent.Chan.$tcChItem_closure" {
     Control.Concurrent.Chan.$tcChItem_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.Chan.$trModule_closure+1;
         const Control.Concurrent.Chan.$tcChItem1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 6476193138296826625;
         const 14259015418390681910;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.684288873 UTC

[section ""data" . $krep1_rdV0S_closure" {
     $krep1_rdV0S_closure:
         const :_con_info;
         const $krep_rdV0R_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.684977359 UTC

[section ""data" . $krep2_rdV0T_closure" {
     $krep2_rdV0T_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Concurrent.Chan.$tcChItem_closure+1;
         const $krep1_rdV0S_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.685669986 UTC

[section ""data" . $krep3_rdV0U_closure" {
     $krep3_rdV0U_closure:
         const :_con_info;
         const $krep2_rdV0T_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.686333819 UTC

[section ""data" . $krep4_rdV0V_closure" {
     $krep4_rdV0V_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep3_rdV0U_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.687032673 UTC

[section ""data" . $krep5_rdV0W_closure" {
     $krep5_rdV0W_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rdV0V_closure+1;
         const $krep2_rdV0T_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.687727374 UTC

[section ""data" . Control.Concurrent.Chan.$tc'ChItem1_closure" {
     Control.Concurrent.Chan.$tc'ChItem1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rdV0R_closure+2;
         const $krep5_rdV0W_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.688443708 UTC

[section ""cstring" . Control.Concurrent.Chan.$tc'ChItem3_bytes" {
     Control.Concurrent.Chan.$tc'ChItem3_bytes:
         I8[] [39,67,104,73,116,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.68916197 UTC

[section ""data" . Control.Concurrent.Chan.$tc'ChItem2_closure" {
     Control.Concurrent.Chan.$tc'ChItem2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$tc'ChItem3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.689924464 UTC

[section ""data" . Control.Concurrent.Chan.$tc'ChItem_closure" {
     Control.Concurrent.Chan.$tc'ChItem_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.Chan.$trModule_closure+1;
         const Control.Concurrent.Chan.$tc'ChItem2_closure+1;
         const Control.Concurrent.Chan.$tc'ChItem1_closure+4;
         const 10690021181819663847;
         const 14453345100680315478;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.690685104 UTC

[section ""data" . $krep6_rdV0X_closure" {
     $krep6_rdV0X_closure:
         const :_con_info;
         const $krep4_rdV0V_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.691435806 UTC

[section ""data" . $krep7_rdV0Y_closure" {
     $krep7_rdV0Y_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep6_rdV0X_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.69424536 UTC

[section ""cstring" . Control.Concurrent.Chan.$tcChan2_bytes" {
     Control.Concurrent.Chan.$tcChan2_bytes:
         I8[] [67,104,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.694872014 UTC

[section ""data" . Control.Concurrent.Chan.$tcChan1_closure" {
     Control.Concurrent.Chan.$tcChan1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$tcChan2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.695534372 UTC

[section ""data" . Control.Concurrent.Chan.$tcChan_closure" {
     Control.Concurrent.Chan.$tcChan_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.Chan.$trModule_closure+1;
         const Control.Concurrent.Chan.$tcChan1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 8939098401262630739;
         const 12846644923708574499;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.696165996 UTC

[section ""data" . $krep8_rdV0Z_closure" {
     $krep8_rdV0Z_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Concurrent.Chan.$tcChan_closure+1;
         const $krep1_rdV0S_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.696811067 UTC

[section ""data" . $krep9_rdV10_closure" {
     $krep9_rdV10_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rdV0Y_closure+1;
         const $krep8_rdV0Z_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.697484105 UTC

[section ""data" . Control.Concurrent.Chan.$tc'Chan1_closure" {
     Control.Concurrent.Chan.$tc'Chan1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rdV0Y_closure+1;
         const $krep9_rdV10_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.698059699 UTC

[section ""cstring" . Control.Concurrent.Chan.$tc'Chan3_bytes" {
     Control.Concurrent.Chan.$tc'Chan3_bytes:
         I8[] [39,67,104,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.698653222 UTC

[section ""data" . Control.Concurrent.Chan.$tc'Chan2_closure" {
     Control.Concurrent.Chan.$tc'Chan2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$tc'Chan3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.699256927 UTC

[section ""data" . Control.Concurrent.Chan.$tc'Chan_closure" {
     Control.Concurrent.Chan.$tc'Chan_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.Chan.$trModule_closure+1;
         const Control.Concurrent.Chan.$tc'Chan2_closure+1;
         const Control.Concurrent.Chan.$tc'Chan1_closure+4;
         const 735828590425899369;
         const 13090399282914560069;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.70022325 UTC

[section ""data" . Control.Concurrent.Chan.ChItem_closure" {
     Control.Concurrent.Chan.ChItem_closure:
         const Control.Concurrent.Chan.ChItem_info;
 },
 Control.Concurrent.Chan.ChItem_entry() //  [R2, R3]
         { info_tbl: [(cdVbA,
                       label: Control.Concurrent.Chan.ChItem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVbA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVbE; else goto cdVbD;
       cdVbE: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.ChItem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVbD: // global
           I64[Hp - 16] = Control.Concurrent.Chan.ChItem_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.701340384 UTC

[section ""data" . Control.Concurrent.Chan.Chan_closure" {
     Control.Concurrent.Chan.Chan_closure:
         const Control.Concurrent.Chan.Chan_info;
 },
 Control.Concurrent.Chan.Chan_entry() //  [R2, R3]
         { info_tbl: [(cdVbK,
                       label: Control.Concurrent.Chan.Chan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVbK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVbO; else goto cdVbN;
       cdVbO: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.Chan_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVbN: // global
           I64[Hp - 16] = Control.Concurrent.Chan.Chan_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.702300606 UTC

[Control.Concurrent.Chan.ChItem_con_entry() //  [R1]
         { info_tbl: [(cdVbP,
                       label: Control.Concurrent.Chan.ChItem_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,67,104,97,110,46,67,104,73,116,101,109]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVbP: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.703103934 UTC

[Control.Concurrent.Chan.Chan_con_entry() //  [R1]
         { info_tbl: [(cdVbQ,
                       label: Control.Concurrent.Chan.Chan_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,67,104,97,110,46,67,104,97,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVbQ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.703833626 UTC

[section ""relreadonly" . SdVbR_srt" { SdVbR_srt:
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.704410974 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:10.705436138 UTC

[section ""data" . Control.Concurrent.Chan.$WChItem_closure" {
     Control.Concurrent.Chan.$WChItem_closure:
         const Control.Concurrent.Chan.$WChItem_info;
 },
 Control.Concurrent.Chan.$WChItem_entry() //  [R2, R3]
         { info_tbl: [(cdVbZ,
                       label: Control.Concurrent.Chan.$WChItem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVbZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVc3; else goto cdVc4;
       cdVc3: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$WChItem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVc4: // global
           I64[Sp - 16] = block_cdVbW_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udVc8; else goto cdVbX;
       udVc8: // global
           call _cdVbW(R1) args: 0, res: 0, upd: 0;
       cdVbX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVbW() //  [R1]
         { info_tbl: [(cdVbW,
                       label: block_cdVbW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVbW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVc7; else goto cdVc6;
       cdVc7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVc6: // global
           _sdV15::P64 = P64[R1 + 7];
           I64[Hp - 16] = Control.Concurrent.Chan.ChItem_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sdV15::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.707066209 UTC

[section ""data" . Control.Concurrent.Chan.$WChan_closure" {
     Control.Concurrent.Chan.$WChan_closure:
         const Control.Concurrent.Chan.$WChan_info;
 },
 Control.Concurrent.Chan.$WChan_entry() //  [R2, R3]
         { info_tbl: [(cdVcg,
                       label: Control.Concurrent.Chan.$WChan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVcg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVcp; else goto cdVcq;
       cdVcp: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$WChan_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVcq: // global
           I64[Sp - 16] = block_cdVcd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udVcw; else goto cdVce;
       udVcw: // global
           call _cdVcd(R1) args: 0, res: 0, upd: 0;
       cdVce: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVcd() //  [R1]
         { info_tbl: [(cdVcd,
                       label: block_cdVcd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVcd: // global
           I64[Sp] = block_cdVcj_info;
           _sdV19::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdV19::P64;
           if (R1 & 7 != 0) goto udVcv; else goto cdVck;
       udVcv: // global
           call _cdVcj(R1) args: 0, res: 0, upd: 0;
       cdVck: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVcj() //  [R1]
         { info_tbl: [(cdVcj,
                       label: block_cdVcj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVcj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVcu; else goto cdVct;
       cdVcu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVct: // global
           _sdV1b::P64 = P64[R1 + 7];
           I64[Hp - 16] = Control.Concurrent.Chan.Chan_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sdV1b::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.708997407 UTC

[section ""data" . Control.Concurrent.Chan.$fEqChan_$c==_closure" {
     Control.Concurrent.Chan.$fEqChan_$c==_closure:
         const Control.Concurrent.Chan.$fEqChan_$c==_info;
 },
 Control.Concurrent.Chan.$fEqChan_$c==_entry() //  [R2, R3]
         { info_tbl: [(cdVcE,
                       label: Control.Concurrent.Chan.$fEqChan_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVcE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdVcI; else goto cdVcJ;
       cdVcI: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$fEqChan_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVcJ: // global
           I64[Sp - 16] = block_cdVcB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udVd7; else goto cdVcC;
       udVd7: // global
           call _cdVcB(R1) args: 0, res: 0, upd: 0;
       cdVcC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVcB() //  [R1]
         { info_tbl: [(cdVcB,
                       label: block_cdVcB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVcB: // global
           I64[Sp - 8] = block_cdVcH_info;
           _sdV1f::P64 = P64[R1 + 7];
           _sdV1g::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sdV1g::P64;
           P64[Sp + 8] = _sdV1f::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVd6; else goto cdVcL;
       udVd6: // global
           call _cdVcH(R1) args: 0, res: 0, upd: 0;
       cdVcL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVcH() //  [R1]
         { info_tbl: [(cdVcH,
                       label: block_cdVcH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVcH: // global
           if (P64[Sp + 16] == P64[R1 + 7]) goto cdVd1; else goto cdVcV;
       cdVd1: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdVcV: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.711644733 UTC

[section ""data" . Control.Concurrent.Chan.$fEqChan_$c/=_closure" {
     Control.Concurrent.Chan.$fEqChan_$c/=_closure:
         const Control.Concurrent.Chan.$fEqChan_$c/=_info;
 },
 Control.Concurrent.Chan.$fEqChan_$c/=_entry() //  [R2, R3]
         { info_tbl: [(cdVdf,
                       label: Control.Concurrent.Chan.$fEqChan_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVdf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdVdj; else goto cdVdk;
       cdVdj: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$fEqChan_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVdk: // global
           I64[Sp - 16] = block_cdVdc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udVdW; else goto cdVdd;
       udVdW: // global
           call _cdVdc(R1) args: 0, res: 0, upd: 0;
       cdVdd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVdc() //  [R1]
         { info_tbl: [(cdVdc,
                       label: block_cdVdc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVdc: // global
           I64[Sp - 8] = block_cdVdi_info;
           _sdV1p::P64 = P64[R1 + 7];
           _sdV1q::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sdV1q::P64;
           P64[Sp + 8] = _sdV1p::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVdV; else goto cdVdm;
       udVdV: // global
           call _cdVdi(R1) args: 0, res: 0, upd: 0;
       cdVdm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVdi() //  [R1]
         { info_tbl: [(cdVdi,
                       label: block_cdVdi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVdi: // global
           if (P64[Sp + 16] != P64[R1 + 7]) goto cdVdL; else goto cdVdC;
       cdVdC: // global
           if (P64[Sp + 8] != P64[R1 + 15]) goto cdVdL; else goto cdVdR;
       cdVdL: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdVdR: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.713112623 UTC

[section ""data" . Control.Concurrent.Chan.$fEqChan_closure" {
     Control.Concurrent.Chan.$fEqChan_closure:
         const GHC.Classes.C:Eq_con_info;
         const Control.Concurrent.Chan.$fEqChan_$c==_closure+2;
         const Control.Concurrent.Chan.$fEqChan_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.714317256 UTC

[section ""data" . Control.Concurrent.Chan.newChan1_closure" {
     Control.Concurrent.Chan.newChan1_closure:
         const Control.Concurrent.Chan.newChan1_info;
 },
 Control.Concurrent.Chan.newChan1_entry() //  []
         { info_tbl: [(cdVed,
                       label: Control.Concurrent.Chan.newChan1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVed: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdVee; else goto cdVef;
       cdVee: // global
           R1 = Control.Concurrent.Chan.newChan1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdVef: // global
           I64[Sp - 8] = block_cdVe1_info;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVe1() //  [R1]
         { info_tbl: [(cdVe1,
                       label: block_cdVe1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVe1: // global
           I64[Sp - 8] = block_cdVe3_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVe3() //  [R1]
         { info_tbl: [(cdVe3,
                       label: block_cdVe3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVe3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdVej; else goto cdVei;
       cdVej: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVei: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_cdVe6_info;
           _cdVe5::P64 = Hp - 7;
           R2 = _cdVe5::P64;
           _sdV1C::P64 = R1;
           R1 = R1;
           P64[Sp] = _sdV1C::P64;
           P64[Sp + 8] = _cdVe5::P64;
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVe6() //  []
         { info_tbl: [(cdVe6,
                       label: block_cdVe6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVe6: // global
           I64[Sp] = block_cdVe8_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVe8() //  [R1]
         { info_tbl: [(cdVe8,
                       label: block_cdVe8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVe8: // global
           I64[Sp] = block_cdVea_info;
           R2 = P64[Sp + 16];
           _sdV1H::P64 = R1;
           R1 = R1;
           P64[Sp + 16] = _sdV1H::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVea() //  []
         { info_tbl: [(cdVea,
                       label: block_cdVea_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVea: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVeo; else goto cdVen;
       cdVeo: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdVen: // global
           I64[Hp - 16] = Control.Concurrent.Chan.Chan_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.716120329 UTC

[section ""data" . Control.Concurrent.Chan.newChan_closure" {
     Control.Concurrent.Chan.newChan_closure:
         const Control.Concurrent.Chan.newChan_info;
 },
 Control.Concurrent.Chan.newChan_entry() //  []
         { info_tbl: [(cdVet,
                       label: Control.Concurrent.Chan.newChan_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVet: // global
           call Control.Concurrent.Chan.newChan1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.718086854 UTC

[section ""data" . Control.Concurrent.Chan.$wwriteChan_closure" {
     Control.Concurrent.Chan.$wwriteChan_closure:
         const Control.Concurrent.Chan.$wwriteChan_info;
 },
 sat_sdV2e_entry() //  [R1]
         { info_tbl: [(cdVeR,
                       label: sat_sdV2e_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVeR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdVeZ; else goto cdVf0;
       cdVeZ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdVf0: // global
           I64[Sp - 32] = block_cdVeM_info;
           _sdV1L::P64 = P64[R1 + 7];
           _sdV1M::P64 = P64[R1 + 15];
           _sdV1Q::P64 = P64[R1 + 23];
           R1 = _sdV1L::P64;
           P64[Sp - 24] = _sdV1L::P64;
           P64[Sp - 16] = _sdV1M::P64;
           P64[Sp - 8] = _sdV1Q::P64;
           Sp = Sp - 32;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVeM() //  [R1]
         { info_tbl: [(cdVeM,
                       label: block_cdVeM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVeM: // global
           I64[Sp] = block_cdVeO_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udVfa; else goto cdVeP;
       udVfa: // global
           call _cdVeO(R1) args: 0, res: 0, upd: 0;
       cdVeP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVeO() //  [R1]
         { info_tbl: [(cdVeO,
                       label: block_cdVeO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVeO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVf4; else goto cdVf3;
       cdVf4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVf3: // global
           _sdV29::P64 = P64[R1 + 7];
           I64[Hp - 16] = Control.Concurrent.Chan.ChItem_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_cdVeV_info;
           R2 = Hp - 15;
           R1 = _sdV29::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVeV() //  []
         { info_tbl: [(cdVeV,
                       label: block_cdVeV_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVeV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdVf7; else goto cdVf6;
       cdVf7: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdVf6: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_cdVeY_info;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVeY() //  []
         { info_tbl: [(cdVeY,
                       label: block_cdVeY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVeY: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.Chan.$wwriteChan_entry() //  [R2, R3, R4]
         { info_tbl: [(cdVfe,
                       label: Control.Concurrent.Chan.$wwriteChan_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVfe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdVff; else goto cdVfg;
       cdVff: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$wwriteChan_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVfg: // global
           I64[Sp - 24] = block_cdVeA_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVeA() //  [R1]
         { info_tbl: [(cdVeA,
                       label: block_cdVeA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVeA: // global
           I64[Sp - 8] = block_cdVeC_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVeC() //  [R1]
         { info_tbl: [(cdVeC,
                       label: block_cdVeC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVeC: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdVfk; else goto cdVfj;
       cdVfk: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdVfj: // global
           _sdV1L::P64 = P64[Sp + 16];
           if (R1 == 0) goto cdVfd; else goto cdVfc;
       cdVfd: // global
           I64[Hp - 24] = sat_sdV2e_info;
           P64[Hp - 16] = _sdV1L::P64;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cdVfc: // global
           Hp = Hp - 32;
           I64[Sp] = block_cdVfl_info;
           R1 = _sdV1L::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVfl() //  [R1]
         { info_tbl: [(cdVfl,
                       label: block_cdVfl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVfl: // global
           I64[Sp] = block_cdVfn_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udVfG; else goto cdVfo;
       udVfG: // global
           call _cdVfn(R1) args: 0, res: 0, upd: 0;
       cdVfo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVfn() //  [R1]
         { info_tbl: [(cdVfn,
                       label: block_cdVfn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVfn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVfA; else goto cdVfz;
       cdVfA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVfz: // global
           _sdV1Z::P64 = P64[R1 + 7];
           I64[Hp - 16] = Control.Concurrent.Chan.ChItem_con_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_cdVft_info;
           R2 = Hp - 15;
           R1 = _sdV1Z::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVft() //  []
         { info_tbl: [(cdVft,
                       label: block_cdVft_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVft: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdVfD; else goto cdVfC;
       cdVfD: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdVfC: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 24] = block_cdVfw_info;
           R2 = Hp - 7;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVfw() //  []
         { info_tbl: [(cdVfw,
                       label: block_cdVfw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVfw: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.721874886 UTC

[section ""data" . Control.Concurrent.Chan.writeChan1_closure" {
     Control.Concurrent.Chan.writeChan1_closure:
         const Control.Concurrent.Chan.writeChan1_info;
 },
 Control.Concurrent.Chan.writeChan1_entry() //  [R2, R3]
         { info_tbl: [(cdVfO,
                       label: Control.Concurrent.Chan.writeChan1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVfO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVfP; else goto cdVfQ;
       cdVfP: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.writeChan1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVfQ: // global
           I64[Sp - 16] = block_cdVfL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udVfU; else goto cdVfM;
       udVfU: // global
           call _cdVfL(R1) args: 0, res: 0, upd: 0;
       cdVfM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVfL() //  [R1]
         { info_tbl: [(cdVfL,
                       label: block_cdVfL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVfL: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call Control.Concurrent.Chan.$wwriteChan_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.723206808 UTC

[section ""data" . Control.Concurrent.Chan.writeChan_closure" {
     Control.Concurrent.Chan.writeChan_closure:
         const Control.Concurrent.Chan.writeChan_info;
 },
 Control.Concurrent.Chan.writeChan_entry() //  [R2, R3]
         { info_tbl: [(cdVfZ,
                       label: Control.Concurrent.Chan.writeChan_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVfZ: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.Chan.writeChan1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.724572381 UTC

[section ""data" . Control.Concurrent.Chan.writeList2Chan1_closure" {
     Control.Concurrent.Chan.writeList2Chan1_closure:
         const Control.Concurrent.Chan.writeList2Chan1_info;
 },
 Control.Concurrent.Chan.writeList2Chan1_entry() //  [R2, R3]
         { info_tbl: [(cdVg8,
                       label: Control.Concurrent.Chan.writeList2Chan1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVg8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdVg9; else goto cdVga;
       cdVg9: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.writeList2Chan1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVga: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cdVgc() args: 0, res: 0, upd: 0;
     }
 },
 _cdVgc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVgc: // global
           I64[Sp - 8] = block_cdVge_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVgE; else goto cdVgg;
       udVgE: // global
           call _cdVge(R1) args: 0, res: 0, upd: 0;
       cdVgg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVge() //  [R1]
         { info_tbl: [(cdVge,
                       label: block_cdVge_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVge: // global
           if (R1 & 7 == 1) goto cdVgm; else goto cdVgr;
       cdVgm: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdVgr: // global
           I64[Sp - 8] = block_cdVgp_info;
           _sdV2s::P64 = P64[R1 + 6];
           _sdV2t::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sdV2t::P64;
           P64[Sp + 16] = _sdV2s::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVgF; else goto cdVgs;
       udVgF: // global
           call _cdVgp(R1) args: 0, res: 0, upd: 0;
       cdVgs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVgp() //  [R1]
         { info_tbl: [(cdVgp,
                       label: block_cdVgp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVgp: // global
           I64[Sp] = block_cdVgw_info;
           R4 = P64[Sp + 24];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Concurrent.Chan.$wwriteChan_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdVgw() //  []
         { info_tbl: [(cdVgw,
                       label: block_cdVgw_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVgw: // global
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cdVgc() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.726489726 UTC

[section ""data" . Control.Concurrent.Chan.writeList2Chan_closure" {
     Control.Concurrent.Chan.writeList2Chan_closure:
         const Control.Concurrent.Chan.writeList2Chan_info;
 },
 Control.Concurrent.Chan.writeList2Chan_entry() //  [R2, R3]
         { info_tbl: [(cdVgL,
                       label: Control.Concurrent.Chan.writeList2Chan_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVgL: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.Chan.writeList2Chan1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.728567804 UTC

[section ""data" . Control.Concurrent.Chan.$wreadChan_closure" {
     Control.Concurrent.Chan.$wreadChan_closure:
         const Control.Concurrent.Chan.$wreadChan_info;
 },
 sat_sdV30_entry() //  [R1, R2]
         { info_tbl: [(cdVh8,
                       label: sat_sdV30_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVh8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVh9; else goto cdVha;
       cdVh9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdVha: // global
           I64[Sp - 16] = block_cdVh6_info;
           _sdV2X::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdV2X::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVh6() //  []
         { info_tbl: [(cdVh6,
                       label: block_cdVh6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVh6: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdV2W_entry() //  [R1]
         { info_tbl: [(cdVhk,
                       label: sat_sdV2W_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVhk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdVhw; else goto cdVhx;
       cdVhw: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdVhx: // global
           I64[Sp - 8] = block_cdVhh_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVhD; else goto cdVhi;
       udVhD: // global
           call _cdVhh(R1) args: 0, res: 0, upd: 0;
       cdVhi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVhh() //  [R1]
         { info_tbl: [(cdVhh,
                       label: block_cdVhh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVhh: // global
           I64[Sp] = block_cdVhn_info;
           R1 = P64[R1 + 7];
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVhn() //  [R1]
         { info_tbl: [(cdVhn,
                       label: block_cdVhn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVhn: // global
           I64[Sp] = block_cdVhp_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udVhE; else goto cdVhq;
       udVhE: // global
           call _cdVhp(R1) args: 0, res: 0, upd: 0;
       cdVhq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVhp() //  [R1]
         { info_tbl: [(cdVhp,
                       label: block_cdVhp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVhp: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdVhC; else goto cdVhB;
       cdVhC: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVhB: // global
           _sdV2S::P64 = P64[R1 + 7];
           _sdV2T::P64 = P64[R1 + 15];
           I64[Hp - 32] = GHC.MVar.MVar_con_info;
           P64[Hp - 24] = _sdV2T::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sdV2S::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io1_sdV2G_entry() //  [R1]
         { info_tbl: [(cdVhK,
                       label: io1_sdV2G_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVhK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVhO; else goto cdVhP;
       cdVhO: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdVhP: // global
           I64[Sp - 16] = block_cdVgZ_info;
           _sdV2A::P64 = P64[R1 + 7];
           R1 = _sdV2A::P64;
           P64[Sp - 8] = _sdV2A::P64;
           Sp = Sp - 16;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVgZ() //  [R1]
         { info_tbl: [(cdVgZ,
                       label: block_cdVgZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVgZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdVhS; else goto cdVhR;
       cdVhS: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVhR: // global
           I64[Hp - 32] = sat_sdV30_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdV2W_info;
           P64[Hp] = R1;
           I64[Sp] = block_cdVhF_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVhF() //  [R1]
         { info_tbl: [(cdVhF,
                       label: block_cdVhF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVhF: // global
           I64[Sp] = block_cdVhH_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udVhX; else goto cdVhI;
       udVhX: // global
           call _cdVhH(R1) args: 0, res: 0, upd: 0;
       cdVhI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVhH() //  [R1]
         { info_tbl: [(cdVhH,
                       label: block_cdVhH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVhH: // global
           I64[Sp] = block_cdVhN_info;
           R2 = P64[R1 + 7];
           _sdV36::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdV36::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVhN() //  []
         { info_tbl: [(cdVhN,
                       label: block_cdVhN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVhN: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.Chan.$wreadChan_entry() //  [R2, R3]
         { info_tbl: [(cdVi2,
                       label: Control.Concurrent.Chan.$wreadChan_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVi2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVi3; else goto cdVi4;
       cdVi3: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$wreadChan_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVi4: // global
           I64[Sp - 16] = block_cdVgS_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVgS() //  [R1]
         { info_tbl: [(cdVgS,
                       label: block_cdVgS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVgS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdVi7; else goto cdVi6;
       cdVi7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdVi6: // global
           I64[Hp - 8] = io1_sdV2G_info;
           P64[Hp] = P64[Sp + 8];
           _cdVgU::P64 = Hp - 7;
           if (R1 == 0) goto cdVi1; else goto cdVi0;
       cdVi1: // global
           R1 = _cdVgU::P64;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cdVi0: // global
           R1 = _cdVgU::P64;
           Sp = Sp + 16;
           call io1_sdV2G_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.732388509 UTC

[section ""data" . Control.Concurrent.Chan.readChan1_closure" {
     Control.Concurrent.Chan.readChan1_closure:
         const Control.Concurrent.Chan.readChan1_info;
 },
 Control.Concurrent.Chan.readChan1_entry() //  [R2]
         { info_tbl: [(cdVif,
                       label: Control.Concurrent.Chan.readChan1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVif: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdVig; else goto cdVih;
       cdVig: // global
           R2 = R2;
           R1 = Control.Concurrent.Chan.readChan1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdVih: // global
           I64[Sp - 8] = block_cdVic_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVil; else goto cdVid;
       udVil: // global
           call _cdVic(R1) args: 0, res: 0, upd: 0;
       cdVid: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVic() //  [R1]
         { info_tbl: [(cdVic,
                       label: block_cdVic_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVic: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Control.Concurrent.Chan.$wreadChan_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.733697231 UTC

[section ""data" . Control.Concurrent.Chan.readChan_closure" {
     Control.Concurrent.Chan.readChan_closure:
         const Control.Concurrent.Chan.readChan_info;
 },
 Control.Concurrent.Chan.readChan_entry() //  [R2]
         { info_tbl: [(cdViq,
                       label: Control.Concurrent.Chan.readChan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdViq: // global
           R2 = R2;
           call Control.Concurrent.Chan.readChan1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.735135858 UTC

[section ""data" . Control.Concurrent.Chan.getChanContents1_closure" {
     Control.Concurrent.Chan.getChanContents1_closure:
         const Control.Concurrent.Chan.getChanContents1_info;
 },
 sat_sdV3s_entry() //  [R1]
         { info_tbl: [(cdViH,
                       label: sat_sdV3s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdViH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdViP; else goto cdViQ;
       cdViP: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdViQ: // global
           I64[Sp - 16] = block_cdViC_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cdViC() //  []
         { info_tbl: [(cdViC,
                       label: block_cdViC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdViC: // global
           _sdV3e::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdViE_info;
           R1 = _sdV3e::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udViX; else goto cdViF;
       udViX: // global
           call _cdViE(R1) args: 0, res: 0, upd: 0;
       cdViF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdViE() //  [R1]
         { info_tbl: [(cdViE,
                       label: block_cdViE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdViE: // global
           I64[Sp - 8] = block_cdViK_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Control.Concurrent.Chan.$wreadChan_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdViK() //  [R1]
         { info_tbl: [(cdViK,
                       label: block_cdViK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdViK: // global
           I64[Sp] = block_cdViM_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call Control.Concurrent.Chan.getChanContents1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdViM() //  [R1]
         { info_tbl: [(cdViM,
                       label: block_cdViM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdViM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdViW; else goto cdViV;
       cdViW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdViV: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.Chan.getChanContents1_entry() //  [R2]
         { info_tbl: [(cdViY,
                       label: Control.Concurrent.Chan.getChanContents1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdViY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdVj2; else goto cdVj1;
       cdVj2: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Control.Concurrent.Chan.getChanContents1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdVj1: // global
           I64[Hp - 8] = sat_sdV3s_info;
           P64[Hp] = R2;
           R2 = Hp - 7;
           call GHC.IO.Unsafe.unsafeDupableInterleaveIO_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.737173745 UTC

[section ""data" . Control.Concurrent.Chan.getChanContents_closure" {
     Control.Concurrent.Chan.getChanContents_closure:
         const Control.Concurrent.Chan.getChanContents_info;
 },
 Control.Concurrent.Chan.getChanContents_entry() //  [R2]
         { info_tbl: [(cdVj7,
                       label: Control.Concurrent.Chan.getChanContents_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVj7: // global
           R2 = R2;
           call Control.Concurrent.Chan.getChanContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.739042379 UTC

[section ""data" . Control.Concurrent.Chan.dupChan1_closure" {
     Control.Concurrent.Chan.dupChan1_closure:
         const Control.Concurrent.Chan.dupChan1_info;
 },
 Control.Concurrent.Chan.dupChan1_entry() //  [R2]
         { info_tbl: [(cdVjh,
                       label: Control.Concurrent.Chan.dupChan1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVjh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdVjr; else goto cdVjs;
       cdVjr: // global
           R2 = R2;
           R1 = Control.Concurrent.Chan.dupChan1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdVjs: // global
           I64[Sp - 8] = block_cdVje_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVjz; else goto cdVjf;
       udVjz: // global
           call _cdVje(R1) args: 0, res: 0, upd: 0;
       cdVjf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVje() //  [R1]
         { info_tbl: [(cdVje,
                       label: block_cdVje_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVje: // global
           I64[Sp - 8] = block_cdVjk_info;
           _sdV3x::P64 = P64[R1 + 15];
           R1 = _sdV3x::P64;
           P64[Sp] = _sdV3x::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVjk() //  [R1]
         { info_tbl: [(cdVjk,
                       label: block_cdVjk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVjk: // global
           I64[Sp - 8] = block_cdVjm_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVjm() //  [R1]
         { info_tbl: [(cdVjm,
                       label: block_cdVjm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVjm: // global
           I64[Sp] = block_cdVjo_info;
           R2 = P64[Sp + 8];
           _sdV3D::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _sdV3D::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVjo() //  []
         { info_tbl: [(cdVjo,
                       label: block_cdVjo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVjo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVjy; else goto cdVjx;
       cdVjy: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdVjx: // global
           I64[Hp - 16] = Control.Concurrent.Chan.Chan_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.740880705 UTC

[section ""data" . Control.Concurrent.Chan.dupChan_closure" {
     Control.Concurrent.Chan.dupChan_closure:
         const Control.Concurrent.Chan.dupChan_info;
 },
 Control.Concurrent.Chan.dupChan_entry() //  [R2]
         { info_tbl: [(cdVjE,
                       label: Control.Concurrent.Chan.dupChan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVjE: // global
           R2 = R2;
           call Control.Concurrent.Chan.dupChan1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.741713269 UTC

[section ""cstring" . Control.Concurrent.Chan.$trModule4_bytes" {
     Control.Concurrent.Chan.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.742360559 UTC

[section ""data" . Control.Concurrent.Chan.$trModule3_closure" {
     Control.Concurrent.Chan.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.742967775 UTC

[section ""cstring" . Control.Concurrent.Chan.$trModule2_bytes" {
     Control.Concurrent.Chan.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,67,104,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.743576544 UTC

[section ""data" . Control.Concurrent.Chan.$trModule1_closure" {
     Control.Concurrent.Chan.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.744201207 UTC

[section ""data" . Control.Concurrent.Chan.$trModule_closure" {
     Control.Concurrent.Chan.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.Chan.$trModule3_closure+1;
         const Control.Concurrent.Chan.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.744855307 UTC

[section ""data" . $krep_rdV0R_closure" {
     $krep_rdV0R_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.745524735 UTC

[section ""cstring" . Control.Concurrent.Chan.$tcChItem2_bytes" {
     Control.Concurrent.Chan.$tcChItem2_bytes:
         I8[] [67,104,73,116,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.746140686 UTC

[section ""data" . Control.Concurrent.Chan.$tcChItem1_closure" {
     Control.Concurrent.Chan.$tcChItem1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$tcChItem2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.748465564 UTC

[section ""data" . Control.Concurrent.Chan.$tcChItem_closure" {
     Control.Concurrent.Chan.$tcChItem_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.Chan.$trModule_closure+1;
         const Control.Concurrent.Chan.$tcChItem1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 6476193138296826625;
         const 14259015418390681910;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.749182917 UTC

[section ""data" . $krep1_rdV0S_closure" {
     $krep1_rdV0S_closure:
         const :_con_info;
         const $krep_rdV0R_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.749874353 UTC

[section ""data" . $krep2_rdV0T_closure" {
     $krep2_rdV0T_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Concurrent.Chan.$tcChItem_closure+1;
         const $krep1_rdV0S_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.750440907 UTC

[section ""data" . $krep3_rdV0U_closure" {
     $krep3_rdV0U_closure:
         const :_con_info;
         const $krep2_rdV0T_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.751099402 UTC

[section ""data" . $krep4_rdV0V_closure" {
     $krep4_rdV0V_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep3_rdV0U_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.751724745 UTC

[section ""data" . $krep5_rdV0W_closure" {
     $krep5_rdV0W_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rdV0V_closure+1;
         const $krep2_rdV0T_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.752325047 UTC

[section ""data" . Control.Concurrent.Chan.$tc'ChItem1_closure" {
     Control.Concurrent.Chan.$tc'ChItem1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rdV0R_closure+2;
         const $krep5_rdV0W_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.75292858 UTC

[section ""cstring" . Control.Concurrent.Chan.$tc'ChItem3_bytes" {
     Control.Concurrent.Chan.$tc'ChItem3_bytes:
         I8[] [39,67,104,73,116,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.75377399 UTC

[section ""data" . Control.Concurrent.Chan.$tc'ChItem2_closure" {
     Control.Concurrent.Chan.$tc'ChItem2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$tc'ChItem3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.754364389 UTC

[section ""data" . Control.Concurrent.Chan.$tc'ChItem_closure" {
     Control.Concurrent.Chan.$tc'ChItem_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.Chan.$trModule_closure+1;
         const Control.Concurrent.Chan.$tc'ChItem2_closure+1;
         const Control.Concurrent.Chan.$tc'ChItem1_closure+4;
         const 10690021181819663847;
         const 14453345100680315478;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.754963447 UTC

[section ""data" . $krep6_rdV0X_closure" {
     $krep6_rdV0X_closure:
         const :_con_info;
         const $krep4_rdV0V_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.755578616 UTC

[section ""data" . $krep7_rdV0Y_closure" {
     $krep7_rdV0Y_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep6_rdV0X_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.756173609 UTC

[section ""cstring" . Control.Concurrent.Chan.$tcChan2_bytes" {
     Control.Concurrent.Chan.$tcChan2_bytes:
         I8[] [67,104,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.756763967 UTC

[section ""data" . Control.Concurrent.Chan.$tcChan1_closure" {
     Control.Concurrent.Chan.$tcChan1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$tcChan2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.757387064 UTC

[section ""data" . Control.Concurrent.Chan.$tcChan_closure" {
     Control.Concurrent.Chan.$tcChan_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.Chan.$trModule_closure+1;
         const Control.Concurrent.Chan.$tcChan1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 8939098401262630739;
         const 12846644923708574499;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.758012154 UTC

[section ""data" . $krep8_rdV0Z_closure" {
     $krep8_rdV0Z_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Concurrent.Chan.$tcChan_closure+1;
         const $krep1_rdV0S_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.758634706 UTC

[section ""data" . $krep9_rdV10_closure" {
     $krep9_rdV10_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rdV0Y_closure+1;
         const $krep8_rdV0Z_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.759212061 UTC

[section ""data" . Control.Concurrent.Chan.$tc'Chan1_closure" {
     Control.Concurrent.Chan.$tc'Chan1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rdV0Y_closure+1;
         const $krep9_rdV10_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.75983285 UTC

[section ""cstring" . Control.Concurrent.Chan.$tc'Chan3_bytes" {
     Control.Concurrent.Chan.$tc'Chan3_bytes:
         I8[] [39,67,104,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.760435523 UTC

[section ""data" . Control.Concurrent.Chan.$tc'Chan2_closure" {
     Control.Concurrent.Chan.$tc'Chan2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$tc'Chan3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.761080402 UTC

[section ""data" . Control.Concurrent.Chan.$tc'Chan_closure" {
     Control.Concurrent.Chan.$tc'Chan_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.Chan.$trModule_closure+1;
         const Control.Concurrent.Chan.$tc'Chan2_closure+1;
         const Control.Concurrent.Chan.$tc'Chan1_closure+4;
         const 735828590425899369;
         const 13090399282914560069;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.762111568 UTC

[section ""data" . Control.Concurrent.Chan.ChItem_closure" {
     Control.Concurrent.Chan.ChItem_closure:
         const Control.Concurrent.Chan.ChItem_info;
 },
 Control.Concurrent.Chan.ChItem_entry() //  [R2, R3]
         { info_tbl: [(cdVjM,
                       label: Control.Concurrent.Chan.ChItem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVjM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVjQ; else goto cdVjP;
       cdVjQ: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.ChItem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVjP: // global
           I64[Hp - 16] = Control.Concurrent.Chan.ChItem_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.763300549 UTC

[section ""data" . Control.Concurrent.Chan.Chan_closure" {
     Control.Concurrent.Chan.Chan_closure:
         const Control.Concurrent.Chan.Chan_info;
 },
 Control.Concurrent.Chan.Chan_entry() //  [R2, R3]
         { info_tbl: [(cdVjW,
                       label: Control.Concurrent.Chan.Chan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVjW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVk0; else goto cdVjZ;
       cdVk0: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.Chan_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVjZ: // global
           I64[Hp - 16] = Control.Concurrent.Chan.Chan_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.764332479 UTC

[Control.Concurrent.Chan.ChItem_con_entry() //  [R1]
         { info_tbl: [(cdVk1,
                       label: Control.Concurrent.Chan.ChItem_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,67,104,97,110,46,67,104,73,116,101,109]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVk1: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.76517541 UTC

[Control.Concurrent.Chan.Chan_con_entry() //  [R1]
         { info_tbl: [(cdVk3,
                       label: Control.Concurrent.Chan.Chan_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,67,104,97,110,46,67,104,97,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVk3: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.766428692 UTC

[section ""relreadonly" . SdVbR_srt" { SdVbR_srt:
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.767293805 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:10.769011377 UTC

[section ""data" . Control.Concurrent.Chan.$WChItem_closure" {
     Control.Concurrent.Chan.$WChItem_closure:
         const Control.Concurrent.Chan.$WChItem_info;
 },
 Control.Concurrent.Chan.$WChItem_entry() //  [R2, R3]
         { info_tbl: [(cdVkc,
                       label: Control.Concurrent.Chan.$WChItem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVkc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVkg; else goto cdVkh;
       cdVkg: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$WChItem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVkh: // global
           I64[Sp - 16] = block_cdVk9_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udVkl; else goto cdVka;
       udVkl: // global
           call _cdVk9(R1) args: 0, res: 0, upd: 0;
       cdVka: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVk9() //  [R1]
         { info_tbl: [(cdVk9,
                       label: block_cdVk9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVk9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVkk; else goto cdVkj;
       cdVkk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVkj: // global
           _sdV15::P64 = P64[R1 + 7];
           I64[Hp - 16] = Control.Concurrent.Chan.ChItem_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sdV15::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.776140966 UTC

[section ""data" . Control.Concurrent.Chan.$WChan_closure" {
     Control.Concurrent.Chan.$WChan_closure:
         const Control.Concurrent.Chan.$WChan_info;
 },
 Control.Concurrent.Chan.$WChan_entry() //  [R2, R3]
         { info_tbl: [(cdVkE,
                       label: Control.Concurrent.Chan.$WChan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVkE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVkN; else goto cdVkO;
       cdVkN: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$WChan_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVkO: // global
           I64[Sp - 16] = block_cdVkB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udVkU; else goto cdVkC;
       udVkU: // global
           call _cdVkB(R1) args: 0, res: 0, upd: 0;
       cdVkC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVkB() //  [R1]
         { info_tbl: [(cdVkB,
                       label: block_cdVkB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVkB: // global
           I64[Sp] = block_cdVkH_info;
           _sdV19::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdV19::P64;
           if (R1 & 7 != 0) goto udVkT; else goto cdVkI;
       udVkT: // global
           call _cdVkH(R1) args: 0, res: 0, upd: 0;
       cdVkI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVkH() //  [R1]
         { info_tbl: [(cdVkH,
                       label: block_cdVkH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVkH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVkS; else goto cdVkR;
       cdVkS: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVkR: // global
           _sdV1b::P64 = P64[R1 + 7];
           I64[Hp - 16] = Control.Concurrent.Chan.Chan_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sdV1b::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.786171769 UTC

[section ""data" . Control.Concurrent.Chan.$fEqChan_$c==_closure" {
     Control.Concurrent.Chan.$fEqChan_$c==_closure:
         const Control.Concurrent.Chan.$fEqChan_$c==_info;
 },
 Control.Concurrent.Chan.$fEqChan_$c==_entry() //  [R2, R3]
         { info_tbl: [(cdVlh,
                       label: Control.Concurrent.Chan.$fEqChan_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVlh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdVll; else goto cdVlm;
       cdVll: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$fEqChan_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVlm: // global
           I64[Sp - 16] = block_cdVle_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udVlK; else goto cdVlf;
       udVlK: // global
           call _cdVle(R1) args: 0, res: 0, upd: 0;
       cdVlf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVle() //  [R1]
         { info_tbl: [(cdVle,
                       label: block_cdVle_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVle: // global
           I64[Sp - 8] = block_cdVlk_info;
           _sdV1f::P64 = P64[R1 + 7];
           _sdV1g::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sdV1g::P64;
           P64[Sp + 8] = _sdV1f::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVlJ; else goto cdVlo;
       udVlJ: // global
           call _cdVlk(R1) args: 0, res: 0, upd: 0;
       cdVlo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVlk() //  [R1]
         { info_tbl: [(cdVlk,
                       label: block_cdVlk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVlk: // global
           if (P64[Sp + 16] == P64[R1 + 7]) goto cdVlE; else goto cdVly;
       cdVlE: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdVly: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.798634768 UTC

[section ""data" . Control.Concurrent.Chan.$fEqChan_$c/=_closure" {
     Control.Concurrent.Chan.$fEqChan_$c/=_closure:
         const Control.Concurrent.Chan.$fEqChan_$c/=_info;
 },
 Control.Concurrent.Chan.$fEqChan_$c/=_entry() //  [R2, R3]
         { info_tbl: [(cdVmb,
                       label: Control.Concurrent.Chan.$fEqChan_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVmb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdVmf; else goto cdVmg;
       cdVmf: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$fEqChan_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVmg: // global
           I64[Sp - 16] = block_cdVm8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udVmS; else goto cdVm9;
       udVmS: // global
           call _cdVm8(R1) args: 0, res: 0, upd: 0;
       cdVm9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVm8() //  [R1]
         { info_tbl: [(cdVm8,
                       label: block_cdVm8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVm8: // global
           I64[Sp - 8] = block_cdVme_info;
           _sdV1p::P64 = P64[R1 + 7];
           _sdV1q::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sdV1q::P64;
           P64[Sp + 8] = _sdV1p::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVmR; else goto cdVmi;
       udVmR: // global
           call _cdVme(R1) args: 0, res: 0, upd: 0;
       cdVmi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVme() //  [R1]
         { info_tbl: [(cdVme,
                       label: block_cdVme_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVme: // global
           if (P64[Sp + 16] != P64[R1 + 7]) goto cdVmH; else goto cdVmy;
       cdVmy: // global
           if (P64[Sp + 8] != P64[R1 + 15]) goto cdVmH; else goto cdVmN;
       cdVmH: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdVmN: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.809950491 UTC

[section ""data" . Control.Concurrent.Chan.$fEqChan_closure" {
     Control.Concurrent.Chan.$fEqChan_closure:
         const GHC.Classes.C:Eq_con_info;
         const Control.Concurrent.Chan.$fEqChan_$c==_closure+2;
         const Control.Concurrent.Chan.$fEqChan_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.813403044 UTC

[section ""data" . Control.Concurrent.Chan.newChan1_closure" {
     Control.Concurrent.Chan.newChan1_closure:
         const Control.Concurrent.Chan.newChan1_info;
 },
 Control.Concurrent.Chan.newChan1_entry() //  []
         { info_tbl: [(cdVnr,
                       label: Control.Concurrent.Chan.newChan1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVnr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdVns; else goto cdVnt;
       cdVns: // global
           R1 = Control.Concurrent.Chan.newChan1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdVnt: // global
           I64[Sp - 8] = block_cdVnf_info;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVnf() //  [R1]
         { info_tbl: [(cdVnf,
                       label: block_cdVnf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVnf: // global
           I64[Sp - 8] = block_cdVnh_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVnh() //  [R1]
         { info_tbl: [(cdVnh,
                       label: block_cdVnh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVnh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdVnx; else goto cdVnw;
       cdVnx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVnw: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_cdVnk_info;
           _cdVnj::P64 = Hp - 7;
           R2 = _cdVnj::P64;
           _sdV1C::P64 = R1;
           R1 = R1;
           P64[Sp] = _sdV1C::P64;
           P64[Sp + 8] = _cdVnj::P64;
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVnk() //  []
         { info_tbl: [(cdVnk,
                       label: block_cdVnk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVnk: // global
           I64[Sp] = block_cdVnm_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVnm() //  [R1]
         { info_tbl: [(cdVnm,
                       label: block_cdVnm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVnm: // global
           I64[Sp] = block_cdVno_info;
           R2 = P64[Sp + 16];
           _sdV1H::P64 = R1;
           R1 = R1;
           P64[Sp + 16] = _sdV1H::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVno() //  []
         { info_tbl: [(cdVno,
                       label: block_cdVno_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVno: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVnC; else goto cdVnB;
       cdVnC: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdVnB: // global
           I64[Hp - 16] = Control.Concurrent.Chan.Chan_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.832379889 UTC

[section ""data" . Control.Concurrent.Chan.newChan_closure" {
     Control.Concurrent.Chan.newChan_closure:
         const Control.Concurrent.Chan.newChan_info;
 },
 Control.Concurrent.Chan.newChan_entry() //  []
         { info_tbl: [(cdVo5,
                       label: Control.Concurrent.Chan.newChan_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVo5: // global
           call Control.Concurrent.Chan.newChan1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.840834908 UTC

[section ""data" . Control.Concurrent.Chan.$wwriteChan_closure" {
     Control.Concurrent.Chan.$wwriteChan_closure:
         const Control.Concurrent.Chan.$wwriteChan_info;
 },
 sat_sdV2e_entry() //  [R1]
         { info_tbl: [(cdVox,
                       label: sat_sdV2e_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVox: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdVoF; else goto cdVoG;
       cdVoF: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdVoG: // global
           I64[Sp - 32] = block_cdVos_info;
           _sdV1L::P64 = P64[R1 + 7];
           _sdV1M::P64 = P64[R1 + 15];
           _sdV1Q::P64 = P64[R1 + 23];
           R1 = _sdV1L::P64;
           P64[Sp - 24] = _sdV1L::P64;
           P64[Sp - 16] = _sdV1M::P64;
           P64[Sp - 8] = _sdV1Q::P64;
           Sp = Sp - 32;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVos() //  [R1]
         { info_tbl: [(cdVos,
                       label: block_cdVos_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVos: // global
           I64[Sp] = block_cdVou_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udVoQ; else goto cdVov;
       udVoQ: // global
           call _cdVou(R1) args: 0, res: 0, upd: 0;
       cdVov: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVou() //  [R1]
         { info_tbl: [(cdVou,
                       label: block_cdVou_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVou: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVoK; else goto cdVoJ;
       cdVoK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVoJ: // global
           _sdV29::P64 = P64[R1 + 7];
           I64[Hp - 16] = Control.Concurrent.Chan.ChItem_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_cdVoB_info;
           R2 = Hp - 15;
           R1 = _sdV29::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVoB() //  []
         { info_tbl: [(cdVoB,
                       label: block_cdVoB_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVoB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdVoN; else goto cdVoM;
       cdVoN: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdVoM: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_cdVoE_info;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVoE() //  []
         { info_tbl: [(cdVoE,
                       label: block_cdVoE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVoE: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.Chan.$wwriteChan_entry() //  [R2, R3, R4]
         { info_tbl: [(cdVoU,
                       label: Control.Concurrent.Chan.$wwriteChan_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVoU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdVoV; else goto cdVoW;
       cdVoV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$wwriteChan_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVoW: // global
           I64[Sp - 24] = block_cdVog_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVog() //  [R1]
         { info_tbl: [(cdVog,
                       label: block_cdVog_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVog: // global
           I64[Sp - 8] = block_cdVoi_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVoi() //  [R1]
         { info_tbl: [(cdVoi,
                       label: block_cdVoi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVoi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdVp0; else goto cdVoZ;
       cdVp0: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdVoZ: // global
           _sdV1L::P64 = P64[Sp + 16];
           if (R1 == 0) goto cdVoT; else goto cdVoS;
       cdVoT: // global
           I64[Hp - 24] = sat_sdV2e_info;
           P64[Hp - 16] = _sdV1L::P64;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cdVoS: // global
           Hp = Hp - 32;
           I64[Sp] = block_cdVp1_info;
           R1 = _sdV1L::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVp1() //  [R1]
         { info_tbl: [(cdVp1,
                       label: block_cdVp1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVp1: // global
           I64[Sp] = block_cdVp3_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udVpm; else goto cdVp4;
       udVpm: // global
           call _cdVp3(R1) args: 0, res: 0, upd: 0;
       cdVp4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVp3() //  [R1]
         { info_tbl: [(cdVp3,
                       label: block_cdVp3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVp3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVpg; else goto cdVpf;
       cdVpg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVpf: // global
           _sdV1Z::P64 = P64[R1 + 7];
           I64[Hp - 16] = Control.Concurrent.Chan.ChItem_con_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_cdVp9_info;
           R2 = Hp - 15;
           R1 = _sdV1Z::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVp9() //  []
         { info_tbl: [(cdVp9,
                       label: block_cdVp9_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVp9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdVpj; else goto cdVpi;
       cdVpj: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdVpi: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 24] = block_cdVpc_info;
           R2 = Hp - 7;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVpc() //  []
         { info_tbl: [(cdVpc,
                       label: block_cdVpc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVpc: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.87534659 UTC

[section ""data" . Control.Concurrent.Chan.writeChan1_closure" {
     Control.Concurrent.Chan.writeChan1_closure:
         const Control.Concurrent.Chan.writeChan1_info;
 },
 Control.Concurrent.Chan.writeChan1_entry() //  [R2, R3]
         { info_tbl: [(cdVqj,
                       label: Control.Concurrent.Chan.writeChan1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVqj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVqk; else goto cdVql;
       cdVqk: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.writeChan1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVql: // global
           I64[Sp - 16] = block_cdVqg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udVqp; else goto cdVqh;
       udVqp: // global
           call _cdVqg(R1) args: 0, res: 0, upd: 0;
       cdVqh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVqg() //  [R1]
         { info_tbl: [(cdVqg,
                       label: block_cdVqg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVqg: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call Control.Concurrent.Chan.$wwriteChan_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.88147644 UTC

[section ""data" . Control.Concurrent.Chan.writeChan_closure" {
     Control.Concurrent.Chan.writeChan_closure:
         const Control.Concurrent.Chan.writeChan_info;
 },
 Control.Concurrent.Chan.writeChan_entry() //  [R2, R3]
         { info_tbl: [(cdVqD,
                       label: Control.Concurrent.Chan.writeChan_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVqD: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.Chan.writeChan1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.886174671 UTC

[section ""data" . Control.Concurrent.Chan.writeList2Chan1_closure" {
     Control.Concurrent.Chan.writeList2Chan1_closure:
         const Control.Concurrent.Chan.writeList2Chan1_info;
 },
 Control.Concurrent.Chan.writeList2Chan1_entry() //  [R2, R3]
         { info_tbl: [(cdVqQ,
                       label: Control.Concurrent.Chan.writeList2Chan1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVqQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdVqR; else goto cdVqS;
       cdVqR: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.writeList2Chan1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVqS: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cdVqU() args: 0, res: 0, upd: 0;
     }
 },
 _cdVqU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVqU: // global
           I64[Sp - 8] = block_cdVqW_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVrm; else goto cdVqY;
       udVrm: // global
           call _cdVqW(R1) args: 0, res: 0, upd: 0;
       cdVqY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVqW() //  [R1]
         { info_tbl: [(cdVqW,
                       label: block_cdVqW_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVqW: // global
           if (R1 & 7 == 1) goto cdVr4; else goto cdVr9;
       cdVr4: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdVr9: // global
           I64[Sp - 8] = block_cdVr7_info;
           _sdV2s::P64 = P64[R1 + 6];
           _sdV2t::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sdV2t::P64;
           P64[Sp + 16] = _sdV2s::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVrn; else goto cdVra;
       udVrn: // global
           call _cdVr7(R1) args: 0, res: 0, upd: 0;
       cdVra: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVr7() //  [R1]
         { info_tbl: [(cdVr7,
                       label: block_cdVr7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVr7: // global
           I64[Sp] = block_cdVre_info;
           R4 = P64[Sp + 24];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Concurrent.Chan.$wwriteChan_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdVre() //  []
         { info_tbl: [(cdVre,
                       label: block_cdVre_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVre: // global
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cdVqU() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.900436698 UTC

[section ""data" . Control.Concurrent.Chan.writeList2Chan_closure" {
     Control.Concurrent.Chan.writeList2Chan_closure:
         const Control.Concurrent.Chan.writeList2Chan_info;
 },
 Control.Concurrent.Chan.writeList2Chan_entry() //  [R2, R3]
         { info_tbl: [(cdVrP,
                       label: Control.Concurrent.Chan.writeList2Chan_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVrP: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.Chan.writeList2Chan1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.908748065 UTC

[section ""data" . Control.Concurrent.Chan.$wreadChan_closure" {
     Control.Concurrent.Chan.$wreadChan_closure:
         const Control.Concurrent.Chan.$wreadChan_info;
 },
 sat_sdV30_entry() //  [R1, R2]
         { info_tbl: [(cdVsg,
                       label: sat_sdV30_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVsg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVsh; else goto cdVsi;
       cdVsh: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdVsi: // global
           I64[Sp - 16] = block_cdVse_info;
           _sdV2X::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdV2X::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVse() //  []
         { info_tbl: [(cdVse,
                       label: block_cdVse_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVse: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdV2W_entry() //  [R1]
         { info_tbl: [(cdVss,
                       label: sat_sdV2W_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVss: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdVsE; else goto cdVsF;
       cdVsE: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdVsF: // global
           I64[Sp - 8] = block_cdVsp_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVsL; else goto cdVsq;
       udVsL: // global
           call _cdVsp(R1) args: 0, res: 0, upd: 0;
       cdVsq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVsp() //  [R1]
         { info_tbl: [(cdVsp,
                       label: block_cdVsp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVsp: // global
           I64[Sp] = block_cdVsv_info;
           R1 = P64[R1 + 7];
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVsv() //  [R1]
         { info_tbl: [(cdVsv,
                       label: block_cdVsv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVsv: // global
           I64[Sp] = block_cdVsx_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udVsM; else goto cdVsy;
       udVsM: // global
           call _cdVsx(R1) args: 0, res: 0, upd: 0;
       cdVsy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVsx() //  [R1]
         { info_tbl: [(cdVsx,
                       label: block_cdVsx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVsx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdVsK; else goto cdVsJ;
       cdVsK: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVsJ: // global
           _sdV2S::P64 = P64[R1 + 7];
           _sdV2T::P64 = P64[R1 + 15];
           I64[Hp - 32] = GHC.MVar.MVar_con_info;
           P64[Hp - 24] = _sdV2T::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sdV2S::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io1_sdV2G_entry() //  [R1]
         { info_tbl: [(cdVsS,
                       label: io1_sdV2G_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVsS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVsW; else goto cdVsX;
       cdVsW: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdVsX: // global
           I64[Sp - 16] = block_cdVs7_info;
           _sdV2A::P64 = P64[R1 + 7];
           R1 = _sdV2A::P64;
           P64[Sp - 8] = _sdV2A::P64;
           Sp = Sp - 16;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVs7() //  [R1]
         { info_tbl: [(cdVs7,
                       label: block_cdVs7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVs7: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdVt0; else goto cdVsZ;
       cdVt0: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVsZ: // global
           I64[Hp - 32] = sat_sdV30_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdV2W_info;
           P64[Hp] = R1;
           I64[Sp] = block_cdVsN_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVsN() //  [R1]
         { info_tbl: [(cdVsN,
                       label: block_cdVsN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVsN: // global
           I64[Sp] = block_cdVsP_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udVt5; else goto cdVsQ;
       udVt5: // global
           call _cdVsP(R1) args: 0, res: 0, upd: 0;
       cdVsQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVsP() //  [R1]
         { info_tbl: [(cdVsP,
                       label: block_cdVsP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVsP: // global
           I64[Sp] = block_cdVsV_info;
           R2 = P64[R1 + 7];
           _sdV36::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdV36::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVsV() //  []
         { info_tbl: [(cdVsV,
                       label: block_cdVsV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVsV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.Chan.$wreadChan_entry() //  [R2, R3]
         { info_tbl: [(cdVta,
                       label: Control.Concurrent.Chan.$wreadChan_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVta: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVtb; else goto cdVtc;
       cdVtb: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$wreadChan_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVtc: // global
           I64[Sp - 16] = block_cdVs0_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVs0() //  [R1]
         { info_tbl: [(cdVs0,
                       label: block_cdVs0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVs0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdVtf; else goto cdVte;
       cdVtf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdVte: // global
           I64[Hp - 8] = io1_sdV2G_info;
           P64[Hp] = P64[Sp + 8];
           _cdVs2::P64 = Hp - 7;
           if (R1 == 0) goto cdVt9; else goto cdVt8;
       cdVt9: // global
           R1 = _cdVs2::P64;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cdVt8: // global
           R1 = _cdVs2::P64;
           Sp = Sp + 16;
           call io1_sdV2G_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.93779795 UTC

[section ""data" . Control.Concurrent.Chan.readChan1_closure" {
     Control.Concurrent.Chan.readChan1_closure:
         const Control.Concurrent.Chan.readChan1_info;
 },
 Control.Concurrent.Chan.readChan1_entry() //  [R2]
         { info_tbl: [(cdVud,
                       label: Control.Concurrent.Chan.readChan1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVud: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdVue; else goto cdVuf;
       cdVue: // global
           R2 = R2;
           R1 = Control.Concurrent.Chan.readChan1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdVuf: // global
           I64[Sp - 8] = block_cdVua_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVuj; else goto cdVub;
       udVuj: // global
           call _cdVua(R1) args: 0, res: 0, upd: 0;
       cdVub: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVua() //  [R1]
         { info_tbl: [(cdVua,
                       label: block_cdVua_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVua: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Control.Concurrent.Chan.$wreadChan_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.943584831 UTC

[section ""data" . Control.Concurrent.Chan.readChan_closure" {
     Control.Concurrent.Chan.readChan_closure:
         const Control.Concurrent.Chan.readChan_info;
 },
 Control.Concurrent.Chan.readChan_entry() //  [R2]
         { info_tbl: [(cdVux,
                       label: Control.Concurrent.Chan.readChan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVux: // global
           R2 = R2;
           call Control.Concurrent.Chan.readChan1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.947748562 UTC

[section ""data" . Control.Concurrent.Chan.getChanContents1_closure" {
     Control.Concurrent.Chan.getChanContents1_closure:
         const Control.Concurrent.Chan.getChanContents1_info;
 },
 sat_sdV3s_entry() //  [R1]
         { info_tbl: [(cdVuS,
                       label: sat_sdV3s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVuS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVv0; else goto cdVv1;
       cdVv0: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdVv1: // global
           I64[Sp - 16] = block_cdVuN_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVuN() //  []
         { info_tbl: [(cdVuN,
                       label: block_cdVuN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVuN: // global
           _sdV3e::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdVuP_info;
           R1 = _sdV3e::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udVv8; else goto cdVuQ;
       udVv8: // global
           call _cdVuP(R1) args: 0, res: 0, upd: 0;
       cdVuQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVuP() //  [R1]
         { info_tbl: [(cdVuP,
                       label: block_cdVuP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVuP: // global
           I64[Sp - 8] = block_cdVuV_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Control.Concurrent.Chan.$wreadChan_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdVuV() //  [R1]
         { info_tbl: [(cdVuV,
                       label: block_cdVuV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVuV: // global
           I64[Sp] = block_cdVuX_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call Control.Concurrent.Chan.getChanContents1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdVuX() //  [R1]
         { info_tbl: [(cdVuX,
                       label: block_cdVuX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVuX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVv7; else goto cdVv6;
       cdVv7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVv6: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.Chan.getChanContents1_entry() //  [R2]
         { info_tbl: [(cdVv9,
                       label: Control.Concurrent.Chan.getChanContents1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVv9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdVvd; else goto cdVvc;
       cdVvd: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Control.Concurrent.Chan.getChanContents1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdVvc: // global
           I64[Hp - 8] = sat_sdV3s_info;
           P64[Hp] = R2;
           R2 = Hp - 7;
           call GHC.IO.Unsafe.unsafeDupableInterleaveIO_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.961556676 UTC

[section ""data" . Control.Concurrent.Chan.getChanContents_closure" {
     Control.Concurrent.Chan.getChanContents_closure:
         const Control.Concurrent.Chan.getChanContents_info;
 },
 Control.Concurrent.Chan.getChanContents_entry() //  [R2]
         { info_tbl: [(cdVvG,
                       label: Control.Concurrent.Chan.getChanContents_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVvG: // global
           R2 = R2;
           call Control.Concurrent.Chan.getChanContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.965608612 UTC

[section ""data" . Control.Concurrent.Chan.dupChan1_closure" {
     Control.Concurrent.Chan.dupChan1_closure:
         const Control.Concurrent.Chan.dupChan1_info;
 },
 Control.Concurrent.Chan.dupChan1_entry() //  [R2]
         { info_tbl: [(cdVvU,
                       label: Control.Concurrent.Chan.dupChan1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVvU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdVw4; else goto cdVw5;
       cdVw4: // global
           R2 = R2;
           R1 = Control.Concurrent.Chan.dupChan1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdVw5: // global
           I64[Sp - 8] = block_cdVvR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVwc; else goto cdVvS;
       udVwc: // global
           call _cdVvR(R1) args: 0, res: 0, upd: 0;
       cdVvS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVvR() //  [R1]
         { info_tbl: [(cdVvR,
                       label: block_cdVvR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVvR: // global
           I64[Sp - 8] = block_cdVvX_info;
           _sdV3x::P64 = P64[R1 + 15];
           R1 = _sdV3x::P64;
           P64[Sp] = _sdV3x::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVvX() //  [R1]
         { info_tbl: [(cdVvX,
                       label: block_cdVvX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVvX: // global
           I64[Sp - 8] = block_cdVvZ_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVvZ() //  [R1]
         { info_tbl: [(cdVvZ,
                       label: block_cdVvZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVvZ: // global
           I64[Sp] = block_cdVw1_info;
           R2 = P64[Sp + 8];
           _sdV3D::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _sdV3D::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVw1() //  []
         { info_tbl: [(cdVw1,
                       label: block_cdVw1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVw1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVwb; else goto cdVwa;
       cdVwb: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdVwa: // global
           I64[Hp - 16] = Control.Concurrent.Chan.Chan_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.979213616 UTC

[section ""data" . Control.Concurrent.Chan.dupChan_closure" {
     Control.Concurrent.Chan.dupChan_closure:
         const Control.Concurrent.Chan.dupChan_info;
 },
 Control.Concurrent.Chan.dupChan_entry() //  [R2]
         { info_tbl: [(cdVwC,
                       label: Control.Concurrent.Chan.dupChan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVwC: // global
           R2 = R2;
           call Control.Concurrent.Chan.dupChan1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.98415443 UTC

[section ""cstring" . Control.Concurrent.Chan.$trModule4_bytes" {
     Control.Concurrent.Chan.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.986871907 UTC

[section ""data" . Control.Concurrent.Chan.$trModule3_closure" {
     Control.Concurrent.Chan.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.989069987 UTC

[section ""cstring" . Control.Concurrent.Chan.$trModule2_bytes" {
     Control.Concurrent.Chan.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,67,104,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.991841374 UTC

[section ""data" . Control.Concurrent.Chan.$trModule1_closure" {
     Control.Concurrent.Chan.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.99463409 UTC

[section ""data" . Control.Concurrent.Chan.$trModule_closure" {
     Control.Concurrent.Chan.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.Chan.$trModule3_closure+1;
         const Control.Concurrent.Chan.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:10.997662387 UTC

[section ""data" . $krep_rdV0R_closure" {
     $krep_rdV0R_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.000270881 UTC

[section ""cstring" . Control.Concurrent.Chan.$tcChItem2_bytes" {
     Control.Concurrent.Chan.$tcChItem2_bytes:
         I8[] [67,104,73,116,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.002843886 UTC

[section ""data" . Control.Concurrent.Chan.$tcChItem1_closure" {
     Control.Concurrent.Chan.$tcChItem1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$tcChItem2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.005641173 UTC

[section ""data" . Control.Concurrent.Chan.$tcChItem_closure" {
     Control.Concurrent.Chan.$tcChItem_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.Chan.$trModule_closure+1;
         const Control.Concurrent.Chan.$tcChItem1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 6476193138296826625;
         const 14259015418390681910;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.007716168 UTC

[section ""data" . $krep1_rdV0S_closure" {
     $krep1_rdV0S_closure:
         const :_con_info;
         const $krep_rdV0R_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.01000248 UTC

[section ""data" . $krep2_rdV0T_closure" {
     $krep2_rdV0T_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Concurrent.Chan.$tcChItem_closure+1;
         const $krep1_rdV0S_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.011785459 UTC

[section ""data" . $krep3_rdV0U_closure" {
     $krep3_rdV0U_closure:
         const :_con_info;
         const $krep2_rdV0T_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.014328549 UTC

[section ""data" . $krep4_rdV0V_closure" {
     $krep4_rdV0V_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep3_rdV0U_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.016171657 UTC

[section ""data" . $krep5_rdV0W_closure" {
     $krep5_rdV0W_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rdV0V_closure+1;
         const $krep2_rdV0T_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.017973264 UTC

[section ""data" . Control.Concurrent.Chan.$tc'ChItem1_closure" {
     Control.Concurrent.Chan.$tc'ChItem1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rdV0R_closure+2;
         const $krep5_rdV0W_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.019677739 UTC

[section ""cstring" . Control.Concurrent.Chan.$tc'ChItem3_bytes" {
     Control.Concurrent.Chan.$tc'ChItem3_bytes:
         I8[] [39,67,104,73,116,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.02136382 UTC

[section ""data" . Control.Concurrent.Chan.$tc'ChItem2_closure" {
     Control.Concurrent.Chan.$tc'ChItem2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$tc'ChItem3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.023088579 UTC

[section ""data" . Control.Concurrent.Chan.$tc'ChItem_closure" {
     Control.Concurrent.Chan.$tc'ChItem_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.Chan.$trModule_closure+1;
         const Control.Concurrent.Chan.$tc'ChItem2_closure+1;
         const Control.Concurrent.Chan.$tc'ChItem1_closure+4;
         const 10690021181819663847;
         const 14453345100680315478;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.025012658 UTC

[section ""data" . $krep6_rdV0X_closure" {
     $krep6_rdV0X_closure:
         const :_con_info;
         const $krep4_rdV0V_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.027063145 UTC

[section ""data" . $krep7_rdV0Y_closure" {
     $krep7_rdV0Y_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep6_rdV0X_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.028879415 UTC

[section ""cstring" . Control.Concurrent.Chan.$tcChan2_bytes" {
     Control.Concurrent.Chan.$tcChan2_bytes:
         I8[] [67,104,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.031245645 UTC

[section ""data" . Control.Concurrent.Chan.$tcChan1_closure" {
     Control.Concurrent.Chan.$tcChan1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$tcChan2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.0330606 UTC

[section ""data" . Control.Concurrent.Chan.$tcChan_closure" {
     Control.Concurrent.Chan.$tcChan_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.Chan.$trModule_closure+1;
         const Control.Concurrent.Chan.$tcChan1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 8939098401262630739;
         const 12846644923708574499;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.035053033 UTC

[section ""data" . $krep8_rdV0Z_closure" {
     $krep8_rdV0Z_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Concurrent.Chan.$tcChan_closure+1;
         const $krep1_rdV0S_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.037196832 UTC

[section ""data" . $krep9_rdV10_closure" {
     $krep9_rdV10_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rdV0Y_closure+1;
         const $krep8_rdV0Z_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.039986639 UTC

[section ""data" . Control.Concurrent.Chan.$tc'Chan1_closure" {
     Control.Concurrent.Chan.$tc'Chan1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rdV0Y_closure+1;
         const $krep9_rdV10_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.043097583 UTC

[section ""cstring" . Control.Concurrent.Chan.$tc'Chan3_bytes" {
     Control.Concurrent.Chan.$tc'Chan3_bytes:
         I8[] [39,67,104,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.045059127 UTC

[section ""data" . Control.Concurrent.Chan.$tc'Chan2_closure" {
     Control.Concurrent.Chan.$tc'Chan2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$tc'Chan3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.046936623 UTC

[section ""data" . Control.Concurrent.Chan.$tc'Chan_closure" {
     Control.Concurrent.Chan.$tc'Chan_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.Chan.$trModule_closure+1;
         const Control.Concurrent.Chan.$tc'Chan2_closure+1;
         const Control.Concurrent.Chan.$tc'Chan1_closure+4;
         const 735828590425899369;
         const 13090399282914560069;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.049359127 UTC

[section ""data" . Control.Concurrent.Chan.ChItem_closure" {
     Control.Concurrent.Chan.ChItem_closure:
         const Control.Concurrent.Chan.ChItem_info;
 },
 Control.Concurrent.Chan.ChItem_entry() //  [R2, R3]
         { info_tbl: [(cdVxh,
                       label: Control.Concurrent.Chan.ChItem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVxh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVxl; else goto cdVxk;
       cdVxl: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.ChItem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVxk: // global
           I64[Hp - 16] = Control.Concurrent.Chan.ChItem_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.053693365 UTC

[section ""data" . Control.Concurrent.Chan.Chan_closure" {
     Control.Concurrent.Chan.Chan_closure:
         const Control.Concurrent.Chan.Chan_info;
 },
 Control.Concurrent.Chan.Chan_entry() //  [R2, R3]
         { info_tbl: [(cdVxw,
                       label: Control.Concurrent.Chan.Chan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVxw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVxA; else goto cdVxz;
       cdVxA: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.Chan_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVxz: // global
           I64[Hp - 16] = Control.Concurrent.Chan.Chan_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.057843217 UTC

[Control.Concurrent.Chan.ChItem_con_entry() //  [R1]
         { info_tbl: [(cdVxG,
                       label: Control.Concurrent.Chan.ChItem_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,67,104,97,110,46,67,104,73,116,101,109]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVxG: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.061983725 UTC

[Control.Concurrent.Chan.Chan_con_entry() //  [R1]
         { info_tbl: [(cdVxM,
                       label: Control.Concurrent.Chan.Chan_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,67,104,97,110,46,67,104,97,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVxM: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.066103629 UTC

[section ""relreadonly" . SdVbR_srt" { SdVbR_srt:
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.593343228 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:11.595750838 UTC

[section ""data" . Control.Concurrent.Chan.$WChItem_closure" {
     Control.Concurrent.Chan.$WChItem_closure:
         const Control.Concurrent.Chan.$WChItem_info;
 },
 Control.Concurrent.Chan.$WChItem_entry() //  [R2, R3]
         { info_tbl: [(cdVAE,
                       label: Control.Concurrent.Chan.$WChItem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVAE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVAI; else goto cdVAJ;
       cdVAI: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$WChItem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVAJ: // global
           I64[Sp - 16] = block_cdVAB_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udVAN; else goto cdVAC;
       udVAN: // global
           call _cdVAB(R1) args: 0, res: 0, upd: 0;
       cdVAC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVAB() //  [R1]
         { info_tbl: [(cdVAB,
                       label: block_cdVAB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVAB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVAM; else goto cdVAL;
       cdVAM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVAL: // global
           _sdVxW::P64 = P64[R1 + 7];
           I64[Hp - 16] = Control.Concurrent.Chan.ChItem_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sdVxW::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.602713708 UTC

[section ""data" . Control.Concurrent.Chan.$WChan_closure" {
     Control.Concurrent.Chan.$WChan_closure:
         const Control.Concurrent.Chan.$WChan_info;
 },
 Control.Concurrent.Chan.$WChan_entry() //  [R2, R3]
         { info_tbl: [(cdVB8,
                       label: Control.Concurrent.Chan.$WChan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVB8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVBh; else goto cdVBi;
       cdVBh: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$WChan_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVBi: // global
           I64[Sp - 16] = block_cdVB5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udVBo; else goto cdVB6;
       udVBo: // global
           call _cdVB5(R1) args: 0, res: 0, upd: 0;
       cdVB6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVB5() //  [R1]
         { info_tbl: [(cdVB5,
                       label: block_cdVB5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVB5: // global
           I64[Sp] = block_cdVBb_info;
           _sdVy0::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdVy0::P64;
           if (R1 & 7 != 0) goto udVBn; else goto cdVBc;
       udVBn: // global
           call _cdVBb(R1) args: 0, res: 0, upd: 0;
       cdVBc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVBb() //  [R1]
         { info_tbl: [(cdVBb,
                       label: block_cdVBb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVBb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVBm; else goto cdVBl;
       cdVBm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVBl: // global
           _sdVy2::P64 = P64[R1 + 7];
           I64[Hp - 16] = Control.Concurrent.Chan.Chan_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sdVy2::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.611923686 UTC

[section ""data" . Control.Concurrent.Chan.$fEqChan_$c==_closure" {
     Control.Concurrent.Chan.$fEqChan_$c==_closure:
         const Control.Concurrent.Chan.$fEqChan_$c==_info;
 },
 Control.Concurrent.Chan.$fEqChan_$c==_entry() //  [R2, R3]
         { info_tbl: [(cdVBO,
                       label: Control.Concurrent.Chan.$fEqChan_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVBO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdVBS; else goto cdVBT;
       cdVBS: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$fEqChan_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVBT: // global
           I64[Sp - 16] = block_cdVBL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udVCh; else goto cdVBM;
       udVCh: // global
           call _cdVBL(R1) args: 0, res: 0, upd: 0;
       cdVBM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVBL() //  [R1]
         { info_tbl: [(cdVBL,
                       label: block_cdVBL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVBL: // global
           I64[Sp - 8] = block_cdVBR_info;
           _sdVy6::P64 = P64[R1 + 7];
           _sdVy7::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sdVy7::P64;
           P64[Sp + 8] = _sdVy6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVCg; else goto cdVBV;
       udVCg: // global
           call _cdVBR(R1) args: 0, res: 0, upd: 0;
       cdVBV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVBR() //  [R1]
         { info_tbl: [(cdVBR,
                       label: block_cdVBR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVBR: // global
           if (P64[Sp + 16] == P64[R1 + 7]) goto cdVCb; else goto cdVC5;
       cdVCb: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdVC5: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.623115272 UTC

[section ""data" . Control.Concurrent.Chan.$fEqChan_$c/=_closure" {
     Control.Concurrent.Chan.$fEqChan_$c/=_closure:
         const Control.Concurrent.Chan.$fEqChan_$c/=_info;
 },
 Control.Concurrent.Chan.$fEqChan_$c/=_entry() //  [R2, R3]
         { info_tbl: [(cdVCM,
                       label: Control.Concurrent.Chan.$fEqChan_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVCM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdVCQ; else goto cdVCR;
       cdVCQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$fEqChan_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVCR: // global
           I64[Sp - 16] = block_cdVCJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udVDt; else goto cdVCK;
       udVDt: // global
           call _cdVCJ(R1) args: 0, res: 0, upd: 0;
       cdVCK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVCJ() //  [R1]
         { info_tbl: [(cdVCJ,
                       label: block_cdVCJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVCJ: // global
           I64[Sp - 8] = block_cdVCP_info;
           _sdVyg::P64 = P64[R1 + 7];
           _sdVyh::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sdVyh::P64;
           P64[Sp + 8] = _sdVyg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVDs; else goto cdVCT;
       udVDs: // global
           call _cdVCP(R1) args: 0, res: 0, upd: 0;
       cdVCT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVCP() //  [R1]
         { info_tbl: [(cdVCP,
                       label: block_cdVCP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVCP: // global
           if (P64[Sp + 16] != P64[R1 + 7]) goto cdVDi; else goto cdVD9;
       cdVD9: // global
           if (P64[Sp + 8] != P64[R1 + 15]) goto cdVDi; else goto cdVDo;
       cdVDi: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdVDo: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.633889797 UTC

[section ""data" . Control.Concurrent.Chan.$fEqChan_closure" {
     Control.Concurrent.Chan.$fEqChan_closure:
         const GHC.Classes.C:Eq_con_info;
         const Control.Concurrent.Chan.$fEqChan_$c==_closure+2;
         const Control.Concurrent.Chan.$fEqChan_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.637701292 UTC

[section ""data" . Control.Concurrent.Chan.newChan1_closure" {
     Control.Concurrent.Chan.newChan1_closure:
         const Control.Concurrent.Chan.newChan1_info;
 },
 Control.Concurrent.Chan.newChan1_entry() //  []
         { info_tbl: [(cdVE6,
                       label: Control.Concurrent.Chan.newChan1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVE6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdVE7; else goto cdVE8;
       cdVE7: // global
           R1 = Control.Concurrent.Chan.newChan1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdVE8: // global
           I64[Sp - 8] = block_cdVDU_info;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVDU() //  [R1]
         { info_tbl: [(cdVDU,
                       label: block_cdVDU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVDU: // global
           I64[Sp - 8] = block_cdVDW_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVDW() //  [R1]
         { info_tbl: [(cdVDW,
                       label: block_cdVDW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVDW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdVEc; else goto cdVEb;
       cdVEc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVEb: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_cdVDZ_info;
           _cdVDY::P64 = Hp - 7;
           R2 = _cdVDY::P64;
           _sdVyt::P64 = R1;
           R1 = R1;
           P64[Sp] = _sdVyt::P64;
           P64[Sp + 8] = _cdVDY::P64;
           Sp = Sp - 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVDZ() //  []
         { info_tbl: [(cdVDZ,
                       label: block_cdVDZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVDZ: // global
           I64[Sp] = block_cdVE1_info;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVE1() //  [R1]
         { info_tbl: [(cdVE1,
                       label: block_cdVE1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVE1: // global
           I64[Sp] = block_cdVE3_info;
           R2 = P64[Sp + 16];
           _sdVyy::P64 = R1;
           R1 = R1;
           P64[Sp + 16] = _sdVyy::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVE3() //  []
         { info_tbl: [(cdVE3,
                       label: block_cdVE3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVE3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVEh; else goto cdVEg;
       cdVEh: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdVEg: // global
           I64[Hp - 16] = Control.Concurrent.Chan.Chan_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.65669642 UTC

[section ""data" . Control.Concurrent.Chan.newChan_closure" {
     Control.Concurrent.Chan.newChan_closure:
         const Control.Concurrent.Chan.newChan_info;
 },
 Control.Concurrent.Chan.newChan_entry() //  []
         { info_tbl: [(cdVER,
                       label: Control.Concurrent.Chan.newChan_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVER: // global
           call Control.Concurrent.Chan.newChan1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.664262693 UTC

[section ""data" . Control.Concurrent.Chan.$wwriteChan_closure" {
     Control.Concurrent.Chan.$wwriteChan_closure:
         const Control.Concurrent.Chan.$wwriteChan_info;
 },
 sat_sdVz5_entry() //  [R1]
         { info_tbl: [(cdVFj,
                       label: sat_sdVz5_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVFj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdVFr; else goto cdVFs;
       cdVFr: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdVFs: // global
           I64[Sp - 32] = block_cdVFe_info;
           _sdVyC::P64 = P64[R1 + 7];
           _sdVyD::P64 = P64[R1 + 15];
           _sdVyH::P64 = P64[R1 + 23];
           R1 = _sdVyC::P64;
           P64[Sp - 24] = _sdVyC::P64;
           P64[Sp - 16] = _sdVyD::P64;
           P64[Sp - 8] = _sdVyH::P64;
           Sp = Sp - 32;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVFe() //  [R1]
         { info_tbl: [(cdVFe,
                       label: block_cdVFe_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVFe: // global
           I64[Sp] = block_cdVFg_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udVFC; else goto cdVFh;
       udVFC: // global
           call _cdVFg(R1) args: 0, res: 0, upd: 0;
       cdVFh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVFg() //  [R1]
         { info_tbl: [(cdVFg,
                       label: block_cdVFg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVFg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVFw; else goto cdVFv;
       cdVFw: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVFv: // global
           _sdVz0::P64 = P64[R1 + 7];
           I64[Hp - 16] = Control.Concurrent.Chan.ChItem_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_cdVFn_info;
           R2 = Hp - 15;
           R1 = _sdVz0::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVFn() //  []
         { info_tbl: [(cdVFn,
                       label: block_cdVFn_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVFn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdVFz; else goto cdVFy;
       cdVFz: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdVFy: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_cdVFq_info;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVFq() //  []
         { info_tbl: [(cdVFq,
                       label: block_cdVFq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVFq: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.Chan.$wwriteChan_entry() //  [R2, R3, R4]
         { info_tbl: [(cdVFG,
                       label: Control.Concurrent.Chan.$wwriteChan_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVFG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdVFH; else goto cdVFI;
       cdVFH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$wwriteChan_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVFI: // global
           I64[Sp - 24] = block_cdVF2_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVF2() //  [R1]
         { info_tbl: [(cdVF2,
                       label: block_cdVF2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVF2: // global
           I64[Sp - 8] = block_cdVF4_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVF4() //  [R1]
         { info_tbl: [(cdVF4,
                       label: block_cdVF4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVF4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdVFM; else goto cdVFL;
       cdVFM: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdVFL: // global
           _sdVyC::P64 = P64[Sp + 16];
           if (R1 == 0) goto cdVFF; else goto cdVFE;
       cdVFF: // global
           I64[Hp - 24] = sat_sdVz5_info;
           P64[Hp - 16] = _sdVyC::P64;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cdVFE: // global
           Hp = Hp - 32;
           I64[Sp] = block_cdVFN_info;
           R1 = _sdVyC::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVFN() //  [R1]
         { info_tbl: [(cdVFN,
                       label: block_cdVFN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVFN: // global
           I64[Sp] = block_cdVFP_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udVG8; else goto cdVFQ;
       udVG8: // global
           call _cdVFP(R1) args: 0, res: 0, upd: 0;
       cdVFQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVFP() //  [R1]
         { info_tbl: [(cdVFP,
                       label: block_cdVFP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVFP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVG2; else goto cdVG1;
       cdVG2: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVG1: // global
           _sdVyQ::P64 = P64[R1 + 7];
           I64[Hp - 16] = Control.Concurrent.Chan.ChItem_con_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_cdVFV_info;
           R2 = Hp - 15;
           R1 = _sdVyQ::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVFV() //  []
         { info_tbl: [(cdVFV,
                       label: block_cdVFV_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVFV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdVG5; else goto cdVG4;
       cdVG5: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdVG4: // global
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 24] = block_cdVFY_info;
           R2 = Hp - 7;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVFY() //  []
         { info_tbl: [(cdVFY,
                       label: block_cdVFY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVFY: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.70696289 UTC

[section ""data" . Control.Concurrent.Chan.writeChan1_closure" {
     Control.Concurrent.Chan.writeChan1_closure:
         const Control.Concurrent.Chan.writeChan1_info;
 },
 Control.Concurrent.Chan.writeChan1_entry() //  [R2, R3]
         { info_tbl: [(cdVHm,
                       label: Control.Concurrent.Chan.writeChan1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVHm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVHn; else goto cdVHo;
       cdVHn: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.writeChan1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVHo: // global
           I64[Sp - 16] = block_cdVHj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udVHs; else goto cdVHk;
       udVHs: // global
           call _cdVHj(R1) args: 0, res: 0, upd: 0;
       cdVHk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVHj() //  [R1]
         { info_tbl: [(cdVHj,
                       label: block_cdVHj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVHj: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call Control.Concurrent.Chan.$wwriteChan_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.715833021 UTC

[section ""data" . Control.Concurrent.Chan.writeChan_closure" {
     Control.Concurrent.Chan.writeChan_closure:
         const Control.Concurrent.Chan.writeChan_info;
 },
 Control.Concurrent.Chan.writeChan_entry() //  [R2, R3]
         { info_tbl: [(cdVHH,
                       label: Control.Concurrent.Chan.writeChan_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVHH: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.Chan.writeChan1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.722132422 UTC

[section ""data" . Control.Concurrent.Chan.writeList2Chan1_closure" {
     Control.Concurrent.Chan.writeList2Chan1_closure:
         const Control.Concurrent.Chan.writeList2Chan1_info;
 },
 Control.Concurrent.Chan.writeList2Chan1_entry() //  [R2, R3]
         { info_tbl: [(cdVHU,
                       label: Control.Concurrent.Chan.writeList2Chan1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVHU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdVHV; else goto cdVHW;
       cdVHV: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.writeList2Chan1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVHW: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cdVHY() args: 0, res: 0, upd: 0;
     }
 },
 _cdVHY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVHY: // global
           I64[Sp - 8] = block_cdVI0_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVIq; else goto cdVI2;
       udVIq: // global
           call _cdVI0(R1) args: 0, res: 0, upd: 0;
       cdVI2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVI0() //  [R1]
         { info_tbl: [(cdVI0,
                       label: block_cdVI0_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVI0: // global
           if (R1 & 7 == 1) goto cdVI8; else goto cdVId;
       cdVI8: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdVId: // global
           I64[Sp - 8] = block_cdVIb_info;
           _sdVzj::P64 = P64[R1 + 6];
           _sdVzk::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sdVzk::P64;
           P64[Sp + 16] = _sdVzj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVIr; else goto cdVIe;
       udVIr: // global
           call _cdVIb(R1) args: 0, res: 0, upd: 0;
       cdVIe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVIb() //  [R1]
         { info_tbl: [(cdVIb,
                       label: block_cdVIb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVIb: // global
           I64[Sp] = block_cdVIi_info;
           R4 = P64[Sp + 24];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Concurrent.Chan.$wwriteChan_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdVIi() //  []
         { info_tbl: [(cdVIi,
                       label: block_cdVIi_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVIi: // global
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cdVHY() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.734504339 UTC

[section ""data" . Control.Concurrent.Chan.writeList2Chan_closure" {
     Control.Concurrent.Chan.writeList2Chan_closure:
         const Control.Concurrent.Chan.writeList2Chan_info;
 },
 Control.Concurrent.Chan.writeList2Chan_entry() //  [R2, R3]
         { info_tbl: [(cdVIX,
                       label: Control.Concurrent.Chan.writeList2Chan_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVIX: // global
           R3 = R3;
           R2 = R2;
           call Control.Concurrent.Chan.writeList2Chan1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.74234385 UTC

[section ""data" . Control.Concurrent.Chan.$wreadChan_closure" {
     Control.Concurrent.Chan.$wreadChan_closure:
         const Control.Concurrent.Chan.$wreadChan_info;
 },
 sat_sdVzR_entry() //  [R1, R2]
         { info_tbl: [(cdVJo,
                       label: sat_sdVzR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVJo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVJp; else goto cdVJq;
       cdVJp: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdVJq: // global
           I64[Sp - 16] = block_cdVJm_info;
           _sdVzO::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sdVzO::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVJm() //  []
         { info_tbl: [(cdVJm,
                       label: block_cdVJm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVJm: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdVzN_entry() //  [R1]
         { info_tbl: [(cdVJA,
                       label: sat_sdVzN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVJA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdVJM; else goto cdVJN;
       cdVJM: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdVJN: // global
           I64[Sp - 8] = block_cdVJx_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVJT; else goto cdVJy;
       udVJT: // global
           call _cdVJx(R1) args: 0, res: 0, upd: 0;
       cdVJy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVJx() //  [R1]
         { info_tbl: [(cdVJx,
                       label: block_cdVJx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVJx: // global
           I64[Sp] = block_cdVJD_info;
           R1 = P64[R1 + 7];
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVJD() //  [R1]
         { info_tbl: [(cdVJD,
                       label: block_cdVJD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVJD: // global
           I64[Sp] = block_cdVJF_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udVJU; else goto cdVJG;
       udVJU: // global
           call _cdVJF(R1) args: 0, res: 0, upd: 0;
       cdVJG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVJF() //  [R1]
         { info_tbl: [(cdVJF,
                       label: block_cdVJF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVJF: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdVJS; else goto cdVJR;
       cdVJS: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVJR: // global
           _sdVzJ::P64 = P64[R1 + 7];
           _sdVzK::P64 = P64[R1 + 15];
           I64[Hp - 32] = GHC.MVar.MVar_con_info;
           P64[Hp - 24] = _sdVzK::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sdVzJ::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io1_sdVzx_entry() //  [R1]
         { info_tbl: [(cdVK0,
                       label: io1_sdVzx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVK0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVK4; else goto cdVK5;
       cdVK4: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdVK5: // global
           I64[Sp - 16] = block_cdVJf_info;
           _sdVzr::P64 = P64[R1 + 7];
           R1 = _sdVzr::P64;
           P64[Sp - 8] = _sdVzr::P64;
           Sp = Sp - 16;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVJf() //  [R1]
         { info_tbl: [(cdVJf,
                       label: block_cdVJf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVJf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdVK8; else goto cdVK7;
       cdVK8: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVK7: // global
           I64[Hp - 32] = sat_sdVzR_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sdVzN_info;
           P64[Hp] = R1;
           I64[Sp] = block_cdVJV_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVJV() //  [R1]
         { info_tbl: [(cdVJV,
                       label: block_cdVJV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVJV: // global
           I64[Sp] = block_cdVJX_info;
           R1 = R1;
           if (R1 & 7 != 0) goto udVKd; else goto cdVJY;
       udVKd: // global
           call _cdVJX(R1) args: 0, res: 0, upd: 0;
       cdVJY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVJX() //  [R1]
         { info_tbl: [(cdVJX,
                       label: block_cdVJX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVJX: // global
           I64[Sp] = block_cdVK3_info;
           R2 = P64[R1 + 7];
           _sdVzX::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdVzX::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVK3() //  []
         { info_tbl: [(cdVK3,
                       label: block_cdVK3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVK3: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.Chan.$wreadChan_entry() //  [R2, R3]
         { info_tbl: [(cdVKi,
                       label: Control.Concurrent.Chan.$wreadChan_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVKi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVKj; else goto cdVKk;
       cdVKj: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.$wreadChan_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVKk: // global
           I64[Sp - 16] = block_cdVJ8_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVJ8() //  [R1]
         { info_tbl: [(cdVJ8,
                       label: block_cdVJ8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVJ8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdVKn; else goto cdVKm;
       cdVKn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdVKm: // global
           I64[Hp - 8] = io1_sdVzx_info;
           P64[Hp] = P64[Sp + 8];
           _cdVJa::P64 = Hp - 7;
           if (R1 == 0) goto cdVKh; else goto cdVKg;
       cdVKh: // global
           R1 = _cdVJa::P64;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cdVKg: // global
           R1 = _cdVJa::P64;
           Sp = Sp + 16;
           call io1_sdVzx_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.784655383 UTC

[section ""data" . Control.Concurrent.Chan.readChan1_closure" {
     Control.Concurrent.Chan.readChan1_closure:
         const Control.Concurrent.Chan.readChan1_info;
 },
 Control.Concurrent.Chan.readChan1_entry() //  [R2]
         { info_tbl: [(cdVLz,
                       label: Control.Concurrent.Chan.readChan1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVLz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdVLA; else goto cdVLB;
       cdVLA: // global
           R2 = R2;
           R1 = Control.Concurrent.Chan.readChan1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdVLB: // global
           I64[Sp - 8] = block_cdVLw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVLF; else goto cdVLx;
       udVLF: // global
           call _cdVLw(R1) args: 0, res: 0, upd: 0;
       cdVLx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVLw() //  [R1]
         { info_tbl: [(cdVLw,
                       label: block_cdVLw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVLw: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Control.Concurrent.Chan.$wreadChan_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.790683991 UTC

[section ""data" . Control.Concurrent.Chan.readChan_closure" {
     Control.Concurrent.Chan.readChan_closure:
         const Control.Concurrent.Chan.readChan_info;
 },
 Control.Concurrent.Chan.readChan_entry() //  [R2]
         { info_tbl: [(cdVLU,
                       label: Control.Concurrent.Chan.readChan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVLU: // global
           R2 = R2;
           call Control.Concurrent.Chan.readChan1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.795729992 UTC

[section ""data" . Control.Concurrent.Chan.getChanContents1_closure" {
     Control.Concurrent.Chan.getChanContents1_closure:
         const Control.Concurrent.Chan.getChanContents1_info;
 },
 sat_sdVAj_entry() //  [R1]
         { info_tbl: [(cdVMf,
                       label: sat_sdVAj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVMf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdVMn; else goto cdVMo;
       cdVMn: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdVMo: // global
           I64[Sp - 16] = block_cdVMa_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVMa() //  []
         { info_tbl: [(cdVMa,
                       label: block_cdVMa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVMa: // global
           _sdVA5::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdVMc_info;
           R1 = _sdVA5::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udVMv; else goto cdVMd;
       udVMv: // global
           call _cdVMc(R1) args: 0, res: 0, upd: 0;
       cdVMd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVMc() //  [R1]
         { info_tbl: [(cdVMc,
                       label: block_cdVMc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVMc: // global
           I64[Sp - 8] = block_cdVMi_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Control.Concurrent.Chan.$wreadChan_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdVMi() //  [R1]
         { info_tbl: [(cdVMi,
                       label: block_cdVMi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVMi: // global
           I64[Sp] = block_cdVMk_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call Control.Concurrent.Chan.getChanContents1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdVMk() //  [R1]
         { info_tbl: [(cdVMk,
                       label: block_cdVMk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVMk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVMu; else goto cdVMt;
       cdVMu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVMt: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Concurrent.Chan.getChanContents1_entry() //  [R2]
         { info_tbl: [(cdVMw,
                       label: Control.Concurrent.Chan.getChanContents1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVMw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdVMA; else goto cdVMz;
       cdVMA: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Control.Concurrent.Chan.getChanContents1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdVMz: // global
           I64[Hp - 8] = sat_sdVAj_info;
           P64[Hp] = R2;
           R2 = Hp - 7;
           call GHC.IO.Unsafe.unsafeDupableInterleaveIO_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.813148371 UTC

[section ""data" . Control.Concurrent.Chan.getChanContents_closure" {
     Control.Concurrent.Chan.getChanContents_closure:
         const Control.Concurrent.Chan.getChanContents_info;
 },
 Control.Concurrent.Chan.getChanContents_entry() //  [R2]
         { info_tbl: [(cdVN9,
                       label: Control.Concurrent.Chan.getChanContents_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVN9: // global
           R2 = R2;
           call Control.Concurrent.Chan.getChanContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.817105244 UTC

[section ""data" . Control.Concurrent.Chan.dupChan1_closure" {
     Control.Concurrent.Chan.dupChan1_closure:
         const Control.Concurrent.Chan.dupChan1_info;
 },
 Control.Concurrent.Chan.dupChan1_entry() //  [R2]
         { info_tbl: [(cdVNn,
                       label: Control.Concurrent.Chan.dupChan1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVNn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdVNx; else goto cdVNy;
       cdVNx: // global
           R2 = R2;
           R1 = Control.Concurrent.Chan.dupChan1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdVNy: // global
           I64[Sp - 8] = block_cdVNk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVNF; else goto cdVNl;
       udVNF: // global
           call _cdVNk(R1) args: 0, res: 0, upd: 0;
       cdVNl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVNk() //  [R1]
         { info_tbl: [(cdVNk,
                       label: block_cdVNk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVNk: // global
           I64[Sp - 8] = block_cdVNq_info;
           _sdVAo::P64 = P64[R1 + 15];
           R1 = _sdVAo::P64;
           P64[Sp] = _sdVAo::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVNq() //  [R1]
         { info_tbl: [(cdVNq,
                       label: block_cdVNq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVNq: // global
           I64[Sp - 8] = block_cdVNs_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cdVNs() //  [R1]
         { info_tbl: [(cdVNs,
                       label: block_cdVNs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVNs: // global
           I64[Sp] = block_cdVNu_info;
           R2 = P64[Sp + 8];
           _sdVAu::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _sdVAu::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVNu() //  []
         { info_tbl: [(cdVNu,
                       label: block_cdVNu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVNu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVNE; else goto cdVND;
       cdVNE: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdVND: // global
           I64[Hp - 16] = Control.Concurrent.Chan.Chan_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.828440235 UTC

[section ""data" . Control.Concurrent.Chan.dupChan_closure" {
     Control.Concurrent.Chan.dupChan_closure:
         const Control.Concurrent.Chan.dupChan_info;
 },
 Control.Concurrent.Chan.dupChan_entry() //  [R2]
         { info_tbl: [(cdVOa,
                       label: Control.Concurrent.Chan.dupChan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVOa: // global
           R2 = R2;
           call Control.Concurrent.Chan.dupChan1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.831886068 UTC

[section ""cstring" . Control.Concurrent.Chan.$trModule4_bytes" {
     Control.Concurrent.Chan.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.833643427 UTC

[section ""data" . Control.Concurrent.Chan.$trModule3_closure" {
     Control.Concurrent.Chan.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.83541811 UTC

[section ""cstring" . Control.Concurrent.Chan.$trModule2_bytes" {
     Control.Concurrent.Chan.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,67,104,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.837740678 UTC

[section ""data" . Control.Concurrent.Chan.$trModule1_closure" {
     Control.Concurrent.Chan.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.840142246 UTC

[section ""data" . Control.Concurrent.Chan.$trModule_closure" {
     Control.Concurrent.Chan.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Concurrent.Chan.$trModule3_closure+1;
         const Control.Concurrent.Chan.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.84204418 UTC

[section ""data" . $krep_rdV0R_closure" {
     $krep_rdV0R_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.843729496 UTC

[section ""cstring" . Control.Concurrent.Chan.$tcChItem2_bytes" {
     Control.Concurrent.Chan.$tcChItem2_bytes:
         I8[] [67,104,73,116,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.84544232 UTC

[section ""data" . Control.Concurrent.Chan.$tcChItem1_closure" {
     Control.Concurrent.Chan.$tcChItem1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$tcChItem2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.847160274 UTC

[section ""data" . Control.Concurrent.Chan.$tcChItem_closure" {
     Control.Concurrent.Chan.$tcChItem_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.Chan.$trModule_closure+1;
         const Control.Concurrent.Chan.$tcChItem1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 6476193138296826625;
         const 14259015418390681910;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.849081931 UTC

[section ""data" . $krep1_rdV0S_closure" {
     $krep1_rdV0S_closure:
         const :_con_info;
         const $krep_rdV0R_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.850959361 UTC

[section ""data" . $krep2_rdV0T_closure" {
     $krep2_rdV0T_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Concurrent.Chan.$tcChItem_closure+1;
         const $krep1_rdV0S_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.852842178 UTC

[section ""data" . $krep3_rdV0U_closure" {
     $krep3_rdV0U_closure:
         const :_con_info;
         const $krep2_rdV0T_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.854744885 UTC

[section ""data" . $krep4_rdV0V_closure" {
     $krep4_rdV0V_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep3_rdV0U_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.856568279 UTC

[section ""data" . $krep5_rdV0W_closure" {
     $krep5_rdV0W_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rdV0V_closure+1;
         const $krep2_rdV0T_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.858813224 UTC

[section ""data" . Control.Concurrent.Chan.$tc'ChItem1_closure" {
     Control.Concurrent.Chan.$tc'ChItem1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rdV0R_closure+2;
         const $krep5_rdV0W_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.860603378 UTC

[section ""cstring" . Control.Concurrent.Chan.$tc'ChItem3_bytes" {
     Control.Concurrent.Chan.$tc'ChItem3_bytes:
         I8[] [39,67,104,73,116,101,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.862407257 UTC

[section ""data" . Control.Concurrent.Chan.$tc'ChItem2_closure" {
     Control.Concurrent.Chan.$tc'ChItem2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$tc'ChItem3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.86417364 UTC

[section ""data" . Control.Concurrent.Chan.$tc'ChItem_closure" {
     Control.Concurrent.Chan.$tc'ChItem_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.Chan.$trModule_closure+1;
         const Control.Concurrent.Chan.$tc'ChItem2_closure+1;
         const Control.Concurrent.Chan.$tc'ChItem1_closure+4;
         const 10690021181819663847;
         const 14453345100680315478;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.866742444 UTC

[section ""data" . $krep6_rdV0X_closure" {
     $krep6_rdV0X_closure:
         const :_con_info;
         const $krep4_rdV0V_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.868594763 UTC

[section ""data" . $krep7_rdV0Y_closure" {
     $krep7_rdV0Y_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep6_rdV0X_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.870410734 UTC

[section ""cstring" . Control.Concurrent.Chan.$tcChan2_bytes" {
     Control.Concurrent.Chan.$tcChan2_bytes:
         I8[] [67,104,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.872092336 UTC

[section ""data" . Control.Concurrent.Chan.$tcChan1_closure" {
     Control.Concurrent.Chan.$tcChan1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$tcChan2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.874533745 UTC

[section ""data" . Control.Concurrent.Chan.$tcChan_closure" {
     Control.Concurrent.Chan.$tcChan_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.Chan.$trModule_closure+1;
         const Control.Concurrent.Chan.$tcChan1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 8939098401262630739;
         const 12846644923708574499;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.876493361 UTC

[section ""data" . $krep8_rdV0Z_closure" {
     $krep8_rdV0Z_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Concurrent.Chan.$tcChan_closure+1;
         const $krep1_rdV0S_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.878327166 UTC

[section ""data" . $krep9_rdV10_closure" {
     $krep9_rdV10_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rdV0Y_closure+1;
         const $krep8_rdV0Z_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.880207129 UTC

[section ""data" . Control.Concurrent.Chan.$tc'Chan1_closure" {
     Control.Concurrent.Chan.$tc'Chan1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rdV0Y_closure+1;
         const $krep9_rdV10_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.882088783 UTC

[section ""cstring" . Control.Concurrent.Chan.$tc'Chan3_bytes" {
     Control.Concurrent.Chan.$tc'Chan3_bytes:
         I8[] [39,67,104,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.883891228 UTC

[section ""data" . Control.Concurrent.Chan.$tc'Chan2_closure" {
     Control.Concurrent.Chan.$tc'Chan2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Concurrent.Chan.$tc'Chan3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.886373084 UTC

[section ""data" . Control.Concurrent.Chan.$tc'Chan_closure" {
     Control.Concurrent.Chan.$tc'Chan_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Concurrent.Chan.$trModule_closure+1;
         const Control.Concurrent.Chan.$tc'Chan2_closure+1;
         const Control.Concurrent.Chan.$tc'Chan1_closure+4;
         const 735828590425899369;
         const 13090399282914560069;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.888684047 UTC

[section ""data" . Control.Concurrent.Chan.ChItem_closure" {
     Control.Concurrent.Chan.ChItem_closure:
         const Control.Concurrent.Chan.ChItem_info;
 },
 Control.Concurrent.Chan.ChItem_entry() //  [R2, R3]
         { info_tbl: [(cdVOP,
                       label: Control.Concurrent.Chan.ChItem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVOP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVOT; else goto cdVOS;
       cdVOT: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.ChItem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVOS: // global
           I64[Hp - 16] = Control.Concurrent.Chan.ChItem_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.892779146 UTC

[section ""data" . Control.Concurrent.Chan.Chan_closure" {
     Control.Concurrent.Chan.Chan_closure:
         const Control.Concurrent.Chan.Chan_info;
 },
 Control.Concurrent.Chan.Chan_entry() //  [R2, R3]
         { info_tbl: [(cdVP5,
                       label: Control.Concurrent.Chan.Chan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVP5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdVP9; else goto cdVP8;
       cdVP9: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Concurrent.Chan.Chan_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVP8: // global
           I64[Hp - 16] = Control.Concurrent.Chan.Chan_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.89736922 UTC

[Control.Concurrent.Chan.ChItem_con_entry() //  [R1]
         { info_tbl: [(cdVPg,
                       label: Control.Concurrent.Chan.ChItem_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,67,104,97,110,46,67,104,73,116,101,109]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVPg: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.900707624 UTC

[Control.Concurrent.Chan.Chan_con_entry() //  [R1]
         { info_tbl: [(cdVPn,
                       label: Control.Concurrent.Chan.Chan_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,67,111,110,99,117,114,114,101,110,116,46,67,104,97,110,46,67,104,97,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVPn: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:11.903979666 UTC

[section ""relreadonly" . SdVPu_srt" { SdVPu_srt:
 }]

