
==================== Raw Cmm ====================
2018-03-16 16:07:00.779891836 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:07:00.78221871 UTC

[section ""data" . Control.Monad.guard_closure" {
     Control.Monad.guard_closure:
         const Control.Monad.guard_info;
 },
 Control.Monad.guard_entry() //  [R2, R3]
         { []
         }
     {offset
       cc7pK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7pL; else goto cc7pM;
       cc7pL: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.guard_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7pM: // global
           I64[Sp - 16] = block_cc7pD_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7pY; else goto cc7pE;
       uc7pY: // global
           call _cc7pD(R1) args: 0, res: 0, upd: 0;
       cc7pE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.guard_info" {
     Control.Monad.guard_info:
         const Control.Monad.guard_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cc7pD() //  [R1]
         { []
         }
     {offset
       cc7pD: // global
           _sc6QB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc7pH; else goto cc7pI;
       cc7pH: // global
           R2 = _sc6QB::P64;
           Sp = Sp + 16;
           call GHC.Base.empty_entry(R2) args: 8, res: 0, upd: 8;
       cc7pI: // global
           I64[Sp + 8] = block_cc7pS_info;
           R2 = _sc6QB::P64;
           Sp = Sp + 8;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7pD_info" {
     block_cc7pD_info:
         const _cc7pD;
         const 1;
         const 30;
 },
 _cc7pS() //  [R1]
         { []
         }
     {offset
       cc7pS: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Tuple.()_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7pS_info" {
     block_cc7pS_info:
         const _cc7pS;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.791926287 UTC

[section ""data" . Control.Monad.filterM_closure" {
     Control.Monad.filterM_closure:
         const Control.Monad.filterM_info;
 },
 z_sc6QH_entry() //  [R1]
         { []
         }
     {offset
       cc7ql: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7qm; else goto cc7qn;
       cc7qm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7qn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_sc6QH_info" {
     z_sc6QH_info:
         const z_sc6QH_entry;
         const 1;
         const 16;
 },
 sat_sc6QQ_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cc7qN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7qO; else goto cc7qP;
       cc7qO: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7qP: // global
           I64[Sp - 24] = block_cc7qG_info;
           _sc6QL::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sc6QL::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc7qZ; else goto cc7qH;
       uc7qZ: // global
           call _cc7qG(R1) args: 0, res: 0, upd: 0;
       cc7qH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sc6QQ_info" {
     sat_sc6QQ_info:
         const sat_sc6QQ_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 _cc7qG() //  [R1]
         { []
         }
     {offset
       cc7qG: // global
           _sc6QO::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cc7qK; else goto cc7qL;
       cc7qK: // global
           R1 = _sc6QO::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc7qL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc7qY; else goto cc7qX;
       cc7qY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7qX: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sc6QO::P64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7qG_info" {
     block_cc7qG_info:
         const _cc7qG;
         const 2;
         const 30;
 },
 go_sc6QI_entry() //  [R1, R2]
         { []
         }
     {offset
       cc7r4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc7r5; else goto cc7r6;
       cc7r5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7r6: // global
           I64[Sp - 40] = block_cc7qt_info;
           _sc6QI::P64 = R1;
           _sc6QF::P64 = P64[R1 + 7];
           _sc6QG::P64 = P64[R1 + 15];
           _sc6QH::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sc6QF::P64;
           P64[Sp - 24] = _sc6QG::P64;
           P64[Sp - 16] = _sc6QH::P64;
           P64[Sp - 8] = _sc6QI::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc7rc; else goto cc7qu;
       uc7rc: // global
           call _cc7qt(R1) args: 0, res: 0, upd: 0;
       cc7qu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sc6QI_info" {
     go_sc6QI_info:
         const go_sc6QI_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 _cc7qt() //  [R1]
         { []
         }
     {offset
       cc7qt: // global
           if (R1 & 7 == 1) goto cc7r1; else goto cc7r2;
       cc7r1: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc7r2: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc7rb; else goto cc7ra;
       cc7rb: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7ra: // global
           _sc6QL::P64 = P64[R1 + 6];
           _sc6QM::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 32];
           P64[Hp - 48] = _sc6QM::P64;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sc6QL::P64;
           I64[Hp - 8] = sat_sc6QQ_info;
           P64[Hp] = _sc6QL::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = Hp - 6;
           P64[Sp + 24] = Hp - 40;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7qt_info" {
     block_cc7qt_info:
         const _cc7qt;
         const 4;
         const 30;
 },
 Control.Monad.filterM_entry() //  [R2, R3]
         { []
         }
     {offset
       cc7rd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7rh; else goto cc7rg;
       cc7rh: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.filterM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7rg: // global
           I64[Hp - 48] = z_sc6QH_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go_sc6QI_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.filterM_info" {
     Control.Monad.filterM_info:
         const Control.Monad.filterM_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.805285505 UTC

[section ""data" . Control.Monad.>=>_closure" {
     Control.Monad.>=>_closure:
         const Control.Monad.>=>_info;
 },
 Control.Monad.>=>_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cc7s0: // global
           _sc6QW::P64 = R5;
           _sc6QV::P64 = R4;
           _sc6QU::P64 = R3;
           _sc6QT::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc7s1; else goto cc7s2;
       cc7s2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc7s4; else goto cc7s3;
       cc7s4: // global
           HpAlloc = 32;
           goto cc7s1;
       cc7s1: // global
           R5 = _sc6QW::P64;
           R4 = _sc6QV::P64;
           R3 = _sc6QU::P64;
           R2 = _sc6QT::P64;
           R1 = Control.Monad.>=>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7s3: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sc6QU::P64;
           P64[Hp] = _sc6QW::P64;
           R2 = _sc6QT::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sc6QV::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.>=>_info" {
     Control.Monad.>=>_info:
         const Control.Monad.>=>_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.809403443 UTC

[section ""data" . Control.Monad.<=<_closure" {
     Control.Monad.<=<_closure:
         const Control.Monad.<=<_info;
 },
 Control.Monad.<=<_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cc7sf: // global
           R5 = R5;
           _sc6R0::P64 = R4;
           R4 = R3;
           R3 = _sc6R0::P64;
           R2 = R2;
           call Control.Monad.>=>_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.<=<_info" {
     Control.Monad.<=<_info:
         const Control.Monad.<=<_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.814376664 UTC

[section ""data" . Control.Monad.forever_closure" {
     Control.Monad.forever_closure:
         const Control.Monad.forever_info;
 },
 a'_sc6R4_entry() //  [R1]
         { []
         }
     {offset
       cc7su: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc7sv; else goto cc7sw;
       cc7sv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7sw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = R1;
           Sp = Sp - 40;
           call GHC.Base.*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . a'_sc6R4_info" {
     a'_sc6R4_info:
         const a'_sc6R4_entry;
         const 2;
         const 18;
 },
 Control.Monad.forever_entry() //  [R2, R3]
         { []
         }
     {offset
       cc7sx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc7sB; else goto cc7sA;
       cc7sB: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.forever_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7sA: // global
           I64[Hp - 24] = a'_sc6R4_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.forever_info" {
     Control.Monad.forever_info:
         const Control.Monad.forever_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.822712056 UTC

[section ""data" . Control.Monad.mapAndUnzipM_closure" {
     Control.Monad.mapAndUnzipM_closure:
         const Control.Monad.mapAndUnzipM_info;
 },
 z_sc6R9_entry() //  [R1]
         { []
         }
     {offset
       cc7sX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7sY; else goto cc7sZ;
       cc7sY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7sZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_sc6R9_info" {
     z_sc6R9_info:
         const z_sc6R9_entry;
         const 1;
         const 16;
 },
 go_sc6Ra_entry() //  [R1, R2]
         { []
         }
     {offset
       cc7tc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc7td; else goto cc7te;
       cc7td: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7te: // global
           I64[Sp - 40] = block_cc7t5_info;
           _sc6Ra::P64 = R1;
           _sc6R5::P64 = P64[R1 + 7];
           _sc6R6::P64 = P64[R1 + 15];
           _sc6R9::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sc6R5::P64;
           P64[Sp - 24] = _sc6R6::P64;
           P64[Sp - 16] = _sc6R9::P64;
           P64[Sp - 8] = _sc6Ra::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc7tp; else goto cc7t6;
       uc7tp: // global
           call _cc7t5(R1) args: 0, res: 0, upd: 0;
       cc7t6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sc6Ra_info" {
     go_sc6Ra_info:
         const go_sc6Ra_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 _cc7t5() //  [R1]
         { []
         }
     {offset
       cc7t5: // global
           if (R1 & 7 == 1) goto cc7t9; else goto cc7ta;
       cc7t9: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc7ta: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc7tm; else goto cc7tl;
       cc7tm: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7tl: // global
           _sc6Rd::P64 = P64[R1 + 6];
           _sc6Re::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sc6Re::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sc6Rd::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7t5_info" {
     block_cc7t5_info:
         const _cc7t5;
         const 4;
         const 30;
 },
 sat_sc6Rh_entry() //  [R1]
         { []
         }
     {offset
       cc7tq: // global
           _sc6Rh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc7tr; else goto cc7ts;
       cc7ts: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7tu; else goto cc7tt;
       cc7tu: // global
           HpAlloc = 56;
           goto cc7tr;
       cc7tr: // global
           R1 = _sc6Rh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7tt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc6Rh::P64;
           _sc6R5::P64 = P64[_sc6Rh::P64 + 16];
           _sc6R6::P64 = P64[_sc6Rh::P64 + 24];
           _sc6R7::P64 = P64[_sc6Rh::P64 + 32];
           I64[Hp - 48] = z_sc6R9_info;
           P64[Hp - 32] = _sc6R5::P64;
           I64[Hp - 24] = go_sc6Ra_info;
           P64[Hp - 16] = _sc6R5::P64;
           P64[Hp - 8] = _sc6R6::P64;
           P64[Hp] = Hp - 48;
           R2 = _sc6R7::P64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call go_sc6Ra_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sc6Rh_info" {
     sat_sc6Rh_info:
         const sat_sc6Rh_entry;
         const 3;
         const 15;
 },
 Control.Monad.mapAndUnzipM_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc7tx: // global
           _sc6R7::P64 = R4;
           _sc6R6::P64 = R3;
           _sc6R5::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc7ty; else goto cc7tz;
       cc7tz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc7tB; else goto cc7tA;
       cc7tB: // global
           HpAlloc = 40;
           goto cc7ty;
       cc7ty: // global
           R4 = _sc6R7::P64;
           R3 = _sc6R6::P64;
           R2 = _sc6R5::P64;
           R1 = Control.Monad.mapAndUnzipM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7tA: // global
           I64[Hp - 32] = sat_sc6Rh_info;
           P64[Hp - 16] = _sc6R5::P64;
           P64[Hp - 8] = _sc6R6::P64;
           P64[Hp] = _sc6R7::P64;
           I64[Sp - 16] = block_cc7tv_info;
           R2 = _sc6R5::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.mapAndUnzipM_info" {
     Control.Monad.mapAndUnzipM_info:
         const Control.Monad.mapAndUnzipM_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cc7tv() //  [R1]
         { []
         }
     {offset
       cc7tv: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.List.unzip_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7tv_info" {
     block_cc7tv_info:
         const _cc7tv;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.838243516 UTC

[section ""data" . Control.Monad.zipWithM_closure" {
     Control.Monad.zipWithM_closure:
         const Control.Monad.zipWithM_info;
 },
 z_sc6Rm_entry() //  [R1]
         { []
         }
     {offset
       cc7uj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7uk; else goto cc7ul;
       cc7uk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7ul: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_sc6Rm_info" {
     z_sc6Rm_info:
         const z_sc6Rm_entry;
         const 1;
         const 16;
 },
 go2_sc6Rn_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cc7uy: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cc7uz; else goto cc7uA;
       cc7uz: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7uA: // global
           I64[Sp - 48] = block_cc7ur_info;
           _sc6Rn::P64 = R1;
           _sc6Ri::P64 = P64[R1 + 6];
           _sc6Rj::P64 = P64[R1 + 14];
           _sc6Rm::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _sc6Ri::P64;
           P64[Sp - 32] = _sc6Rj::P64;
           P64[Sp - 24] = _sc6Rm::P64;
           P64[Sp - 16] = _sc6Rn::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uc7v2; else goto cc7us;
       uc7v2: // global
           call _cc7ur(R1) args: 0, res: 0, upd: 0;
       cc7us: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go2_sc6Rn_info" {
     go2_sc6Rn_info:
         const go2_sc6Rn_entry;
         const 3;
         const 8;
         const 8589934607;
 },
 _cc7ur() //  [R1]
         { []
         }
     {offset
       cc7ur: // global
           if (R1 & 7 == 1) goto uc7uY; else goto cc7uw;
       uc7uY: // global
           Sp = Sp + 24;
           call _cc7uO() args: 0, res: 0, upd: 0;
       cc7uw: // global
           I64[Sp - 8] = block_cc7uG_info;
           _sc6Rr::P64 = P64[R1 + 6];
           _sc6Rs::P64 = P64[R1 + 14];
           R1 = P64[Sp + 40];
           P64[Sp] = _sc6Rs::P64;
           P64[Sp + 40] = _sc6Rr::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7v0; else goto cc7uI;
       uc7v0: // global
           call _cc7uG(R1) args: 0, res: 0, upd: 0;
       cc7uI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7ur_info" {
     block_cc7ur_info:
         const _cc7ur;
         const 5;
         const 30;
 },
 _cc7uG() //  [R1]
         { []
         }
     {offset
       cc7uG: // global
           if (R1 & 7 == 1) goto uc7uZ; else goto cc7uP;
       uc7uZ: // global
           Sp = Sp + 32;
           call _cc7uO() args: 0, res: 0, upd: 0;
       cc7uP: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc7uU; else goto cc7uT;
       cc7uU: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7uT: // global
           _sc6Ru::P64 = P64[R1 + 6];
           _sc6Rv::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _sc6Rv::P64;
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = _sc6Ru::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_ppp_info;
           P64[Sp + 32] = GHC.Types.:_closure+2;
           P64[Sp + 40] = Hp - 32;
           P64[Sp + 48] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7uG_info" {
     block_cc7uG_info:
         const _cc7uG;
         const 6;
         const 30;
 },
 _cc7uO() //  []
         { []
         }
     {offset
       cc7uO: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.zipWithM_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cc7v4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7v8; else goto cc7v7;
       cc7v8: // global
           HpAlloc = 56;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.zipWithM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7v7: // global
           I64[Hp - 48] = z_sc6Rm_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go2_sc6Rn_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R3 = R5;
           R2 = R4;
           R1 = Hp - 22;
           call go2_sc6Rn_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.zipWithM_info" {
     Control.Monad.zipWithM_info:
         const Control.Monad.zipWithM_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.853766829 UTC

[section ""data" . Control.Monad.zipWithM__closure" {
     Control.Monad.zipWithM__closure:
         const Control.Monad.zipWithM__info;
 },
 z_sc6RC_entry() //  [R1]
         { []
         }
     {offset
       cc7vO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7vP; else goto cc7vQ;
       cc7vP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7vQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_sc6RC_info" {
     z_sc6RC_info:
         const z_sc6RC_entry;
         const 1;
         const 16;
 },
 go2_sc6RD_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cc7w3: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cc7w4; else goto cc7w5;
       cc7w4: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7w5: // global
           I64[Sp - 48] = block_cc7vW_info;
           _sc6RD::P64 = R1;
           _sc6Ry::P64 = P64[R1 + 6];
           _sc6Rz::P64 = P64[R1 + 14];
           _sc6RC::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _sc6Ry::P64;
           P64[Sp - 32] = _sc6Rz::P64;
           P64[Sp - 24] = _sc6RC::P64;
           P64[Sp - 16] = _sc6RD::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uc7wx; else goto cc7vX;
       uc7wx: // global
           call _cc7vW(R1) args: 0, res: 0, upd: 0;
       cc7vX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go2_sc6RD_info" {
     go2_sc6RD_info:
         const go2_sc6RD_entry;
         const 3;
         const 8;
         const 8589934607;
 },
 _cc7vW() //  [R1]
         { []
         }
     {offset
       cc7vW: // global
           if (R1 & 7 == 1) goto uc7wt; else goto cc7w1;
       uc7wt: // global
           Sp = Sp + 24;
           call _cc7wj() args: 0, res: 0, upd: 0;
       cc7w1: // global
           I64[Sp - 8] = block_cc7wb_info;
           _sc6RH::P64 = P64[R1 + 6];
           _sc6RI::P64 = P64[R1 + 14];
           R1 = P64[Sp + 40];
           P64[Sp] = _sc6RI::P64;
           P64[Sp + 40] = _sc6RH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7wv; else goto cc7wd;
       uc7wv: // global
           call _cc7wb(R1) args: 0, res: 0, upd: 0;
       cc7wd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7vW_info" {
     block_cc7vW_info:
         const _cc7vW;
         const 5;
         const 30;
 },
 _cc7wb() //  [R1]
         { []
         }
     {offset
       cc7wb: // global
           if (R1 & 7 == 1) goto uc7wu; else goto cc7wk;
       uc7wu: // global
           Sp = Sp + 32;
           call _cc7wj() args: 0, res: 0, upd: 0;
       cc7wk: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc7wp; else goto cc7wo;
       cc7wp: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7wo: // global
           _sc6RK::P64 = P64[R1 + 6];
           _sc6RL::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _sc6RL::P64;
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = _sc6RK::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 32;
           P64[Sp + 48] = Hp - 72;
           Sp = Sp + 32;
           call GHC.Base.*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7wb_info" {
     block_cc7wb_info:
         const _cc7wb;
         const 6;
         const 30;
 },
 _cc7wj() //  []
         { []
         }
     {offset
       cc7wj: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.zipWithM__entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cc7wz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7wD; else goto cc7wC;
       cc7wD: // global
           HpAlloc = 56;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.zipWithM__closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7wC: // global
           I64[Hp - 48] = z_sc6RC_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go2_sc6RD_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R3 = R5;
           R2 = R4;
           R1 = Hp - 22;
           call go2_sc6RD_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.zipWithM__info" {
     Control.Monad.zipWithM__info:
         const Control.Monad.zipWithM__entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.866919769 UTC

[section ""data" . Control.Monad.foldM_$sfoldM_closure" {
     Control.Monad.foldM_$sfoldM_closure:
         const Control.Monad.foldM_$sfoldM_info;
 },
 Control.Monad.foldM_$sfoldM_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc7xh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7xi; else goto cc7xj;
       cc7xi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM_$sfoldM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7xj: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc7xl() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . Control.Monad.foldM_$sfoldM_info" {
     Control.Monad.foldM_$sfoldM_info:
         const Control.Monad.foldM_$sfoldM_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cc7xl() //  []
         { []
         }
     {offset
       cc7xl: // global
           I64[Sp - 8] = block_cc7xn_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7xT; else goto cc7xp;
       uc7xT: // global
           call _cc7xn(R1) args: 0, res: 0, upd: 0;
       cc7xp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7xn() //  [R1]
         { []
         }
     {offset
       cc7xn: // global
           _sc6RT::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cc7xv; else goto cc7xD;
       cc7xv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc7xy; else goto cc7xx;
       cc7xy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7xx: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sc6RT::P64;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7xD: // global
           I64[Sp] = block_cc7xB_info;
           R3 = P64[R1 + 6];
           R2 = _sc6RT::P64;
           _sc6RW::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc6RW::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7xn_info" {
     block_cc7xn_info:
         const _cc7xn;
         const 131;
         const 30;
 },
 _cc7xB() //  [R1]
         { []
         }
     {offset
       cc7xB: // global
           if (R1 & 7 == 1) goto cc7xJ; else goto cc7xN;
       cc7xJ: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7xN: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           Sp = Sp + 8;
           call _cc7xl() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cc7xB_info" {
     block_cc7xB_info:
         const _cc7xB;
         const 131;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.875920442 UTC

[section ""data" . Control.Monad.foldM1_closure" {
     Control.Monad.foldM1_closure:
         const Control.Monad.foldM1_info;
 },
 Control.Monad.foldM1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc7yn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7yo; else goto cc7yp;
       cc7yo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7yp: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc7yr() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . Control.Monad.foldM1_info" {
     Control.Monad.foldM1_info:
         const Control.Monad.foldM1_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _cc7yr() //  []
         { []
         }
     {offset
       cc7yr: // global
           I64[Sp - 8] = block_cc7yt_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7yN; else goto cc7yv;
       uc7yN: // global
           call _cc7yt(R1) args: 0, res: 0, upd: 0;
       cc7yv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7yt() //  [R1]
         { []
         }
     {offset
       cc7yt: // global
           _sc6S5::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cc7yB; else goto cc7yG;
       cc7yB: // global
           R1 = _sc6S5::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7yG: // global
           I64[Sp] = block_cc7yE_info;
           R3 = P64[R1 + 6];
           R2 = _sc6S5::P64;
           _sc6S9::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc6S9::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7yt_info" {
     block_cc7yt_info:
         const _cc7yt;
         const 131;
         const 30;
 },
 _cc7yE() //  [R1]
         { []
         }
     {offset
       cc7yE: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cc7yr() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cc7yE_info" {
     block_cc7yE_info:
         const _cc7yE;
         const 131;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.88401386 UTC

[section ""data" . Control.Monad.foldM_$sfoldM1_closure" {
     Control.Monad.foldM_$sfoldM1_closure:
         const Control.Monad.foldM_$sfoldM1_info;
 },
 Control.Monad.foldM_$sfoldM1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc7zb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Control.Monad.foldM1_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.foldM_$sfoldM1_info" {
     Control.Monad.foldM_$sfoldM1_info:
         const Control.Monad.foldM_$sfoldM1_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.888042674 UTC

[section ""data" . Control.Monad.foldM_closure" {
     Control.Monad.foldM_closure:
         const Control.Monad.foldM_info;
 },
 Control.Monad.foldM_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cc7zm: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Foldable.foldlM_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.foldM_info" {
     Control.Monad.foldM_info:
         const Control.Monad.foldM_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.891130263 UTC

[section ""data" . Control.Monad.foldM_1_closure" {
     Control.Monad.foldM_1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Tuple.()_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.894606181 UTC

[section ""data" . Control.Monad.foldM__$sfoldM__closure" {
     Control.Monad.foldM__$sfoldM__closure:
         const Control.Monad.foldM__$sfoldM__info;
 },
 Control.Monad.foldM__$sfoldM__entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc7zA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7zB; else goto cc7zC;
       cc7zB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM__$sfoldM__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7zC: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc7zE() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . Control.Monad.foldM__$sfoldM__info" {
     Control.Monad.foldM__$sfoldM__info:
         const Control.Monad.foldM__$sfoldM__entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cc7zE() //  []
         { []
         }
     {offset
       cc7zE: // global
           I64[Sp - 8] = block_cc7zG_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7A9; else goto cc7zI;
       uc7A9: // global
           call _cc7zG(R1) args: 0, res: 0, upd: 0;
       cc7zI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7zG() //  [R1]
         { []
         }
     {offset
       cc7zG: // global
           if (R1 & 7 == 1) goto cc7zO; else goto cc7zT;
       cc7zO: // global
           R1 = Control.Monad.foldM_1_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7zT: // global
           I64[Sp] = block_cc7zR_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sc6Sl::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc6Sl::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7zG_info" {
     block_cc7zG_info:
         const _cc7zG;
         const 131;
         const 30;
 },
 _cc7zR() //  [R1]
         { []
         }
     {offset
       cc7zR: // global
           if (R1 & 7 == 1) goto cc7zZ; else goto cc7A3;
       cc7zZ: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7A3: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           Sp = Sp + 8;
           call _cc7zE() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cc7zR_info" {
     block_cc7zR_info:
         const _cc7zR;
         const 131;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.903162142 UTC

[section ""data" . Control.Monad.foldM_2_closure" {
     Control.Monad.foldM_2_closure:
         const Control.Monad.foldM_2_info;
 },
 Control.Monad.foldM_2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc7AD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7AE; else goto cc7AF;
       cc7AE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM_2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7AF: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc7AH() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . Control.Monad.foldM_2_info" {
     Control.Monad.foldM_2_info:
         const Control.Monad.foldM_2_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _cc7AH() //  []
         { []
         }
     {offset
       cc7AH: // global
           I64[Sp - 8] = block_cc7AJ_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7B3; else goto cc7AL;
       uc7B3: // global
           call _cc7AJ(R1) args: 0, res: 0, upd: 0;
       cc7AL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7AJ() //  [R1]
         { []
         }
     {offset
       cc7AJ: // global
           if (R1 & 7 == 1) goto cc7AR; else goto cc7AW;
       cc7AR: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7AW: // global
           I64[Sp] = block_cc7AU_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sc6Sy::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc6Sy::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7AJ_info" {
     block_cc7AJ_info:
         const _cc7AJ;
         const 131;
         const 30;
 },
 _cc7AU() //  [R1]
         { []
         }
     {offset
       cc7AU: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cc7AH() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cc7AU_info" {
     block_cc7AU_info:
         const _cc7AU;
         const 131;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.911008536 UTC

[section ""data" . Control.Monad.foldM__$sfoldM_1_closure" {
     Control.Monad.foldM__$sfoldM_1_closure:
         const Control.Monad.foldM__$sfoldM_1_info;
 },
 Control.Monad.foldM__$sfoldM_1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc7Br: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Control.Monad.foldM_2_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.foldM__$sfoldM_1_info" {
     Control.Monad.foldM__$sfoldM_1_info:
         const Control.Monad.foldM__$sfoldM_1_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.916819826 UTC

[section ""data" . Control.Monad.foldM__closure" {
     Control.Monad.foldM__closure:
         const Control.Monad.foldM__info;
 },
 sat_sc6SI_entry() //  [R1]
         { []
         }
     {offset
       cc7BG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7BH; else goto cc7BI;
       cc7BH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7BI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sc6SI_info" {
     sat_sc6SI_info:
         const sat_sc6SI_entry;
         const 1;
         const 16;
 },
 sat_sc6SH_entry() //  [R1]
         { []
         }
     {offset
       cc7BN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7BO; else goto cc7BP;
       cc7BO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7BP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Foldable.foldlM_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sc6SH_info" {
     sat_sc6SH_info:
         const sat_sc6SH_entry;
         const 5;
         const 15;
 },
 Control.Monad.foldM__entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cc7BQ: // global
           _sc6SG::P64 = R6;
           _sc6SF::P64 = R5;
           _sc6SE::P64 = R4;
           _sc6SD::P64 = R3;
           _sc6SC::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc7BR; else goto cc7BS;
       cc7BS: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc7BU; else goto cc7BT;
       cc7BU: // global
           HpAlloc = 80;
           goto cc7BR;
       cc7BR: // global
           R6 = _sc6SG::P64;
           R5 = _sc6SF::P64;
           R4 = _sc6SE::P64;
           R3 = _sc6SD::P64;
           R2 = _sc6SC::P64;
           R1 = Control.Monad.foldM__closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7BT: // global
           I64[Hp - 72] = sat_sc6SI_info;
           P64[Hp - 56] = _sc6SD::P64;
           I64[Hp - 48] = sat_sc6SH_info;
           P64[Hp - 32] = _sc6SC::P64;
           P64[Hp - 24] = _sc6SD::P64;
           P64[Hp - 16] = _sc6SE::P64;
           P64[Hp - 8] = _sc6SF::P64;
           P64[Hp] = _sc6SG::P64;
           R2 = _sc6SD::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 48;
           P64[Sp - 8] = Hp - 72;
           Sp = Sp - 24;
           call GHC.Base.>>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.foldM__info" {
     Control.Monad.foldM__info:
         const Control.Monad.foldM__entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.927154142 UTC

[section ""data" . Control.Monad.<$!>_closure" {
     Control.Monad.<$!>_closure:
         const Control.Monad.<$!>_info;
 },
 sat_sc6SO_entry() //  [R1, R2]
         { []
         }
     {offset
       cc7Cl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7Cm; else goto cc7Cn;
       cc7Cm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7Cn: // global
           I64[Sp - 16] = block_cc7Cj_info;
           R2 = R2;
           _sc6SJ::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _sc6SJ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sc6SO_info" {
     sat_sc6SO_info:
         const sat_sc6SO_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _cc7Cj() //  [R1]
         { []
         }
     {offset
       cc7Cj: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7Cj_info" {
     block_cc7Cj_info:
         const _cc7Cj;
         const 1;
         const 30;
 },
 Control.Monad.<$!>_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc7Cp: // global
           _sc6SL::P64 = R4;
           _sc6SK::P64 = R3;
           _sc6SJ::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc7Cq; else goto cc7Cr;
       cc7Cr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc7Ct; else goto cc7Cs;
       cc7Ct: // global
           HpAlloc = 24;
           goto cc7Cq;
       cc7Cq: // global
           R4 = _sc6SL::P64;
           R3 = _sc6SK::P64;
           R2 = _sc6SJ::P64;
           R1 = Control.Monad.<$!>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Cs: // global
           I64[Hp - 16] = sat_sc6SO_info;
           P64[Hp - 8] = _sc6SJ::P64;
           P64[Hp] = _sc6SK::P64;
           R2 = _sc6SJ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sc6SL::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.<$!>_info" {
     Control.Monad.<$!>_info:
         const Control.Monad.<$!>_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.936705089 UTC

[section ""data" . Control.Monad.mfilter_closure" {
     Control.Monad.mfilter_closure:
         const Control.Monad.mfilter_info;
 },
 lvl_sc6SS_entry() //  [R1]
         { []
         }
     {offset
       cc7CP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7CQ; else goto cc7CR;
       cc7CQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7CR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_sc6SS_info" {
     lvl_sc6SS_info:
         const lvl_sc6SS_entry;
         const 1;
         const 16;
 },
 sat_sc6SW_entry() //  [R1, R2]
         { []
         }
     {offset
       cc7D7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7D8; else goto cc7D9;
       cc7D8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7D9: // global
           I64[Sp - 32] = block_cc7D1_info;
           _sc6SU::P64 = R2;
           R2 = R2;
           _sc6SS::P64 = P64[R1 + 15];
           _sc6ST::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 24] = _sc6SS::P64;
           P64[Sp - 16] = _sc6ST::P64;
           P64[Sp - 8] = _sc6SU::P64;
           Sp = Sp - 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sc6SW_info" {
     sat_sc6SW_info:
         const sat_sc6SW_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 _cc7D1() //  [R1]
         { []
         }
     {offset
       cc7D1: // global
           if (R1 & 7 == 1) goto cc7D4; else goto cc7D5;
       cc7D4: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc7D5: // global
           R2 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_p_info;
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7D1_info" {
     block_cc7D1_info:
         const _cc7D1;
         const 3;
         const 30;
 },
 Control.Monad.mfilter_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc7Dg: // global
           _sc6SR::P64 = R4;
           _sc6SQ::P64 = R3;
           _sc6SP::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cc7Dh; else goto cc7Di;
       cc7Di: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc7Dk; else goto cc7Dj;
       cc7Dk: // global
           HpAlloc = 24;
           goto cc7Dh;
       cc7Dh: // global
           R4 = _sc6SR::P64;
           R3 = _sc6SQ::P64;
           R2 = _sc6SP::P64;
           R1 = Control.Monad.mfilter_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Dj: // global
           I64[Hp - 16] = lvl_sc6SS_info;
           P64[Hp] = _sc6SP::P64;
           I64[Sp - 32] = block_cc7CS_info;
           R2 = _sc6SP::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sc6SQ::P64;
           P64[Sp - 8] = _sc6SR::P64;
           Sp = Sp - 32;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.mfilter_info" {
     Control.Monad.mfilter_info:
         const Control.Monad.mfilter_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cc7CS() //  [R1]
         { []
         }
     {offset
       cc7CS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc7Dn; else goto cc7Dm;
       cc7Dn: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7Dm: // global
           I64[Hp - 24] = sat_sc6SW_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = Hp - 23;
           Sp = Sp + 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7CS_info" {
     block_cc7CS_info:
         const _cc7CS;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.948196644 UTC

[section ""cstring" . Control.Monad.$trModule4_bytes" {
     Control.Monad.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.950122232 UTC

[section ""data" . Control.Monad.$trModule3_closure" {
     Control.Monad.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.951977406 UTC

[section ""cstring" . Control.Monad.$trModule2_bytes" {
     Control.Monad.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.953752826 UTC

[section ""data" . Control.Monad.$trModule1_closure" {
     Control.Monad.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.955482611 UTC

[section ""data" . Control.Monad.$trModule_closure" {
     Control.Monad.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.$trModule3_closure+1;
         const Control.Monad.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.958651098 UTC

[section ""data" . Control.Monad.unless_$sunless_closure" {
     Control.Monad.unless_$sunless_closure:
         const Control.Monad.unless_$sunless_info;
 },
 Control.Monad.unless_$sunless_entry() //  [R2, R3]
         { []
         }
     {offset
       cc7E4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7E5; else goto cc7E6;
       cc7E5: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.unless_$sunless_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7E6: // global
           I64[Sp - 16] = block_cc7DX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7Ed; else goto cc7DY;
       uc7Ed: // global
           call _cc7DX(R1) args: 0, res: 0, upd: 0;
       cc7DY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.unless_$sunless_info" {
     Control.Monad.unless_$sunless_info:
         const Control.Monad.unless_$sunless_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cc7DX() //  [R1]
         { []
         }
     {offset
       cc7DX: // global
           if (R1 & 7 == 1) goto cc7E1; else goto cc7E2;
       cc7E1: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc7E2: // global
           R1 = Control.Monad.foldM_1_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7DX_info" {
     block_cc7DX_info:
         const _cc7DX;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.965755553 UTC

[section ""data" . Control.Monad.replicateM__$sreplicateM__closure" {
     Control.Monad.replicateM__$sreplicateM__closure:
         const Control.Monad.replicateM__$sreplicateM__info;
 },
 Control.Monad.replicateM__$sreplicateM__entry() //  [R2, R3]
         { []
         }
     {offset
       cc7Ez: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7EA; else goto cc7EB;
       cc7EA: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM__$sreplicateM__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7EB: // global
           I64[Sp - 16] = block_cc7Ew_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7F8; else goto cc7Ex;
       uc7F8: // global
           call _cc7Ew(R1) args: 0, res: 0, upd: 0;
       cc7Ex: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.replicateM__$sreplicateM__info" {
     Control.Monad.replicateM__$sreplicateM__info:
         const Control.Monad.replicateM__$sreplicateM__entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cc7Ew() //  [R1]
         { []
         }
     {offset
       cc7Ew: // global
           I64[Sp] = I64[R1 + 7];
           call _cc7EI() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cc7Ew_info" {
     block_cc7Ew_info:
         const _cc7Ew;
         const 1;
         const 30;
 },
 _cc7EI() //  []
         { []
         }
     {offset
       cc7EI: // global
           if (%MO_S_Gt_W64(I64[Sp], 0)) goto cc7EQ; else goto cc7F2;
       cc7EQ: // global
           I64[Sp - 8] = block_cc7EO_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7F9; else goto cc7ER;
       uc7F9: // global
           call _cc7EO(R1) args: 0, res: 0, upd: 0;
       cc7ER: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cc7F2: // global
           R1 = Control.Monad.foldM_1_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc7EO() //  [R1]
         { []
         }
     {offset
       cc7EO: // global
           if (R1 & 7 == 1) goto cc7EX; else goto cc7F1;
       cc7EX: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7F1: // global
           I64[Sp + 8] = I64[Sp + 8] - 1;
           Sp = Sp + 8;
           call _cc7EI() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cc7EO_info" {
     block_cc7EO_info:
         const _cc7EO;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.972881867 UTC

[section ""data" . Control.Monad.replicateM1_closure" {
     Control.Monad.replicateM1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.977182053 UTC

[section ""data" . Control.Monad.$w$sreplicateM_closure" {
     Control.Monad.$w$sreplicateM_closure:
         const Control.Monad.$w$sreplicateM_info;
 },
 $wloop_sc6Tc_entry() //  [R1, R2]
         { []
         }
     {offset
       cc7FK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7FL; else goto cc7FM;
       cc7FL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7FM: // global
           if (%MO_S_Gt_W64(R2, 0)) goto cc7FI; else goto cc7FJ;
       cc7FI: // global
           I64[Sp - 24] = block_cc7FO_info;
           _sc6Tc::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sc6Tc::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc7Gm; else goto cc7FP;
       uc7Gm: // global
           call _cc7FO(R1) args: 0, res: 0, upd: 0;
       cc7FP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cc7FJ: // global
           R1 = Control.Monad.replicateM1_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . $wloop_sc6Tc_info" {
     $wloop_sc6Tc_info:
         const $wloop_sc6Tc_entry;
         const 1;
         const 9;
         const 4294967300;
 },
 _cc7FO() //  [R1]
         { []
         }
     {offset
       cc7FO: // global
           if (R1 & 7 == 1) goto uc7Gk; else goto cc7G3;
       uc7Gk: // global
           Sp = Sp + 24;
           call _cc7G9() args: 0, res: 0, upd: 0;
       cc7G3: // global
           _sc6Tc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc7G2_info;
           R2 = I64[Sp + 16] - 1;
           _sc6Tg::P64 = P64[R1 + 6];
           R1 = _sc6Tc::P64;
           P64[Sp + 16] = _sc6Tg::P64;
           Sp = Sp + 8;
           call $wloop_sc6Tc_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7FO_info" {
     block_cc7FO_info:
         const _cc7FO;
         const 130;
         const 30;
 },
 _cc7G2() //  [R1]
         { []
         }
     {offset
       cc7G2: // global
           if (R1 & 7 == 1) goto uc7Gl; else goto cc7Ge;
       uc7Gl: // global
           Sp = Sp + 16;
           call _cc7G9() args: 0, res: 0, upd: 0;
       cc7Ge: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc7Gh; else goto cc7Gg;
       cc7Gh: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7Gg: // global
           _sc6Tj::P64 = P64[R1 + 6];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sc6Tj::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7G2_info" {
     block_cc7G2_info:
         const _cc7G2;
         const 1;
         const 30;
 },
 _cc7G9() //  []
         { []
         }
     {offset
       cc7G9: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.$w$sreplicateM_entry() //  [R2, R3]
         { []
         }
     {offset
       cc7Gp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc7Gt; else goto cc7Gs;
       cc7Gt: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$w$sreplicateM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Gs: // global
           I64[Hp - 8] = $wloop_sc6Tc_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call $wloop_sc6Tc_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.$w$sreplicateM_info" {
     Control.Monad.$w$sreplicateM_info:
         const Control.Monad.$w$sreplicateM_entry;
         const 0;
         const 14;
         const 8589934605;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.9871071 UTC

[section ""data" . Control.Monad.replicateM_$sreplicateM_closure" {
     Control.Monad.replicateM_$sreplicateM_closure:
         const Control.Monad.replicateM_$sreplicateM_info;
 },
 Control.Monad.replicateM_$sreplicateM_entry() //  [R2, R3]
         { []
         }
     {offset
       cc7H2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7H3; else goto cc7H4;
       cc7H3: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM_$sreplicateM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7H4: // global
           I64[Sp - 16] = block_cc7GZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7H8; else goto cc7H0;
       uc7H8: // global
           call _cc7GZ(R1) args: 0, res: 0, upd: 0;
       cc7H0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.replicateM_$sreplicateM_info" {
     Control.Monad.replicateM_$sreplicateM_info:
         const Control.Monad.replicateM_$sreplicateM_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cc7GZ() //  [R1]
         { []
         }
     {offset
       cc7GZ: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Control.Monad.$w$sreplicateM_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7GZ_info" {
     block_cc7GZ_info:
         const _cc7GZ;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.99309879 UTC

[section ""data" . Control.Monad.unless1_closure" {
     Control.Monad.unless1_closure:
         const Control.Monad.unless1_info;
 },
 Control.Monad.unless1_entry() //  [R2, R3]
         { []
         }
     {offset
       cc7Ht: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7Hu; else goto cc7Hv;
       cc7Hu: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.unless1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Hv: // global
           I64[Sp - 16] = block_cc7Hm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7HC; else goto cc7Hn;
       uc7HC: // global
           call _cc7Hm(R1) args: 0, res: 0, upd: 0;
       cc7Hn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.unless1_info" {
     Control.Monad.unless1_info:
         const Control.Monad.unless1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cc7Hm() //  [R1]
         { []
         }
     {offset
       cc7Hm: // global
           if (R1 & 7 == 1) goto cc7Hq; else goto cc7Hr;
       cc7Hq: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       cc7Hr: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7Hm_info" {
     block_cc7Hm_info:
         const _cc7Hm;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:00.998517348 UTC

[section ""data" . Control.Monad.unless_$sunless1_closure" {
     Control.Monad.unless_$sunless1_closure:
         const Control.Monad.unless_$sunless1_info;
 },
 Control.Monad.unless_$sunless1_entry() //  [R2, R3]
         { []
         }
     {offset
       cc7HT: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.unless1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.unless_$sunless1_info" {
     Control.Monad.unless_$sunless1_info:
         const Control.Monad.unless_$sunless1_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:01.002851051 UTC

[section ""data" . Control.Monad.unless_closure" {
     Control.Monad.unless_closure:
         const Control.Monad.unless_info;
 },
 Control.Monad.unless_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc7Ib: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7Ic; else goto cc7Id;
       cc7Ic: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.unless_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Id: // global
           I64[Sp - 24] = block_cc7I4_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc7Ik; else goto cc7I5;
       uc7Ik: // global
           call _cc7I4(R1) args: 0, res: 0, upd: 0;
       cc7I5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.unless_info" {
     Control.Monad.unless_info:
         const Control.Monad.unless_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cc7I4() //  [R1]
         { []
         }
     {offset
       cc7I4: // global
           if (R1 & 7 == 1) goto cc7I8; else goto cc7I9;
       cc7I8: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc7I9: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7I4_info" {
     block_cc7I4_info:
         const _cc7I4;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:01.008877005 UTC

[section ""data" . Control.Monad.replicateM_1_closure" {
     Control.Monad.replicateM_1_closure:
         const Control.Monad.replicateM_1_info;
 },
 Control.Monad.replicateM_1_entry() //  [R2, R3]
         { []
         }
     {offset
       cc7ID: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7IE; else goto cc7IF;
       cc7IE: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM_1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7IF: // global
           I64[Sp - 16] = block_cc7IA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7J2; else goto cc7IB;
       uc7J2: // global
           call _cc7IA(R1) args: 0, res: 0, upd: 0;
       cc7IB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.replicateM_1_info" {
     Control.Monad.replicateM_1_info:
         const Control.Monad.replicateM_1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cc7IA() //  [R1]
         { []
         }
     {offset
       cc7IA: // global
           I64[Sp] = I64[R1 + 7];
           call _cc7IM() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cc7IA_info" {
     block_cc7IA_info:
         const _cc7IA;
         const 1;
         const 30;
 },
 _cc7IM() //  []
         { []
         }
     {offset
       cc7IM: // global
           if (%MO_S_Gt_W64(I64[Sp], 0)) goto cc7IU; else goto cc7IX;
       cc7IU: // global
           I64[Sp - 8] = block_cc7IS_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cc7IX: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc7IS() //  []
         { []
         }
     {offset
       cc7IS: // global
           I64[Sp + 8] = I64[Sp + 8] - 1;
           Sp = Sp + 8;
           call _cc7IM() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cc7IS_info" {
     block_cc7IS_info:
         const _cc7IS;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:01.016214222 UTC

[section ""data" . Control.Monad.replicateM__$sreplicateM_1_closure" {
     Control.Monad.replicateM__$sreplicateM_1_closure:
         const Control.Monad.replicateM__$sreplicateM_1_info;
 },
 Control.Monad.replicateM__$sreplicateM_1_entry() //  [R2, R3]
         { []
         }
     {offset
       cc7Jo: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.replicateM_1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.replicateM__$sreplicateM_1_info" {
     Control.Monad.replicateM__$sreplicateM_1_info:
         const Control.Monad.replicateM__$sreplicateM_1_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:01.021328177 UTC

[section ""data" . Control.Monad.$wreplicateM__closure" {
     Control.Monad.$wreplicateM__closure:
         const Control.Monad.$wreplicateM__info;
 },
 lvl_sc6TN_entry() //  [R1]
         { []
         }
     {offset
       cc7JD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7JE; else goto cc7JF;
       cc7JE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7JF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_sc6TN_info" {
     lvl_sc6TN_info:
         const lvl_sc6TN_entry;
         const 1;
         const 16;
 },
 sat_sc6TS_entry() //  [R1]
         { []
         }
     {offset
       cc7JU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7JV; else goto cc7JW;
       cc7JV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7JW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wloop_sc6TO_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sc6TS_info" {
     sat_sc6TS_info:
         const sat_sc6TS_entry;
         const 4294967297;
         const 19;
 },
 $wloop_sc6TO_entry() //  [R1, R2]
         { []
         }
     {offset
       cc7K0: // global
           _sc6TP::I64 = R2;
           _sc6TO::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cc7K1; else goto cc7K2;
       cc7K2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc7K4; else goto cc7K3;
       cc7K4: // global
           HpAlloc = 32;
           goto cc7K1;
       cc7K1: // global
           R2 = _sc6TP::I64;
           R1 = _sc6TO::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7K3: // global
           if (%MO_S_Gt_W64(_sc6TP::I64, 0)) goto cc7JY; else goto cc7JZ;
       cc7JY: // global
           _sc6TK::P64 = P64[_sc6TO::P64 + 7];
           _sc6TM::P64 = P64[_sc6TO::P64 + 15];
           I64[Hp - 24] = sat_sc6TS_info;
           P64[Hp - 8] = _sc6TO::P64;
           I64[Hp] = _sc6TP::I64;
           R2 = _sc6TK::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sc6TM::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Base.*>_entry(R2) args: 32, res: 0, upd: 8;
       cc7JZ: // global
           _sc6TN::P64 = P64[_sc6TO::P64 + 23];
           Hp = Hp - 32;
           R1 = _sc6TN::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . $wloop_sc6TO_info" {
     $wloop_sc6TO_info:
         const $wloop_sc6TO_entry;
         const 3;
         const 8;
         const 4294967300;
 },
 Control.Monad.$wreplicateM__entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc7K5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7K9; else goto cc7K8;
       cc7K9: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$wreplicateM__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7K8: // global
           I64[Hp - 48] = lvl_sc6TN_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = $wloop_sc6TO_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 48;
           R2 = R3;
           R1 = Hp - 23;
           call $wloop_sc6TO_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.$wreplicateM__info" {
     Control.Monad.$wreplicateM__info:
         const Control.Monad.$wreplicateM__entry;
         const 0;
         const 14;
         const 12884901909;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:01.031125634 UTC

[section ""data" . Control.Monad.replicateM__closure" {
     Control.Monad.replicateM__closure:
         const Control.Monad.replicateM__info;
 },
 Control.Monad.replicateM__entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc7KA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7KB; else goto cc7KC;
       cc7KB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7KC: // global
           I64[Sp - 24] = block_cc7Kx_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc7KG; else goto cc7Ky;
       uc7KG: // global
           call _cc7Kx(R1) args: 0, res: 0, upd: 0;
       cc7Ky: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.replicateM__info" {
     Control.Monad.replicateM__info:
         const Control.Monad.replicateM__entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cc7Kx() //  [R1]
         { []
         }
     {offset
       cc7Kx: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Control.Monad.$wreplicateM__entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7Kx_info" {
     block_cc7Kx_info:
         const _cc7Kx;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:01.038186944 UTC

[section ""data" . Control.Monad.$w$sreplicateM1_closure" {
     Control.Monad.$w$sreplicateM1_closure:
         const Control.Monad.$w$sreplicateM1_info;
 },
 $wloop_sc6U1_entry() //  [R1, R2]
         { []
         }
     {offset
       cc7L4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7L5; else goto cc7L6;
       cc7L5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7L6: // global
           if (%MO_S_Gt_W64(R2, 0)) goto cc7L2; else goto cc7L3;
       cc7L2: // global
           I64[Sp - 24] = block_cc7L8_info;
           _sc6U1::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp - 16] = _sc6U1::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cc7L3: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . $wloop_sc6U1_info" {
     $wloop_sc6U1_info:
         const $wloop_sc6U1_entry;
         const 1;
         const 9;
         const 8589934596;
 },
 _cc7L8() //  [R1]
         { []
         }
     {offset
       cc7L8: // global
           _sc6U1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc7Ld_info;
           R2 = I64[Sp + 16] - 1;
           _sc6U7::P64 = R1;
           R1 = _sc6U1::P64;
           P64[Sp + 16] = _sc6U7::P64;
           Sp = Sp + 8;
           call $wloop_sc6U1_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7L8_info" {
     block_cc7L8_info:
         const _cc7L8;
         const 130;
         const 30;
 },
 _cc7Ld() //  [R1]
         { []
         }
     {offset
       cc7Ld: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc7Lj; else goto cc7Li;
       cc7Lj: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7Li: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7Ld_info" {
     block_cc7Ld_info:
         const _cc7Ld;
         const 1;
         const 30;
 },
 Control.Monad.$w$sreplicateM1_entry() //  [R2, R3]
         { []
         }
     {offset
       cc7Lk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc7Lo; else goto cc7Ln;
       cc7Lo: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$w$sreplicateM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Ln: // global
           I64[Hp - 8] = $wloop_sc6U1_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 6;
           call $wloop_sc6U1_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.$w$sreplicateM1_info" {
     Control.Monad.$w$sreplicateM1_info:
         const Control.Monad.$w$sreplicateM1_entry;
         const 0;
         const 14;
         const 12884901901;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:01.047190144 UTC

[section ""data" . Control.Monad.replicateM2_closure" {
     Control.Monad.replicateM2_closure:
         const Control.Monad.replicateM2_info;
 },
 Control.Monad.replicateM2_entry() //  [R2, R3]
         { []
         }
     {offset
       cc7LO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7LP; else goto cc7LQ;
       cc7LP: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7LQ: // global
           I64[Sp - 16] = block_cc7LL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7LU; else goto cc7LM;
       uc7LU: // global
           call _cc7LL(R1) args: 0, res: 0, upd: 0;
       cc7LM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.replicateM2_info" {
     Control.Monad.replicateM2_info:
         const Control.Monad.replicateM2_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cc7LL() //  [R1]
         { []
         }
     {offset
       cc7LL: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Control.Monad.$w$sreplicateM1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7LL_info" {
     block_cc7LL_info:
         const _cc7LL;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:01.052092263 UTC

[section ""data" . Control.Monad.replicateM_$sreplicateM1_closure" {
     Control.Monad.replicateM_$sreplicateM1_closure:
         const Control.Monad.replicateM_$sreplicateM1_info;
 },
 Control.Monad.replicateM_$sreplicateM1_entry() //  [R2, R3]
         { []
         }
     {offset
       cc7M8: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.replicateM2_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.replicateM_$sreplicateM1_info" {
     Control.Monad.replicateM_$sreplicateM1_info:
         const Control.Monad.replicateM_$sreplicateM1_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:01.057644669 UTC

[section ""data" . Control.Monad.$wreplicateM_closure" {
     Control.Monad.$wreplicateM_closure:
         const Control.Monad.$wreplicateM_info;
 },
 lvl_sc6Ul_entry() //  [R1]
         { []
         }
     {offset
       cc7Mn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7Mo; else goto cc7Mp;
       cc7Mo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7Mp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_sc6Ul_info" {
     lvl_sc6Ul_info:
         const lvl_sc6Ul_entry;
         const 1;
         const 16;
 },
 sat_sc6Uq_entry() //  [R1]
         { []
         }
     {offset
       cc7ME: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7MF; else goto cc7MG;
       cc7MF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7MG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wloop_sc6Um_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sc6Uq_info" {
     sat_sc6Uq_info:
         const sat_sc6Uq_entry;
         const 4294967297;
         const 19;
 },
 $wloop_sc6Um_entry() //  [R1, R2]
         { []
         }
     {offset
       cc7MK: // global
           _sc6Un::I64 = R2;
           _sc6Um::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc7ML; else goto cc7MM;
       cc7MM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc7MO; else goto cc7MN;
       cc7MO: // global
           HpAlloc = 32;
           goto cc7ML;
       cc7ML: // global
           R2 = _sc6Un::I64;
           R1 = _sc6Um::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7MN: // global
           if (%MO_S_Gt_W64(_sc6Un::I64, 0)) goto cc7MI; else goto cc7MJ;
       cc7MI: // global
           _sc6Ui::P64 = P64[_sc6Um::P64 + 7];
           _sc6Uk::P64 = P64[_sc6Um::P64 + 15];
           I64[Hp - 24] = sat_sc6Uq_info;
           P64[Hp - 8] = _sc6Um::P64;
           I64[Hp] = _sc6Un::I64;
           R2 = _sc6Ui::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           P64[Sp - 16] = _sc6Uk::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
       cc7MJ: // global
           _sc6Ul::P64 = P64[_sc6Um::P64 + 23];
           Hp = Hp - 32;
           R1 = _sc6Ul::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . $wloop_sc6Um_info" {
     $wloop_sc6Um_info:
         const $wloop_sc6Um_entry;
         const 3;
         const 8;
         const 4294967300;
 },
 Control.Monad.$wreplicateM_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc7MP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7MT; else goto cc7MS;
       cc7MT: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$wreplicateM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7MS: // global
           I64[Hp - 48] = lvl_sc6Ul_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = $wloop_sc6Um_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 48;
           R2 = R3;
           R1 = Hp - 23;
           call $wloop_sc6Um_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.$wreplicateM_info" {
     Control.Monad.$wreplicateM_info:
         const Control.Monad.$wreplicateM_entry;
         const 0;
         const 14;
         const 12884901909;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:01.067176853 UTC

[section ""data" . Control.Monad.replicateM_closure" {
     Control.Monad.replicateM_closure:
         const Control.Monad.replicateM_info;
 },
 Control.Monad.replicateM_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc7Nk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7Nl; else goto cc7Nm;
       cc7Nl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Nm: // global
           I64[Sp - 24] = block_cc7Nh_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc7Nq; else goto cc7Ni;
       uc7Nq: // global
           call _cc7Nh(R1) args: 0, res: 0, upd: 0;
       cc7Ni: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.replicateM_info" {
     Control.Monad.replicateM_info:
         const Control.Monad.replicateM_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cc7Nh() //  [R1]
         { []
         }
     {offset
       cc7Nh: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Control.Monad.$wreplicateM_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7Nh_info" {
     block_cc7Nh_info:
         const _cc7Nh;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:01.072620504 UTC

[section ""relreadonly" . Sc7a2_srt" { Sc7a2_srt:
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:01.996123573 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:07:01.998623319 UTC

[section ""data" . Control.Monad.guard_closure" {
     Control.Monad.guard_closure:
         const Control.Monad.guard_info;
 },
 Control.Monad.guard_entry() //  [R2, R3]
         { []
         }
     {offset
       cc7RH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7RI; else goto cc7RJ;
       cc7RI: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.guard_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7RJ: // global
           I64[Sp - 16] = block_cc7RA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7RV; else goto cc7RB;
       uc7RV: // global
           call _cc7RA(R1) args: 0, res: 0, upd: 0;
       cc7RB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.guard_info" {
     Control.Monad.guard_info:
         const Control.Monad.guard_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cc7RA() //  [R1]
         { []
         }
     {offset
       cc7RA: // global
           _sc7NB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc7RE; else goto cc7RF;
       cc7RE: // global
           R2 = _sc7NB::P64;
           Sp = Sp + 16;
           call GHC.Base.empty_entry(R2) args: 8, res: 0, upd: 8;
       cc7RF: // global
           I64[Sp + 8] = block_cc7RP_info;
           R2 = _sc7NB::P64;
           Sp = Sp + 8;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7RA_info" {
     block_cc7RA_info:
         const _cc7RA;
         const 1;
         const 30;
 },
 _cc7RP() //  [R1]
         { []
         }
     {offset
       cc7RP: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Tuple.()_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7RP_info" {
     block_cc7RP_info:
         const _cc7RP;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.082104471 UTC

[section ""data" . Control.Monad.filterM_closure" {
     Control.Monad.filterM_closure:
         const Control.Monad.filterM_info;
 },
 z_sc7NH_entry() //  [R1]
         { []
         }
     {offset
       cc7Sn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7So; else goto cc7Sp;
       cc7So: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7Sp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_sc7NH_info" {
     z_sc7NH_info:
         const z_sc7NH_entry;
         const 1;
         const 16;
 },
 sat_sc7NQ_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cc7SP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7SQ; else goto cc7SR;
       cc7SQ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7SR: // global
           I64[Sp - 24] = block_cc7SI_info;
           _sc7NL::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sc7NL::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc7T1; else goto cc7SJ;
       uc7T1: // global
           call _cc7SI(R1) args: 0, res: 0, upd: 0;
       cc7SJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sc7NQ_info" {
     sat_sc7NQ_info:
         const sat_sc7NQ_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 _cc7SI() //  [R1]
         { []
         }
     {offset
       cc7SI: // global
           _sc7NO::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cc7SM; else goto cc7SN;
       cc7SM: // global
           R1 = _sc7NO::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc7SN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc7T0; else goto cc7SZ;
       cc7T0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7SZ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sc7NO::P64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7SI_info" {
     block_cc7SI_info:
         const _cc7SI;
         const 2;
         const 30;
 },
 go_sc7NI_entry() //  [R1, R2]
         { []
         }
     {offset
       cc7T6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc7T7; else goto cc7T8;
       cc7T7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7T8: // global
           I64[Sp - 40] = block_cc7Sv_info;
           _sc7NI::P64 = R1;
           _sc7NF::P64 = P64[R1 + 7];
           _sc7NG::P64 = P64[R1 + 15];
           _sc7NH::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sc7NF::P64;
           P64[Sp - 24] = _sc7NG::P64;
           P64[Sp - 16] = _sc7NH::P64;
           P64[Sp - 8] = _sc7NI::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc7Te; else goto cc7Sw;
       uc7Te: // global
           call _cc7Sv(R1) args: 0, res: 0, upd: 0;
       cc7Sw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sc7NI_info" {
     go_sc7NI_info:
         const go_sc7NI_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 _cc7Sv() //  [R1]
         { []
         }
     {offset
       cc7Sv: // global
           if (R1 & 7 == 1) goto cc7T3; else goto cc7T4;
       cc7T3: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc7T4: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc7Td; else goto cc7Tc;
       cc7Td: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7Tc: // global
           _sc7NL::P64 = P64[R1 + 6];
           _sc7NM::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 32];
           P64[Hp - 48] = _sc7NM::P64;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sc7NL::P64;
           I64[Hp - 8] = sat_sc7NQ_info;
           P64[Hp] = _sc7NL::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = Hp - 6;
           P64[Sp + 24] = Hp - 40;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7Sv_info" {
     block_cc7Sv_info:
         const _cc7Sv;
         const 4;
         const 30;
 },
 Control.Monad.filterM_entry() //  [R2, R3]
         { []
         }
     {offset
       cc7Tf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7Tj; else goto cc7Ti;
       cc7Tj: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.filterM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Ti: // global
           I64[Hp - 48] = z_sc7NH_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go_sc7NI_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.filterM_info" {
     Control.Monad.filterM_info:
         const Control.Monad.filterM_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.095475253 UTC

[section ""data" . Control.Monad.>=>_closure" {
     Control.Monad.>=>_closure:
         const Control.Monad.>=>_info;
 },
 Control.Monad.>=>_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cc7Uf: // global
           _sc7NW::P64 = R5;
           _sc7NV::P64 = R4;
           _sc7NU::P64 = R3;
           _sc7NT::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc7Ug; else goto cc7Uh;
       cc7Uh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc7Uj; else goto cc7Ui;
       cc7Uj: // global
           HpAlloc = 32;
           goto cc7Ug;
       cc7Ug: // global
           R5 = _sc7NW::P64;
           R4 = _sc7NV::P64;
           R3 = _sc7NU::P64;
           R2 = _sc7NT::P64;
           R1 = Control.Monad.>=>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Ui: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sc7NU::P64;
           P64[Hp] = _sc7NW::P64;
           R2 = _sc7NT::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sc7NV::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.>=>_info" {
     Control.Monad.>=>_info:
         const Control.Monad.>=>_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.099627251 UTC

[section ""data" . Control.Monad.<=<_closure" {
     Control.Monad.<=<_closure:
         const Control.Monad.<=<_info;
 },
 Control.Monad.<=<_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cc7Uw: // global
           R5 = R5;
           _sc7O0::P64 = R4;
           R4 = R3;
           R3 = _sc7O0::P64;
           R2 = R2;
           call Control.Monad.>=>_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.<=<_info" {
     Control.Monad.<=<_info:
         const Control.Monad.<=<_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.103914871 UTC

[section ""data" . Control.Monad.forever_closure" {
     Control.Monad.forever_closure:
         const Control.Monad.forever_info;
 },
 a'_sc7O4_entry() //  [R1]
         { []
         }
     {offset
       cc7UL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc7UM; else goto cc7UN;
       cc7UM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7UN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = R1;
           Sp = Sp - 40;
           call GHC.Base.*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . a'_sc7O4_info" {
     a'_sc7O4_info:
         const a'_sc7O4_entry;
         const 2;
         const 18;
 },
 Control.Monad.forever_entry() //  [R2, R3]
         { []
         }
     {offset
       cc7UO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc7US; else goto cc7UR;
       cc7US: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.forever_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7UR: // global
           I64[Hp - 24] = a'_sc7O4_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.forever_info" {
     Control.Monad.forever_info:
         const Control.Monad.forever_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.111945311 UTC

[section ""data" . Control.Monad.mapAndUnzipM_closure" {
     Control.Monad.mapAndUnzipM_closure:
         const Control.Monad.mapAndUnzipM_info;
 },
 z_sc7O9_entry() //  [R1]
         { []
         }
     {offset
       cc7Vh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7Vi; else goto cc7Vj;
       cc7Vi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7Vj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_sc7O9_info" {
     z_sc7O9_info:
         const z_sc7O9_entry;
         const 1;
         const 16;
 },
 go_sc7Oa_entry() //  [R1, R2]
         { []
         }
     {offset
       cc7Vw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc7Vx; else goto cc7Vy;
       cc7Vx: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7Vy: // global
           I64[Sp - 40] = block_cc7Vp_info;
           _sc7Oa::P64 = R1;
           _sc7O5::P64 = P64[R1 + 7];
           _sc7O6::P64 = P64[R1 + 15];
           _sc7O9::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sc7O5::P64;
           P64[Sp - 24] = _sc7O6::P64;
           P64[Sp - 16] = _sc7O9::P64;
           P64[Sp - 8] = _sc7Oa::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc7VJ; else goto cc7Vq;
       uc7VJ: // global
           call _cc7Vp(R1) args: 0, res: 0, upd: 0;
       cc7Vq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sc7Oa_info" {
     go_sc7Oa_info:
         const go_sc7Oa_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 _cc7Vp() //  [R1]
         { []
         }
     {offset
       cc7Vp: // global
           if (R1 & 7 == 1) goto cc7Vt; else goto cc7Vu;
       cc7Vt: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc7Vu: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc7VG; else goto cc7VF;
       cc7VG: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7VF: // global
           _sc7Od::P64 = P64[R1 + 6];
           _sc7Oe::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sc7Oe::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sc7Od::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7Vp_info" {
     block_cc7Vp_info:
         const _cc7Vp;
         const 4;
         const 30;
 },
 sat_sc7Oh_entry() //  [R1]
         { []
         }
     {offset
       cc7VK: // global
           _sc7Oh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc7VL; else goto cc7VM;
       cc7VM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7VO; else goto cc7VN;
       cc7VO: // global
           HpAlloc = 56;
           goto cc7VL;
       cc7VL: // global
           R1 = _sc7Oh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7VN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc7Oh::P64;
           _sc7O5::P64 = P64[_sc7Oh::P64 + 16];
           _sc7O6::P64 = P64[_sc7Oh::P64 + 24];
           _sc7O7::P64 = P64[_sc7Oh::P64 + 32];
           I64[Hp - 48] = z_sc7O9_info;
           P64[Hp - 32] = _sc7O5::P64;
           I64[Hp - 24] = go_sc7Oa_info;
           P64[Hp - 16] = _sc7O5::P64;
           P64[Hp - 8] = _sc7O6::P64;
           P64[Hp] = Hp - 48;
           R2 = _sc7O7::P64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call go_sc7Oa_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sc7Oh_info" {
     sat_sc7Oh_info:
         const sat_sc7Oh_entry;
         const 3;
         const 15;
 },
 Control.Monad.mapAndUnzipM_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc7VR: // global
           _sc7O7::P64 = R4;
           _sc7O6::P64 = R3;
           _sc7O5::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc7VS; else goto cc7VT;
       cc7VT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc7VV; else goto cc7VU;
       cc7VV: // global
           HpAlloc = 40;
           goto cc7VS;
       cc7VS: // global
           R4 = _sc7O7::P64;
           R3 = _sc7O6::P64;
           R2 = _sc7O5::P64;
           R1 = Control.Monad.mapAndUnzipM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7VU: // global
           I64[Hp - 32] = sat_sc7Oh_info;
           P64[Hp - 16] = _sc7O5::P64;
           P64[Hp - 8] = _sc7O6::P64;
           P64[Hp] = _sc7O7::P64;
           I64[Sp - 16] = block_cc7VP_info;
           R2 = _sc7O5::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.mapAndUnzipM_info" {
     Control.Monad.mapAndUnzipM_info:
         const Control.Monad.mapAndUnzipM_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cc7VP() //  [R1]
         { []
         }
     {offset
       cc7VP: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.List.unzip_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7VP_info" {
     block_cc7VP_info:
         const _cc7VP;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.129752035 UTC

[section ""data" . Control.Monad.zipWithM_closure" {
     Control.Monad.zipWithM_closure:
         const Control.Monad.zipWithM_info;
 },
 z_sc7Om_entry() //  [R1]
         { []
         }
     {offset
       cc7WV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7WW; else goto cc7WX;
       cc7WW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7WX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_sc7Om_info" {
     z_sc7Om_info:
         const z_sc7Om_entry;
         const 1;
         const 16;
 },
 go2_sc7On_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cc7Xa: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cc7Xb; else goto cc7Xc;
       cc7Xb: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Xc: // global
           I64[Sp - 48] = block_cc7X3_info;
           _sc7On::P64 = R1;
           _sc7Oi::P64 = P64[R1 + 6];
           _sc7Oj::P64 = P64[R1 + 14];
           _sc7Om::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _sc7Oi::P64;
           P64[Sp - 32] = _sc7Oj::P64;
           P64[Sp - 24] = _sc7Om::P64;
           P64[Sp - 16] = _sc7On::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uc7XE; else goto cc7X4;
       uc7XE: // global
           call _cc7X3(R1) args: 0, res: 0, upd: 0;
       cc7X4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go2_sc7On_info" {
     go2_sc7On_info:
         const go2_sc7On_entry;
         const 3;
         const 8;
         const 8589934607;
 },
 _cc7X3() //  [R1]
         { []
         }
     {offset
       cc7X3: // global
           if (R1 & 7 == 1) goto uc7XA; else goto cc7X8;
       uc7XA: // global
           Sp = Sp + 24;
           call _cc7Xq() args: 0, res: 0, upd: 0;
       cc7X8: // global
           I64[Sp - 8] = block_cc7Xi_info;
           _sc7Or::P64 = P64[R1 + 6];
           _sc7Os::P64 = P64[R1 + 14];
           R1 = P64[Sp + 40];
           P64[Sp] = _sc7Os::P64;
           P64[Sp + 40] = _sc7Or::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7XC; else goto cc7Xk;
       uc7XC: // global
           call _cc7Xi(R1) args: 0, res: 0, upd: 0;
       cc7Xk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7X3_info" {
     block_cc7X3_info:
         const _cc7X3;
         const 5;
         const 30;
 },
 _cc7Xi() //  [R1]
         { []
         }
     {offset
       cc7Xi: // global
           if (R1 & 7 == 1) goto uc7XB; else goto cc7Xr;
       uc7XB: // global
           Sp = Sp + 32;
           call _cc7Xq() args: 0, res: 0, upd: 0;
       cc7Xr: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc7Xw; else goto cc7Xv;
       cc7Xw: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7Xv: // global
           _sc7Ou::P64 = P64[R1 + 6];
           _sc7Ov::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _sc7Ov::P64;
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = _sc7Ou::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_ppp_info;
           P64[Sp + 32] = GHC.Types.:_closure+2;
           P64[Sp + 40] = Hp - 32;
           P64[Sp + 48] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7Xi_info" {
     block_cc7Xi_info:
         const _cc7Xi;
         const 6;
         const 30;
 },
 _cc7Xq() //  []
         { []
         }
     {offset
       cc7Xq: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.zipWithM_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cc7XG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7XK; else goto cc7XJ;
       cc7XK: // global
           HpAlloc = 56;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.zipWithM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7XJ: // global
           I64[Hp - 48] = z_sc7Om_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go2_sc7On_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R3 = R5;
           R2 = R4;
           R1 = Hp - 22;
           call go2_sc7On_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.zipWithM_info" {
     Control.Monad.zipWithM_info:
         const Control.Monad.zipWithM_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.144277341 UTC

[section ""data" . Control.Monad.zipWithM__closure" {
     Control.Monad.zipWithM__closure:
         const Control.Monad.zipWithM__info;
 },
 z_sc7OC_entry() //  [R1]
         { []
         }
     {offset
       cc7YD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7YE; else goto cc7YF;
       cc7YE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7YF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_sc7OC_info" {
     z_sc7OC_info:
         const z_sc7OC_entry;
         const 1;
         const 16;
 },
 go2_sc7OD_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cc7YS: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cc7YT; else goto cc7YU;
       cc7YT: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7YU: // global
           I64[Sp - 48] = block_cc7YL_info;
           _sc7OD::P64 = R1;
           _sc7Oy::P64 = P64[R1 + 6];
           _sc7Oz::P64 = P64[R1 + 14];
           _sc7OC::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _sc7Oy::P64;
           P64[Sp - 32] = _sc7Oz::P64;
           P64[Sp - 24] = _sc7OC::P64;
           P64[Sp - 16] = _sc7OD::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uc7Zm; else goto cc7YM;
       uc7Zm: // global
           call _cc7YL(R1) args: 0, res: 0, upd: 0;
       cc7YM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go2_sc7OD_info" {
     go2_sc7OD_info:
         const go2_sc7OD_entry;
         const 3;
         const 8;
         const 8589934607;
 },
 _cc7YL() //  [R1]
         { []
         }
     {offset
       cc7YL: // global
           if (R1 & 7 == 1) goto uc7Zi; else goto cc7YQ;
       uc7Zi: // global
           Sp = Sp + 24;
           call _cc7Z8() args: 0, res: 0, upd: 0;
       cc7YQ: // global
           I64[Sp - 8] = block_cc7Z0_info;
           _sc7OH::P64 = P64[R1 + 6];
           _sc7OI::P64 = P64[R1 + 14];
           R1 = P64[Sp + 40];
           P64[Sp] = _sc7OI::P64;
           P64[Sp + 40] = _sc7OH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7Zk; else goto cc7Z2;
       uc7Zk: // global
           call _cc7Z0(R1) args: 0, res: 0, upd: 0;
       cc7Z2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7YL_info" {
     block_cc7YL_info:
         const _cc7YL;
         const 5;
         const 30;
 },
 _cc7Z0() //  [R1]
         { []
         }
     {offset
       cc7Z0: // global
           if (R1 & 7 == 1) goto uc7Zj; else goto cc7Z9;
       uc7Zj: // global
           Sp = Sp + 32;
           call _cc7Z8() args: 0, res: 0, upd: 0;
       cc7Z9: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc7Ze; else goto cc7Zd;
       cc7Ze: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7Zd: // global
           _sc7OK::P64 = P64[R1 + 6];
           _sc7OL::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _sc7OL::P64;
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = _sc7OK::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 32;
           P64[Sp + 48] = Hp - 72;
           Sp = Sp + 32;
           call GHC.Base.*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc7Z0_info" {
     block_cc7Z0_info:
         const _cc7Z0;
         const 6;
         const 30;
 },
 _cc7Z8() //  []
         { []
         }
     {offset
       cc7Z8: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.zipWithM__entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cc7Zo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7Zs; else goto cc7Zr;
       cc7Zs: // global
           HpAlloc = 56;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.zipWithM__closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Zr: // global
           I64[Hp - 48] = z_sc7OC_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go2_sc7OD_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R3 = R5;
           R2 = R4;
           R1 = Hp - 22;
           call go2_sc7OD_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.zipWithM__info" {
     Control.Monad.zipWithM__info:
         const Control.Monad.zipWithM__entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.158370445 UTC

[section ""data" . Control.Monad.foldM_$sfoldM_closure" {
     Control.Monad.foldM_$sfoldM_closure:
         const Control.Monad.foldM_$sfoldM_info;
 },
 Control.Monad.foldM_$sfoldM_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc80h: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc80i; else goto cc80j;
       cc80i: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM_$sfoldM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc80j: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc80l() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . Control.Monad.foldM_$sfoldM_info" {
     Control.Monad.foldM_$sfoldM_info:
         const Control.Monad.foldM_$sfoldM_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cc80l() //  []
         { []
         }
     {offset
       cc80l: // global
           I64[Sp - 8] = block_cc80n_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc80T; else goto cc80p;
       uc80T: // global
           call _cc80n(R1) args: 0, res: 0, upd: 0;
       cc80p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc80n() //  [R1]
         { []
         }
     {offset
       cc80n: // global
           _sc7OT::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cc80v; else goto cc80D;
       cc80v: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc80y; else goto cc80x;
       cc80y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc80x: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sc7OT::P64;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc80D: // global
           I64[Sp] = block_cc80B_info;
           R3 = P64[R1 + 6];
           R2 = _sc7OT::P64;
           _sc7OW::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc7OW::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cc80n_info" {
     block_cc80n_info:
         const _cc80n;
         const 131;
         const 30;
 },
 _cc80B() //  [R1]
         { []
         }
     {offset
       cc80B: // global
           if (R1 & 7 == 1) goto cc80J; else goto cc80N;
       cc80J: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc80N: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           Sp = Sp + 8;
           call _cc80l() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cc80B_info" {
     block_cc80B_info:
         const _cc80B;
         const 131;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.169067795 UTC

[section ""data" . Control.Monad.foldM1_closure" {
     Control.Monad.foldM1_closure:
         const Control.Monad.foldM1_info;
 },
 Control.Monad.foldM1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc81r: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc81s; else goto cc81t;
       cc81s: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc81t: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc81v() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . Control.Monad.foldM1_info" {
     Control.Monad.foldM1_info:
         const Control.Monad.foldM1_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _cc81v() //  []
         { []
         }
     {offset
       cc81v: // global
           I64[Sp - 8] = block_cc81x_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc81R; else goto cc81z;
       uc81R: // global
           call _cc81x(R1) args: 0, res: 0, upd: 0;
       cc81z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc81x() //  [R1]
         { []
         }
     {offset
       cc81x: // global
           _sc7P5::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cc81F; else goto cc81K;
       cc81F: // global
           R1 = _sc7P5::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc81K: // global
           I64[Sp] = block_cc81I_info;
           R3 = P64[R1 + 6];
           R2 = _sc7P5::P64;
           _sc7P9::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc7P9::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cc81x_info" {
     block_cc81x_info:
         const _cc81x;
         const 131;
         const 30;
 },
 _cc81I() //  [R1]
         { []
         }
     {offset
       cc81I: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cc81v() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cc81I_info" {
     block_cc81I_info:
         const _cc81I;
         const 131;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.176842371 UTC

[section ""data" . Control.Monad.foldM_$sfoldM1_closure" {
     Control.Monad.foldM_$sfoldM1_closure:
         const Control.Monad.foldM_$sfoldM1_info;
 },
 Control.Monad.foldM_$sfoldM1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc82h: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Control.Monad.foldM1_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.foldM_$sfoldM1_info" {
     Control.Monad.foldM_$sfoldM1_info:
         const Control.Monad.foldM_$sfoldM1_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.18038924 UTC

[section ""data" . Control.Monad.foldM_closure" {
     Control.Monad.foldM_closure:
         const Control.Monad.foldM_info;
 },
 Control.Monad.foldM_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cc82s: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Foldable.foldlM_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.foldM_info" {
     Control.Monad.foldM_info:
         const Control.Monad.foldM_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.183856966 UTC

[section ""data" . Control.Monad.foldM_1_closure" {
     Control.Monad.foldM_1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Tuple.()_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.187212426 UTC

[section ""data" . Control.Monad.foldM__$sfoldM__closure" {
     Control.Monad.foldM__$sfoldM__closure:
         const Control.Monad.foldM__$sfoldM__info;
 },
 Control.Monad.foldM__$sfoldM__entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc82G: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc82H; else goto cc82I;
       cc82H: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM__$sfoldM__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc82I: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc82K() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . Control.Monad.foldM__$sfoldM__info" {
     Control.Monad.foldM__$sfoldM__info:
         const Control.Monad.foldM__$sfoldM__entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cc82K() //  []
         { []
         }
     {offset
       cc82K: // global
           I64[Sp - 8] = block_cc82M_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc83f; else goto cc82O;
       uc83f: // global
           call _cc82M(R1) args: 0, res: 0, upd: 0;
       cc82O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc82M() //  [R1]
         { []
         }
     {offset
       cc82M: // global
           if (R1 & 7 == 1) goto cc82U; else goto cc82Z;
       cc82U: // global
           R1 = Control.Monad.foldM_1_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc82Z: // global
           I64[Sp] = block_cc82X_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sc7Pl::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc7Pl::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cc82M_info" {
     block_cc82M_info:
         const _cc82M;
         const 131;
         const 30;
 },
 _cc82X() //  [R1]
         { []
         }
     {offset
       cc82X: // global
           if (R1 & 7 == 1) goto cc835; else goto cc839;
       cc835: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc839: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           Sp = Sp + 8;
           call _cc82K() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cc82X_info" {
     block_cc82X_info:
         const _cc82X;
         const 131;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.196222749 UTC

[section ""data" . Control.Monad.foldM_2_closure" {
     Control.Monad.foldM_2_closure:
         const Control.Monad.foldM_2_info;
 },
 Control.Monad.foldM_2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc83M: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc83N; else goto cc83O;
       cc83N: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM_2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc83O: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc83Q() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . Control.Monad.foldM_2_info" {
     Control.Monad.foldM_2_info:
         const Control.Monad.foldM_2_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _cc83Q() //  []
         { []
         }
     {offset
       cc83Q: // global
           I64[Sp - 8] = block_cc83S_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc84c; else goto cc83U;
       uc84c: // global
           call _cc83S(R1) args: 0, res: 0, upd: 0;
       cc83U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc83S() //  [R1]
         { []
         }
     {offset
       cc83S: // global
           if (R1 & 7 == 1) goto cc840; else goto cc845;
       cc840: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc845: // global
           I64[Sp] = block_cc843_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sc7Py::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc7Py::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cc83S_info" {
     block_cc83S_info:
         const _cc83S;
         const 131;
         const 30;
 },
 _cc843() //  [R1]
         { []
         }
     {offset
       cc843: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cc83Q() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cc843_info" {
     block_cc843_info:
         const _cc843;
         const 131;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.204780766 UTC

[section ""data" . Control.Monad.foldM__$sfoldM_1_closure" {
     Control.Monad.foldM__$sfoldM_1_closure:
         const Control.Monad.foldM__$sfoldM_1_info;
 },
 Control.Monad.foldM__$sfoldM_1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc84D: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Control.Monad.foldM_2_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.foldM__$sfoldM_1_info" {
     Control.Monad.foldM__$sfoldM_1_info:
         const Control.Monad.foldM__$sfoldM_1_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.209411369 UTC

[section ""data" . Control.Monad.foldM__closure" {
     Control.Monad.foldM__closure:
         const Control.Monad.foldM__info;
 },
 sat_sc7PI_entry() //  [R1]
         { []
         }
     {offset
       cc84S: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc84T; else goto cc84U;
       cc84T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc84U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sc7PI_info" {
     sat_sc7PI_info:
         const sat_sc7PI_entry;
         const 1;
         const 16;
 },
 sat_sc7PH_entry() //  [R1]
         { []
         }
     {offset
       cc84Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc850; else goto cc851;
       cc850: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc851: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Foldable.foldlM_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sc7PH_info" {
     sat_sc7PH_info:
         const sat_sc7PH_entry;
         const 5;
         const 15;
 },
 Control.Monad.foldM__entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cc852: // global
           _sc7PG::P64 = R6;
           _sc7PF::P64 = R5;
           _sc7PE::P64 = R4;
           _sc7PD::P64 = R3;
           _sc7PC::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc853; else goto cc854;
       cc854: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc856; else goto cc855;
       cc856: // global
           HpAlloc = 80;
           goto cc853;
       cc853: // global
           R6 = _sc7PG::P64;
           R5 = _sc7PF::P64;
           R4 = _sc7PE::P64;
           R3 = _sc7PD::P64;
           R2 = _sc7PC::P64;
           R1 = Control.Monad.foldM__closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc855: // global
           I64[Hp - 72] = sat_sc7PI_info;
           P64[Hp - 56] = _sc7PD::P64;
           I64[Hp - 48] = sat_sc7PH_info;
           P64[Hp - 32] = _sc7PC::P64;
           P64[Hp - 24] = _sc7PD::P64;
           P64[Hp - 16] = _sc7PE::P64;
           P64[Hp - 8] = _sc7PF::P64;
           P64[Hp] = _sc7PG::P64;
           R2 = _sc7PD::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 48;
           P64[Sp - 8] = Hp - 72;
           Sp = Sp - 24;
           call GHC.Base.>>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.foldM__info" {
     Control.Monad.foldM__info:
         const Control.Monad.foldM__entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.218040185 UTC

[section ""data" . Control.Monad.<$!>_closure" {
     Control.Monad.<$!>_closure:
         const Control.Monad.<$!>_info;
 },
 sat_sc7PO_entry() //  [R1, R2]
         { []
         }
     {offset
       cc85F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc85G; else goto cc85H;
       cc85G: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc85H: // global
           I64[Sp - 16] = block_cc85D_info;
           R2 = R2;
           _sc7PJ::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _sc7PJ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sc7PO_info" {
     sat_sc7PO_info:
         const sat_sc7PO_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _cc85D() //  [R1]
         { []
         }
     {offset
       cc85D: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc85D_info" {
     block_cc85D_info:
         const _cc85D;
         const 1;
         const 30;
 },
 Control.Monad.<$!>_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc85J: // global
           _sc7PL::P64 = R4;
           _sc7PK::P64 = R3;
           _sc7PJ::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc85K; else goto cc85L;
       cc85L: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc85N; else goto cc85M;
       cc85N: // global
           HpAlloc = 24;
           goto cc85K;
       cc85K: // global
           R4 = _sc7PL::P64;
           R3 = _sc7PK::P64;
           R2 = _sc7PJ::P64;
           R1 = Control.Monad.<$!>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc85M: // global
           I64[Hp - 16] = sat_sc7PO_info;
           P64[Hp - 8] = _sc7PJ::P64;
           P64[Hp] = _sc7PK::P64;
           R2 = _sc7PJ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sc7PL::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.<$!>_info" {
     Control.Monad.<$!>_info:
         const Control.Monad.<$!>_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.227050589 UTC

[section ""data" . Control.Monad.mfilter_closure" {
     Control.Monad.mfilter_closure:
         const Control.Monad.mfilter_info;
 },
 lvl_sc7PS_entry() //  [R1]
         { []
         }
     {offset
       cc86d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc86e; else goto cc86f;
       cc86e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc86f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_sc7PS_info" {
     lvl_sc7PS_info:
         const lvl_sc7PS_entry;
         const 1;
         const 16;
 },
 sat_sc7PW_entry() //  [R1, R2]
         { []
         }
     {offset
       cc86v: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc86w; else goto cc86x;
       cc86w: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc86x: // global
           I64[Sp - 32] = block_cc86p_info;
           _sc7PU::P64 = R2;
           R2 = R2;
           _sc7PS::P64 = P64[R1 + 15];
           _sc7PT::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 24] = _sc7PS::P64;
           P64[Sp - 16] = _sc7PT::P64;
           P64[Sp - 8] = _sc7PU::P64;
           Sp = Sp - 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sc7PW_info" {
     sat_sc7PW_info:
         const sat_sc7PW_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 _cc86p() //  [R1]
         { []
         }
     {offset
       cc86p: // global
           if (R1 & 7 == 1) goto cc86s; else goto cc86t;
       cc86s: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc86t: // global
           R2 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_p_info;
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc86p_info" {
     block_cc86p_info:
         const _cc86p;
         const 3;
         const 30;
 },
 Control.Monad.mfilter_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc86E: // global
           _sc7PR::P64 = R4;
           _sc7PQ::P64 = R3;
           _sc7PP::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cc86F; else goto cc86G;
       cc86G: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc86I; else goto cc86H;
       cc86I: // global
           HpAlloc = 24;
           goto cc86F;
       cc86F: // global
           R4 = _sc7PR::P64;
           R3 = _sc7PQ::P64;
           R2 = _sc7PP::P64;
           R1 = Control.Monad.mfilter_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc86H: // global
           I64[Hp - 16] = lvl_sc7PS_info;
           P64[Hp] = _sc7PP::P64;
           I64[Sp - 32] = block_cc86g_info;
           R2 = _sc7PP::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sc7PQ::P64;
           P64[Sp - 8] = _sc7PR::P64;
           Sp = Sp - 32;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.mfilter_info" {
     Control.Monad.mfilter_info:
         const Control.Monad.mfilter_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cc86g() //  [R1]
         { []
         }
     {offset
       cc86g: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc86L; else goto cc86K;
       cc86L: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc86K: // global
           I64[Hp - 24] = sat_sc7PW_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = Hp - 23;
           Sp = Sp + 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc86g_info" {
     block_cc86g_info:
         const _cc86g;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.237736206 UTC

[section ""cstring" . Control.Monad.$trModule4_bytes" {
     Control.Monad.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.239388858 UTC

[section ""data" . Control.Monad.$trModule3_closure" {
     Control.Monad.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.241047131 UTC

[section ""cstring" . Control.Monad.$trModule2_bytes" {
     Control.Monad.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.242887691 UTC

[section ""data" . Control.Monad.$trModule1_closure" {
     Control.Monad.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.244609953 UTC

[section ""data" . Control.Monad.$trModule_closure" {
     Control.Monad.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.$trModule3_closure+1;
         const Control.Monad.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.24732324 UTC

[section ""data" . Control.Monad.unless_$sunless_closure" {
     Control.Monad.unless_$sunless_closure:
         const Control.Monad.unless_$sunless_info;
 },
 Control.Monad.unless_$sunless_entry() //  [R2, R3]
         { []
         }
     {offset
       cc87z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc87A; else goto cc87B;
       cc87A: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.unless_$sunless_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc87B: // global
           I64[Sp - 16] = block_cc87s_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc87I; else goto cc87t;
       uc87I: // global
           call _cc87s(R1) args: 0, res: 0, upd: 0;
       cc87t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.unless_$sunless_info" {
     Control.Monad.unless_$sunless_info:
         const Control.Monad.unless_$sunless_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cc87s() //  [R1]
         { []
         }
     {offset
       cc87s: // global
           if (R1 & 7 == 1) goto cc87w; else goto cc87x;
       cc87w: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc87x: // global
           R1 = Control.Monad.foldM_1_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc87s_info" {
     block_cc87s_info:
         const _cc87s;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.253866092 UTC

[section ""data" . Control.Monad.replicateM__$sreplicateM__closure" {
     Control.Monad.replicateM__$sreplicateM__closure:
         const Control.Monad.replicateM__$sreplicateM__info;
 },
 Control.Monad.replicateM__$sreplicateM__entry() //  [R2, R3]
         { []
         }
     {offset
       cc885: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc886; else goto cc887;
       cc886: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM__$sreplicateM__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc887: // global
           I64[Sp - 16] = block_cc882_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc88E; else goto cc883;
       uc88E: // global
           call _cc882(R1) args: 0, res: 0, upd: 0;
       cc883: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.replicateM__$sreplicateM__info" {
     Control.Monad.replicateM__$sreplicateM__info:
         const Control.Monad.replicateM__$sreplicateM__entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cc882() //  [R1]
         { []
         }
     {offset
       cc882: // global
           I64[Sp] = I64[R1 + 7];
           call _cc88e() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cc882_info" {
     block_cc882_info:
         const _cc882;
         const 1;
         const 30;
 },
 _cc88e() //  []
         { []
         }
     {offset
       cc88e: // global
           if (%MO_S_Gt_W64(I64[Sp], 0)) goto cc88m; else goto cc88y;
       cc88m: // global
           I64[Sp - 8] = block_cc88k_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc88F; else goto cc88n;
       uc88F: // global
           call _cc88k(R1) args: 0, res: 0, upd: 0;
       cc88n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cc88y: // global
           R1 = Control.Monad.foldM_1_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc88k() //  [R1]
         { []
         }
     {offset
       cc88k: // global
           if (R1 & 7 == 1) goto cc88t; else goto cc88x;
       cc88t: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc88x: // global
           I64[Sp + 8] = I64[Sp + 8] - 1;
           Sp = Sp + 8;
           call _cc88e() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cc88k_info" {
     block_cc88k_info:
         const _cc88k;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.261182698 UTC

[section ""data" . Control.Monad.replicateM1_closure" {
     Control.Monad.replicateM1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.265213854 UTC

[section ""data" . Control.Monad.$w$sreplicateM_closure" {
     Control.Monad.$w$sreplicateM_closure:
         const Control.Monad.$w$sreplicateM_info;
 },
 $wloop_sc7Qc_entry() //  [R1, R2]
         { []
         }
     {offset
       cc89j: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc89k; else goto cc89l;
       cc89k: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc89l: // global
           if (%MO_S_Gt_W64(R2, 0)) goto cc89h; else goto cc89i;
       cc89h: // global
           I64[Sp - 24] = block_cc89n_info;
           _sc7Qc::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sc7Qc::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc89V; else goto cc89o;
       uc89V: // global
           call _cc89n(R1) args: 0, res: 0, upd: 0;
       cc89o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cc89i: // global
           R1 = Control.Monad.replicateM1_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . $wloop_sc7Qc_info" {
     $wloop_sc7Qc_info:
         const $wloop_sc7Qc_entry;
         const 1;
         const 9;
         const 4294967300;
 },
 _cc89n() //  [R1]
         { []
         }
     {offset
       cc89n: // global
           if (R1 & 7 == 1) goto uc89T; else goto cc89C;
       uc89T: // global
           Sp = Sp + 24;
           call _cc89I() args: 0, res: 0, upd: 0;
       cc89C: // global
           _sc7Qc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc89B_info;
           R2 = I64[Sp + 16] - 1;
           _sc7Qg::P64 = P64[R1 + 6];
           R1 = _sc7Qc::P64;
           P64[Sp + 16] = _sc7Qg::P64;
           Sp = Sp + 8;
           call $wloop_sc7Qc_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cc89n_info" {
     block_cc89n_info:
         const _cc89n;
         const 130;
         const 30;
 },
 _cc89B() //  [R1]
         { []
         }
     {offset
       cc89B: // global
           if (R1 & 7 == 1) goto uc89U; else goto cc89N;
       uc89U: // global
           Sp = Sp + 16;
           call _cc89I() args: 0, res: 0, upd: 0;
       cc89N: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc89Q; else goto cc89P;
       cc89Q: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc89P: // global
           _sc7Qj::P64 = P64[R1 + 6];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sc7Qj::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc89B_info" {
     block_cc89B_info:
         const _cc89B;
         const 1;
         const 30;
 },
 _cc89I() //  []
         { []
         }
     {offset
       cc89I: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.$w$sreplicateM_entry() //  [R2, R3]
         { []
         }
     {offset
       cc89Y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc8a2; else goto cc8a1;
       cc8a2: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$w$sreplicateM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8a1: // global
           I64[Hp - 8] = $wloop_sc7Qc_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call $wloop_sc7Qc_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.$w$sreplicateM_info" {
     Control.Monad.$w$sreplicateM_info:
         const Control.Monad.$w$sreplicateM_entry;
         const 0;
         const 14;
         const 8589934605;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.276518262 UTC

[section ""data" . Control.Monad.replicateM_$sreplicateM_closure" {
     Control.Monad.replicateM_$sreplicateM_closure:
         const Control.Monad.replicateM_$sreplicateM_info;
 },
 Control.Monad.replicateM_$sreplicateM_entry() //  [R2, R3]
         { []
         }
     {offset
       cc8aH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc8aI; else goto cc8aJ;
       cc8aI: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM_$sreplicateM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8aJ: // global
           I64[Sp - 16] = block_cc8aE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc8aN; else goto cc8aF;
       uc8aN: // global
           call _cc8aE(R1) args: 0, res: 0, upd: 0;
       cc8aF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.replicateM_$sreplicateM_info" {
     Control.Monad.replicateM_$sreplicateM_info:
         const Control.Monad.replicateM_$sreplicateM_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cc8aE() //  [R1]
         { []
         }
     {offset
       cc8aE: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Control.Monad.$w$sreplicateM_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc8aE_info" {
     block_cc8aE_info:
         const _cc8aE;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.2823206 UTC

[section ""data" . Control.Monad.unless1_closure" {
     Control.Monad.unless1_closure:
         const Control.Monad.unless1_info;
 },
 Control.Monad.unless1_entry() //  [R2, R3]
         { []
         }
     {offset
       cc8b9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc8ba; else goto cc8bb;
       cc8ba: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.unless1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8bb: // global
           I64[Sp - 16] = block_cc8b2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc8bi; else goto cc8b3;
       uc8bi: // global
           call _cc8b2(R1) args: 0, res: 0, upd: 0;
       cc8b3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.unless1_info" {
     Control.Monad.unless1_info:
         const Control.Monad.unless1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cc8b2() //  [R1]
         { []
         }
     {offset
       cc8b2: // global
           if (R1 & 7 == 1) goto cc8b6; else goto cc8b7;
       cc8b6: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       cc8b7: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc8b2_info" {
     block_cc8b2_info:
         const _cc8b2;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.287438408 UTC

[section ""data" . Control.Monad.unless_$sunless1_closure" {
     Control.Monad.unless_$sunless1_closure:
         const Control.Monad.unless_$sunless1_info;
 },
 Control.Monad.unless_$sunless1_entry() //  [R2, R3]
         { []
         }
     {offset
       cc8bB: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.unless1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.unless_$sunless1_info" {
     Control.Monad.unless_$sunless1_info:
         const Control.Monad.unless_$sunless1_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.29121633 UTC

[section ""data" . Control.Monad.unless_closure" {
     Control.Monad.unless_closure:
         const Control.Monad.unless_info;
 },
 Control.Monad.unless_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc8bT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc8bU; else goto cc8bV;
       cc8bU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.unless_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8bV: // global
           I64[Sp - 24] = block_cc8bM_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc8c2; else goto cc8bN;
       uc8c2: // global
           call _cc8bM(R1) args: 0, res: 0, upd: 0;
       cc8bN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.unless_info" {
     Control.Monad.unless_info:
         const Control.Monad.unless_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cc8bM() //  [R1]
         { []
         }
     {offset
       cc8bM: // global
           if (R1 & 7 == 1) goto cc8bQ; else goto cc8bR;
       cc8bQ: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc8bR: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc8bM_info" {
     block_cc8bM_info:
         const _cc8bM;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.297737805 UTC

[section ""data" . Control.Monad.replicateM_1_closure" {
     Control.Monad.replicateM_1_closure:
         const Control.Monad.replicateM_1_info;
 },
 Control.Monad.replicateM_1_entry() //  [R2, R3]
         { []
         }
     {offset
       cc8cp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc8cq; else goto cc8cr;
       cc8cq: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM_1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8cr: // global
           I64[Sp - 16] = block_cc8cm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc8cO; else goto cc8cn;
       uc8cO: // global
           call _cc8cm(R1) args: 0, res: 0, upd: 0;
       cc8cn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.replicateM_1_info" {
     Control.Monad.replicateM_1_info:
         const Control.Monad.replicateM_1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cc8cm() //  [R1]
         { []
         }
     {offset
       cc8cm: // global
           I64[Sp] = I64[R1 + 7];
           call _cc8cy() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cc8cm_info" {
     block_cc8cm_info:
         const _cc8cm;
         const 1;
         const 30;
 },
 _cc8cy() //  []
         { []
         }
     {offset
       cc8cy: // global
           if (%MO_S_Gt_W64(I64[Sp], 0)) goto cc8cG; else goto cc8cJ;
       cc8cG: // global
           I64[Sp - 8] = block_cc8cE_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cc8cJ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc8cE() //  []
         { []
         }
     {offset
       cc8cE: // global
           I64[Sp + 8] = I64[Sp + 8] - 1;
           Sp = Sp + 8;
           call _cc8cy() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cc8cE_info" {
     block_cc8cE_info:
         const _cc8cE;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.304857923 UTC

[section ""data" . Control.Monad.replicateM__$sreplicateM_1_closure" {
     Control.Monad.replicateM__$sreplicateM_1_closure:
         const Control.Monad.replicateM__$sreplicateM_1_info;
 },
 Control.Monad.replicateM__$sreplicateM_1_entry() //  [R2, R3]
         { []
         }
     {offset
       cc8dd: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.replicateM_1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.replicateM__$sreplicateM_1_info" {
     Control.Monad.replicateM__$sreplicateM_1_info:
         const Control.Monad.replicateM__$sreplicateM_1_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.310902906 UTC

[section ""data" . Control.Monad.$wreplicateM__closure" {
     Control.Monad.$wreplicateM__closure:
         const Control.Monad.$wreplicateM__info;
 },
 lvl_sc7QN_entry() //  [R1]
         { []
         }
     {offset
       cc8ds: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc8dt; else goto cc8du;
       cc8dt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc8du: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_sc7QN_info" {
     lvl_sc7QN_info:
         const lvl_sc7QN_entry;
         const 1;
         const 16;
 },
 sat_sc7QS_entry() //  [R1]
         { []
         }
     {offset
       cc8dJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc8dK; else goto cc8dL;
       cc8dK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc8dL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wloop_sc7QO_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sc7QS_info" {
     sat_sc7QS_info:
         const sat_sc7QS_entry;
         const 4294967297;
         const 19;
 },
 $wloop_sc7QO_entry() //  [R1, R2]
         { []
         }
     {offset
       cc8dP: // global
           _sc7QP::I64 = R2;
           _sc7QO::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cc8dQ; else goto cc8dR;
       cc8dR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc8dT; else goto cc8dS;
       cc8dT: // global
           HpAlloc = 32;
           goto cc8dQ;
       cc8dQ: // global
           R2 = _sc7QP::I64;
           R1 = _sc7QO::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc8dS: // global
           if (%MO_S_Gt_W64(_sc7QP::I64, 0)) goto cc8dN; else goto cc8dO;
       cc8dN: // global
           _sc7QK::P64 = P64[_sc7QO::P64 + 7];
           _sc7QM::P64 = P64[_sc7QO::P64 + 15];
           I64[Hp - 24] = sat_sc7QS_info;
           P64[Hp - 8] = _sc7QO::P64;
           I64[Hp] = _sc7QP::I64;
           R2 = _sc7QK::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sc7QM::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Base.*>_entry(R2) args: 32, res: 0, upd: 8;
       cc8dO: // global
           _sc7QN::P64 = P64[_sc7QO::P64 + 23];
           Hp = Hp - 32;
           R1 = _sc7QN::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . $wloop_sc7QO_info" {
     $wloop_sc7QO_info:
         const $wloop_sc7QO_entry;
         const 3;
         const 8;
         const 4294967300;
 },
 Control.Monad.$wreplicateM__entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc8dU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc8dY; else goto cc8dX;
       cc8dY: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$wreplicateM__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8dX: // global
           I64[Hp - 48] = lvl_sc7QN_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = $wloop_sc7QO_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 48;
           R2 = R3;
           R1 = Hp - 23;
           call $wloop_sc7QO_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.$wreplicateM__info" {
     Control.Monad.$wreplicateM__info:
         const Control.Monad.$wreplicateM__entry;
         const 0;
         const 14;
         const 12884901909;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.320574443 UTC

[section ""data" . Control.Monad.replicateM__closure" {
     Control.Monad.replicateM__closure:
         const Control.Monad.replicateM__info;
 },
 Control.Monad.replicateM__entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc8ey: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc8ez; else goto cc8eA;
       cc8ez: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8eA: // global
           I64[Sp - 24] = block_cc8ev_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc8eE; else goto cc8ew;
       uc8eE: // global
           call _cc8ev(R1) args: 0, res: 0, upd: 0;
       cc8ew: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.replicateM__info" {
     Control.Monad.replicateM__info:
         const Control.Monad.replicateM__entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cc8ev() //  [R1]
         { []
         }
     {offset
       cc8ev: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Control.Monad.$wreplicateM__entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc8ev_info" {
     block_cc8ev_info:
         const _cc8ev;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.327256988 UTC

[section ""data" . Control.Monad.$w$sreplicateM1_closure" {
     Control.Monad.$w$sreplicateM1_closure:
         const Control.Monad.$w$sreplicateM1_info;
 },
 $wloop_sc7R1_entry() //  [R1, R2]
         { []
         }
     {offset
       cc8f3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc8f4; else goto cc8f5;
       cc8f4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc8f5: // global
           if (%MO_S_Gt_W64(R2, 0)) goto cc8f1; else goto cc8f2;
       cc8f1: // global
           I64[Sp - 24] = block_cc8f7_info;
           _sc7R1::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp - 16] = _sc7R1::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cc8f2: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . $wloop_sc7R1_info" {
     $wloop_sc7R1_info:
         const $wloop_sc7R1_entry;
         const 1;
         const 9;
         const 8589934596;
 },
 _cc8f7() //  [R1]
         { []
         }
     {offset
       cc8f7: // global
           _sc7R1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc8fc_info;
           R2 = I64[Sp + 16] - 1;
           _sc7R7::P64 = R1;
           R1 = _sc7R1::P64;
           P64[Sp + 16] = _sc7R7::P64;
           Sp = Sp + 8;
           call $wloop_sc7R1_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cc8f7_info" {
     block_cc8f7_info:
         const _cc8f7;
         const 130;
         const 30;
 },
 _cc8fc() //  [R1]
         { []
         }
     {offset
       cc8fc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc8fi; else goto cc8fh;
       cc8fi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc8fh: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc8fc_info" {
     block_cc8fc_info:
         const _cc8fc;
         const 1;
         const 30;
 },
 Control.Monad.$w$sreplicateM1_entry() //  [R2, R3]
         { []
         }
     {offset
       cc8fj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc8fn; else goto cc8fm;
       cc8fn: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$w$sreplicateM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8fm: // global
           I64[Hp - 8] = $wloop_sc7R1_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 6;
           call $wloop_sc7R1_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.$w$sreplicateM1_info" {
     Control.Monad.$w$sreplicateM1_info:
         const Control.Monad.$w$sreplicateM1_entry;
         const 0;
         const 14;
         const 12884901901;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.335940459 UTC

[section ""data" . Control.Monad.replicateM2_closure" {
     Control.Monad.replicateM2_closure:
         const Control.Monad.replicateM2_info;
 },
 Control.Monad.replicateM2_entry() //  [R2, R3]
         { []
         }
     {offset
       cc8fS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc8fT; else goto cc8fU;
       cc8fT: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8fU: // global
           I64[Sp - 16] = block_cc8fP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc8fY; else goto cc8fQ;
       uc8fY: // global
           call _cc8fP(R1) args: 0, res: 0, upd: 0;
       cc8fQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.replicateM2_info" {
     Control.Monad.replicateM2_info:
         const Control.Monad.replicateM2_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cc8fP() //  [R1]
         { []
         }
     {offset
       cc8fP: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Control.Monad.$w$sreplicateM1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc8fP_info" {
     block_cc8fP_info:
         const _cc8fP;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.341107182 UTC

[section ""data" . Control.Monad.replicateM_$sreplicateM1_closure" {
     Control.Monad.replicateM_$sreplicateM1_closure:
         const Control.Monad.replicateM_$sreplicateM1_info;
 },
 Control.Monad.replicateM_$sreplicateM1_entry() //  [R2, R3]
         { []
         }
     {offset
       cc8gd: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.replicateM2_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.replicateM_$sreplicateM1_info" {
     Control.Monad.replicateM_$sreplicateM1_info:
         const Control.Monad.replicateM_$sreplicateM1_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.346871964 UTC

[section ""data" . Control.Monad.$wreplicateM_closure" {
     Control.Monad.$wreplicateM_closure:
         const Control.Monad.$wreplicateM_info;
 },
 lvl_sc7Rl_entry() //  [R1]
         { []
         }
     {offset
       cc8gs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc8gt; else goto cc8gu;
       cc8gt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc8gu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_sc7Rl_info" {
     lvl_sc7Rl_info:
         const lvl_sc7Rl_entry;
         const 1;
         const 16;
 },
 sat_sc7Rq_entry() //  [R1]
         { []
         }
     {offset
       cc8gJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc8gK; else goto cc8gL;
       cc8gK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc8gL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wloop_sc7Rm_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sc7Rq_info" {
     sat_sc7Rq_info:
         const sat_sc7Rq_entry;
         const 4294967297;
         const 19;
 },
 $wloop_sc7Rm_entry() //  [R1, R2]
         { []
         }
     {offset
       cc8gP: // global
           _sc7Rn::I64 = R2;
           _sc7Rm::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc8gQ; else goto cc8gR;
       cc8gR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc8gT; else goto cc8gS;
       cc8gT: // global
           HpAlloc = 32;
           goto cc8gQ;
       cc8gQ: // global
           R2 = _sc7Rn::I64;
           R1 = _sc7Rm::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc8gS: // global
           if (%MO_S_Gt_W64(_sc7Rn::I64, 0)) goto cc8gN; else goto cc8gO;
       cc8gN: // global
           _sc7Ri::P64 = P64[_sc7Rm::P64 + 7];
           _sc7Rk::P64 = P64[_sc7Rm::P64 + 15];
           I64[Hp - 24] = sat_sc7Rq_info;
           P64[Hp - 8] = _sc7Rm::P64;
           I64[Hp] = _sc7Rn::I64;
           R2 = _sc7Ri::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           P64[Sp - 16] = _sc7Rk::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
       cc8gO: // global
           _sc7Rl::P64 = P64[_sc7Rm::P64 + 23];
           Hp = Hp - 32;
           R1 = _sc7Rl::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . $wloop_sc7Rm_info" {
     $wloop_sc7Rm_info:
         const $wloop_sc7Rm_entry;
         const 3;
         const 8;
         const 4294967300;
 },
 Control.Monad.$wreplicateM_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc8gU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc8gY; else goto cc8gX;
       cc8gY: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$wreplicateM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8gX: // global
           I64[Hp - 48] = lvl_sc7Rl_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = $wloop_sc7Rm_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 48;
           R2 = R3;
           R1 = Hp - 23;
           call $wloop_sc7Rm_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.$wreplicateM_info" {
     Control.Monad.$wreplicateM_info:
         const Control.Monad.$wreplicateM_entry;
         const 0;
         const 14;
         const 12884901909;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.356404458 UTC

[section ""data" . Control.Monad.replicateM_closure" {
     Control.Monad.replicateM_closure:
         const Control.Monad.replicateM_info;
 },
 Control.Monad.replicateM_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cc8hA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc8hB; else goto cc8hC;
       cc8hB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8hC: // global
           I64[Sp - 24] = block_cc8hx_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc8hG; else goto cc8hy;
       uc8hG: // global
           call _cc8hx(R1) args: 0, res: 0, upd: 0;
       cc8hy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.replicateM_info" {
     Control.Monad.replicateM_info:
         const Control.Monad.replicateM_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cc8hx() //  [R1]
         { []
         }
     {offset
       cc8hx: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Control.Monad.$wreplicateM_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cc8hx_info" {
     block_cc8hx_info:
         const _cc8hx;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:02.361643309 UTC

[section ""relreadonly" . Sc8hR_srt" { Sc8hR_srt:
 }]

