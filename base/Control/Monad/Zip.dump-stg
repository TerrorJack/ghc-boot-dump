
==================== Pre unarise: ====================
2018-03-16 16:08:39.362195634 UTC

Control.Monad.Zip.$p1MonadZip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     GHC.Base.Monad m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sdtIm]
        case v_sdtIm of {
          Control.Monad.Zip.C:MonadZip v_sdtIo [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdtIo;
        };

Control.Monad.Zip.mzip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b. m a -> m b -> m (a, b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sdtIs]
        case v_sdtIs of {
          Control.Monad.Zip.C:MonadZip _ [Occ=Dead]
                                       v_sdtIv [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdtIv;
        };

Control.Monad.Zip.mzipWith
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b c. (a -> b -> c) -> m a -> m b -> m c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sdtIy]
        case v_sdtIy of {
          Control.Monad.Zip.C:MonadZip _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdtIC [Occ=Once]
                                       _ [Occ=Dead] ->
              v_sdtIC;
        };

Control.Monad.Zip.munzip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b. m (a, b) -> (m a, m b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sdtIE]
        case v_sdtIE of {
          Control.Monad.Zip.C:MonadZip _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdtIJ [Occ=Once] ->
              v_sdtIJ;
        };

Control.Monad.Zip.$fMonadZip[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Base.$fMonad[]
                                                 GHC.List.zip
                                                 GHC.List.zipWith
                                                 GHC.List.unzip];

Control.Monad.Zip.$w$cmunzip3 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty (a, b)
     -> (# GHC.Base.NonEmpty a, GHC.Base.NonEmpty b #)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(1*U,1*U),U)>,
 Unf=OtherCon []] =
    [] \r [w_sdtIK]
        let {
          sat_sdtJ7 [Occ=Once] :: [b_sdtv1]
          [LclId] =
              [w_sdtIK] \u []
                  case w_sdtIK of {
                    GHC.Base.:| _ [Occ=Dead] as_sdtJ6 [Occ=Once] ->
                        GHC.Base.map Data.Tuple.snd as_sdtJ6;
                  }; } in
        let {
          sat_sdtJ3 [Occ=Once] :: b_sdtv1
          [LclId] =
              [w_sdtIK] \u []
                  case w_sdtIK of {
                    GHC.Base.:| a1_sdtIY [Occ=Once!] _ [Occ=Dead] ->
                        case a1_sdtIY of {
                          (,) _ [Occ=Dead] y_sdtJ2 [Occ=Once] -> y_sdtJ2;
                        };
                  }; } in
        let {
          sat_sdtJ8 [Occ=Once] :: GHC.Base.NonEmpty b_sdtv1
          [LclId] =
              CCCS GHC.Base.:|! [sat_sdtJ3 sat_sdtJ7]; } in
        let {
          sat_sdtIV [Occ=Once] :: [a_sdtv0]
          [LclId] =
              [w_sdtIK] \u []
                  case w_sdtIK of {
                    GHC.Base.:| _ [Occ=Dead] as_sdtIU [Occ=Once] ->
                        GHC.Base.map Data.Tuple.fst as_sdtIU;
                  }; } in
        let {
          sat_sdtIR [Occ=Once] :: a_sdtv0
          [LclId] =
              [w_sdtIK] \u []
                  case w_sdtIK of {
                    GHC.Base.:| a1_sdtIM [Occ=Once!] _ [Occ=Dead] ->
                        case a1_sdtIM of {
                          (,) x_sdtIP [Occ=Once] _ [Occ=Dead] -> x_sdtIP;
                        };
                  }; } in
        let {
          sat_sdtIW [Occ=Once] :: GHC.Base.NonEmpty a_sdtv0
          [LclId] =
              CCCS GHC.Base.:|! [sat_sdtIR sat_sdtIV];
        } in  (#,#) [sat_sdtIW sat_sdtJ8];

Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty (a, b)
     -> (GHC.Base.NonEmpty a, GHC.Base.NonEmpty b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(U,U),U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdtJ9]
        case Control.Monad.Zip.$w$cmunzip3 w_sdtJ9 of {
          (#,#) ww1_sdtJb [Occ=Once] ww2_sdtJc [Occ=Once] ->
              (,) [ww1_sdtJb ww2_sdtJc];
        };

Control.Monad.Zip.$fMonadZipNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip GHC.Base.NonEmpty
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Base.$fMonadNonEmpty
                                                 Data.List.NonEmpty.zip
                                                 Data.List.NonEmpty.zipWith
                                                 Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip];

Control.Monad.Zip.$fMonadZipIdentity_$cmunzip
  :: forall a b.
     Data.Functor.Identity.Identity (a, b)
     -> (Data.Functor.Identity.Identity a,
         Data.Functor.Identity.Identity b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sdtJd] ds_sdtJd;

Control.Monad.Zip.$fMonadZipIdentity1
  :: forall b a c.
     (a -> b -> c)
     -> Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdtJh m1_sdtJi m2_sdtJj] f_sdtJh m1_sdtJi m2_sdtJj;

Control.Monad.Zip.$fMonadZipDual1
  :: forall b a c.
     (a -> b -> c)
     -> Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual b
     -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdtJk m1_sdtJl m2_sdtJm] f_sdtJk m1_sdtJl m2_sdtJm;

Control.Monad.Zip.$fMonadZipSum1
  :: forall b a c.
     (a -> b -> c)
     -> Data.Semigroup.Internal.Sum a
     -> Data.Semigroup.Internal.Sum b
     -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdtJn m1_sdtJo m2_sdtJp] f_sdtJn m1_sdtJo m2_sdtJp;

Control.Monad.Zip.$fMonadZipProduct1
  :: forall b a c.
     (a -> b -> c)
     -> Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product b
     -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdtJq m1_sdtJr m2_sdtJs] f_sdtJq m1_sdtJr m2_sdtJs;

Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdtJt m1_sdtJu m2_sdtJv]
        case m1_sdtJu of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdtJx [Occ=Once] ->
              case m2_sdtJv of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdtJz [Occ=Once] ->
                    let {
                      sat_sdtJA [Occ=Once] :: c_adtcP
                      [LclId] =
                          [f_sdtJt x_sdtJx x1_sdtJz] \u [] f_sdtJt x_sdtJx x1_sdtJz;
                    } in  GHC.Base.Just [sat_sdtJA];
              };
        };

Control.Monad.Zip.$fMonadZipFirst1
  :: forall a b c.
     (a -> b -> c)
     -> Data.Monoid.First a -> Data.Monoid.First b -> GHC.Base.Maybe c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdtJB m1_sdtJC m2_sdtJD]
        case m1_sdtJC of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdtJF [Occ=Once] ->
              case m2_sdtJD of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdtJH [Occ=Once] ->
                    let {
                      sat_sdtJI [Occ=Once] :: c_adtcc
                      [LclId] =
                          [f_sdtJB x_sdtJF x1_sdtJH] \u [] f_sdtJB x_sdtJF x1_sdtJH;
                    } in  GHC.Base.Just [sat_sdtJI];
              };
        };

Control.Monad.Zip.$fMonadZipLast1
  :: forall a b c.
     (a -> b -> c)
     -> Data.Monoid.Last a -> Data.Monoid.Last b -> GHC.Base.Maybe c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdtJJ m1_sdtJK m2_sdtJL]
        case m1_sdtJK of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdtJN [Occ=Once] ->
              case m2_sdtJL of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdtJP [Occ=Once] ->
                    let {
                      sat_sdtJQ [Occ=Once] :: c_adtbz
                      [LclId] =
                          [f_sdtJJ x_sdtJN x1_sdtJP] \u [] f_sdtJJ x_sdtJN x1_sdtJP;
                    } in  GHC.Base.Just [sat_sdtJQ];
              };
        };

Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     GHC.Base.Monad (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtJR]
        let {
          sat_sdtJS [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Monad f_Xdtc6
          [LclId] =
              [$dMonadZip_sdtJR] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdtJR;
        } in  Data.Semigroup.Internal.$fMonadAlt sat_sdtJS;

Control.Monad.Zip.$fMonadZipProxy_$cmzipWith
  :: forall a b c.
     (a -> b -> c)
     -> Data.Proxy.Proxy a -> Data.Proxy.Proxy b -> Data.Proxy.Proxy c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdtJT ds1_sdtJU ds2_sdtJV] Data.Proxy.Proxy [];

Control.Monad.Zip.$fMonadZipU1_$cmzipWith
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Generics.U1 a -> GHC.Generics.U1 b -> GHC.Generics.U1 c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdtJW ds1_sdtJX ds2_sdtJY] GHC.Generics.U1 [];

Control.Monad.Zip.$fMonadZipPar2
  :: forall b a c.
     (a -> b -> c) -> GHC.Generics.Par1 a -> GHC.Generics.Par1 b -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdtJZ m1_sdtK0 m2_sdtK1] f_sdtJZ m1_sdtK0 m2_sdtK1;

Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     GHC.Base.Monad (GHC.Generics.Rec1 f)
[GblId,
 Arity=1,
 Str=<L,1*U(1*U(U(1*U(1*U,1*U),U,1*U,1*U,1*U,1*U),C(C1(U)),A,A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtK2]
        let {
          sat_sdtK3 [Occ=Once,
                     Dmd=<L,U(U(1*U(1*U,1*U),U,1*U,1*U,1*U,1*U),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_Xdt9S
          [LclId] =
              [$dMonadZip_sdtK2] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdtK2;
        } in  GHC.Generics.$fMonadRec1 sat_sdtK3;

Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     GHC.Base.Monad (GHC.Generics.M1 i c f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtK4]
        let {
          sat_sdtK5 [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Monad f_Xdt9j
          [LclId] =
              [$dMonadZip_sdtK4] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdtK4;
        } in  GHC.Generics.$fMonadM1 sat_sdtK5;

Control.Monad.Zip.$fMonadZip:*:_$cmzipWith [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b c.
     (a -> b -> c)
     -> (GHC.Generics.:*:) f g a
     -> (GHC.Generics.:*:) f g b
     -> (GHC.Generics.:*:) f g c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A)><L,1*U(A,A,1*C1(C1(C1(U))),A)><L,U><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdtK6 w1_sdtK7 w2_sdtK8 w3_sdtK9 w4_sdtKa]
        case w3_sdtK9 of {
          GHC.Generics.:*: ww1_sdtKc [Occ=Once] ww2_sdtKd [Occ=Once] ->
              case w4_sdtKa of {
                GHC.Generics.:*: ww4_sdtKf [Occ=Once] ww5_sdtKg [Occ=Once] ->
                    let {
                      sat_sdtKi [Occ=Once] :: g_sdtv8 c_sdtvd
                      [LclId] =
                          [w1_sdtK7 w2_sdtK8 ww2_sdtKd ww5_sdtKg] \u []
                              Control.Monad.Zip.mzipWith
                                  w1_sdtK7 w2_sdtK8 ww2_sdtKd ww5_sdtKg; } in
                    let {
                      sat_sdtKh [Occ=Once] :: f_sdtv7 c_sdtvd
                      [LclId] =
                          [w_sdtK6 w2_sdtK8 ww1_sdtKc ww4_sdtKf] \u []
                              Control.Monad.Zip.mzipWith w_sdtK6 w2_sdtK8 ww1_sdtKc ww4_sdtKf;
                    } in  GHC.Generics.:*: [sat_sdtKh sat_sdtKi];
              };
        };

Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     GHC.Base.Monad (f GHC.Generics.:*: g)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtKj $dMonadZip1_sdtKk]
        let {
          sat_sdtKm [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_adt6u
          [LclId] =
              [$dMonadZip1_sdtKk] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip1_sdtKk; } in
        let {
          sat_sdtKl [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_adt6t
          [LclId] =
              [$dMonadZip_sdtKj] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdtKj;
        } in  GHC.Generics.$fMonad:*: sat_sdtKl sat_sdtKm;

Control.Monad.Zip.$dmmunzip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b. m (a, b) -> (m a, m b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtKn eta_sdtKo]
        let {
          $dMonad_sdtKp [Dmd=<L,U(A,C(C1(U)),A,C(U),A)>]
            :: GHC.Base.Monad m_adt27
          [LclId] =
              [$dMonadZip_sdtKn] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdtKn; } in
        let {
          sat_sdtKD [Occ=Once] :: m_adt27 b_adt6d
          [LclId] =
              [eta_sdtKo $dMonad_sdtKp] \u []
                  let {
                    sat_sdtKC [Occ=Once] :: (a_adt6c, b_adt6d) -> m_adt27 b_adt6d
                    [LclId] =
                        [$dMonad_sdtKp] \r [x1_sdtKx]
                            let {
                              sat_sdtKB [Occ=Once] :: b_adt6d
                              [LclId] =
                                  [x1_sdtKx] \u []
                                      case x1_sdtKx of {
                                        (,) _ [Occ=Dead] y_sdtKA [Occ=Once] -> y_sdtKA;
                                      };
                            } in  GHC.Base.return $dMonad_sdtKp sat_sdtKB;
                  } in  GHC.Base.>>= $dMonad_sdtKp eta_sdtKo sat_sdtKC; } in
        let {
          sat_sdtKw [Occ=Once] :: m_adt27 a_adt6c
          [LclId] =
              [eta_sdtKo $dMonad_sdtKp] \u []
                  let {
                    sat_sdtKv [Occ=Once] :: (a_adt6c, b_adt6d) -> m_adt27 a_adt6c
                    [LclId] =
                        [$dMonad_sdtKp] \r [x1_sdtKq]
                            let {
                              sat_sdtKu [Occ=Once] :: a_adt6c
                              [LclId] =
                                  [x1_sdtKq] \u []
                                      case x1_sdtKq of {
                                        (,) x_sdtKs [Occ=Once] _ [Occ=Dead] -> x_sdtKs;
                                      };
                            } in  GHC.Base.return $dMonad_sdtKp sat_sdtKu;
                  } in  GHC.Base.>>= $dMonad_sdtKp eta_sdtKo sat_sdtKv;
        } in  (,) [sat_sdtKw sat_sdtKD];

Control.Monad.Zip.$dmmzipWith
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b c. (a -> b -> c) -> m a -> m b -> m c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S))LLL)LLL),U(1*U(A,1*C1(C1(U)),A,C(U),A),1*C1(C1(U)),A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtKE eta_sdtKF eta1_sdtKG eta2_sdtKH]
        case
            Control.Monad.Zip.$p1MonadZip $dMonadZip_sdtKE
        of
        $dMonad_sdtKI [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
        { __DEFAULT ->
              let {
                sat_sdtKU [Occ=Once] :: (a_adt5U, b_adt5V) -> m_adt27 c_adt5W
                [LclId] =
                    [eta_sdtKF $dMonad_sdtKI] \r [x1_sdtKK]
                        let {
                          sat_sdtKT [Occ=Once] :: c_adt5W
                          [LclId] =
                              [eta_sdtKF x1_sdtKK] \u []
                                  let {
                                    sat_sdtKS [Occ=Once] :: b_adt5V
                                    [LclId] =
                                        [x1_sdtKK] \u []
                                            case x1_sdtKK of {
                                              (,) _ [Occ=Dead] y_sdtKR [Occ=Once] -> y_sdtKR;
                                            }; } in
                                  let {
                                    sat_sdtKO [Occ=Once] :: a_adt5U
                                    [LclId] =
                                        [x1_sdtKK] \u []
                                            case x1_sdtKK of {
                                              (,) x_sdtKM [Occ=Once] _ [Occ=Dead] -> x_sdtKM;
                                            };
                                  } in  eta_sdtKF sat_sdtKO sat_sdtKS;
                        } in  GHC.Base.return $dMonad_sdtKI sat_sdtKT; } in
              let {
                sat_sdtKJ [Occ=Once] :: m_adt27 (a_adt5U, b_adt5V)
                [LclId] =
                    [$dMonadZip_sdtKE eta1_sdtKG eta2_sdtKH] \u []
                        Control.Monad.Zip.mzip $dMonadZip_sdtKE eta1_sdtKG eta2_sdtKH;
              } in  GHC.Base.>>= $dMonad_sdtKI sat_sdtKJ sat_sdtKU;
        };

Control.Monad.Zip.$dmmzip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b. m a -> m b -> m (a, b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLC(S)L),1*U(A,A,1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtKV]
        Control.Monad.Zip.mzipWith $dMonadZip_sdtKV GHC.Tuple.(,);

Control.Monad.Zip.$fMonadZip:*:_$cmzip
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     (GHC.Generics.:*:) f g a
     -> (GHC.Generics.:*:) f g b -> (GHC.Generics.:*:) f g (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A)><L,1*U(A,A,1*C1(C1(C1(U))),A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtKW $dMonadZip1_sdtKX w_sdtKY w1_sdtKZ]
        case w_sdtKY of {
          GHC.Generics.:*: ww1_sdtL1 [Occ=Once] ww2_sdtL2 [Occ=Once] ->
              case w1_sdtKZ of {
                GHC.Generics.:*: ww4_sdtL4 [Occ=Once] ww5_sdtL5 [Occ=Once] ->
                    let {
                      sat_sdtL7 [Occ=Once] :: g_adt6u (a_adt6E, b_adt6F)
                      [LclId] =
                          [$dMonadZip1_sdtKX ww2_sdtL2 ww5_sdtL5] \u []
                              Control.Monad.Zip.mzipWith
                                  $dMonadZip1_sdtKX GHC.Tuple.(,) ww2_sdtL2 ww5_sdtL5; } in
                    let {
                      sat_sdtL6 [Occ=Once] :: f_adt6t (a_adt6E, b_adt6F)
                      [LclId] =
                          [$dMonadZip_sdtKW ww1_sdtL1 ww4_sdtL4] \u []
                              Control.Monad.Zip.mzipWith
                                  $dMonadZip_sdtKW GHC.Tuple.(,) ww1_sdtL1 ww4_sdtL4;
                    } in  GHC.Generics.:*: [sat_sdtL6 sat_sdtL7];
              };
        };

Control.Monad.Zip.$w$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     (GHC.Generics.:*:) f g (a, b)
     -> (# (GHC.Generics.:*:) f g a, (GHC.Generics.:*:) f g b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdtL8 w1_sdtL9 w2_sdtLa]
        let {
          $dMonad_sdtLb [Dmd=<L,U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_sdtvG
          [LclId] =
              [w1_sdtL9] \u [] Control.Monad.Zip.$p1MonadZip w1_sdtL9; } in
        let {
          lvl_sdtLc [Dmd=<L,U(A,C(U),A,A,A,A)>]
            :: GHC.Base.Applicative g_sdtvG
          [LclId] =
              [$dMonad_sdtLb] \u [] GHC.Base.$p1Monad $dMonad_sdtLb; } in
        let {
          $dMonad1_sdtLd [Dmd=<L,U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_sdtvF
          [LclId] =
              [w_sdtL8] \u [] Control.Monad.Zip.$p1MonadZip w_sdtL8; } in
        let {
          lvl1_sdtLe [Dmd=<L,U(A,C(U),A,A,A,A)>]
            :: GHC.Base.Applicative f_sdtvF
          [LclId] =
              [$dMonad1_sdtLd] \u [] GHC.Base.$p1Monad $dMonad1_sdtLd; } in
        let {
          sat_sdtLO [Occ=Once] :: (GHC.Generics.:*:) f_sdtvF g_sdtvG b_sdtvK
          [LclId] =
              [w2_sdtLa $dMonad_sdtLb lvl_sdtLc $dMonad1_sdtLd lvl1_sdtLe] \u []
                  case w2_sdtLa of {
                    GHC.Generics.:*: ww1_sdtLy [Occ=Once] ww2_sdtLz [Occ=Once] ->
                        let {
                          sat_sdtLN [Occ=Once] :: g_sdtvG b_sdtvK
                          [LclId] =
                              [$dMonad_sdtLb lvl_sdtLc ww2_sdtLz] \u []
                                  let {
                                    sat_sdtLM [Occ=Once] :: (a_sdtvJ, b_sdtvK) -> g_sdtvG b_sdtvK
                                    [LclId] =
                                        [lvl_sdtLc] \r [a1_sdtLH]
                                            let {
                                              sat_sdtLL [Occ=Once] :: b_sdtvK
                                              [LclId] =
                                                  [a1_sdtLH] \u []
                                                      case a1_sdtLH of {
                                                        (,) _ [Occ=Dead] y_sdtLK [Occ=Once] ->
                                                            y_sdtLK;
                                                      };
                                            } in  GHC.Base.pure lvl_sdtLc sat_sdtLL;
                                  } in  GHC.Base.>>= $dMonad_sdtLb ww2_sdtLz sat_sdtLM; } in
                        let {
                          sat_sdtLG [Occ=Once] :: f_sdtvF b_sdtvK
                          [LclId] =
                              [$dMonad1_sdtLd lvl1_sdtLe ww1_sdtLy] \u []
                                  let {
                                    sat_sdtLF [Occ=Once] :: (a_sdtvJ, b_sdtvK) -> f_sdtvF b_sdtvK
                                    [LclId] =
                                        [lvl1_sdtLe] \r [a1_sdtLA]
                                            let {
                                              sat_sdtLE [Occ=Once] :: b_sdtvK
                                              [LclId] =
                                                  [a1_sdtLA] \u []
                                                      case a1_sdtLA of {
                                                        (,) _ [Occ=Dead] y_sdtLD [Occ=Once] ->
                                                            y_sdtLD;
                                                      };
                                            } in  GHC.Base.pure lvl1_sdtLe sat_sdtLE;
                                  } in  GHC.Base.>>= $dMonad1_sdtLd ww1_sdtLy sat_sdtLF;
                        } in  GHC.Generics.:*: [sat_sdtLG sat_sdtLN];
                  }; } in
        let {
          sat_sdtLw [Occ=Once] :: (GHC.Generics.:*:) f_sdtvF g_sdtvG a_sdtvJ
          [LclId] =
              [w2_sdtLa $dMonad_sdtLb lvl_sdtLc $dMonad1_sdtLd lvl1_sdtLe] \u []
                  case w2_sdtLa of {
                    GHC.Generics.:*: ww1_sdtLg [Occ=Once] ww2_sdtLh [Occ=Once] ->
                        let {
                          sat_sdtLv [Occ=Once] :: g_sdtvG a_sdtvJ
                          [LclId] =
                              [$dMonad_sdtLb lvl_sdtLc ww2_sdtLh] \u []
                                  let {
                                    sat_sdtLu [Occ=Once] :: (a_sdtvJ, b_sdtvK) -> g_sdtvG a_sdtvJ
                                    [LclId] =
                                        [lvl_sdtLc] \r [a1_sdtLp]
                                            let {
                                              sat_sdtLt [Occ=Once] :: a_sdtvJ
                                              [LclId] =
                                                  [a1_sdtLp] \u []
                                                      case a1_sdtLp of {
                                                        (,) x_sdtLr [Occ=Once] _ [Occ=Dead] ->
                                                            x_sdtLr;
                                                      };
                                            } in  GHC.Base.pure lvl_sdtLc sat_sdtLt;
                                  } in  GHC.Base.>>= $dMonad_sdtLb ww2_sdtLh sat_sdtLu; } in
                        let {
                          sat_sdtLo [Occ=Once] :: f_sdtvF a_sdtvJ
                          [LclId] =
                              [$dMonad1_sdtLd lvl1_sdtLe ww1_sdtLg] \u []
                                  let {
                                    sat_sdtLn [Occ=Once] :: (a_sdtvJ, b_sdtvK) -> f_sdtvF a_sdtvJ
                                    [LclId] =
                                        [lvl1_sdtLe] \r [a1_sdtLi]
                                            let {
                                              sat_sdtLm [Occ=Once] :: a_sdtvJ
                                              [LclId] =
                                                  [a1_sdtLi] \u []
                                                      case a1_sdtLi of {
                                                        (,) x_sdtLk [Occ=Once] _ [Occ=Dead] ->
                                                            x_sdtLk;
                                                      };
                                            } in  GHC.Base.pure lvl1_sdtLe sat_sdtLm;
                                  } in  GHC.Base.>>= $dMonad1_sdtLd ww1_sdtLg sat_sdtLn;
                        } in  GHC.Generics.:*: [sat_sdtLo sat_sdtLv];
                  };
        } in  (#,#) [sat_sdtLw sat_sdtLO];

Control.Monad.Zip.$fMonadZip:*:_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     (GHC.Generics.:*:) f g (a, b)
     -> ((GHC.Generics.:*:) f g a, (GHC.Generics.:*:) f g b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdtLP w1_sdtLQ w2_sdtLR]
        case Control.Monad.Zip.$w$cmunzip w_sdtLP w1_sdtLQ w2_sdtLR of {
          (#,#) ww1_sdtLT [Occ=Once] ww2_sdtLU [Occ=Once] ->
              (,) [ww1_sdtLT ww2_sdtLU];
        };

Control.Monad.Zip.$fMonadZip:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     Control.Monad.Zip.MonadZip (f GHC.Generics.:*: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)><L,U(U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sdtLV $dMonadZip1_sdtLW]
        let {
          sat_sdtM0 [Occ=Once]
            :: forall a b.
               (GHC.Generics.:*:) f_adt6t g_adt6u (a, b)
               -> ((GHC.Generics.:*:) f_adt6t g_adt6u a,
                   (GHC.Generics.:*:) f_adt6t g_adt6u b)
          [LclId] =
              [$dMonadZip_sdtLV $dMonadZip1_sdtLW] \r [eta_B1]
                  Control.Monad.Zip.$fMonadZip:*:_$cmunzip
                      $dMonadZip_sdtLV $dMonadZip1_sdtLW eta_B1; } in
        let {
          sat_sdtLZ [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> (GHC.Generics.:*:) f_adt6t g_adt6u a
               -> (GHC.Generics.:*:) f_adt6t g_adt6u b
               -> (GHC.Generics.:*:) f_adt6t g_adt6u c
          [LclId] =
              [$dMonadZip_sdtLV $dMonadZip1_sdtLW] \r [eta_B3 eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZip:*:_$cmzipWith
                      $dMonadZip_sdtLV $dMonadZip1_sdtLW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdtLY [Occ=Once]
            :: forall a b.
               (GHC.Generics.:*:) f_adt6t g_adt6u a
               -> (GHC.Generics.:*:) f_adt6t g_adt6u b
               -> (GHC.Generics.:*:) f_adt6t g_adt6u (a, b)
          [LclId] =
              [$dMonadZip_sdtLV $dMonadZip1_sdtLW] \r [eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZip:*:_$cmzip
                      $dMonadZip_sdtLV $dMonadZip1_sdtLW eta_B2 eta_B1; } in
        let {
          sat_sdtLX [Occ=Once]
            :: GHC.Base.Monad (f_adt6t GHC.Generics.:*: g_adt6u)
          [LclId] =
              [$dMonadZip_sdtLV $dMonadZip1_sdtLW] \u []
                  Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip
                      $dMonadZip_sdtLV $dMonadZip1_sdtLW;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sdtLX
                                        sat_sdtLY
                                        sat_sdtLZ
                                        sat_sdtM0];

Control.Monad.Zip.$fMonadZipM2
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.M1 i c f a -> GHC.Generics.M1 i c f b -> f (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtM1 ds_sdtM2 ds1_sdtM3]
        Control.Monad.Zip.mzipWith
            $dMonadZip_sdtM1 GHC.Tuple.(,) ds_sdtM2 ds1_sdtM3;

Control.Monad.Zip.$w$cmunzip2 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.M1 i c f (a, b)
     -> (# GHC.Generics.M1 i c f a, GHC.Generics.M1 i c f b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdtM4 w1_sdtM5]
        let {
          $dMonad_sdtM6 [Dmd=<L,U(A,C(C1(U)),A,C(U),A)>]
            :: GHC.Base.Monad f_sdtvQ
          [LclId] =
              [w_sdtM4] \u [] Control.Monad.Zip.$p1MonadZip w_sdtM4; } in
        let {
          sat_sdtMk [Occ=Once]
            :: GHC.Generics.M1 i_sdtvR c_sdtvS f_sdtvQ b_sdtvV
          [LclId] =
              [w1_sdtM5 $dMonad_sdtM6] \u []
                  let {
                    sat_sdtMj [Occ=Once] :: (a_sdtvU, b_sdtvV) -> f_sdtvQ b_sdtvV
                    [LclId] =
                        [$dMonad_sdtM6] \r [x1_sdtMe]
                            let {
                              sat_sdtMi [Occ=Once] :: b_sdtvV
                              [LclId] =
                                  [x1_sdtMe] \u []
                                      case x1_sdtMe of {
                                        (,) _ [Occ=Dead] y_sdtMh [Occ=Once] -> y_sdtMh;
                                      };
                            } in  GHC.Base.return $dMonad_sdtM6 sat_sdtMi;
                  } in  GHC.Base.>>= $dMonad_sdtM6 w1_sdtM5 sat_sdtMj; } in
        let {
          sat_sdtMd [Occ=Once]
            :: GHC.Generics.M1 i_sdtvR c_sdtvS f_sdtvQ a_sdtvU
          [LclId] =
              [w1_sdtM5 $dMonad_sdtM6] \u []
                  let {
                    sat_sdtMc [Occ=Once] :: (a_sdtvU, b_sdtvV) -> f_sdtvQ a_sdtvU
                    [LclId] =
                        [$dMonad_sdtM6] \r [x1_sdtM7]
                            let {
                              sat_sdtMb [Occ=Once] :: a_sdtvU
                              [LclId] =
                                  [x1_sdtM7] \u []
                                      case x1_sdtM7 of {
                                        (,) x_sdtM9 [Occ=Once] _ [Occ=Dead] -> x_sdtM9;
                                      };
                            } in  GHC.Base.return $dMonad_sdtM6 sat_sdtMb;
                  } in  GHC.Base.>>= $dMonad_sdtM6 w1_sdtM5 sat_sdtMc;
        } in  (#,#) [sat_sdtMd sat_sdtMk];

Control.Monad.Zip.$fMonadZipM1_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.M1 i c f (a, b)
     -> (GHC.Generics.M1 i c f a, GHC.Generics.M1 i c f b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdtMl w1_sdtMm]
        case Control.Monad.Zip.$w$cmunzip2 w_sdtMl w1_sdtMm of {
          (#,#) ww1_sdtMo [Occ=Once] ww2_sdtMp [Occ=Once] ->
              (,) [ww1_sdtMo ww2_sdtMp];
        };

Control.Monad.Zip.$fMonadZipM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     Control.Monad.Zip.MonadZip (GHC.Generics.M1 i c f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),U,1*U,U,1*U),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sdtMq]
        let {
          sat_sdtMx [Occ=Once]
            :: forall a b.
               GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s (a, b)
               -> (GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s a,
                   GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s b)
          [LclId] =
              [$dMonadZip_sdtMq] \r [eta_B1]
                  Control.Monad.Zip.$fMonadZipM1_$cmunzip
                      $dMonadZip_sdtMq eta_B1; } in
        let {
          sat_sdtMw [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s a
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s b
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s c
          [LclId] =
              [$dMonadZip_sdtMq] \r [f1_sdtMt ds_sdtMu ds1_sdtMv]
                  Control.Monad.Zip.mzipWith
                      $dMonadZip_sdtMq f1_sdtMt ds_sdtMu ds1_sdtMv; } in
        let {
          sat_sdtMs [Occ=Once]
            :: forall a b.
               GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s a
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s b
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s (a, b)
          [LclId] =
              [$dMonadZip_sdtMq] \r [eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZipM2 $dMonadZip_sdtMq eta_B2 eta_B1; } in
        let {
          sat_sdtMr [Occ=Once]
            :: GHC.Base.Monad (GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s)
          [LclId] =
              [$dMonadZip_sdtMq] \u []
                  Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip $dMonadZip_sdtMq;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sdtMr
                                        sat_sdtMs
                                        sat_sdtMw
                                        sat_sdtMx];

Control.Monad.Zip.$fMonadZipRec2
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.Rec1 f a -> GHC.Generics.Rec1 f b -> f (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtMy ds_sdtMz ds1_sdtMA]
        Control.Monad.Zip.mzipWith
            $dMonadZip_sdtMy GHC.Tuple.(,) ds_sdtMz ds1_sdtMA;

Control.Monad.Zip.$w$cmunzip4 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.Rec1 f (a, b)
     -> (# GHC.Generics.Rec1 f a, GHC.Generics.Rec1 f b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdtMB w1_sdtMC]
        let {
          $dMonad_sdtMD [Dmd=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_sdtw1
          [LclId] =
              [w_sdtMB] \u [] Control.Monad.Zip.$p1MonadZip w_sdtMB; } in
        let {
          sat_sdtMT [Occ=Once] :: GHC.Generics.Rec1 f_sdtw1 b_sdtw4
          [LclId] =
              [w1_sdtMC $dMonad_sdtMD] \u []
                  let {
                    lvl_sdtMM [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                      :: GHC.Base.Applicative f_sdtw1
                    [LclId] =
                        [$dMonad_sdtMD] \u [] GHC.Base.$p1Monad $dMonad_sdtMD; } in
                  let {
                    sat_sdtMS [Occ=Once] :: (a_sdtw3, b_sdtw4) -> f_sdtw1 b_sdtw4
                    [LclId] =
                        [lvl_sdtMM] \r [a1_sdtMN]
                            let {
                              sat_sdtMR [Occ=Once] :: b_sdtw4
                              [LclId] =
                                  [a1_sdtMN] \u []
                                      case a1_sdtMN of {
                                        (,) _ [Occ=Dead] y_sdtMQ [Occ=Once] -> y_sdtMQ;
                                      };
                            } in  GHC.Base.pure lvl_sdtMM sat_sdtMR;
                  } in  GHC.Base.>>= $dMonad_sdtMD w1_sdtMC sat_sdtMS; } in
        let {
          sat_sdtML [Occ=Once] :: GHC.Generics.Rec1 f_sdtw1 a_sdtw3
          [LclId] =
              [w1_sdtMC $dMonad_sdtMD] \u []
                  let {
                    lvl_sdtME [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                      :: GHC.Base.Applicative f_sdtw1
                    [LclId] =
                        [$dMonad_sdtMD] \u [] GHC.Base.$p1Monad $dMonad_sdtMD; } in
                  let {
                    sat_sdtMK [Occ=Once] :: (a_sdtw3, b_sdtw4) -> f_sdtw1 a_sdtw3
                    [LclId] =
                        [lvl_sdtME] \r [a1_sdtMF]
                            let {
                              sat_sdtMJ [Occ=Once] :: a_sdtw3
                              [LclId] =
                                  [a1_sdtMF] \u []
                                      case a1_sdtMF of {
                                        (,) x_sdtMH [Occ=Once] _ [Occ=Dead] -> x_sdtMH;
                                      };
                            } in  GHC.Base.pure lvl_sdtME sat_sdtMJ;
                  } in  GHC.Base.>>= $dMonad_sdtMD w1_sdtMC sat_sdtMK;
        } in  (#,#) [sat_sdtML sat_sdtMT];

Control.Monad.Zip.$fMonadZipRec1_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.Rec1 f (a, b)
     -> (GHC.Generics.Rec1 f a, GHC.Generics.Rec1 f b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdtMU w1_sdtMV]
        case Control.Monad.Zip.$w$cmunzip4 w_sdtMU w1_sdtMV of {
          (#,#) ww1_sdtMX [Occ=Once] ww2_sdtMY [Occ=Once] ->
              (,) [ww1_sdtMX ww2_sdtMY];
        };

Control.Monad.Zip.$fMonadZipRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     Control.Monad.Zip.MonadZip (GHC.Generics.Rec1 f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(1*U(1*U,1*U),U,1*U,1*U,1*U,1*U),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sdtMZ]
        let {
          sat_sdtN6 [Occ=Once]
            :: forall a b.
               GHC.Generics.Rec1 f_Xdtao (a, b)
               -> (GHC.Generics.Rec1 f_Xdtao a, GHC.Generics.Rec1 f_Xdtao b)
          [LclId] =
              [$dMonadZip_sdtMZ] \r [eta_B1]
                  Control.Monad.Zip.$fMonadZipRec1_$cmunzip
                      $dMonadZip_sdtMZ eta_B1; } in
        let {
          sat_sdtN5 [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> GHC.Generics.Rec1 f_Xdtao a
               -> GHC.Generics.Rec1 f_Xdtao b
               -> GHC.Generics.Rec1 f_Xdtao c
          [LclId] =
              [$dMonadZip_sdtMZ] \r [f1_sdtN2 ds_sdtN3 ds1_sdtN4]
                  Control.Monad.Zip.mzipWith
                      $dMonadZip_sdtMZ f1_sdtN2 ds_sdtN3 ds1_sdtN4; } in
        let {
          sat_sdtN1 [Occ=Once]
            :: forall a b.
               GHC.Generics.Rec1 f_Xdtao a
               -> GHC.Generics.Rec1 f_Xdtao b -> GHC.Generics.Rec1 f_Xdtao (a, b)
          [LclId] =
              [$dMonadZip_sdtMZ] \r [eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZipRec2
                      $dMonadZip_sdtMZ eta_B2 eta_B1; } in
        let {
          sat_sdtN0 [Occ=Once] :: GHC.Base.Monad (GHC.Generics.Rec1 f_Xdtao)
          [LclId] =
              [$dMonadZip_sdtMZ] \u []
                  Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip $dMonadZip_sdtMZ;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sdtN0
                                        sat_sdtN1
                                        sat_sdtN5
                                        sat_sdtN6];

Control.Monad.Zip.$fMonadZipPar1_$cmunzip
  :: forall a b.
     GHC.Generics.Par1 (a, b)
     -> (GHC.Generics.Par1 a, GHC.Generics.Par1 b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [mab_sdtN7]
        let {
          sat_sdtNf [Occ=Once] :: GHC.Generics.Par1 b_adt9i
          [LclId] =
              [mab_sdtN7] \u []
                  case mab_sdtN7 of {
                    (,) _ [Occ=Dead] y_sdtNe [Occ=Once] -> y_sdtNe;
                  }; } in
        let {
          sat_sdtNb [Occ=Once] :: GHC.Generics.Par1 a_adt9h
          [LclId] =
              [mab_sdtN7] \u []
                  case mab_sdtN7 of {
                    (,) x_sdtN9 [Occ=Once] _ [Occ=Dead] -> x_sdtN9;
                  };
        } in  (,) [sat_sdtNb sat_sdtNf];

Control.Monad.Zip.$fMonadZipPar1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip GHC.Generics.Par1
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Generics.$fMonadPar1
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipPar2
                                                 Control.Monad.Zip.$fMonadZipPar1_$cmunzip];

Control.Monad.Zip.$fMonadZipU1_$cmzip
  :: forall a b.
     GHC.Generics.U1 a -> GHC.Generics.U1 b -> GHC.Generics.U1 (a, b)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdtNg ds1_sdtNh] GHC.Generics.U1 [];

Control.Monad.Zip.$fMonadZipU2
  :: forall b a. (GHC.Generics.U1 a, GHC.Generics.U1 b)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Generics.U1 GHC.Generics.U1];

Control.Monad.Zip.$fMonadZipU1_$cmunzip
  :: forall a b.
     GHC.Generics.U1 (a, b) -> (GHC.Generics.U1 a, GHC.Generics.U1 b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [mab_sdtNi] Control.Monad.Zip.$fMonadZipU2;

Control.Monad.Zip.$fMonadZipU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip GHC.Generics.U1
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Generics.$fMonadU1
                                                 Control.Monad.Zip.$fMonadZipU1_$cmzip
                                                 Control.Monad.Zip.$fMonadZipU1_$cmzipWith
                                                 Control.Monad.Zip.$fMonadZipU1_$cmunzip];

Control.Monad.Zip.$fMonadZipProxy_$cmzip
  :: forall a b.
     Data.Proxy.Proxy a -> Data.Proxy.Proxy b -> Data.Proxy.Proxy (a, b)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdtNj ds1_sdtNk] Data.Proxy.Proxy [];

Control.Monad.Zip.$fMonadZipProxy1
  :: forall b a. (Data.Proxy.Proxy a, Data.Proxy.Proxy b)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Proxy.Proxy Data.Proxy.Proxy];

Control.Monad.Zip.$fMonadZipProxy_$cmunzip
  :: forall a b.
     Data.Proxy.Proxy (a, b) -> (Data.Proxy.Proxy a, Data.Proxy.Proxy b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [mab_sdtNl] Control.Monad.Zip.$fMonadZipProxy1;

Control.Monad.Zip.$fMonadZipProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Proxy.Proxy
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Proxy.$fMonadProxy
                                                 Control.Monad.Zip.$fMonadZipProxy_$cmzip
                                                 Control.Monad.Zip.$fMonadZipProxy_$cmzipWith
                                                 Control.Monad.Zip.$fMonadZipProxy_$cmunzip];

Control.Monad.Zip.$fMonadZipAlt1
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     Data.Semigroup.Internal.Alt f a
     -> Data.Semigroup.Internal.Alt f b -> f (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtNm ds_sdtNn ds1_sdtNo]
        Control.Monad.Zip.mzipWith
            $dMonadZip_sdtNm GHC.Tuple.(,) ds_sdtNn ds1_sdtNo;

Control.Monad.Zip.$w$cmunzip1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     Data.Semigroup.Internal.Alt f (a, b)
     -> (# Data.Semigroup.Internal.Alt f a,
           Data.Semigroup.Internal.Alt f b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdtNp w1_sdtNq]
        let {
          $dMonad_sdtNr [Dmd=<L,U(A,C(C1(U)),A,C(U),A)>]
            :: GHC.Base.Monad f_sdtwa
          [LclId] =
              [w_sdtNp] \u [] Control.Monad.Zip.$p1MonadZip w_sdtNp; } in
        let {
          sat_sdtNF [Occ=Once] :: Data.Semigroup.Internal.Alt f_sdtwa b_sdtwd
          [LclId] =
              [w1_sdtNq $dMonad_sdtNr] \u []
                  let {
                    sat_sdtNE [Occ=Once] :: (a_sdtwc, b_sdtwd) -> f_sdtwa b_sdtwd
                    [LclId] =
                        [$dMonad_sdtNr] \r [x1_sdtNz]
                            let {
                              sat_sdtND [Occ=Once] :: b_sdtwd
                              [LclId] =
                                  [x1_sdtNz] \u []
                                      case x1_sdtNz of {
                                        (,) _ [Occ=Dead] y_sdtNC [Occ=Once] -> y_sdtNC;
                                      };
                            } in  GHC.Base.return $dMonad_sdtNr sat_sdtND;
                  } in  GHC.Base.>>= $dMonad_sdtNr w1_sdtNq sat_sdtNE; } in
        let {
          sat_sdtNy [Occ=Once] :: Data.Semigroup.Internal.Alt f_sdtwa a_sdtwc
          [LclId] =
              [w1_sdtNq $dMonad_sdtNr] \u []
                  let {
                    sat_sdtNx [Occ=Once] :: (a_sdtwc, b_sdtwd) -> f_sdtwa a_sdtwc
                    [LclId] =
                        [$dMonad_sdtNr] \r [x1_sdtNs]
                            let {
                              sat_sdtNw [Occ=Once] :: a_sdtwc
                              [LclId] =
                                  [x1_sdtNs] \u []
                                      case x1_sdtNs of {
                                        (,) x_sdtNu [Occ=Once] _ [Occ=Dead] -> x_sdtNu;
                                      };
                            } in  GHC.Base.return $dMonad_sdtNr sat_sdtNw;
                  } in  GHC.Base.>>= $dMonad_sdtNr w1_sdtNq sat_sdtNx;
        } in  (#,#) [sat_sdtNy sat_sdtNF];

Control.Monad.Zip.$fMonadZipAlt_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     Data.Semigroup.Internal.Alt f (a, b)
     -> (Data.Semigroup.Internal.Alt f a,
         Data.Semigroup.Internal.Alt f b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdtNG w1_sdtNH]
        case Control.Monad.Zip.$w$cmunzip1 w_sdtNG w1_sdtNH of {
          (#,#) ww1_sdtNJ [Occ=Once] ww2_sdtNK [Occ=Once] ->
              (,) [ww1_sdtNJ ww2_sdtNK];
        };

Control.Monad.Zip.$fMonadZipAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     Control.Monad.Zip.MonadZip (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),U,1*U,U,1*U),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sdtNL]
        let {
          sat_sdtNS [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_Xdtd8 (a, b)
               -> (Data.Semigroup.Internal.Alt f_Xdtd8 a,
                   Data.Semigroup.Internal.Alt f_Xdtd8 b)
          [LclId] =
              [$dMonadZip_sdtNL] \r [eta_B1]
                  Control.Monad.Zip.$fMonadZipAlt_$cmunzip
                      $dMonadZip_sdtNL eta_B1; } in
        let {
          sat_sdtNR [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Semigroup.Internal.Alt f_Xdtd8 a
               -> Data.Semigroup.Internal.Alt f_Xdtd8 b
               -> Data.Semigroup.Internal.Alt f_Xdtd8 c
          [LclId] =
              [$dMonadZip_sdtNL] \r [f1_sdtNO ds_sdtNP ds1_sdtNQ]
                  Control.Monad.Zip.mzipWith
                      $dMonadZip_sdtNL f1_sdtNO ds_sdtNP ds1_sdtNQ; } in
        let {
          sat_sdtNN [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_Xdtd8 a
               -> Data.Semigroup.Internal.Alt f_Xdtd8 b
               -> Data.Semigroup.Internal.Alt f_Xdtd8 (a, b)
          [LclId] =
              [$dMonadZip_sdtNL] \r [eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZipAlt1
                      $dMonadZip_sdtNL eta_B2 eta_B1; } in
        let {
          sat_sdtNM [Occ=Once]
            :: GHC.Base.Monad (Data.Semigroup.Internal.Alt f_Xdtd8)
          [LclId] =
              [$dMonadZip_sdtNL] \u []
                  Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip $dMonadZip_sdtNL;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sdtNM
                                        sat_sdtNN
                                        sat_sdtNR
                                        sat_sdtNS];

Control.Monad.Zip.$fMonadZipLast2
  :: forall b a.
     Data.Monoid.Last a -> Data.Monoid.Last b -> GHC.Base.Maybe (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [m1_sdtNT m2_sdtNU]
        case m1_sdtNT of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdtNW [Occ=Once] ->
              case m2_sdtNU of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdtNY [Occ=Once] ->
                    let {
                      sat_sdtNZ [Occ=Once] :: (a_adtbn, b_adtbo)
                      [LclId] =
                          CCCS (,)! [x_sdtNW x1_sdtNY];
                    } in  GHC.Base.Just [sat_sdtNZ];
              };
        };

Control.Monad.Zip.$fMonadZipLast_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Data.Monoid.Last (a, b) -> (Data.Monoid.Last a, Data.Monoid.Last b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [w_sdtO0]
        let {
          sat_sdtOe [Occ=Once] :: Data.Monoid.Last b_sdtwk
          [LclId] =
              [w_sdtO0] \u []
                  case w_sdtO0 of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdtO9 [Occ=Once!] ->
                        let {
                          sat_sdtOd [Occ=Once] :: b_sdtwk
                          [LclId] =
                              [x_sdtO9] \u []
                                  case x_sdtO9 of {
                                    (,) _ [Occ=Dead] y_sdtOc [Occ=Once] -> y_sdtOc;
                                  };
                        } in  GHC.Base.Just [sat_sdtOd];
                  }; } in
        let {
          sat_sdtO7 [Occ=Once] :: Data.Monoid.Last a_sdtwj
          [LclId] =
              [w_sdtO0] \u []
                  case w_sdtO0 of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdtO2 [Occ=Once!] ->
                        let {
                          sat_sdtO6 [Occ=Once] :: a_sdtwj
                          [LclId] =
                              [x_sdtO2] \u []
                                  case x_sdtO2 of {
                                    (,) x1_sdtO4 [Occ=Once] _ [Occ=Dead] -> x1_sdtO4;
                                  };
                        } in  GHC.Base.Just [sat_sdtO6];
                  };
        } in  (,) [sat_sdtO7 sat_sdtOe];

Control.Monad.Zip.$fMonadZipLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Monoid.Last
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Monoid.$fMonadLast
                                                 Control.Monad.Zip.$fMonadZipLast2
                                                 Control.Monad.Zip.$fMonadZipLast1
                                                 Control.Monad.Zip.$fMonadZipLast_$cmunzip];

Control.Monad.Zip.$fMonadZipFirst2
  :: forall b a.
     Data.Monoid.First a -> Data.Monoid.First b -> GHC.Base.Maybe (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [m1_sdtOf m2_sdtOg]
        case m1_sdtOf of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdtOi [Occ=Once] ->
              case m2_sdtOg of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdtOk [Occ=Once] ->
                    let {
                      sat_sdtOl [Occ=Once] :: (a_adtc0, b_adtc1)
                      [LclId] =
                          CCCS (,)! [x_sdtOi x1_sdtOk];
                    } in  GHC.Base.Just [sat_sdtOl];
              };
        };

Control.Monad.Zip.$fMonadZipFirst_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Data.Monoid.First (a, b)
     -> (Data.Monoid.First a, Data.Monoid.First b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [w_sdtOm]
        let {
          sat_sdtOA [Occ=Once] :: Data.Monoid.First b_sdtwr
          [LclId] =
              [w_sdtOm] \u []
                  case w_sdtOm of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdtOv [Occ=Once!] ->
                        let {
                          sat_sdtOz [Occ=Once] :: b_sdtwr
                          [LclId] =
                              [x_sdtOv] \u []
                                  case x_sdtOv of {
                                    (,) _ [Occ=Dead] y_sdtOy [Occ=Once] -> y_sdtOy;
                                  };
                        } in  GHC.Base.Just [sat_sdtOz];
                  }; } in
        let {
          sat_sdtOt [Occ=Once] :: Data.Monoid.First a_sdtwq
          [LclId] =
              [w_sdtOm] \u []
                  case w_sdtOm of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdtOo [Occ=Once!] ->
                        let {
                          sat_sdtOs [Occ=Once] :: a_sdtwq
                          [LclId] =
                              [x_sdtOo] \u []
                                  case x_sdtOo of {
                                    (,) x1_sdtOq [Occ=Once] _ [Occ=Dead] -> x1_sdtOq;
                                  };
                        } in  GHC.Base.Just [sat_sdtOs];
                  };
        } in  (,) [sat_sdtOt sat_sdtOA];

Control.Monad.Zip.$fMonadZipFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Monoid.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Monoid.$fMonadFirst
                                                 Control.Monad.Zip.$fMonadZipFirst2
                                                 Control.Monad.Zip.$fMonadZipFirst1
                                                 Control.Monad.Zip.$fMonadZipFirst_$cmunzip];

Control.Monad.Zip.$fMonadZipMaybe_$cmzip
  :: forall a b.
     GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [m1_sdtOB m2_sdtOC]
        case m1_sdtOB of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdtOE [Occ=Once] ->
              case m2_sdtOC of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdtOG [Occ=Once] ->
                    let {
                      sat_sdtOH [Occ=Once] :: (a_adtcD, b_adtcE)
                      [LclId] =
                          CCCS (,)! [x_sdtOE x1_sdtOG];
                    } in  GHC.Base.Just [sat_sdtOH];
              };
        };

Control.Monad.Zip.$fMonadZipMaybe_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.Maybe (a, b) -> (GHC.Base.Maybe a, GHC.Base.Maybe b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [w_sdtOI]
        let {
          sat_sdtOW [Occ=Once] :: GHC.Base.Maybe b_sdtwy
          [LclId] =
              [w_sdtOI] \u []
                  case w_sdtOI of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdtOR [Occ=Once!] ->
                        let {
                          sat_sdtOV [Occ=Once] :: b_sdtwy
                          [LclId] =
                              [x_sdtOR] \u []
                                  case x_sdtOR of {
                                    (,) _ [Occ=Dead] y_sdtOU [Occ=Once] -> y_sdtOU;
                                  };
                        } in  GHC.Base.Just [sat_sdtOV];
                  }; } in
        let {
          sat_sdtOP [Occ=Once] :: GHC.Base.Maybe a_sdtwx
          [LclId] =
              [w_sdtOI] \u []
                  case w_sdtOI of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdtOK [Occ=Once!] ->
                        let {
                          sat_sdtOO [Occ=Once] :: a_sdtwx
                          [LclId] =
                              [x_sdtOK] \u []
                                  case x_sdtOK of {
                                    (,) x1_sdtOM [Occ=Once] _ [Occ=Dead] -> x1_sdtOM;
                                  };
                        } in  GHC.Base.Just [sat_sdtOO];
                  };
        } in  (,) [sat_sdtOP sat_sdtOW];

Control.Monad.Zip.$fMonadZipMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Base.$fMonadMaybe
                                                 Control.Monad.Zip.$fMonadZipMaybe_$cmzip
                                                 Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith
                                                 Control.Monad.Zip.$fMonadZipMaybe_$cmunzip];

Control.Monad.Zip.$fMonadZipProduct_$cmunzip
  :: forall a b.
     Data.Semigroup.Internal.Product (a, b)
     -> (Data.Semigroup.Internal.Product a,
         Data.Semigroup.Internal.Product b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [mab_sdtOX]
        let {
          sat_sdtP5 [Occ=Once] :: Data.Semigroup.Internal.Product b_adtdE
          [LclId] =
              [mab_sdtOX] \u []
                  case mab_sdtOX of {
                    (,) _ [Occ=Dead] y_sdtP4 [Occ=Once] -> y_sdtP4;
                  }; } in
        let {
          sat_sdtP1 [Occ=Once] :: Data.Semigroup.Internal.Product a_adtdD
          [LclId] =
              [mab_sdtOX] \u []
                  case mab_sdtOX of {
                    (,) x_sdtOZ [Occ=Once] _ [Occ=Dead] -> x_sdtOZ;
                  };
        } in  (,) [sat_sdtP1 sat_sdtP5];

Control.Monad.Zip.$fMonadZipProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Semigroup.Internal.$fMonadProduct
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipProduct1
                                                 Control.Monad.Zip.$fMonadZipProduct_$cmunzip];

Control.Monad.Zip.$fMonadZipSum_$cmunzip
  :: forall a b.
     Data.Semigroup.Internal.Sum (a, b)
     -> (Data.Semigroup.Internal.Sum a, Data.Semigroup.Internal.Sum b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [mab_sdtP6]
        let {
          sat_sdtPe [Occ=Once] :: Data.Semigroup.Internal.Sum b_adteh
          [LclId] =
              [mab_sdtP6] \u []
                  case mab_sdtP6 of {
                    (,) _ [Occ=Dead] y_sdtPd [Occ=Once] -> y_sdtPd;
                  }; } in
        let {
          sat_sdtPa [Occ=Once] :: Data.Semigroup.Internal.Sum a_adteg
          [LclId] =
              [mab_sdtP6] \u []
                  case mab_sdtP6 of {
                    (,) x_sdtP8 [Occ=Once] _ [Occ=Dead] -> x_sdtP8;
                  };
        } in  (,) [sat_sdtPa sat_sdtPe];

Control.Monad.Zip.$fMonadZipSum [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Semigroup.Internal.$fMonadSum
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipSum1
                                                 Control.Monad.Zip.$fMonadZipSum_$cmunzip];

Control.Monad.Zip.$fMonadZipDual_$cmunzip
  :: forall a b.
     Data.Semigroup.Internal.Dual (a, b)
     -> (Data.Semigroup.Internal.Dual a, Data.Semigroup.Internal.Dual b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [mab_sdtPf]
        let {
          sat_sdtPn [Occ=Once] :: Data.Semigroup.Internal.Dual b_adteU
          [LclId] =
              [mab_sdtPf] \u []
                  case mab_sdtPf of {
                    (,) _ [Occ=Dead] y_sdtPm [Occ=Once] -> y_sdtPm;
                  }; } in
        let {
          sat_sdtPj [Occ=Once] :: Data.Semigroup.Internal.Dual a_adteT
          [LclId] =
              [mab_sdtPf] \u []
                  case mab_sdtPf of {
                    (,) x_sdtPh [Occ=Once] _ [Occ=Dead] -> x_sdtPh;
                  };
        } in  (,) [sat_sdtPj sat_sdtPn];

Control.Monad.Zip.$fMonadZipDual [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Semigroup.Internal.$fMonadDual
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipDual1
                                                 Control.Monad.Zip.$fMonadZipDual_$cmunzip];

Control.Monad.Zip.$fMonadZipIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Functor.Identity.$fMonadIdentity
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipIdentity1
                                                 Control.Monad.Zip.$fMonadZipIdentity_$cmunzip];

Control.Monad.Zip.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Control.Monad.Zip.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Monad.Zip.$trModule4];

Control.Monad.Zip.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Control.Monad.Zip"#;

Control.Monad.Zip.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Monad.Zip.$trModule2];

Control.Monad.Zip.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Control.Monad.Zip.$trModule3
                                     Control.Monad.Zip.$trModule1];

$krep_rdtIk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Control.Monad.Zip.$tcMonadZip1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_rdtIk];

Control.Monad.Zip.$tcMonadZip3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "MonadZip"#;

Control.Monad.Zip.$tcMonadZip2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Monad.Zip.$tcMonadZip3];

Control.Monad.Zip.$tcMonadZip :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4362170845454097361##
                                    3840659568565778968##
                                    Control.Monad.Zip.$trModule
                                    Control.Monad.Zip.$tcMonadZip2
                                    0#
                                    Control.Monad.Zip.$tcMonadZip1];

Control.Monad.Zip.C:MonadZip
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall a b. m a -> m b -> m (a, b))
     -> (forall a b c. (a -> b -> c) -> m a -> m b -> m c)
     -> (forall a b. m (a, b) -> (m a, m b))
     -> Control.Monad.Zip.MonadZip m
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Control.Monad.Zip.C:MonadZip [eta_B4 eta_B3 eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:08:39.390032768 UTC

Control.Monad.Zip.$p1MonadZip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     GHC.Base.Monad m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sdtIm]
        case v_sdtIm of {
          Control.Monad.Zip.C:MonadZip v_sdtIo [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdtIo;
        };

Control.Monad.Zip.mzip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b. m a -> m b -> m (a, b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sdtIs]
        case v_sdtIs of {
          Control.Monad.Zip.C:MonadZip _ [Occ=Dead]
                                       v_sdtIv [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdtIv;
        };

Control.Monad.Zip.mzipWith
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b c. (a -> b -> c) -> m a -> m b -> m c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sdtIy]
        case v_sdtIy of {
          Control.Monad.Zip.C:MonadZip _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdtIC [Occ=Once]
                                       _ [Occ=Dead] ->
              v_sdtIC;
        };

Control.Monad.Zip.munzip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b. m (a, b) -> (m a, m b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sdtIE]
        case v_sdtIE of {
          Control.Monad.Zip.C:MonadZip _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdtIJ [Occ=Once] ->
              v_sdtIJ;
        };

Control.Monad.Zip.$fMonadZip[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Base.$fMonad[]
                                                 GHC.List.zip
                                                 GHC.List.zipWith
                                                 GHC.List.unzip];

Control.Monad.Zip.$w$cmunzip3 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty (a, b)
     -> (# GHC.Base.NonEmpty a, GHC.Base.NonEmpty b #)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(1*U,1*U),U)>,
 Unf=OtherCon []] =
    [] \r [w_sdtIK]
        let {
          sat_sdtJ7 [Occ=Once] :: [b_sdtv1]
          [LclId] =
              [w_sdtIK] \u []
                  case w_sdtIK of {
                    GHC.Base.:| _ [Occ=Dead] as_sdtJ6 [Occ=Once] ->
                        GHC.Base.map Data.Tuple.snd as_sdtJ6;
                  }; } in
        let {
          sat_sdtJ3 [Occ=Once] :: b_sdtv1
          [LclId] =
              [w_sdtIK] \u []
                  case w_sdtIK of {
                    GHC.Base.:| a1_sdtIY [Occ=Once!] _ [Occ=Dead] ->
                        case a1_sdtIY of {
                          (,) _ [Occ=Dead] y_sdtJ2 [Occ=Once] -> y_sdtJ2;
                        };
                  }; } in
        let {
          sat_sdtJ8 [Occ=Once] :: GHC.Base.NonEmpty b_sdtv1
          [LclId] =
              CCCS GHC.Base.:|! [sat_sdtJ3 sat_sdtJ7]; } in
        let {
          sat_sdtIV [Occ=Once] :: [a_sdtv0]
          [LclId] =
              [w_sdtIK] \u []
                  case w_sdtIK of {
                    GHC.Base.:| _ [Occ=Dead] as_sdtIU [Occ=Once] ->
                        GHC.Base.map Data.Tuple.fst as_sdtIU;
                  }; } in
        let {
          sat_sdtIR [Occ=Once] :: a_sdtv0
          [LclId] =
              [w_sdtIK] \u []
                  case w_sdtIK of {
                    GHC.Base.:| a1_sdtIM [Occ=Once!] _ [Occ=Dead] ->
                        case a1_sdtIM of {
                          (,) x_sdtIP [Occ=Once] _ [Occ=Dead] -> x_sdtIP;
                        };
                  }; } in
        let {
          sat_sdtIW [Occ=Once] :: GHC.Base.NonEmpty a_sdtv0
          [LclId] =
              CCCS GHC.Base.:|! [sat_sdtIR sat_sdtIV];
        } in  (#,#) [sat_sdtIW sat_sdtJ8];

Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty (a, b)
     -> (GHC.Base.NonEmpty a, GHC.Base.NonEmpty b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(U,U),U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdtJ9]
        case Control.Monad.Zip.$w$cmunzip3 w_sdtJ9 of {
          (#,#) ww1_sdtJb [Occ=Once] ww2_sdtJc [Occ=Once] ->
              (,) [ww1_sdtJb ww2_sdtJc];
        };

Control.Monad.Zip.$fMonadZipNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip GHC.Base.NonEmpty
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Base.$fMonadNonEmpty
                                                 Data.List.NonEmpty.zip
                                                 Data.List.NonEmpty.zipWith
                                                 Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip];

Control.Monad.Zip.$fMonadZipIdentity_$cmunzip
  :: forall a b.
     Data.Functor.Identity.Identity (a, b)
     -> (Data.Functor.Identity.Identity a,
         Data.Functor.Identity.Identity b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sdtJd] ds_sdtJd;

Control.Monad.Zip.$fMonadZipIdentity1
  :: forall b a c.
     (a -> b -> c)
     -> Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdtJh m1_sdtJi m2_sdtJj] f_sdtJh m1_sdtJi m2_sdtJj;

Control.Monad.Zip.$fMonadZipDual1
  :: forall b a c.
     (a -> b -> c)
     -> Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual b
     -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdtJk m1_sdtJl m2_sdtJm] f_sdtJk m1_sdtJl m2_sdtJm;

Control.Monad.Zip.$fMonadZipSum1
  :: forall b a c.
     (a -> b -> c)
     -> Data.Semigroup.Internal.Sum a
     -> Data.Semigroup.Internal.Sum b
     -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdtJn m1_sdtJo m2_sdtJp] f_sdtJn m1_sdtJo m2_sdtJp;

Control.Monad.Zip.$fMonadZipProduct1
  :: forall b a c.
     (a -> b -> c)
     -> Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product b
     -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdtJq m1_sdtJr m2_sdtJs] f_sdtJq m1_sdtJr m2_sdtJs;

Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdtJt m1_sdtJu m2_sdtJv]
        case m1_sdtJu of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdtJx [Occ=Once] ->
              case m2_sdtJv of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdtJz [Occ=Once] ->
                    let {
                      sat_sdtJA [Occ=Once] :: c_adtcP
                      [LclId] =
                          [f_sdtJt x_sdtJx x1_sdtJz] \u [] f_sdtJt x_sdtJx x1_sdtJz;
                    } in  GHC.Base.Just [sat_sdtJA];
              };
        };

Control.Monad.Zip.$fMonadZipFirst1
  :: forall a b c.
     (a -> b -> c)
     -> Data.Monoid.First a -> Data.Monoid.First b -> GHC.Base.Maybe c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdtJB m1_sdtJC m2_sdtJD]
        case m1_sdtJC of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdtJF [Occ=Once] ->
              case m2_sdtJD of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdtJH [Occ=Once] ->
                    let {
                      sat_sdtJI [Occ=Once] :: c_adtcc
                      [LclId] =
                          [f_sdtJB x_sdtJF x1_sdtJH] \u [] f_sdtJB x_sdtJF x1_sdtJH;
                    } in  GHC.Base.Just [sat_sdtJI];
              };
        };

Control.Monad.Zip.$fMonadZipLast1
  :: forall a b c.
     (a -> b -> c)
     -> Data.Monoid.Last a -> Data.Monoid.Last b -> GHC.Base.Maybe c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdtJJ m1_sdtJK m2_sdtJL]
        case m1_sdtJK of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdtJN [Occ=Once] ->
              case m2_sdtJL of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdtJP [Occ=Once] ->
                    let {
                      sat_sdtJQ [Occ=Once] :: c_adtbz
                      [LclId] =
                          [f_sdtJJ x_sdtJN x1_sdtJP] \u [] f_sdtJJ x_sdtJN x1_sdtJP;
                    } in  GHC.Base.Just [sat_sdtJQ];
              };
        };

Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     GHC.Base.Monad (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtJR]
        let {
          sat_sdtJS [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Monad f_Xdtc6
          [LclId] =
              [$dMonadZip_sdtJR] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdtJR;
        } in  Data.Semigroup.Internal.$fMonadAlt sat_sdtJS;

Control.Monad.Zip.$fMonadZipProxy_$cmzipWith
  :: forall a b c.
     (a -> b -> c)
     -> Data.Proxy.Proxy a -> Data.Proxy.Proxy b -> Data.Proxy.Proxy c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdtJT ds1_sdtJU ds2_sdtJV] Data.Proxy.Proxy [];

Control.Monad.Zip.$fMonadZipU1_$cmzipWith
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Generics.U1 a -> GHC.Generics.U1 b -> GHC.Generics.U1 c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdtJW ds1_sdtJX ds2_sdtJY] GHC.Generics.U1 [];

Control.Monad.Zip.$fMonadZipPar2
  :: forall b a c.
     (a -> b -> c) -> GHC.Generics.Par1 a -> GHC.Generics.Par1 b -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdtJZ m1_sdtK0 m2_sdtK1] f_sdtJZ m1_sdtK0 m2_sdtK1;

Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     GHC.Base.Monad (GHC.Generics.Rec1 f)
[GblId,
 Arity=1,
 Str=<L,1*U(1*U(U(1*U(1*U,1*U),U,1*U,1*U,1*U,1*U),C(C1(U)),A,A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtK2]
        let {
          sat_sdtK3 [Occ=Once,
                     Dmd=<L,U(U(1*U(1*U,1*U),U,1*U,1*U,1*U,1*U),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_Xdt9S
          [LclId] =
              [$dMonadZip_sdtK2] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdtK2;
        } in  GHC.Generics.$fMonadRec1 sat_sdtK3;

Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     GHC.Base.Monad (GHC.Generics.M1 i c f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtK4]
        let {
          sat_sdtK5 [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Monad f_Xdt9j
          [LclId] =
              [$dMonadZip_sdtK4] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdtK4;
        } in  GHC.Generics.$fMonadM1 sat_sdtK5;

Control.Monad.Zip.$fMonadZip:*:_$cmzipWith [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b c.
     (a -> b -> c)
     -> (GHC.Generics.:*:) f g a
     -> (GHC.Generics.:*:) f g b
     -> (GHC.Generics.:*:) f g c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A)><L,1*U(A,A,1*C1(C1(C1(U))),A)><L,U><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdtK6 w1_sdtK7 w2_sdtK8 w3_sdtK9 w4_sdtKa]
        case w3_sdtK9 of {
          GHC.Generics.:*: ww1_sdtKc [Occ=Once] ww2_sdtKd [Occ=Once] ->
              case w4_sdtKa of {
                GHC.Generics.:*: ww4_sdtKf [Occ=Once] ww5_sdtKg [Occ=Once] ->
                    let {
                      sat_sdtKi [Occ=Once] :: g_sdtv8 c_sdtvd
                      [LclId] =
                          [w1_sdtK7 w2_sdtK8 ww2_sdtKd ww5_sdtKg] \u []
                              Control.Monad.Zip.mzipWith
                                  w1_sdtK7 w2_sdtK8 ww2_sdtKd ww5_sdtKg; } in
                    let {
                      sat_sdtKh [Occ=Once] :: f_sdtv7 c_sdtvd
                      [LclId] =
                          [w_sdtK6 w2_sdtK8 ww1_sdtKc ww4_sdtKf] \u []
                              Control.Monad.Zip.mzipWith w_sdtK6 w2_sdtK8 ww1_sdtKc ww4_sdtKf;
                    } in  GHC.Generics.:*: [sat_sdtKh sat_sdtKi];
              };
        };

Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     GHC.Base.Monad (f GHC.Generics.:*: g)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtKj $dMonadZip1_sdtKk]
        let {
          sat_sdtKm [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_adt6u
          [LclId] =
              [$dMonadZip1_sdtKk] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip1_sdtKk; } in
        let {
          sat_sdtKl [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_adt6t
          [LclId] =
              [$dMonadZip_sdtKj] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdtKj;
        } in  GHC.Generics.$fMonad:*: sat_sdtKl sat_sdtKm;

Control.Monad.Zip.$dmmunzip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b. m (a, b) -> (m a, m b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtKn eta_sdtKo]
        let {
          $dMonad_sdtKp [Dmd=<L,U(A,C(C1(U)),A,C(U),A)>]
            :: GHC.Base.Monad m_adt27
          [LclId] =
              [$dMonadZip_sdtKn] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdtKn; } in
        let {
          sat_sdtKD [Occ=Once] :: m_adt27 b_adt6d
          [LclId] =
              [eta_sdtKo $dMonad_sdtKp] \u []
                  let {
                    sat_sdtKC [Occ=Once] :: (a_adt6c, b_adt6d) -> m_adt27 b_adt6d
                    [LclId] =
                        [$dMonad_sdtKp] \r [x1_sdtKx]
                            let {
                              sat_sdtKB [Occ=Once] :: b_adt6d
                              [LclId] =
                                  [x1_sdtKx] \u []
                                      case x1_sdtKx of {
                                        (,) _ [Occ=Dead] y_sdtKA [Occ=Once] -> y_sdtKA;
                                      };
                            } in  GHC.Base.return $dMonad_sdtKp sat_sdtKB;
                  } in  GHC.Base.>>= $dMonad_sdtKp eta_sdtKo sat_sdtKC; } in
        let {
          sat_sdtKw [Occ=Once] :: m_adt27 a_adt6c
          [LclId] =
              [eta_sdtKo $dMonad_sdtKp] \u []
                  let {
                    sat_sdtKv [Occ=Once] :: (a_adt6c, b_adt6d) -> m_adt27 a_adt6c
                    [LclId] =
                        [$dMonad_sdtKp] \r [x1_sdtKq]
                            let {
                              sat_sdtKu [Occ=Once] :: a_adt6c
                              [LclId] =
                                  [x1_sdtKq] \u []
                                      case x1_sdtKq of {
                                        (,) x_sdtKs [Occ=Once] _ [Occ=Dead] -> x_sdtKs;
                                      };
                            } in  GHC.Base.return $dMonad_sdtKp sat_sdtKu;
                  } in  GHC.Base.>>= $dMonad_sdtKp eta_sdtKo sat_sdtKv;
        } in  (,) [sat_sdtKw sat_sdtKD];

Control.Monad.Zip.$dmmzipWith
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b c. (a -> b -> c) -> m a -> m b -> m c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S))LLL)LLL),U(1*U(A,1*C1(C1(U)),A,C(U),A),1*C1(C1(U)),A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtKE eta_sdtKF eta1_sdtKG eta2_sdtKH]
        case
            Control.Monad.Zip.$p1MonadZip $dMonadZip_sdtKE
        of
        $dMonad_sdtKI [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
        { __DEFAULT ->
              let {
                sat_sdtKU [Occ=Once] :: (a_adt5U, b_adt5V) -> m_adt27 c_adt5W
                [LclId] =
                    [eta_sdtKF $dMonad_sdtKI] \r [x1_sdtKK]
                        let {
                          sat_sdtKT [Occ=Once] :: c_adt5W
                          [LclId] =
                              [eta_sdtKF x1_sdtKK] \u []
                                  let {
                                    sat_sdtKS [Occ=Once] :: b_adt5V
                                    [LclId] =
                                        [x1_sdtKK] \u []
                                            case x1_sdtKK of {
                                              (,) _ [Occ=Dead] y_sdtKR [Occ=Once] -> y_sdtKR;
                                            }; } in
                                  let {
                                    sat_sdtKO [Occ=Once] :: a_adt5U
                                    [LclId] =
                                        [x1_sdtKK] \u []
                                            case x1_sdtKK of {
                                              (,) x_sdtKM [Occ=Once] _ [Occ=Dead] -> x_sdtKM;
                                            };
                                  } in  eta_sdtKF sat_sdtKO sat_sdtKS;
                        } in  GHC.Base.return $dMonad_sdtKI sat_sdtKT; } in
              let {
                sat_sdtKJ [Occ=Once] :: m_adt27 (a_adt5U, b_adt5V)
                [LclId] =
                    [$dMonadZip_sdtKE eta1_sdtKG eta2_sdtKH] \u []
                        Control.Monad.Zip.mzip $dMonadZip_sdtKE eta1_sdtKG eta2_sdtKH;
              } in  GHC.Base.>>= $dMonad_sdtKI sat_sdtKJ sat_sdtKU;
        };

Control.Monad.Zip.$dmmzip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b. m a -> m b -> m (a, b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLC(S)L),1*U(A,A,1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtKV]
        Control.Monad.Zip.mzipWith $dMonadZip_sdtKV GHC.Tuple.(,);

Control.Monad.Zip.$fMonadZip:*:_$cmzip
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     (GHC.Generics.:*:) f g a
     -> (GHC.Generics.:*:) f g b -> (GHC.Generics.:*:) f g (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A)><L,1*U(A,A,1*C1(C1(C1(U))),A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtKW $dMonadZip1_sdtKX w_sdtKY w1_sdtKZ]
        case w_sdtKY of {
          GHC.Generics.:*: ww1_sdtL1 [Occ=Once] ww2_sdtL2 [Occ=Once] ->
              case w1_sdtKZ of {
                GHC.Generics.:*: ww4_sdtL4 [Occ=Once] ww5_sdtL5 [Occ=Once] ->
                    let {
                      sat_sdtL7 [Occ=Once] :: g_adt6u (a_adt6E, b_adt6F)
                      [LclId] =
                          [$dMonadZip1_sdtKX ww2_sdtL2 ww5_sdtL5] \u []
                              Control.Monad.Zip.mzipWith
                                  $dMonadZip1_sdtKX GHC.Tuple.(,) ww2_sdtL2 ww5_sdtL5; } in
                    let {
                      sat_sdtL6 [Occ=Once] :: f_adt6t (a_adt6E, b_adt6F)
                      [LclId] =
                          [$dMonadZip_sdtKW ww1_sdtL1 ww4_sdtL4] \u []
                              Control.Monad.Zip.mzipWith
                                  $dMonadZip_sdtKW GHC.Tuple.(,) ww1_sdtL1 ww4_sdtL4;
                    } in  GHC.Generics.:*: [sat_sdtL6 sat_sdtL7];
              };
        };

Control.Monad.Zip.$w$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     (GHC.Generics.:*:) f g (a, b)
     -> (# (GHC.Generics.:*:) f g a, (GHC.Generics.:*:) f g b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdtL8 w1_sdtL9 w2_sdtLa]
        let {
          $dMonad_sdtLb [Dmd=<L,U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_sdtvG
          [LclId] =
              [w1_sdtL9] \u [] Control.Monad.Zip.$p1MonadZip w1_sdtL9; } in
        let {
          lvl_sdtLc [Dmd=<L,U(A,C(U),A,A,A,A)>]
            :: GHC.Base.Applicative g_sdtvG
          [LclId] =
              [$dMonad_sdtLb] \u [] GHC.Base.$p1Monad $dMonad_sdtLb; } in
        let {
          $dMonad1_sdtLd [Dmd=<L,U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_sdtvF
          [LclId] =
              [w_sdtL8] \u [] Control.Monad.Zip.$p1MonadZip w_sdtL8; } in
        let {
          lvl1_sdtLe [Dmd=<L,U(A,C(U),A,A,A,A)>]
            :: GHC.Base.Applicative f_sdtvF
          [LclId] =
              [$dMonad1_sdtLd] \u [] GHC.Base.$p1Monad $dMonad1_sdtLd; } in
        let {
          sat_sdtLO [Occ=Once] :: (GHC.Generics.:*:) f_sdtvF g_sdtvG b_sdtvK
          [LclId] =
              [w2_sdtLa $dMonad_sdtLb lvl_sdtLc $dMonad1_sdtLd lvl1_sdtLe] \u []
                  case w2_sdtLa of {
                    GHC.Generics.:*: ww1_sdtLy [Occ=Once] ww2_sdtLz [Occ=Once] ->
                        let {
                          sat_sdtLN [Occ=Once] :: g_sdtvG b_sdtvK
                          [LclId] =
                              [$dMonad_sdtLb lvl_sdtLc ww2_sdtLz] \u []
                                  let {
                                    sat_sdtLM [Occ=Once] :: (a_sdtvJ, b_sdtvK) -> g_sdtvG b_sdtvK
                                    [LclId] =
                                        [lvl_sdtLc] \r [a1_sdtLH]
                                            let {
                                              sat_sdtLL [Occ=Once] :: b_sdtvK
                                              [LclId] =
                                                  [a1_sdtLH] \u []
                                                      case a1_sdtLH of {
                                                        (,) _ [Occ=Dead] y_sdtLK [Occ=Once] ->
                                                            y_sdtLK;
                                                      };
                                            } in  GHC.Base.pure lvl_sdtLc sat_sdtLL;
                                  } in  GHC.Base.>>= $dMonad_sdtLb ww2_sdtLz sat_sdtLM; } in
                        let {
                          sat_sdtLG [Occ=Once] :: f_sdtvF b_sdtvK
                          [LclId] =
                              [$dMonad1_sdtLd lvl1_sdtLe ww1_sdtLy] \u []
                                  let {
                                    sat_sdtLF [Occ=Once] :: (a_sdtvJ, b_sdtvK) -> f_sdtvF b_sdtvK
                                    [LclId] =
                                        [lvl1_sdtLe] \r [a1_sdtLA]
                                            let {
                                              sat_sdtLE [Occ=Once] :: b_sdtvK
                                              [LclId] =
                                                  [a1_sdtLA] \u []
                                                      case a1_sdtLA of {
                                                        (,) _ [Occ=Dead] y_sdtLD [Occ=Once] ->
                                                            y_sdtLD;
                                                      };
                                            } in  GHC.Base.pure lvl1_sdtLe sat_sdtLE;
                                  } in  GHC.Base.>>= $dMonad1_sdtLd ww1_sdtLy sat_sdtLF;
                        } in  GHC.Generics.:*: [sat_sdtLG sat_sdtLN];
                  }; } in
        let {
          sat_sdtLw [Occ=Once] :: (GHC.Generics.:*:) f_sdtvF g_sdtvG a_sdtvJ
          [LclId] =
              [w2_sdtLa $dMonad_sdtLb lvl_sdtLc $dMonad1_sdtLd lvl1_sdtLe] \u []
                  case w2_sdtLa of {
                    GHC.Generics.:*: ww1_sdtLg [Occ=Once] ww2_sdtLh [Occ=Once] ->
                        let {
                          sat_sdtLv [Occ=Once] :: g_sdtvG a_sdtvJ
                          [LclId] =
                              [$dMonad_sdtLb lvl_sdtLc ww2_sdtLh] \u []
                                  let {
                                    sat_sdtLu [Occ=Once] :: (a_sdtvJ, b_sdtvK) -> g_sdtvG a_sdtvJ
                                    [LclId] =
                                        [lvl_sdtLc] \r [a1_sdtLp]
                                            let {
                                              sat_sdtLt [Occ=Once] :: a_sdtvJ
                                              [LclId] =
                                                  [a1_sdtLp] \u []
                                                      case a1_sdtLp of {
                                                        (,) x_sdtLr [Occ=Once] _ [Occ=Dead] ->
                                                            x_sdtLr;
                                                      };
                                            } in  GHC.Base.pure lvl_sdtLc sat_sdtLt;
                                  } in  GHC.Base.>>= $dMonad_sdtLb ww2_sdtLh sat_sdtLu; } in
                        let {
                          sat_sdtLo [Occ=Once] :: f_sdtvF a_sdtvJ
                          [LclId] =
                              [$dMonad1_sdtLd lvl1_sdtLe ww1_sdtLg] \u []
                                  let {
                                    sat_sdtLn [Occ=Once] :: (a_sdtvJ, b_sdtvK) -> f_sdtvF a_sdtvJ
                                    [LclId] =
                                        [lvl1_sdtLe] \r [a1_sdtLi]
                                            let {
                                              sat_sdtLm [Occ=Once] :: a_sdtvJ
                                              [LclId] =
                                                  [a1_sdtLi] \u []
                                                      case a1_sdtLi of {
                                                        (,) x_sdtLk [Occ=Once] _ [Occ=Dead] ->
                                                            x_sdtLk;
                                                      };
                                            } in  GHC.Base.pure lvl1_sdtLe sat_sdtLm;
                                  } in  GHC.Base.>>= $dMonad1_sdtLd ww1_sdtLg sat_sdtLn;
                        } in  GHC.Generics.:*: [sat_sdtLo sat_sdtLv];
                  };
        } in  (#,#) [sat_sdtLw sat_sdtLO];

Control.Monad.Zip.$fMonadZip:*:_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     (GHC.Generics.:*:) f g (a, b)
     -> ((GHC.Generics.:*:) f g a, (GHC.Generics.:*:) f g b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdtLP w1_sdtLQ w2_sdtLR]
        case Control.Monad.Zip.$w$cmunzip w_sdtLP w1_sdtLQ w2_sdtLR of {
          (#,#) ww1_sdtLT [Occ=Once] ww2_sdtLU [Occ=Once] ->
              (,) [ww1_sdtLT ww2_sdtLU];
        };

Control.Monad.Zip.$fMonadZip:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     Control.Monad.Zip.MonadZip (f GHC.Generics.:*: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)><L,U(U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sdtLV $dMonadZip1_sdtLW]
        let {
          sat_sdtM0 [Occ=Once]
            :: forall a b.
               (GHC.Generics.:*:) f_adt6t g_adt6u (a, b)
               -> ((GHC.Generics.:*:) f_adt6t g_adt6u a,
                   (GHC.Generics.:*:) f_adt6t g_adt6u b)
          [LclId] =
              [$dMonadZip_sdtLV $dMonadZip1_sdtLW] \r [eta_B1]
                  Control.Monad.Zip.$fMonadZip:*:_$cmunzip
                      $dMonadZip_sdtLV $dMonadZip1_sdtLW eta_B1; } in
        let {
          sat_sdtLZ [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> (GHC.Generics.:*:) f_adt6t g_adt6u a
               -> (GHC.Generics.:*:) f_adt6t g_adt6u b
               -> (GHC.Generics.:*:) f_adt6t g_adt6u c
          [LclId] =
              [$dMonadZip_sdtLV $dMonadZip1_sdtLW] \r [eta_B3 eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZip:*:_$cmzipWith
                      $dMonadZip_sdtLV $dMonadZip1_sdtLW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdtLY [Occ=Once]
            :: forall a b.
               (GHC.Generics.:*:) f_adt6t g_adt6u a
               -> (GHC.Generics.:*:) f_adt6t g_adt6u b
               -> (GHC.Generics.:*:) f_adt6t g_adt6u (a, b)
          [LclId] =
              [$dMonadZip_sdtLV $dMonadZip1_sdtLW] \r [eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZip:*:_$cmzip
                      $dMonadZip_sdtLV $dMonadZip1_sdtLW eta_B2 eta_B1; } in
        let {
          sat_sdtLX [Occ=Once]
            :: GHC.Base.Monad (f_adt6t GHC.Generics.:*: g_adt6u)
          [LclId] =
              [$dMonadZip_sdtLV $dMonadZip1_sdtLW] \u []
                  Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip
                      $dMonadZip_sdtLV $dMonadZip1_sdtLW;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sdtLX
                                        sat_sdtLY
                                        sat_sdtLZ
                                        sat_sdtM0];

Control.Monad.Zip.$fMonadZipM2
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.M1 i c f a -> GHC.Generics.M1 i c f b -> f (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtM1 ds_sdtM2 ds1_sdtM3]
        Control.Monad.Zip.mzipWith
            $dMonadZip_sdtM1 GHC.Tuple.(,) ds_sdtM2 ds1_sdtM3;

Control.Monad.Zip.$w$cmunzip2 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.M1 i c f (a, b)
     -> (# GHC.Generics.M1 i c f a, GHC.Generics.M1 i c f b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdtM4 w1_sdtM5]
        let {
          $dMonad_sdtM6 [Dmd=<L,U(A,C(C1(U)),A,C(U),A)>]
            :: GHC.Base.Monad f_sdtvQ
          [LclId] =
              [w_sdtM4] \u [] Control.Monad.Zip.$p1MonadZip w_sdtM4; } in
        let {
          sat_sdtMk [Occ=Once]
            :: GHC.Generics.M1 i_sdtvR c_sdtvS f_sdtvQ b_sdtvV
          [LclId] =
              [w1_sdtM5 $dMonad_sdtM6] \u []
                  let {
                    sat_sdtMj [Occ=Once] :: (a_sdtvU, b_sdtvV) -> f_sdtvQ b_sdtvV
                    [LclId] =
                        [$dMonad_sdtM6] \r [x1_sdtMe]
                            let {
                              sat_sdtMi [Occ=Once] :: b_sdtvV
                              [LclId] =
                                  [x1_sdtMe] \u []
                                      case x1_sdtMe of {
                                        (,) _ [Occ=Dead] y_sdtMh [Occ=Once] -> y_sdtMh;
                                      };
                            } in  GHC.Base.return $dMonad_sdtM6 sat_sdtMi;
                  } in  GHC.Base.>>= $dMonad_sdtM6 w1_sdtM5 sat_sdtMj; } in
        let {
          sat_sdtMd [Occ=Once]
            :: GHC.Generics.M1 i_sdtvR c_sdtvS f_sdtvQ a_sdtvU
          [LclId] =
              [w1_sdtM5 $dMonad_sdtM6] \u []
                  let {
                    sat_sdtMc [Occ=Once] :: (a_sdtvU, b_sdtvV) -> f_sdtvQ a_sdtvU
                    [LclId] =
                        [$dMonad_sdtM6] \r [x1_sdtM7]
                            let {
                              sat_sdtMb [Occ=Once] :: a_sdtvU
                              [LclId] =
                                  [x1_sdtM7] \u []
                                      case x1_sdtM7 of {
                                        (,) x_sdtM9 [Occ=Once] _ [Occ=Dead] -> x_sdtM9;
                                      };
                            } in  GHC.Base.return $dMonad_sdtM6 sat_sdtMb;
                  } in  GHC.Base.>>= $dMonad_sdtM6 w1_sdtM5 sat_sdtMc;
        } in  (#,#) [sat_sdtMd sat_sdtMk];

Control.Monad.Zip.$fMonadZipM1_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.M1 i c f (a, b)
     -> (GHC.Generics.M1 i c f a, GHC.Generics.M1 i c f b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdtMl w1_sdtMm]
        case Control.Monad.Zip.$w$cmunzip2 w_sdtMl w1_sdtMm of {
          (#,#) ww1_sdtMo [Occ=Once] ww2_sdtMp [Occ=Once] ->
              (,) [ww1_sdtMo ww2_sdtMp];
        };

Control.Monad.Zip.$fMonadZipM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     Control.Monad.Zip.MonadZip (GHC.Generics.M1 i c f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),U,1*U,U,1*U),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sdtMq]
        let {
          sat_sdtMx [Occ=Once]
            :: forall a b.
               GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s (a, b)
               -> (GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s a,
                   GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s b)
          [LclId] =
              [$dMonadZip_sdtMq] \r [eta_B1]
                  Control.Monad.Zip.$fMonadZipM1_$cmunzip
                      $dMonadZip_sdtMq eta_B1; } in
        let {
          sat_sdtMw [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s a
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s b
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s c
          [LclId] =
              [$dMonadZip_sdtMq] \r [f1_sdtMt ds_sdtMu ds1_sdtMv]
                  Control.Monad.Zip.mzipWith
                      $dMonadZip_sdtMq f1_sdtMt ds_sdtMu ds1_sdtMv; } in
        let {
          sat_sdtMs [Occ=Once]
            :: forall a b.
               GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s a
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s b
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s (a, b)
          [LclId] =
              [$dMonadZip_sdtMq] \r [eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZipM2 $dMonadZip_sdtMq eta_B2 eta_B1; } in
        let {
          sat_sdtMr [Occ=Once]
            :: GHC.Base.Monad (GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s)
          [LclId] =
              [$dMonadZip_sdtMq] \u []
                  Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip $dMonadZip_sdtMq;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sdtMr
                                        sat_sdtMs
                                        sat_sdtMw
                                        sat_sdtMx];

Control.Monad.Zip.$fMonadZipRec2
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.Rec1 f a -> GHC.Generics.Rec1 f b -> f (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtMy ds_sdtMz ds1_sdtMA]
        Control.Monad.Zip.mzipWith
            $dMonadZip_sdtMy GHC.Tuple.(,) ds_sdtMz ds1_sdtMA;

Control.Monad.Zip.$w$cmunzip4 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.Rec1 f (a, b)
     -> (# GHC.Generics.Rec1 f a, GHC.Generics.Rec1 f b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdtMB w1_sdtMC]
        let {
          $dMonad_sdtMD [Dmd=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_sdtw1
          [LclId] =
              [w_sdtMB] \u [] Control.Monad.Zip.$p1MonadZip w_sdtMB; } in
        let {
          sat_sdtMT [Occ=Once] :: GHC.Generics.Rec1 f_sdtw1 b_sdtw4
          [LclId] =
              [w1_sdtMC $dMonad_sdtMD] \u []
                  let {
                    lvl_sdtMM [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                      :: GHC.Base.Applicative f_sdtw1
                    [LclId] =
                        [$dMonad_sdtMD] \u [] GHC.Base.$p1Monad $dMonad_sdtMD; } in
                  let {
                    sat_sdtMS [Occ=Once] :: (a_sdtw3, b_sdtw4) -> f_sdtw1 b_sdtw4
                    [LclId] =
                        [lvl_sdtMM] \r [a1_sdtMN]
                            let {
                              sat_sdtMR [Occ=Once] :: b_sdtw4
                              [LclId] =
                                  [a1_sdtMN] \u []
                                      case a1_sdtMN of {
                                        (,) _ [Occ=Dead] y_sdtMQ [Occ=Once] -> y_sdtMQ;
                                      };
                            } in  GHC.Base.pure lvl_sdtMM sat_sdtMR;
                  } in  GHC.Base.>>= $dMonad_sdtMD w1_sdtMC sat_sdtMS; } in
        let {
          sat_sdtML [Occ=Once] :: GHC.Generics.Rec1 f_sdtw1 a_sdtw3
          [LclId] =
              [w1_sdtMC $dMonad_sdtMD] \u []
                  let {
                    lvl_sdtME [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                      :: GHC.Base.Applicative f_sdtw1
                    [LclId] =
                        [$dMonad_sdtMD] \u [] GHC.Base.$p1Monad $dMonad_sdtMD; } in
                  let {
                    sat_sdtMK [Occ=Once] :: (a_sdtw3, b_sdtw4) -> f_sdtw1 a_sdtw3
                    [LclId] =
                        [lvl_sdtME] \r [a1_sdtMF]
                            let {
                              sat_sdtMJ [Occ=Once] :: a_sdtw3
                              [LclId] =
                                  [a1_sdtMF] \u []
                                      case a1_sdtMF of {
                                        (,) x_sdtMH [Occ=Once] _ [Occ=Dead] -> x_sdtMH;
                                      };
                            } in  GHC.Base.pure lvl_sdtME sat_sdtMJ;
                  } in  GHC.Base.>>= $dMonad_sdtMD w1_sdtMC sat_sdtMK;
        } in  (#,#) [sat_sdtML sat_sdtMT];

Control.Monad.Zip.$fMonadZipRec1_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.Rec1 f (a, b)
     -> (GHC.Generics.Rec1 f a, GHC.Generics.Rec1 f b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdtMU w1_sdtMV]
        case Control.Monad.Zip.$w$cmunzip4 w_sdtMU w1_sdtMV of {
          (#,#) ww1_sdtMX [Occ=Once] ww2_sdtMY [Occ=Once] ->
              (,) [ww1_sdtMX ww2_sdtMY];
        };

Control.Monad.Zip.$fMonadZipRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     Control.Monad.Zip.MonadZip (GHC.Generics.Rec1 f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(1*U(1*U,1*U),U,1*U,1*U,1*U,1*U),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sdtMZ]
        let {
          sat_sdtN6 [Occ=Once]
            :: forall a b.
               GHC.Generics.Rec1 f_Xdtao (a, b)
               -> (GHC.Generics.Rec1 f_Xdtao a, GHC.Generics.Rec1 f_Xdtao b)
          [LclId] =
              [$dMonadZip_sdtMZ] \r [eta_B1]
                  Control.Monad.Zip.$fMonadZipRec1_$cmunzip
                      $dMonadZip_sdtMZ eta_B1; } in
        let {
          sat_sdtN5 [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> GHC.Generics.Rec1 f_Xdtao a
               -> GHC.Generics.Rec1 f_Xdtao b
               -> GHC.Generics.Rec1 f_Xdtao c
          [LclId] =
              [$dMonadZip_sdtMZ] \r [f1_sdtN2 ds_sdtN3 ds1_sdtN4]
                  Control.Monad.Zip.mzipWith
                      $dMonadZip_sdtMZ f1_sdtN2 ds_sdtN3 ds1_sdtN4; } in
        let {
          sat_sdtN1 [Occ=Once]
            :: forall a b.
               GHC.Generics.Rec1 f_Xdtao a
               -> GHC.Generics.Rec1 f_Xdtao b -> GHC.Generics.Rec1 f_Xdtao (a, b)
          [LclId] =
              [$dMonadZip_sdtMZ] \r [eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZipRec2
                      $dMonadZip_sdtMZ eta_B2 eta_B1; } in
        let {
          sat_sdtN0 [Occ=Once] :: GHC.Base.Monad (GHC.Generics.Rec1 f_Xdtao)
          [LclId] =
              [$dMonadZip_sdtMZ] \u []
                  Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip $dMonadZip_sdtMZ;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sdtN0
                                        sat_sdtN1
                                        sat_sdtN5
                                        sat_sdtN6];

Control.Monad.Zip.$fMonadZipPar1_$cmunzip
  :: forall a b.
     GHC.Generics.Par1 (a, b)
     -> (GHC.Generics.Par1 a, GHC.Generics.Par1 b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [mab_sdtN7]
        let {
          sat_sdtNf [Occ=Once] :: GHC.Generics.Par1 b_adt9i
          [LclId] =
              [mab_sdtN7] \u []
                  case mab_sdtN7 of {
                    (,) _ [Occ=Dead] y_sdtNe [Occ=Once] -> y_sdtNe;
                  }; } in
        let {
          sat_sdtNb [Occ=Once] :: GHC.Generics.Par1 a_adt9h
          [LclId] =
              [mab_sdtN7] \u []
                  case mab_sdtN7 of {
                    (,) x_sdtN9 [Occ=Once] _ [Occ=Dead] -> x_sdtN9;
                  };
        } in  (,) [sat_sdtNb sat_sdtNf];

Control.Monad.Zip.$fMonadZipPar1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip GHC.Generics.Par1
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Generics.$fMonadPar1
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipPar2
                                                 Control.Monad.Zip.$fMonadZipPar1_$cmunzip];

Control.Monad.Zip.$fMonadZipU1_$cmzip
  :: forall a b.
     GHC.Generics.U1 a -> GHC.Generics.U1 b -> GHC.Generics.U1 (a, b)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdtNg ds1_sdtNh] GHC.Generics.U1 [];

Control.Monad.Zip.$fMonadZipU2
  :: forall b a. (GHC.Generics.U1 a, GHC.Generics.U1 b)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Generics.U1 GHC.Generics.U1];

Control.Monad.Zip.$fMonadZipU1_$cmunzip
  :: forall a b.
     GHC.Generics.U1 (a, b) -> (GHC.Generics.U1 a, GHC.Generics.U1 b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [mab_sdtNi] Control.Monad.Zip.$fMonadZipU2;

Control.Monad.Zip.$fMonadZipU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip GHC.Generics.U1
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Generics.$fMonadU1
                                                 Control.Monad.Zip.$fMonadZipU1_$cmzip
                                                 Control.Monad.Zip.$fMonadZipU1_$cmzipWith
                                                 Control.Monad.Zip.$fMonadZipU1_$cmunzip];

Control.Monad.Zip.$fMonadZipProxy_$cmzip
  :: forall a b.
     Data.Proxy.Proxy a -> Data.Proxy.Proxy b -> Data.Proxy.Proxy (a, b)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdtNj ds1_sdtNk] Data.Proxy.Proxy [];

Control.Monad.Zip.$fMonadZipProxy1
  :: forall b a. (Data.Proxy.Proxy a, Data.Proxy.Proxy b)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Proxy.Proxy Data.Proxy.Proxy];

Control.Monad.Zip.$fMonadZipProxy_$cmunzip
  :: forall a b.
     Data.Proxy.Proxy (a, b) -> (Data.Proxy.Proxy a, Data.Proxy.Proxy b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [mab_sdtNl] Control.Monad.Zip.$fMonadZipProxy1;

Control.Monad.Zip.$fMonadZipProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Proxy.Proxy
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Proxy.$fMonadProxy
                                                 Control.Monad.Zip.$fMonadZipProxy_$cmzip
                                                 Control.Monad.Zip.$fMonadZipProxy_$cmzipWith
                                                 Control.Monad.Zip.$fMonadZipProxy_$cmunzip];

Control.Monad.Zip.$fMonadZipAlt1
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     Data.Semigroup.Internal.Alt f a
     -> Data.Semigroup.Internal.Alt f b -> f (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdtNm ds_sdtNn ds1_sdtNo]
        Control.Monad.Zip.mzipWith
            $dMonadZip_sdtNm GHC.Tuple.(,) ds_sdtNn ds1_sdtNo;

Control.Monad.Zip.$w$cmunzip1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     Data.Semigroup.Internal.Alt f (a, b)
     -> (# Data.Semigroup.Internal.Alt f a,
           Data.Semigroup.Internal.Alt f b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdtNp w1_sdtNq]
        let {
          $dMonad_sdtNr [Dmd=<L,U(A,C(C1(U)),A,C(U),A)>]
            :: GHC.Base.Monad f_sdtwa
          [LclId] =
              [w_sdtNp] \u [] Control.Monad.Zip.$p1MonadZip w_sdtNp; } in
        let {
          sat_sdtNF [Occ=Once] :: Data.Semigroup.Internal.Alt f_sdtwa b_sdtwd
          [LclId] =
              [w1_sdtNq $dMonad_sdtNr] \u []
                  let {
                    sat_sdtNE [Occ=Once] :: (a_sdtwc, b_sdtwd) -> f_sdtwa b_sdtwd
                    [LclId] =
                        [$dMonad_sdtNr] \r [x1_sdtNz]
                            let {
                              sat_sdtND [Occ=Once] :: b_sdtwd
                              [LclId] =
                                  [x1_sdtNz] \u []
                                      case x1_sdtNz of {
                                        (,) _ [Occ=Dead] y_sdtNC [Occ=Once] -> y_sdtNC;
                                      };
                            } in  GHC.Base.return $dMonad_sdtNr sat_sdtND;
                  } in  GHC.Base.>>= $dMonad_sdtNr w1_sdtNq sat_sdtNE; } in
        let {
          sat_sdtNy [Occ=Once] :: Data.Semigroup.Internal.Alt f_sdtwa a_sdtwc
          [LclId] =
              [w1_sdtNq $dMonad_sdtNr] \u []
                  let {
                    sat_sdtNx [Occ=Once] :: (a_sdtwc, b_sdtwd) -> f_sdtwa a_sdtwc
                    [LclId] =
                        [$dMonad_sdtNr] \r [x1_sdtNs]
                            let {
                              sat_sdtNw [Occ=Once] :: a_sdtwc
                              [LclId] =
                                  [x1_sdtNs] \u []
                                      case x1_sdtNs of {
                                        (,) x_sdtNu [Occ=Once] _ [Occ=Dead] -> x_sdtNu;
                                      };
                            } in  GHC.Base.return $dMonad_sdtNr sat_sdtNw;
                  } in  GHC.Base.>>= $dMonad_sdtNr w1_sdtNq sat_sdtNx;
        } in  (#,#) [sat_sdtNy sat_sdtNF];

Control.Monad.Zip.$fMonadZipAlt_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     Data.Semigroup.Internal.Alt f (a, b)
     -> (Data.Semigroup.Internal.Alt f a,
         Data.Semigroup.Internal.Alt f b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdtNG w1_sdtNH]
        case Control.Monad.Zip.$w$cmunzip1 w_sdtNG w1_sdtNH of {
          (#,#) ww1_sdtNJ [Occ=Once] ww2_sdtNK [Occ=Once] ->
              (,) [ww1_sdtNJ ww2_sdtNK];
        };

Control.Monad.Zip.$fMonadZipAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     Control.Monad.Zip.MonadZip (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),U,1*U,U,1*U),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sdtNL]
        let {
          sat_sdtNS [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_Xdtd8 (a, b)
               -> (Data.Semigroup.Internal.Alt f_Xdtd8 a,
                   Data.Semigroup.Internal.Alt f_Xdtd8 b)
          [LclId] =
              [$dMonadZip_sdtNL] \r [eta_B1]
                  Control.Monad.Zip.$fMonadZipAlt_$cmunzip
                      $dMonadZip_sdtNL eta_B1; } in
        let {
          sat_sdtNR [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Semigroup.Internal.Alt f_Xdtd8 a
               -> Data.Semigroup.Internal.Alt f_Xdtd8 b
               -> Data.Semigroup.Internal.Alt f_Xdtd8 c
          [LclId] =
              [$dMonadZip_sdtNL] \r [f1_sdtNO ds_sdtNP ds1_sdtNQ]
                  Control.Monad.Zip.mzipWith
                      $dMonadZip_sdtNL f1_sdtNO ds_sdtNP ds1_sdtNQ; } in
        let {
          sat_sdtNN [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_Xdtd8 a
               -> Data.Semigroup.Internal.Alt f_Xdtd8 b
               -> Data.Semigroup.Internal.Alt f_Xdtd8 (a, b)
          [LclId] =
              [$dMonadZip_sdtNL] \r [eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZipAlt1
                      $dMonadZip_sdtNL eta_B2 eta_B1; } in
        let {
          sat_sdtNM [Occ=Once]
            :: GHC.Base.Monad (Data.Semigroup.Internal.Alt f_Xdtd8)
          [LclId] =
              [$dMonadZip_sdtNL] \u []
                  Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip $dMonadZip_sdtNL;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sdtNM
                                        sat_sdtNN
                                        sat_sdtNR
                                        sat_sdtNS];

Control.Monad.Zip.$fMonadZipLast2
  :: forall b a.
     Data.Monoid.Last a -> Data.Monoid.Last b -> GHC.Base.Maybe (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [m1_sdtNT m2_sdtNU]
        case m1_sdtNT of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdtNW [Occ=Once] ->
              case m2_sdtNU of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdtNY [Occ=Once] ->
                    let {
                      sat_sdtNZ [Occ=Once] :: (a_adtbn, b_adtbo)
                      [LclId] =
                          CCCS (,)! [x_sdtNW x1_sdtNY];
                    } in  GHC.Base.Just [sat_sdtNZ];
              };
        };

Control.Monad.Zip.$fMonadZipLast_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Data.Monoid.Last (a, b) -> (Data.Monoid.Last a, Data.Monoid.Last b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [w_sdtO0]
        let {
          sat_sdtOe [Occ=Once] :: Data.Monoid.Last b_sdtwk
          [LclId] =
              [w_sdtO0] \u []
                  case w_sdtO0 of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdtO9 [Occ=Once!] ->
                        let {
                          sat_sdtOd [Occ=Once] :: b_sdtwk
                          [LclId] =
                              [x_sdtO9] \u []
                                  case x_sdtO9 of {
                                    (,) _ [Occ=Dead] y_sdtOc [Occ=Once] -> y_sdtOc;
                                  };
                        } in  GHC.Base.Just [sat_sdtOd];
                  }; } in
        let {
          sat_sdtO7 [Occ=Once] :: Data.Monoid.Last a_sdtwj
          [LclId] =
              [w_sdtO0] \u []
                  case w_sdtO0 of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdtO2 [Occ=Once!] ->
                        let {
                          sat_sdtO6 [Occ=Once] :: a_sdtwj
                          [LclId] =
                              [x_sdtO2] \u []
                                  case x_sdtO2 of {
                                    (,) x1_sdtO4 [Occ=Once] _ [Occ=Dead] -> x1_sdtO4;
                                  };
                        } in  GHC.Base.Just [sat_sdtO6];
                  };
        } in  (,) [sat_sdtO7 sat_sdtOe];

Control.Monad.Zip.$fMonadZipLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Monoid.Last
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Monoid.$fMonadLast
                                                 Control.Monad.Zip.$fMonadZipLast2
                                                 Control.Monad.Zip.$fMonadZipLast1
                                                 Control.Monad.Zip.$fMonadZipLast_$cmunzip];

Control.Monad.Zip.$fMonadZipFirst2
  :: forall b a.
     Data.Monoid.First a -> Data.Monoid.First b -> GHC.Base.Maybe (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [m1_sdtOf m2_sdtOg]
        case m1_sdtOf of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdtOi [Occ=Once] ->
              case m2_sdtOg of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdtOk [Occ=Once] ->
                    let {
                      sat_sdtOl [Occ=Once] :: (a_adtc0, b_adtc1)
                      [LclId] =
                          CCCS (,)! [x_sdtOi x1_sdtOk];
                    } in  GHC.Base.Just [sat_sdtOl];
              };
        };

Control.Monad.Zip.$fMonadZipFirst_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Data.Monoid.First (a, b)
     -> (Data.Monoid.First a, Data.Monoid.First b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [w_sdtOm]
        let {
          sat_sdtOA [Occ=Once] :: Data.Monoid.First b_sdtwr
          [LclId] =
              [w_sdtOm] \u []
                  case w_sdtOm of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdtOv [Occ=Once!] ->
                        let {
                          sat_sdtOz [Occ=Once] :: b_sdtwr
                          [LclId] =
                              [x_sdtOv] \u []
                                  case x_sdtOv of {
                                    (,) _ [Occ=Dead] y_sdtOy [Occ=Once] -> y_sdtOy;
                                  };
                        } in  GHC.Base.Just [sat_sdtOz];
                  }; } in
        let {
          sat_sdtOt [Occ=Once] :: Data.Monoid.First a_sdtwq
          [LclId] =
              [w_sdtOm] \u []
                  case w_sdtOm of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdtOo [Occ=Once!] ->
                        let {
                          sat_sdtOs [Occ=Once] :: a_sdtwq
                          [LclId] =
                              [x_sdtOo] \u []
                                  case x_sdtOo of {
                                    (,) x1_sdtOq [Occ=Once] _ [Occ=Dead] -> x1_sdtOq;
                                  };
                        } in  GHC.Base.Just [sat_sdtOs];
                  };
        } in  (,) [sat_sdtOt sat_sdtOA];

Control.Monad.Zip.$fMonadZipFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Monoid.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Monoid.$fMonadFirst
                                                 Control.Monad.Zip.$fMonadZipFirst2
                                                 Control.Monad.Zip.$fMonadZipFirst1
                                                 Control.Monad.Zip.$fMonadZipFirst_$cmunzip];

Control.Monad.Zip.$fMonadZipMaybe_$cmzip
  :: forall a b.
     GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [m1_sdtOB m2_sdtOC]
        case m1_sdtOB of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdtOE [Occ=Once] ->
              case m2_sdtOC of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdtOG [Occ=Once] ->
                    let {
                      sat_sdtOH [Occ=Once] :: (a_adtcD, b_adtcE)
                      [LclId] =
                          CCCS (,)! [x_sdtOE x1_sdtOG];
                    } in  GHC.Base.Just [sat_sdtOH];
              };
        };

Control.Monad.Zip.$fMonadZipMaybe_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.Maybe (a, b) -> (GHC.Base.Maybe a, GHC.Base.Maybe b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [w_sdtOI]
        let {
          sat_sdtOW [Occ=Once] :: GHC.Base.Maybe b_sdtwy
          [LclId] =
              [w_sdtOI] \u []
                  case w_sdtOI of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdtOR [Occ=Once!] ->
                        let {
                          sat_sdtOV [Occ=Once] :: b_sdtwy
                          [LclId] =
                              [x_sdtOR] \u []
                                  case x_sdtOR of {
                                    (,) _ [Occ=Dead] y_sdtOU [Occ=Once] -> y_sdtOU;
                                  };
                        } in  GHC.Base.Just [sat_sdtOV];
                  }; } in
        let {
          sat_sdtOP [Occ=Once] :: GHC.Base.Maybe a_sdtwx
          [LclId] =
              [w_sdtOI] \u []
                  case w_sdtOI of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdtOK [Occ=Once!] ->
                        let {
                          sat_sdtOO [Occ=Once] :: a_sdtwx
                          [LclId] =
                              [x_sdtOK] \u []
                                  case x_sdtOK of {
                                    (,) x1_sdtOM [Occ=Once] _ [Occ=Dead] -> x1_sdtOM;
                                  };
                        } in  GHC.Base.Just [sat_sdtOO];
                  };
        } in  (,) [sat_sdtOP sat_sdtOW];

Control.Monad.Zip.$fMonadZipMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Base.$fMonadMaybe
                                                 Control.Monad.Zip.$fMonadZipMaybe_$cmzip
                                                 Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith
                                                 Control.Monad.Zip.$fMonadZipMaybe_$cmunzip];

Control.Monad.Zip.$fMonadZipProduct_$cmunzip
  :: forall a b.
     Data.Semigroup.Internal.Product (a, b)
     -> (Data.Semigroup.Internal.Product a,
         Data.Semigroup.Internal.Product b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [mab_sdtOX]
        let {
          sat_sdtP5 [Occ=Once] :: Data.Semigroup.Internal.Product b_adtdE
          [LclId] =
              [mab_sdtOX] \u []
                  case mab_sdtOX of {
                    (,) _ [Occ=Dead] y_sdtP4 [Occ=Once] -> y_sdtP4;
                  }; } in
        let {
          sat_sdtP1 [Occ=Once] :: Data.Semigroup.Internal.Product a_adtdD
          [LclId] =
              [mab_sdtOX] \u []
                  case mab_sdtOX of {
                    (,) x_sdtOZ [Occ=Once] _ [Occ=Dead] -> x_sdtOZ;
                  };
        } in  (,) [sat_sdtP1 sat_sdtP5];

Control.Monad.Zip.$fMonadZipProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Semigroup.Internal.$fMonadProduct
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipProduct1
                                                 Control.Monad.Zip.$fMonadZipProduct_$cmunzip];

Control.Monad.Zip.$fMonadZipSum_$cmunzip
  :: forall a b.
     Data.Semigroup.Internal.Sum (a, b)
     -> (Data.Semigroup.Internal.Sum a, Data.Semigroup.Internal.Sum b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [mab_sdtP6]
        let {
          sat_sdtPe [Occ=Once] :: Data.Semigroup.Internal.Sum b_adteh
          [LclId] =
              [mab_sdtP6] \u []
                  case mab_sdtP6 of {
                    (,) _ [Occ=Dead] y_sdtPd [Occ=Once] -> y_sdtPd;
                  }; } in
        let {
          sat_sdtPa [Occ=Once] :: Data.Semigroup.Internal.Sum a_adteg
          [LclId] =
              [mab_sdtP6] \u []
                  case mab_sdtP6 of {
                    (,) x_sdtP8 [Occ=Once] _ [Occ=Dead] -> x_sdtP8;
                  };
        } in  (,) [sat_sdtPa sat_sdtPe];

Control.Monad.Zip.$fMonadZipSum [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Semigroup.Internal.$fMonadSum
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipSum1
                                                 Control.Monad.Zip.$fMonadZipSum_$cmunzip];

Control.Monad.Zip.$fMonadZipDual_$cmunzip
  :: forall a b.
     Data.Semigroup.Internal.Dual (a, b)
     -> (Data.Semigroup.Internal.Dual a, Data.Semigroup.Internal.Dual b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [mab_sdtPf]
        let {
          sat_sdtPn [Occ=Once] :: Data.Semigroup.Internal.Dual b_adteU
          [LclId] =
              [mab_sdtPf] \u []
                  case mab_sdtPf of {
                    (,) _ [Occ=Dead] y_sdtPm [Occ=Once] -> y_sdtPm;
                  }; } in
        let {
          sat_sdtPj [Occ=Once] :: Data.Semigroup.Internal.Dual a_adteT
          [LclId] =
              [mab_sdtPf] \u []
                  case mab_sdtPf of {
                    (,) x_sdtPh [Occ=Once] _ [Occ=Dead] -> x_sdtPh;
                  };
        } in  (,) [sat_sdtPj sat_sdtPn];

Control.Monad.Zip.$fMonadZipDual [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Semigroup.Internal.$fMonadDual
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipDual1
                                                 Control.Monad.Zip.$fMonadZipDual_$cmunzip];

Control.Monad.Zip.$fMonadZipIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Functor.Identity.$fMonadIdentity
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipIdentity1
                                                 Control.Monad.Zip.$fMonadZipIdentity_$cmunzip];

Control.Monad.Zip.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Control.Monad.Zip.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Monad.Zip.$trModule4];

Control.Monad.Zip.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Control.Monad.Zip"#;

Control.Monad.Zip.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Monad.Zip.$trModule2];

Control.Monad.Zip.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Control.Monad.Zip.$trModule3
                                     Control.Monad.Zip.$trModule1];

$krep_rdtIk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Control.Monad.Zip.$tcMonadZip1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_rdtIk];

Control.Monad.Zip.$tcMonadZip3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "MonadZip"#;

Control.Monad.Zip.$tcMonadZip2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Monad.Zip.$tcMonadZip3];

Control.Monad.Zip.$tcMonadZip :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4362170845454097361##
                                    3840659568565778968##
                                    Control.Monad.Zip.$trModule
                                    Control.Monad.Zip.$tcMonadZip2
                                    0#
                                    Control.Monad.Zip.$tcMonadZip1];

Control.Monad.Zip.C:MonadZip
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall a b. m a -> m b -> m (a, b))
     -> (forall a b c. (a -> b -> c) -> m a -> m b -> m c)
     -> (forall a b. m (a, b) -> (m a, m b))
     -> Control.Monad.Zip.MonadZip m
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Control.Monad.Zip.C:MonadZip [eta_B4 eta_B3 eta_B2 eta_B1];


==================== Pre unarise: ====================
2018-03-16 16:08:41.462720736 UTC

Control.Monad.Zip.$p1MonadZip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     GHC.Base.Monad m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sdvhY]
        case v_sdvhY of {
          Control.Monad.Zip.C:MonadZip v_sdvi0 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdvi0;
        };

Control.Monad.Zip.mzip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b. m a -> m b -> m (a, b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sdvi4]
        case v_sdvi4 of {
          Control.Monad.Zip.C:MonadZip _ [Occ=Dead]
                                       v_sdvi7 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdvi7;
        };

Control.Monad.Zip.mzipWith
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b c. (a -> b -> c) -> m a -> m b -> m c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sdvia]
        case v_sdvia of {
          Control.Monad.Zip.C:MonadZip _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdvie [Occ=Once]
                                       _ [Occ=Dead] ->
              v_sdvie;
        };

Control.Monad.Zip.munzip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b. m (a, b) -> (m a, m b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sdvig]
        case v_sdvig of {
          Control.Monad.Zip.C:MonadZip _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdvil [Occ=Once] ->
              v_sdvil;
        };

Control.Monad.Zip.$fMonadZip[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Base.$fMonad[]
                                                 GHC.List.zip
                                                 GHC.List.zipWith
                                                 GHC.List.unzip];

Control.Monad.Zip.$w$cmunzip3 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty (a, b)
     -> (# GHC.Base.NonEmpty a, GHC.Base.NonEmpty b #)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(1*U,1*U),U)>,
 Unf=OtherCon []] =
    [] \r [w_sdvim]
        let {
          sat_sdviJ [Occ=Once] :: [b_sdtv1]
          [LclId] =
              [w_sdvim] \u []
                  case w_sdvim of {
                    GHC.Base.:| _ [Occ=Dead] as_sdviI [Occ=Once] ->
                        GHC.Base.map Data.Tuple.snd as_sdviI;
                  }; } in
        let {
          sat_sdviF [Occ=Once] :: b_sdtv1
          [LclId] =
              [w_sdvim] \u []
                  case w_sdvim of {
                    GHC.Base.:| a1_sdviA [Occ=Once!] _ [Occ=Dead] ->
                        case a1_sdviA of {
                          (,) _ [Occ=Dead] y_sdviE [Occ=Once] -> y_sdviE;
                        };
                  }; } in
        let {
          sat_sdviK [Occ=Once] :: GHC.Base.NonEmpty b_sdtv1
          [LclId] =
              CCCS GHC.Base.:|! [sat_sdviF sat_sdviJ]; } in
        let {
          sat_sdvix [Occ=Once] :: [a_sdtv0]
          [LclId] =
              [w_sdvim] \u []
                  case w_sdvim of {
                    GHC.Base.:| _ [Occ=Dead] as_sdviw [Occ=Once] ->
                        GHC.Base.map Data.Tuple.fst as_sdviw;
                  }; } in
        let {
          sat_sdvit [Occ=Once] :: a_sdtv0
          [LclId] =
              [w_sdvim] \u []
                  case w_sdvim of {
                    GHC.Base.:| a1_sdvio [Occ=Once!] _ [Occ=Dead] ->
                        case a1_sdvio of {
                          (,) x_sdvir [Occ=Once] _ [Occ=Dead] -> x_sdvir;
                        };
                  }; } in
        let {
          sat_sdviy [Occ=Once] :: GHC.Base.NonEmpty a_sdtv0
          [LclId] =
              CCCS GHC.Base.:|! [sat_sdvit sat_sdvix];
        } in  (#,#) [sat_sdviy sat_sdviK];

Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty (a, b)
     -> (GHC.Base.NonEmpty a, GHC.Base.NonEmpty b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(U,U),U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdviL]
        case Control.Monad.Zip.$w$cmunzip3 w_sdviL of {
          (#,#) ww1_sdviN [Occ=Once] ww2_sdviO [Occ=Once] ->
              (,) [ww1_sdviN ww2_sdviO];
        };

Control.Monad.Zip.$fMonadZipNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip GHC.Base.NonEmpty
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Base.$fMonadNonEmpty
                                                 Data.List.NonEmpty.zip
                                                 Data.List.NonEmpty.zipWith
                                                 Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip];

Control.Monad.Zip.$fMonadZipIdentity_$cmunzip
  :: forall a b.
     Data.Functor.Identity.Identity (a, b)
     -> (Data.Functor.Identity.Identity a,
         Data.Functor.Identity.Identity b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sdviP] ds_sdviP;

Control.Monad.Zip.$fMonadZipIdentity1
  :: forall b a c.
     (a -> b -> c)
     -> Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdviT m1_sdviU m2_sdviV] f_sdviT m1_sdviU m2_sdviV;

Control.Monad.Zip.$fMonadZipDual1
  :: forall b a c.
     (a -> b -> c)
     -> Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual b
     -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdviW m1_sdviX m2_sdviY] f_sdviW m1_sdviX m2_sdviY;

Control.Monad.Zip.$fMonadZipSum1
  :: forall b a c.
     (a -> b -> c)
     -> Data.Semigroup.Internal.Sum a
     -> Data.Semigroup.Internal.Sum b
     -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdviZ m1_sdvj0 m2_sdvj1] f_sdviZ m1_sdvj0 m2_sdvj1;

Control.Monad.Zip.$fMonadZipProduct1
  :: forall b a c.
     (a -> b -> c)
     -> Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product b
     -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdvj2 m1_sdvj3 m2_sdvj4] f_sdvj2 m1_sdvj3 m2_sdvj4;

Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdvj5 m1_sdvj6 m2_sdvj7]
        case m1_sdvj6 of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdvj9 [Occ=Once] ->
              case m2_sdvj7 of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdvjb [Occ=Once] ->
                    let {
                      sat_sdvjc [Occ=Once] :: c_adtcP
                      [LclId] =
                          [f_sdvj5 x_sdvj9 x1_sdvjb] \u [] f_sdvj5 x_sdvj9 x1_sdvjb;
                    } in  GHC.Base.Just [sat_sdvjc];
              };
        };

Control.Monad.Zip.$fMonadZipFirst1
  :: forall a b c.
     (a -> b -> c)
     -> Data.Monoid.First a -> Data.Monoid.First b -> GHC.Base.Maybe c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdvjd m1_sdvje m2_sdvjf]
        case m1_sdvje of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdvjh [Occ=Once] ->
              case m2_sdvjf of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdvjj [Occ=Once] ->
                    let {
                      sat_sdvjk [Occ=Once] :: c_adtcc
                      [LclId] =
                          [f_sdvjd x_sdvjh x1_sdvjj] \u [] f_sdvjd x_sdvjh x1_sdvjj;
                    } in  GHC.Base.Just [sat_sdvjk];
              };
        };

Control.Monad.Zip.$fMonadZipLast1
  :: forall a b c.
     (a -> b -> c)
     -> Data.Monoid.Last a -> Data.Monoid.Last b -> GHC.Base.Maybe c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdvjl m1_sdvjm m2_sdvjn]
        case m1_sdvjm of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdvjp [Occ=Once] ->
              case m2_sdvjn of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdvjr [Occ=Once] ->
                    let {
                      sat_sdvjs [Occ=Once] :: c_adtbz
                      [LclId] =
                          [f_sdvjl x_sdvjp x1_sdvjr] \u [] f_sdvjl x_sdvjp x1_sdvjr;
                    } in  GHC.Base.Just [sat_sdvjs];
              };
        };

Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     GHC.Base.Monad (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvjt]
        let {
          sat_sdvju [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Monad f_Xdtc6
          [LclId] =
              [$dMonadZip_sdvjt] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdvjt;
        } in  Data.Semigroup.Internal.$fMonadAlt sat_sdvju;

Control.Monad.Zip.$fMonadZipProxy_$cmzipWith
  :: forall a b c.
     (a -> b -> c)
     -> Data.Proxy.Proxy a -> Data.Proxy.Proxy b -> Data.Proxy.Proxy c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdvjv ds1_sdvjw ds2_sdvjx] Data.Proxy.Proxy [];

Control.Monad.Zip.$fMonadZipU1_$cmzipWith
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Generics.U1 a -> GHC.Generics.U1 b -> GHC.Generics.U1 c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdvjy ds1_sdvjz ds2_sdvjA] GHC.Generics.U1 [];

Control.Monad.Zip.$fMonadZipPar2
  :: forall b a c.
     (a -> b -> c) -> GHC.Generics.Par1 a -> GHC.Generics.Par1 b -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdvjB m1_sdvjC m2_sdvjD] f_sdvjB m1_sdvjC m2_sdvjD;

Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     GHC.Base.Monad (GHC.Generics.Rec1 f)
[GblId,
 Arity=1,
 Str=<L,1*U(1*U(U(1*U(1*U,1*U),U,1*U,1*U,1*U,1*U),C(C1(U)),A,A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvjE]
        let {
          sat_sdvjF [Occ=Once,
                     Dmd=<L,U(U(1*U(1*U,1*U),U,1*U,1*U,1*U,1*U),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_Xdt9S
          [LclId] =
              [$dMonadZip_sdvjE] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdvjE;
        } in  GHC.Generics.$fMonadRec1 sat_sdvjF;

Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     GHC.Base.Monad (GHC.Generics.M1 i c f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvjG]
        let {
          sat_sdvjH [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Monad f_Xdt9j
          [LclId] =
              [$dMonadZip_sdvjG] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdvjG;
        } in  GHC.Generics.$fMonadM1 sat_sdvjH;

Control.Monad.Zip.$fMonadZip:*:_$cmzipWith [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b c.
     (a -> b -> c)
     -> (GHC.Generics.:*:) f g a
     -> (GHC.Generics.:*:) f g b
     -> (GHC.Generics.:*:) f g c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A)><L,1*U(A,A,1*C1(C1(C1(U))),A)><L,U><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdvjI w1_sdvjJ w2_sdvjK w3_sdvjL w4_sdvjM]
        case w3_sdvjL of {
          GHC.Generics.:*: ww1_sdvjO [Occ=Once] ww2_sdvjP [Occ=Once] ->
              case w4_sdvjM of {
                GHC.Generics.:*: ww4_sdvjR [Occ=Once] ww5_sdvjS [Occ=Once] ->
                    let {
                      sat_sdvjU [Occ=Once] :: g_sdtv8 c_sdtvd
                      [LclId] =
                          [w1_sdvjJ w2_sdvjK ww2_sdvjP ww5_sdvjS] \u []
                              Control.Monad.Zip.mzipWith
                                  w1_sdvjJ w2_sdvjK ww2_sdvjP ww5_sdvjS; } in
                    let {
                      sat_sdvjT [Occ=Once] :: f_sdtv7 c_sdtvd
                      [LclId] =
                          [w_sdvjI w2_sdvjK ww1_sdvjO ww4_sdvjR] \u []
                              Control.Monad.Zip.mzipWith w_sdvjI w2_sdvjK ww1_sdvjO ww4_sdvjR;
                    } in  GHC.Generics.:*: [sat_sdvjT sat_sdvjU];
              };
        };

Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     GHC.Base.Monad (f GHC.Generics.:*: g)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvjV $dMonadZip1_sdvjW]
        let {
          sat_sdvjY [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_adt6u
          [LclId] =
              [$dMonadZip1_sdvjW] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip1_sdvjW; } in
        let {
          sat_sdvjX [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_adt6t
          [LclId] =
              [$dMonadZip_sdvjV] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdvjV;
        } in  GHC.Generics.$fMonad:*: sat_sdvjX sat_sdvjY;

Control.Monad.Zip.$dmmunzip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b. m (a, b) -> (m a, m b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvjZ eta_sdvk0]
        let {
          $dMonad_sdvk1 [Dmd=<L,U(A,C(C1(U)),A,C(U),A)>]
            :: GHC.Base.Monad m_adt27
          [LclId] =
              [$dMonadZip_sdvjZ] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdvjZ; } in
        let {
          sat_sdvkf [Occ=Once] :: m_adt27 b_adt6d
          [LclId] =
              [eta_sdvk0 $dMonad_sdvk1] \u []
                  let {
                    sat_sdvke [Occ=Once] :: (a_adt6c, b_adt6d) -> m_adt27 b_adt6d
                    [LclId] =
                        [$dMonad_sdvk1] \r [x1_sdvk9]
                            let {
                              sat_sdvkd [Occ=Once] :: b_adt6d
                              [LclId] =
                                  [x1_sdvk9] \u []
                                      case x1_sdvk9 of {
                                        (,) _ [Occ=Dead] y_sdvkc [Occ=Once] -> y_sdvkc;
                                      };
                            } in  GHC.Base.return $dMonad_sdvk1 sat_sdvkd;
                  } in  GHC.Base.>>= $dMonad_sdvk1 eta_sdvk0 sat_sdvke; } in
        let {
          sat_sdvk8 [Occ=Once] :: m_adt27 a_adt6c
          [LclId] =
              [eta_sdvk0 $dMonad_sdvk1] \u []
                  let {
                    sat_sdvk7 [Occ=Once] :: (a_adt6c, b_adt6d) -> m_adt27 a_adt6c
                    [LclId] =
                        [$dMonad_sdvk1] \r [x1_sdvk2]
                            let {
                              sat_sdvk6 [Occ=Once] :: a_adt6c
                              [LclId] =
                                  [x1_sdvk2] \u []
                                      case x1_sdvk2 of {
                                        (,) x_sdvk4 [Occ=Once] _ [Occ=Dead] -> x_sdvk4;
                                      };
                            } in  GHC.Base.return $dMonad_sdvk1 sat_sdvk6;
                  } in  GHC.Base.>>= $dMonad_sdvk1 eta_sdvk0 sat_sdvk7;
        } in  (,) [sat_sdvk8 sat_sdvkf];

Control.Monad.Zip.$dmmzipWith
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b c. (a -> b -> c) -> m a -> m b -> m c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S))LLL)LLL),U(1*U(A,1*C1(C1(U)),A,C(U),A),1*C1(C1(U)),A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvkg eta_sdvkh eta1_sdvki eta2_sdvkj]
        case
            Control.Monad.Zip.$p1MonadZip $dMonadZip_sdvkg
        of
        $dMonad_sdvkk [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
        { __DEFAULT ->
              let {
                sat_sdvkw [Occ=Once] :: (a_adt5U, b_adt5V) -> m_adt27 c_adt5W
                [LclId] =
                    [eta_sdvkh $dMonad_sdvkk] \r [x1_sdvkm]
                        let {
                          sat_sdvkv [Occ=Once] :: c_adt5W
                          [LclId] =
                              [eta_sdvkh x1_sdvkm] \u []
                                  let {
                                    sat_sdvku [Occ=Once] :: b_adt5V
                                    [LclId] =
                                        [x1_sdvkm] \u []
                                            case x1_sdvkm of {
                                              (,) _ [Occ=Dead] y_sdvkt [Occ=Once] -> y_sdvkt;
                                            }; } in
                                  let {
                                    sat_sdvkq [Occ=Once] :: a_adt5U
                                    [LclId] =
                                        [x1_sdvkm] \u []
                                            case x1_sdvkm of {
                                              (,) x_sdvko [Occ=Once] _ [Occ=Dead] -> x_sdvko;
                                            };
                                  } in  eta_sdvkh sat_sdvkq sat_sdvku;
                        } in  GHC.Base.return $dMonad_sdvkk sat_sdvkv; } in
              let {
                sat_sdvkl [Occ=Once] :: m_adt27 (a_adt5U, b_adt5V)
                [LclId] =
                    [$dMonadZip_sdvkg eta1_sdvki eta2_sdvkj] \u []
                        Control.Monad.Zip.mzip $dMonadZip_sdvkg eta1_sdvki eta2_sdvkj;
              } in  GHC.Base.>>= $dMonad_sdvkk sat_sdvkl sat_sdvkw;
        };

Control.Monad.Zip.$dmmzip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b. m a -> m b -> m (a, b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLC(S)L),1*U(A,A,1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvkx]
        Control.Monad.Zip.mzipWith $dMonadZip_sdvkx GHC.Tuple.(,);

Control.Monad.Zip.$fMonadZip:*:_$cmzip
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     (GHC.Generics.:*:) f g a
     -> (GHC.Generics.:*:) f g b -> (GHC.Generics.:*:) f g (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A)><L,1*U(A,A,1*C1(C1(C1(U))),A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvky $dMonadZip1_sdvkz w_sdvkA w1_sdvkB]
        case w_sdvkA of {
          GHC.Generics.:*: ww1_sdvkD [Occ=Once] ww2_sdvkE [Occ=Once] ->
              case w1_sdvkB of {
                GHC.Generics.:*: ww4_sdvkG [Occ=Once] ww5_sdvkH [Occ=Once] ->
                    let {
                      sat_sdvkJ [Occ=Once] :: g_adt6u (a_adt6E, b_adt6F)
                      [LclId] =
                          [$dMonadZip1_sdvkz ww2_sdvkE ww5_sdvkH] \u []
                              Control.Monad.Zip.mzipWith
                                  $dMonadZip1_sdvkz GHC.Tuple.(,) ww2_sdvkE ww5_sdvkH; } in
                    let {
                      sat_sdvkI [Occ=Once] :: f_adt6t (a_adt6E, b_adt6F)
                      [LclId] =
                          [$dMonadZip_sdvky ww1_sdvkD ww4_sdvkG] \u []
                              Control.Monad.Zip.mzipWith
                                  $dMonadZip_sdvky GHC.Tuple.(,) ww1_sdvkD ww4_sdvkG;
                    } in  GHC.Generics.:*: [sat_sdvkI sat_sdvkJ];
              };
        };

Control.Monad.Zip.$w$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     (GHC.Generics.:*:) f g (a, b)
     -> (# (GHC.Generics.:*:) f g a, (GHC.Generics.:*:) f g b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdvkK w1_sdvkL w2_sdvkM]
        let {
          $dMonad_sdvkN [Dmd=<L,U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_sdtvG
          [LclId] =
              [w1_sdvkL] \u [] Control.Monad.Zip.$p1MonadZip w1_sdvkL; } in
        let {
          lvl_sdvkO [Dmd=<L,U(A,C(U),A,A,A,A)>]
            :: GHC.Base.Applicative g_sdtvG
          [LclId] =
              [$dMonad_sdvkN] \u [] GHC.Base.$p1Monad $dMonad_sdvkN; } in
        let {
          $dMonad1_sdvkP [Dmd=<L,U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_sdtvF
          [LclId] =
              [w_sdvkK] \u [] Control.Monad.Zip.$p1MonadZip w_sdvkK; } in
        let {
          lvl1_sdvkQ [Dmd=<L,U(A,C(U),A,A,A,A)>]
            :: GHC.Base.Applicative f_sdtvF
          [LclId] =
              [$dMonad1_sdvkP] \u [] GHC.Base.$p1Monad $dMonad1_sdvkP; } in
        let {
          sat_sdvlq [Occ=Once] :: (GHC.Generics.:*:) f_sdtvF g_sdtvG b_sdtvK
          [LclId] =
              [w2_sdvkM $dMonad_sdvkN lvl_sdvkO $dMonad1_sdvkP lvl1_sdvkQ] \u []
                  case w2_sdvkM of {
                    GHC.Generics.:*: ww1_sdvla [Occ=Once] ww2_sdvlb [Occ=Once] ->
                        let {
                          sat_sdvlp [Occ=Once] :: g_sdtvG b_sdtvK
                          [LclId] =
                              [$dMonad_sdvkN lvl_sdvkO ww2_sdvlb] \u []
                                  let {
                                    sat_sdvlo [Occ=Once] :: (a_sdtvJ, b_sdtvK) -> g_sdtvG b_sdtvK
                                    [LclId] =
                                        [lvl_sdvkO] \r [a1_sdvlj]
                                            let {
                                              sat_sdvln [Occ=Once] :: b_sdtvK
                                              [LclId] =
                                                  [a1_sdvlj] \u []
                                                      case a1_sdvlj of {
                                                        (,) _ [Occ=Dead] y_sdvlm [Occ=Once] ->
                                                            y_sdvlm;
                                                      };
                                            } in  GHC.Base.pure lvl_sdvkO sat_sdvln;
                                  } in  GHC.Base.>>= $dMonad_sdvkN ww2_sdvlb sat_sdvlo; } in
                        let {
                          sat_sdvli [Occ=Once] :: f_sdtvF b_sdtvK
                          [LclId] =
                              [$dMonad1_sdvkP lvl1_sdvkQ ww1_sdvla] \u []
                                  let {
                                    sat_sdvlh [Occ=Once] :: (a_sdtvJ, b_sdtvK) -> f_sdtvF b_sdtvK
                                    [LclId] =
                                        [lvl1_sdvkQ] \r [a1_sdvlc]
                                            let {
                                              sat_sdvlg [Occ=Once] :: b_sdtvK
                                              [LclId] =
                                                  [a1_sdvlc] \u []
                                                      case a1_sdvlc of {
                                                        (,) _ [Occ=Dead] y_sdvlf [Occ=Once] ->
                                                            y_sdvlf;
                                                      };
                                            } in  GHC.Base.pure lvl1_sdvkQ sat_sdvlg;
                                  } in  GHC.Base.>>= $dMonad1_sdvkP ww1_sdvla sat_sdvlh;
                        } in  GHC.Generics.:*: [sat_sdvli sat_sdvlp];
                  }; } in
        let {
          sat_sdvl8 [Occ=Once] :: (GHC.Generics.:*:) f_sdtvF g_sdtvG a_sdtvJ
          [LclId] =
              [w2_sdvkM $dMonad_sdvkN lvl_sdvkO $dMonad1_sdvkP lvl1_sdvkQ] \u []
                  case w2_sdvkM of {
                    GHC.Generics.:*: ww1_sdvkS [Occ=Once] ww2_sdvkT [Occ=Once] ->
                        let {
                          sat_sdvl7 [Occ=Once] :: g_sdtvG a_sdtvJ
                          [LclId] =
                              [$dMonad_sdvkN lvl_sdvkO ww2_sdvkT] \u []
                                  let {
                                    sat_sdvl6 [Occ=Once] :: (a_sdtvJ, b_sdtvK) -> g_sdtvG a_sdtvJ
                                    [LclId] =
                                        [lvl_sdvkO] \r [a1_sdvl1]
                                            let {
                                              sat_sdvl5 [Occ=Once] :: a_sdtvJ
                                              [LclId] =
                                                  [a1_sdvl1] \u []
                                                      case a1_sdvl1 of {
                                                        (,) x_sdvl3 [Occ=Once] _ [Occ=Dead] ->
                                                            x_sdvl3;
                                                      };
                                            } in  GHC.Base.pure lvl_sdvkO sat_sdvl5;
                                  } in  GHC.Base.>>= $dMonad_sdvkN ww2_sdvkT sat_sdvl6; } in
                        let {
                          sat_sdvl0 [Occ=Once] :: f_sdtvF a_sdtvJ
                          [LclId] =
                              [$dMonad1_sdvkP lvl1_sdvkQ ww1_sdvkS] \u []
                                  let {
                                    sat_sdvkZ [Occ=Once] :: (a_sdtvJ, b_sdtvK) -> f_sdtvF a_sdtvJ
                                    [LclId] =
                                        [lvl1_sdvkQ] \r [a1_sdvkU]
                                            let {
                                              sat_sdvkY [Occ=Once] :: a_sdtvJ
                                              [LclId] =
                                                  [a1_sdvkU] \u []
                                                      case a1_sdvkU of {
                                                        (,) x_sdvkW [Occ=Once] _ [Occ=Dead] ->
                                                            x_sdvkW;
                                                      };
                                            } in  GHC.Base.pure lvl1_sdvkQ sat_sdvkY;
                                  } in  GHC.Base.>>= $dMonad1_sdvkP ww1_sdvkS sat_sdvkZ;
                        } in  GHC.Generics.:*: [sat_sdvl0 sat_sdvl7];
                  };
        } in  (#,#) [sat_sdvl8 sat_sdvlq];

Control.Monad.Zip.$fMonadZip:*:_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     (GHC.Generics.:*:) f g (a, b)
     -> ((GHC.Generics.:*:) f g a, (GHC.Generics.:*:) f g b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdvlr w1_sdvls w2_sdvlt]
        case Control.Monad.Zip.$w$cmunzip w_sdvlr w1_sdvls w2_sdvlt of {
          (#,#) ww1_sdvlv [Occ=Once] ww2_sdvlw [Occ=Once] ->
              (,) [ww1_sdvlv ww2_sdvlw];
        };

Control.Monad.Zip.$fMonadZip:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     Control.Monad.Zip.MonadZip (f GHC.Generics.:*: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)><L,U(U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sdvlx $dMonadZip1_sdvly]
        let {
          sat_sdvlC [Occ=Once]
            :: forall a b.
               (GHC.Generics.:*:) f_adt6t g_adt6u (a, b)
               -> ((GHC.Generics.:*:) f_adt6t g_adt6u a,
                   (GHC.Generics.:*:) f_adt6t g_adt6u b)
          [LclId] =
              [$dMonadZip_sdvlx $dMonadZip1_sdvly] \r [eta_B1]
                  Control.Monad.Zip.$fMonadZip:*:_$cmunzip
                      $dMonadZip_sdvlx $dMonadZip1_sdvly eta_B1; } in
        let {
          sat_sdvlB [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> (GHC.Generics.:*:) f_adt6t g_adt6u a
               -> (GHC.Generics.:*:) f_adt6t g_adt6u b
               -> (GHC.Generics.:*:) f_adt6t g_adt6u c
          [LclId] =
              [$dMonadZip_sdvlx $dMonadZip1_sdvly] \r [eta_B3 eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZip:*:_$cmzipWith
                      $dMonadZip_sdvlx $dMonadZip1_sdvly eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdvlA [Occ=Once]
            :: forall a b.
               (GHC.Generics.:*:) f_adt6t g_adt6u a
               -> (GHC.Generics.:*:) f_adt6t g_adt6u b
               -> (GHC.Generics.:*:) f_adt6t g_adt6u (a, b)
          [LclId] =
              [$dMonadZip_sdvlx $dMonadZip1_sdvly] \r [eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZip:*:_$cmzip
                      $dMonadZip_sdvlx $dMonadZip1_sdvly eta_B2 eta_B1; } in
        let {
          sat_sdvlz [Occ=Once]
            :: GHC.Base.Monad (f_adt6t GHC.Generics.:*: g_adt6u)
          [LclId] =
              [$dMonadZip_sdvlx $dMonadZip1_sdvly] \u []
                  Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip
                      $dMonadZip_sdvlx $dMonadZip1_sdvly;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sdvlz
                                        sat_sdvlA
                                        sat_sdvlB
                                        sat_sdvlC];

Control.Monad.Zip.$fMonadZipM2
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.M1 i c f a -> GHC.Generics.M1 i c f b -> f (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvlD ds_sdvlE ds1_sdvlF]
        Control.Monad.Zip.mzipWith
            $dMonadZip_sdvlD GHC.Tuple.(,) ds_sdvlE ds1_sdvlF;

Control.Monad.Zip.$w$cmunzip2 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.M1 i c f (a, b)
     -> (# GHC.Generics.M1 i c f a, GHC.Generics.M1 i c f b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdvlG w1_sdvlH]
        let {
          $dMonad_sdvlI [Dmd=<L,U(A,C(C1(U)),A,C(U),A)>]
            :: GHC.Base.Monad f_sdtvQ
          [LclId] =
              [w_sdvlG] \u [] Control.Monad.Zip.$p1MonadZip w_sdvlG; } in
        let {
          sat_sdvlW [Occ=Once]
            :: GHC.Generics.M1 i_sdtvR c_sdtvS f_sdtvQ b_sdtvV
          [LclId] =
              [w1_sdvlH $dMonad_sdvlI] \u []
                  let {
                    sat_sdvlV [Occ=Once] :: (a_sdtvU, b_sdtvV) -> f_sdtvQ b_sdtvV
                    [LclId] =
                        [$dMonad_sdvlI] \r [x1_sdvlQ]
                            let {
                              sat_sdvlU [Occ=Once] :: b_sdtvV
                              [LclId] =
                                  [x1_sdvlQ] \u []
                                      case x1_sdvlQ of {
                                        (,) _ [Occ=Dead] y_sdvlT [Occ=Once] -> y_sdvlT;
                                      };
                            } in  GHC.Base.return $dMonad_sdvlI sat_sdvlU;
                  } in  GHC.Base.>>= $dMonad_sdvlI w1_sdvlH sat_sdvlV; } in
        let {
          sat_sdvlP [Occ=Once]
            :: GHC.Generics.M1 i_sdtvR c_sdtvS f_sdtvQ a_sdtvU
          [LclId] =
              [w1_sdvlH $dMonad_sdvlI] \u []
                  let {
                    sat_sdvlO [Occ=Once] :: (a_sdtvU, b_sdtvV) -> f_sdtvQ a_sdtvU
                    [LclId] =
                        [$dMonad_sdvlI] \r [x1_sdvlJ]
                            let {
                              sat_sdvlN [Occ=Once] :: a_sdtvU
                              [LclId] =
                                  [x1_sdvlJ] \u []
                                      case x1_sdvlJ of {
                                        (,) x_sdvlL [Occ=Once] _ [Occ=Dead] -> x_sdvlL;
                                      };
                            } in  GHC.Base.return $dMonad_sdvlI sat_sdvlN;
                  } in  GHC.Base.>>= $dMonad_sdvlI w1_sdvlH sat_sdvlO;
        } in  (#,#) [sat_sdvlP sat_sdvlW];

Control.Monad.Zip.$fMonadZipM1_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.M1 i c f (a, b)
     -> (GHC.Generics.M1 i c f a, GHC.Generics.M1 i c f b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdvlX w1_sdvlY]
        case Control.Monad.Zip.$w$cmunzip2 w_sdvlX w1_sdvlY of {
          (#,#) ww1_sdvm0 [Occ=Once] ww2_sdvm1 [Occ=Once] ->
              (,) [ww1_sdvm0 ww2_sdvm1];
        };

Control.Monad.Zip.$fMonadZipM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     Control.Monad.Zip.MonadZip (GHC.Generics.M1 i c f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),U,1*U,U,1*U),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sdvm2]
        let {
          sat_sdvm9 [Occ=Once]
            :: forall a b.
               GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s (a, b)
               -> (GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s a,
                   GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s b)
          [LclId] =
              [$dMonadZip_sdvm2] \r [eta_B1]
                  Control.Monad.Zip.$fMonadZipM1_$cmunzip
                      $dMonadZip_sdvm2 eta_B1; } in
        let {
          sat_sdvm8 [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s a
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s b
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s c
          [LclId] =
              [$dMonadZip_sdvm2] \r [f1_sdvm5 ds_sdvm6 ds1_sdvm7]
                  Control.Monad.Zip.mzipWith
                      $dMonadZip_sdvm2 f1_sdvm5 ds_sdvm6 ds1_sdvm7; } in
        let {
          sat_sdvm4 [Occ=Once]
            :: forall a b.
               GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s a
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s b
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s (a, b)
          [LclId] =
              [$dMonadZip_sdvm2] \r [eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZipM2 $dMonadZip_sdvm2 eta_B2 eta_B1; } in
        let {
          sat_sdvm3 [Occ=Once]
            :: GHC.Base.Monad (GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s)
          [LclId] =
              [$dMonadZip_sdvm2] \u []
                  Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip $dMonadZip_sdvm2;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sdvm3
                                        sat_sdvm4
                                        sat_sdvm8
                                        sat_sdvm9];

Control.Monad.Zip.$fMonadZipRec2
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.Rec1 f a -> GHC.Generics.Rec1 f b -> f (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvma ds_sdvmb ds1_sdvmc]
        Control.Monad.Zip.mzipWith
            $dMonadZip_sdvma GHC.Tuple.(,) ds_sdvmb ds1_sdvmc;

Control.Monad.Zip.$w$cmunzip4 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.Rec1 f (a, b)
     -> (# GHC.Generics.Rec1 f a, GHC.Generics.Rec1 f b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdvmd w1_sdvme]
        let {
          $dMonad_sdvmf [Dmd=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_sdtw1
          [LclId] =
              [w_sdvmd] \u [] Control.Monad.Zip.$p1MonadZip w_sdvmd; } in
        let {
          sat_sdvmv [Occ=Once] :: GHC.Generics.Rec1 f_sdtw1 b_sdtw4
          [LclId] =
              [w1_sdvme $dMonad_sdvmf] \u []
                  let {
                    lvl_sdvmo [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                      :: GHC.Base.Applicative f_sdtw1
                    [LclId] =
                        [$dMonad_sdvmf] \u [] GHC.Base.$p1Monad $dMonad_sdvmf; } in
                  let {
                    sat_sdvmu [Occ=Once] :: (a_sdtw3, b_sdtw4) -> f_sdtw1 b_sdtw4
                    [LclId] =
                        [lvl_sdvmo] \r [a1_sdvmp]
                            let {
                              sat_sdvmt [Occ=Once] :: b_sdtw4
                              [LclId] =
                                  [a1_sdvmp] \u []
                                      case a1_sdvmp of {
                                        (,) _ [Occ=Dead] y_sdvms [Occ=Once] -> y_sdvms;
                                      };
                            } in  GHC.Base.pure lvl_sdvmo sat_sdvmt;
                  } in  GHC.Base.>>= $dMonad_sdvmf w1_sdvme sat_sdvmu; } in
        let {
          sat_sdvmn [Occ=Once] :: GHC.Generics.Rec1 f_sdtw1 a_sdtw3
          [LclId] =
              [w1_sdvme $dMonad_sdvmf] \u []
                  let {
                    lvl_sdvmg [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                      :: GHC.Base.Applicative f_sdtw1
                    [LclId] =
                        [$dMonad_sdvmf] \u [] GHC.Base.$p1Monad $dMonad_sdvmf; } in
                  let {
                    sat_sdvmm [Occ=Once] :: (a_sdtw3, b_sdtw4) -> f_sdtw1 a_sdtw3
                    [LclId] =
                        [lvl_sdvmg] \r [a1_sdvmh]
                            let {
                              sat_sdvml [Occ=Once] :: a_sdtw3
                              [LclId] =
                                  [a1_sdvmh] \u []
                                      case a1_sdvmh of {
                                        (,) x_sdvmj [Occ=Once] _ [Occ=Dead] -> x_sdvmj;
                                      };
                            } in  GHC.Base.pure lvl_sdvmg sat_sdvml;
                  } in  GHC.Base.>>= $dMonad_sdvmf w1_sdvme sat_sdvmm;
        } in  (#,#) [sat_sdvmn sat_sdvmv];

Control.Monad.Zip.$fMonadZipRec1_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.Rec1 f (a, b)
     -> (GHC.Generics.Rec1 f a, GHC.Generics.Rec1 f b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdvmw w1_sdvmx]
        case Control.Monad.Zip.$w$cmunzip4 w_sdvmw w1_sdvmx of {
          (#,#) ww1_sdvmz [Occ=Once] ww2_sdvmA [Occ=Once] ->
              (,) [ww1_sdvmz ww2_sdvmA];
        };

Control.Monad.Zip.$fMonadZipRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     Control.Monad.Zip.MonadZip (GHC.Generics.Rec1 f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(1*U(1*U,1*U),U,1*U,1*U,1*U,1*U),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sdvmB]
        let {
          sat_sdvmI [Occ=Once]
            :: forall a b.
               GHC.Generics.Rec1 f_Xdtao (a, b)
               -> (GHC.Generics.Rec1 f_Xdtao a, GHC.Generics.Rec1 f_Xdtao b)
          [LclId] =
              [$dMonadZip_sdvmB] \r [eta_B1]
                  Control.Monad.Zip.$fMonadZipRec1_$cmunzip
                      $dMonadZip_sdvmB eta_B1; } in
        let {
          sat_sdvmH [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> GHC.Generics.Rec1 f_Xdtao a
               -> GHC.Generics.Rec1 f_Xdtao b
               -> GHC.Generics.Rec1 f_Xdtao c
          [LclId] =
              [$dMonadZip_sdvmB] \r [f1_sdvmE ds_sdvmF ds1_sdvmG]
                  Control.Monad.Zip.mzipWith
                      $dMonadZip_sdvmB f1_sdvmE ds_sdvmF ds1_sdvmG; } in
        let {
          sat_sdvmD [Occ=Once]
            :: forall a b.
               GHC.Generics.Rec1 f_Xdtao a
               -> GHC.Generics.Rec1 f_Xdtao b -> GHC.Generics.Rec1 f_Xdtao (a, b)
          [LclId] =
              [$dMonadZip_sdvmB] \r [eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZipRec2
                      $dMonadZip_sdvmB eta_B2 eta_B1; } in
        let {
          sat_sdvmC [Occ=Once] :: GHC.Base.Monad (GHC.Generics.Rec1 f_Xdtao)
          [LclId] =
              [$dMonadZip_sdvmB] \u []
                  Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip $dMonadZip_sdvmB;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sdvmC
                                        sat_sdvmD
                                        sat_sdvmH
                                        sat_sdvmI];

Control.Monad.Zip.$fMonadZipPar1_$cmunzip
  :: forall a b.
     GHC.Generics.Par1 (a, b)
     -> (GHC.Generics.Par1 a, GHC.Generics.Par1 b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [mab_sdvmJ]
        let {
          sat_sdvmR [Occ=Once] :: GHC.Generics.Par1 b_adt9i
          [LclId] =
              [mab_sdvmJ] \u []
                  case mab_sdvmJ of {
                    (,) _ [Occ=Dead] y_sdvmQ [Occ=Once] -> y_sdvmQ;
                  }; } in
        let {
          sat_sdvmN [Occ=Once] :: GHC.Generics.Par1 a_adt9h
          [LclId] =
              [mab_sdvmJ] \u []
                  case mab_sdvmJ of {
                    (,) x_sdvmL [Occ=Once] _ [Occ=Dead] -> x_sdvmL;
                  };
        } in  (,) [sat_sdvmN sat_sdvmR];

Control.Monad.Zip.$fMonadZipPar1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip GHC.Generics.Par1
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Generics.$fMonadPar1
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipPar2
                                                 Control.Monad.Zip.$fMonadZipPar1_$cmunzip];

Control.Monad.Zip.$fMonadZipU1_$cmzip
  :: forall a b.
     GHC.Generics.U1 a -> GHC.Generics.U1 b -> GHC.Generics.U1 (a, b)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdvmS ds1_sdvmT] GHC.Generics.U1 [];

Control.Monad.Zip.$fMonadZipU2
  :: forall b a. (GHC.Generics.U1 a, GHC.Generics.U1 b)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Generics.U1 GHC.Generics.U1];

Control.Monad.Zip.$fMonadZipU1_$cmunzip
  :: forall a b.
     GHC.Generics.U1 (a, b) -> (GHC.Generics.U1 a, GHC.Generics.U1 b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [mab_sdvmU] Control.Monad.Zip.$fMonadZipU2;

Control.Monad.Zip.$fMonadZipU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip GHC.Generics.U1
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Generics.$fMonadU1
                                                 Control.Monad.Zip.$fMonadZipU1_$cmzip
                                                 Control.Monad.Zip.$fMonadZipU1_$cmzipWith
                                                 Control.Monad.Zip.$fMonadZipU1_$cmunzip];

Control.Monad.Zip.$fMonadZipProxy_$cmzip
  :: forall a b.
     Data.Proxy.Proxy a -> Data.Proxy.Proxy b -> Data.Proxy.Proxy (a, b)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdvmV ds1_sdvmW] Data.Proxy.Proxy [];

Control.Monad.Zip.$fMonadZipProxy1
  :: forall b a. (Data.Proxy.Proxy a, Data.Proxy.Proxy b)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Proxy.Proxy Data.Proxy.Proxy];

Control.Monad.Zip.$fMonadZipProxy_$cmunzip
  :: forall a b.
     Data.Proxy.Proxy (a, b) -> (Data.Proxy.Proxy a, Data.Proxy.Proxy b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [mab_sdvmX] Control.Monad.Zip.$fMonadZipProxy1;

Control.Monad.Zip.$fMonadZipProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Proxy.Proxy
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Proxy.$fMonadProxy
                                                 Control.Monad.Zip.$fMonadZipProxy_$cmzip
                                                 Control.Monad.Zip.$fMonadZipProxy_$cmzipWith
                                                 Control.Monad.Zip.$fMonadZipProxy_$cmunzip];

Control.Monad.Zip.$fMonadZipAlt1
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     Data.Semigroup.Internal.Alt f a
     -> Data.Semigroup.Internal.Alt f b -> f (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvmY ds_sdvmZ ds1_sdvn0]
        Control.Monad.Zip.mzipWith
            $dMonadZip_sdvmY GHC.Tuple.(,) ds_sdvmZ ds1_sdvn0;

Control.Monad.Zip.$w$cmunzip1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     Data.Semigroup.Internal.Alt f (a, b)
     -> (# Data.Semigroup.Internal.Alt f a,
           Data.Semigroup.Internal.Alt f b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdvn1 w1_sdvn2]
        let {
          $dMonad_sdvn3 [Dmd=<L,U(A,C(C1(U)),A,C(U),A)>]
            :: GHC.Base.Monad f_sdtwa
          [LclId] =
              [w_sdvn1] \u [] Control.Monad.Zip.$p1MonadZip w_sdvn1; } in
        let {
          sat_sdvnh [Occ=Once] :: Data.Semigroup.Internal.Alt f_sdtwa b_sdtwd
          [LclId] =
              [w1_sdvn2 $dMonad_sdvn3] \u []
                  let {
                    sat_sdvng [Occ=Once] :: (a_sdtwc, b_sdtwd) -> f_sdtwa b_sdtwd
                    [LclId] =
                        [$dMonad_sdvn3] \r [x1_sdvnb]
                            let {
                              sat_sdvnf [Occ=Once] :: b_sdtwd
                              [LclId] =
                                  [x1_sdvnb] \u []
                                      case x1_sdvnb of {
                                        (,) _ [Occ=Dead] y_sdvne [Occ=Once] -> y_sdvne;
                                      };
                            } in  GHC.Base.return $dMonad_sdvn3 sat_sdvnf;
                  } in  GHC.Base.>>= $dMonad_sdvn3 w1_sdvn2 sat_sdvng; } in
        let {
          sat_sdvna [Occ=Once] :: Data.Semigroup.Internal.Alt f_sdtwa a_sdtwc
          [LclId] =
              [w1_sdvn2 $dMonad_sdvn3] \u []
                  let {
                    sat_sdvn9 [Occ=Once] :: (a_sdtwc, b_sdtwd) -> f_sdtwa a_sdtwc
                    [LclId] =
                        [$dMonad_sdvn3] \r [x1_sdvn4]
                            let {
                              sat_sdvn8 [Occ=Once] :: a_sdtwc
                              [LclId] =
                                  [x1_sdvn4] \u []
                                      case x1_sdvn4 of {
                                        (,) x_sdvn6 [Occ=Once] _ [Occ=Dead] -> x_sdvn6;
                                      };
                            } in  GHC.Base.return $dMonad_sdvn3 sat_sdvn8;
                  } in  GHC.Base.>>= $dMonad_sdvn3 w1_sdvn2 sat_sdvn9;
        } in  (#,#) [sat_sdvna sat_sdvnh];

Control.Monad.Zip.$fMonadZipAlt_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     Data.Semigroup.Internal.Alt f (a, b)
     -> (Data.Semigroup.Internal.Alt f a,
         Data.Semigroup.Internal.Alt f b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdvni w1_sdvnj]
        case Control.Monad.Zip.$w$cmunzip1 w_sdvni w1_sdvnj of {
          (#,#) ww1_sdvnl [Occ=Once] ww2_sdvnm [Occ=Once] ->
              (,) [ww1_sdvnl ww2_sdvnm];
        };

Control.Monad.Zip.$fMonadZipAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     Control.Monad.Zip.MonadZip (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),U,1*U,U,1*U),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sdvnn]
        let {
          sat_sdvnu [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_Xdtd8 (a, b)
               -> (Data.Semigroup.Internal.Alt f_Xdtd8 a,
                   Data.Semigroup.Internal.Alt f_Xdtd8 b)
          [LclId] =
              [$dMonadZip_sdvnn] \r [eta_B1]
                  Control.Monad.Zip.$fMonadZipAlt_$cmunzip
                      $dMonadZip_sdvnn eta_B1; } in
        let {
          sat_sdvnt [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Semigroup.Internal.Alt f_Xdtd8 a
               -> Data.Semigroup.Internal.Alt f_Xdtd8 b
               -> Data.Semigroup.Internal.Alt f_Xdtd8 c
          [LclId] =
              [$dMonadZip_sdvnn] \r [f1_sdvnq ds_sdvnr ds1_sdvns]
                  Control.Monad.Zip.mzipWith
                      $dMonadZip_sdvnn f1_sdvnq ds_sdvnr ds1_sdvns; } in
        let {
          sat_sdvnp [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_Xdtd8 a
               -> Data.Semigroup.Internal.Alt f_Xdtd8 b
               -> Data.Semigroup.Internal.Alt f_Xdtd8 (a, b)
          [LclId] =
              [$dMonadZip_sdvnn] \r [eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZipAlt1
                      $dMonadZip_sdvnn eta_B2 eta_B1; } in
        let {
          sat_sdvno [Occ=Once]
            :: GHC.Base.Monad (Data.Semigroup.Internal.Alt f_Xdtd8)
          [LclId] =
              [$dMonadZip_sdvnn] \u []
                  Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip $dMonadZip_sdvnn;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sdvno
                                        sat_sdvnp
                                        sat_sdvnt
                                        sat_sdvnu];

Control.Monad.Zip.$fMonadZipLast2
  :: forall b a.
     Data.Monoid.Last a -> Data.Monoid.Last b -> GHC.Base.Maybe (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [m1_sdvnv m2_sdvnw]
        case m1_sdvnv of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdvny [Occ=Once] ->
              case m2_sdvnw of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdvnA [Occ=Once] ->
                    let {
                      sat_sdvnB [Occ=Once] :: (a_adtbn, b_adtbo)
                      [LclId] =
                          CCCS (,)! [x_sdvny x1_sdvnA];
                    } in  GHC.Base.Just [sat_sdvnB];
              };
        };

Control.Monad.Zip.$fMonadZipLast_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Data.Monoid.Last (a, b) -> (Data.Monoid.Last a, Data.Monoid.Last b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [w_sdvnC]
        let {
          sat_sdvnQ [Occ=Once] :: Data.Monoid.Last b_sdtwk
          [LclId] =
              [w_sdvnC] \u []
                  case w_sdvnC of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdvnL [Occ=Once!] ->
                        let {
                          sat_sdvnP [Occ=Once] :: b_sdtwk
                          [LclId] =
                              [x_sdvnL] \u []
                                  case x_sdvnL of {
                                    (,) _ [Occ=Dead] y_sdvnO [Occ=Once] -> y_sdvnO;
                                  };
                        } in  GHC.Base.Just [sat_sdvnP];
                  }; } in
        let {
          sat_sdvnJ [Occ=Once] :: Data.Monoid.Last a_sdtwj
          [LclId] =
              [w_sdvnC] \u []
                  case w_sdvnC of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdvnE [Occ=Once!] ->
                        let {
                          sat_sdvnI [Occ=Once] :: a_sdtwj
                          [LclId] =
                              [x_sdvnE] \u []
                                  case x_sdvnE of {
                                    (,) x1_sdvnG [Occ=Once] _ [Occ=Dead] -> x1_sdvnG;
                                  };
                        } in  GHC.Base.Just [sat_sdvnI];
                  };
        } in  (,) [sat_sdvnJ sat_sdvnQ];

Control.Monad.Zip.$fMonadZipLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Monoid.Last
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Monoid.$fMonadLast
                                                 Control.Monad.Zip.$fMonadZipLast2
                                                 Control.Monad.Zip.$fMonadZipLast1
                                                 Control.Monad.Zip.$fMonadZipLast_$cmunzip];

Control.Monad.Zip.$fMonadZipFirst2
  :: forall b a.
     Data.Monoid.First a -> Data.Monoid.First b -> GHC.Base.Maybe (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [m1_sdvnR m2_sdvnS]
        case m1_sdvnR of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdvnU [Occ=Once] ->
              case m2_sdvnS of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdvnW [Occ=Once] ->
                    let {
                      sat_sdvnX [Occ=Once] :: (a_adtc0, b_adtc1)
                      [LclId] =
                          CCCS (,)! [x_sdvnU x1_sdvnW];
                    } in  GHC.Base.Just [sat_sdvnX];
              };
        };

Control.Monad.Zip.$fMonadZipFirst_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Data.Monoid.First (a, b)
     -> (Data.Monoid.First a, Data.Monoid.First b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [w_sdvnY]
        let {
          sat_sdvoc [Occ=Once] :: Data.Monoid.First b_sdtwr
          [LclId] =
              [w_sdvnY] \u []
                  case w_sdvnY of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdvo7 [Occ=Once!] ->
                        let {
                          sat_sdvob [Occ=Once] :: b_sdtwr
                          [LclId] =
                              [x_sdvo7] \u []
                                  case x_sdvo7 of {
                                    (,) _ [Occ=Dead] y_sdvoa [Occ=Once] -> y_sdvoa;
                                  };
                        } in  GHC.Base.Just [sat_sdvob];
                  }; } in
        let {
          sat_sdvo5 [Occ=Once] :: Data.Monoid.First a_sdtwq
          [LclId] =
              [w_sdvnY] \u []
                  case w_sdvnY of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdvo0 [Occ=Once!] ->
                        let {
                          sat_sdvo4 [Occ=Once] :: a_sdtwq
                          [LclId] =
                              [x_sdvo0] \u []
                                  case x_sdvo0 of {
                                    (,) x1_sdvo2 [Occ=Once] _ [Occ=Dead] -> x1_sdvo2;
                                  };
                        } in  GHC.Base.Just [sat_sdvo4];
                  };
        } in  (,) [sat_sdvo5 sat_sdvoc];

Control.Monad.Zip.$fMonadZipFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Monoid.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Monoid.$fMonadFirst
                                                 Control.Monad.Zip.$fMonadZipFirst2
                                                 Control.Monad.Zip.$fMonadZipFirst1
                                                 Control.Monad.Zip.$fMonadZipFirst_$cmunzip];

Control.Monad.Zip.$fMonadZipMaybe_$cmzip
  :: forall a b.
     GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [m1_sdvod m2_sdvoe]
        case m1_sdvod of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdvog [Occ=Once] ->
              case m2_sdvoe of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdvoi [Occ=Once] ->
                    let {
                      sat_sdvoj [Occ=Once] :: (a_adtcD, b_adtcE)
                      [LclId] =
                          CCCS (,)! [x_sdvog x1_sdvoi];
                    } in  GHC.Base.Just [sat_sdvoj];
              };
        };

Control.Monad.Zip.$fMonadZipMaybe_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.Maybe (a, b) -> (GHC.Base.Maybe a, GHC.Base.Maybe b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [w_sdvok]
        let {
          sat_sdvoy [Occ=Once] :: GHC.Base.Maybe b_sdtwy
          [LclId] =
              [w_sdvok] \u []
                  case w_sdvok of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdvot [Occ=Once!] ->
                        let {
                          sat_sdvox [Occ=Once] :: b_sdtwy
                          [LclId] =
                              [x_sdvot] \u []
                                  case x_sdvot of {
                                    (,) _ [Occ=Dead] y_sdvow [Occ=Once] -> y_sdvow;
                                  };
                        } in  GHC.Base.Just [sat_sdvox];
                  }; } in
        let {
          sat_sdvor [Occ=Once] :: GHC.Base.Maybe a_sdtwx
          [LclId] =
              [w_sdvok] \u []
                  case w_sdvok of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdvom [Occ=Once!] ->
                        let {
                          sat_sdvoq [Occ=Once] :: a_sdtwx
                          [LclId] =
                              [x_sdvom] \u []
                                  case x_sdvom of {
                                    (,) x1_sdvoo [Occ=Once] _ [Occ=Dead] -> x1_sdvoo;
                                  };
                        } in  GHC.Base.Just [sat_sdvoq];
                  };
        } in  (,) [sat_sdvor sat_sdvoy];

Control.Monad.Zip.$fMonadZipMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Base.$fMonadMaybe
                                                 Control.Monad.Zip.$fMonadZipMaybe_$cmzip
                                                 Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith
                                                 Control.Monad.Zip.$fMonadZipMaybe_$cmunzip];

Control.Monad.Zip.$fMonadZipProduct_$cmunzip
  :: forall a b.
     Data.Semigroup.Internal.Product (a, b)
     -> (Data.Semigroup.Internal.Product a,
         Data.Semigroup.Internal.Product b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [mab_sdvoz]
        let {
          sat_sdvoH [Occ=Once] :: Data.Semigroup.Internal.Product b_adtdE
          [LclId] =
              [mab_sdvoz] \u []
                  case mab_sdvoz of {
                    (,) _ [Occ=Dead] y_sdvoG [Occ=Once] -> y_sdvoG;
                  }; } in
        let {
          sat_sdvoD [Occ=Once] :: Data.Semigroup.Internal.Product a_adtdD
          [LclId] =
              [mab_sdvoz] \u []
                  case mab_sdvoz of {
                    (,) x_sdvoB [Occ=Once] _ [Occ=Dead] -> x_sdvoB;
                  };
        } in  (,) [sat_sdvoD sat_sdvoH];

Control.Monad.Zip.$fMonadZipProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Semigroup.Internal.$fMonadProduct
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipProduct1
                                                 Control.Monad.Zip.$fMonadZipProduct_$cmunzip];

Control.Monad.Zip.$fMonadZipSum_$cmunzip
  :: forall a b.
     Data.Semigroup.Internal.Sum (a, b)
     -> (Data.Semigroup.Internal.Sum a, Data.Semigroup.Internal.Sum b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [mab_sdvoI]
        let {
          sat_sdvoQ [Occ=Once] :: Data.Semigroup.Internal.Sum b_adteh
          [LclId] =
              [mab_sdvoI] \u []
                  case mab_sdvoI of {
                    (,) _ [Occ=Dead] y_sdvoP [Occ=Once] -> y_sdvoP;
                  }; } in
        let {
          sat_sdvoM [Occ=Once] :: Data.Semigroup.Internal.Sum a_adteg
          [LclId] =
              [mab_sdvoI] \u []
                  case mab_sdvoI of {
                    (,) x_sdvoK [Occ=Once] _ [Occ=Dead] -> x_sdvoK;
                  };
        } in  (,) [sat_sdvoM sat_sdvoQ];

Control.Monad.Zip.$fMonadZipSum [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Semigroup.Internal.$fMonadSum
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipSum1
                                                 Control.Monad.Zip.$fMonadZipSum_$cmunzip];

Control.Monad.Zip.$fMonadZipDual_$cmunzip
  :: forall a b.
     Data.Semigroup.Internal.Dual (a, b)
     -> (Data.Semigroup.Internal.Dual a, Data.Semigroup.Internal.Dual b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [mab_sdvoR]
        let {
          sat_sdvoZ [Occ=Once] :: Data.Semigroup.Internal.Dual b_adteU
          [LclId] =
              [mab_sdvoR] \u []
                  case mab_sdvoR of {
                    (,) _ [Occ=Dead] y_sdvoY [Occ=Once] -> y_sdvoY;
                  }; } in
        let {
          sat_sdvoV [Occ=Once] :: Data.Semigroup.Internal.Dual a_adteT
          [LclId] =
              [mab_sdvoR] \u []
                  case mab_sdvoR of {
                    (,) x_sdvoT [Occ=Once] _ [Occ=Dead] -> x_sdvoT;
                  };
        } in  (,) [sat_sdvoV sat_sdvoZ];

Control.Monad.Zip.$fMonadZipDual [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Semigroup.Internal.$fMonadDual
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipDual1
                                                 Control.Monad.Zip.$fMonadZipDual_$cmunzip];

Control.Monad.Zip.$fMonadZipIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Functor.Identity.$fMonadIdentity
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipIdentity1
                                                 Control.Monad.Zip.$fMonadZipIdentity_$cmunzip];

Control.Monad.Zip.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Control.Monad.Zip.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Monad.Zip.$trModule4];

Control.Monad.Zip.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Control.Monad.Zip"#;

Control.Monad.Zip.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Monad.Zip.$trModule2];

Control.Monad.Zip.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Control.Monad.Zip.$trModule3
                                     Control.Monad.Zip.$trModule1];

$krep_rdtIk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Control.Monad.Zip.$tcMonadZip1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_rdtIk];

Control.Monad.Zip.$tcMonadZip3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "MonadZip"#;

Control.Monad.Zip.$tcMonadZip2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Monad.Zip.$tcMonadZip3];

Control.Monad.Zip.$tcMonadZip :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4362170845454097361##
                                    3840659568565778968##
                                    Control.Monad.Zip.$trModule
                                    Control.Monad.Zip.$tcMonadZip2
                                    0#
                                    Control.Monad.Zip.$tcMonadZip1];

Control.Monad.Zip.C:MonadZip
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall a b. m a -> m b -> m (a, b))
     -> (forall a b c. (a -> b -> c) -> m a -> m b -> m c)
     -> (forall a b. m (a, b) -> (m a, m b))
     -> Control.Monad.Zip.MonadZip m
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Control.Monad.Zip.C:MonadZip [eta_B4 eta_B3 eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:08:41.492757193 UTC

Control.Monad.Zip.$p1MonadZip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     GHC.Base.Monad m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sdvhY]
        case v_sdvhY of {
          Control.Monad.Zip.C:MonadZip v_sdvi0 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdvi0;
        };

Control.Monad.Zip.mzip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b. m a -> m b -> m (a, b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sdvi4]
        case v_sdvi4 of {
          Control.Monad.Zip.C:MonadZip _ [Occ=Dead]
                                       v_sdvi7 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdvi7;
        };

Control.Monad.Zip.mzipWith
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b c. (a -> b -> c) -> m a -> m b -> m c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sdvia]
        case v_sdvia of {
          Control.Monad.Zip.C:MonadZip _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdvie [Occ=Once]
                                       _ [Occ=Dead] ->
              v_sdvie;
        };

Control.Monad.Zip.munzip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b. m (a, b) -> (m a, m b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sdvig]
        case v_sdvig of {
          Control.Monad.Zip.C:MonadZip _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdvil [Occ=Once] ->
              v_sdvil;
        };

Control.Monad.Zip.$fMonadZip[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Base.$fMonad[]
                                                 GHC.List.zip
                                                 GHC.List.zipWith
                                                 GHC.List.unzip];

Control.Monad.Zip.$w$cmunzip3 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty (a, b)
     -> (# GHC.Base.NonEmpty a, GHC.Base.NonEmpty b #)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(1*U,1*U),U)>,
 Unf=OtherCon []] =
    [] \r [w_sdvim]
        let {
          sat_sdviJ [Occ=Once] :: [b_sdtv1]
          [LclId] =
              [w_sdvim] \u []
                  case w_sdvim of {
                    GHC.Base.:| _ [Occ=Dead] as_sdviI [Occ=Once] ->
                        GHC.Base.map Data.Tuple.snd as_sdviI;
                  }; } in
        let {
          sat_sdviF [Occ=Once] :: b_sdtv1
          [LclId] =
              [w_sdvim] \u []
                  case w_sdvim of {
                    GHC.Base.:| a1_sdviA [Occ=Once!] _ [Occ=Dead] ->
                        case a1_sdviA of {
                          (,) _ [Occ=Dead] y_sdviE [Occ=Once] -> y_sdviE;
                        };
                  }; } in
        let {
          sat_sdviK [Occ=Once] :: GHC.Base.NonEmpty b_sdtv1
          [LclId] =
              CCCS GHC.Base.:|! [sat_sdviF sat_sdviJ]; } in
        let {
          sat_sdvix [Occ=Once] :: [a_sdtv0]
          [LclId] =
              [w_sdvim] \u []
                  case w_sdvim of {
                    GHC.Base.:| _ [Occ=Dead] as_sdviw [Occ=Once] ->
                        GHC.Base.map Data.Tuple.fst as_sdviw;
                  }; } in
        let {
          sat_sdvit [Occ=Once] :: a_sdtv0
          [LclId] =
              [w_sdvim] \u []
                  case w_sdvim of {
                    GHC.Base.:| a1_sdvio [Occ=Once!] _ [Occ=Dead] ->
                        case a1_sdvio of {
                          (,) x_sdvir [Occ=Once] _ [Occ=Dead] -> x_sdvir;
                        };
                  }; } in
        let {
          sat_sdviy [Occ=Once] :: GHC.Base.NonEmpty a_sdtv0
          [LclId] =
              CCCS GHC.Base.:|! [sat_sdvit sat_sdvix];
        } in  (#,#) [sat_sdviy sat_sdviK];

Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty (a, b)
     -> (GHC.Base.NonEmpty a, GHC.Base.NonEmpty b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(U,U),U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdviL]
        case Control.Monad.Zip.$w$cmunzip3 w_sdviL of {
          (#,#) ww1_sdviN [Occ=Once] ww2_sdviO [Occ=Once] ->
              (,) [ww1_sdviN ww2_sdviO];
        };

Control.Monad.Zip.$fMonadZipNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip GHC.Base.NonEmpty
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Base.$fMonadNonEmpty
                                                 Data.List.NonEmpty.zip
                                                 Data.List.NonEmpty.zipWith
                                                 Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip];

Control.Monad.Zip.$fMonadZipIdentity_$cmunzip
  :: forall a b.
     Data.Functor.Identity.Identity (a, b)
     -> (Data.Functor.Identity.Identity a,
         Data.Functor.Identity.Identity b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sdviP] ds_sdviP;

Control.Monad.Zip.$fMonadZipIdentity1
  :: forall b a c.
     (a -> b -> c)
     -> Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdviT m1_sdviU m2_sdviV] f_sdviT m1_sdviU m2_sdviV;

Control.Monad.Zip.$fMonadZipDual1
  :: forall b a c.
     (a -> b -> c)
     -> Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual b
     -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdviW m1_sdviX m2_sdviY] f_sdviW m1_sdviX m2_sdviY;

Control.Monad.Zip.$fMonadZipSum1
  :: forall b a c.
     (a -> b -> c)
     -> Data.Semigroup.Internal.Sum a
     -> Data.Semigroup.Internal.Sum b
     -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdviZ m1_sdvj0 m2_sdvj1] f_sdviZ m1_sdvj0 m2_sdvj1;

Control.Monad.Zip.$fMonadZipProduct1
  :: forall b a c.
     (a -> b -> c)
     -> Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product b
     -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdvj2 m1_sdvj3 m2_sdvj4] f_sdvj2 m1_sdvj3 m2_sdvj4;

Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdvj5 m1_sdvj6 m2_sdvj7]
        case m1_sdvj6 of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdvj9 [Occ=Once] ->
              case m2_sdvj7 of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdvjb [Occ=Once] ->
                    let {
                      sat_sdvjc [Occ=Once] :: c_adtcP
                      [LclId] =
                          [f_sdvj5 x_sdvj9 x1_sdvjb] \u [] f_sdvj5 x_sdvj9 x1_sdvjb;
                    } in  GHC.Base.Just [sat_sdvjc];
              };
        };

Control.Monad.Zip.$fMonadZipFirst1
  :: forall a b c.
     (a -> b -> c)
     -> Data.Monoid.First a -> Data.Monoid.First b -> GHC.Base.Maybe c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdvjd m1_sdvje m2_sdvjf]
        case m1_sdvje of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdvjh [Occ=Once] ->
              case m2_sdvjf of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdvjj [Occ=Once] ->
                    let {
                      sat_sdvjk [Occ=Once] :: c_adtcc
                      [LclId] =
                          [f_sdvjd x_sdvjh x1_sdvjj] \u [] f_sdvjd x_sdvjh x1_sdvjj;
                    } in  GHC.Base.Just [sat_sdvjk];
              };
        };

Control.Monad.Zip.$fMonadZipLast1
  :: forall a b c.
     (a -> b -> c)
     -> Data.Monoid.Last a -> Data.Monoid.Last b -> GHC.Base.Maybe c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdvjl m1_sdvjm m2_sdvjn]
        case m1_sdvjm of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdvjp [Occ=Once] ->
              case m2_sdvjn of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdvjr [Occ=Once] ->
                    let {
                      sat_sdvjs [Occ=Once] :: c_adtbz
                      [LclId] =
                          [f_sdvjl x_sdvjp x1_sdvjr] \u [] f_sdvjl x_sdvjp x1_sdvjr;
                    } in  GHC.Base.Just [sat_sdvjs];
              };
        };

Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     GHC.Base.Monad (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvjt]
        let {
          sat_sdvju [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Monad f_Xdtc6
          [LclId] =
              [$dMonadZip_sdvjt] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdvjt;
        } in  Data.Semigroup.Internal.$fMonadAlt sat_sdvju;

Control.Monad.Zip.$fMonadZipProxy_$cmzipWith
  :: forall a b c.
     (a -> b -> c)
     -> Data.Proxy.Proxy a -> Data.Proxy.Proxy b -> Data.Proxy.Proxy c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdvjv ds1_sdvjw ds2_sdvjx] Data.Proxy.Proxy [];

Control.Monad.Zip.$fMonadZipU1_$cmzipWith
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Generics.U1 a -> GHC.Generics.U1 b -> GHC.Generics.U1 c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdvjy ds1_sdvjz ds2_sdvjA] GHC.Generics.U1 [];

Control.Monad.Zip.$fMonadZipPar2
  :: forall b a c.
     (a -> b -> c) -> GHC.Generics.Par1 a -> GHC.Generics.Par1 b -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdvjB m1_sdvjC m2_sdvjD] f_sdvjB m1_sdvjC m2_sdvjD;

Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     GHC.Base.Monad (GHC.Generics.Rec1 f)
[GblId,
 Arity=1,
 Str=<L,1*U(1*U(U(1*U(1*U,1*U),U,1*U,1*U,1*U,1*U),C(C1(U)),A,A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvjE]
        let {
          sat_sdvjF [Occ=Once,
                     Dmd=<L,U(U(1*U(1*U,1*U),U,1*U,1*U,1*U,1*U),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_Xdt9S
          [LclId] =
              [$dMonadZip_sdvjE] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdvjE;
        } in  GHC.Generics.$fMonadRec1 sat_sdvjF;

Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     GHC.Base.Monad (GHC.Generics.M1 i c f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvjG]
        let {
          sat_sdvjH [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Monad f_Xdt9j
          [LclId] =
              [$dMonadZip_sdvjG] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdvjG;
        } in  GHC.Generics.$fMonadM1 sat_sdvjH;

Control.Monad.Zip.$fMonadZip:*:_$cmzipWith [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b c.
     (a -> b -> c)
     -> (GHC.Generics.:*:) f g a
     -> (GHC.Generics.:*:) f g b
     -> (GHC.Generics.:*:) f g c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A)><L,1*U(A,A,1*C1(C1(C1(U))),A)><L,U><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdvjI w1_sdvjJ w2_sdvjK w3_sdvjL w4_sdvjM]
        case w3_sdvjL of {
          GHC.Generics.:*: ww1_sdvjO [Occ=Once] ww2_sdvjP [Occ=Once] ->
              case w4_sdvjM of {
                GHC.Generics.:*: ww4_sdvjR [Occ=Once] ww5_sdvjS [Occ=Once] ->
                    let {
                      sat_sdvjU [Occ=Once] :: g_sdtv8 c_sdtvd
                      [LclId] =
                          [w1_sdvjJ w2_sdvjK ww2_sdvjP ww5_sdvjS] \u []
                              Control.Monad.Zip.mzipWith
                                  w1_sdvjJ w2_sdvjK ww2_sdvjP ww5_sdvjS; } in
                    let {
                      sat_sdvjT [Occ=Once] :: f_sdtv7 c_sdtvd
                      [LclId] =
                          [w_sdvjI w2_sdvjK ww1_sdvjO ww4_sdvjR] \u []
                              Control.Monad.Zip.mzipWith w_sdvjI w2_sdvjK ww1_sdvjO ww4_sdvjR;
                    } in  GHC.Generics.:*: [sat_sdvjT sat_sdvjU];
              };
        };

Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     GHC.Base.Monad (f GHC.Generics.:*: g)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvjV $dMonadZip1_sdvjW]
        let {
          sat_sdvjY [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_adt6u
          [LclId] =
              [$dMonadZip1_sdvjW] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip1_sdvjW; } in
        let {
          sat_sdvjX [Occ=Once,
                     Dmd=<L,U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_adt6t
          [LclId] =
              [$dMonadZip_sdvjV] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdvjV;
        } in  GHC.Generics.$fMonad:*: sat_sdvjX sat_sdvjY;

Control.Monad.Zip.$dmmunzip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b. m (a, b) -> (m a, m b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvjZ eta_sdvk0]
        let {
          $dMonad_sdvk1 [Dmd=<L,U(A,C(C1(U)),A,C(U),A)>]
            :: GHC.Base.Monad m_adt27
          [LclId] =
              [$dMonadZip_sdvjZ] \u []
                  Control.Monad.Zip.$p1MonadZip $dMonadZip_sdvjZ; } in
        let {
          sat_sdvkf [Occ=Once] :: m_adt27 b_adt6d
          [LclId] =
              [eta_sdvk0 $dMonad_sdvk1] \u []
                  let {
                    sat_sdvke [Occ=Once] :: (a_adt6c, b_adt6d) -> m_adt27 b_adt6d
                    [LclId] =
                        [$dMonad_sdvk1] \r [x1_sdvk9]
                            let {
                              sat_sdvkd [Occ=Once] :: b_adt6d
                              [LclId] =
                                  [x1_sdvk9] \u []
                                      case x1_sdvk9 of {
                                        (,) _ [Occ=Dead] y_sdvkc [Occ=Once] -> y_sdvkc;
                                      };
                            } in  GHC.Base.return $dMonad_sdvk1 sat_sdvkd;
                  } in  GHC.Base.>>= $dMonad_sdvk1 eta_sdvk0 sat_sdvke; } in
        let {
          sat_sdvk8 [Occ=Once] :: m_adt27 a_adt6c
          [LclId] =
              [eta_sdvk0 $dMonad_sdvk1] \u []
                  let {
                    sat_sdvk7 [Occ=Once] :: (a_adt6c, b_adt6d) -> m_adt27 a_adt6c
                    [LclId] =
                        [$dMonad_sdvk1] \r [x1_sdvk2]
                            let {
                              sat_sdvk6 [Occ=Once] :: a_adt6c
                              [LclId] =
                                  [x1_sdvk2] \u []
                                      case x1_sdvk2 of {
                                        (,) x_sdvk4 [Occ=Once] _ [Occ=Dead] -> x_sdvk4;
                                      };
                            } in  GHC.Base.return $dMonad_sdvk1 sat_sdvk6;
                  } in  GHC.Base.>>= $dMonad_sdvk1 eta_sdvk0 sat_sdvk7;
        } in  (,) [sat_sdvk8 sat_sdvkf];

Control.Monad.Zip.$dmmzipWith
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b c. (a -> b -> c) -> m a -> m b -> m c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S))LLL)LLL),U(1*U(A,1*C1(C1(U)),A,C(U),A),1*C1(C1(U)),A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvkg eta_sdvkh eta1_sdvki eta2_sdvkj]
        case
            Control.Monad.Zip.$p1MonadZip $dMonadZip_sdvkg
        of
        $dMonad_sdvkk [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
        { __DEFAULT ->
              let {
                sat_sdvkw [Occ=Once] :: (a_adt5U, b_adt5V) -> m_adt27 c_adt5W
                [LclId] =
                    [eta_sdvkh $dMonad_sdvkk] \r [x1_sdvkm]
                        let {
                          sat_sdvkv [Occ=Once] :: c_adt5W
                          [LclId] =
                              [eta_sdvkh x1_sdvkm] \u []
                                  let {
                                    sat_sdvku [Occ=Once] :: b_adt5V
                                    [LclId] =
                                        [x1_sdvkm] \u []
                                            case x1_sdvkm of {
                                              (,) _ [Occ=Dead] y_sdvkt [Occ=Once] -> y_sdvkt;
                                            }; } in
                                  let {
                                    sat_sdvkq [Occ=Once] :: a_adt5U
                                    [LclId] =
                                        [x1_sdvkm] \u []
                                            case x1_sdvkm of {
                                              (,) x_sdvko [Occ=Once] _ [Occ=Dead] -> x_sdvko;
                                            };
                                  } in  eta_sdvkh sat_sdvkq sat_sdvku;
                        } in  GHC.Base.return $dMonad_sdvkk sat_sdvkv; } in
              let {
                sat_sdvkl [Occ=Once] :: m_adt27 (a_adt5U, b_adt5V)
                [LclId] =
                    [$dMonadZip_sdvkg eta1_sdvki eta2_sdvkj] \u []
                        Control.Monad.Zip.mzip $dMonadZip_sdvkg eta1_sdvki eta2_sdvkj;
              } in  GHC.Base.>>= $dMonad_sdvkk sat_sdvkl sat_sdvkw;
        };

Control.Monad.Zip.$dmmzip
  :: forall (m :: * -> *).
     Control.Monad.Zip.MonadZip m =>
     forall a b. m a -> m b -> m (a, b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLC(S)L),1*U(A,A,1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvkx]
        Control.Monad.Zip.mzipWith $dMonadZip_sdvkx GHC.Tuple.(,);

Control.Monad.Zip.$fMonadZip:*:_$cmzip
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     (GHC.Generics.:*:) f g a
     -> (GHC.Generics.:*:) f g b -> (GHC.Generics.:*:) f g (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A)><L,1*U(A,A,1*C1(C1(C1(U))),A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvky $dMonadZip1_sdvkz w_sdvkA w1_sdvkB]
        case w_sdvkA of {
          GHC.Generics.:*: ww1_sdvkD [Occ=Once] ww2_sdvkE [Occ=Once] ->
              case w1_sdvkB of {
                GHC.Generics.:*: ww4_sdvkG [Occ=Once] ww5_sdvkH [Occ=Once] ->
                    let {
                      sat_sdvkJ [Occ=Once] :: g_adt6u (a_adt6E, b_adt6F)
                      [LclId] =
                          [$dMonadZip1_sdvkz ww2_sdvkE ww5_sdvkH] \u []
                              Control.Monad.Zip.mzipWith
                                  $dMonadZip1_sdvkz GHC.Tuple.(,) ww2_sdvkE ww5_sdvkH; } in
                    let {
                      sat_sdvkI [Occ=Once] :: f_adt6t (a_adt6E, b_adt6F)
                      [LclId] =
                          [$dMonadZip_sdvky ww1_sdvkD ww4_sdvkG] \u []
                              Control.Monad.Zip.mzipWith
                                  $dMonadZip_sdvky GHC.Tuple.(,) ww1_sdvkD ww4_sdvkG;
                    } in  GHC.Generics.:*: [sat_sdvkI sat_sdvkJ];
              };
        };

Control.Monad.Zip.$w$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     (GHC.Generics.:*:) f g (a, b)
     -> (# (GHC.Generics.:*:) f g a, (GHC.Generics.:*:) f g b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdvkK w1_sdvkL w2_sdvkM]
        let {
          $dMonad_sdvkN [Dmd=<L,U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad g_sdtvG
          [LclId] =
              [w1_sdvkL] \u [] Control.Monad.Zip.$p1MonadZip w1_sdvkL; } in
        let {
          lvl_sdvkO [Dmd=<L,U(A,C(U),A,A,A,A)>]
            :: GHC.Base.Applicative g_sdtvG
          [LclId] =
              [$dMonad_sdvkN] \u [] GHC.Base.$p1Monad $dMonad_sdvkN; } in
        let {
          $dMonad1_sdvkP [Dmd=<L,U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_sdtvF
          [LclId] =
              [w_sdvkK] \u [] Control.Monad.Zip.$p1MonadZip w_sdvkK; } in
        let {
          lvl1_sdvkQ [Dmd=<L,U(A,C(U),A,A,A,A)>]
            :: GHC.Base.Applicative f_sdtvF
          [LclId] =
              [$dMonad1_sdvkP] \u [] GHC.Base.$p1Monad $dMonad1_sdvkP; } in
        let {
          sat_sdvlq [Occ=Once] :: (GHC.Generics.:*:) f_sdtvF g_sdtvG b_sdtvK
          [LclId] =
              [w2_sdvkM $dMonad_sdvkN lvl_sdvkO $dMonad1_sdvkP lvl1_sdvkQ] \u []
                  case w2_sdvkM of {
                    GHC.Generics.:*: ww1_sdvla [Occ=Once] ww2_sdvlb [Occ=Once] ->
                        let {
                          sat_sdvlp [Occ=Once] :: g_sdtvG b_sdtvK
                          [LclId] =
                              [$dMonad_sdvkN lvl_sdvkO ww2_sdvlb] \u []
                                  let {
                                    sat_sdvlo [Occ=Once] :: (a_sdtvJ, b_sdtvK) -> g_sdtvG b_sdtvK
                                    [LclId] =
                                        [lvl_sdvkO] \r [a1_sdvlj]
                                            let {
                                              sat_sdvln [Occ=Once] :: b_sdtvK
                                              [LclId] =
                                                  [a1_sdvlj] \u []
                                                      case a1_sdvlj of {
                                                        (,) _ [Occ=Dead] y_sdvlm [Occ=Once] ->
                                                            y_sdvlm;
                                                      };
                                            } in  GHC.Base.pure lvl_sdvkO sat_sdvln;
                                  } in  GHC.Base.>>= $dMonad_sdvkN ww2_sdvlb sat_sdvlo; } in
                        let {
                          sat_sdvli [Occ=Once] :: f_sdtvF b_sdtvK
                          [LclId] =
                              [$dMonad1_sdvkP lvl1_sdvkQ ww1_sdvla] \u []
                                  let {
                                    sat_sdvlh [Occ=Once] :: (a_sdtvJ, b_sdtvK) -> f_sdtvF b_sdtvK
                                    [LclId] =
                                        [lvl1_sdvkQ] \r [a1_sdvlc]
                                            let {
                                              sat_sdvlg [Occ=Once] :: b_sdtvK
                                              [LclId] =
                                                  [a1_sdvlc] \u []
                                                      case a1_sdvlc of {
                                                        (,) _ [Occ=Dead] y_sdvlf [Occ=Once] ->
                                                            y_sdvlf;
                                                      };
                                            } in  GHC.Base.pure lvl1_sdvkQ sat_sdvlg;
                                  } in  GHC.Base.>>= $dMonad1_sdvkP ww1_sdvla sat_sdvlh;
                        } in  GHC.Generics.:*: [sat_sdvli sat_sdvlp];
                  }; } in
        let {
          sat_sdvl8 [Occ=Once] :: (GHC.Generics.:*:) f_sdtvF g_sdtvG a_sdtvJ
          [LclId] =
              [w2_sdvkM $dMonad_sdvkN lvl_sdvkO $dMonad1_sdvkP lvl1_sdvkQ] \u []
                  case w2_sdvkM of {
                    GHC.Generics.:*: ww1_sdvkS [Occ=Once] ww2_sdvkT [Occ=Once] ->
                        let {
                          sat_sdvl7 [Occ=Once] :: g_sdtvG a_sdtvJ
                          [LclId] =
                              [$dMonad_sdvkN lvl_sdvkO ww2_sdvkT] \u []
                                  let {
                                    sat_sdvl6 [Occ=Once] :: (a_sdtvJ, b_sdtvK) -> g_sdtvG a_sdtvJ
                                    [LclId] =
                                        [lvl_sdvkO] \r [a1_sdvl1]
                                            let {
                                              sat_sdvl5 [Occ=Once] :: a_sdtvJ
                                              [LclId] =
                                                  [a1_sdvl1] \u []
                                                      case a1_sdvl1 of {
                                                        (,) x_sdvl3 [Occ=Once] _ [Occ=Dead] ->
                                                            x_sdvl3;
                                                      };
                                            } in  GHC.Base.pure lvl_sdvkO sat_sdvl5;
                                  } in  GHC.Base.>>= $dMonad_sdvkN ww2_sdvkT sat_sdvl6; } in
                        let {
                          sat_sdvl0 [Occ=Once] :: f_sdtvF a_sdtvJ
                          [LclId] =
                              [$dMonad1_sdvkP lvl1_sdvkQ ww1_sdvkS] \u []
                                  let {
                                    sat_sdvkZ [Occ=Once] :: (a_sdtvJ, b_sdtvK) -> f_sdtvF a_sdtvJ
                                    [LclId] =
                                        [lvl1_sdvkQ] \r [a1_sdvkU]
                                            let {
                                              sat_sdvkY [Occ=Once] :: a_sdtvJ
                                              [LclId] =
                                                  [a1_sdvkU] \u []
                                                      case a1_sdvkU of {
                                                        (,) x_sdvkW [Occ=Once] _ [Occ=Dead] ->
                                                            x_sdvkW;
                                                      };
                                            } in  GHC.Base.pure lvl1_sdvkQ sat_sdvkY;
                                  } in  GHC.Base.>>= $dMonad1_sdvkP ww1_sdvkS sat_sdvkZ;
                        } in  GHC.Generics.:*: [sat_sdvl0 sat_sdvl7];
                  };
        } in  (#,#) [sat_sdvl8 sat_sdvlq];

Control.Monad.Zip.$fMonadZip:*:_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     forall a b.
     (GHC.Generics.:*:) f g (a, b)
     -> ((GHC.Generics.:*:) f g a, (GHC.Generics.:*:) f g b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,1*U(1*U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdvlr w1_sdvls w2_sdvlt]
        case Control.Monad.Zip.$w$cmunzip w_sdvlr w1_sdvls w2_sdvlt of {
          (#,#) ww1_sdvlv [Occ=Once] ww2_sdvlw [Occ=Once] ->
              (,) [ww1_sdvlv ww2_sdvlw];
        };

Control.Monad.Zip.$fMonadZip:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) =>
     Control.Monad.Zip.MonadZip (f GHC.Generics.:*: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)><L,U(U(U(U(C(C1(U)),C(C1(U))),C(U),C(C1(U)),C(C1(C1(U))),A,A),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sdvlx $dMonadZip1_sdvly]
        let {
          sat_sdvlC [Occ=Once]
            :: forall a b.
               (GHC.Generics.:*:) f_adt6t g_adt6u (a, b)
               -> ((GHC.Generics.:*:) f_adt6t g_adt6u a,
                   (GHC.Generics.:*:) f_adt6t g_adt6u b)
          [LclId] =
              [$dMonadZip_sdvlx $dMonadZip1_sdvly] \r [eta_B1]
                  Control.Monad.Zip.$fMonadZip:*:_$cmunzip
                      $dMonadZip_sdvlx $dMonadZip1_sdvly eta_B1; } in
        let {
          sat_sdvlB [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> (GHC.Generics.:*:) f_adt6t g_adt6u a
               -> (GHC.Generics.:*:) f_adt6t g_adt6u b
               -> (GHC.Generics.:*:) f_adt6t g_adt6u c
          [LclId] =
              [$dMonadZip_sdvlx $dMonadZip1_sdvly] \r [eta_B3 eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZip:*:_$cmzipWith
                      $dMonadZip_sdvlx $dMonadZip1_sdvly eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdvlA [Occ=Once]
            :: forall a b.
               (GHC.Generics.:*:) f_adt6t g_adt6u a
               -> (GHC.Generics.:*:) f_adt6t g_adt6u b
               -> (GHC.Generics.:*:) f_adt6t g_adt6u (a, b)
          [LclId] =
              [$dMonadZip_sdvlx $dMonadZip1_sdvly] \r [eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZip:*:_$cmzip
                      $dMonadZip_sdvlx $dMonadZip1_sdvly eta_B2 eta_B1; } in
        let {
          sat_sdvlz [Occ=Once]
            :: GHC.Base.Monad (f_adt6t GHC.Generics.:*: g_adt6u)
          [LclId] =
              [$dMonadZip_sdvlx $dMonadZip1_sdvly] \u []
                  Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip
                      $dMonadZip_sdvlx $dMonadZip1_sdvly;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sdvlz
                                        sat_sdvlA
                                        sat_sdvlB
                                        sat_sdvlC];

Control.Monad.Zip.$fMonadZipM2
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.M1 i c f a -> GHC.Generics.M1 i c f b -> f (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvlD ds_sdvlE ds1_sdvlF]
        Control.Monad.Zip.mzipWith
            $dMonadZip_sdvlD GHC.Tuple.(,) ds_sdvlE ds1_sdvlF;

Control.Monad.Zip.$w$cmunzip2 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.M1 i c f (a, b)
     -> (# GHC.Generics.M1 i c f a, GHC.Generics.M1 i c f b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdvlG w1_sdvlH]
        let {
          $dMonad_sdvlI [Dmd=<L,U(A,C(C1(U)),A,C(U),A)>]
            :: GHC.Base.Monad f_sdtvQ
          [LclId] =
              [w_sdvlG] \u [] Control.Monad.Zip.$p1MonadZip w_sdvlG; } in
        let {
          sat_sdvlW [Occ=Once]
            :: GHC.Generics.M1 i_sdtvR c_sdtvS f_sdtvQ b_sdtvV
          [LclId] =
              [w1_sdvlH $dMonad_sdvlI] \u []
                  let {
                    sat_sdvlV [Occ=Once] :: (a_sdtvU, b_sdtvV) -> f_sdtvQ b_sdtvV
                    [LclId] =
                        [$dMonad_sdvlI] \r [x1_sdvlQ]
                            let {
                              sat_sdvlU [Occ=Once] :: b_sdtvV
                              [LclId] =
                                  [x1_sdvlQ] \u []
                                      case x1_sdvlQ of {
                                        (,) _ [Occ=Dead] y_sdvlT [Occ=Once] -> y_sdvlT;
                                      };
                            } in  GHC.Base.return $dMonad_sdvlI sat_sdvlU;
                  } in  GHC.Base.>>= $dMonad_sdvlI w1_sdvlH sat_sdvlV; } in
        let {
          sat_sdvlP [Occ=Once]
            :: GHC.Generics.M1 i_sdtvR c_sdtvS f_sdtvQ a_sdtvU
          [LclId] =
              [w1_sdvlH $dMonad_sdvlI] \u []
                  let {
                    sat_sdvlO [Occ=Once] :: (a_sdtvU, b_sdtvV) -> f_sdtvQ a_sdtvU
                    [LclId] =
                        [$dMonad_sdvlI] \r [x1_sdvlJ]
                            let {
                              sat_sdvlN [Occ=Once] :: a_sdtvU
                              [LclId] =
                                  [x1_sdvlJ] \u []
                                      case x1_sdvlJ of {
                                        (,) x_sdvlL [Occ=Once] _ [Occ=Dead] -> x_sdvlL;
                                      };
                            } in  GHC.Base.return $dMonad_sdvlI sat_sdvlN;
                  } in  GHC.Base.>>= $dMonad_sdvlI w1_sdvlH sat_sdvlO;
        } in  (#,#) [sat_sdvlP sat_sdvlW];

Control.Monad.Zip.$fMonadZipM1_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.M1 i c f (a, b)
     -> (GHC.Generics.M1 i c f a, GHC.Generics.M1 i c f b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdvlX w1_sdvlY]
        case Control.Monad.Zip.$w$cmunzip2 w_sdvlX w1_sdvlY of {
          (#,#) ww1_sdvm0 [Occ=Once] ww2_sdvm1 [Occ=Once] ->
              (,) [ww1_sdvm0 ww2_sdvm1];
        };

Control.Monad.Zip.$fMonadZipM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Control.Monad.Zip.MonadZip f =>
     Control.Monad.Zip.MonadZip (GHC.Generics.M1 i c f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),U,1*U,U,1*U),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sdvm2]
        let {
          sat_sdvm9 [Occ=Once]
            :: forall a b.
               GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s (a, b)
               -> (GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s a,
                   GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s b)
          [LclId] =
              [$dMonadZip_sdvm2] \r [eta_B1]
                  Control.Monad.Zip.$fMonadZipM1_$cmunzip
                      $dMonadZip_sdvm2 eta_B1; } in
        let {
          sat_sdvm8 [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s a
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s b
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s c
          [LclId] =
              [$dMonadZip_sdvm2] \r [f1_sdvm5 ds_sdvm6 ds1_sdvm7]
                  Control.Monad.Zip.mzipWith
                      $dMonadZip_sdvm2 f1_sdvm5 ds_sdvm6 ds1_sdvm7; } in
        let {
          sat_sdvm4 [Occ=Once]
            :: forall a b.
               GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s a
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s b
               -> GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s (a, b)
          [LclId] =
              [$dMonadZip_sdvm2] \r [eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZipM2 $dMonadZip_sdvm2 eta_B2 eta_B1; } in
        let {
          sat_sdvm3 [Occ=Once]
            :: GHC.Base.Monad (GHC.Generics.M1 i_Xdt9u c_Xdt9w f_Xdt9s)
          [LclId] =
              [$dMonadZip_sdvm2] \u []
                  Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip $dMonadZip_sdvm2;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sdvm3
                                        sat_sdvm4
                                        sat_sdvm8
                                        sat_sdvm9];

Control.Monad.Zip.$fMonadZipRec2
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.Rec1 f a -> GHC.Generics.Rec1 f b -> f (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvma ds_sdvmb ds1_sdvmc]
        Control.Monad.Zip.mzipWith
            $dMonadZip_sdvma GHC.Tuple.(,) ds_sdvmb ds1_sdvmc;

Control.Monad.Zip.$w$cmunzip4 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.Rec1 f (a, b)
     -> (# GHC.Generics.Rec1 f a, GHC.Generics.Rec1 f b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdvmd w1_sdvme]
        let {
          $dMonad_sdvmf [Dmd=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A)>]
            :: GHC.Base.Monad f_sdtw1
          [LclId] =
              [w_sdvmd] \u [] Control.Monad.Zip.$p1MonadZip w_sdvmd; } in
        let {
          sat_sdvmv [Occ=Once] :: GHC.Generics.Rec1 f_sdtw1 b_sdtw4
          [LclId] =
              [w1_sdvme $dMonad_sdvmf] \u []
                  let {
                    lvl_sdvmo [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                      :: GHC.Base.Applicative f_sdtw1
                    [LclId] =
                        [$dMonad_sdvmf] \u [] GHC.Base.$p1Monad $dMonad_sdvmf; } in
                  let {
                    sat_sdvmu [Occ=Once] :: (a_sdtw3, b_sdtw4) -> f_sdtw1 b_sdtw4
                    [LclId] =
                        [lvl_sdvmo] \r [a1_sdvmp]
                            let {
                              sat_sdvmt [Occ=Once] :: b_sdtw4
                              [LclId] =
                                  [a1_sdvmp] \u []
                                      case a1_sdvmp of {
                                        (,) _ [Occ=Dead] y_sdvms [Occ=Once] -> y_sdvms;
                                      };
                            } in  GHC.Base.pure lvl_sdvmo sat_sdvmt;
                  } in  GHC.Base.>>= $dMonad_sdvmf w1_sdvme sat_sdvmu; } in
        let {
          sat_sdvmn [Occ=Once] :: GHC.Generics.Rec1 f_sdtw1 a_sdtw3
          [LclId] =
              [w1_sdvme $dMonad_sdvmf] \u []
                  let {
                    lvl_sdvmg [Occ=OnceL, Dmd=<L,U(A,C(U),A,A,A,A)>]
                      :: GHC.Base.Applicative f_sdtw1
                    [LclId] =
                        [$dMonad_sdvmf] \u [] GHC.Base.$p1Monad $dMonad_sdvmf; } in
                  let {
                    sat_sdvmm [Occ=Once] :: (a_sdtw3, b_sdtw4) -> f_sdtw1 a_sdtw3
                    [LclId] =
                        [lvl_sdvmg] \r [a1_sdvmh]
                            let {
                              sat_sdvml [Occ=Once] :: a_sdtw3
                              [LclId] =
                                  [a1_sdvmh] \u []
                                      case a1_sdvmh of {
                                        (,) x_sdvmj [Occ=Once] _ [Occ=Dead] -> x_sdvmj;
                                      };
                            } in  GHC.Base.pure lvl_sdvmg sat_sdvml;
                  } in  GHC.Base.>>= $dMonad_sdvmf w1_sdvme sat_sdvmm;
        } in  (#,#) [sat_sdvmn sat_sdvmv];

Control.Monad.Zip.$fMonadZipRec1_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     GHC.Generics.Rec1 f (a, b)
     -> (GHC.Generics.Rec1 f a, GHC.Generics.Rec1 f b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdvmw w1_sdvmx]
        case Control.Monad.Zip.$w$cmunzip4 w_sdvmw w1_sdvmx of {
          (#,#) ww1_sdvmz [Occ=Once] ww2_sdvmA [Occ=Once] ->
              (,) [ww1_sdvmz ww2_sdvmA];
        };

Control.Monad.Zip.$fMonadZipRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     Control.Monad.Zip.MonadZip (GHC.Generics.Rec1 f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(1*U(1*U,1*U),U,1*U,1*U,1*U,1*U),C(C1(U)),A,A,A),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sdvmB]
        let {
          sat_sdvmI [Occ=Once]
            :: forall a b.
               GHC.Generics.Rec1 f_Xdtao (a, b)
               -> (GHC.Generics.Rec1 f_Xdtao a, GHC.Generics.Rec1 f_Xdtao b)
          [LclId] =
              [$dMonadZip_sdvmB] \r [eta_B1]
                  Control.Monad.Zip.$fMonadZipRec1_$cmunzip
                      $dMonadZip_sdvmB eta_B1; } in
        let {
          sat_sdvmH [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> GHC.Generics.Rec1 f_Xdtao a
               -> GHC.Generics.Rec1 f_Xdtao b
               -> GHC.Generics.Rec1 f_Xdtao c
          [LclId] =
              [$dMonadZip_sdvmB] \r [f1_sdvmE ds_sdvmF ds1_sdvmG]
                  Control.Monad.Zip.mzipWith
                      $dMonadZip_sdvmB f1_sdvmE ds_sdvmF ds1_sdvmG; } in
        let {
          sat_sdvmD [Occ=Once]
            :: forall a b.
               GHC.Generics.Rec1 f_Xdtao a
               -> GHC.Generics.Rec1 f_Xdtao b -> GHC.Generics.Rec1 f_Xdtao (a, b)
          [LclId] =
              [$dMonadZip_sdvmB] \r [eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZipRec2
                      $dMonadZip_sdvmB eta_B2 eta_B1; } in
        let {
          sat_sdvmC [Occ=Once] :: GHC.Base.Monad (GHC.Generics.Rec1 f_Xdtao)
          [LclId] =
              [$dMonadZip_sdvmB] \u []
                  Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip $dMonadZip_sdvmB;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sdvmC
                                        sat_sdvmD
                                        sat_sdvmH
                                        sat_sdvmI];

Control.Monad.Zip.$fMonadZipPar1_$cmunzip
  :: forall a b.
     GHC.Generics.Par1 (a, b)
     -> (GHC.Generics.Par1 a, GHC.Generics.Par1 b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [mab_sdvmJ]
        let {
          sat_sdvmR [Occ=Once] :: GHC.Generics.Par1 b_adt9i
          [LclId] =
              [mab_sdvmJ] \u []
                  case mab_sdvmJ of {
                    (,) _ [Occ=Dead] y_sdvmQ [Occ=Once] -> y_sdvmQ;
                  }; } in
        let {
          sat_sdvmN [Occ=Once] :: GHC.Generics.Par1 a_adt9h
          [LclId] =
              [mab_sdvmJ] \u []
                  case mab_sdvmJ of {
                    (,) x_sdvmL [Occ=Once] _ [Occ=Dead] -> x_sdvmL;
                  };
        } in  (,) [sat_sdvmN sat_sdvmR];

Control.Monad.Zip.$fMonadZipPar1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip GHC.Generics.Par1
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Generics.$fMonadPar1
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipPar2
                                                 Control.Monad.Zip.$fMonadZipPar1_$cmunzip];

Control.Monad.Zip.$fMonadZipU1_$cmzip
  :: forall a b.
     GHC.Generics.U1 a -> GHC.Generics.U1 b -> GHC.Generics.U1 (a, b)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdvmS ds1_sdvmT] GHC.Generics.U1 [];

Control.Monad.Zip.$fMonadZipU2
  :: forall b a. (GHC.Generics.U1 a, GHC.Generics.U1 b)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Generics.U1 GHC.Generics.U1];

Control.Monad.Zip.$fMonadZipU1_$cmunzip
  :: forall a b.
     GHC.Generics.U1 (a, b) -> (GHC.Generics.U1 a, GHC.Generics.U1 b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [mab_sdvmU] Control.Monad.Zip.$fMonadZipU2;

Control.Monad.Zip.$fMonadZipU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip GHC.Generics.U1
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Generics.$fMonadU1
                                                 Control.Monad.Zip.$fMonadZipU1_$cmzip
                                                 Control.Monad.Zip.$fMonadZipU1_$cmzipWith
                                                 Control.Monad.Zip.$fMonadZipU1_$cmunzip];

Control.Monad.Zip.$fMonadZipProxy_$cmzip
  :: forall a b.
     Data.Proxy.Proxy a -> Data.Proxy.Proxy b -> Data.Proxy.Proxy (a, b)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdvmV ds1_sdvmW] Data.Proxy.Proxy [];

Control.Monad.Zip.$fMonadZipProxy1
  :: forall b a. (Data.Proxy.Proxy a, Data.Proxy.Proxy b)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Proxy.Proxy Data.Proxy.Proxy];

Control.Monad.Zip.$fMonadZipProxy_$cmunzip
  :: forall a b.
     Data.Proxy.Proxy (a, b) -> (Data.Proxy.Proxy a, Data.Proxy.Proxy b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [mab_sdvmX] Control.Monad.Zip.$fMonadZipProxy1;

Control.Monad.Zip.$fMonadZipProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Proxy.Proxy
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Proxy.$fMonadProxy
                                                 Control.Monad.Zip.$fMonadZipProxy_$cmzip
                                                 Control.Monad.Zip.$fMonadZipProxy_$cmzipWith
                                                 Control.Monad.Zip.$fMonadZipProxy_$cmunzip];

Control.Monad.Zip.$fMonadZipAlt1
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     Data.Semigroup.Internal.Alt f a
     -> Data.Semigroup.Internal.Alt f b -> f (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadZip_sdvmY ds_sdvmZ ds1_sdvn0]
        Control.Monad.Zip.mzipWith
            $dMonadZip_sdvmY GHC.Tuple.(,) ds_sdvmZ ds1_sdvn0;

Control.Monad.Zip.$w$cmunzip1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     Data.Semigroup.Internal.Alt f (a, b)
     -> (# Data.Semigroup.Internal.Alt f a,
           Data.Semigroup.Internal.Alt f b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdvn1 w1_sdvn2]
        let {
          $dMonad_sdvn3 [Dmd=<L,U(A,C(C1(U)),A,C(U),A)>]
            :: GHC.Base.Monad f_sdtwa
          [LclId] =
              [w_sdvn1] \u [] Control.Monad.Zip.$p1MonadZip w_sdvn1; } in
        let {
          sat_sdvnh [Occ=Once] :: Data.Semigroup.Internal.Alt f_sdtwa b_sdtwd
          [LclId] =
              [w1_sdvn2 $dMonad_sdvn3] \u []
                  let {
                    sat_sdvng [Occ=Once] :: (a_sdtwc, b_sdtwd) -> f_sdtwa b_sdtwd
                    [LclId] =
                        [$dMonad_sdvn3] \r [x1_sdvnb]
                            let {
                              sat_sdvnf [Occ=Once] :: b_sdtwd
                              [LclId] =
                                  [x1_sdvnb] \u []
                                      case x1_sdvnb of {
                                        (,) _ [Occ=Dead] y_sdvne [Occ=Once] -> y_sdvne;
                                      };
                            } in  GHC.Base.return $dMonad_sdvn3 sat_sdvnf;
                  } in  GHC.Base.>>= $dMonad_sdvn3 w1_sdvn2 sat_sdvng; } in
        let {
          sat_sdvna [Occ=Once] :: Data.Semigroup.Internal.Alt f_sdtwa a_sdtwc
          [LclId] =
              [w1_sdvn2 $dMonad_sdvn3] \u []
                  let {
                    sat_sdvn9 [Occ=Once] :: (a_sdtwc, b_sdtwd) -> f_sdtwa a_sdtwc
                    [LclId] =
                        [$dMonad_sdvn3] \r [x1_sdvn4]
                            let {
                              sat_sdvn8 [Occ=Once] :: a_sdtwc
                              [LclId] =
                                  [x1_sdvn4] \u []
                                      case x1_sdvn4 of {
                                        (,) x_sdvn6 [Occ=Once] _ [Occ=Dead] -> x_sdvn6;
                                      };
                            } in  GHC.Base.return $dMonad_sdvn3 sat_sdvn8;
                  } in  GHC.Base.>>= $dMonad_sdvn3 w1_sdvn2 sat_sdvn9;
        } in  (#,#) [sat_sdvna sat_sdvnh];

Control.Monad.Zip.$fMonadZipAlt_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     forall a b.
     Data.Semigroup.Internal.Alt f (a, b)
     -> (Data.Semigroup.Internal.Alt f a,
         Data.Semigroup.Internal.Alt f b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,C(C1(U)),A,C(U),A),A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdvni w1_sdvnj]
        case Control.Monad.Zip.$w$cmunzip1 w_sdvni w1_sdvnj of {
          (#,#) ww1_sdvnl [Occ=Once] ww2_sdvnm [Occ=Once] ->
              (,) [ww1_sdvnl ww2_sdvnm];
        };

Control.Monad.Zip.$fMonadZipAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Control.Monad.Zip.MonadZip f =>
     Control.Monad.Zip.MonadZip (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),U,1*U,U,1*U),A,C(C1(C1(U))),A)>m] =
    [] \r [$dMonadZip_sdvnn]
        let {
          sat_sdvnu [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_Xdtd8 (a, b)
               -> (Data.Semigroup.Internal.Alt f_Xdtd8 a,
                   Data.Semigroup.Internal.Alt f_Xdtd8 b)
          [LclId] =
              [$dMonadZip_sdvnn] \r [eta_B1]
                  Control.Monad.Zip.$fMonadZipAlt_$cmunzip
                      $dMonadZip_sdvnn eta_B1; } in
        let {
          sat_sdvnt [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Semigroup.Internal.Alt f_Xdtd8 a
               -> Data.Semigroup.Internal.Alt f_Xdtd8 b
               -> Data.Semigroup.Internal.Alt f_Xdtd8 c
          [LclId] =
              [$dMonadZip_sdvnn] \r [f1_sdvnq ds_sdvnr ds1_sdvns]
                  Control.Monad.Zip.mzipWith
                      $dMonadZip_sdvnn f1_sdvnq ds_sdvnr ds1_sdvns; } in
        let {
          sat_sdvnp [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_Xdtd8 a
               -> Data.Semigroup.Internal.Alt f_Xdtd8 b
               -> Data.Semigroup.Internal.Alt f_Xdtd8 (a, b)
          [LclId] =
              [$dMonadZip_sdvnn] \r [eta_B2 eta_B1]
                  Control.Monad.Zip.$fMonadZipAlt1
                      $dMonadZip_sdvnn eta_B2 eta_B1; } in
        let {
          sat_sdvno [Occ=Once]
            :: GHC.Base.Monad (Data.Semigroup.Internal.Alt f_Xdtd8)
          [LclId] =
              [$dMonadZip_sdvnn] \u []
                  Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip $dMonadZip_sdvnn;
        } in 
          Control.Monad.Zip.C:MonadZip [sat_sdvno
                                        sat_sdvnp
                                        sat_sdvnt
                                        sat_sdvnu];

Control.Monad.Zip.$fMonadZipLast2
  :: forall b a.
     Data.Monoid.Last a -> Data.Monoid.Last b -> GHC.Base.Maybe (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [m1_sdvnv m2_sdvnw]
        case m1_sdvnv of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdvny [Occ=Once] ->
              case m2_sdvnw of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdvnA [Occ=Once] ->
                    let {
                      sat_sdvnB [Occ=Once] :: (a_adtbn, b_adtbo)
                      [LclId] =
                          CCCS (,)! [x_sdvny x1_sdvnA];
                    } in  GHC.Base.Just [sat_sdvnB];
              };
        };

Control.Monad.Zip.$fMonadZipLast_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Data.Monoid.Last (a, b) -> (Data.Monoid.Last a, Data.Monoid.Last b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [w_sdvnC]
        let {
          sat_sdvnQ [Occ=Once] :: Data.Monoid.Last b_sdtwk
          [LclId] =
              [w_sdvnC] \u []
                  case w_sdvnC of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdvnL [Occ=Once!] ->
                        let {
                          sat_sdvnP [Occ=Once] :: b_sdtwk
                          [LclId] =
                              [x_sdvnL] \u []
                                  case x_sdvnL of {
                                    (,) _ [Occ=Dead] y_sdvnO [Occ=Once] -> y_sdvnO;
                                  };
                        } in  GHC.Base.Just [sat_sdvnP];
                  }; } in
        let {
          sat_sdvnJ [Occ=Once] :: Data.Monoid.Last a_sdtwj
          [LclId] =
              [w_sdvnC] \u []
                  case w_sdvnC of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdvnE [Occ=Once!] ->
                        let {
                          sat_sdvnI [Occ=Once] :: a_sdtwj
                          [LclId] =
                              [x_sdvnE] \u []
                                  case x_sdvnE of {
                                    (,) x1_sdvnG [Occ=Once] _ [Occ=Dead] -> x1_sdvnG;
                                  };
                        } in  GHC.Base.Just [sat_sdvnI];
                  };
        } in  (,) [sat_sdvnJ sat_sdvnQ];

Control.Monad.Zip.$fMonadZipLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Monoid.Last
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Monoid.$fMonadLast
                                                 Control.Monad.Zip.$fMonadZipLast2
                                                 Control.Monad.Zip.$fMonadZipLast1
                                                 Control.Monad.Zip.$fMonadZipLast_$cmunzip];

Control.Monad.Zip.$fMonadZipFirst2
  :: forall b a.
     Data.Monoid.First a -> Data.Monoid.First b -> GHC.Base.Maybe (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [m1_sdvnR m2_sdvnS]
        case m1_sdvnR of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdvnU [Occ=Once] ->
              case m2_sdvnS of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdvnW [Occ=Once] ->
                    let {
                      sat_sdvnX [Occ=Once] :: (a_adtc0, b_adtc1)
                      [LclId] =
                          CCCS (,)! [x_sdvnU x1_sdvnW];
                    } in  GHC.Base.Just [sat_sdvnX];
              };
        };

Control.Monad.Zip.$fMonadZipFirst_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Data.Monoid.First (a, b)
     -> (Data.Monoid.First a, Data.Monoid.First b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [w_sdvnY]
        let {
          sat_sdvoc [Occ=Once] :: Data.Monoid.First b_sdtwr
          [LclId] =
              [w_sdvnY] \u []
                  case w_sdvnY of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdvo7 [Occ=Once!] ->
                        let {
                          sat_sdvob [Occ=Once] :: b_sdtwr
                          [LclId] =
                              [x_sdvo7] \u []
                                  case x_sdvo7 of {
                                    (,) _ [Occ=Dead] y_sdvoa [Occ=Once] -> y_sdvoa;
                                  };
                        } in  GHC.Base.Just [sat_sdvob];
                  }; } in
        let {
          sat_sdvo5 [Occ=Once] :: Data.Monoid.First a_sdtwq
          [LclId] =
              [w_sdvnY] \u []
                  case w_sdvnY of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdvo0 [Occ=Once!] ->
                        let {
                          sat_sdvo4 [Occ=Once] :: a_sdtwq
                          [LclId] =
                              [x_sdvo0] \u []
                                  case x_sdvo0 of {
                                    (,) x1_sdvo2 [Occ=Once] _ [Occ=Dead] -> x1_sdvo2;
                                  };
                        } in  GHC.Base.Just [sat_sdvo4];
                  };
        } in  (,) [sat_sdvo5 sat_sdvoc];

Control.Monad.Zip.$fMonadZipFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Monoid.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Monoid.$fMonadFirst
                                                 Control.Monad.Zip.$fMonadZipFirst2
                                                 Control.Monad.Zip.$fMonadZipFirst1
                                                 Control.Monad.Zip.$fMonadZipFirst_$cmunzip];

Control.Monad.Zip.$fMonadZipMaybe_$cmzip
  :: forall a b.
     GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [m1_sdvod m2_sdvoe]
        case m1_sdvod of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sdvog [Occ=Once] ->
              case m2_sdvoe of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sdvoi [Occ=Once] ->
                    let {
                      sat_sdvoj [Occ=Once] :: (a_adtcD, b_adtcE)
                      [LclId] =
                          CCCS (,)! [x_sdvog x1_sdvoi];
                    } in  GHC.Base.Just [sat_sdvoj];
              };
        };

Control.Monad.Zip.$fMonadZipMaybe_$cmunzip [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.Maybe (a, b) -> (GHC.Base.Maybe a, GHC.Base.Maybe b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [w_sdvok]
        let {
          sat_sdvoy [Occ=Once] :: GHC.Base.Maybe b_sdtwy
          [LclId] =
              [w_sdvok] \u []
                  case w_sdvok of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdvot [Occ=Once!] ->
                        let {
                          sat_sdvox [Occ=Once] :: b_sdtwy
                          [LclId] =
                              [x_sdvot] \u []
                                  case x_sdvot of {
                                    (,) _ [Occ=Dead] y_sdvow [Occ=Once] -> y_sdvow;
                                  };
                        } in  GHC.Base.Just [sat_sdvox];
                  }; } in
        let {
          sat_sdvor [Occ=Once] :: GHC.Base.Maybe a_sdtwx
          [LclId] =
              [w_sdvok] \u []
                  case w_sdvok of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sdvom [Occ=Once!] ->
                        let {
                          sat_sdvoq [Occ=Once] :: a_sdtwx
                          [LclId] =
                              [x_sdvom] \u []
                                  case x_sdvom of {
                                    (,) x1_sdvoo [Occ=Once] _ [Occ=Dead] -> x1_sdvoo;
                                  };
                        } in  GHC.Base.Just [sat_sdvoq];
                  };
        } in  (,) [sat_sdvor sat_sdvoy];

Control.Monad.Zip.$fMonadZipMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [GHC.Base.$fMonadMaybe
                                                 Control.Monad.Zip.$fMonadZipMaybe_$cmzip
                                                 Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith
                                                 Control.Monad.Zip.$fMonadZipMaybe_$cmunzip];

Control.Monad.Zip.$fMonadZipProduct_$cmunzip
  :: forall a b.
     Data.Semigroup.Internal.Product (a, b)
     -> (Data.Semigroup.Internal.Product a,
         Data.Semigroup.Internal.Product b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [mab_sdvoz]
        let {
          sat_sdvoH [Occ=Once] :: Data.Semigroup.Internal.Product b_adtdE
          [LclId] =
              [mab_sdvoz] \u []
                  case mab_sdvoz of {
                    (,) _ [Occ=Dead] y_sdvoG [Occ=Once] -> y_sdvoG;
                  }; } in
        let {
          sat_sdvoD [Occ=Once] :: Data.Semigroup.Internal.Product a_adtdD
          [LclId] =
              [mab_sdvoz] \u []
                  case mab_sdvoz of {
                    (,) x_sdvoB [Occ=Once] _ [Occ=Dead] -> x_sdvoB;
                  };
        } in  (,) [sat_sdvoD sat_sdvoH];

Control.Monad.Zip.$fMonadZipProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Semigroup.Internal.$fMonadProduct
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipProduct1
                                                 Control.Monad.Zip.$fMonadZipProduct_$cmunzip];

Control.Monad.Zip.$fMonadZipSum_$cmunzip
  :: forall a b.
     Data.Semigroup.Internal.Sum (a, b)
     -> (Data.Semigroup.Internal.Sum a, Data.Semigroup.Internal.Sum b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [mab_sdvoI]
        let {
          sat_sdvoQ [Occ=Once] :: Data.Semigroup.Internal.Sum b_adteh
          [LclId] =
              [mab_sdvoI] \u []
                  case mab_sdvoI of {
                    (,) _ [Occ=Dead] y_sdvoP [Occ=Once] -> y_sdvoP;
                  }; } in
        let {
          sat_sdvoM [Occ=Once] :: Data.Semigroup.Internal.Sum a_adteg
          [LclId] =
              [mab_sdvoI] \u []
                  case mab_sdvoI of {
                    (,) x_sdvoK [Occ=Once] _ [Occ=Dead] -> x_sdvoK;
                  };
        } in  (,) [sat_sdvoM sat_sdvoQ];

Control.Monad.Zip.$fMonadZipSum [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Semigroup.Internal.$fMonadSum
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipSum1
                                                 Control.Monad.Zip.$fMonadZipSum_$cmunzip];

Control.Monad.Zip.$fMonadZipDual_$cmunzip
  :: forall a b.
     Data.Semigroup.Internal.Dual (a, b)
     -> (Data.Semigroup.Internal.Dual a, Data.Semigroup.Internal.Dual b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [mab_sdvoR]
        let {
          sat_sdvoZ [Occ=Once] :: Data.Semigroup.Internal.Dual b_adteU
          [LclId] =
              [mab_sdvoR] \u []
                  case mab_sdvoR of {
                    (,) _ [Occ=Dead] y_sdvoY [Occ=Once] -> y_sdvoY;
                  }; } in
        let {
          sat_sdvoV [Occ=Once] :: Data.Semigroup.Internal.Dual a_adteT
          [LclId] =
              [mab_sdvoR] \u []
                  case mab_sdvoR of {
                    (,) x_sdvoT [Occ=Once] _ [Occ=Dead] -> x_sdvoT;
                  };
        } in  (,) [sat_sdvoV sat_sdvoZ];

Control.Monad.Zip.$fMonadZipDual [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Semigroup.Internal.$fMonadDual
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipDual1
                                                 Control.Monad.Zip.$fMonadZipDual_$cmunzip];

Control.Monad.Zip.$fMonadZipIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Zip.MonadZip Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Zip.C:MonadZip! [Data.Functor.Identity.$fMonadIdentity
                                                 GHC.Tuple.(,)
                                                 Control.Monad.Zip.$fMonadZipIdentity1
                                                 Control.Monad.Zip.$fMonadZipIdentity_$cmunzip];

Control.Monad.Zip.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Control.Monad.Zip.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Monad.Zip.$trModule4];

Control.Monad.Zip.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Control.Monad.Zip"#;

Control.Monad.Zip.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Monad.Zip.$trModule2];

Control.Monad.Zip.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Control.Monad.Zip.$trModule3
                                     Control.Monad.Zip.$trModule1];

$krep_rdtIk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Control.Monad.Zip.$tcMonadZip1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_rdtIk];

Control.Monad.Zip.$tcMonadZip3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "MonadZip"#;

Control.Monad.Zip.$tcMonadZip2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Monad.Zip.$tcMonadZip3];

Control.Monad.Zip.$tcMonadZip :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4362170845454097361##
                                    3840659568565778968##
                                    Control.Monad.Zip.$trModule
                                    Control.Monad.Zip.$tcMonadZip2
                                    0#
                                    Control.Monad.Zip.$tcMonadZip1];

Control.Monad.Zip.C:MonadZip
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall a b. m a -> m b -> m (a, b))
     -> (forall a b c. (a -> b -> c) -> m a -> m b -> m c)
     -> (forall a b. m (a, b) -> (m a, m b))
     -> Control.Monad.Zip.MonadZip m
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Control.Monad.Zip.C:MonadZip [eta_B4 eta_B3 eta_B2 eta_B1];

