
==================== Output Cmm ====================
2018-03-16 16:08:39.415389919 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:08:39.416492046 UTC

[section ""data" . Control.Monad.Zip.$p1MonadZip_closure" {
     Control.Monad.Zip.$p1MonadZip_closure:
         const Control.Monad.Zip.$p1MonadZip_info;
 },
 Control.Monad.Zip.$p1MonadZip_entry() //  [R2]
         { info_tbl: [(cdtPv,
                       label: Control.Monad.Zip.$p1MonadZip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtPv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdtPw; else goto cdtPx;
       cdtPw: // global
           R2 = R2;
           R1 = Control.Monad.Zip.$p1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdtPx: // global
           I64[Sp - 8] = block_cdtPs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udtPB; else goto cdtPt;
       udtPB: // global
           call _cdtPs(R1) args: 0, res: 0, upd: 0;
       cdtPt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdtPs() //  [R1]
         { info_tbl: [(cdtPs,
                       label: block_cdtPs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtPs: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.417924296 UTC

[section ""data" . Control.Monad.Zip.mzip_closure" {
     Control.Monad.Zip.mzip_closure:
         const Control.Monad.Zip.mzip_info;
 },
 Control.Monad.Zip.mzip_entry() //  [R2]
         { info_tbl: [(cdtPJ,
                       label: Control.Monad.Zip.mzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtPJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdtPK; else goto cdtPL;
       cdtPK: // global
           R2 = R2;
           R1 = Control.Monad.Zip.mzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdtPL: // global
           I64[Sp - 8] = block_cdtPG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udtPP; else goto cdtPH;
       udtPP: // global
           call _cdtPG(R1) args: 0, res: 0, upd: 0;
       cdtPH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdtPG() //  [R1]
         { info_tbl: [(cdtPG,
                       label: block_cdtPG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtPG: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.419215346 UTC

[section ""data" . Control.Monad.Zip.mzipWith_closure" {
     Control.Monad.Zip.mzipWith_closure:
         const Control.Monad.Zip.mzipWith_info;
 },
 Control.Monad.Zip.mzipWith_entry() //  [R2]
         { info_tbl: [(cdtPX,
                       label: Control.Monad.Zip.mzipWith_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtPX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdtPY; else goto cdtPZ;
       cdtPY: // global
           R2 = R2;
           R1 = Control.Monad.Zip.mzipWith_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdtPZ: // global
           I64[Sp - 8] = block_cdtPU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udtQ3; else goto cdtPV;
       udtQ3: // global
           call _cdtPU(R1) args: 0, res: 0, upd: 0;
       cdtPV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdtPU() //  [R1]
         { info_tbl: [(cdtPU,
                       label: block_cdtPU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtPU: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.420492389 UTC

[section ""data" . Control.Monad.Zip.munzip_closure" {
     Control.Monad.Zip.munzip_closure:
         const Control.Monad.Zip.munzip_info;
 },
 Control.Monad.Zip.munzip_entry() //  [R2]
         { info_tbl: [(cdtQb,
                       label: Control.Monad.Zip.munzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtQb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdtQc; else goto cdtQd;
       cdtQc: // global
           R2 = R2;
           R1 = Control.Monad.Zip.munzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdtQd: // global
           I64[Sp - 8] = block_cdtQ8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udtQh; else goto cdtQ9;
       udtQh: // global
           call _cdtQ8(R1) args: 0, res: 0, upd: 0;
       cdtQ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdtQ8() //  [R1]
         { info_tbl: [(cdtQ8,
                       label: block_cdtQ8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtQ8: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.421648603 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip[]_closure" {
     Control.Monad.Zip.$fMonadZip[]_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Base.$fMonad[]_closure;
         const GHC.List.zip_closure+2;
         const GHC.List.zipWith_closure+3;
         const GHC.List.unzip_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.423531009 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip3_closure" {
     Control.Monad.Zip.$w$cmunzip3_closure:
         const Control.Monad.Zip.$w$cmunzip3_info;
 },
 sat_sdtJ7_entry() //  [R1]
         { info_tbl: [(cdtQt,
                       label: sat_sdtJ7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtQt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdtQu; else goto cdtQv;
       cdtQu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtQv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdtQq_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udtQz; else goto cdtQr;
       udtQz: // global
           call _cdtQq(R1) args: 0, res: 0, upd: 0;
       cdtQr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdtQq() //  [R1]
         { info_tbl: [(cdtQq,
                       label: block_cdtQq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtQq: // global
           R3 = P64[R1 + 15];
           R2 = Data.Tuple.snd_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtJ3_entry() //  [R1]
         { info_tbl: [(cdtQH,
                       label: sat_sdtJ3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtQH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdtQL; else goto cdtQM;
       cdtQL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtQM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdtQE_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udtQU; else goto cdtQF;
       udtQU: // global
           call _cdtQE(R1) args: 0, res: 0, upd: 0;
       cdtQF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdtQE() //  [R1]
         { info_tbl: [(cdtQE,
                       label: block_cdtQE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtQE: // global
           I64[Sp] = block_cdtQK_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udtQT; else goto cdtQO;
       udtQT: // global
           call _cdtQK(R1) args: 0, res: 0, upd: 0;
       cdtQO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdtQK() //  [R1]
         { info_tbl: [(cdtQK,
                       label: block_cdtQK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtQK: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtIV_entry() //  [R1]
         { info_tbl: [(cdtR3,
                       label: sat_sdtIV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtR3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdtR4; else goto cdtR5;
       cdtR4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtR5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdtR0_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udtR9; else goto cdtR1;
       udtR9: // global
           call _cdtR0(R1) args: 0, res: 0, upd: 0;
       cdtR1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdtR0() //  [R1]
         { info_tbl: [(cdtR0,
                       label: block_cdtR0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtR0: // global
           R3 = P64[R1 + 15];
           R2 = Data.Tuple.fst_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtIR_entry() //  [R1]
         { info_tbl: [(cdtRh,
                       label: sat_sdtIR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtRh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdtRl; else goto cdtRm;
       cdtRl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtRm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdtRe_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udtRu; else goto cdtRf;
       udtRu: // global
           call _cdtRe(R1) args: 0, res: 0, upd: 0;
       cdtRf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdtRe() //  [R1]
         { info_tbl: [(cdtRe,
                       label: block_cdtRe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtRe: // global
           I64[Sp] = block_cdtRk_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udtRt; else goto cdtRo;
       udtRt: // global
           call _cdtRk(R1) args: 0, res: 0, upd: 0;
       cdtRo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdtRk() //  [R1]
         { info_tbl: [(cdtRk,
                       label: block_cdtRk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtRk: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip3_entry() //  [R2]
         { info_tbl: [(cdtRw,
                       label: Control.Monad.Zip.$w$cmunzip3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtRw: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdtRA; else goto cdtRz;
       cdtRA: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdtRz: // global
           I64[Hp - 136] = sat_sdtJ7_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sdtJ3_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = GHC.Base.:|_con_info;
           P64[Hp - 80] = Hp - 112;
           P64[Hp - 72] = Hp - 136;
           I64[Hp - 64] = sat_sdtIV_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdtIR_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = Hp - 87;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.426845861 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdtRI,
                       label: Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtRI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdtRJ; else goto cdtRK;
       cdtRJ: // global
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdtRK: // global
           I64[Sp - 8] = block_cdtRF_info;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdtRF() //  [R1, R2]
         { info_tbl: [(cdtRF,
                       label: block_cdtRF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtRF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdtRN; else goto cdtRM;
       cdtRN: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdtRM: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.42791842 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipNonEmpty_closure" {
     Control.Monad.Zip.$fMonadZipNonEmpty_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Base.$fMonadNonEmpty_closure;
         const Data.List.NonEmpty.zip_closure+2;
         const Data.List.NonEmpty.zipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.428660401 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdtRS,
                       label: Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtRS: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.429504245 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipIdentity1_closure" {
     Control.Monad.Zip.$fMonadZipIdentity1_closure:
         const Control.Monad.Zip.$fMonadZipIdentity1_info;
 },
 Control.Monad.Zip.$fMonadZipIdentity1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdtRZ,
                       label: Control.Monad.Zip.$fMonadZipIdentity1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtRZ: // global
           _sdtJi::P64 = R3;
           R3 = R4;
           _sdtJh::P64 = R2;
           R2 = _sdtJi::P64;
           R1 = _sdtJh::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.430383465 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipDual1_closure" {
     Control.Monad.Zip.$fMonadZipDual1_closure:
         const Control.Monad.Zip.$fMonadZipDual1_info;
 },
 Control.Monad.Zip.$fMonadZipDual1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdtS6,
                       label: Control.Monad.Zip.$fMonadZipDual1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtS6: // global
           _sdtJl::P64 = R3;
           R3 = R4;
           _sdtJk::P64 = R2;
           R2 = _sdtJl::P64;
           R1 = _sdtJk::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.431213299 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipSum1_closure" {
     Control.Monad.Zip.$fMonadZipSum1_closure:
         const Control.Monad.Zip.$fMonadZipSum1_info;
 },
 Control.Monad.Zip.$fMonadZipSum1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdtSd,
                       label: Control.Monad.Zip.$fMonadZipSum1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtSd: // global
           _sdtJo::P64 = R3;
           R3 = R4;
           _sdtJn::P64 = R2;
           R2 = _sdtJo::P64;
           R1 = _sdtJn::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.432128803 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProduct1_closure" {
     Control.Monad.Zip.$fMonadZipProduct1_closure:
         const Control.Monad.Zip.$fMonadZipProduct1_info;
 },
 Control.Monad.Zip.$fMonadZipProduct1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdtSk,
                       label: Control.Monad.Zip.$fMonadZipProduct1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtSk: // global
           _sdtJr::P64 = R3;
           R3 = R4;
           _sdtJq::P64 = R2;
           R2 = _sdtJr::P64;
           R1 = _sdtJq::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.43357812 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_info;
 },
 Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cdtSy,
                       label: Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtSy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdtSz; else goto cdtSA;
       cdtSz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdtSA: // global
           I64[Sp - 24] = block_cdtSr_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udtT2; else goto cdtSs;
       udtT2: // global
           call _cdtSr(R1) args: 0, res: 0, upd: 0;
       cdtSs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdtSr() //  [R1]
         { info_tbl: [(cdtSr,
                       label: block_cdtSr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtSr: // global
           if (R1 & 7 == 1) goto udtSY; else goto cdtSw;
       udtSY: // global
           Sp = Sp + 24;
           call _cdtSO() args: 0, res: 0, upd: 0;
       cdtSw: // global
           I64[Sp] = block_cdtSG_info;
           _sdtJx::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdtJx::P64;
           if (R1 & 7 != 0) goto udtT0; else goto cdtSI;
       udtT0: // global
           call _cdtSG(R1) args: 0, res: 0, upd: 0;
       cdtSI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdtSG() //  [R1]
         { info_tbl: [(cdtSG,
                       label: block_cdtSG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtSG: // global
           if (R1 & 7 == 1) goto udtSZ; else goto cdtST;
       udtSZ: // global
           Sp = Sp + 24;
           call _cdtSO() args: 0, res: 0, upd: 0;
       cdtST: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdtSW; else goto cdtSV;
       cdtSW: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdtSV: // global
           _sdtJz::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sdtJz::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdtSO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtSO: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.435701076 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst1_closure" {
     Control.Monad.Zip.$fMonadZipFirst1_closure:
         const Control.Monad.Zip.$fMonadZipFirst1_info;
 },
 Control.Monad.Zip.$fMonadZipFirst1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdtTf,
                       label: Control.Monad.Zip.$fMonadZipFirst1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtTf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdtTg; else goto cdtTh;
       cdtTg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipFirst1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdtTh: // global
           I64[Sp - 24] = block_cdtT8_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udtTJ; else goto cdtT9;
       udtTJ: // global
           call _cdtT8(R1) args: 0, res: 0, upd: 0;
       cdtT9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdtT8() //  [R1]
         { info_tbl: [(cdtT8,
                       label: block_cdtT8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtT8: // global
           if (R1 & 7 == 1) goto udtTF; else goto cdtTd;
       udtTF: // global
           Sp = Sp + 24;
           call _cdtTv() args: 0, res: 0, upd: 0;
       cdtTd: // global
           I64[Sp] = block_cdtTn_info;
           _sdtJF::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdtJF::P64;
           if (R1 & 7 != 0) goto udtTH; else goto cdtTp;
       udtTH: // global
           call _cdtTn(R1) args: 0, res: 0, upd: 0;
       cdtTp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdtTn() //  [R1]
         { info_tbl: [(cdtTn,
                       label: block_cdtTn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtTn: // global
           if (R1 & 7 == 1) goto udtTG; else goto cdtTA;
       udtTG: // global
           Sp = Sp + 24;
           call _cdtTv() args: 0, res: 0, upd: 0;
       cdtTA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdtTD; else goto cdtTC;
       cdtTD: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdtTC: // global
           _sdtJH::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sdtJH::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdtTv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtTv: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.437862218 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast1_closure" {
     Control.Monad.Zip.$fMonadZipLast1_closure:
         const Control.Monad.Zip.$fMonadZipLast1_info;
 },
 Control.Monad.Zip.$fMonadZipLast1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdtTW,
                       label: Control.Monad.Zip.$fMonadZipLast1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtTW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdtTX; else goto cdtTY;
       cdtTX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipLast1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdtTY: // global
           I64[Sp - 24] = block_cdtTP_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udtUq; else goto cdtTQ;
       udtUq: // global
           call _cdtTP(R1) args: 0, res: 0, upd: 0;
       cdtTQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdtTP() //  [R1]
         { info_tbl: [(cdtTP,
                       label: block_cdtTP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtTP: // global
           if (R1 & 7 == 1) goto udtUm; else goto cdtTU;
       udtUm: // global
           Sp = Sp + 24;
           call _cdtUc() args: 0, res: 0, upd: 0;
       cdtTU: // global
           I64[Sp] = block_cdtU4_info;
           _sdtJN::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdtJN::P64;
           if (R1 & 7 != 0) goto udtUo; else goto cdtU6;
       udtUo: // global
           call _cdtU4(R1) args: 0, res: 0, upd: 0;
       cdtU6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdtU4() //  [R1]
         { info_tbl: [(cdtU4,
                       label: block_cdtU4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtU4: // global
           if (R1 & 7 == 1) goto udtUn; else goto cdtUh;
       udtUn: // global
           Sp = Sp + 24;
           call _cdtUc() args: 0, res: 0, upd: 0;
       cdtUh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdtUk; else goto cdtUj;
       cdtUk: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdtUj: // global
           _sdtJP::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sdtJP::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdtUc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtUc: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.439688269 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_info;
 },
 sat_sdtJS_entry() //  [R1]
         { info_tbl: [(cdtUA,
                       label: sat_sdtJS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtUA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdtUB; else goto cdtUC;
       cdtUB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtUC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_entry() //  [R2]
         { info_tbl: [(cdtUD,
                       label: Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtUD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdtUH; else goto cdtUG;
       cdtUH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdtUG: // global
           I64[Hp - 16] = sat_sdtJS_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fMonadAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.44087129 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_info;
 },
 Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_entry() //  []
         { info_tbl: [(cdtUM,
                       label: Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtUM: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.441834918 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZipU1_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZipU1_$cmzipWith_info;
 },
 Control.Monad.Zip.$fMonadZipU1_$cmzipWith_entry() //  []
         { info_tbl: [(cdtUT,
                       label: Control.Monad.Zip.$fMonadZipU1_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtUT: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.442670373 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipPar2_closure" {
     Control.Monad.Zip.$fMonadZipPar2_closure:
         const Control.Monad.Zip.$fMonadZipPar2_info;
 },
 Control.Monad.Zip.$fMonadZipPar2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdtV0,
                       label: Control.Monad.Zip.$fMonadZipPar2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtV0: // global
           _sdtK0::P64 = R3;
           R3 = R4;
           _sdtJZ::P64 = R2;
           R2 = _sdtK0::P64;
           R1 = _sdtJZ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.443751065 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_info;
         const 0;
 },
 sat_sdtK3_entry() //  [R1]
         { info_tbl: [(cdtVb,
                       label: sat_sdtK3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtVb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdtVc; else goto cdtVd;
       cdtVc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtVd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_entry() //  [R2]
         { info_tbl: [(cdtVe,
                       label: Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtVe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdtVi; else goto cdtVh;
       cdtVi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdtVh: // global
           I64[Hp - 16] = sat_sdtK3_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadRec1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.445118431 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_info;
 },
 sat_sdtK5_entry() //  [R1]
         { info_tbl: [(cdtVs,
                       label: sat_sdtK5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtVs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdtVt; else goto cdtVu;
       cdtVt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtVu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_entry() //  [R2]
         { info_tbl: [(cdtVv,
                       label: Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtVv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdtVz; else goto cdtVy;
       cdtVz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdtVy: // global
           I64[Hp - 16] = sat_sdtK5_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.446935444 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_info;
 },
 sat_sdtKi_entry() //  [R1]
         { info_tbl: [(cdtVS,
                       label: sat_sdtKi_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtVS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdtVT; else goto cdtVU;
       cdtVT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtVU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdtKh_entry() //  [R1]
         { info_tbl: [(cdtVZ,
                       label: sat_sdtKh_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtVZ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdtW0; else goto cdtW1;
       cdtW0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtW1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cdtW2,
                       label: Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtW2: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdtW4; else goto cdtW5;
       cdtW4: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdtW5: // global
           I64[Sp - 40] = block_cdtVE_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udtWb; else goto cdtVF;
       udtWb: // global
           call _cdtVE(R1) args: 0, res: 0, upd: 0;
       cdtVF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdtVE() //  [R1]
         { info_tbl: [(cdtVE,
                       label: block_cdtVE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtVE: // global
           I64[Sp - 8] = block_cdtVJ_info;
           _sdtKc::P64 = P64[R1 + 7];
           _sdtKd::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sdtKd::P64;
           P64[Sp + 32] = _sdtKc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udtWa; else goto cdtVK;
       udtWa: // global
           call _cdtVJ(R1) args: 0, res: 0, upd: 0;
       cdtVK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdtVJ() //  [R1]
         { info_tbl: [(cdtVJ,
                       label: block_cdtVJ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtVJ: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cdtW9; else goto cdtW8;
       cdtW9: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdtW8: // global
           _sdtKf::P64 = P64[R1 + 7];
           _sdtKg::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_sdtKi_info;
           P64[Hp - 96] = P64[Sp + 24];
           _sdtK8::P64 = P64[Sp + 32];
           P64[Hp - 88] = _sdtK8::P64;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sdtKg::P64;
           I64[Hp - 64] = sat_sdtKh_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _sdtK8::P64;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = _sdtKf::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.449502239 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_info;
         const 0;
 },
 sat_sdtKm_entry() //  [R1]
         { info_tbl: [(cdtWk,
                       label: sat_sdtKm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtWk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdtWl; else goto cdtWm;
       cdtWl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtWm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtKl_entry() //  [R1]
         { info_tbl: [(cdtWr,
                       label: sat_sdtKl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtWr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdtWs; else goto cdtWt;
       cdtWs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtWt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_entry() //  [R2, R3]
         { info_tbl: [(cdtWu,
                       label: Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtWu: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdtWy; else goto cdtWx;
       cdtWy: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdtWx: // global
           I64[Hp - 40] = sat_sdtKm_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sdtKl_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fMonad:*:_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.451802558 UTC

[section ""data" . Control.Monad.Zip.$dmmunzip_closure" {
     Control.Monad.Zip.$dmmunzip_closure:
         const Control.Monad.Zip.$dmmunzip_info;
 },
 $dMonad_sdtKp_entry() //  [R1]
         { info_tbl: [(cdtWH,
                       label: $dMonad_sdtKp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtWH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdtWI; else goto cdtWJ;
       cdtWI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtWJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtKC_entry() //  [R1, R2]
         { info_tbl: [(cdtWU,
                       label: sat_sdtKC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtWU: // global
           _sdtKx::P64 = R2;
           _sdtKC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdtWV; else goto cdtWW;
       cdtWW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdtWY; else goto cdtWX;
       cdtWY: // global
           HpAlloc = 24;
           goto cdtWV;
       cdtWV: // global
           R2 = _sdtKx::P64;
           R1 = _sdtKC::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdtWX: // global
           _sdtKp::P64 = P64[_sdtKC::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtKx::P64;
           R2 = _sdtKp::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtKD_entry() //  [R1]
         { info_tbl: [(cdtWZ,
                       label: sat_sdtKD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtWZ: // global
           _sdtKD::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdtX0; else goto cdtX1;
       cdtX1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdtX3; else goto cdtX2;
       cdtX3: // global
           HpAlloc = 16;
           goto cdtX0;
       cdtX0: // global
           R1 = _sdtKD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtX2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtKD::P64;
           _sdtKo::P64 = P64[_sdtKD::P64 + 16];
           _sdtKp::P64 = P64[_sdtKD::P64 + 24];
           I64[Hp - 8] = sat_sdtKC_info;
           P64[Hp] = _sdtKp::P64;
           R2 = _sdtKp::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtKo::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtKv_entry() //  [R1, R2]
         { info_tbl: [(cdtXe,
                       label: sat_sdtKv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtXe: // global
           _sdtKq::P64 = R2;
           _sdtKv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdtXf; else goto cdtXg;
       cdtXg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdtXi; else goto cdtXh;
       cdtXi: // global
           HpAlloc = 24;
           goto cdtXf;
       cdtXf: // global
           R2 = _sdtKq::P64;
           R1 = _sdtKv::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdtXh: // global
           _sdtKp::P64 = P64[_sdtKv::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtKq::P64;
           R2 = _sdtKp::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtKw_entry() //  [R1]
         { info_tbl: [(cdtXj,
                       label: sat_sdtKw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtXj: // global
           _sdtKw::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdtXk; else goto cdtXl;
       cdtXl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdtXn; else goto cdtXm;
       cdtXn: // global
           HpAlloc = 16;
           goto cdtXk;
       cdtXk: // global
           R1 = _sdtKw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtXm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtKw::P64;
           _sdtKo::P64 = P64[_sdtKw::P64 + 16];
           _sdtKp::P64 = P64[_sdtKw::P64 + 24];
           I64[Hp - 8] = sat_sdtKv_info;
           P64[Hp] = _sdtKp::P64;
           R2 = _sdtKp::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtKo::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$dmmunzip_entry() //  [R2, R3]
         { info_tbl: [(cdtXp,
                       label: Control.Monad.Zip.$dmmunzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtXp: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdtXt; else goto cdtXs;
       cdtXt: // global
           HpAlloc = 112;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$dmmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdtXs: // global
           I64[Hp - 104] = $dMonad_sdtKp_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sdtKD_info;
           P64[Hp - 64] = R3;
           _cdtWD::P64 = Hp - 104;
           P64[Hp - 56] = _cdtWD::P64;
           I64[Hp - 48] = sat_sdtKw_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = _cdtWD::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.455607573 UTC

[section ""data" . Control.Monad.Zip.$dmmzipWith_closure" {
     Control.Monad.Zip.$dmmzipWith_closure:
         const Control.Monad.Zip.$dmmzipWith_info;
 },
 sat_sdtKT_entry() //  [R1]
         { info_tbl: [(cdtXN,
                       label: sat_sdtKT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtXN: // global
           _sdtKT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdtXO; else goto cdtXP;
       cdtXP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdtXR; else goto cdtXQ;
       cdtXR: // global
           HpAlloc = 48;
           goto cdtXO;
       cdtXO: // global
           R1 = _sdtKT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtXQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtKT::P64;
           _sdtKF::P64 = P64[_sdtKT::P64 + 16];
           _sdtKK::P64 = P64[_sdtKT::P64 + 24];
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sdtKK::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtKK::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _sdtKF::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtKU_entry() //  [R1, R2]
         { info_tbl: [(cdtXS,
                       label: sat_sdtKU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtXS: // global
           _sdtKK::P64 = R2;
           _sdtKU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdtXT; else goto cdtXU;
       cdtXU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdtXW; else goto cdtXV;
       cdtXW: // global
           HpAlloc = 32;
           goto cdtXT;
       cdtXT: // global
           R2 = _sdtKK::P64;
           R1 = _sdtKU::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdtXV: // global
           _sdtKF::P64 = P64[_sdtKU::P64 + 7];
           _sdtKI::P64 = P64[_sdtKU::P64 + 15];
           I64[Hp - 24] = sat_sdtKT_info;
           P64[Hp - 8] = _sdtKF::P64;
           P64[Hp] = _sdtKK::P64;
           R2 = _sdtKI::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtKJ_entry() //  [R1]
         { info_tbl: [(cdtY1,
                       label: sat_sdtKJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtY1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdtY2; else goto cdtY3;
       cdtY2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtY3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Monad.Zip.mzip_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$dmmzipWith_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdtY4,
                       label: Control.Monad.Zip.$dmmzipWith_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtY4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdtY5; else goto cdtY6;
       cdtY5: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$dmmzipWith_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdtY6: // global
           I64[Sp - 40] = block_cdtXy_info;
           _sdtKE::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _sdtKE::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdtXy() //  [R1]
         { info_tbl: [(cdtXy,
                       label: block_cdtXy_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtXy: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdtY9; else goto cdtY8;
       cdtY9: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdtY8: // global
           I64[Hp - 56] = sat_sdtKU_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdtKJ_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 55;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.457990519 UTC

[section ""data" . Control.Monad.Zip.$dmmzip_closure" {
     Control.Monad.Zip.$dmmzip_closure:
         const Control.Monad.Zip.$dmmzip_info;
 },
 Control.Monad.Zip.$dmmzip_entry() //  [R2]
         { info_tbl: [(cdtYe,
                       label: Control.Monad.Zip.$dmmzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtYe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdtYf; else goto cdtYg;
       cdtYf: // global
           R2 = R2;
           R1 = Control.Monad.Zip.$dmmzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdtYg: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Tuple.(,)_closure+2;
           Sp = Sp - 16;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.459614261 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cmzip_info;
 },
 sat_sdtL7_entry() //  [R1]
         { info_tbl: [(cdtYz,
                       label: sat_sdtL7_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtYz: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdtYA; else goto cdtYB;
       cdtYA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtYB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdtL6_entry() //  [R1]
         { info_tbl: [(cdtYG,
                       label: sat_sdtL6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtYG: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdtYH; else goto cdtYI;
       cdtYH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtYI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZip:*:_$cmzip_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdtYJ,
                       label: Control.Monad.Zip.$fMonadZip:*:_$cmzip_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtYJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdtYL; else goto cdtYM;
       cdtYL: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cmzip_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdtYM: // global
           I64[Sp - 32] = block_cdtYl_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udtYS; else goto cdtYm;
       udtYS: // global
           call _cdtYl(R1) args: 0, res: 0, upd: 0;
       cdtYm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdtYl() //  [R1]
         { info_tbl: [(cdtYl,
                       label: block_cdtYl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtYl: // global
           I64[Sp - 8] = block_cdtYq_info;
           _sdtL1::P64 = P64[R1 + 7];
           _sdtL2::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdtL2::P64;
           P64[Sp + 24] = _sdtL1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udtYR; else goto cdtYr;
       udtYR: // global
           call _cdtYq(R1) args: 0, res: 0, upd: 0;
       cdtYr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdtYq() //  [R1]
         { info_tbl: [(cdtYq,
                       label: block_cdtYq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtYq: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdtYQ; else goto cdtYP;
       cdtYQ: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdtYP: // global
           _sdtL4::P64 = P64[R1 + 7];
           _sdtL5::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sdtL7_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sdtL5::P64;
           I64[Hp - 56] = sat_sdtL6_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdtL4::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.464437764 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip_closure" {
     Control.Monad.Zip.$w$cmunzip_closure:
         const Control.Monad.Zip.$w$cmunzip_info;
 },
 $dMonad_sdtLb_entry() //  [R1]
         { info_tbl: [(cdtZ1,
                       label: $dMonad_sdtLb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtZ1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdtZ2; else goto cdtZ3;
       cdtZ2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtZ3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl_sdtLc_entry() //  [R1]
         { info_tbl: [(cdtZ8,
                       label: lvl_sdtLc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtZ8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdtZ9; else goto cdtZa;
       cdtZ9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtZa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dMonad1_sdtLd_entry() //  [R1]
         { info_tbl: [(cdtZf,
                       label: $dMonad1_sdtLd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtZf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdtZg; else goto cdtZh;
       cdtZg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtZh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl1_sdtLe_entry() //  [R1]
         { info_tbl: [(cdtZm,
                       label: lvl1_sdtLe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtZm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdtZn; else goto cdtZo;
       cdtZn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtZo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtLM_entry() //  [R1, R2]
         { info_tbl: [(cdtZI,
                       label: sat_sdtLM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtZI: // global
           _sdtLH::P64 = R2;
           _sdtLM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdtZJ; else goto cdtZK;
       cdtZK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdtZM; else goto cdtZL;
       cdtZM: // global
           HpAlloc = 24;
           goto cdtZJ;
       cdtZJ: // global
           R2 = _sdtLH::P64;
           R1 = _sdtLM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdtZL: // global
           _sdtLc::P64 = P64[_sdtLM::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtLH::P64;
           R2 = _sdtLc::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtLN_entry() //  [R1]
         { info_tbl: [(cdtZN,
                       label: sat_sdtLN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtZN: // global
           _sdtLN::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdtZO; else goto cdtZP;
       cdtZP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdtZR; else goto cdtZQ;
       cdtZR: // global
           HpAlloc = 16;
           goto cdtZO;
       cdtZO: // global
           R1 = _sdtLN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdtZQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtLN::P64;
           _sdtLb::P64 = P64[_sdtLN::P64 + 16];
           _sdtLc::P64 = P64[_sdtLN::P64 + 24];
           _sdtLz::P64 = P64[_sdtLN::P64 + 32];
           I64[Hp - 8] = sat_sdtLM_info;
           P64[Hp] = _sdtLc::P64;
           R2 = _sdtLb::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtLz::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtLF_entry() //  [R1, R2]
         { info_tbl: [(cdu02,
                       label: sat_sdtLF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu02: // global
           _sdtLA::P64 = R2;
           _sdtLF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdu03; else goto cdu04;
       cdu04: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdu06; else goto cdu05;
       cdu06: // global
           HpAlloc = 24;
           goto cdu03;
       cdu03: // global
           R2 = _sdtLA::P64;
           R1 = _sdtLF::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdu05: // global
           _sdtLe::P64 = P64[_sdtLF::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtLA::P64;
           R2 = _sdtLe::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtLG_entry() //  [R1]
         { info_tbl: [(cdu07,
                       label: sat_sdtLG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu07: // global
           _sdtLG::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdu08; else goto cdu09;
       cdu09: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdu0b; else goto cdu0a;
       cdu0b: // global
           HpAlloc = 16;
           goto cdu08;
       cdu08: // global
           R1 = _sdtLG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu0a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtLG::P64;
           _sdtLd::P64 = P64[_sdtLG::P64 + 16];
           _sdtLe::P64 = P64[_sdtLG::P64 + 24];
           _sdtLy::P64 = P64[_sdtLG::P64 + 32];
           I64[Hp - 8] = sat_sdtLF_info;
           P64[Hp] = _sdtLe::P64;
           R2 = _sdtLd::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtLy::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtLO_entry() //  [R1]
         { info_tbl: [(cdu0c,
                       label: sat_sdtLO_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu0c: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cdu0e; else goto cdu0f;
       cdu0e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu0f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cdtZt_info;
           _sdtLb::P64 = P64[R1 + 24];
           _sdtLc::P64 = P64[R1 + 32];
           _sdtLd::P64 = P64[R1 + 40];
           _sdtLe::P64 = P64[R1 + 48];
           R1 = P64[R1 + 16];
           P64[Sp - 48] = _sdtLb::P64;
           P64[Sp - 40] = _sdtLc::P64;
           P64[Sp - 32] = _sdtLd::P64;
           P64[Sp - 24] = _sdtLe::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto udu0j; else goto cdtZu;
       udu0j: // global
           call _cdtZt(R1) args: 0, res: 0, upd: 0;
       cdtZu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdtZt() //  [R1]
         { info_tbl: [(cdtZt,
                       label: block_cdtZt_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtZt: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdu0i; else goto cdu0h;
       cdu0i: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdu0h: // global
           _sdtLy::P64 = P64[R1 + 7];
           _sdtLz::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sdtLN_info;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sdtLz::P64;
           I64[Hp - 56] = sat_sdtLG_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdtLy::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtLu_entry() //  [R1, R2]
         { info_tbl: [(cdu0D,
                       label: sat_sdtLu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu0D: // global
           _sdtLp::P64 = R2;
           _sdtLu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdu0E; else goto cdu0F;
       cdu0F: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdu0H; else goto cdu0G;
       cdu0H: // global
           HpAlloc = 24;
           goto cdu0E;
       cdu0E: // global
           R2 = _sdtLp::P64;
           R1 = _sdtLu::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdu0G: // global
           _sdtLc::P64 = P64[_sdtLu::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtLp::P64;
           R2 = _sdtLc::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtLv_entry() //  [R1]
         { info_tbl: [(cdu0I,
                       label: sat_sdtLv_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu0I: // global
           _sdtLv::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdu0J; else goto cdu0K;
       cdu0K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdu0M; else goto cdu0L;
       cdu0M: // global
           HpAlloc = 16;
           goto cdu0J;
       cdu0J: // global
           R1 = _sdtLv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu0L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtLv::P64;
           _sdtLb::P64 = P64[_sdtLv::P64 + 16];
           _sdtLc::P64 = P64[_sdtLv::P64 + 24];
           _sdtLh::P64 = P64[_sdtLv::P64 + 32];
           I64[Hp - 8] = sat_sdtLu_info;
           P64[Hp] = _sdtLc::P64;
           R2 = _sdtLb::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtLh::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtLn_entry() //  [R1, R2]
         { info_tbl: [(cdu0X,
                       label: sat_sdtLn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu0X: // global
           _sdtLi::P64 = R2;
           _sdtLn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdu0Y; else goto cdu0Z;
       cdu0Z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdu11; else goto cdu10;
       cdu11: // global
           HpAlloc = 24;
           goto cdu0Y;
       cdu0Y: // global
           R2 = _sdtLi::P64;
           R1 = _sdtLn::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdu10: // global
           _sdtLe::P64 = P64[_sdtLn::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtLi::P64;
           R2 = _sdtLe::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtLo_entry() //  [R1]
         { info_tbl: [(cdu12,
                       label: sat_sdtLo_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu12: // global
           _sdtLo::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdu13; else goto cdu14;
       cdu14: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdu16; else goto cdu15;
       cdu16: // global
           HpAlloc = 16;
           goto cdu13;
       cdu13: // global
           R1 = _sdtLo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu15: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtLo::P64;
           _sdtLd::P64 = P64[_sdtLo::P64 + 16];
           _sdtLe::P64 = P64[_sdtLo::P64 + 24];
           _sdtLg::P64 = P64[_sdtLo::P64 + 32];
           I64[Hp - 8] = sat_sdtLn_info;
           P64[Hp] = _sdtLe::P64;
           R2 = _sdtLd::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtLg::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtLw_entry() //  [R1]
         { info_tbl: [(cdu17,
                       label: sat_sdtLw_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu17: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cdu19; else goto cdu1a;
       cdu19: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu1a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cdu0o_info;
           _sdtLb::P64 = P64[R1 + 24];
           _sdtLc::P64 = P64[R1 + 32];
           _sdtLd::P64 = P64[R1 + 40];
           _sdtLe::P64 = P64[R1 + 48];
           R1 = P64[R1 + 16];
           P64[Sp - 48] = _sdtLb::P64;
           P64[Sp - 40] = _sdtLc::P64;
           P64[Sp - 32] = _sdtLd::P64;
           P64[Sp - 24] = _sdtLe::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto udu1e; else goto cdu0p;
       udu1e: // global
           call _cdu0o(R1) args: 0, res: 0, upd: 0;
       cdu0p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdu0o() //  [R1]
         { info_tbl: [(cdu0o,
                       label: block_cdu0o_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu0o: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdu1d; else goto cdu1c;
       cdu1d: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdu1c: // global
           _sdtLg::P64 = P64[R1 + 7];
           _sdtLh::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sdtLv_info;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sdtLh::P64;
           I64[Hp - 56] = sat_sdtLo_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdtLg::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip_entry() //  [R2, R3, R4]
         { info_tbl: [(cdu1f,
                       label: Control.Monad.Zip.$w$cmunzip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu1f: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cdu1j; else goto cdu1i;
       cdu1j: // global
           HpAlloc = 208;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdu1i: // global
           I64[Hp - 200] = $dMonad_sdtLb_info;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = lvl_sdtLc_info;
           _cdtYX::P64 = Hp - 200;
           P64[Hp - 160] = _cdtYX::P64;
           I64[Hp - 152] = $dMonad1_sdtLd_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = lvl1_sdtLe_info;
           _cdtZb::P64 = Hp - 152;
           P64[Hp - 112] = _cdtZb::P64;
           I64[Hp - 104] = sat_sdtLO_info;
           P64[Hp - 88] = R4;
           P64[Hp - 80] = _cdtYX::P64;
           _cdtZ4::P64 = Hp - 176;
           P64[Hp - 72] = _cdtZ4::P64;
           P64[Hp - 64] = _cdtZb::P64;
           _cdtZi::P64 = Hp - 128;
           P64[Hp - 56] = _cdtZi::P64;
           I64[Hp - 48] = sat_sdtLw_info;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = _cdtYX::P64;
           P64[Hp - 16] = _cdtZ4::P64;
           P64[Hp - 8] = _cdtZb::P64;
           P64[Hp] = _cdtZi::P64;
           R2 = Hp - 104;
           R1 = Hp - 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.471394825 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZip:*:_$cmunzip_entry() //  [R2, R3, R4]
         { info_tbl: [(cdu1r,
                       label: Control.Monad.Zip.$fMonadZip:*:_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu1r: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdu1s; else goto cdu1t;
       cdu1s: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdu1t: // global
           I64[Sp - 8] = block_cdu1o_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdu1o() //  [R1, R2]
         { info_tbl: [(cdu1o,
                       label: block_cdu1o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu1o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdu1w; else goto cdu1v;
       cdu1w: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdu1v: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.473335257 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_closure" {
     Control.Monad.Zip.$fMonadZip:*:_closure:
         const Control.Monad.Zip.$fMonadZip:*:_info;
         const 0;
 },
 sat_sdtM0_entry() //  [R1, R2]
         { info_tbl: [(cdu1G,
                       label: sat_sdtM0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu1G: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZip:*:_$cmunzip_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtLZ_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdu1O,
                       label: sat_sdtLZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu1O: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtLY_entry() //  [R1, R2, R3]
         { info_tbl: [(cdu1W,
                       label: sat_sdtLY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu1W: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZip:*:_$cmzip_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtLX_entry() //  [R1]
         { info_tbl: [(cdu23,
                       label: sat_sdtLX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu23: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdu24; else goto cdu25;
       cdu24: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu25: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_entry(R3,
                                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZip:*:_entry() //  [R2, R3]
         { info_tbl: [(cdu27,
                       label: Control.Monad.Zip.$fMonadZip:*:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu27: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdu2b; else goto cdu2a;
       cdu2b: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdu2a: // global
           I64[Hp - 136] = sat_sdtM0_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sdtLZ_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sdtLY_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_sdtLX_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 86;
           P64[Hp - 8] = Hp - 109;
           P64[Hp] = Hp - 135;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.475403255 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM2_closure" {
     Control.Monad.Zip.$fMonadZipM2_closure:
         const Control.Monad.Zip.$fMonadZipM2_info;
 },
 Control.Monad.Zip.$fMonadZipM2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdu2g,
                       label: Control.Monad.Zip.$fMonadZipM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu2g: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdu2h; else goto cdu2i;
       cdu2h: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdu2i: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.479634267 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip2_closure" {
     Control.Monad.Zip.$w$cmunzip2_closure:
         const Control.Monad.Zip.$w$cmunzip2_info;
 },
 $dMonad_sdtM6_entry() //  [R1]
         { info_tbl: [(cdu2r,
                       label: $dMonad_sdtM6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu2r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdu2s; else goto cdu2t;
       cdu2s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu2t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtMj_entry() //  [R1, R2]
         { info_tbl: [(cdu2E,
                       label: sat_sdtMj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu2E: // global
           _sdtMe::P64 = R2;
           _sdtMj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdu2F; else goto cdu2G;
       cdu2G: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdu2I; else goto cdu2H;
       cdu2I: // global
           HpAlloc = 24;
           goto cdu2F;
       cdu2F: // global
           R2 = _sdtMe::P64;
           R1 = _sdtMj::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdu2H: // global
           _sdtM6::P64 = P64[_sdtMj::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtMe::P64;
           R2 = _sdtM6::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtMk_entry() //  [R1]
         { info_tbl: [(cdu2J,
                       label: sat_sdtMk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu2J: // global
           _sdtMk::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdu2K; else goto cdu2L;
       cdu2L: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdu2N; else goto cdu2M;
       cdu2N: // global
           HpAlloc = 16;
           goto cdu2K;
       cdu2K: // global
           R1 = _sdtMk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu2M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtMk::P64;
           _sdtM5::P64 = P64[_sdtMk::P64 + 16];
           _sdtM6::P64 = P64[_sdtMk::P64 + 24];
           I64[Hp - 8] = sat_sdtMj_info;
           P64[Hp] = _sdtM6::P64;
           R2 = _sdtM6::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtM5::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtMc_entry() //  [R1, R2]
         { info_tbl: [(cdu2Y,
                       label: sat_sdtMc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu2Y: // global
           _sdtM7::P64 = R2;
           _sdtMc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdu2Z; else goto cdu30;
       cdu30: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdu32; else goto cdu31;
       cdu32: // global
           HpAlloc = 24;
           goto cdu2Z;
       cdu2Z: // global
           R2 = _sdtM7::P64;
           R1 = _sdtMc::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdu31: // global
           _sdtM6::P64 = P64[_sdtMc::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtM7::P64;
           R2 = _sdtM6::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtMd_entry() //  [R1]
         { info_tbl: [(cdu33,
                       label: sat_sdtMd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu33: // global
           _sdtMd::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdu34; else goto cdu35;
       cdu35: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdu37; else goto cdu36;
       cdu37: // global
           HpAlloc = 16;
           goto cdu34;
       cdu34: // global
           R1 = _sdtMd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu36: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtMd::P64;
           _sdtM5::P64 = P64[_sdtMd::P64 + 16];
           _sdtM6::P64 = P64[_sdtMd::P64 + 24];
           I64[Hp - 8] = sat_sdtMc_info;
           P64[Hp] = _sdtM6::P64;
           R2 = _sdtM6::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtM5::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip2_entry() //  [R2, R3]
         { info_tbl: [(cdu38,
                       label: Control.Monad.Zip.$w$cmunzip2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu38: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdu3c; else goto cdu3b;
       cdu3c: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdu3b: // global
           I64[Hp - 80] = $dMonad_sdtM6_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtMk_info;
           P64[Hp - 40] = R3;
           _cdu2n::P64 = Hp - 80;
           P64[Hp - 32] = _cdu2n::P64;
           I64[Hp - 24] = sat_sdtMd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdu2n::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.48236565 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipM1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipM1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipM1_$cmunzip_entry() //  [R2, R3]
         { info_tbl: [(cdu3k,
                       label: Control.Monad.Zip.$fMonadZipM1_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu3k: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdu3l; else goto cdu3m;
       cdu3l: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM1_$cmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdu3m: // global
           I64[Sp - 8] = block_cdu3h_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip2_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdu3h() //  [R1, R2]
         { info_tbl: [(cdu3h,
                       label: block_cdu3h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu3h: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdu3p; else goto cdu3o;
       cdu3p: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdu3o: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.484069679 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM1_closure" {
     Control.Monad.Zip.$fMonadZipM1_closure:
         const Control.Monad.Zip.$fMonadZipM1_info;
 },
 sat_sdtMx_entry() //  [R1, R2]
         { info_tbl: [(cdu3z,
                       label: sat_sdtMx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu3z: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZipM1_$cmunzip_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtMw_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdu3H,
                       label: sat_sdtMw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu3H: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdu3I; else goto cdu3J;
       cdu3I: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdu3J: // global
           _sdtMt::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sdtMt::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sdtMs_entry() //  [R1, R2, R3]
         { info_tbl: [(cdu3P,
                       label: sat_sdtMs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu3P: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZipM2_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtMr_entry() //  [R1]
         { info_tbl: [(cdu3W,
                       label: sat_sdtMr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu3W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdu3X; else goto cdu3Y;
       cdu3X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu3Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipM1_entry() //  [R2]
         { info_tbl: [(cdu40,
                       label: Control.Monad.Zip.$fMonadZipM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu40: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdu44; else goto cdu43;
       cdu44: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdu43: // global
           I64[Hp - 104] = sat_sdtMx_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdtMw_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdtMs_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtMr_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.485978616 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec2_closure" {
     Control.Monad.Zip.$fMonadZipRec2_closure:
         const Control.Monad.Zip.$fMonadZipRec2_info;
 },
 Control.Monad.Zip.$fMonadZipRec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdu49,
                       label: Control.Monad.Zip.$fMonadZipRec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu49: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdu4a; else goto cdu4b;
       cdu4a: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdu4b: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.487939612 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip4_closure" {
     Control.Monad.Zip.$w$cmunzip4_closure:
         const Control.Monad.Zip.$w$cmunzip4_info;
 },
 $dMonad_sdtMD_entry() //  [R1]
         { info_tbl: [(cdu4k,
                       label: $dMonad_sdtMD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu4k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdu4l; else goto cdu4m;
       cdu4l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu4m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl_sdtMM_entry() //  [R1]
         { info_tbl: [(cdu4v,
                       label: lvl_sdtMM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu4v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdu4w; else goto cdu4x;
       cdu4w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu4x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtMS_entry() //  [R1, R2]
         { info_tbl: [(cdu4E,
                       label: sat_sdtMS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu4E: // global
           _sdtMN::P64 = R2;
           _sdtMS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdu4F; else goto cdu4G;
       cdu4G: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdu4I; else goto cdu4H;
       cdu4I: // global
           HpAlloc = 24;
           goto cdu4F;
       cdu4F: // global
           R2 = _sdtMN::P64;
           R1 = _sdtMS::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdu4H: // global
           _sdtMM::P64 = P64[_sdtMS::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtMN::P64;
           R2 = _sdtMM::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtMT_entry() //  [R1]
         { info_tbl: [(cdu4J,
                       label: sat_sdtMT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu4J: // global
           _sdtMT::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdu4K; else goto cdu4L;
       cdu4L: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdu4N; else goto cdu4M;
       cdu4N: // global
           HpAlloc = 40;
           goto cdu4K;
       cdu4K: // global
           R1 = _sdtMT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu4M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtMT::P64;
           _sdtMC::P64 = P64[_sdtMT::P64 + 16];
           _sdtMD::P64 = P64[_sdtMT::P64 + 24];
           I64[Hp - 32] = lvl_sdtMM_info;
           P64[Hp - 16] = _sdtMD::P64;
           I64[Hp - 8] = sat_sdtMS_info;
           P64[Hp] = Hp - 32;
           R2 = _sdtMD::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtMC::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 lvl_sdtME_entry() //  [R1]
         { info_tbl: [(cdu4W,
                       label: lvl_sdtME_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu4W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdu4X; else goto cdu4Y;
       cdu4X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu4Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtMK_entry() //  [R1, R2]
         { info_tbl: [(cdu55,
                       label: sat_sdtMK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu55: // global
           _sdtMF::P64 = R2;
           _sdtMK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdu56; else goto cdu57;
       cdu57: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdu59; else goto cdu58;
       cdu59: // global
           HpAlloc = 24;
           goto cdu56;
       cdu56: // global
           R2 = _sdtMF::P64;
           R1 = _sdtMK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdu58: // global
           _sdtME::P64 = P64[_sdtMK::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtMF::P64;
           R2 = _sdtME::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtML_entry() //  [R1]
         { info_tbl: [(cdu5a,
                       label: sat_sdtML_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu5a: // global
           _sdtML::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdu5b; else goto cdu5c;
       cdu5c: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdu5e; else goto cdu5d;
       cdu5e: // global
           HpAlloc = 40;
           goto cdu5b;
       cdu5b: // global
           R1 = _sdtML::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu5d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtML::P64;
           _sdtMC::P64 = P64[_sdtML::P64 + 16];
           _sdtMD::P64 = P64[_sdtML::P64 + 24];
           I64[Hp - 32] = lvl_sdtME_info;
           P64[Hp - 16] = _sdtMD::P64;
           I64[Hp - 8] = sat_sdtMK_info;
           P64[Hp] = Hp - 32;
           R2 = _sdtMD::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtMC::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip4_entry() //  [R2, R3]
         { info_tbl: [(cdu5f,
                       label: Control.Monad.Zip.$w$cmunzip4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu5f: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdu5j; else goto cdu5i;
       cdu5j: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdu5i: // global
           I64[Hp - 80] = $dMonad_sdtMD_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtMT_info;
           P64[Hp - 40] = R3;
           _cdu4g::P64 = Hp - 80;
           P64[Hp - 32] = _cdu4g::P64;
           I64[Hp - 24] = sat_sdtML_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdu4g::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.491174748 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipRec1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipRec1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipRec1_$cmunzip_entry() //  [R2, R3]
         { info_tbl: [(cdu5r,
                       label: Control.Monad.Zip.$fMonadZipRec1_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu5r: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdu5s; else goto cdu5t;
       cdu5s: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec1_$cmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdu5t: // global
           I64[Sp - 8] = block_cdu5o_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip4_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdu5o() //  [R1, R2]
         { info_tbl: [(cdu5o,
                       label: block_cdu5o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu5o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdu5w; else goto cdu5v;
       cdu5w: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdu5v: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.492904564 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec1_closure" {
     Control.Monad.Zip.$fMonadZipRec1_closure:
         const Control.Monad.Zip.$fMonadZipRec1_info;
         const 0;
 },
 sat_sdtN6_entry() //  [R1, R2]
         { info_tbl: [(cdu5G,
                       label: sat_sdtN6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu5G: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZipRec1_$cmunzip_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtN5_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdu5O,
                       label: sat_sdtN5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu5O: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdu5P; else goto cdu5Q;
       cdu5P: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdu5Q: // global
           _sdtN2::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sdtN2::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sdtN1_entry() //  [R1, R2, R3]
         { info_tbl: [(cdu5W,
                       label: sat_sdtN1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu5W: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZipRec2_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtN0_entry() //  [R1]
         { info_tbl: [(cdu63,
                       label: sat_sdtN0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu63: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdu64; else goto cdu65;
       cdu64: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu65: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipRec1_entry() //  [R2]
         { info_tbl: [(cdu67,
                       label: Control.Monad.Zip.$fMonadZipRec1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu67: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdu6b; else goto cdu6a;
       cdu6b: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdu6a: // global
           I64[Hp - 104] = sat_sdtN6_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdtN5_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdtN1_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtN0_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.494865598 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipPar1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipPar1_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdu6j,
                       label: Control.Monad.Zip.$fMonadZipPar1_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu6j: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdu6n; else goto cdu6m;
       cdu6n: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdu6m: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.495738304 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipPar1_closure" {
     Control.Monad.Zip.$fMonadZipPar1_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Generics.$fMonadPar1_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipPar2_closure+3;
         const Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.496407225 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZipU1_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZipU1_$cmzip_info;
 },
 Control.Monad.Zip.$fMonadZipU1_$cmzip_entry() //  []
         { info_tbl: [(cdu6s,
                       label: Control.Monad.Zip.$fMonadZipU1_$cmzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu6s: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.497060564 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU2_closure" {
     Control.Monad.Zip.$fMonadZipU2_closure:
         const (,)_con_info;
         const GHC.Generics.U1_closure+1;
         const GHC.Generics.U1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.497760748 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipU1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipU1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipU1_$cmunzip_entry() //  []
         { info_tbl: [(cdu6z,
                       label: Control.Monad.Zip.$fMonadZipU1_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu6z: // global
           R1 = Control.Monad.Zip.$fMonadZipU2_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.498468571 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_closure" {
     Control.Monad.Zip.$fMonadZipU1_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Generics.$fMonadU1_closure;
         const Control.Monad.Zip.$fMonadZipU1_$cmzip_closure+2;
         const Control.Monad.Zip.$fMonadZipU1_$cmzipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipU1_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.499161517 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZipProxy_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZipProxy_$cmzip_info;
 },
 Control.Monad.Zip.$fMonadZipProxy_$cmzip_entry() //  []
         { info_tbl: [(cdu6G,
                       label: Control.Monad.Zip.$fMonadZipProxy_$cmzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu6G: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.499906892 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy1_closure" {
     Control.Monad.Zip.$fMonadZipProxy1_closure:
         const (,)_con_info;
         const Data.Proxy.Proxy_closure+1;
         const Data.Proxy.Proxy_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.500562332 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipProxy_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipProxy_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipProxy_$cmunzip_entry() //  []
         { info_tbl: [(cdu6N,
                       label: Control.Monad.Zip.$fMonadZipProxy_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu6N: // global
           R1 = Control.Monad.Zip.$fMonadZipProxy1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.501399032 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_closure" {
     Control.Monad.Zip.$fMonadZipProxy_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Proxy.$fMonadProxy_closure;
         const Control.Monad.Zip.$fMonadZipProxy_$cmzip_closure+2;
         const Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipProxy_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.502174184 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt1_closure" {
     Control.Monad.Zip.$fMonadZipAlt1_closure:
         const Control.Monad.Zip.$fMonadZipAlt1_info;
 },
 Control.Monad.Zip.$fMonadZipAlt1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdu6U,
                       label: Control.Monad.Zip.$fMonadZipAlt1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu6U: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdu6V; else goto cdu6W;
       cdu6V: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdu6W: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.504028316 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip1_closure" {
     Control.Monad.Zip.$w$cmunzip1_closure:
         const Control.Monad.Zip.$w$cmunzip1_info;
 },
 $dMonad_sdtNr_entry() //  [R1]
         { info_tbl: [(cdu75,
                       label: $dMonad_sdtNr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu75: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdu76; else goto cdu77;
       cdu76: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu77: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtNE_entry() //  [R1, R2]
         { info_tbl: [(cdu7i,
                       label: sat_sdtNE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu7i: // global
           _sdtNz::P64 = R2;
           _sdtNE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdu7j; else goto cdu7k;
       cdu7k: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdu7m; else goto cdu7l;
       cdu7m: // global
           HpAlloc = 24;
           goto cdu7j;
       cdu7j: // global
           R2 = _sdtNz::P64;
           R1 = _sdtNE::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdu7l: // global
           _sdtNr::P64 = P64[_sdtNE::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtNz::P64;
           R2 = _sdtNr::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtNF_entry() //  [R1]
         { info_tbl: [(cdu7n,
                       label: sat_sdtNF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu7n: // global
           _sdtNF::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdu7o; else goto cdu7p;
       cdu7p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdu7r; else goto cdu7q;
       cdu7r: // global
           HpAlloc = 16;
           goto cdu7o;
       cdu7o: // global
           R1 = _sdtNF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu7q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtNF::P64;
           _sdtNq::P64 = P64[_sdtNF::P64 + 16];
           _sdtNr::P64 = P64[_sdtNF::P64 + 24];
           I64[Hp - 8] = sat_sdtNE_info;
           P64[Hp] = _sdtNr::P64;
           R2 = _sdtNr::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtNq::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtNx_entry() //  [R1, R2]
         { info_tbl: [(cdu7C,
                       label: sat_sdtNx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu7C: // global
           _sdtNs::P64 = R2;
           _sdtNx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdu7D; else goto cdu7E;
       cdu7E: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdu7G; else goto cdu7F;
       cdu7G: // global
           HpAlloc = 24;
           goto cdu7D;
       cdu7D: // global
           R2 = _sdtNs::P64;
           R1 = _sdtNx::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdu7F: // global
           _sdtNr::P64 = P64[_sdtNx::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtNs::P64;
           R2 = _sdtNr::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtNy_entry() //  [R1]
         { info_tbl: [(cdu7H,
                       label: sat_sdtNy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu7H: // global
           _sdtNy::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdu7I; else goto cdu7J;
       cdu7J: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdu7L; else goto cdu7K;
       cdu7L: // global
           HpAlloc = 16;
           goto cdu7I;
       cdu7I: // global
           R1 = _sdtNy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu7K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtNy::P64;
           _sdtNq::P64 = P64[_sdtNy::P64 + 16];
           _sdtNr::P64 = P64[_sdtNy::P64 + 24];
           I64[Hp - 8] = sat_sdtNx_info;
           P64[Hp] = _sdtNr::P64;
           R2 = _sdtNr::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtNq::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip1_entry() //  [R2, R3]
         { info_tbl: [(cdu7M,
                       label: Control.Monad.Zip.$w$cmunzip1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu7M: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdu7Q; else goto cdu7P;
       cdu7Q: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdu7P: // global
           I64[Hp - 80] = $dMonad_sdtNr_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtNF_info;
           P64[Hp - 40] = R3;
           _cdu71::P64 = Hp - 80;
           P64[Hp - 32] = _cdu71::P64;
           I64[Hp - 24] = sat_sdtNy_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdu71::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.506846158 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipAlt_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipAlt_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipAlt_$cmunzip_entry() //  [R2, R3]
         { info_tbl: [(cdu7Y,
                       label: Control.Monad.Zip.$fMonadZipAlt_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu7Y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdu7Z; else goto cdu80;
       cdu7Z: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt_$cmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdu80: // global
           I64[Sp - 8] = block_cdu7V_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip1_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdu7V() //  [R1, R2]
         { info_tbl: [(cdu7V,
                       label: block_cdu7V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu7V: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdu83; else goto cdu82;
       cdu83: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdu82: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.508566631 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt_closure" {
     Control.Monad.Zip.$fMonadZipAlt_closure:
         const Control.Monad.Zip.$fMonadZipAlt_info;
 },
 sat_sdtNS_entry() //  [R1, R2]
         { info_tbl: [(cdu8d,
                       label: sat_sdtNS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu8d: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZipAlt_$cmunzip_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtNR_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdu8l,
                       label: sat_sdtNR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu8l: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdu8m; else goto cdu8n;
       cdu8m: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdu8n: // global
           _sdtNO::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sdtNO::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sdtNN_entry() //  [R1, R2, R3]
         { info_tbl: [(cdu8t,
                       label: sat_sdtNN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu8t: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZipAlt1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtNM_entry() //  [R1]
         { info_tbl: [(cdu8A,
                       label: sat_sdtNM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu8A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdu8B; else goto cdu8C;
       cdu8B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu8C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipAlt_entry() //  [R2]
         { info_tbl: [(cdu8E,
                       label: Control.Monad.Zip.$fMonadZipAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu8E: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdu8I; else goto cdu8H;
       cdu8I: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdu8H: // global
           I64[Hp - 104] = sat_sdtNS_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdtNR_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdtNN_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtNM_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.510900834 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast2_closure" {
     Control.Monad.Zip.$fMonadZipLast2_closure:
         const Control.Monad.Zip.$fMonadZipLast2_info;
 },
 Control.Monad.Zip.$fMonadZipLast2_entry() //  [R2, R3]
         { info_tbl: [(cdu8U,
                       label: Control.Monad.Zip.$fMonadZipLast2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu8U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdu8V; else goto cdu8W;
       cdu8V: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipLast2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdu8W: // global
           I64[Sp - 16] = block_cdu8N_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udu9o; else goto cdu8O;
       udu9o: // global
           call _cdu8N(R1) args: 0, res: 0, upd: 0;
       cdu8O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdu8N() //  [R1]
         { info_tbl: [(cdu8N,
                       label: block_cdu8N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu8N: // global
           if (R1 & 7 == 1) goto udu9k; else goto cdu8S;
       udu9k: // global
           Sp = Sp + 16;
           call _cdu9a() args: 0, res: 0, upd: 0;
       cdu8S: // global
           I64[Sp] = block_cdu92_info;
           _sdtNW::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdtNW::P64;
           if (R1 & 7 != 0) goto udu9m; else goto cdu94;
       udu9m: // global
           call _cdu92(R1) args: 0, res: 0, upd: 0;
       cdu94: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdu92() //  [R1]
         { info_tbl: [(cdu92,
                       label: block_cdu92_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu92: // global
           if (R1 & 7 == 1) goto udu9l; else goto cdu9f;
       udu9l: // global
           Sp = Sp + 16;
           call _cdu9a() args: 0, res: 0, upd: 0;
       cdu9f: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdu9i; else goto cdu9h;
       cdu9i: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdu9h: // global
           _sdtNY::P64 = P64[R1 + 6];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sdtNY::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdu9a() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu9a: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.513545948 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipLast_$cmunzip_info;
 },
 sat_sdtOe_entry() //  [R1]
         { info_tbl: [(cdu9F,
                       label: sat_sdtOe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu9F: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdu9G; else goto cdu9H;
       cdu9G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdu9H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdu9y_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udu9S; else goto cdu9z;
       udu9S: // global
           call _cdu9y(R1) args: 0, res: 0, upd: 0;
       cdu9z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdu9y() //  [R1]
         { info_tbl: [(cdu9y,
                       label: block_cdu9y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu9y: // global
           if (R1 & 7 == 1) goto cdu9C; else goto cdu9D;
       cdu9C: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdu9D: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdu9R; else goto cdu9Q;
       cdu9R: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdu9Q: // global
           _sdtO9::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_1_upd_info;
           P64[Hp - 16] = _sdtO9::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtO7_entry() //  [R1]
         { info_tbl: [(cdua4,
                       label: sat_sdtO7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdua4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdua5; else goto cdua6;
       cdua5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdua6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdu9X_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduah; else goto cdu9Y;
       uduah: // global
           call _cdu9X(R1) args: 0, res: 0, upd: 0;
       cdu9Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdu9X() //  [R1]
         { info_tbl: [(cdu9X,
                       label: block_cdu9X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdu9X: // global
           if (R1 & 7 == 1) goto cdua1; else goto cdua2;
       cdua1: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdua2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cduag; else goto cduaf;
       cduag: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cduaf: // global
           _sdtO2::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdtO2::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipLast_$cmunzip_entry() //  [R2]
         { info_tbl: [(cduaj,
                       label: Control.Monad.Zip.$fMonadZipLast_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduaj: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cduan; else goto cduam;
       cduan: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduam: // global
           I64[Hp - 64] = sat_sdtOe_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdtO7_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.515591249 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast_closure" {
     Control.Monad.Zip.$fMonadZipLast_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Monoid.$fMonadLast_closure;
         const Control.Monad.Zip.$fMonadZipLast2_closure+2;
         const Control.Monad.Zip.$fMonadZipLast1_closure+3;
         const Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.516730626 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst2_closure" {
     Control.Monad.Zip.$fMonadZipFirst2_closure:
         const Control.Monad.Zip.$fMonadZipFirst2_info;
 },
 Control.Monad.Zip.$fMonadZipFirst2_entry() //  [R2, R3]
         { info_tbl: [(cduaz,
                       label: Control.Monad.Zip.$fMonadZipFirst2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduaz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduaA; else goto cduaB;
       cduaA: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipFirst2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cduaB: // global
           I64[Sp - 16] = block_cduas_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udub3; else goto cduat;
       udub3: // global
           call _cduas(R1) args: 0, res: 0, upd: 0;
       cduat: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduas() //  [R1]
         { info_tbl: [(cduas,
                       label: block_cduas_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduas: // global
           if (R1 & 7 == 1) goto uduaZ; else goto cduax;
       uduaZ: // global
           Sp = Sp + 16;
           call _cduaP() args: 0, res: 0, upd: 0;
       cduax: // global
           I64[Sp] = block_cduaH_info;
           _sdtOi::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdtOi::P64;
           if (R1 & 7 != 0) goto udub1; else goto cduaJ;
       udub1: // global
           call _cduaH(R1) args: 0, res: 0, upd: 0;
       cduaJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduaH() //  [R1]
         { info_tbl: [(cduaH,
                       label: block_cduaH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduaH: // global
           if (R1 & 7 == 1) goto udub0; else goto cduaU;
       udub0: // global
           Sp = Sp + 16;
           call _cduaP() args: 0, res: 0, upd: 0;
       cduaU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cduaX; else goto cduaW;
       cduaX: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cduaW: // global
           _sdtOk::P64 = P64[R1 + 6];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sdtOk::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cduaP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduaP: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.519082424 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipFirst_$cmunzip_info;
 },
 sat_sdtOA_entry() //  [R1]
         { info_tbl: [(cdubk,
                       label: sat_sdtOA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdubk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdubl; else goto cdubm;
       cdubl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdubm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdubd_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udubx; else goto cdube;
       udubx: // global
           call _cdubd(R1) args: 0, res: 0, upd: 0;
       cdube: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdubd() //  [R1]
         { info_tbl: [(cdubd,
                       label: block_cdubd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdubd: // global
           if (R1 & 7 == 1) goto cdubh; else goto cdubi;
       cdubh: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdubi: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdubw; else goto cdubv;
       cdubw: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdubv: // global
           _sdtOv::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_1_upd_info;
           P64[Hp - 16] = _sdtOv::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtOt_entry() //  [R1]
         { info_tbl: [(cdubJ,
                       label: sat_sdtOt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdubJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdubK; else goto cdubL;
       cdubK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdubL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdubC_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udubW; else goto cdubD;
       udubW: // global
           call _cdubC(R1) args: 0, res: 0, upd: 0;
       cdubD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdubC() //  [R1]
         { info_tbl: [(cdubC,
                       label: block_cdubC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdubC: // global
           if (R1 & 7 == 1) goto cdubG; else goto cdubH;
       cdubG: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdubH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdubV; else goto cdubU;
       cdubV: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdubU: // global
           _sdtOo::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdtOo::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipFirst_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdubY,
                       label: Control.Monad.Zip.$fMonadZipFirst_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdubY: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cduc2; else goto cduc1;
       cduc2: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduc1: // global
           I64[Hp - 64] = sat_sdtOA_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdtOt_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.521149827 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst_closure" {
     Control.Monad.Zip.$fMonadZipFirst_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Monoid.$fMonadFirst_closure;
         const Control.Monad.Zip.$fMonadZipFirst2_closure+2;
         const Control.Monad.Zip.$fMonadZipFirst1_closure+3;
         const Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.522367959 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzip_info;
 },
 Control.Monad.Zip.$fMonadZipMaybe_$cmzip_entry() //  [R2, R3]
         { info_tbl: [(cduce,
                       label: Control.Monad.Zip.$fMonadZipMaybe_$cmzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduce: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cducf; else goto cducg;
       cducf: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cducg: // global
           I64[Sp - 16] = block_cduc7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uducI; else goto cduc8;
       uducI: // global
           call _cduc7(R1) args: 0, res: 0, upd: 0;
       cduc8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduc7() //  [R1]
         { info_tbl: [(cduc7,
                       label: block_cduc7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduc7: // global
           if (R1 & 7 == 1) goto uducE; else goto cducc;
       uducE: // global
           Sp = Sp + 16;
           call _cducu() args: 0, res: 0, upd: 0;
       cducc: // global
           I64[Sp] = block_cducm_info;
           _sdtOE::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdtOE::P64;
           if (R1 & 7 != 0) goto uducG; else goto cduco;
       uducG: // global
           call _cducm(R1) args: 0, res: 0, upd: 0;
       cduco: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cducm() //  [R1]
         { info_tbl: [(cducm,
                       label: block_cducm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cducm: // global
           if (R1 & 7 == 1) goto uducF; else goto cducz;
       uducF: // global
           Sp = Sp + 16;
           call _cducu() args: 0, res: 0, upd: 0;
       cducz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cducC; else goto cducB;
       cducC: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cducB: // global
           _sdtOG::P64 = P64[R1 + 6];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sdtOG::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cducu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cducu: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.524702451 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_info;
 },
 sat_sdtOW_entry() //  [R1]
         { info_tbl: [(cducZ,
                       label: sat_sdtOW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cducZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdud0; else goto cdud1;
       cdud0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdud1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cducS_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ududc; else goto cducT;
       ududc: // global
           call _cducS(R1) args: 0, res: 0, upd: 0;
       cducT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cducS() //  [R1]
         { info_tbl: [(cducS,
                       label: block_cducS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cducS: // global
           if (R1 & 7 == 1) goto cducW; else goto cducX;
       cducW: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cducX: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdudb; else goto cduda;
       cdudb: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cduda: // global
           _sdtOR::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_1_upd_info;
           P64[Hp - 16] = _sdtOR::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtOP_entry() //  [R1]
         { info_tbl: [(cdudo,
                       label: sat_sdtOP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdudo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdudp; else goto cdudq;
       cdudp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdudq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdudh_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ududB; else goto cdudi;
       ududB: // global
           call _cdudh(R1) args: 0, res: 0, upd: 0;
       cdudi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdudh() //  [R1]
         { info_tbl: [(cdudh,
                       label: block_cdudh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdudh: // global
           if (R1 & 7 == 1) goto cdudl; else goto cdudm;
       cdudl: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdudm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdudA; else goto cdudz;
       cdudA: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdudz: // global
           _sdtOK::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdtOK::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdudD,
                       label: Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdudD: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdudH; else goto cdudG;
       cdudH: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdudG: // global
           I64[Hp - 64] = sat_sdtOW_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdtOP_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.526965023 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Base.$fMonadMaybe_closure;
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure+2;
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.527783447 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipProduct_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipProduct_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdudP,
                       label: Control.Monad.Zip.$fMonadZipProduct_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdudP: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdudT; else goto cdudS;
       cdudT: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdudS: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.528716267 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProduct_closure" {
     Control.Monad.Zip.$fMonadZipProduct_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Semigroup.Internal.$fMonadProduct_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipProduct1_closure+3;
         const Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.529538643 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipSum_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipSum_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdue1,
                       label: Control.Monad.Zip.$fMonadZipSum_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdue1: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdue5; else goto cdue4;
       cdue5: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdue4: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.530434291 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipSum_closure" {
     Control.Monad.Zip.$fMonadZipSum_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Semigroup.Internal.$fMonadSum_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipSum1_closure+3;
         const Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.531246017 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipDual_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipDual_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdued,
                       label: Control.Monad.Zip.$fMonadZipDual_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdued: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdueh; else goto cdueg;
       cdueh: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdueg: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.532172647 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipDual_closure" {
     Control.Monad.Zip.$fMonadZipDual_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Semigroup.Internal.$fMonadDual_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipDual1_closure+3;
         const Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.5327994 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipIdentity_closure" {
     Control.Monad.Zip.$fMonadZipIdentity_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Functor.Identity.$fMonadIdentity_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipIdentity1_closure+3;
         const Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.533396865 UTC

[section ""cstring" . Control.Monad.Zip.$trModule4_bytes" {
     Control.Monad.Zip.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.533969578 UTC

[section ""data" . Control.Monad.Zip.$trModule3_closure" {
     Control.Monad.Zip.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Zip.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.534584784 UTC

[section ""cstring" . Control.Monad.Zip.$trModule2_bytes" {
     Control.Monad.Zip.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100,46,90,105,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.535160367 UTC

[section ""data" . Control.Monad.Zip.$trModule1_closure" {
     Control.Monad.Zip.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Zip.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.535728128 UTC

[section ""data" . Control.Monad.Zip.$trModule_closure" {
     Control.Monad.Zip.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.Zip.$trModule3_closure+1;
         const Control.Monad.Zip.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.538575245 UTC

[section ""data" . $krep_rdtIk_closure" {
     $krep_rdtIk_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.539194288 UTC

[section ""data" . Control.Monad.Zip.$tcMonadZip1_closure" {
     Control.Monad.Zip.$tcMonadZip1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep_rdtIk_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.539786989 UTC

[section ""cstring" . Control.Monad.Zip.$tcMonadZip3_bytes" {
     Control.Monad.Zip.$tcMonadZip3_bytes:
         I8[] [77,111,110,97,100,90,105,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.540393166 UTC

[section ""data" . Control.Monad.Zip.$tcMonadZip2_closure" {
     Control.Monad.Zip.$tcMonadZip2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Zip.$tcMonadZip3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.540963228 UTC

[section ""data" . Control.Monad.Zip.$tcMonadZip_closure" {
     Control.Monad.Zip.$tcMonadZip_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.Zip.$trModule_closure+1;
         const Control.Monad.Zip.$tcMonadZip2_closure+1;
         const Control.Monad.Zip.$tcMonadZip1_closure+4;
         const 4362170845454097361;
         const 3840659568565778968;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.541918643 UTC

[section ""data" . Control.Monad.Zip.C:MonadZip_closure" {
     Control.Monad.Zip.C:MonadZip_closure:
         const Control.Monad.Zip.C:MonadZip_info;
 },
 Control.Monad.Zip.C:MonadZip_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cduen,
                       label: Control.Monad.Zip.C:MonadZip_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduen: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cduer; else goto cdueq;
       cduer: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.C:MonadZip_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdueq: // global
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.542864543 UTC

[Control.Monad.Zip.C:MonadZip_con_entry() //  [R1]
         { info_tbl: [(cdues,
                       label: Control.Monad.Zip.C:MonadZip_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,77,111,110,97,100,46,90,105,112,46,67,58,77,111,110,97,100,90,105,112]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdues: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.543510007 UTC

[section ""relreadonly" . SdtVj_srt" {
     SdtVj_srt:
         const GHC.Generics.$fMonadRec1_closure;
         const Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure;
         const GHC.Generics.$fMonad:*:_closure;
         const Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure;
         const Control.Monad.Zip.$fMonadZip:*:_closure;
         const Control.Monad.Zip.$fMonadZipRec1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.544125242 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:08:39.544899498 UTC

[section ""data" . Control.Monad.Zip.$p1MonadZip_closure" {
     Control.Monad.Zip.$p1MonadZip_closure:
         const Control.Monad.Zip.$p1MonadZip_info;
 },
 Control.Monad.Zip.$p1MonadZip_entry() //  [R2]
         { info_tbl: [(cdueA,
                       label: Control.Monad.Zip.$p1MonadZip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdueA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdueB; else goto cdueC;
       cdueB: // global
           R2 = R2;
           R1 = Control.Monad.Zip.$p1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdueC: // global
           I64[Sp - 8] = block_cduex_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udueG; else goto cduey;
       udueG: // global
           call _cduex(R1) args: 0, res: 0, upd: 0;
       cduey: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduex() //  [R1]
         { info_tbl: [(cduex,
                       label: block_cduex_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduex: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.546082954 UTC

[section ""data" . Control.Monad.Zip.mzip_closure" {
     Control.Monad.Zip.mzip_closure:
         const Control.Monad.Zip.mzip_info;
 },
 Control.Monad.Zip.mzip_entry() //  [R2]
         { info_tbl: [(cdueO,
                       label: Control.Monad.Zip.mzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdueO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdueP; else goto cdueQ;
       cdueP: // global
           R2 = R2;
           R1 = Control.Monad.Zip.mzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdueQ: // global
           I64[Sp - 8] = block_cdueL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udueU; else goto cdueM;
       udueU: // global
           call _cdueL(R1) args: 0, res: 0, upd: 0;
       cdueM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdueL() //  [R1]
         { info_tbl: [(cdueL,
                       label: block_cdueL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdueL: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.547204843 UTC

[section ""data" . Control.Monad.Zip.mzipWith_closure" {
     Control.Monad.Zip.mzipWith_closure:
         const Control.Monad.Zip.mzipWith_info;
 },
 Control.Monad.Zip.mzipWith_entry() //  [R2]
         { info_tbl: [(cduf2,
                       label: Control.Monad.Zip.mzipWith_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduf2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cduf3; else goto cduf4;
       cduf3: // global
           R2 = R2;
           R1 = Control.Monad.Zip.mzipWith_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduf4: // global
           I64[Sp - 8] = block_cdueZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uduf8; else goto cduf0;
       uduf8: // global
           call _cdueZ(R1) args: 0, res: 0, upd: 0;
       cduf0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdueZ() //  [R1]
         { info_tbl: [(cdueZ,
                       label: block_cdueZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdueZ: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.548377721 UTC

[section ""data" . Control.Monad.Zip.munzip_closure" {
     Control.Monad.Zip.munzip_closure:
         const Control.Monad.Zip.munzip_info;
 },
 Control.Monad.Zip.munzip_entry() //  [R2]
         { info_tbl: [(cdufg,
                       label: Control.Monad.Zip.munzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdufg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdufh; else goto cdufi;
       cdufh: // global
           R2 = R2;
           R1 = Control.Monad.Zip.munzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdufi: // global
           I64[Sp - 8] = block_cdufd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udufm; else goto cdufe;
       udufm: // global
           call _cdufd(R1) args: 0, res: 0, upd: 0;
       cdufe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdufd() //  [R1]
         { info_tbl: [(cdufd,
                       label: block_cdufd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdufd: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.549377239 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip[]_closure" {
     Control.Monad.Zip.$fMonadZip[]_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Base.$fMonad[]_closure;
         const GHC.List.zip_closure+2;
         const GHC.List.zipWith_closure+3;
         const GHC.List.unzip_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.55102985 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip3_closure" {
     Control.Monad.Zip.$w$cmunzip3_closure:
         const Control.Monad.Zip.$w$cmunzip3_info;
 },
 sat_sdtJ7_entry() //  [R1]
         { info_tbl: [(cdufy,
                       label: sat_sdtJ7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdufy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdufz; else goto cdufA;
       cdufz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdufA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdufv_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udufE; else goto cdufw;
       udufE: // global
           call _cdufv(R1) args: 0, res: 0, upd: 0;
       cdufw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdufv() //  [R1]
         { info_tbl: [(cdufv,
                       label: block_cdufv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdufv: // global
           R3 = P64[R1 + 15];
           R2 = Data.Tuple.snd_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtJ3_entry() //  [R1]
         { info_tbl: [(cdufM,
                       label: sat_sdtJ3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdufM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdufQ; else goto cdufR;
       cdufQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdufR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdufJ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udufZ; else goto cdufK;
       udufZ: // global
           call _cdufJ(R1) args: 0, res: 0, upd: 0;
       cdufK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdufJ() //  [R1]
         { info_tbl: [(cdufJ,
                       label: block_cdufJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdufJ: // global
           I64[Sp] = block_cdufP_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udufY; else goto cdufT;
       udufY: // global
           call _cdufP(R1) args: 0, res: 0, upd: 0;
       cdufT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdufP() //  [R1]
         { info_tbl: [(cdufP,
                       label: block_cdufP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdufP: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtIV_entry() //  [R1]
         { info_tbl: [(cdug8,
                       label: sat_sdtIV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdug8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdug9; else goto cduga;
       cdug9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduga: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdug5_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduge; else goto cdug6;
       uduge: // global
           call _cdug5(R1) args: 0, res: 0, upd: 0;
       cdug6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdug5() //  [R1]
         { info_tbl: [(cdug5,
                       label: block_cdug5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdug5: // global
           R3 = P64[R1 + 15];
           R2 = Data.Tuple.fst_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtIR_entry() //  [R1]
         { info_tbl: [(cdugm,
                       label: sat_sdtIR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdugm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdugq; else goto cdugr;
       cdugq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdugr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdugj_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udugz; else goto cdugk;
       udugz: // global
           call _cdugj(R1) args: 0, res: 0, upd: 0;
       cdugk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdugj() //  [R1]
         { info_tbl: [(cdugj,
                       label: block_cdugj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdugj: // global
           I64[Sp] = block_cdugp_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udugy; else goto cdugt;
       udugy: // global
           call _cdugp(R1) args: 0, res: 0, upd: 0;
       cdugt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdugp() //  [R1]
         { info_tbl: [(cdugp,
                       label: block_cdugp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdugp: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip3_entry() //  [R2]
         { info_tbl: [(cdugB,
                       label: Control.Monad.Zip.$w$cmunzip3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdugB: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdugF; else goto cdugE;
       cdugF: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdugE: // global
           I64[Hp - 136] = sat_sdtJ7_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sdtJ3_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = GHC.Base.:|_con_info;
           P64[Hp - 80] = Hp - 112;
           P64[Hp - 72] = Hp - 136;
           I64[Hp - 64] = sat_sdtIV_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdtIR_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = Hp - 87;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.554051088 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdugN,
                       label: Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdugN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdugO; else goto cdugP;
       cdugO: // global
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdugP: // global
           I64[Sp - 8] = block_cdugK_info;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdugK() //  [R1, R2]
         { info_tbl: [(cdugK,
                       label: block_cdugK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdugK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdugS; else goto cdugR;
       cdugS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdugR: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.555077421 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipNonEmpty_closure" {
     Control.Monad.Zip.$fMonadZipNonEmpty_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Base.$fMonadNonEmpty_closure;
         const Data.List.NonEmpty.zip_closure+2;
         const Data.List.NonEmpty.zipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.555820508 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdugX,
                       label: Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdugX: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.55663329 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipIdentity1_closure" {
     Control.Monad.Zip.$fMonadZipIdentity1_closure:
         const Control.Monad.Zip.$fMonadZipIdentity1_info;
 },
 Control.Monad.Zip.$fMonadZipIdentity1_entry() //  [R2, R3, R4]
         { info_tbl: [(cduh4,
                       label: Control.Monad.Zip.$fMonadZipIdentity1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduh4: // global
           _sdtJi::P64 = R3;
           R3 = R4;
           _sdtJh::P64 = R2;
           R2 = _sdtJi::P64;
           R1 = _sdtJh::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.557528026 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipDual1_closure" {
     Control.Monad.Zip.$fMonadZipDual1_closure:
         const Control.Monad.Zip.$fMonadZipDual1_info;
 },
 Control.Monad.Zip.$fMonadZipDual1_entry() //  [R2, R3, R4]
         { info_tbl: [(cduhb,
                       label: Control.Monad.Zip.$fMonadZipDual1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduhb: // global
           _sdtJl::P64 = R3;
           R3 = R4;
           _sdtJk::P64 = R2;
           R2 = _sdtJl::P64;
           R1 = _sdtJk::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.558392678 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipSum1_closure" {
     Control.Monad.Zip.$fMonadZipSum1_closure:
         const Control.Monad.Zip.$fMonadZipSum1_info;
 },
 Control.Monad.Zip.$fMonadZipSum1_entry() //  [R2, R3, R4]
         { info_tbl: [(cduhi,
                       label: Control.Monad.Zip.$fMonadZipSum1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduhi: // global
           _sdtJo::P64 = R3;
           R3 = R4;
           _sdtJn::P64 = R2;
           R2 = _sdtJo::P64;
           R1 = _sdtJn::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.559280703 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProduct1_closure" {
     Control.Monad.Zip.$fMonadZipProduct1_closure:
         const Control.Monad.Zip.$fMonadZipProduct1_info;
 },
 Control.Monad.Zip.$fMonadZipProduct1_entry() //  [R2, R3, R4]
         { info_tbl: [(cduhp,
                       label: Control.Monad.Zip.$fMonadZipProduct1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduhp: // global
           _sdtJr::P64 = R3;
           R3 = R4;
           _sdtJq::P64 = R2;
           R2 = _sdtJr::P64;
           R1 = _sdtJq::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.560644079 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_info;
 },
 Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cduhD,
                       label: Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduhD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduhE; else goto cduhF;
       cduhE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduhF: // global
           I64[Sp - 24] = block_cduhw_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udui7; else goto cduhx;
       udui7: // global
           call _cduhw(R1) args: 0, res: 0, upd: 0;
       cduhx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduhw() //  [R1]
         { info_tbl: [(cduhw,
                       label: block_cduhw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduhw: // global
           if (R1 & 7 == 1) goto udui3; else goto cduhB;
       udui3: // global
           Sp = Sp + 24;
           call _cduhT() args: 0, res: 0, upd: 0;
       cduhB: // global
           I64[Sp] = block_cduhL_info;
           _sdtJx::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdtJx::P64;
           if (R1 & 7 != 0) goto udui5; else goto cduhN;
       udui5: // global
           call _cduhL(R1) args: 0, res: 0, upd: 0;
       cduhN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduhL() //  [R1]
         { info_tbl: [(cduhL,
                       label: block_cduhL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduhL: // global
           if (R1 & 7 == 1) goto udui4; else goto cduhY;
       udui4: // global
           Sp = Sp + 24;
           call _cduhT() args: 0, res: 0, upd: 0;
       cduhY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdui1; else goto cdui0;
       cdui1: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdui0: // global
           _sdtJz::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sdtJz::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cduhT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduhT: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.56340271 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst1_closure" {
     Control.Monad.Zip.$fMonadZipFirst1_closure:
         const Control.Monad.Zip.$fMonadZipFirst1_info;
 },
 Control.Monad.Zip.$fMonadZipFirst1_entry() //  [R2, R3, R4]
         { info_tbl: [(cduik,
                       label: Control.Monad.Zip.$fMonadZipFirst1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduik: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduil; else goto cduim;
       cduil: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipFirst1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduim: // global
           I64[Sp - 24] = block_cduid_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduiO; else goto cduie;
       uduiO: // global
           call _cduid(R1) args: 0, res: 0, upd: 0;
       cduie: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduid() //  [R1]
         { info_tbl: [(cduid,
                       label: block_cduid_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduid: // global
           if (R1 & 7 == 1) goto uduiK; else goto cduii;
       uduiK: // global
           Sp = Sp + 24;
           call _cduiA() args: 0, res: 0, upd: 0;
       cduii: // global
           I64[Sp] = block_cduis_info;
           _sdtJF::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdtJF::P64;
           if (R1 & 7 != 0) goto uduiM; else goto cduiu;
       uduiM: // global
           call _cduis(R1) args: 0, res: 0, upd: 0;
       cduiu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduis() //  [R1]
         { info_tbl: [(cduis,
                       label: block_cduis_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduis: // global
           if (R1 & 7 == 1) goto uduiL; else goto cduiF;
       uduiL: // global
           Sp = Sp + 24;
           call _cduiA() args: 0, res: 0, upd: 0;
       cduiF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cduiI; else goto cduiH;
       cduiI: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cduiH: // global
           _sdtJH::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sdtJH::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cduiA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduiA: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.56550596 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast1_closure" {
     Control.Monad.Zip.$fMonadZipLast1_closure:
         const Control.Monad.Zip.$fMonadZipLast1_info;
 },
 Control.Monad.Zip.$fMonadZipLast1_entry() //  [R2, R3, R4]
         { info_tbl: [(cduj1,
                       label: Control.Monad.Zip.$fMonadZipLast1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduj1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduj2; else goto cduj3;
       cduj2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipLast1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduj3: // global
           I64[Sp - 24] = block_cduiU_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udujv; else goto cduiV;
       udujv: // global
           call _cduiU(R1) args: 0, res: 0, upd: 0;
       cduiV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduiU() //  [R1]
         { info_tbl: [(cduiU,
                       label: block_cduiU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduiU: // global
           if (R1 & 7 == 1) goto udujr; else goto cduiZ;
       udujr: // global
           Sp = Sp + 24;
           call _cdujh() args: 0, res: 0, upd: 0;
       cduiZ: // global
           I64[Sp] = block_cduj9_info;
           _sdtJN::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdtJN::P64;
           if (R1 & 7 != 0) goto udujt; else goto cdujb;
       udujt: // global
           call _cduj9(R1) args: 0, res: 0, upd: 0;
       cdujb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduj9() //  [R1]
         { info_tbl: [(cduj9,
                       label: block_cduj9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduj9: // global
           if (R1 & 7 == 1) goto udujs; else goto cdujm;
       udujs: // global
           Sp = Sp + 24;
           call _cdujh() args: 0, res: 0, upd: 0;
       cdujm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdujp; else goto cdujo;
       cdujp: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdujo: // global
           _sdtJP::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sdtJP::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdujh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdujh: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.567330483 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_info;
 },
 sat_sdtJS_entry() //  [R1]
         { info_tbl: [(cdujF,
                       label: sat_sdtJS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdujF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdujG; else goto cdujH;
       cdujG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdujH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_entry() //  [R2]
         { info_tbl: [(cdujI,
                       label: Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdujI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdujM; else goto cdujL;
       cdujM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdujL: // global
           I64[Hp - 16] = sat_sdtJS_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fMonadAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.568502973 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_info;
 },
 Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_entry() //  []
         { info_tbl: [(cdujR,
                       label: Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdujR: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.569380052 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZipU1_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZipU1_$cmzipWith_info;
 },
 Control.Monad.Zip.$fMonadZipU1_$cmzipWith_entry() //  []
         { info_tbl: [(cdujY,
                       label: Control.Monad.Zip.$fMonadZipU1_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdujY: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.570202184 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipPar2_closure" {
     Control.Monad.Zip.$fMonadZipPar2_closure:
         const Control.Monad.Zip.$fMonadZipPar2_info;
 },
 Control.Monad.Zip.$fMonadZipPar2_entry() //  [R2, R3, R4]
         { info_tbl: [(cduk5,
                       label: Control.Monad.Zip.$fMonadZipPar2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduk5: // global
           _sdtK0::P64 = R3;
           R3 = R4;
           _sdtJZ::P64 = R2;
           R2 = _sdtK0::P64;
           R1 = _sdtJZ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.571207698 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_info;
         const 0;
 },
 sat_sdtK3_entry() //  [R1]
         { info_tbl: [(cdukg,
                       label: sat_sdtK3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdukg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdukh; else goto cduki;
       cdukh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduki: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_entry() //  [R2]
         { info_tbl: [(cdukj,
                       label: Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdukj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdukn; else goto cdukm;
       cdukn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdukm: // global
           I64[Hp - 16] = sat_sdtK3_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadRec1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.572552737 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_info;
 },
 sat_sdtK5_entry() //  [R1]
         { info_tbl: [(cdukw,
                       label: sat_sdtK5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdukw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdukx; else goto cduky;
       cdukx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduky: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_entry() //  [R2]
         { info_tbl: [(cdukz,
                       label: Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdukz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdukD; else goto cdukC;
       cdukD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdukC: // global
           I64[Hp - 16] = sat_sdtK5_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.574594252 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_info;
 },
 sat_sdtKi_entry() //  [R1]
         { info_tbl: [(cdukW,
                       label: sat_sdtKi_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdukW: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdukX; else goto cdukY;
       cdukX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdukY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdtKh_entry() //  [R1]
         { info_tbl: [(cdul3,
                       label: sat_sdtKh_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdul3: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdul4; else goto cdul5;
       cdul4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdul5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cdul6,
                       label: Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdul6: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdul8; else goto cdul9;
       cdul8: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdul9: // global
           I64[Sp - 40] = block_cdukI_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udulf; else goto cdukJ;
       udulf: // global
           call _cdukI(R1) args: 0, res: 0, upd: 0;
       cdukJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdukI() //  [R1]
         { info_tbl: [(cdukI,
                       label: block_cdukI_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdukI: // global
           I64[Sp - 8] = block_cdukN_info;
           _sdtKc::P64 = P64[R1 + 7];
           _sdtKd::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sdtKd::P64;
           P64[Sp + 32] = _sdtKc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udule; else goto cdukO;
       udule: // global
           call _cdukN(R1) args: 0, res: 0, upd: 0;
       cdukO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdukN() //  [R1]
         { info_tbl: [(cdukN,
                       label: block_cdukN_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdukN: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cduld; else goto cdulc;
       cduld: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdulc: // global
           _sdtKf::P64 = P64[R1 + 7];
           _sdtKg::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_sdtKi_info;
           P64[Hp - 96] = P64[Sp + 24];
           _sdtK8::P64 = P64[Sp + 32];
           P64[Hp - 88] = _sdtK8::P64;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sdtKg::P64;
           I64[Hp - 64] = sat_sdtKh_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _sdtK8::P64;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = _sdtKf::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.577051235 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_info;
         const 0;
 },
 sat_sdtKm_entry() //  [R1]
         { info_tbl: [(cdulo,
                       label: sat_sdtKm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdulo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdulp; else goto cdulq;
       cdulp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdulq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtKl_entry() //  [R1]
         { info_tbl: [(cdulv,
                       label: sat_sdtKl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdulv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdulw; else goto cdulx;
       cdulw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdulx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_entry() //  [R2, R3]
         { info_tbl: [(cduly,
                       label: Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduly: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdulC; else goto cdulB;
       cdulC: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdulB: // global
           I64[Hp - 40] = sat_sdtKm_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sdtKl_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fMonad:*:_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.579342523 UTC

[section ""data" . Control.Monad.Zip.$dmmunzip_closure" {
     Control.Monad.Zip.$dmmunzip_closure:
         const Control.Monad.Zip.$dmmunzip_info;
 },
 $dMonad_sdtKp_entry() //  [R1]
         { info_tbl: [(cdulL,
                       label: $dMonad_sdtKp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdulL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdulM; else goto cdulN;
       cdulM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdulN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtKC_entry() //  [R1, R2]
         { info_tbl: [(cdulY,
                       label: sat_sdtKC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdulY: // global
           _sdtKx::P64 = R2;
           _sdtKC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdulZ; else goto cdum0;
       cdum0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdum2; else goto cdum1;
       cdum2: // global
           HpAlloc = 24;
           goto cdulZ;
       cdulZ: // global
           R2 = _sdtKx::P64;
           R1 = _sdtKC::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdum1: // global
           _sdtKp::P64 = P64[_sdtKC::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtKx::P64;
           R2 = _sdtKp::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtKD_entry() //  [R1]
         { info_tbl: [(cdum3,
                       label: sat_sdtKD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdum3: // global
           _sdtKD::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdum4; else goto cdum5;
       cdum5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdum7; else goto cdum6;
       cdum7: // global
           HpAlloc = 16;
           goto cdum4;
       cdum4: // global
           R1 = _sdtKD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdum6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtKD::P64;
           _sdtKo::P64 = P64[_sdtKD::P64 + 16];
           _sdtKp::P64 = P64[_sdtKD::P64 + 24];
           I64[Hp - 8] = sat_sdtKC_info;
           P64[Hp] = _sdtKp::P64;
           R2 = _sdtKp::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtKo::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtKv_entry() //  [R1, R2]
         { info_tbl: [(cdumi,
                       label: sat_sdtKv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdumi: // global
           _sdtKq::P64 = R2;
           _sdtKv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdumj; else goto cdumk;
       cdumk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdumm; else goto cduml;
       cdumm: // global
           HpAlloc = 24;
           goto cdumj;
       cdumj: // global
           R2 = _sdtKq::P64;
           R1 = _sdtKv::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduml: // global
           _sdtKp::P64 = P64[_sdtKv::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtKq::P64;
           R2 = _sdtKp::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtKw_entry() //  [R1]
         { info_tbl: [(cdumn,
                       label: sat_sdtKw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdumn: // global
           _sdtKw::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdumo; else goto cdump;
       cdump: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdumr; else goto cdumq;
       cdumr: // global
           HpAlloc = 16;
           goto cdumo;
       cdumo: // global
           R1 = _sdtKw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdumq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtKw::P64;
           _sdtKo::P64 = P64[_sdtKw::P64 + 16];
           _sdtKp::P64 = P64[_sdtKw::P64 + 24];
           I64[Hp - 8] = sat_sdtKv_info;
           P64[Hp] = _sdtKp::P64;
           R2 = _sdtKp::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtKo::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$dmmunzip_entry() //  [R2, R3]
         { info_tbl: [(cdumt,
                       label: Control.Monad.Zip.$dmmunzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdumt: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdumx; else goto cdumw;
       cdumx: // global
           HpAlloc = 112;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$dmmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdumw: // global
           I64[Hp - 104] = $dMonad_sdtKp_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sdtKD_info;
           P64[Hp - 64] = R3;
           _cdulH::P64 = Hp - 104;
           P64[Hp - 56] = _cdulH::P64;
           I64[Hp - 48] = sat_sdtKw_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = _cdulH::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.58264134 UTC

[section ""data" . Control.Monad.Zip.$dmmzipWith_closure" {
     Control.Monad.Zip.$dmmzipWith_closure:
         const Control.Monad.Zip.$dmmzipWith_info;
 },
 sat_sdtKT_entry() //  [R1]
         { info_tbl: [(cdumR,
                       label: sat_sdtKT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdumR: // global
           _sdtKT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdumS; else goto cdumT;
       cdumT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdumV; else goto cdumU;
       cdumV: // global
           HpAlloc = 48;
           goto cdumS;
       cdumS: // global
           R1 = _sdtKT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdumU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtKT::P64;
           _sdtKF::P64 = P64[_sdtKT::P64 + 16];
           _sdtKK::P64 = P64[_sdtKT::P64 + 24];
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sdtKK::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtKK::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _sdtKF::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtKU_entry() //  [R1, R2]
         { info_tbl: [(cdumW,
                       label: sat_sdtKU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdumW: // global
           _sdtKK::P64 = R2;
           _sdtKU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdumX; else goto cdumY;
       cdumY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdun0; else goto cdumZ;
       cdun0: // global
           HpAlloc = 32;
           goto cdumX;
       cdumX: // global
           R2 = _sdtKK::P64;
           R1 = _sdtKU::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdumZ: // global
           _sdtKF::P64 = P64[_sdtKU::P64 + 7];
           _sdtKI::P64 = P64[_sdtKU::P64 + 15];
           I64[Hp - 24] = sat_sdtKT_info;
           P64[Hp - 8] = _sdtKF::P64;
           P64[Hp] = _sdtKK::P64;
           R2 = _sdtKI::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtKJ_entry() //  [R1]
         { info_tbl: [(cdun5,
                       label: sat_sdtKJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdun5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdun6; else goto cdun7;
       cdun6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdun7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Monad.Zip.mzip_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$dmmzipWith_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdun8,
                       label: Control.Monad.Zip.$dmmzipWith_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdun8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdun9; else goto cduna;
       cdun9: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$dmmzipWith_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduna: // global
           I64[Sp - 40] = block_cdumC_info;
           _sdtKE::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _sdtKE::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdumC() //  [R1]
         { info_tbl: [(cdumC,
                       label: block_cdumC_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdumC: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdund; else goto cdunc;
       cdund: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdunc: // global
           I64[Hp - 56] = sat_sdtKU_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdtKJ_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 55;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.584949562 UTC

[section ""data" . Control.Monad.Zip.$dmmzip_closure" {
     Control.Monad.Zip.$dmmzip_closure:
         const Control.Monad.Zip.$dmmzip_info;
 },
 Control.Monad.Zip.$dmmzip_entry() //  [R2]
         { info_tbl: [(cduni,
                       label: Control.Monad.Zip.$dmmzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduni: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdunj; else goto cdunk;
       cdunj: // global
           R2 = R2;
           R1 = Control.Monad.Zip.$dmmzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdunk: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Tuple.(,)_closure+2;
           Sp = Sp - 16;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.586701801 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cmzip_info;
 },
 sat_sdtL7_entry() //  [R1]
         { info_tbl: [(cdunD,
                       label: sat_sdtL7_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdunD: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdunE; else goto cdunF;
       cdunE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdunF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdtL6_entry() //  [R1]
         { info_tbl: [(cdunK,
                       label: sat_sdtL6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdunK: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdunL; else goto cdunM;
       cdunL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdunM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZip:*:_$cmzip_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdunN,
                       label: Control.Monad.Zip.$fMonadZip:*:_$cmzip_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdunN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdunP; else goto cdunQ;
       cdunP: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cmzip_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdunQ: // global
           I64[Sp - 32] = block_cdunp_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udunW; else goto cdunq;
       udunW: // global
           call _cdunp(R1) args: 0, res: 0, upd: 0;
       cdunq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdunp() //  [R1]
         { info_tbl: [(cdunp,
                       label: block_cdunp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdunp: // global
           I64[Sp - 8] = block_cdunu_info;
           _sdtL1::P64 = P64[R1 + 7];
           _sdtL2::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdtL2::P64;
           P64[Sp + 24] = _sdtL1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udunV; else goto cdunv;
       udunV: // global
           call _cdunu(R1) args: 0, res: 0, upd: 0;
       cdunv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdunu() //  [R1]
         { info_tbl: [(cdunu,
                       label: block_cdunu_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdunu: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdunU; else goto cdunT;
       cdunU: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdunT: // global
           _sdtL4::P64 = P64[R1 + 7];
           _sdtL5::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sdtL7_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sdtL5::P64;
           I64[Hp - 56] = sat_sdtL6_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdtL4::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.591390977 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip_closure" {
     Control.Monad.Zip.$w$cmunzip_closure:
         const Control.Monad.Zip.$w$cmunzip_info;
 },
 $dMonad_sdtLb_entry() //  [R1]
         { info_tbl: [(cduo5,
                       label: $dMonad_sdtLb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduo5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduo6; else goto cduo7;
       cduo6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduo7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl_sdtLc_entry() //  [R1]
         { info_tbl: [(cduoc,
                       label: lvl_sdtLc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduoc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduod; else goto cduoe;
       cduod: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduoe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dMonad1_sdtLd_entry() //  [R1]
         { info_tbl: [(cduoj,
                       label: $dMonad1_sdtLd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduoj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduok; else goto cduol;
       cduok: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduol: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl1_sdtLe_entry() //  [R1]
         { info_tbl: [(cduoq,
                       label: lvl1_sdtLe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduoq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduor; else goto cduos;
       cduor: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduos: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtLM_entry() //  [R1, R2]
         { info_tbl: [(cduoM,
                       label: sat_sdtLM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduoM: // global
           _sdtLH::P64 = R2;
           _sdtLM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduoN; else goto cduoO;
       cduoO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduoQ; else goto cduoP;
       cduoQ: // global
           HpAlloc = 24;
           goto cduoN;
       cduoN: // global
           R2 = _sdtLH::P64;
           R1 = _sdtLM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduoP: // global
           _sdtLc::P64 = P64[_sdtLM::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtLH::P64;
           R2 = _sdtLc::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtLN_entry() //  [R1]
         { info_tbl: [(cduoR,
                       label: sat_sdtLN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduoR: // global
           _sdtLN::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduoS; else goto cduoT;
       cduoT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduoV; else goto cduoU;
       cduoV: // global
           HpAlloc = 16;
           goto cduoS;
       cduoS: // global
           R1 = _sdtLN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduoU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtLN::P64;
           _sdtLb::P64 = P64[_sdtLN::P64 + 16];
           _sdtLc::P64 = P64[_sdtLN::P64 + 24];
           _sdtLz::P64 = P64[_sdtLN::P64 + 32];
           I64[Hp - 8] = sat_sdtLM_info;
           P64[Hp] = _sdtLc::P64;
           R2 = _sdtLb::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtLz::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtLF_entry() //  [R1, R2]
         { info_tbl: [(cdup6,
                       label: sat_sdtLF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdup6: // global
           _sdtLA::P64 = R2;
           _sdtLF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdup7; else goto cdup8;
       cdup8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdupa; else goto cdup9;
       cdupa: // global
           HpAlloc = 24;
           goto cdup7;
       cdup7: // global
           R2 = _sdtLA::P64;
           R1 = _sdtLF::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdup9: // global
           _sdtLe::P64 = P64[_sdtLF::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtLA::P64;
           R2 = _sdtLe::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtLG_entry() //  [R1]
         { info_tbl: [(cdupb,
                       label: sat_sdtLG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdupb: // global
           _sdtLG::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdupc; else goto cdupd;
       cdupd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdupf; else goto cdupe;
       cdupf: // global
           HpAlloc = 16;
           goto cdupc;
       cdupc: // global
           R1 = _sdtLG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdupe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtLG::P64;
           _sdtLd::P64 = P64[_sdtLG::P64 + 16];
           _sdtLe::P64 = P64[_sdtLG::P64 + 24];
           _sdtLy::P64 = P64[_sdtLG::P64 + 32];
           I64[Hp - 8] = sat_sdtLF_info;
           P64[Hp] = _sdtLe::P64;
           R2 = _sdtLd::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtLy::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtLO_entry() //  [R1]
         { info_tbl: [(cdupg,
                       label: sat_sdtLO_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdupg: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cdupi; else goto cdupj;
       cdupi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdupj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cduox_info;
           _sdtLb::P64 = P64[R1 + 24];
           _sdtLc::P64 = P64[R1 + 32];
           _sdtLd::P64 = P64[R1 + 40];
           _sdtLe::P64 = P64[R1 + 48];
           R1 = P64[R1 + 16];
           P64[Sp - 48] = _sdtLb::P64;
           P64[Sp - 40] = _sdtLc::P64;
           P64[Sp - 32] = _sdtLd::P64;
           P64[Sp - 24] = _sdtLe::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto udupn; else goto cduoy;
       udupn: // global
           call _cduox(R1) args: 0, res: 0, upd: 0;
       cduoy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cduox() //  [R1]
         { info_tbl: [(cduox,
                       label: block_cduox_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduox: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdupm; else goto cdupl;
       cdupm: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdupl: // global
           _sdtLy::P64 = P64[R1 + 7];
           _sdtLz::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sdtLN_info;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sdtLz::P64;
           I64[Hp - 56] = sat_sdtLG_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdtLy::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtLu_entry() //  [R1, R2]
         { info_tbl: [(cdupH,
                       label: sat_sdtLu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdupH: // global
           _sdtLp::P64 = R2;
           _sdtLu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdupI; else goto cdupJ;
       cdupJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdupL; else goto cdupK;
       cdupL: // global
           HpAlloc = 24;
           goto cdupI;
       cdupI: // global
           R2 = _sdtLp::P64;
           R1 = _sdtLu::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdupK: // global
           _sdtLc::P64 = P64[_sdtLu::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtLp::P64;
           R2 = _sdtLc::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtLv_entry() //  [R1]
         { info_tbl: [(cdupM,
                       label: sat_sdtLv_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdupM: // global
           _sdtLv::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdupN; else goto cdupO;
       cdupO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdupQ; else goto cdupP;
       cdupQ: // global
           HpAlloc = 16;
           goto cdupN;
       cdupN: // global
           R1 = _sdtLv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdupP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtLv::P64;
           _sdtLb::P64 = P64[_sdtLv::P64 + 16];
           _sdtLc::P64 = P64[_sdtLv::P64 + 24];
           _sdtLh::P64 = P64[_sdtLv::P64 + 32];
           I64[Hp - 8] = sat_sdtLu_info;
           P64[Hp] = _sdtLc::P64;
           R2 = _sdtLb::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtLh::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtLn_entry() //  [R1, R2]
         { info_tbl: [(cduq1,
                       label: sat_sdtLn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduq1: // global
           _sdtLi::P64 = R2;
           _sdtLn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduq2; else goto cduq3;
       cduq3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduq5; else goto cduq4;
       cduq5: // global
           HpAlloc = 24;
           goto cduq2;
       cduq2: // global
           R2 = _sdtLi::P64;
           R1 = _sdtLn::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduq4: // global
           _sdtLe::P64 = P64[_sdtLn::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtLi::P64;
           R2 = _sdtLe::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtLo_entry() //  [R1]
         { info_tbl: [(cduq6,
                       label: sat_sdtLo_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduq6: // global
           _sdtLo::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduq7; else goto cduq8;
       cduq8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduqa; else goto cduq9;
       cduqa: // global
           HpAlloc = 16;
           goto cduq7;
       cduq7: // global
           R1 = _sdtLo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduq9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtLo::P64;
           _sdtLd::P64 = P64[_sdtLo::P64 + 16];
           _sdtLe::P64 = P64[_sdtLo::P64 + 24];
           _sdtLg::P64 = P64[_sdtLo::P64 + 32];
           I64[Hp - 8] = sat_sdtLn_info;
           P64[Hp] = _sdtLe::P64;
           R2 = _sdtLd::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtLg::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtLw_entry() //  [R1]
         { info_tbl: [(cduqb,
                       label: sat_sdtLw_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduqb: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cduqd; else goto cduqe;
       cduqd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduqe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cdups_info;
           _sdtLb::P64 = P64[R1 + 24];
           _sdtLc::P64 = P64[R1 + 32];
           _sdtLd::P64 = P64[R1 + 40];
           _sdtLe::P64 = P64[R1 + 48];
           R1 = P64[R1 + 16];
           P64[Sp - 48] = _sdtLb::P64;
           P64[Sp - 40] = _sdtLc::P64;
           P64[Sp - 32] = _sdtLd::P64;
           P64[Sp - 24] = _sdtLe::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uduqi; else goto cdupt;
       uduqi: // global
           call _cdups(R1) args: 0, res: 0, upd: 0;
       cdupt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdups() //  [R1]
         { info_tbl: [(cdups,
                       label: block_cdups_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdups: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cduqh; else goto cduqg;
       cduqh: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cduqg: // global
           _sdtLg::P64 = P64[R1 + 7];
           _sdtLh::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sdtLv_info;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sdtLh::P64;
           I64[Hp - 56] = sat_sdtLo_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdtLg::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip_entry() //  [R2, R3, R4]
         { info_tbl: [(cduqj,
                       label: Control.Monad.Zip.$w$cmunzip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduqj: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cduqn; else goto cduqm;
       cduqn: // global
           HpAlloc = 208;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduqm: // global
           I64[Hp - 200] = $dMonad_sdtLb_info;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = lvl_sdtLc_info;
           _cduo1::P64 = Hp - 200;
           P64[Hp - 160] = _cduo1::P64;
           I64[Hp - 152] = $dMonad1_sdtLd_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = lvl1_sdtLe_info;
           _cduof::P64 = Hp - 152;
           P64[Hp - 112] = _cduof::P64;
           I64[Hp - 104] = sat_sdtLO_info;
           P64[Hp - 88] = R4;
           P64[Hp - 80] = _cduo1::P64;
           _cduo8::P64 = Hp - 176;
           P64[Hp - 72] = _cduo8::P64;
           P64[Hp - 64] = _cduof::P64;
           _cduom::P64 = Hp - 128;
           P64[Hp - 56] = _cduom::P64;
           I64[Hp - 48] = sat_sdtLw_info;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = _cduo1::P64;
           P64[Hp - 16] = _cduo8::P64;
           P64[Hp - 8] = _cduof::P64;
           P64[Hp] = _cduom::P64;
           R2 = Hp - 104;
           R1 = Hp - 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.598075053 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZip:*:_$cmunzip_entry() //  [R2, R3, R4]
         { info_tbl: [(cduqv,
                       label: Control.Monad.Zip.$fMonadZip:*:_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduqv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cduqw; else goto cduqx;
       cduqw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduqx: // global
           I64[Sp - 8] = block_cduqs_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cduqs() //  [R1, R2]
         { info_tbl: [(cduqs,
                       label: block_cduqs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduqs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduqA; else goto cduqz;
       cduqA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cduqz: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.599911816 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_closure" {
     Control.Monad.Zip.$fMonadZip:*:_closure:
         const Control.Monad.Zip.$fMonadZip:*:_info;
         const 0;
 },
 sat_sdtM0_entry() //  [R1, R2]
         { info_tbl: [(cduqK,
                       label: sat_sdtM0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduqK: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZip:*:_$cmunzip_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtLZ_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cduqS,
                       label: sat_sdtLZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduqS: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtLY_entry() //  [R1, R2, R3]
         { info_tbl: [(cdur0,
                       label: sat_sdtLY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdur0: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZip:*:_$cmzip_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtLX_entry() //  [R1]
         { info_tbl: [(cdur7,
                       label: sat_sdtLX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdur7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdur8; else goto cdur9;
       cdur8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdur9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_entry(R3,
                                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZip:*:_entry() //  [R2, R3]
         { info_tbl: [(cdurb,
                       label: Control.Monad.Zip.$fMonadZip:*:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdurb: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdurf; else goto cdure;
       cdurf: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdure: // global
           I64[Hp - 136] = sat_sdtM0_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sdtLZ_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sdtLY_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_sdtLX_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 86;
           P64[Hp - 8] = Hp - 109;
           P64[Hp] = Hp - 135;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.601852052 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM2_closure" {
     Control.Monad.Zip.$fMonadZipM2_closure:
         const Control.Monad.Zip.$fMonadZipM2_info;
 },
 Control.Monad.Zip.$fMonadZipM2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdurk,
                       label: Control.Monad.Zip.$fMonadZipM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdurk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdurl; else goto cdurm;
       cdurl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdurm: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.603697254 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip2_closure" {
     Control.Monad.Zip.$w$cmunzip2_closure:
         const Control.Monad.Zip.$w$cmunzip2_info;
 },
 $dMonad_sdtM6_entry() //  [R1]
         { info_tbl: [(cdurv,
                       label: $dMonad_sdtM6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdurv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdurw; else goto cdurx;
       cdurw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdurx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtMj_entry() //  [R1, R2]
         { info_tbl: [(cdurI,
                       label: sat_sdtMj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdurI: // global
           _sdtMe::P64 = R2;
           _sdtMj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdurJ; else goto cdurK;
       cdurK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdurM; else goto cdurL;
       cdurM: // global
           HpAlloc = 24;
           goto cdurJ;
       cdurJ: // global
           R2 = _sdtMe::P64;
           R1 = _sdtMj::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdurL: // global
           _sdtM6::P64 = P64[_sdtMj::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtMe::P64;
           R2 = _sdtM6::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtMk_entry() //  [R1]
         { info_tbl: [(cdurN,
                       label: sat_sdtMk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdurN: // global
           _sdtMk::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdurO; else goto cdurP;
       cdurP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdurR; else goto cdurQ;
       cdurR: // global
           HpAlloc = 16;
           goto cdurO;
       cdurO: // global
           R1 = _sdtMk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdurQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtMk::P64;
           _sdtM5::P64 = P64[_sdtMk::P64 + 16];
           _sdtM6::P64 = P64[_sdtMk::P64 + 24];
           I64[Hp - 8] = sat_sdtMj_info;
           P64[Hp] = _sdtM6::P64;
           R2 = _sdtM6::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtM5::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtMc_entry() //  [R1, R2]
         { info_tbl: [(cdus2,
                       label: sat_sdtMc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdus2: // global
           _sdtM7::P64 = R2;
           _sdtMc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdus3; else goto cdus4;
       cdus4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdus6; else goto cdus5;
       cdus6: // global
           HpAlloc = 24;
           goto cdus3;
       cdus3: // global
           R2 = _sdtM7::P64;
           R1 = _sdtMc::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdus5: // global
           _sdtM6::P64 = P64[_sdtMc::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtM7::P64;
           R2 = _sdtM6::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtMd_entry() //  [R1]
         { info_tbl: [(cdus7,
                       label: sat_sdtMd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdus7: // global
           _sdtMd::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdus8; else goto cdus9;
       cdus9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdusb; else goto cdusa;
       cdusb: // global
           HpAlloc = 16;
           goto cdus8;
       cdus8: // global
           R1 = _sdtMd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdusa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtMd::P64;
           _sdtM5::P64 = P64[_sdtMd::P64 + 16];
           _sdtM6::P64 = P64[_sdtMd::P64 + 24];
           I64[Hp - 8] = sat_sdtMc_info;
           P64[Hp] = _sdtM6::P64;
           R2 = _sdtM6::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtM5::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip2_entry() //  [R2, R3]
         { info_tbl: [(cdusc,
                       label: Control.Monad.Zip.$w$cmunzip2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdusc: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdusg; else goto cdusf;
       cdusg: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdusf: // global
           I64[Hp - 80] = $dMonad_sdtM6_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtMk_info;
           P64[Hp - 40] = R3;
           _cdurr::P64 = Hp - 80;
           P64[Hp - 32] = _cdurr::P64;
           I64[Hp - 24] = sat_sdtMd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdurr::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.606459455 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipM1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipM1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipM1_$cmunzip_entry() //  [R2, R3]
         { info_tbl: [(cduso,
                       label: Control.Monad.Zip.$fMonadZipM1_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduso: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdusp; else goto cdusq;
       cdusp: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM1_$cmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdusq: // global
           I64[Sp - 8] = block_cdusl_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip2_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdusl() //  [R1, R2]
         { info_tbl: [(cdusl,
                       label: block_cdusl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdusl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdust; else goto cduss;
       cdust: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cduss: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.610372776 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM1_closure" {
     Control.Monad.Zip.$fMonadZipM1_closure:
         const Control.Monad.Zip.$fMonadZipM1_info;
 },
 sat_sdtMx_entry() //  [R1, R2]
         { info_tbl: [(cdusD,
                       label: sat_sdtMx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdusD: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZipM1_$cmunzip_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtMw_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdusL,
                       label: sat_sdtMw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdusL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdusM; else goto cdusN;
       cdusM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdusN: // global
           _sdtMt::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sdtMt::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sdtMs_entry() //  [R1, R2, R3]
         { info_tbl: [(cdusT,
                       label: sat_sdtMs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdusT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZipM2_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtMr_entry() //  [R1]
         { info_tbl: [(cdut0,
                       label: sat_sdtMr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdut0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdut1; else goto cdut2;
       cdut1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdut2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipM1_entry() //  [R2]
         { info_tbl: [(cdut4,
                       label: Control.Monad.Zip.$fMonadZipM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdut4: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdut8; else goto cdut7;
       cdut8: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdut7: // global
           I64[Hp - 104] = sat_sdtMx_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdtMw_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdtMs_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtMr_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.612276478 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec2_closure" {
     Control.Monad.Zip.$fMonadZipRec2_closure:
         const Control.Monad.Zip.$fMonadZipRec2_info;
 },
 Control.Monad.Zip.$fMonadZipRec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdutd,
                       label: Control.Monad.Zip.$fMonadZipRec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdutd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdute; else goto cdutf;
       cdute: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdutf: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.614351457 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip4_closure" {
     Control.Monad.Zip.$w$cmunzip4_closure:
         const Control.Monad.Zip.$w$cmunzip4_info;
 },
 $dMonad_sdtMD_entry() //  [R1]
         { info_tbl: [(cduto,
                       label: $dMonad_sdtMD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduto: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdutp; else goto cdutq;
       cdutp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdutq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl_sdtMM_entry() //  [R1]
         { info_tbl: [(cdutz,
                       label: lvl_sdtMM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdutz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdutA; else goto cdutB;
       cdutA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdutB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtMS_entry() //  [R1, R2]
         { info_tbl: [(cdutI,
                       label: sat_sdtMS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdutI: // global
           _sdtMN::P64 = R2;
           _sdtMS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdutJ; else goto cdutK;
       cdutK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdutM; else goto cdutL;
       cdutM: // global
           HpAlloc = 24;
           goto cdutJ;
       cdutJ: // global
           R2 = _sdtMN::P64;
           R1 = _sdtMS::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdutL: // global
           _sdtMM::P64 = P64[_sdtMS::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtMN::P64;
           R2 = _sdtMM::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtMT_entry() //  [R1]
         { info_tbl: [(cdutN,
                       label: sat_sdtMT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdutN: // global
           _sdtMT::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdutO; else goto cdutP;
       cdutP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdutR; else goto cdutQ;
       cdutR: // global
           HpAlloc = 40;
           goto cdutO;
       cdutO: // global
           R1 = _sdtMT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdutQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtMT::P64;
           _sdtMC::P64 = P64[_sdtMT::P64 + 16];
           _sdtMD::P64 = P64[_sdtMT::P64 + 24];
           I64[Hp - 32] = lvl_sdtMM_info;
           P64[Hp - 16] = _sdtMD::P64;
           I64[Hp - 8] = sat_sdtMS_info;
           P64[Hp] = Hp - 32;
           R2 = _sdtMD::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtMC::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 lvl_sdtME_entry() //  [R1]
         { info_tbl: [(cduu0,
                       label: lvl_sdtME_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduu0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduu1; else goto cduu2;
       cduu1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduu2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtMK_entry() //  [R1, R2]
         { info_tbl: [(cduu9,
                       label: sat_sdtMK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduu9: // global
           _sdtMF::P64 = R2;
           _sdtMK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduua; else goto cduub;
       cduub: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduud; else goto cduuc;
       cduud: // global
           HpAlloc = 24;
           goto cduua;
       cduua: // global
           R2 = _sdtMF::P64;
           R1 = _sdtMK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduuc: // global
           _sdtME::P64 = P64[_sdtMK::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtMF::P64;
           R2 = _sdtME::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtML_entry() //  [R1]
         { info_tbl: [(cduue,
                       label: sat_sdtML_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduue: // global
           _sdtML::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduuf; else goto cduug;
       cduug: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cduui; else goto cduuh;
       cduui: // global
           HpAlloc = 40;
           goto cduuf;
       cduuf: // global
           R1 = _sdtML::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduuh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtML::P64;
           _sdtMC::P64 = P64[_sdtML::P64 + 16];
           _sdtMD::P64 = P64[_sdtML::P64 + 24];
           I64[Hp - 32] = lvl_sdtME_info;
           P64[Hp - 16] = _sdtMD::P64;
           I64[Hp - 8] = sat_sdtMK_info;
           P64[Hp] = Hp - 32;
           R2 = _sdtMD::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtMC::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip4_entry() //  [R2, R3]
         { info_tbl: [(cduuj,
                       label: Control.Monad.Zip.$w$cmunzip4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduuj: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cduun; else goto cduum;
       cduun: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cduum: // global
           I64[Hp - 80] = $dMonad_sdtMD_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtMT_info;
           P64[Hp - 40] = R3;
           _cdutk::P64 = Hp - 80;
           P64[Hp - 32] = _cdutk::P64;
           I64[Hp - 24] = sat_sdtML_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdutk::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.617528954 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipRec1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipRec1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipRec1_$cmunzip_entry() //  [R2, R3]
         { info_tbl: [(cduuv,
                       label: Control.Monad.Zip.$fMonadZipRec1_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduuv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cduuw; else goto cduux;
       cduuw: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec1_$cmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cduux: // global
           I64[Sp - 8] = block_cduus_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip4_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cduus() //  [R1, R2]
         { info_tbl: [(cduus,
                       label: block_cduus_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduus: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduuA; else goto cduuz;
       cduuA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cduuz: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.619240342 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec1_closure" {
     Control.Monad.Zip.$fMonadZipRec1_closure:
         const Control.Monad.Zip.$fMonadZipRec1_info;
         const 0;
 },
 sat_sdtN6_entry() //  [R1, R2]
         { info_tbl: [(cduuK,
                       label: sat_sdtN6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduuK: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZipRec1_$cmunzip_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtN5_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cduuS,
                       label: sat_sdtN5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduuS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cduuT; else goto cduuU;
       cduuT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduuU: // global
           _sdtN2::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sdtN2::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sdtN1_entry() //  [R1, R2, R3]
         { info_tbl: [(cduv0,
                       label: sat_sdtN1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduv0: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZipRec2_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtN0_entry() //  [R1]
         { info_tbl: [(cduv7,
                       label: sat_sdtN0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduv7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduv8; else goto cduv9;
       cduv8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduv9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipRec1_entry() //  [R2]
         { info_tbl: [(cduvb,
                       label: Control.Monad.Zip.$fMonadZipRec1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduvb: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cduvf; else goto cduve;
       cduvf: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduve: // global
           I64[Hp - 104] = sat_sdtN6_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdtN5_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdtN1_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtN0_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.621195312 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipPar1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipPar1_$cmunzip_entry() //  [R2]
         { info_tbl: [(cduvn,
                       label: Control.Monad.Zip.$fMonadZipPar1_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduvn: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cduvr; else goto cduvq;
       cduvr: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduvq: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.622239844 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipPar1_closure" {
     Control.Monad.Zip.$fMonadZipPar1_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Generics.$fMonadPar1_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipPar2_closure+3;
         const Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.622934449 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZipU1_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZipU1_$cmzip_info;
 },
 Control.Monad.Zip.$fMonadZipU1_$cmzip_entry() //  []
         { info_tbl: [(cduvw,
                       label: Control.Monad.Zip.$fMonadZipU1_$cmzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduvw: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.623649718 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU2_closure" {
     Control.Monad.Zip.$fMonadZipU2_closure:
         const (,)_con_info;
         const GHC.Generics.U1_closure+1;
         const GHC.Generics.U1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.62433433 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipU1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipU1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipU1_$cmunzip_entry() //  []
         { info_tbl: [(cduvD,
                       label: Control.Monad.Zip.$fMonadZipU1_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduvD: // global
           R1 = Control.Monad.Zip.$fMonadZipU2_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.625056333 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_closure" {
     Control.Monad.Zip.$fMonadZipU1_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Generics.$fMonadU1_closure;
         const Control.Monad.Zip.$fMonadZipU1_$cmzip_closure+2;
         const Control.Monad.Zip.$fMonadZipU1_$cmzipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipU1_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.628735308 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZipProxy_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZipProxy_$cmzip_info;
 },
 Control.Monad.Zip.$fMonadZipProxy_$cmzip_entry() //  []
         { info_tbl: [(cduvK,
                       label: Control.Monad.Zip.$fMonadZipProxy_$cmzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduvK: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.629521163 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy1_closure" {
     Control.Monad.Zip.$fMonadZipProxy1_closure:
         const (,)_con_info;
         const Data.Proxy.Proxy_closure+1;
         const Data.Proxy.Proxy_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.630273272 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipProxy_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipProxy_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipProxy_$cmunzip_entry() //  []
         { info_tbl: [(cduvR,
                       label: Control.Monad.Zip.$fMonadZipProxy_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduvR: // global
           R1 = Control.Monad.Zip.$fMonadZipProxy1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.631077846 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_closure" {
     Control.Monad.Zip.$fMonadZipProxy_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Proxy.$fMonadProxy_closure;
         const Control.Monad.Zip.$fMonadZipProxy_$cmzip_closure+2;
         const Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipProxy_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.631933011 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt1_closure" {
     Control.Monad.Zip.$fMonadZipAlt1_closure:
         const Control.Monad.Zip.$fMonadZipAlt1_info;
 },
 Control.Monad.Zip.$fMonadZipAlt1_entry() //  [R2, R3, R4]
         { info_tbl: [(cduvY,
                       label: Control.Monad.Zip.$fMonadZipAlt1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduvY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cduvZ; else goto cduw0;
       cduvZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduw0: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.633923635 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip1_closure" {
     Control.Monad.Zip.$w$cmunzip1_closure:
         const Control.Monad.Zip.$w$cmunzip1_info;
 },
 $dMonad_sdtNr_entry() //  [R1]
         { info_tbl: [(cduw9,
                       label: $dMonad_sdtNr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduw9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduwa; else goto cduwb;
       cduwa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduwb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtNE_entry() //  [R1, R2]
         { info_tbl: [(cduwm,
                       label: sat_sdtNE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduwm: // global
           _sdtNz::P64 = R2;
           _sdtNE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduwn; else goto cduwo;
       cduwo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduwq; else goto cduwp;
       cduwq: // global
           HpAlloc = 24;
           goto cduwn;
       cduwn: // global
           R2 = _sdtNz::P64;
           R1 = _sdtNE::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduwp: // global
           _sdtNr::P64 = P64[_sdtNE::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtNz::P64;
           R2 = _sdtNr::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtNF_entry() //  [R1]
         { info_tbl: [(cduwr,
                       label: sat_sdtNF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduwr: // global
           _sdtNF::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduws; else goto cduwt;
       cduwt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduwv; else goto cduwu;
       cduwv: // global
           HpAlloc = 16;
           goto cduws;
       cduws: // global
           R1 = _sdtNF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduwu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtNF::P64;
           _sdtNq::P64 = P64[_sdtNF::P64 + 16];
           _sdtNr::P64 = P64[_sdtNF::P64 + 24];
           I64[Hp - 8] = sat_sdtNE_info;
           P64[Hp] = _sdtNr::P64;
           R2 = _sdtNr::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtNq::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtNx_entry() //  [R1, R2]
         { info_tbl: [(cduwG,
                       label: sat_sdtNx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduwG: // global
           _sdtNs::P64 = R2;
           _sdtNx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduwH; else goto cduwI;
       cduwI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduwK; else goto cduwJ;
       cduwK: // global
           HpAlloc = 24;
           goto cduwH;
       cduwH: // global
           R2 = _sdtNs::P64;
           R1 = _sdtNx::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduwJ: // global
           _sdtNr::P64 = P64[_sdtNx::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtNs::P64;
           R2 = _sdtNr::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtNy_entry() //  [R1]
         { info_tbl: [(cduwL,
                       label: sat_sdtNy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduwL: // global
           _sdtNy::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduwM; else goto cduwN;
       cduwN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduwP; else goto cduwO;
       cduwP: // global
           HpAlloc = 16;
           goto cduwM;
       cduwM: // global
           R1 = _sdtNy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduwO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtNy::P64;
           _sdtNq::P64 = P64[_sdtNy::P64 + 16];
           _sdtNr::P64 = P64[_sdtNy::P64 + 24];
           I64[Hp - 8] = sat_sdtNx_info;
           P64[Hp] = _sdtNr::P64;
           R2 = _sdtNr::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtNq::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip1_entry() //  [R2, R3]
         { info_tbl: [(cduwQ,
                       label: Control.Monad.Zip.$w$cmunzip1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduwQ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cduwU; else goto cduwT;
       cduwU: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cduwT: // global
           I64[Hp - 80] = $dMonad_sdtNr_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtNF_info;
           P64[Hp - 40] = R3;
           _cduw5::P64 = Hp - 80;
           P64[Hp - 32] = _cduw5::P64;
           I64[Hp - 24] = sat_sdtNy_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cduw5::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.636817953 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipAlt_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipAlt_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipAlt_$cmunzip_entry() //  [R2, R3]
         { info_tbl: [(cdux2,
                       label: Control.Monad.Zip.$fMonadZipAlt_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdux2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdux3; else goto cdux4;
       cdux3: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt_$cmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdux4: // global
           I64[Sp - 8] = block_cduwZ_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip1_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cduwZ() //  [R1, R2]
         { info_tbl: [(cduwZ,
                       label: block_cduwZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduwZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdux7; else goto cdux6;
       cdux7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdux6: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.638815403 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt_closure" {
     Control.Monad.Zip.$fMonadZipAlt_closure:
         const Control.Monad.Zip.$fMonadZipAlt_info;
 },
 sat_sdtNS_entry() //  [R1, R2]
         { info_tbl: [(cduxh,
                       label: sat_sdtNS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduxh: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZipAlt_$cmunzip_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtNR_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cduxp,
                       label: sat_sdtNR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduxp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cduxq; else goto cduxr;
       cduxq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduxr: // global
           _sdtNO::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sdtNO::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sdtNN_entry() //  [R1, R2, R3]
         { info_tbl: [(cduxx,
                       label: sat_sdtNN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduxx: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZipAlt1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtNM_entry() //  [R1]
         { info_tbl: [(cduxE,
                       label: sat_sdtNM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduxE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduxF; else goto cduxG;
       cduxF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduxG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipAlt_entry() //  [R2]
         { info_tbl: [(cduxI,
                       label: Control.Monad.Zip.$fMonadZipAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduxI: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cduxM; else goto cduxL;
       cduxM: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduxL: // global
           I64[Hp - 104] = sat_sdtNS_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdtNR_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdtNN_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtNM_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.64118874 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast2_closure" {
     Control.Monad.Zip.$fMonadZipLast2_closure:
         const Control.Monad.Zip.$fMonadZipLast2_info;
 },
 Control.Monad.Zip.$fMonadZipLast2_entry() //  [R2, R3]
         { info_tbl: [(cduxY,
                       label: Control.Monad.Zip.$fMonadZipLast2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduxY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduxZ; else goto cduy0;
       cduxZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipLast2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cduy0: // global
           I64[Sp - 16] = block_cduxR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uduys; else goto cduxS;
       uduys: // global
           call _cduxR(R1) args: 0, res: 0, upd: 0;
       cduxS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduxR() //  [R1]
         { info_tbl: [(cduxR,
                       label: block_cduxR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduxR: // global
           if (R1 & 7 == 1) goto uduyo; else goto cduxW;
       uduyo: // global
           Sp = Sp + 16;
           call _cduye() args: 0, res: 0, upd: 0;
       cduxW: // global
           I64[Sp] = block_cduy6_info;
           _sdtNW::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdtNW::P64;
           if (R1 & 7 != 0) goto uduyq; else goto cduy8;
       uduyq: // global
           call _cduy6(R1) args: 0, res: 0, upd: 0;
       cduy8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduy6() //  [R1]
         { info_tbl: [(cduy6,
                       label: block_cduy6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduy6: // global
           if (R1 & 7 == 1) goto uduyp; else goto cduyj;
       uduyp: // global
           Sp = Sp + 16;
           call _cduye() args: 0, res: 0, upd: 0;
       cduyj: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cduym; else goto cduyl;
       cduym: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cduyl: // global
           _sdtNY::P64 = P64[R1 + 6];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sdtNY::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cduye() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduye: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.643585974 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipLast_$cmunzip_info;
 },
 sat_sdtOe_entry() //  [R1]
         { info_tbl: [(cduyJ,
                       label: sat_sdtOe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduyJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduyK; else goto cduyL;
       cduyK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduyL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cduyC_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduyW; else goto cduyD;
       uduyW: // global
           call _cduyC(R1) args: 0, res: 0, upd: 0;
       cduyD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cduyC() //  [R1]
         { info_tbl: [(cduyC,
                       label: block_cduyC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduyC: // global
           if (R1 & 7 == 1) goto cduyG; else goto cduyH;
       cduyG: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cduyH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cduyV; else goto cduyU;
       cduyV: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cduyU: // global
           _sdtO9::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_1_upd_info;
           P64[Hp - 16] = _sdtO9::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtO7_entry() //  [R1]
         { info_tbl: [(cduz8,
                       label: sat_sdtO7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduz8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduz9; else goto cduza;
       cduz9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduza: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cduz1_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduzl; else goto cduz2;
       uduzl: // global
           call _cduz1(R1) args: 0, res: 0, upd: 0;
       cduz2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cduz1() //  [R1]
         { info_tbl: [(cduz1,
                       label: block_cduz1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduz1: // global
           if (R1 & 7 == 1) goto cduz5; else goto cduz6;
       cduz5: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cduz6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cduzk; else goto cduzj;
       cduzk: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cduzj: // global
           _sdtO2::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdtO2::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipLast_$cmunzip_entry() //  [R2]
         { info_tbl: [(cduzn,
                       label: Control.Monad.Zip.$fMonadZipLast_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduzn: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cduzr; else goto cduzq;
       cduzr: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduzq: // global
           I64[Hp - 64] = sat_sdtOe_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdtO7_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.645735561 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast_closure" {
     Control.Monad.Zip.$fMonadZipLast_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Monoid.$fMonadLast_closure;
         const Control.Monad.Zip.$fMonadZipLast2_closure+2;
         const Control.Monad.Zip.$fMonadZipLast1_closure+3;
         const Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.646919364 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst2_closure" {
     Control.Monad.Zip.$fMonadZipFirst2_closure:
         const Control.Monad.Zip.$fMonadZipFirst2_info;
 },
 Control.Monad.Zip.$fMonadZipFirst2_entry() //  [R2, R3]
         { info_tbl: [(cduzD,
                       label: Control.Monad.Zip.$fMonadZipFirst2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduzD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduzE; else goto cduzF;
       cduzE: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipFirst2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cduzF: // global
           I64[Sp - 16] = block_cduzw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uduA7; else goto cduzx;
       uduA7: // global
           call _cduzw(R1) args: 0, res: 0, upd: 0;
       cduzx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduzw() //  [R1]
         { info_tbl: [(cduzw,
                       label: block_cduzw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduzw: // global
           if (R1 & 7 == 1) goto uduA3; else goto cduzB;
       uduA3: // global
           Sp = Sp + 16;
           call _cduzT() args: 0, res: 0, upd: 0;
       cduzB: // global
           I64[Sp] = block_cduzL_info;
           _sdtOi::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdtOi::P64;
           if (R1 & 7 != 0) goto uduA5; else goto cduzN;
       uduA5: // global
           call _cduzL(R1) args: 0, res: 0, upd: 0;
       cduzN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduzL() //  [R1]
         { info_tbl: [(cduzL,
                       label: block_cduzL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduzL: // global
           if (R1 & 7 == 1) goto uduA4; else goto cduzY;
       uduA4: // global
           Sp = Sp + 16;
           call _cduzT() args: 0, res: 0, upd: 0;
       cduzY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cduA1; else goto cduA0;
       cduA1: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cduA0: // global
           _sdtOk::P64 = P64[R1 + 6];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sdtOk::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cduzT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduzT: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.649556353 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipFirst_$cmunzip_info;
 },
 sat_sdtOA_entry() //  [R1]
         { info_tbl: [(cduAo,
                       label: sat_sdtOA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduAo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduAp; else goto cduAq;
       cduAp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduAq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cduAh_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduAB; else goto cduAi;
       uduAB: // global
           call _cduAh(R1) args: 0, res: 0, upd: 0;
       cduAi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cduAh() //  [R1]
         { info_tbl: [(cduAh,
                       label: block_cduAh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduAh: // global
           if (R1 & 7 == 1) goto cduAl; else goto cduAm;
       cduAl: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cduAm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cduAA; else goto cduAz;
       cduAA: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cduAz: // global
           _sdtOv::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_1_upd_info;
           P64[Hp - 16] = _sdtOv::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtOt_entry() //  [R1]
         { info_tbl: [(cduAN,
                       label: sat_sdtOt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduAN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduAO; else goto cduAP;
       cduAO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduAP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cduAG_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduB0; else goto cduAH;
       uduB0: // global
           call _cduAG(R1) args: 0, res: 0, upd: 0;
       cduAH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cduAG() //  [R1]
         { info_tbl: [(cduAG,
                       label: block_cduAG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduAG: // global
           if (R1 & 7 == 1) goto cduAK; else goto cduAL;
       cduAK: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cduAL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cduAZ; else goto cduAY;
       cduAZ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cduAY: // global
           _sdtOo::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdtOo::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipFirst_$cmunzip_entry() //  [R2]
         { info_tbl: [(cduB2,
                       label: Control.Monad.Zip.$fMonadZipFirst_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduB2: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cduB6; else goto cduB5;
       cduB6: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduB5: // global
           I64[Hp - 64] = sat_sdtOA_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdtOt_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.651707924 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst_closure" {
     Control.Monad.Zip.$fMonadZipFirst_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Monoid.$fMonadFirst_closure;
         const Control.Monad.Zip.$fMonadZipFirst2_closure+2;
         const Control.Monad.Zip.$fMonadZipFirst1_closure+3;
         const Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.652834705 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzip_info;
 },
 Control.Monad.Zip.$fMonadZipMaybe_$cmzip_entry() //  [R2, R3]
         { info_tbl: [(cduBi,
                       label: Control.Monad.Zip.$fMonadZipMaybe_$cmzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduBi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduBj; else goto cduBk;
       cduBj: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cduBk: // global
           I64[Sp - 16] = block_cduBb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uduBM; else goto cduBc;
       uduBM: // global
           call _cduBb(R1) args: 0, res: 0, upd: 0;
       cduBc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduBb() //  [R1]
         { info_tbl: [(cduBb,
                       label: block_cduBb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduBb: // global
           if (R1 & 7 == 1) goto uduBI; else goto cduBg;
       uduBI: // global
           Sp = Sp + 16;
           call _cduBy() args: 0, res: 0, upd: 0;
       cduBg: // global
           I64[Sp] = block_cduBq_info;
           _sdtOE::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdtOE::P64;
           if (R1 & 7 != 0) goto uduBK; else goto cduBs;
       uduBK: // global
           call _cduBq(R1) args: 0, res: 0, upd: 0;
       cduBs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduBq() //  [R1]
         { info_tbl: [(cduBq,
                       label: block_cduBq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduBq: // global
           if (R1 & 7 == 1) goto uduBJ; else goto cduBD;
       uduBJ: // global
           Sp = Sp + 16;
           call _cduBy() args: 0, res: 0, upd: 0;
       cduBD: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cduBG; else goto cduBF;
       cduBG: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cduBF: // global
           _sdtOG::P64 = P64[R1 + 6];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sdtOG::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cduBy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduBy: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.655235482 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_info;
 },
 sat_sdtOW_entry() //  [R1]
         { info_tbl: [(cduC3,
                       label: sat_sdtOW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduC3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduC4; else goto cduC5;
       cduC4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduC5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cduBW_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduCg; else goto cduBX;
       uduCg: // global
           call _cduBW(R1) args: 0, res: 0, upd: 0;
       cduBX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cduBW() //  [R1]
         { info_tbl: [(cduBW,
                       label: block_cduBW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduBW: // global
           if (R1 & 7 == 1) goto cduC0; else goto cduC1;
       cduC0: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cduC1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cduCf; else goto cduCe;
       cduCf: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cduCe: // global
           _sdtOR::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_1_upd_info;
           P64[Hp - 16] = _sdtOR::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtOP_entry() //  [R1]
         { info_tbl: [(cduCs,
                       label: sat_sdtOP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduCs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduCt; else goto cduCu;
       cduCt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduCu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cduCl_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduCF; else goto cduCm;
       uduCF: // global
           call _cduCl(R1) args: 0, res: 0, upd: 0;
       cduCm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cduCl() //  [R1]
         { info_tbl: [(cduCl,
                       label: block_cduCl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduCl: // global
           if (R1 & 7 == 1) goto cduCp; else goto cduCq;
       cduCp: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cduCq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cduCE; else goto cduCD;
       cduCE: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cduCD: // global
           _sdtOK::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdtOK::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_entry() //  [R2]
         { info_tbl: [(cduCH,
                       label: Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduCH: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cduCL; else goto cduCK;
       cduCL: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduCK: // global
           I64[Hp - 64] = sat_sdtOW_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdtOP_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.657377224 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Base.$fMonadMaybe_closure;
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure+2;
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.658256293 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipProduct_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipProduct_$cmunzip_entry() //  [R2]
         { info_tbl: [(cduCT,
                       label: Control.Monad.Zip.$fMonadZipProduct_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduCT: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cduCX; else goto cduCW;
       cduCX: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduCW: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.659186432 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProduct_closure" {
     Control.Monad.Zip.$fMonadZipProduct_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Semigroup.Internal.$fMonadProduct_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipProduct1_closure+3;
         const Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.659975146 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipSum_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipSum_$cmunzip_entry() //  [R2]
         { info_tbl: [(cduD5,
                       label: Control.Monad.Zip.$fMonadZipSum_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduD5: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cduD9; else goto cduD8;
       cduD9: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduD8: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.660829439 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipSum_closure" {
     Control.Monad.Zip.$fMonadZipSum_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Semigroup.Internal.$fMonadSum_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipSum1_closure+3;
         const Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.661706919 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipDual_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipDual_$cmunzip_entry() //  [R2]
         { info_tbl: [(cduDh,
                       label: Control.Monad.Zip.$fMonadZipDual_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduDh: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cduDl; else goto cduDk;
       cduDl: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduDk: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.66264185 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipDual_closure" {
     Control.Monad.Zip.$fMonadZipDual_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Semigroup.Internal.$fMonadDual_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipDual1_closure+3;
         const Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.663303406 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipIdentity_closure" {
     Control.Monad.Zip.$fMonadZipIdentity_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Functor.Identity.$fMonadIdentity_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipIdentity1_closure+3;
         const Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.663909292 UTC

[section ""cstring" . Control.Monad.Zip.$trModule4_bytes" {
     Control.Monad.Zip.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.664488526 UTC

[section ""data" . Control.Monad.Zip.$trModule3_closure" {
     Control.Monad.Zip.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Zip.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.665087093 UTC

[section ""cstring" . Control.Monad.Zip.$trModule2_bytes" {
     Control.Monad.Zip.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100,46,90,105,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.665817115 UTC

[section ""data" . Control.Monad.Zip.$trModule1_closure" {
     Control.Monad.Zip.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Zip.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.666383422 UTC

[section ""data" . Control.Monad.Zip.$trModule_closure" {
     Control.Monad.Zip.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.Zip.$trModule3_closure+1;
         const Control.Monad.Zip.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.666984748 UTC

[section ""data" . $krep_rdtIk_closure" {
     $krep_rdtIk_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.667541596 UTC

[section ""data" . Control.Monad.Zip.$tcMonadZip1_closure" {
     Control.Monad.Zip.$tcMonadZip1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep_rdtIk_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.668124012 UTC

[section ""cstring" . Control.Monad.Zip.$tcMonadZip3_bytes" {
     Control.Monad.Zip.$tcMonadZip3_bytes:
         I8[] [77,111,110,97,100,90,105,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.670820774 UTC

[section ""data" . Control.Monad.Zip.$tcMonadZip2_closure" {
     Control.Monad.Zip.$tcMonadZip2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Zip.$tcMonadZip3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.671420384 UTC

[section ""data" . Control.Monad.Zip.$tcMonadZip_closure" {
     Control.Monad.Zip.$tcMonadZip_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.Zip.$trModule_closure+1;
         const Control.Monad.Zip.$tcMonadZip2_closure+1;
         const Control.Monad.Zip.$tcMonadZip1_closure+4;
         const 4362170845454097361;
         const 3840659568565778968;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.672311274 UTC

[section ""data" . Control.Monad.Zip.C:MonadZip_closure" {
     Control.Monad.Zip.C:MonadZip_closure:
         const Control.Monad.Zip.C:MonadZip_info;
 },
 Control.Monad.Zip.C:MonadZip_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cduDr,
                       label: Control.Monad.Zip.C:MonadZip_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduDr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cduDv; else goto cduDu;
       cduDv: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.C:MonadZip_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduDu: // global
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.673522544 UTC

[Control.Monad.Zip.C:MonadZip_con_entry() //  [R1]
         { info_tbl: [(cduDw,
                       label: Control.Monad.Zip.C:MonadZip_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,77,111,110,97,100,46,90,105,112,46,67,58,77,111,110,97,100,90,105,112]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduDw: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.674222891 UTC

[section ""relreadonly" . SdtVj_srt" {
     SdtVj_srt:
         const GHC.Generics.$fMonadRec1_closure;
         const Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure;
         const GHC.Generics.$fMonad:*:_closure;
         const Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure;
         const Control.Monad.Zip.$fMonadZip:*:_closure;
         const Control.Monad.Zip.$fMonadZipRec1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.675264397 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:08:39.677092989 UTC

[section ""data" . Control.Monad.Zip.$p1MonadZip_closure" {
     Control.Monad.Zip.$p1MonadZip_closure:
         const Control.Monad.Zip.$p1MonadZip_info;
 },
 Control.Monad.Zip.$p1MonadZip_entry() //  [R2]
         { info_tbl: [(cduDF,
                       label: Control.Monad.Zip.$p1MonadZip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduDF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cduDG; else goto cduDH;
       cduDG: // global
           R2 = R2;
           R1 = Control.Monad.Zip.$p1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduDH: // global
           I64[Sp - 8] = block_cduDC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uduDL; else goto cduDD;
       uduDL: // global
           call _cduDC(R1) args: 0, res: 0, upd: 0;
       cduDD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduDC() //  [R1]
         { info_tbl: [(cduDC,
                       label: block_cduDC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduDC: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.683140271 UTC

[section ""data" . Control.Monad.Zip.mzip_closure" {
     Control.Monad.Zip.mzip_closure:
         const Control.Monad.Zip.mzip_info;
 },
 Control.Monad.Zip.mzip_entry() //  [R2]
         { info_tbl: [(cduE4,
                       label: Control.Monad.Zip.mzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduE4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cduE5; else goto cduE6;
       cduE5: // global
           R2 = R2;
           R1 = Control.Monad.Zip.mzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduE6: // global
           I64[Sp - 8] = block_cduE1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uduEa; else goto cduE2;
       uduEa: // global
           call _cduE1(R1) args: 0, res: 0, upd: 0;
       cduE2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduE1() //  [R1]
         { info_tbl: [(cduE1,
                       label: block_cduE1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduE1: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.689441555 UTC

[section ""data" . Control.Monad.Zip.mzipWith_closure" {
     Control.Monad.Zip.mzipWith_closure:
         const Control.Monad.Zip.mzipWith_info;
 },
 Control.Monad.Zip.mzipWith_entry() //  [R2]
         { info_tbl: [(cduEr,
                       label: Control.Monad.Zip.mzipWith_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduEr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cduEs; else goto cduEt;
       cduEs: // global
           R2 = R2;
           R1 = Control.Monad.Zip.mzipWith_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduEt: // global
           I64[Sp - 8] = block_cduEo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uduEx; else goto cduEp;
       uduEx: // global
           call _cduEo(R1) args: 0, res: 0, upd: 0;
       cduEp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduEo() //  [R1]
         { info_tbl: [(cduEo,
                       label: block_cduEo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduEo: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.694741732 UTC

[section ""data" . Control.Monad.Zip.munzip_closure" {
     Control.Monad.Zip.munzip_closure:
         const Control.Monad.Zip.munzip_info;
 },
 Control.Monad.Zip.munzip_entry() //  [R2]
         { info_tbl: [(cduEO,
                       label: Control.Monad.Zip.munzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduEO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cduEP; else goto cduEQ;
       cduEP: // global
           R2 = R2;
           R1 = Control.Monad.Zip.munzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduEQ: // global
           I64[Sp - 8] = block_cduEL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uduEU; else goto cduEM;
       uduEU: // global
           call _cduEL(R1) args: 0, res: 0, upd: 0;
       cduEM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduEL() //  [R1]
         { info_tbl: [(cduEL,
                       label: block_cduEL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduEL: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.700345987 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip[]_closure" {
     Control.Monad.Zip.$fMonadZip[]_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Base.$fMonad[]_closure;
         const GHC.List.zip_closure+2;
         const GHC.List.zipWith_closure+3;
         const GHC.List.unzip_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.703491496 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip3_closure" {
     Control.Monad.Zip.$w$cmunzip3_closure:
         const Control.Monad.Zip.$w$cmunzip3_info;
 },
 sat_sdtJ7_entry() //  [R1]
         { info_tbl: [(cduFg,
                       label: sat_sdtJ7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduFg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduFh; else goto cduFi;
       cduFh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduFi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cduFd_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduFm; else goto cduFe;
       uduFm: // global
           call _cduFd(R1) args: 0, res: 0, upd: 0;
       cduFe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cduFd() //  [R1]
         { info_tbl: [(cduFd,
                       label: block_cduFd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduFd: // global
           R3 = P64[R1 + 15];
           R2 = Data.Tuple.snd_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtJ3_entry() //  [R1]
         { info_tbl: [(cduFu,
                       label: sat_sdtJ3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduFu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduFy; else goto cduFz;
       cduFy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduFz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cduFr_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduFH; else goto cduFs;
       uduFH: // global
           call _cduFr(R1) args: 0, res: 0, upd: 0;
       cduFs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cduFr() //  [R1]
         { info_tbl: [(cduFr,
                       label: block_cduFr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduFr: // global
           I64[Sp] = block_cduFx_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto uduFG; else goto cduFB;
       uduFG: // global
           call _cduFx(R1) args: 0, res: 0, upd: 0;
       cduFB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cduFx() //  [R1]
         { info_tbl: [(cduFx,
                       label: block_cduFx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduFx: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtIV_entry() //  [R1]
         { info_tbl: [(cduFQ,
                       label: sat_sdtIV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduFQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduFR; else goto cduFS;
       cduFR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduFS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cduFN_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduFW; else goto cduFO;
       uduFW: // global
           call _cduFN(R1) args: 0, res: 0, upd: 0;
       cduFO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cduFN() //  [R1]
         { info_tbl: [(cduFN,
                       label: block_cduFN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduFN: // global
           R3 = P64[R1 + 15];
           R2 = Data.Tuple.fst_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtIR_entry() //  [R1]
         { info_tbl: [(cduG4,
                       label: sat_sdtIR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduG4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduG8; else goto cduG9;
       cduG8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduG9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cduG1_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduGh; else goto cduG2;
       uduGh: // global
           call _cduG1(R1) args: 0, res: 0, upd: 0;
       cduG2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cduG1() //  [R1]
         { info_tbl: [(cduG1,
                       label: block_cduG1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduG1: // global
           I64[Sp] = block_cduG7_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto uduGg; else goto cduGb;
       uduGg: // global
           call _cduG7(R1) args: 0, res: 0, upd: 0;
       cduGb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cduG7() //  [R1]
         { info_tbl: [(cduG7,
                       label: block_cduG7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduG7: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip3_entry() //  [R2]
         { info_tbl: [(cduGj,
                       label: Control.Monad.Zip.$w$cmunzip3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduGj: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cduGn; else goto cduGm;
       cduGn: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduGm: // global
           I64[Hp - 136] = sat_sdtJ7_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sdtJ3_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = GHC.Base.:|_con_info;
           P64[Hp - 80] = Hp - 112;
           P64[Hp - 72] = Hp - 136;
           I64[Hp - 64] = sat_sdtIV_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdtIR_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = Hp - 87;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.726111611 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_entry() //  [R2]
         { info_tbl: [(cduHi,
                       label: Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduHi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cduHj; else goto cduHk;
       cduHj: // global
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduHk: // global
           I64[Sp - 8] = block_cduHf_info;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cduHf() //  [R1, R2]
         { info_tbl: [(cduHf,
                       label: block_cduHf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduHf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduHn; else goto cduHm;
       cduHn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cduHm: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.731475691 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipNonEmpty_closure" {
     Control.Monad.Zip.$fMonadZipNonEmpty_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Base.$fMonadNonEmpty_closure;
         const Data.List.NonEmpty.zip_closure+2;
         const Data.List.NonEmpty.zipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.733546255 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_entry() //  [R2]
         { info_tbl: [(cduHC,
                       label: Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduHC: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.737074396 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipIdentity1_closure" {
     Control.Monad.Zip.$fMonadZipIdentity1_closure:
         const Control.Monad.Zip.$fMonadZipIdentity1_info;
 },
 Control.Monad.Zip.$fMonadZipIdentity1_entry() //  [R2, R3, R4]
         { info_tbl: [(cduHP,
                       label: Control.Monad.Zip.$fMonadZipIdentity1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduHP: // global
           _sdtJi::P64 = R3;
           R3 = R4;
           _sdtJh::P64 = R2;
           R2 = _sdtJi::P64;
           R1 = _sdtJh::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.741056717 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipDual1_closure" {
     Control.Monad.Zip.$fMonadZipDual1_closure:
         const Control.Monad.Zip.$fMonadZipDual1_info;
 },
 Control.Monad.Zip.$fMonadZipDual1_entry() //  [R2, R3, R4]
         { info_tbl: [(cduI0,
                       label: Control.Monad.Zip.$fMonadZipDual1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduI0: // global
           _sdtJl::P64 = R3;
           R3 = R4;
           _sdtJk::P64 = R2;
           R2 = _sdtJl::P64;
           R1 = _sdtJk::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.745207105 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipSum1_closure" {
     Control.Monad.Zip.$fMonadZipSum1_closure:
         const Control.Monad.Zip.$fMonadZipSum1_info;
 },
 Control.Monad.Zip.$fMonadZipSum1_entry() //  [R2, R3, R4]
         { info_tbl: [(cduIb,
                       label: Control.Monad.Zip.$fMonadZipSum1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduIb: // global
           _sdtJo::P64 = R3;
           R3 = R4;
           _sdtJn::P64 = R2;
           R2 = _sdtJo::P64;
           R1 = _sdtJn::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.74868984 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProduct1_closure" {
     Control.Monad.Zip.$fMonadZipProduct1_closure:
         const Control.Monad.Zip.$fMonadZipProduct1_info;
 },
 Control.Monad.Zip.$fMonadZipProduct1_entry() //  [R2, R3, R4]
         { info_tbl: [(cduIm,
                       label: Control.Monad.Zip.$fMonadZipProduct1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduIm: // global
           _sdtJr::P64 = R3;
           R3 = R4;
           _sdtJq::P64 = R2;
           R2 = _sdtJr::P64;
           R1 = _sdtJq::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.752986381 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_info;
 },
 Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cduIE,
                       label: Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduIE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduIF; else goto cduIG;
       cduIF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduIG: // global
           I64[Sp - 24] = block_cduIx_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduJ8; else goto cduIy;
       uduJ8: // global
           call _cduIx(R1) args: 0, res: 0, upd: 0;
       cduIy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduIx() //  [R1]
         { info_tbl: [(cduIx,
                       label: block_cduIx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduIx: // global
           if (R1 & 7 == 1) goto uduJ4; else goto cduIC;
       uduJ4: // global
           Sp = Sp + 24;
           call _cduIU() args: 0, res: 0, upd: 0;
       cduIC: // global
           I64[Sp] = block_cduIM_info;
           _sdtJx::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdtJx::P64;
           if (R1 & 7 != 0) goto uduJ6; else goto cduIO;
       uduJ6: // global
           call _cduIM(R1) args: 0, res: 0, upd: 0;
       cduIO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduIM() //  [R1]
         { info_tbl: [(cduIM,
                       label: block_cduIM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduIM: // global
           if (R1 & 7 == 1) goto uduJ5; else goto cduIZ;
       uduJ5: // global
           Sp = Sp + 24;
           call _cduIU() args: 0, res: 0, upd: 0;
       cduIZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cduJ2; else goto cduJ1;
       cduJ2: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cduJ1: // global
           _sdtJz::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sdtJz::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cduIU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduIU: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.762360548 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst1_closure" {
     Control.Monad.Zip.$fMonadZipFirst1_closure:
         const Control.Monad.Zip.$fMonadZipFirst1_info;
 },
 Control.Monad.Zip.$fMonadZipFirst1_entry() //  [R2, R3, R4]
         { info_tbl: [(cduJJ,
                       label: Control.Monad.Zip.$fMonadZipFirst1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduJJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduJK; else goto cduJL;
       cduJK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipFirst1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduJL: // global
           I64[Sp - 24] = block_cduJC_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduKd; else goto cduJD;
       uduKd: // global
           call _cduJC(R1) args: 0, res: 0, upd: 0;
       cduJD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduJC() //  [R1]
         { info_tbl: [(cduJC,
                       label: block_cduJC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduJC: // global
           if (R1 & 7 == 1) goto uduK9; else goto cduJH;
       uduK9: // global
           Sp = Sp + 24;
           call _cduJZ() args: 0, res: 0, upd: 0;
       cduJH: // global
           I64[Sp] = block_cduJR_info;
           _sdtJF::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdtJF::P64;
           if (R1 & 7 != 0) goto uduKb; else goto cduJT;
       uduKb: // global
           call _cduJR(R1) args: 0, res: 0, upd: 0;
       cduJT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduJR() //  [R1]
         { info_tbl: [(cduJR,
                       label: block_cduJR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduJR: // global
           if (R1 & 7 == 1) goto uduKa; else goto cduK4;
       uduKa: // global
           Sp = Sp + 24;
           call _cduJZ() args: 0, res: 0, upd: 0;
       cduK4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cduK7; else goto cduK6;
       cduK7: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cduK6: // global
           _sdtJH::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sdtJH::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cduJZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduJZ: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.771882876 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast1_closure" {
     Control.Monad.Zip.$fMonadZipLast1_closure:
         const Control.Monad.Zip.$fMonadZipLast1_info;
 },
 Control.Monad.Zip.$fMonadZipLast1_entry() //  [R2, R3, R4]
         { info_tbl: [(cduKO,
                       label: Control.Monad.Zip.$fMonadZipLast1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduKO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduKP; else goto cduKQ;
       cduKP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipLast1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduKQ: // global
           I64[Sp - 24] = block_cduKH_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduLi; else goto cduKI;
       uduLi: // global
           call _cduKH(R1) args: 0, res: 0, upd: 0;
       cduKI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduKH() //  [R1]
         { info_tbl: [(cduKH,
                       label: block_cduKH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduKH: // global
           if (R1 & 7 == 1) goto uduLe; else goto cduKM;
       uduLe: // global
           Sp = Sp + 24;
           call _cduL4() args: 0, res: 0, upd: 0;
       cduKM: // global
           I64[Sp] = block_cduKW_info;
           _sdtJN::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdtJN::P64;
           if (R1 & 7 != 0) goto uduLg; else goto cduKY;
       uduLg: // global
           call _cduKW(R1) args: 0, res: 0, upd: 0;
       cduKY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduKW() //  [R1]
         { info_tbl: [(cduKW,
                       label: block_cduKW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduKW: // global
           if (R1 & 7 == 1) goto uduLf; else goto cduL9;
       uduLf: // global
           Sp = Sp + 24;
           call _cduL4() args: 0, res: 0, upd: 0;
       cduL9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cduLc; else goto cduLb;
       cduLc: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cduLb: // global
           _sdtJP::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sdtJP::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cduL4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduL4: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.78216896 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_info;
 },
 sat_sdtJS_entry() //  [R1]
         { info_tbl: [(cduLQ,
                       label: sat_sdtJS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduLQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduLR; else goto cduLS;
       cduLR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduLS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_entry() //  [R2]
         { info_tbl: [(cduLT,
                       label: Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduLT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduLX; else goto cduLW;
       cduLX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduLW: // global
           I64[Hp - 16] = sat_sdtJS_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fMonadAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.787953036 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_info;
 },
 Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_entry() //  []
         { info_tbl: [(cduMa,
                       label: Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduMa: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.791302742 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZipU1_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZipU1_$cmzipWith_info;
 },
 Control.Monad.Zip.$fMonadZipU1_$cmzipWith_entry() //  []
         { info_tbl: [(cduMm,
                       label: Control.Monad.Zip.$fMonadZipU1_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduMm: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.794828142 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipPar2_closure" {
     Control.Monad.Zip.$fMonadZipPar2_closure:
         const Control.Monad.Zip.$fMonadZipPar2_info;
 },
 Control.Monad.Zip.$fMonadZipPar2_entry() //  [R2, R3, R4]
         { info_tbl: [(cduMy,
                       label: Control.Monad.Zip.$fMonadZipPar2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduMy: // global
           _sdtK0::P64 = R3;
           R3 = R4;
           _sdtJZ::P64 = R2;
           R2 = _sdtK0::P64;
           R1 = _sdtJZ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.798717219 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_info;
         const 0;
 },
 sat_sdtK3_entry() //  [R1]
         { info_tbl: [(cduMN,
                       label: sat_sdtK3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduMN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduMO; else goto cduMP;
       cduMO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduMP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_entry() //  [R2]
         { info_tbl: [(cduMQ,
                       label: Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduMQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduMU; else goto cduMT;
       cduMU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduMT: // global
           I64[Hp - 16] = sat_sdtK3_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadRec1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.804516931 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_info;
 },
 sat_sdtK5_entry() //  [R1]
         { info_tbl: [(cduNb,
                       label: sat_sdtK5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduNb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduNc; else goto cduNd;
       cduNc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduNd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_entry() //  [R2]
         { info_tbl: [(cduNe,
                       label: Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduNe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduNi; else goto cduNh;
       cduNi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduNh: // global
           I64[Hp - 16] = sat_sdtK5_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.810680571 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_info;
 },
 sat_sdtKi_entry() //  [R1]
         { info_tbl: [(cduNJ,
                       label: sat_sdtKi_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduNJ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cduNK; else goto cduNL;
       cduNK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduNL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdtKh_entry() //  [R1]
         { info_tbl: [(cduNQ,
                       label: sat_sdtKh_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduNQ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cduNR; else goto cduNS;
       cduNR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduNS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cduNT,
                       label: Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduNT: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cduNV; else goto cduNW;
       cduNV: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduNW: // global
           I64[Sp - 40] = block_cduNv_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uduO2; else goto cduNw;
       uduO2: // global
           call _cduNv(R1) args: 0, res: 0, upd: 0;
       cduNw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduNv() //  [R1]
         { info_tbl: [(cduNv,
                       label: block_cduNv_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduNv: // global
           I64[Sp - 8] = block_cduNA_info;
           _sdtKc::P64 = P64[R1 + 7];
           _sdtKd::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sdtKd::P64;
           P64[Sp + 32] = _sdtKc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uduO1; else goto cduNB;
       uduO1: // global
           call _cduNA(R1) args: 0, res: 0, upd: 0;
       cduNB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduNA() //  [R1]
         { info_tbl: [(cduNA,
                       label: block_cduNA_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduNA: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cduO0; else goto cduNZ;
       cduO0: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cduNZ: // global
           _sdtKf::P64 = P64[R1 + 7];
           _sdtKg::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_sdtKi_info;
           P64[Hp - 96] = P64[Sp + 24];
           _sdtK8::P64 = P64[Sp + 32];
           P64[Hp - 88] = _sdtK8::P64;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sdtKg::P64;
           I64[Hp - 64] = sat_sdtKh_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _sdtK8::P64;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = _sdtKf::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.824068501 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_info;
         const 0;
 },
 sat_sdtKm_entry() //  [R1]
         { info_tbl: [(cduOJ,
                       label: sat_sdtKm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduOJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduOK; else goto cduOL;
       cduOK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduOL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtKl_entry() //  [R1]
         { info_tbl: [(cduOQ,
                       label: sat_sdtKl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduOQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduOR; else goto cduOS;
       cduOR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduOS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_entry() //  [R2, R3]
         { info_tbl: [(cduOT,
                       label: Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduOT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cduOX; else goto cduOW;
       cduOX: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cduOW: // global
           I64[Hp - 40] = sat_sdtKm_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sdtKl_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fMonad:*:_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.832722623 UTC

[section ""data" . Control.Monad.Zip.$dmmunzip_closure" {
     Control.Monad.Zip.$dmmunzip_closure:
         const Control.Monad.Zip.$dmmunzip_info;
 },
 $dMonad_sdtKp_entry() //  [R1]
         { info_tbl: [(cduPi,
                       label: $dMonad_sdtKp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduPi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduPj; else goto cduPk;
       cduPj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduPk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtKC_entry() //  [R1, R2]
         { info_tbl: [(cduPv,
                       label: sat_sdtKC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduPv: // global
           _sdtKx::P64 = R2;
           _sdtKC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduPw; else goto cduPx;
       cduPx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduPz; else goto cduPy;
       cduPz: // global
           HpAlloc = 24;
           goto cduPw;
       cduPw: // global
           R2 = _sdtKx::P64;
           R1 = _sdtKC::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduPy: // global
           _sdtKp::P64 = P64[_sdtKC::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtKx::P64;
           R2 = _sdtKp::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtKD_entry() //  [R1]
         { info_tbl: [(cduPA,
                       label: sat_sdtKD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduPA: // global
           _sdtKD::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduPB; else goto cduPC;
       cduPC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduPE; else goto cduPD;
       cduPE: // global
           HpAlloc = 16;
           goto cduPB;
       cduPB: // global
           R1 = _sdtKD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduPD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtKD::P64;
           _sdtKo::P64 = P64[_sdtKD::P64 + 16];
           _sdtKp::P64 = P64[_sdtKD::P64 + 24];
           I64[Hp - 8] = sat_sdtKC_info;
           P64[Hp] = _sdtKp::P64;
           R2 = _sdtKp::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtKo::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtKv_entry() //  [R1, R2]
         { info_tbl: [(cduPP,
                       label: sat_sdtKv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduPP: // global
           _sdtKq::P64 = R2;
           _sdtKv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduPQ; else goto cduPR;
       cduPR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduPT; else goto cduPS;
       cduPT: // global
           HpAlloc = 24;
           goto cduPQ;
       cduPQ: // global
           R2 = _sdtKq::P64;
           R1 = _sdtKv::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduPS: // global
           _sdtKp::P64 = P64[_sdtKv::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtKq::P64;
           R2 = _sdtKp::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtKw_entry() //  [R1]
         { info_tbl: [(cduPU,
                       label: sat_sdtKw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduPU: // global
           _sdtKw::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduPV; else goto cduPW;
       cduPW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduPY; else goto cduPX;
       cduPY: // global
           HpAlloc = 16;
           goto cduPV;
       cduPV: // global
           R1 = _sdtKw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduPX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtKw::P64;
           _sdtKo::P64 = P64[_sdtKw::P64 + 16];
           _sdtKp::P64 = P64[_sdtKw::P64 + 24];
           I64[Hp - 8] = sat_sdtKv_info;
           P64[Hp] = _sdtKp::P64;
           R2 = _sdtKp::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtKo::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$dmmunzip_entry() //  [R2, R3]
         { info_tbl: [(cduQ0,
                       label: Control.Monad.Zip.$dmmunzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduQ0: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cduQ4; else goto cduQ3;
       cduQ4: // global
           HpAlloc = 112;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$dmmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cduQ3: // global
           I64[Hp - 104] = $dMonad_sdtKp_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sdtKD_info;
           P64[Hp - 64] = R3;
           _cduPe::P64 = Hp - 104;
           P64[Hp - 56] = _cduPe::P64;
           I64[Hp - 48] = sat_sdtKw_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = _cduPe::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.848241334 UTC

[section ""data" . Control.Monad.Zip.$dmmzipWith_closure" {
     Control.Monad.Zip.$dmmzipWith_closure:
         const Control.Monad.Zip.$dmmzipWith_info;
 },
 sat_sdtKT_entry() //  [R1]
         { info_tbl: [(cduQT,
                       label: sat_sdtKT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduQT: // global
           _sdtKT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduQU; else goto cduQV;
       cduQV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cduQX; else goto cduQW;
       cduQX: // global
           HpAlloc = 48;
           goto cduQU;
       cduQU: // global
           R1 = _sdtKT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduQW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtKT::P64;
           _sdtKF::P64 = P64[_sdtKT::P64 + 16];
           _sdtKK::P64 = P64[_sdtKT::P64 + 24];
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sdtKK::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtKK::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _sdtKF::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtKU_entry() //  [R1, R2]
         { info_tbl: [(cduQY,
                       label: sat_sdtKU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduQY: // global
           _sdtKK::P64 = R2;
           _sdtKU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduQZ; else goto cduR0;
       cduR0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cduR2; else goto cduR1;
       cduR2: // global
           HpAlloc = 32;
           goto cduQZ;
       cduQZ: // global
           R2 = _sdtKK::P64;
           R1 = _sdtKU::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduR1: // global
           _sdtKF::P64 = P64[_sdtKU::P64 + 7];
           _sdtKI::P64 = P64[_sdtKU::P64 + 15];
           I64[Hp - 24] = sat_sdtKT_info;
           P64[Hp - 8] = _sdtKF::P64;
           P64[Hp] = _sdtKK::P64;
           R2 = _sdtKI::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtKJ_entry() //  [R1]
         { info_tbl: [(cduR7,
                       label: sat_sdtKJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduR7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cduR8; else goto cduR9;
       cduR8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduR9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Monad.Zip.mzip_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$dmmzipWith_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cduRa,
                       label: Control.Monad.Zip.$dmmzipWith_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduRa: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cduRb; else goto cduRc;
       cduRb: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$dmmzipWith_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduRc: // global
           I64[Sp - 40] = block_cduQE_info;
           _sdtKE::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _sdtKE::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cduQE() //  [R1]
         { info_tbl: [(cduQE,
                       label: block_cduQE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduQE: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cduRf; else goto cduRe;
       cduRf: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cduRe: // global
           I64[Hp - 56] = sat_sdtKU_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdtKJ_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 55;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.861113796 UTC

[section ""data" . Control.Monad.Zip.$dmmzip_closure" {
     Control.Monad.Zip.$dmmzip_closure:
         const Control.Monad.Zip.$dmmzip_info;
 },
 Control.Monad.Zip.$dmmzip_entry() //  [R2]
         { info_tbl: [(cduRN,
                       label: Control.Monad.Zip.$dmmzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduRN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduRO; else goto cduRP;
       cduRO: // global
           R2 = R2;
           R1 = Control.Monad.Zip.$dmmzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduRP: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Tuple.(,)_closure+2;
           Sp = Sp - 16;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.865761354 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cmzip_info;
 },
 sat_sdtL7_entry() //  [R1]
         { info_tbl: [(cduSd,
                       label: sat_sdtL7_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduSd: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cduSe; else goto cduSf;
       cduSe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduSf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdtL6_entry() //  [R1]
         { info_tbl: [(cduSk,
                       label: sat_sdtL6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduSk: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cduSl; else goto cduSm;
       cduSl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduSm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZip:*:_$cmzip_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cduSn,
                       label: Control.Monad.Zip.$fMonadZip:*:_$cmzip_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduSn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cduSp; else goto cduSq;
       cduSp: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cmzip_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduSq: // global
           I64[Sp - 32] = block_cduRZ_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uduSw; else goto cduS0;
       uduSw: // global
           call _cduRZ(R1) args: 0, res: 0, upd: 0;
       cduS0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduRZ() //  [R1]
         { info_tbl: [(cduRZ,
                       label: block_cduRZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduRZ: // global
           I64[Sp - 8] = block_cduS4_info;
           _sdtL1::P64 = P64[R1 + 7];
           _sdtL2::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdtL2::P64;
           P64[Sp + 24] = _sdtL1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uduSv; else goto cduS5;
       uduSv: // global
           call _cduS4(R1) args: 0, res: 0, upd: 0;
       cduS5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduS4() //  [R1]
         { info_tbl: [(cduS4,
                       label: block_cduS4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduS4: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cduSu; else goto cduSt;
       cduSu: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cduSt: // global
           _sdtL4::P64 = P64[R1 + 7];
           _sdtL5::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sdtL7_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sdtL5::P64;
           I64[Hp - 56] = sat_sdtL6_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdtL4::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.880639419 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip_closure" {
     Control.Monad.Zip.$w$cmunzip_closure:
         const Control.Monad.Zip.$w$cmunzip_info;
 },
 $dMonad_sdtLb_entry() //  [R1]
         { info_tbl: [(cduTb,
                       label: $dMonad_sdtLb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduTb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduTc; else goto cduTd;
       cduTc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduTd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl_sdtLc_entry() //  [R1]
         { info_tbl: [(cduTi,
                       label: lvl_sdtLc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduTi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduTj; else goto cduTk;
       cduTj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduTk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dMonad1_sdtLd_entry() //  [R1]
         { info_tbl: [(cduTp,
                       label: $dMonad1_sdtLd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduTp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduTq; else goto cduTr;
       cduTq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduTr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl1_sdtLe_entry() //  [R1]
         { info_tbl: [(cduTw,
                       label: lvl1_sdtLe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduTw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduTx; else goto cduTy;
       cduTx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduTy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtLM_entry() //  [R1, R2]
         { info_tbl: [(cduTS,
                       label: sat_sdtLM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduTS: // global
           _sdtLH::P64 = R2;
           _sdtLM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduTT; else goto cduTU;
       cduTU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduTW; else goto cduTV;
       cduTW: // global
           HpAlloc = 24;
           goto cduTT;
       cduTT: // global
           R2 = _sdtLH::P64;
           R1 = _sdtLM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduTV: // global
           _sdtLc::P64 = P64[_sdtLM::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtLH::P64;
           R2 = _sdtLc::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtLN_entry() //  [R1]
         { info_tbl: [(cduTX,
                       label: sat_sdtLN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduTX: // global
           _sdtLN::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduTY; else goto cduTZ;
       cduTZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduU1; else goto cduU0;
       cduU1: // global
           HpAlloc = 16;
           goto cduTY;
       cduTY: // global
           R1 = _sdtLN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduU0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtLN::P64;
           _sdtLb::P64 = P64[_sdtLN::P64 + 16];
           _sdtLc::P64 = P64[_sdtLN::P64 + 24];
           _sdtLz::P64 = P64[_sdtLN::P64 + 32];
           I64[Hp - 8] = sat_sdtLM_info;
           P64[Hp] = _sdtLc::P64;
           R2 = _sdtLb::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtLz::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtLF_entry() //  [R1, R2]
         { info_tbl: [(cduUc,
                       label: sat_sdtLF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduUc: // global
           _sdtLA::P64 = R2;
           _sdtLF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduUd; else goto cduUe;
       cduUe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduUg; else goto cduUf;
       cduUg: // global
           HpAlloc = 24;
           goto cduUd;
       cduUd: // global
           R2 = _sdtLA::P64;
           R1 = _sdtLF::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduUf: // global
           _sdtLe::P64 = P64[_sdtLF::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtLA::P64;
           R2 = _sdtLe::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtLG_entry() //  [R1]
         { info_tbl: [(cduUh,
                       label: sat_sdtLG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduUh: // global
           _sdtLG::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduUi; else goto cduUj;
       cduUj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduUl; else goto cduUk;
       cduUl: // global
           HpAlloc = 16;
           goto cduUi;
       cduUi: // global
           R1 = _sdtLG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduUk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtLG::P64;
           _sdtLd::P64 = P64[_sdtLG::P64 + 16];
           _sdtLe::P64 = P64[_sdtLG::P64 + 24];
           _sdtLy::P64 = P64[_sdtLG::P64 + 32];
           I64[Hp - 8] = sat_sdtLF_info;
           P64[Hp] = _sdtLe::P64;
           R2 = _sdtLd::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtLy::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtLO_entry() //  [R1]
         { info_tbl: [(cduUm,
                       label: sat_sdtLO_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduUm: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cduUo; else goto cduUp;
       cduUo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduUp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cduTD_info;
           _sdtLb::P64 = P64[R1 + 24];
           _sdtLc::P64 = P64[R1 + 32];
           _sdtLd::P64 = P64[R1 + 40];
           _sdtLe::P64 = P64[R1 + 48];
           R1 = P64[R1 + 16];
           P64[Sp - 48] = _sdtLb::P64;
           P64[Sp - 40] = _sdtLc::P64;
           P64[Sp - 32] = _sdtLd::P64;
           P64[Sp - 24] = _sdtLe::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uduUt; else goto cduTE;
       uduUt: // global
           call _cduTD(R1) args: 0, res: 0, upd: 0;
       cduTE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cduTD() //  [R1]
         { info_tbl: [(cduTD,
                       label: block_cduTD_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduTD: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cduUs; else goto cduUr;
       cduUs: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cduUr: // global
           _sdtLy::P64 = P64[R1 + 7];
           _sdtLz::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sdtLN_info;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sdtLz::P64;
           I64[Hp - 56] = sat_sdtLG_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdtLy::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtLu_entry() //  [R1, R2]
         { info_tbl: [(cduUN,
                       label: sat_sdtLu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduUN: // global
           _sdtLp::P64 = R2;
           _sdtLu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduUO; else goto cduUP;
       cduUP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduUR; else goto cduUQ;
       cduUR: // global
           HpAlloc = 24;
           goto cduUO;
       cduUO: // global
           R2 = _sdtLp::P64;
           R1 = _sdtLu::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduUQ: // global
           _sdtLc::P64 = P64[_sdtLu::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtLp::P64;
           R2 = _sdtLc::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtLv_entry() //  [R1]
         { info_tbl: [(cduUS,
                       label: sat_sdtLv_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduUS: // global
           _sdtLv::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduUT; else goto cduUU;
       cduUU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduUW; else goto cduUV;
       cduUW: // global
           HpAlloc = 16;
           goto cduUT;
       cduUT: // global
           R1 = _sdtLv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduUV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtLv::P64;
           _sdtLb::P64 = P64[_sdtLv::P64 + 16];
           _sdtLc::P64 = P64[_sdtLv::P64 + 24];
           _sdtLh::P64 = P64[_sdtLv::P64 + 32];
           I64[Hp - 8] = sat_sdtLu_info;
           P64[Hp] = _sdtLc::P64;
           R2 = _sdtLb::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtLh::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtLn_entry() //  [R1, R2]
         { info_tbl: [(cduV7,
                       label: sat_sdtLn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduV7: // global
           _sdtLi::P64 = R2;
           _sdtLn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduV8; else goto cduV9;
       cduV9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduVb; else goto cduVa;
       cduVb: // global
           HpAlloc = 24;
           goto cduV8;
       cduV8: // global
           R2 = _sdtLi::P64;
           R1 = _sdtLn::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduVa: // global
           _sdtLe::P64 = P64[_sdtLn::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtLi::P64;
           R2 = _sdtLe::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtLo_entry() //  [R1]
         { info_tbl: [(cduVc,
                       label: sat_sdtLo_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduVc: // global
           _sdtLo::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduVd; else goto cduVe;
       cduVe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduVg; else goto cduVf;
       cduVg: // global
           HpAlloc = 16;
           goto cduVd;
       cduVd: // global
           R1 = _sdtLo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduVf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtLo::P64;
           _sdtLd::P64 = P64[_sdtLo::P64 + 16];
           _sdtLe::P64 = P64[_sdtLo::P64 + 24];
           _sdtLg::P64 = P64[_sdtLo::P64 + 32];
           I64[Hp - 8] = sat_sdtLn_info;
           P64[Hp] = _sdtLe::P64;
           R2 = _sdtLd::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtLg::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtLw_entry() //  [R1]
         { info_tbl: [(cduVh,
                       label: sat_sdtLw_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduVh: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cduVj; else goto cduVk;
       cduVj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduVk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cduUy_info;
           _sdtLb::P64 = P64[R1 + 24];
           _sdtLc::P64 = P64[R1 + 32];
           _sdtLd::P64 = P64[R1 + 40];
           _sdtLe::P64 = P64[R1 + 48];
           R1 = P64[R1 + 16];
           P64[Sp - 48] = _sdtLb::P64;
           P64[Sp - 40] = _sdtLc::P64;
           P64[Sp - 32] = _sdtLd::P64;
           P64[Sp - 24] = _sdtLe::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uduVo; else goto cduUz;
       uduVo: // global
           call _cduUy(R1) args: 0, res: 0, upd: 0;
       cduUz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cduUy() //  [R1]
         { info_tbl: [(cduUy,
                       label: block_cduUy_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduUy: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cduVn; else goto cduVm;
       cduVn: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cduVm: // global
           _sdtLg::P64 = P64[R1 + 7];
           _sdtLh::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sdtLv_info;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sdtLh::P64;
           I64[Hp - 56] = sat_sdtLo_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdtLg::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip_entry() //  [R2, R3, R4]
         { info_tbl: [(cduVp,
                       label: Control.Monad.Zip.$w$cmunzip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduVp: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cduVt; else goto cduVs;
       cduVt: // global
           HpAlloc = 208;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduVs: // global
           I64[Hp - 200] = $dMonad_sdtLb_info;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = lvl_sdtLc_info;
           _cduT7::P64 = Hp - 200;
           P64[Hp - 160] = _cduT7::P64;
           I64[Hp - 152] = $dMonad1_sdtLd_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = lvl1_sdtLe_info;
           _cduTl::P64 = Hp - 152;
           P64[Hp - 112] = _cduTl::P64;
           I64[Hp - 104] = sat_sdtLO_info;
           P64[Hp - 88] = R4;
           P64[Hp - 80] = _cduT7::P64;
           _cduTe::P64 = Hp - 176;
           P64[Hp - 72] = _cduTe::P64;
           P64[Hp - 64] = _cduTl::P64;
           _cduTs::P64 = Hp - 128;
           P64[Hp - 56] = _cduTs::P64;
           I64[Hp - 48] = sat_sdtLw_info;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = _cduT7::P64;
           P64[Hp - 16] = _cduTe::P64;
           P64[Hp - 8] = _cduTl::P64;
           P64[Hp] = _cduTs::P64;
           R2 = Hp - 104;
           R1 = Hp - 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.919769004 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZip:*:_$cmunzip_entry() //  [R2, R3, R4]
         { info_tbl: [(cduX4,
                       label: Control.Monad.Zip.$fMonadZip:*:_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduX4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cduX5; else goto cduX6;
       cduX5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduX6: // global
           I64[Sp - 8] = block_cduX1_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cduX1() //  [R1, R2]
         { info_tbl: [(cduX1,
                       label: block_cduX1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduX1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduX9; else goto cduX8;
       cduX9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cduX8: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.925978472 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_closure" {
     Control.Monad.Zip.$fMonadZip:*:_closure:
         const Control.Monad.Zip.$fMonadZip:*:_info;
         const 0;
 },
 sat_sdtM0_entry() //  [R1, R2]
         { info_tbl: [(cduXs,
                       label: sat_sdtM0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduXs: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZip:*:_$cmunzip_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtLZ_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cduXA,
                       label: sat_sdtLZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduXA: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtLY_entry() //  [R1, R2, R3]
         { info_tbl: [(cduXI,
                       label: sat_sdtLY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduXI: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZip:*:_$cmzip_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtLX_entry() //  [R1]
         { info_tbl: [(cduXP,
                       label: sat_sdtLX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduXP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduXQ; else goto cduXR;
       cduXQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduXR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_entry(R3,
                                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZip:*:_entry() //  [R2, R3]
         { info_tbl: [(cduXT,
                       label: Control.Monad.Zip.$fMonadZip:*:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduXT: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cduXX; else goto cduXW;
       cduXX: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cduXW: // global
           I64[Hp - 136] = sat_sdtM0_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sdtLZ_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sdtLY_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_sdtLX_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 86;
           P64[Hp - 8] = Hp - 109;
           P64[Hp] = Hp - 135;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.937008633 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM2_closure" {
     Control.Monad.Zip.$fMonadZipM2_closure:
         const Control.Monad.Zip.$fMonadZipM2_info;
 },
 Control.Monad.Zip.$fMonadZipM2_entry() //  [R2, R3, R4]
         { info_tbl: [(cduYo,
                       label: Control.Monad.Zip.$fMonadZipM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduYo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cduYp; else goto cduYq;
       cduYp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduYq: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.942088762 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip2_closure" {
     Control.Monad.Zip.$w$cmunzip2_closure:
         const Control.Monad.Zip.$w$cmunzip2_info;
 },
 $dMonad_sdtM6_entry() //  [R1]
         { info_tbl: [(cduYE,
                       label: $dMonad_sdtM6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduYE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduYF; else goto cduYG;
       cduYF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduYG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtMj_entry() //  [R1, R2]
         { info_tbl: [(cduYR,
                       label: sat_sdtMj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduYR: // global
           _sdtMe::P64 = R2;
           _sdtMj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduYS; else goto cduYT;
       cduYT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduYV; else goto cduYU;
       cduYV: // global
           HpAlloc = 24;
           goto cduYS;
       cduYS: // global
           R2 = _sdtMe::P64;
           R1 = _sdtMj::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduYU: // global
           _sdtM6::P64 = P64[_sdtMj::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtMe::P64;
           R2 = _sdtM6::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtMk_entry() //  [R1]
         { info_tbl: [(cduYW,
                       label: sat_sdtMk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduYW: // global
           _sdtMk::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduYX; else goto cduYY;
       cduYY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduZ0; else goto cduYZ;
       cduZ0: // global
           HpAlloc = 16;
           goto cduYX;
       cduYX: // global
           R1 = _sdtMk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduYZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtMk::P64;
           _sdtM5::P64 = P64[_sdtMk::P64 + 16];
           _sdtM6::P64 = P64[_sdtMk::P64 + 24];
           I64[Hp - 8] = sat_sdtMj_info;
           P64[Hp] = _sdtM6::P64;
           R2 = _sdtM6::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtM5::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtMc_entry() //  [R1, R2]
         { info_tbl: [(cduZb,
                       label: sat_sdtMc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduZb: // global
           _sdtM7::P64 = R2;
           _sdtMc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduZc; else goto cduZd;
       cduZd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduZf; else goto cduZe;
       cduZf: // global
           HpAlloc = 24;
           goto cduZc;
       cduZc: // global
           R2 = _sdtM7::P64;
           R1 = _sdtMc::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduZe: // global
           _sdtM6::P64 = P64[_sdtMc::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtM7::P64;
           R2 = _sdtM6::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtMd_entry() //  [R1]
         { info_tbl: [(cduZg,
                       label: sat_sdtMd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduZg: // global
           _sdtMd::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduZh; else goto cduZi;
       cduZi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduZk; else goto cduZj;
       cduZk: // global
           HpAlloc = 16;
           goto cduZh;
       cduZh: // global
           R1 = _sdtMd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduZj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtMd::P64;
           _sdtM5::P64 = P64[_sdtMd::P64 + 16];
           _sdtM6::P64 = P64[_sdtMd::P64 + 24];
           I64[Hp - 8] = sat_sdtMc_info;
           P64[Hp] = _sdtM6::P64;
           R2 = _sdtM6::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtM5::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip2_entry() //  [R2, R3]
         { info_tbl: [(cduZl,
                       label: Control.Monad.Zip.$w$cmunzip2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduZl: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cduZp; else goto cduZo;
       cduZp: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cduZo: // global
           I64[Hp - 80] = $dMonad_sdtM6_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtMk_info;
           P64[Hp - 40] = R3;
           _cduYA::P64 = Hp - 80;
           P64[Hp - 32] = _cduYA::P64;
           I64[Hp - 24] = sat_sdtMd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cduYA::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.957791281 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipM1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipM1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipM1_$cmunzip_entry() //  [R2, R3]
         { info_tbl: [(cdv00,
                       label: Control.Monad.Zip.$fMonadZipM1_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv00: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdv01; else goto cdv02;
       cdv01: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM1_$cmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv02: // global
           I64[Sp - 8] = block_cduZX_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip2_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cduZX() //  [R1, R2]
         { info_tbl: [(cduZX,
                       label: block_cduZX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduZX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdv05; else goto cdv04;
       cdv05: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdv04: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.964008175 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM1_closure" {
     Control.Monad.Zip.$fMonadZipM1_closure:
         const Control.Monad.Zip.$fMonadZipM1_info;
 },
 sat_sdtMx_entry() //  [R1, R2]
         { info_tbl: [(cdv0o,
                       label: sat_sdtMx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv0o: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZipM1_$cmunzip_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtMw_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdv0w,
                       label: sat_sdtMw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv0w: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdv0x; else goto cdv0y;
       cdv0x: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv0y: // global
           _sdtMt::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sdtMt::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sdtMs_entry() //  [R1, R2, R3]
         { info_tbl: [(cdv0E,
                       label: sat_sdtMs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv0E: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZipM2_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtMr_entry() //  [R1]
         { info_tbl: [(cdv0L,
                       label: sat_sdtMr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv0L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdv0M; else goto cdv0N;
       cdv0M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv0N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipM1_entry() //  [R2]
         { info_tbl: [(cdv0P,
                       label: Control.Monad.Zip.$fMonadZipM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv0P: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdv0T; else goto cdv0S;
       cdv0T: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdv0S: // global
           I64[Hp - 104] = sat_sdtMx_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdtMw_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdtMs_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtMr_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.97508371 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec2_closure" {
     Control.Monad.Zip.$fMonadZipRec2_closure:
         const Control.Monad.Zip.$fMonadZipRec2_info;
 },
 Control.Monad.Zip.$fMonadZipRec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdv1l,
                       label: Control.Monad.Zip.$fMonadZipRec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv1l: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdv1m; else goto cdv1n;
       cdv1m: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv1n: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.979955028 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip4_closure" {
     Control.Monad.Zip.$w$cmunzip4_closure:
         const Control.Monad.Zip.$w$cmunzip4_info;
 },
 $dMonad_sdtMD_entry() //  [R1]
         { info_tbl: [(cdv1B,
                       label: $dMonad_sdtMD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv1B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdv1C; else goto cdv1D;
       cdv1C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv1D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl_sdtMM_entry() //  [R1]
         { info_tbl: [(cdv1M,
                       label: lvl_sdtMM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv1M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdv1N; else goto cdv1O;
       cdv1N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv1O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtMS_entry() //  [R1, R2]
         { info_tbl: [(cdv1V,
                       label: sat_sdtMS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv1V: // global
           _sdtMN::P64 = R2;
           _sdtMS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdv1W; else goto cdv1X;
       cdv1X: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdv1Z; else goto cdv1Y;
       cdv1Z: // global
           HpAlloc = 24;
           goto cdv1W;
       cdv1W: // global
           R2 = _sdtMN::P64;
           R1 = _sdtMS::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdv1Y: // global
           _sdtMM::P64 = P64[_sdtMS::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtMN::P64;
           R2 = _sdtMM::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtMT_entry() //  [R1]
         { info_tbl: [(cdv20,
                       label: sat_sdtMT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv20: // global
           _sdtMT::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdv21; else goto cdv22;
       cdv22: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdv24; else goto cdv23;
       cdv24: // global
           HpAlloc = 40;
           goto cdv21;
       cdv21: // global
           R1 = _sdtMT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv23: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtMT::P64;
           _sdtMC::P64 = P64[_sdtMT::P64 + 16];
           _sdtMD::P64 = P64[_sdtMT::P64 + 24];
           I64[Hp - 32] = lvl_sdtMM_info;
           P64[Hp - 16] = _sdtMD::P64;
           I64[Hp - 8] = sat_sdtMS_info;
           P64[Hp] = Hp - 32;
           R2 = _sdtMD::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtMC::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 lvl_sdtME_entry() //  [R1]
         { info_tbl: [(cdv2d,
                       label: lvl_sdtME_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv2d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdv2e; else goto cdv2f;
       cdv2e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv2f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtMK_entry() //  [R1, R2]
         { info_tbl: [(cdv2m,
                       label: sat_sdtMK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv2m: // global
           _sdtMF::P64 = R2;
           _sdtMK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdv2n; else goto cdv2o;
       cdv2o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdv2q; else goto cdv2p;
       cdv2q: // global
           HpAlloc = 24;
           goto cdv2n;
       cdv2n: // global
           R2 = _sdtMF::P64;
           R1 = _sdtMK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdv2p: // global
           _sdtME::P64 = P64[_sdtMK::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtMF::P64;
           R2 = _sdtME::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtML_entry() //  [R1]
         { info_tbl: [(cdv2r,
                       label: sat_sdtML_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv2r: // global
           _sdtML::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdv2s; else goto cdv2t;
       cdv2t: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdv2v; else goto cdv2u;
       cdv2v: // global
           HpAlloc = 40;
           goto cdv2s;
       cdv2s: // global
           R1 = _sdtML::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv2u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtML::P64;
           _sdtMC::P64 = P64[_sdtML::P64 + 16];
           _sdtMD::P64 = P64[_sdtML::P64 + 24];
           I64[Hp - 32] = lvl_sdtME_info;
           P64[Hp - 16] = _sdtMD::P64;
           I64[Hp - 8] = sat_sdtMK_info;
           P64[Hp] = Hp - 32;
           R2 = _sdtMD::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtMC::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip4_entry() //  [R2, R3]
         { info_tbl: [(cdv2w,
                       label: Control.Monad.Zip.$w$cmunzip4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv2w: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdv2A; else goto cdv2z;
       cdv2A: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv2z: // global
           I64[Hp - 80] = $dMonad_sdtMD_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtMT_info;
           P64[Hp - 40] = R3;
           _cdv1x::P64 = Hp - 80;
           P64[Hp - 32] = _cdv1x::P64;
           I64[Hp - 24] = sat_sdtML_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdv1x::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.998731676 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipRec1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipRec1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipRec1_$cmunzip_entry() //  [R2, R3]
         { info_tbl: [(cdv3l,
                       label: Control.Monad.Zip.$fMonadZipRec1_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv3l: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdv3m; else goto cdv3n;
       cdv3m: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec1_$cmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv3n: // global
           I64[Sp - 8] = block_cdv3i_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip4_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdv3i() //  [R1, R2]
         { info_tbl: [(cdv3i,
                       label: block_cdv3i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv3i: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdv3q; else goto cdv3p;
       cdv3q: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdv3p: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.004630001 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec1_closure" {
     Control.Monad.Zip.$fMonadZipRec1_closure:
         const Control.Monad.Zip.$fMonadZipRec1_info;
         const 0;
 },
 sat_sdtN6_entry() //  [R1, R2]
         { info_tbl: [(cdv3J,
                       label: sat_sdtN6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv3J: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZipRec1_$cmunzip_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtN5_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdv3R,
                       label: sat_sdtN5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv3R: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdv3S; else goto cdv3T;
       cdv3S: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv3T: // global
           _sdtN2::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sdtN2::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sdtN1_entry() //  [R1, R2, R3]
         { info_tbl: [(cdv3Z,
                       label: sat_sdtN1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv3Z: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZipRec2_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtN0_entry() //  [R1]
         { info_tbl: [(cdv46,
                       label: sat_sdtN0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv46: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdv47; else goto cdv48;
       cdv47: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv48: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipRec1_entry() //  [R2]
         { info_tbl: [(cdv4a,
                       label: Control.Monad.Zip.$fMonadZipRec1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv4a: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdv4e; else goto cdv4d;
       cdv4e: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdv4d: // global
           I64[Hp - 104] = sat_sdtN6_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdtN5_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdtN1_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtN0_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.015771479 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipPar1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipPar1_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdv4J,
                       label: Control.Monad.Zip.$fMonadZipPar1_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv4J: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdv4N; else goto cdv4M;
       cdv4N: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdv4M: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.019500458 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipPar1_closure" {
     Control.Monad.Zip.$fMonadZipPar1_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Generics.$fMonadPar1_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipPar2_closure+3;
         const Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.021372947 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZipU1_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZipU1_$cmzip_info;
 },
 Control.Monad.Zip.$fMonadZipU1_$cmzip_entry() //  []
         { info_tbl: [(cdv50,
                       label: Control.Monad.Zip.$fMonadZipU1_$cmzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv50: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.025191745 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU2_closure" {
     Control.Monad.Zip.$fMonadZipU2_closure:
         const (,)_con_info;
         const GHC.Generics.U1_closure+1;
         const GHC.Generics.U1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.027401128 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipU1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipU1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipU1_$cmunzip_entry() //  []
         { info_tbl: [(cdv5d,
                       label: Control.Monad.Zip.$fMonadZipU1_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv5d: // global
           R1 = Control.Monad.Zip.$fMonadZipU2_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.030521451 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_closure" {
     Control.Monad.Zip.$fMonadZipU1_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Generics.$fMonadU1_closure;
         const Control.Monad.Zip.$fMonadZipU1_$cmzip_closure+2;
         const Control.Monad.Zip.$fMonadZipU1_$cmzipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipU1_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.032363516 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZipProxy_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZipProxy_$cmzip_info;
 },
 Control.Monad.Zip.$fMonadZipProxy_$cmzip_entry() //  []
         { info_tbl: [(cdv5q,
                       label: Control.Monad.Zip.$fMonadZipProxy_$cmzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv5q: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.035472719 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy1_closure" {
     Control.Monad.Zip.$fMonadZipProxy1_closure:
         const (,)_con_info;
         const Data.Proxy.Proxy_closure+1;
         const Data.Proxy.Proxy_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.037270373 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipProxy_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipProxy_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipProxy_$cmunzip_entry() //  []
         { info_tbl: [(cdv5D,
                       label: Control.Monad.Zip.$fMonadZipProxy_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv5D: // global
           R1 = Control.Monad.Zip.$fMonadZipProxy1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.040415988 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_closure" {
     Control.Monad.Zip.$fMonadZipProxy_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Proxy.$fMonadProxy_closure;
         const Control.Monad.Zip.$fMonadZipProxy_$cmzip_closure+2;
         const Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipProxy_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.042412707 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt1_closure" {
     Control.Monad.Zip.$fMonadZipAlt1_closure:
         const Control.Monad.Zip.$fMonadZipAlt1_info;
 },
 Control.Monad.Zip.$fMonadZipAlt1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdv5Q,
                       label: Control.Monad.Zip.$fMonadZipAlt1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv5Q: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdv5R; else goto cdv5S;
       cdv5R: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv5S: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.047091922 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip1_closure" {
     Control.Monad.Zip.$w$cmunzip1_closure:
         const Control.Monad.Zip.$w$cmunzip1_info;
 },
 $dMonad_sdtNr_entry() //  [R1]
         { info_tbl: [(cdv66,
                       label: $dMonad_sdtNr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv66: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdv67; else goto cdv68;
       cdv67: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv68: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtNE_entry() //  [R1, R2]
         { info_tbl: [(cdv6j,
                       label: sat_sdtNE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv6j: // global
           _sdtNz::P64 = R2;
           _sdtNE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdv6k; else goto cdv6l;
       cdv6l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdv6n; else goto cdv6m;
       cdv6n: // global
           HpAlloc = 24;
           goto cdv6k;
       cdv6k: // global
           R2 = _sdtNz::P64;
           R1 = _sdtNE::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdv6m: // global
           _sdtNr::P64 = P64[_sdtNE::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtNz::P64;
           R2 = _sdtNr::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtNF_entry() //  [R1]
         { info_tbl: [(cdv6o,
                       label: sat_sdtNF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv6o: // global
           _sdtNF::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdv6p; else goto cdv6q;
       cdv6q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdv6s; else goto cdv6r;
       cdv6s: // global
           HpAlloc = 16;
           goto cdv6p;
       cdv6p: // global
           R1 = _sdtNF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv6r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtNF::P64;
           _sdtNq::P64 = P64[_sdtNF::P64 + 16];
           _sdtNr::P64 = P64[_sdtNF::P64 + 24];
           I64[Hp - 8] = sat_sdtNE_info;
           P64[Hp] = _sdtNr::P64;
           R2 = _sdtNr::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtNq::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdtNx_entry() //  [R1, R2]
         { info_tbl: [(cdv6D,
                       label: sat_sdtNx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv6D: // global
           _sdtNs::P64 = R2;
           _sdtNx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdv6E; else goto cdv6F;
       cdv6F: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdv6H; else goto cdv6G;
       cdv6H: // global
           HpAlloc = 24;
           goto cdv6E;
       cdv6E: // global
           R2 = _sdtNs::P64;
           R1 = _sdtNx::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdv6G: // global
           _sdtNr::P64 = P64[_sdtNx::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtNs::P64;
           R2 = _sdtNr::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdtNy_entry() //  [R1]
         { info_tbl: [(cdv6I,
                       label: sat_sdtNy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv6I: // global
           _sdtNy::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdv6J; else goto cdv6K;
       cdv6K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdv6M; else goto cdv6L;
       cdv6M: // global
           HpAlloc = 16;
           goto cdv6J;
       cdv6J: // global
           R1 = _sdtNy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv6L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtNy::P64;
           _sdtNq::P64 = P64[_sdtNy::P64 + 16];
           _sdtNr::P64 = P64[_sdtNy::P64 + 24];
           I64[Hp - 8] = sat_sdtNx_info;
           P64[Hp] = _sdtNr::P64;
           R2 = _sdtNr::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtNq::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip1_entry() //  [R2, R3]
         { info_tbl: [(cdv6N,
                       label: Control.Monad.Zip.$w$cmunzip1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv6N: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdv6R; else goto cdv6Q;
       cdv6R: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv6Q: // global
           I64[Hp - 80] = $dMonad_sdtNr_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtNF_info;
           P64[Hp - 40] = R3;
           _cdv62::P64 = Hp - 80;
           P64[Hp - 32] = _cdv62::P64;
           I64[Hp - 24] = sat_sdtNy_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdv62::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.062698777 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipAlt_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipAlt_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipAlt_$cmunzip_entry() //  [R2, R3]
         { info_tbl: [(cdv7s,
                       label: Control.Monad.Zip.$fMonadZipAlt_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv7s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdv7t; else goto cdv7u;
       cdv7t: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt_$cmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv7u: // global
           I64[Sp - 8] = block_cdv7p_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip1_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdv7p() //  [R1, R2]
         { info_tbl: [(cdv7p,
                       label: block_cdv7p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv7p: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdv7x; else goto cdv7w;
       cdv7x: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdv7w: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.069115552 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt_closure" {
     Control.Monad.Zip.$fMonadZipAlt_closure:
         const Control.Monad.Zip.$fMonadZipAlt_info;
 },
 sat_sdtNS_entry() //  [R1, R2]
         { info_tbl: [(cdv7Q,
                       label: sat_sdtNS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv7Q: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZipAlt_$cmunzip_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtNR_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdv7Y,
                       label: sat_sdtNR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv7Y: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdv7Z; else goto cdv80;
       cdv7Z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv80: // global
           _sdtNO::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sdtNO::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sdtNN_entry() //  [R1, R2, R3]
         { info_tbl: [(cdv86,
                       label: sat_sdtNN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv86: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZipAlt1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdtNM_entry() //  [R1]
         { info_tbl: [(cdv8d,
                       label: sat_sdtNM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv8d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdv8e; else goto cdv8f;
       cdv8e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv8f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipAlt_entry() //  [R2]
         { info_tbl: [(cdv8h,
                       label: Control.Monad.Zip.$fMonadZipAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv8h: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdv8l; else goto cdv8k;
       cdv8l: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdv8k: // global
           I64[Hp - 104] = sat_sdtNS_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdtNR_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdtNN_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtNM_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.080302065 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast2_closure" {
     Control.Monad.Zip.$fMonadZipLast2_closure:
         const Control.Monad.Zip.$fMonadZipLast2_info;
 },
 Control.Monad.Zip.$fMonadZipLast2_entry() //  [R2, R3]
         { info_tbl: [(cdv8U,
                       label: Control.Monad.Zip.$fMonadZipLast2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv8U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdv8V; else goto cdv8W;
       cdv8V: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipLast2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv8W: // global
           I64[Sp - 16] = block_cdv8N_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udv9o; else goto cdv8O;
       udv9o: // global
           call _cdv8N(R1) args: 0, res: 0, upd: 0;
       cdv8O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdv8N() //  [R1]
         { info_tbl: [(cdv8N,
                       label: block_cdv8N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv8N: // global
           if (R1 & 7 == 1) goto udv9k; else goto cdv8S;
       udv9k: // global
           Sp = Sp + 16;
           call _cdv9a() args: 0, res: 0, upd: 0;
       cdv8S: // global
           I64[Sp] = block_cdv92_info;
           _sdtNW::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdtNW::P64;
           if (R1 & 7 != 0) goto udv9m; else goto cdv94;
       udv9m: // global
           call _cdv92(R1) args: 0, res: 0, upd: 0;
       cdv94: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdv92() //  [R1]
         { info_tbl: [(cdv92,
                       label: block_cdv92_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv92: // global
           if (R1 & 7 == 1) goto udv9l; else goto cdv9f;
       udv9l: // global
           Sp = Sp + 16;
           call _cdv9a() args: 0, res: 0, upd: 0;
       cdv9f: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdv9i; else goto cdv9h;
       cdv9i: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdv9h: // global
           _sdtNY::P64 = P64[R1 + 6];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sdtNY::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdv9a() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv9a: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.091815788 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipLast_$cmunzip_info;
 },
 sat_sdtOe_entry() //  [R1]
         { info_tbl: [(cdva2,
                       label: sat_sdtOe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdva2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdva3; else goto cdva4;
       cdva3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdva4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdv9V_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvaf; else goto cdv9W;
       udvaf: // global
           call _cdv9V(R1) args: 0, res: 0, upd: 0;
       cdv9W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdv9V() //  [R1]
         { info_tbl: [(cdv9V,
                       label: block_cdv9V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv9V: // global
           if (R1 & 7 == 1) goto cdv9Z; else goto cdva0;
       cdv9Z: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdva0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvae; else goto cdvad;
       cdvae: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvad: // global
           _sdtO9::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_1_upd_info;
           P64[Hp - 16] = _sdtO9::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtO7_entry() //  [R1]
         { info_tbl: [(cdvar,
                       label: sat_sdtO7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvar: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvas; else goto cdvat;
       cdvas: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvat: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvak_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvaE; else goto cdval;
       udvaE: // global
           call _cdvak(R1) args: 0, res: 0, upd: 0;
       cdval: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdvak() //  [R1]
         { info_tbl: [(cdvak,
                       label: block_cdvak_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvak: // global
           if (R1 & 7 == 1) goto cdvao; else goto cdvap;
       cdvao: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdvap: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvaD; else goto cdvaC;
       cdvaD: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvaC: // global
           _sdtO2::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdtO2::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipLast_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdvaG,
                       label: Control.Monad.Zip.$fMonadZipLast_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvaG: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdvaK; else goto cdvaJ;
       cdvaK: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvaJ: // global
           I64[Hp - 64] = sat_sdtOe_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdtO7_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.105178755 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast_closure" {
     Control.Monad.Zip.$fMonadZipLast_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Monoid.$fMonadLast_closure;
         const Control.Monad.Zip.$fMonadZipLast2_closure+2;
         const Control.Monad.Zip.$fMonadZipLast1_closure+3;
         const Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.107837438 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst2_closure" {
     Control.Monad.Zip.$fMonadZipFirst2_closure:
         const Control.Monad.Zip.$fMonadZipFirst2_info;
 },
 Control.Monad.Zip.$fMonadZipFirst2_entry() //  [R2, R3]
         { info_tbl: [(cdvbu,
                       label: Control.Monad.Zip.$fMonadZipFirst2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvbu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvbv; else goto cdvbw;
       cdvbv: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipFirst2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvbw: // global
           I64[Sp - 16] = block_cdvbn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udvbY; else goto cdvbo;
       udvbY: // global
           call _cdvbn(R1) args: 0, res: 0, upd: 0;
       cdvbo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvbn() //  [R1]
         { info_tbl: [(cdvbn,
                       label: block_cdvbn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvbn: // global
           if (R1 & 7 == 1) goto udvbU; else goto cdvbs;
       udvbU: // global
           Sp = Sp + 16;
           call _cdvbK() args: 0, res: 0, upd: 0;
       cdvbs: // global
           I64[Sp] = block_cdvbC_info;
           _sdtOi::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdtOi::P64;
           if (R1 & 7 != 0) goto udvbW; else goto cdvbE;
       udvbW: // global
           call _cdvbC(R1) args: 0, res: 0, upd: 0;
       cdvbE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvbC() //  [R1]
         { info_tbl: [(cdvbC,
                       label: block_cdvbC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvbC: // global
           if (R1 & 7 == 1) goto udvbV; else goto cdvbP;
       udvbV: // global
           Sp = Sp + 16;
           call _cdvbK() args: 0, res: 0, upd: 0;
       cdvbP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvbS; else goto cdvbR;
       cdvbS: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvbR: // global
           _sdtOk::P64 = P64[R1 + 6];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sdtOk::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdvbK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvbK: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.117871101 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipFirst_$cmunzip_info;
 },
 sat_sdtOA_entry() //  [R1]
         { info_tbl: [(cdvcC,
                       label: sat_sdtOA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvcC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvcD; else goto cdvcE;
       cdvcD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvcE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvcv_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvcP; else goto cdvcw;
       udvcP: // global
           call _cdvcv(R1) args: 0, res: 0, upd: 0;
       cdvcw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdvcv() //  [R1]
         { info_tbl: [(cdvcv,
                       label: block_cdvcv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvcv: // global
           if (R1 & 7 == 1) goto cdvcz; else goto cdvcA;
       cdvcz: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdvcA: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvcO; else goto cdvcN;
       cdvcO: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvcN: // global
           _sdtOv::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_1_upd_info;
           P64[Hp - 16] = _sdtOv::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtOt_entry() //  [R1]
         { info_tbl: [(cdvd1,
                       label: sat_sdtOt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvd1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvd2; else goto cdvd3;
       cdvd2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvd3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvcU_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvde; else goto cdvcV;
       udvde: // global
           call _cdvcU(R1) args: 0, res: 0, upd: 0;
       cdvcV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdvcU() //  [R1]
         { info_tbl: [(cdvcU,
                       label: block_cdvcU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvcU: // global
           if (R1 & 7 == 1) goto cdvcY; else goto cdvcZ;
       cdvcY: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdvcZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvdd; else goto cdvdc;
       cdvdd: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvdc: // global
           _sdtOo::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdtOo::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipFirst_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdvdg,
                       label: Control.Monad.Zip.$fMonadZipFirst_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvdg: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdvdk; else goto cdvdj;
       cdvdk: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvdj: // global
           I64[Hp - 64] = sat_sdtOA_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdtOt_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.130688299 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst_closure" {
     Control.Monad.Zip.$fMonadZipFirst_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Monoid.$fMonadFirst_closure;
         const Control.Monad.Zip.$fMonadZipFirst2_closure+2;
         const Control.Monad.Zip.$fMonadZipFirst1_closure+3;
         const Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.133286194 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzip_info;
 },
 Control.Monad.Zip.$fMonadZipMaybe_$cmzip_entry() //  [R2, R3]
         { info_tbl: [(cdve4,
                       label: Control.Monad.Zip.$fMonadZipMaybe_$cmzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdve4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdve5; else goto cdve6;
       cdve5: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdve6: // global
           I64[Sp - 16] = block_cdvdX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udvey; else goto cdvdY;
       udvey: // global
           call _cdvdX(R1) args: 0, res: 0, upd: 0;
       cdvdY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvdX() //  [R1]
         { info_tbl: [(cdvdX,
                       label: block_cdvdX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvdX: // global
           if (R1 & 7 == 1) goto udveu; else goto cdve2;
       udveu: // global
           Sp = Sp + 16;
           call _cdvek() args: 0, res: 0, upd: 0;
       cdve2: // global
           I64[Sp] = block_cdvec_info;
           _sdtOE::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdtOE::P64;
           if (R1 & 7 != 0) goto udvew; else goto cdvee;
       udvew: // global
           call _cdvec(R1) args: 0, res: 0, upd: 0;
       cdvee: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvec() //  [R1]
         { info_tbl: [(cdvec,
                       label: block_cdvec_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvec: // global
           if (R1 & 7 == 1) goto udvev; else goto cdvep;
       udvev: // global
           Sp = Sp + 16;
           call _cdvek() args: 0, res: 0, upd: 0;
       cdvep: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdves; else goto cdver;
       cdves: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdver: // global
           _sdtOG::P64 = P64[R1 + 6];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sdtOG::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdvek() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvek: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.143375089 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_info;
 },
 sat_sdtOW_entry() //  [R1]
         { info_tbl: [(cdvfc,
                       label: sat_sdtOW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvfc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvfd; else goto cdvfe;
       cdvfd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvfe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvf5_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvfp; else goto cdvf6;
       udvfp: // global
           call _cdvf5(R1) args: 0, res: 0, upd: 0;
       cdvf6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdvf5() //  [R1]
         { info_tbl: [(cdvf5,
                       label: block_cdvf5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvf5: // global
           if (R1 & 7 == 1) goto cdvf9; else goto cdvfa;
       cdvf9: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdvfa: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvfo; else goto cdvfn;
       cdvfo: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvfn: // global
           _sdtOR::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_1_upd_info;
           P64[Hp - 16] = _sdtOR::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdtOP_entry() //  [R1]
         { info_tbl: [(cdvfB,
                       label: sat_sdtOP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvfB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvfC; else goto cdvfD;
       cdvfC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvfD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvfu_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvfO; else goto cdvfv;
       udvfO: // global
           call _cdvfu(R1) args: 0, res: 0, upd: 0;
       cdvfv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdvfu() //  [R1]
         { info_tbl: [(cdvfu,
                       label: block_cdvfu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvfu: // global
           if (R1 & 7 == 1) goto cdvfy; else goto cdvfz;
       cdvfy: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdvfz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvfN; else goto cdvfM;
       cdvfN: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvfM: // global
           _sdtOK::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdtOK::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdvfQ,
                       label: Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvfQ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdvfU; else goto cdvfT;
       cdvfU: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvfT: // global
           I64[Hp - 64] = sat_sdtOW_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdtOP_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.155521469 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Base.$fMonadMaybe_closure;
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure+2;
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.157626442 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipProduct_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipProduct_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdvgA,
                       label: Control.Monad.Zip.$fMonadZipProduct_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvgA: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdvgE; else goto cdvgD;
       cdvgE: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvgD: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.16172733 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProduct_closure" {
     Control.Monad.Zip.$fMonadZipProduct_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Semigroup.Internal.$fMonadProduct_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipProduct1_closure+3;
         const Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.16374995 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipSum_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipSum_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdvgU,
                       label: Control.Monad.Zip.$fMonadZipSum_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvgU: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdvgY; else goto cdvgX;
       cdvgY: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvgX: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.167388346 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipSum_closure" {
     Control.Monad.Zip.$fMonadZipSum_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Semigroup.Internal.$fMonadSum_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipSum1_closure+3;
         const Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.169369922 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipDual_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipDual_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdvhe,
                       label: Control.Monad.Zip.$fMonadZipDual_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvhe: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdvhi; else goto cdvhh;
       cdvhi: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvhh: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.173196284 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipDual_closure" {
     Control.Monad.Zip.$fMonadZipDual_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Semigroup.Internal.$fMonadDual_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipDual1_closure+3;
         const Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.176059483 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipIdentity_closure" {
     Control.Monad.Zip.$fMonadZipIdentity_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Functor.Identity.$fMonadIdentity_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipIdentity1_closure+3;
         const Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.177814836 UTC

[section ""cstring" . Control.Monad.Zip.$trModule4_bytes" {
     Control.Monad.Zip.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.179503587 UTC

[section ""data" . Control.Monad.Zip.$trModule3_closure" {
     Control.Monad.Zip.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Zip.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.181195368 UTC

[section ""cstring" . Control.Monad.Zip.$trModule2_bytes" {
     Control.Monad.Zip.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100,46,90,105,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.182825452 UTC

[section ""data" . Control.Monad.Zip.$trModule1_closure" {
     Control.Monad.Zip.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Zip.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.184496494 UTC

[section ""data" . Control.Monad.Zip.$trModule_closure" {
     Control.Monad.Zip.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.Zip.$trModule3_closure+1;
         const Control.Monad.Zip.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.186240055 UTC

[section ""data" . $krep_rdtIk_closure" {
     $krep_rdtIk_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.187907985 UTC

[section ""data" . Control.Monad.Zip.$tcMonadZip1_closure" {
     Control.Monad.Zip.$tcMonadZip1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep_rdtIk_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.190014927 UTC

[section ""cstring" . Control.Monad.Zip.$tcMonadZip3_bytes" {
     Control.Monad.Zip.$tcMonadZip3_bytes:
         I8[] [77,111,110,97,100,90,105,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.191681606 UTC

[section ""data" . Control.Monad.Zip.$tcMonadZip2_closure" {
     Control.Monad.Zip.$tcMonadZip2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Zip.$tcMonadZip3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.193423805 UTC

[section ""data" . Control.Monad.Zip.$tcMonadZip_closure" {
     Control.Monad.Zip.$tcMonadZip_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.Zip.$trModule_closure+1;
         const Control.Monad.Zip.$tcMonadZip2_closure+1;
         const Control.Monad.Zip.$tcMonadZip1_closure+4;
         const 4362170845454097361;
         const 3840659568565778968;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.195565342 UTC

[section ""data" . Control.Monad.Zip.C:MonadZip_closure" {
     Control.Monad.Zip.C:MonadZip_closure:
         const Control.Monad.Zip.C:MonadZip_info;
 },
 Control.Monad.Zip.C:MonadZip_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdvhH,
                       label: Control.Monad.Zip.C:MonadZip_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvhH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvhL; else goto cdvhK;
       cdvhL: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.C:MonadZip_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvhK: // global
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.199353037 UTC

[Control.Monad.Zip.C:MonadZip_con_entry() //  [R1]
         { info_tbl: [(cdvhR,
                       label: Control.Monad.Zip.C:MonadZip_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,77,111,110,97,100,46,90,105,112,46,67,58,77,111,110,97,100,90,105,112]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvhR: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:40.203564849 UTC

[section ""relreadonly" . SdtVj_srt" {
     SdtVj_srt:
         const GHC.Generics.$fMonadRec1_closure;
         const Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure;
         const GHC.Generics.$fMonad:*:_closure;
         const Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure;
         const Control.Monad.Zip.$fMonadZip:*:_closure;
         const Control.Monad.Zip.$fMonadZipRec1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.525563128 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:08:41.527042527 UTC

[section ""data" . Control.Monad.Zip.$p1MonadZip_closure" {
     Control.Monad.Zip.$p1MonadZip_closure:
         const Control.Monad.Zip.$p1MonadZip_info;
 },
 Control.Monad.Zip.$p1MonadZip_entry() //  [R2]
         { info_tbl: [(cdvp7,
                       label: Control.Monad.Zip.$p1MonadZip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvp7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdvp8; else goto cdvp9;
       cdvp8: // global
           R2 = R2;
           R1 = Control.Monad.Zip.$p1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvp9: // global
           I64[Sp - 8] = block_cdvp4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udvpd; else goto cdvp5;
       udvpd: // global
           call _cdvp4(R1) args: 0, res: 0, upd: 0;
       cdvp5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvp4() //  [R1]
         { info_tbl: [(cdvp4,
                       label: block_cdvp4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvp4: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.532758012 UTC

[section ""data" . Control.Monad.Zip.mzip_closure" {
     Control.Monad.Zip.mzip_closure:
         const Control.Monad.Zip.mzip_info;
 },
 Control.Monad.Zip.mzip_entry() //  [R2]
         { info_tbl: [(cdvpx,
                       label: Control.Monad.Zip.mzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvpx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdvpy; else goto cdvpz;
       cdvpy: // global
           R2 = R2;
           R1 = Control.Monad.Zip.mzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvpz: // global
           I64[Sp - 8] = block_cdvpu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udvpD; else goto cdvpv;
       udvpD: // global
           call _cdvpu(R1) args: 0, res: 0, upd: 0;
       cdvpv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvpu() //  [R1]
         { info_tbl: [(cdvpu,
                       label: block_cdvpu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvpu: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.538226269 UTC

[section ""data" . Control.Monad.Zip.mzipWith_closure" {
     Control.Monad.Zip.mzipWith_closure:
         const Control.Monad.Zip.mzipWith_info;
 },
 Control.Monad.Zip.mzipWith_entry() //  [R2]
         { info_tbl: [(cdvpV,
                       label: Control.Monad.Zip.mzipWith_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvpV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdvpW; else goto cdvpX;
       cdvpW: // global
           R2 = R2;
           R1 = Control.Monad.Zip.mzipWith_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvpX: // global
           I64[Sp - 8] = block_cdvpS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udvq1; else goto cdvpT;
       udvq1: // global
           call _cdvpS(R1) args: 0, res: 0, upd: 0;
       cdvpT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvpS() //  [R1]
         { info_tbl: [(cdvpS,
                       label: block_cdvpS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvpS: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.543741157 UTC

[section ""data" . Control.Monad.Zip.munzip_closure" {
     Control.Monad.Zip.munzip_closure:
         const Control.Monad.Zip.munzip_info;
 },
 Control.Monad.Zip.munzip_entry() //  [R2]
         { info_tbl: [(cdvqj,
                       label: Control.Monad.Zip.munzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvqj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdvqk; else goto cdvql;
       cdvqk: // global
           R2 = R2;
           R1 = Control.Monad.Zip.munzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvql: // global
           I64[Sp - 8] = block_cdvqg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udvqp; else goto cdvqh;
       udvqp: // global
           call _cdvqg(R1) args: 0, res: 0, upd: 0;
       cdvqh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvqg() //  [R1]
         { info_tbl: [(cdvqg,
                       label: block_cdvqg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvqg: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.549151259 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip[]_closure" {
     Control.Monad.Zip.$fMonadZip[]_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Base.$fMonad[]_closure;
         const GHC.List.zip_closure+2;
         const GHC.List.zipWith_closure+3;
         const GHC.List.unzip_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.552360693 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip3_closure" {
     Control.Monad.Zip.$w$cmunzip3_closure:
         const Control.Monad.Zip.$w$cmunzip3_info;
 },
 sat_sdviJ_entry() //  [R1]
         { info_tbl: [(cdvqM,
                       label: sat_sdviJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvqM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvqN; else goto cdvqO;
       cdvqN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvqO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvqJ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvqS; else goto cdvqK;
       udvqS: // global
           call _cdvqJ(R1) args: 0, res: 0, upd: 0;
       cdvqK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdvqJ() //  [R1]
         { info_tbl: [(cdvqJ,
                       label: block_cdvqJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvqJ: // global
           R3 = P64[R1 + 15];
           R2 = Data.Tuple.snd_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdviF_entry() //  [R1]
         { info_tbl: [(cdvr0,
                       label: sat_sdviF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvr0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvr4; else goto cdvr5;
       cdvr4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvr5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvqX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvrd; else goto cdvqY;
       udvrd: // global
           call _cdvqX(R1) args: 0, res: 0, upd: 0;
       cdvqY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdvqX() //  [R1]
         { info_tbl: [(cdvqX,
                       label: block_cdvqX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvqX: // global
           I64[Sp] = block_cdvr3_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udvrc; else goto cdvr7;
       udvrc: // global
           call _cdvr3(R1) args: 0, res: 0, upd: 0;
       cdvr7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdvr3() //  [R1]
         { info_tbl: [(cdvr3,
                       label: block_cdvr3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvr3: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdvix_entry() //  [R1]
         { info_tbl: [(cdvrm,
                       label: sat_sdvix_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvrm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvrn; else goto cdvro;
       cdvrn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvro: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvrj_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvrs; else goto cdvrk;
       udvrs: // global
           call _cdvrj(R1) args: 0, res: 0, upd: 0;
       cdvrk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdvrj() //  [R1]
         { info_tbl: [(cdvrj,
                       label: block_cdvrj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvrj: // global
           R3 = P64[R1 + 15];
           R2 = Data.Tuple.fst_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdvit_entry() //  [R1]
         { info_tbl: [(cdvrA,
                       label: sat_sdvit_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvrA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvrE; else goto cdvrF;
       cdvrE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvrF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvrx_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvrN; else goto cdvry;
       udvrN: // global
           call _cdvrx(R1) args: 0, res: 0, upd: 0;
       cdvry: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdvrx() //  [R1]
         { info_tbl: [(cdvrx,
                       label: block_cdvrx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvrx: // global
           I64[Sp] = block_cdvrD_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udvrM; else goto cdvrH;
       udvrM: // global
           call _cdvrD(R1) args: 0, res: 0, upd: 0;
       cdvrH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdvrD() //  [R1]
         { info_tbl: [(cdvrD,
                       label: block_cdvrD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvrD: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip3_entry() //  [R2]
         { info_tbl: [(cdvrP,
                       label: Control.Monad.Zip.$w$cmunzip3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvrP: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdvrT; else goto cdvrS;
       cdvrT: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvrS: // global
           I64[Hp - 136] = sat_sdviJ_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sdviF_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = GHC.Base.:|_con_info;
           P64[Hp - 80] = Hp - 112;
           P64[Hp - 72] = Hp - 136;
           I64[Hp - 64] = sat_sdvix_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdvit_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = Hp - 87;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.575719503 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdvt6,
                       label: Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvt6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdvt7; else goto cdvt8;
       cdvt7: // global
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvt8: // global
           I64[Sp - 8] = block_cdvt3_info;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdvt3() //  [R1, R2]
         { info_tbl: [(cdvt3,
                       label: block_cdvt3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvt3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvtb; else goto cdvta;
       cdvtb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdvta: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.581236637 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipNonEmpty_closure" {
     Control.Monad.Zip.$fMonadZipNonEmpty_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Base.$fMonadNonEmpty_closure;
         const Data.List.NonEmpty.zip_closure+2;
         const Data.List.NonEmpty.zipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.5856955 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdvts,
                       label: Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvts: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.589961582 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipIdentity1_closure" {
     Control.Monad.Zip.$fMonadZipIdentity1_closure:
         const Control.Monad.Zip.$fMonadZipIdentity1_info;
 },
 Control.Monad.Zip.$fMonadZipIdentity1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdvtF,
                       label: Control.Monad.Zip.$fMonadZipIdentity1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvtF: // global
           _sdviU::P64 = R3;
           R3 = R4;
           _sdviT::P64 = R2;
           R2 = _sdviU::P64;
           R1 = _sdviT::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.594392926 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipDual1_closure" {
     Control.Monad.Zip.$fMonadZipDual1_closure:
         const Control.Monad.Zip.$fMonadZipDual1_info;
 },
 Control.Monad.Zip.$fMonadZipDual1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdvtQ,
                       label: Control.Monad.Zip.$fMonadZipDual1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvtQ: // global
           _sdviX::P64 = R3;
           R3 = R4;
           _sdviW::P64 = R2;
           R2 = _sdviX::P64;
           R1 = _sdviW::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.599327057 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipSum1_closure" {
     Control.Monad.Zip.$fMonadZipSum1_closure:
         const Control.Monad.Zip.$fMonadZipSum1_info;
 },
 Control.Monad.Zip.$fMonadZipSum1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdvu1,
                       label: Control.Monad.Zip.$fMonadZipSum1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvu1: // global
           _sdvj0::P64 = R3;
           R3 = R4;
           _sdviZ::P64 = R2;
           R2 = _sdvj0::P64;
           R1 = _sdviZ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.603127074 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProduct1_closure" {
     Control.Monad.Zip.$fMonadZipProduct1_closure:
         const Control.Monad.Zip.$fMonadZipProduct1_info;
 },
 Control.Monad.Zip.$fMonadZipProduct1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdvuc,
                       label: Control.Monad.Zip.$fMonadZipProduct1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvuc: // global
           _sdvj3::P64 = R3;
           R3 = R4;
           _sdvj2::P64 = R2;
           R2 = _sdvj3::P64;
           R1 = _sdvj2::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.608025415 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_info;
 },
 Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cdvuu,
                       label: Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvuu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvuv; else goto cdvuw;
       cdvuv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvuw: // global
           I64[Sp - 24] = block_cdvun_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvuY; else goto cdvuo;
       udvuY: // global
           call _cdvun(R1) args: 0, res: 0, upd: 0;
       cdvuo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvun() //  [R1]
         { info_tbl: [(cdvun,
                       label: block_cdvun_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvun: // global
           if (R1 & 7 == 1) goto udvuU; else goto cdvus;
       udvuU: // global
           Sp = Sp + 24;
           call _cdvuK() args: 0, res: 0, upd: 0;
       cdvus: // global
           I64[Sp] = block_cdvuC_info;
           _sdvj9::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdvj9::P64;
           if (R1 & 7 != 0) goto udvuW; else goto cdvuE;
       udvuW: // global
           call _cdvuC(R1) args: 0, res: 0, upd: 0;
       cdvuE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvuC() //  [R1]
         { info_tbl: [(cdvuC,
                       label: block_cdvuC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvuC: // global
           if (R1 & 7 == 1) goto udvuV; else goto cdvuP;
       udvuV: // global
           Sp = Sp + 24;
           call _cdvuK() args: 0, res: 0, upd: 0;
       cdvuP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdvuS; else goto cdvuR;
       cdvuS: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvuR: // global
           _sdvjb::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sdvjb::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdvuK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvuK: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.620237793 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst1_closure" {
     Control.Monad.Zip.$fMonadZipFirst1_closure:
         const Control.Monad.Zip.$fMonadZipFirst1_info;
 },
 Control.Monad.Zip.$fMonadZipFirst1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdvvE,
                       label: Control.Monad.Zip.$fMonadZipFirst1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvvE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvvF; else goto cdvvG;
       cdvvF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipFirst1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvvG: // global
           I64[Sp - 24] = block_cdvvx_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvw8; else goto cdvvy;
       udvw8: // global
           call _cdvvx(R1) args: 0, res: 0, upd: 0;
       cdvvy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvvx() //  [R1]
         { info_tbl: [(cdvvx,
                       label: block_cdvvx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvvx: // global
           if (R1 & 7 == 1) goto udvw4; else goto cdvvC;
       udvw4: // global
           Sp = Sp + 24;
           call _cdvvU() args: 0, res: 0, upd: 0;
       cdvvC: // global
           I64[Sp] = block_cdvvM_info;
           _sdvjh::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdvjh::P64;
           if (R1 & 7 != 0) goto udvw6; else goto cdvvO;
       udvw6: // global
           call _cdvvM(R1) args: 0, res: 0, upd: 0;
       cdvvO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvvM() //  [R1]
         { info_tbl: [(cdvvM,
                       label: block_cdvvM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvvM: // global
           if (R1 & 7 == 1) goto udvw5; else goto cdvvZ;
       udvw5: // global
           Sp = Sp + 24;
           call _cdvvU() args: 0, res: 0, upd: 0;
       cdvvZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdvw2; else goto cdvw1;
       cdvw2: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvw1: // global
           _sdvjj::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sdvjj::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdvvU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvvU: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.630580271 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast1_closure" {
     Control.Monad.Zip.$fMonadZipLast1_closure:
         const Control.Monad.Zip.$fMonadZipLast1_info;
 },
 Control.Monad.Zip.$fMonadZipLast1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdvwO,
                       label: Control.Monad.Zip.$fMonadZipLast1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvwO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvwP; else goto cdvwQ;
       cdvwP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipLast1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvwQ: // global
           I64[Sp - 24] = block_cdvwH_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvxi; else goto cdvwI;
       udvxi: // global
           call _cdvwH(R1) args: 0, res: 0, upd: 0;
       cdvwI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvwH() //  [R1]
         { info_tbl: [(cdvwH,
                       label: block_cdvwH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvwH: // global
           if (R1 & 7 == 1) goto udvxe; else goto cdvwM;
       udvxe: // global
           Sp = Sp + 24;
           call _cdvx4() args: 0, res: 0, upd: 0;
       cdvwM: // global
           I64[Sp] = block_cdvwW_info;
           _sdvjp::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdvjp::P64;
           if (R1 & 7 != 0) goto udvxg; else goto cdvwY;
       udvxg: // global
           call _cdvwW(R1) args: 0, res: 0, upd: 0;
       cdvwY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvwW() //  [R1]
         { info_tbl: [(cdvwW,
                       label: block_cdvwW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvwW: // global
           if (R1 & 7 == 1) goto udvxf; else goto cdvx9;
       udvxf: // global
           Sp = Sp + 24;
           call _cdvx4() args: 0, res: 0, upd: 0;
       cdvx9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdvxc; else goto cdvxb;
       cdvxc: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvxb: // global
           _sdvjr::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sdvjr::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdvx4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvx4: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.642064864 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_info;
 },
 sat_sdvju_entry() //  [R1]
         { info_tbl: [(cdvxV,
                       label: sat_sdvju_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvxV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvxW; else goto cdvxX;
       cdvxW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvxX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_entry() //  [R2]
         { info_tbl: [(cdvxY,
                       label: Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvxY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvy2; else goto cdvy1;
       cdvy2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvy1: // global
           I64[Hp - 16] = sat_sdvju_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fMonadAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.650234701 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_info;
 },
 Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_entry() //  []
         { info_tbl: [(cdvyh,
                       label: Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvyh: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.654081994 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZipU1_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZipU1_$cmzipWith_info;
 },
 Control.Monad.Zip.$fMonadZipU1_$cmzipWith_entry() //  []
         { info_tbl: [(cdvyu,
                       label: Control.Monad.Zip.$fMonadZipU1_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvyu: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.657997775 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipPar2_closure" {
     Control.Monad.Zip.$fMonadZipPar2_closure:
         const Control.Monad.Zip.$fMonadZipPar2_info;
 },
 Control.Monad.Zip.$fMonadZipPar2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdvyH,
                       label: Control.Monad.Zip.$fMonadZipPar2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvyH: // global
           _sdvjC::P64 = R3;
           R3 = R4;
           _sdvjB::P64 = R2;
           R2 = _sdvjC::P64;
           R1 = _sdvjB::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.662199724 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_info;
         const 0;
 },
 sat_sdvjF_entry() //  [R1]
         { info_tbl: [(cdvyW,
                       label: sat_sdvjF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvyW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvyX; else goto cdvyY;
       cdvyX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvyY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_entry() //  [R2]
         { info_tbl: [(cdvyZ,
                       label: Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvyZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvz3; else goto cdvz2;
       cdvz3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvz2: // global
           I64[Hp - 16] = sat_sdvjF_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadRec1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.668650295 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_info;
 },
 sat_sdvjH_entry() //  [R1]
         { info_tbl: [(cdvzn,
                       label: sat_sdvjH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvzn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvzo; else goto cdvzp;
       cdvzo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvzp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_entry() //  [R2]
         { info_tbl: [(cdvzq,
                       label: Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvzq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvzu; else goto cdvzt;
       cdvzu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvzt: // global
           I64[Hp - 16] = sat_sdvjH_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.674894566 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_info;
 },
 sat_sdvjU_entry() //  [R1]
         { info_tbl: [(cdvzX,
                       label: sat_sdvjU_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvzX: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdvzY; else goto cdvzZ;
       cdvzY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvzZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdvjT_entry() //  [R1]
         { info_tbl: [(cdvA4,
                       label: sat_sdvjT_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvA4: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdvA5; else goto cdvA6;
       cdvA5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvA6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { info_tbl: [(cdvA7,
                       label: Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvA7: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdvA9; else goto cdvAa;
       cdvA9: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvAa: // global
           I64[Sp - 40] = block_cdvzJ_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udvAg; else goto cdvzK;
       udvAg: // global
           call _cdvzJ(R1) args: 0, res: 0, upd: 0;
       cdvzK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvzJ() //  [R1]
         { info_tbl: [(cdvzJ,
                       label: block_cdvzJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvzJ: // global
           I64[Sp - 8] = block_cdvzO_info;
           _sdvjO::P64 = P64[R1 + 7];
           _sdvjP::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sdvjP::P64;
           P64[Sp + 32] = _sdvjO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udvAf; else goto cdvzP;
       udvAf: // global
           call _cdvzO(R1) args: 0, res: 0, upd: 0;
       cdvzP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvzO() //  [R1]
         { info_tbl: [(cdvzO,
                       label: block_cdvzO_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvzO: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cdvAe; else goto cdvAd;
       cdvAe: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvAd: // global
           _sdvjR::P64 = P64[R1 + 7];
           _sdvjS::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_sdvjU_info;
           P64[Hp - 96] = P64[Sp + 24];
           _sdvjK::P64 = P64[Sp + 32];
           P64[Hp - 88] = _sdvjK::P64;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sdvjS::P64;
           I64[Hp - 64] = sat_sdvjT_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _sdvjK::P64;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = _sdvjR::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.688830785 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_info;
         const 0;
 },
 sat_sdvjY_entry() //  [R1]
         { info_tbl: [(cdvB6,
                       label: sat_sdvjY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvB6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvB7; else goto cdvB8;
       cdvB7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvB8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdvjX_entry() //  [R1]
         { info_tbl: [(cdvBd,
                       label: sat_sdvjX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvBd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvBe; else goto cdvBf;
       cdvBe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvBf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_entry() //  [R2, R3]
         { info_tbl: [(cdvBg,
                       label: Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvBg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdvBk; else goto cdvBj;
       cdvBk: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvBj: // global
           I64[Hp - 40] = sat_sdvjY_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sdvjX_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fMonad:*:_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.697824806 UTC

[section ""data" . Control.Monad.Zip.$dmmunzip_closure" {
     Control.Monad.Zip.$dmmunzip_closure:
         const Control.Monad.Zip.$dmmunzip_info;
 },
 $dMonad_sdvk1_entry() //  [R1]
         { info_tbl: [(cdvBJ,
                       label: $dMonad_sdvk1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvBJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvBK; else goto cdvBL;
       cdvBK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvBL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdvke_entry() //  [R1, R2]
         { info_tbl: [(cdvBW,
                       label: sat_sdvke_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvBW: // global
           _sdvk9::P64 = R2;
           _sdvke::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvBX; else goto cdvBY;
       cdvBY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvC0; else goto cdvBZ;
       cdvC0: // global
           HpAlloc = 24;
           goto cdvBX;
       cdvBX: // global
           R2 = _sdvk9::P64;
           R1 = _sdvke::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvBZ: // global
           _sdvk1::P64 = P64[_sdvke::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdvk9::P64;
           R2 = _sdvk1::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdvkf_entry() //  [R1]
         { info_tbl: [(cdvC1,
                       label: sat_sdvkf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvC1: // global
           _sdvkf::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvC2; else goto cdvC3;
       cdvC3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvC5; else goto cdvC4;
       cdvC5: // global
           HpAlloc = 16;
           goto cdvC2;
       cdvC2: // global
           R1 = _sdvkf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvC4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvkf::P64;
           _sdvk0::P64 = P64[_sdvkf::P64 + 16];
           _sdvk1::P64 = P64[_sdvkf::P64 + 24];
           I64[Hp - 8] = sat_sdvke_info;
           P64[Hp] = _sdvk1::P64;
           R2 = _sdvk1::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvk0::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdvk7_entry() //  [R1, R2]
         { info_tbl: [(cdvCg,
                       label: sat_sdvk7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvCg: // global
           _sdvk2::P64 = R2;
           _sdvk7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvCh; else goto cdvCi;
       cdvCi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvCk; else goto cdvCj;
       cdvCk: // global
           HpAlloc = 24;
           goto cdvCh;
       cdvCh: // global
           R2 = _sdvk2::P64;
           R1 = _sdvk7::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvCj: // global
           _sdvk1::P64 = P64[_sdvk7::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdvk2::P64;
           R2 = _sdvk1::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdvk8_entry() //  [R1]
         { info_tbl: [(cdvCl,
                       label: sat_sdvk8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvCl: // global
           _sdvk8::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvCm; else goto cdvCn;
       cdvCn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvCp; else goto cdvCo;
       cdvCp: // global
           HpAlloc = 16;
           goto cdvCm;
       cdvCm: // global
           R1 = _sdvk8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvCo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvk8::P64;
           _sdvk0::P64 = P64[_sdvk8::P64 + 16];
           _sdvk1::P64 = P64[_sdvk8::P64 + 24];
           I64[Hp - 8] = sat_sdvk7_info;
           P64[Hp] = _sdvk1::P64;
           R2 = _sdvk1::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvk0::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$dmmunzip_entry() //  [R2, R3]
         { info_tbl: [(cdvCr,
                       label: Control.Monad.Zip.$dmmunzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvCr: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdvCv; else goto cdvCu;
       cdvCv: // global
           HpAlloc = 112;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$dmmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvCu: // global
           I64[Hp - 104] = $dMonad_sdvk1_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sdvkf_info;
           P64[Hp - 64] = R3;
           _cdvBF::P64 = Hp - 104;
           P64[Hp - 56] = _cdvBF::P64;
           I64[Hp - 48] = sat_sdvk8_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = _cdvBF::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.713891754 UTC

[section ""data" . Control.Monad.Zip.$dmmzipWith_closure" {
     Control.Monad.Zip.$dmmzipWith_closure:
         const Control.Monad.Zip.$dmmzipWith_info;
 },
 sat_sdvkv_entry() //  [R1]
         { info_tbl: [(cdvDz,
                       label: sat_sdvkv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvDz: // global
           _sdvkv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvDA; else goto cdvDB;
       cdvDB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdvDD; else goto cdvDC;
       cdvDD: // global
           HpAlloc = 48;
           goto cdvDA;
       cdvDA: // global
           R1 = _sdvkv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvDC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvkv::P64;
           _sdvkh::P64 = P64[_sdvkv::P64 + 16];
           _sdvkm::P64 = P64[_sdvkv::P64 + 24];
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sdvkm::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdvkm::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _sdvkh::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdvkw_entry() //  [R1, R2]
         { info_tbl: [(cdvDE,
                       label: sat_sdvkw_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvDE: // global
           _sdvkm::P64 = R2;
           _sdvkw::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvDF; else goto cdvDG;
       cdvDG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdvDI; else goto cdvDH;
       cdvDI: // global
           HpAlloc = 32;
           goto cdvDF;
       cdvDF: // global
           R2 = _sdvkm::P64;
           R1 = _sdvkw::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvDH: // global
           _sdvkh::P64 = P64[_sdvkw::P64 + 7];
           _sdvkk::P64 = P64[_sdvkw::P64 + 15];
           I64[Hp - 24] = sat_sdvkv_info;
           P64[Hp - 8] = _sdvkh::P64;
           P64[Hp] = _sdvkm::P64;
           R2 = _sdvkk::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdvkl_entry() //  [R1]
         { info_tbl: [(cdvDN,
                       label: sat_sdvkl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvDN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdvDO; else goto cdvDP;
       cdvDO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvDP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Monad.Zip.mzip_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$dmmzipWith_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdvDQ,
                       label: Control.Monad.Zip.$dmmzipWith_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvDQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdvDR; else goto cdvDS;
       cdvDR: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$dmmzipWith_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvDS: // global
           I64[Sp - 40] = block_cdvDk_info;
           _sdvkg::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _sdvkg::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdvDk() //  [R1]
         { info_tbl: [(cdvDk,
                       label: block_cdvDk_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvDk: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdvDV; else goto cdvDU;
       cdvDV: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvDU: // global
           I64[Hp - 56] = sat_sdvkw_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdvkl_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 55;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.727128443 UTC

[section ""data" . Control.Monad.Zip.$dmmzip_closure" {
     Control.Monad.Zip.$dmmzip_closure:
         const Control.Monad.Zip.$dmmzip_info;
 },
 Control.Monad.Zip.$dmmzip_entry() //  [R2]
         { info_tbl: [(cdvEE,
                       label: Control.Monad.Zip.$dmmzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvEE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvEF; else goto cdvEG;
       cdvEF: // global
           R2 = R2;
           R1 = Control.Monad.Zip.$dmmzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvEG: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Tuple.(,)_closure+2;
           Sp = Sp - 16;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.732824772 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cmzip_info;
 },
 sat_sdvkJ_entry() //  [R1]
         { info_tbl: [(cdvF7,
                       label: sat_sdvkJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvF7: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdvF8; else goto cdvF9;
       cdvF8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvF9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdvkI_entry() //  [R1]
         { info_tbl: [(cdvFe,
                       label: sat_sdvkI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvFe: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdvFf; else goto cdvFg;
       cdvFf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvFg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZip:*:_$cmzip_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdvFh,
                       label: Control.Monad.Zip.$fMonadZip:*:_$cmzip_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvFh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdvFj; else goto cdvFk;
       cdvFj: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cmzip_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvFk: // global
           I64[Sp - 32] = block_cdvET_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udvFq; else goto cdvEU;
       udvFq: // global
           call _cdvET(R1) args: 0, res: 0, upd: 0;
       cdvEU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvET() //  [R1]
         { info_tbl: [(cdvET,
                       label: block_cdvET_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvET: // global
           I64[Sp - 8] = block_cdvEY_info;
           _sdvkD::P64 = P64[R1 + 7];
           _sdvkE::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdvkE::P64;
           P64[Sp + 24] = _sdvkD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udvFp; else goto cdvEZ;
       udvFp: // global
           call _cdvEY(R1) args: 0, res: 0, upd: 0;
       cdvEZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvEY() //  [R1]
         { info_tbl: [(cdvEY,
                       label: block_cdvEY_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvEY: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdvFo; else goto cdvFn;
       cdvFo: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvFn: // global
           _sdvkG::P64 = P64[R1 + 7];
           _sdvkH::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sdvkJ_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sdvkH::P64;
           I64[Hp - 56] = sat_sdvkI_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdvkG::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.747925274 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip_closure" {
     Control.Monad.Zip.$w$cmunzip_closure:
         const Control.Monad.Zip.$w$cmunzip_info;
 },
 $dMonad_sdvkN_entry() //  [R1]
         { info_tbl: [(cdvGi,
                       label: $dMonad_sdvkN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvGi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvGj; else goto cdvGk;
       cdvGj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvGk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl_sdvkO_entry() //  [R1]
         { info_tbl: [(cdvGp,
                       label: lvl_sdvkO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvGp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvGq; else goto cdvGr;
       cdvGq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvGr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dMonad1_sdvkP_entry() //  [R1]
         { info_tbl: [(cdvGw,
                       label: $dMonad1_sdvkP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvGw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvGx; else goto cdvGy;
       cdvGx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvGy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl1_sdvkQ_entry() //  [R1]
         { info_tbl: [(cdvGD,
                       label: lvl1_sdvkQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvGD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvGE; else goto cdvGF;
       cdvGE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvGF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdvlo_entry() //  [R1, R2]
         { info_tbl: [(cdvGZ,
                       label: sat_sdvlo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvGZ: // global
           _sdvlj::P64 = R2;
           _sdvlo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvH0; else goto cdvH1;
       cdvH1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvH3; else goto cdvH2;
       cdvH3: // global
           HpAlloc = 24;
           goto cdvH0;
       cdvH0: // global
           R2 = _sdvlj::P64;
           R1 = _sdvlo::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvH2: // global
           _sdvkO::P64 = P64[_sdvlo::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdvlj::P64;
           R2 = _sdvkO::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdvlp_entry() //  [R1]
         { info_tbl: [(cdvH4,
                       label: sat_sdvlp_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvH4: // global
           _sdvlp::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvH5; else goto cdvH6;
       cdvH6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvH8; else goto cdvH7;
       cdvH8: // global
           HpAlloc = 16;
           goto cdvH5;
       cdvH5: // global
           R1 = _sdvlp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvH7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvlp::P64;
           _sdvkN::P64 = P64[_sdvlp::P64 + 16];
           _sdvkO::P64 = P64[_sdvlp::P64 + 24];
           _sdvlb::P64 = P64[_sdvlp::P64 + 32];
           I64[Hp - 8] = sat_sdvlo_info;
           P64[Hp] = _sdvkO::P64;
           R2 = _sdvkN::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvlb::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdvlh_entry() //  [R1, R2]
         { info_tbl: [(cdvHj,
                       label: sat_sdvlh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvHj: // global
           _sdvlc::P64 = R2;
           _sdvlh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvHk; else goto cdvHl;
       cdvHl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvHn; else goto cdvHm;
       cdvHn: // global
           HpAlloc = 24;
           goto cdvHk;
       cdvHk: // global
           R2 = _sdvlc::P64;
           R1 = _sdvlh::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvHm: // global
           _sdvkQ::P64 = P64[_sdvlh::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdvlc::P64;
           R2 = _sdvkQ::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdvli_entry() //  [R1]
         { info_tbl: [(cdvHo,
                       label: sat_sdvli_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvHo: // global
           _sdvli::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvHp; else goto cdvHq;
       cdvHq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvHs; else goto cdvHr;
       cdvHs: // global
           HpAlloc = 16;
           goto cdvHp;
       cdvHp: // global
           R1 = _sdvli::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvHr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvli::P64;
           _sdvkP::P64 = P64[_sdvli::P64 + 16];
           _sdvkQ::P64 = P64[_sdvli::P64 + 24];
           _sdvla::P64 = P64[_sdvli::P64 + 32];
           I64[Hp - 8] = sat_sdvlh_info;
           P64[Hp] = _sdvkQ::P64;
           R2 = _sdvkP::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvla::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdvlq_entry() //  [R1]
         { info_tbl: [(cdvHt,
                       label: sat_sdvlq_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvHt: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cdvHv; else goto cdvHw;
       cdvHv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvHw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cdvGK_info;
           _sdvkN::P64 = P64[R1 + 24];
           _sdvkO::P64 = P64[R1 + 32];
           _sdvkP::P64 = P64[R1 + 40];
           _sdvkQ::P64 = P64[R1 + 48];
           R1 = P64[R1 + 16];
           P64[Sp - 48] = _sdvkN::P64;
           P64[Sp - 40] = _sdvkO::P64;
           P64[Sp - 32] = _sdvkP::P64;
           P64[Sp - 24] = _sdvkQ::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto udvHA; else goto cdvGL;
       udvHA: // global
           call _cdvGK(R1) args: 0, res: 0, upd: 0;
       cdvGL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdvGK() //  [R1]
         { info_tbl: [(cdvGK,
                       label: block_cdvGK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvGK: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdvHz; else goto cdvHy;
       cdvHz: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvHy: // global
           _sdvla::P64 = P64[R1 + 7];
           _sdvlb::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sdvlp_info;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sdvlb::P64;
           I64[Hp - 56] = sat_sdvli_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdvla::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdvl6_entry() //  [R1, R2]
         { info_tbl: [(cdvHU,
                       label: sat_sdvl6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvHU: // global
           _sdvl1::P64 = R2;
           _sdvl6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvHV; else goto cdvHW;
       cdvHW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvHY; else goto cdvHX;
       cdvHY: // global
           HpAlloc = 24;
           goto cdvHV;
       cdvHV: // global
           R2 = _sdvl1::P64;
           R1 = _sdvl6::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvHX: // global
           _sdvkO::P64 = P64[_sdvl6::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdvl1::P64;
           R2 = _sdvkO::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdvl7_entry() //  [R1]
         { info_tbl: [(cdvHZ,
                       label: sat_sdvl7_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvHZ: // global
           _sdvl7::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvI0; else goto cdvI1;
       cdvI1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvI3; else goto cdvI2;
       cdvI3: // global
           HpAlloc = 16;
           goto cdvI0;
       cdvI0: // global
           R1 = _sdvl7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvI2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvl7::P64;
           _sdvkN::P64 = P64[_sdvl7::P64 + 16];
           _sdvkO::P64 = P64[_sdvl7::P64 + 24];
           _sdvkT::P64 = P64[_sdvl7::P64 + 32];
           I64[Hp - 8] = sat_sdvl6_info;
           P64[Hp] = _sdvkO::P64;
           R2 = _sdvkN::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvkT::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdvkZ_entry() //  [R1, R2]
         { info_tbl: [(cdvIe,
                       label: sat_sdvkZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvIe: // global
           _sdvkU::P64 = R2;
           _sdvkZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvIf; else goto cdvIg;
       cdvIg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvIi; else goto cdvIh;
       cdvIi: // global
           HpAlloc = 24;
           goto cdvIf;
       cdvIf: // global
           R2 = _sdvkU::P64;
           R1 = _sdvkZ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvIh: // global
           _sdvkQ::P64 = P64[_sdvkZ::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdvkU::P64;
           R2 = _sdvkQ::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdvl0_entry() //  [R1]
         { info_tbl: [(cdvIj,
                       label: sat_sdvl0_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvIj: // global
           _sdvl0::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvIk; else goto cdvIl;
       cdvIl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvIn; else goto cdvIm;
       cdvIn: // global
           HpAlloc = 16;
           goto cdvIk;
       cdvIk: // global
           R1 = _sdvl0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvIm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvl0::P64;
           _sdvkP::P64 = P64[_sdvl0::P64 + 16];
           _sdvkQ::P64 = P64[_sdvl0::P64 + 24];
           _sdvkS::P64 = P64[_sdvl0::P64 + 32];
           I64[Hp - 8] = sat_sdvkZ_info;
           P64[Hp] = _sdvkQ::P64;
           R2 = _sdvkP::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvkS::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdvl8_entry() //  [R1]
         { info_tbl: [(cdvIo,
                       label: sat_sdvl8_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvIo: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cdvIq; else goto cdvIr;
       cdvIq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvIr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cdvHF_info;
           _sdvkN::P64 = P64[R1 + 24];
           _sdvkO::P64 = P64[R1 + 32];
           _sdvkP::P64 = P64[R1 + 40];
           _sdvkQ::P64 = P64[R1 + 48];
           R1 = P64[R1 + 16];
           P64[Sp - 48] = _sdvkN::P64;
           P64[Sp - 40] = _sdvkO::P64;
           P64[Sp - 32] = _sdvkP::P64;
           P64[Sp - 24] = _sdvkQ::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto udvIv; else goto cdvHG;
       udvIv: // global
           call _cdvHF(R1) args: 0, res: 0, upd: 0;
       cdvHG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdvHF() //  [R1]
         { info_tbl: [(cdvHF,
                       label: block_cdvHF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvHF: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdvIu; else goto cdvIt;
       cdvIu: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvIt: // global
           _sdvkS::P64 = P64[R1 + 7];
           _sdvkT::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sdvl7_info;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sdvkT::P64;
           I64[Hp - 56] = sat_sdvl0_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdvkS::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip_entry() //  [R2, R3, R4]
         { info_tbl: [(cdvIw,
                       label: Control.Monad.Zip.$w$cmunzip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvIw: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cdvIA; else goto cdvIz;
       cdvIA: // global
           HpAlloc = 208;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvIz: // global
           I64[Hp - 200] = $dMonad_sdvkN_info;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = lvl_sdvkO_info;
           _cdvGe::P64 = Hp - 200;
           P64[Hp - 160] = _cdvGe::P64;
           I64[Hp - 152] = $dMonad1_sdvkP_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = lvl1_sdvkQ_info;
           _cdvGs::P64 = Hp - 152;
           P64[Hp - 112] = _cdvGs::P64;
           I64[Hp - 104] = sat_sdvlq_info;
           P64[Hp - 88] = R4;
           P64[Hp - 80] = _cdvGe::P64;
           _cdvGl::P64 = Hp - 176;
           P64[Hp - 72] = _cdvGl::P64;
           P64[Hp - 64] = _cdvGs::P64;
           _cdvGz::P64 = Hp - 128;
           P64[Hp - 56] = _cdvGz::P64;
           I64[Hp - 48] = sat_sdvl8_info;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = _cdvGe::P64;
           P64[Hp - 16] = _cdvGl::P64;
           P64[Hp - 8] = _cdvGs::P64;
           P64[Hp] = _cdvGz::P64;
           R2 = Hp - 104;
           R1 = Hp - 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.790172391 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZip:*:_$cmunzip_entry() //  [R2, R3, R4]
         { info_tbl: [(cdvKP,
                       label: Control.Monad.Zip.$fMonadZip:*:_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvKP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdvKQ; else goto cdvKR;
       cdvKQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvKR: // global
           I64[Sp - 8] = block_cdvKM_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdvKM() //  [R1, R2]
         { info_tbl: [(cdvKM,
                       label: block_cdvKM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvKM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvKU; else goto cdvKT;
       cdvKU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdvKT: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.796501181 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_closure" {
     Control.Monad.Zip.$fMonadZip:*:_closure:
         const Control.Monad.Zip.$fMonadZip:*:_info;
         const 0;
 },
 sat_sdvlC_entry() //  [R1, R2]
         { info_tbl: [(cdvLf,
                       label: sat_sdvlC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvLf: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZip:*:_$cmunzip_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdvlB_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdvLn,
                       label: sat_sdvlB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvLn: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdvlA_entry() //  [R1, R2, R3]
         { info_tbl: [(cdvLv,
                       label: sat_sdvlA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvLv: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZip:*:_$cmzip_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdvlz_entry() //  [R1]
         { info_tbl: [(cdvLC,
                       label: sat_sdvlz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvLC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvLD; else goto cdvLE;
       cdvLD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvLE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_entry(R3,
                                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZip:*:_entry() //  [R2, R3]
         { info_tbl: [(cdvLG,
                       label: Control.Monad.Zip.$fMonadZip:*:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvLG: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdvLK; else goto cdvLJ;
       cdvLK: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvLJ: // global
           I64[Hp - 136] = sat_sdvlC_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sdvlB_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sdvlA_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_sdvlz_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 86;
           P64[Hp - 8] = Hp - 109;
           P64[Hp] = Hp - 135;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.808190442 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM2_closure" {
     Control.Monad.Zip.$fMonadZipM2_closure:
         const Control.Monad.Zip.$fMonadZipM2_info;
 },
 Control.Monad.Zip.$fMonadZipM2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdvMh,
                       label: Control.Monad.Zip.$fMonadZipM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvMh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdvMi; else goto cdvMj;
       cdvMi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvMj: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.813154661 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip2_closure" {
     Control.Monad.Zip.$w$cmunzip2_closure:
         const Control.Monad.Zip.$w$cmunzip2_info;
 },
 $dMonad_sdvlI_entry() //  [R1]
         { info_tbl: [(cdvMA,
                       label: $dMonad_sdvlI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvMA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvMB; else goto cdvMC;
       cdvMB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvMC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdvlV_entry() //  [R1, R2]
         { info_tbl: [(cdvMN,
                       label: sat_sdvlV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvMN: // global
           _sdvlQ::P64 = R2;
           _sdvlV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvMO; else goto cdvMP;
       cdvMP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvMR; else goto cdvMQ;
       cdvMR: // global
           HpAlloc = 24;
           goto cdvMO;
       cdvMO: // global
           R2 = _sdvlQ::P64;
           R1 = _sdvlV::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvMQ: // global
           _sdvlI::P64 = P64[_sdvlV::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdvlQ::P64;
           R2 = _sdvlI::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdvlW_entry() //  [R1]
         { info_tbl: [(cdvMS,
                       label: sat_sdvlW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvMS: // global
           _sdvlW::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvMT; else goto cdvMU;
       cdvMU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvMW; else goto cdvMV;
       cdvMW: // global
           HpAlloc = 16;
           goto cdvMT;
       cdvMT: // global
           R1 = _sdvlW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvMV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvlW::P64;
           _sdvlH::P64 = P64[_sdvlW::P64 + 16];
           _sdvlI::P64 = P64[_sdvlW::P64 + 24];
           I64[Hp - 8] = sat_sdvlV_info;
           P64[Hp] = _sdvlI::P64;
           R2 = _sdvlI::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvlH::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdvlO_entry() //  [R1, R2]
         { info_tbl: [(cdvN7,
                       label: sat_sdvlO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvN7: // global
           _sdvlJ::P64 = R2;
           _sdvlO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvN8; else goto cdvN9;
       cdvN9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvNb; else goto cdvNa;
       cdvNb: // global
           HpAlloc = 24;
           goto cdvN8;
       cdvN8: // global
           R2 = _sdvlJ::P64;
           R1 = _sdvlO::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvNa: // global
           _sdvlI::P64 = P64[_sdvlO::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdvlJ::P64;
           R2 = _sdvlI::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdvlP_entry() //  [R1]
         { info_tbl: [(cdvNc,
                       label: sat_sdvlP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvNc: // global
           _sdvlP::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvNd; else goto cdvNe;
       cdvNe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvNg; else goto cdvNf;
       cdvNg: // global
           HpAlloc = 16;
           goto cdvNd;
       cdvNd: // global
           R1 = _sdvlP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvNf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvlP::P64;
           _sdvlH::P64 = P64[_sdvlP::P64 + 16];
           _sdvlI::P64 = P64[_sdvlP::P64 + 24];
           I64[Hp - 8] = sat_sdvlO_info;
           P64[Hp] = _sdvlI::P64;
           R2 = _sdvlI::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvlH::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip2_entry() //  [R2, R3]
         { info_tbl: [(cdvNh,
                       label: Control.Monad.Zip.$w$cmunzip2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvNh: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdvNl; else goto cdvNk;
       cdvNl: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvNk: // global
           I64[Hp - 80] = $dMonad_sdvlI_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdvlW_info;
           P64[Hp - 40] = R3;
           _cdvMw::P64 = Hp - 80;
           P64[Hp - 32] = _cdvMw::P64;
           I64[Hp - 24] = sat_sdvlP_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdvMw::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.829077794 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipM1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipM1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipM1_$cmunzip_entry() //  [R2, R3]
         { info_tbl: [(cdvOa,
                       label: Control.Monad.Zip.$fMonadZipM1_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvOa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdvOb; else goto cdvOc;
       cdvOb: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM1_$cmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvOc: // global
           I64[Sp - 8] = block_cdvO7_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip2_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdvO7() //  [R1, R2]
         { info_tbl: [(cdvO7,
                       label: block_cdvO7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvO7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvOf; else goto cdvOe;
       cdvOf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdvOe: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.83552474 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM1_closure" {
     Control.Monad.Zip.$fMonadZipM1_closure:
         const Control.Monad.Zip.$fMonadZipM1_info;
 },
 sat_sdvm9_entry() //  [R1, R2]
         { info_tbl: [(cdvOA,
                       label: sat_sdvm9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvOA: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZipM1_$cmunzip_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdvm8_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdvOI,
                       label: sat_sdvm8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvOI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdvOJ; else goto cdvOK;
       cdvOJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvOK: // global
           _sdvm5::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sdvm5::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sdvm4_entry() //  [R1, R2, R3]
         { info_tbl: [(cdvOQ,
                       label: sat_sdvm4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvOQ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZipM2_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdvm3_entry() //  [R1]
         { info_tbl: [(cdvOX,
                       label: sat_sdvm3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvOX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvOY; else goto cdvOZ;
       cdvOY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvOZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipM1_entry() //  [R2]
         { info_tbl: [(cdvP1,
                       label: Control.Monad.Zip.$fMonadZipM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvP1: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdvP5; else goto cdvP4;
       cdvP5: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvP4: // global
           I64[Hp - 104] = sat_sdvm9_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdvm8_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdvm4_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdvm3_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.846720414 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec2_closure" {
     Control.Monad.Zip.$fMonadZipRec2_closure:
         const Control.Monad.Zip.$fMonadZipRec2_info;
 },
 Control.Monad.Zip.$fMonadZipRec2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdvPE,
                       label: Control.Monad.Zip.$fMonadZipRec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvPE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdvPF; else goto cdvPG;
       cdvPF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvPG: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.852076066 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip4_closure" {
     Control.Monad.Zip.$w$cmunzip4_closure:
         const Control.Monad.Zip.$w$cmunzip4_info;
 },
 $dMonad_sdvmf_entry() //  [R1]
         { info_tbl: [(cdvPX,
                       label: $dMonad_sdvmf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvPX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvPY; else goto cdvPZ;
       cdvPY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvPZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl_sdvmo_entry() //  [R1]
         { info_tbl: [(cdvQ8,
                       label: lvl_sdvmo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvQ8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvQ9; else goto cdvQa;
       cdvQ9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvQa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdvmu_entry() //  [R1, R2]
         { info_tbl: [(cdvQh,
                       label: sat_sdvmu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvQh: // global
           _sdvmp::P64 = R2;
           _sdvmu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvQi; else goto cdvQj;
       cdvQj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvQl; else goto cdvQk;
       cdvQl: // global
           HpAlloc = 24;
           goto cdvQi;
       cdvQi: // global
           R2 = _sdvmp::P64;
           R1 = _sdvmu::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvQk: // global
           _sdvmo::P64 = P64[_sdvmu::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdvmp::P64;
           R2 = _sdvmo::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdvmv_entry() //  [R1]
         { info_tbl: [(cdvQm,
                       label: sat_sdvmv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvQm: // global
           _sdvmv::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvQn; else goto cdvQo;
       cdvQo: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvQq; else goto cdvQp;
       cdvQq: // global
           HpAlloc = 40;
           goto cdvQn;
       cdvQn: // global
           R1 = _sdvmv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvQp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvmv::P64;
           _sdvme::P64 = P64[_sdvmv::P64 + 16];
           _sdvmf::P64 = P64[_sdvmv::P64 + 24];
           I64[Hp - 32] = lvl_sdvmo_info;
           P64[Hp - 16] = _sdvmf::P64;
           I64[Hp - 8] = sat_sdvmu_info;
           P64[Hp] = Hp - 32;
           R2 = _sdvmf::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvme::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 lvl_sdvmg_entry() //  [R1]
         { info_tbl: [(cdvQz,
                       label: lvl_sdvmg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvQz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvQA; else goto cdvQB;
       cdvQA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvQB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdvmm_entry() //  [R1, R2]
         { info_tbl: [(cdvQI,
                       label: sat_sdvmm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvQI: // global
           _sdvmh::P64 = R2;
           _sdvmm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvQJ; else goto cdvQK;
       cdvQK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvQM; else goto cdvQL;
       cdvQM: // global
           HpAlloc = 24;
           goto cdvQJ;
       cdvQJ: // global
           R2 = _sdvmh::P64;
           R1 = _sdvmm::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvQL: // global
           _sdvmg::P64 = P64[_sdvmm::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdvmh::P64;
           R2 = _sdvmg::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdvmn_entry() //  [R1]
         { info_tbl: [(cdvQN,
                       label: sat_sdvmn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvQN: // global
           _sdvmn::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvQO; else goto cdvQP;
       cdvQP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvQR; else goto cdvQQ;
       cdvQR: // global
           HpAlloc = 40;
           goto cdvQO;
       cdvQO: // global
           R1 = _sdvmn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvQQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvmn::P64;
           _sdvme::P64 = P64[_sdvmn::P64 + 16];
           _sdvmf::P64 = P64[_sdvmn::P64 + 24];
           I64[Hp - 32] = lvl_sdvmg_info;
           P64[Hp - 16] = _sdvmf::P64;
           I64[Hp - 8] = sat_sdvmm_info;
           P64[Hp] = Hp - 32;
           R2 = _sdvmf::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvme::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip4_entry() //  [R2, R3]
         { info_tbl: [(cdvQS,
                       label: Control.Monad.Zip.$w$cmunzip4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvQS: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdvQW; else goto cdvQV;
       cdvQW: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvQV: // global
           I64[Hp - 80] = $dMonad_sdvmf_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdvmv_info;
           P64[Hp - 40] = R3;
           _cdvPT::P64 = Hp - 80;
           P64[Hp - 32] = _cdvPT::P64;
           I64[Hp - 24] = sat_sdvmn_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdvPT::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.871598502 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipRec1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipRec1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipRec1_$cmunzip_entry() //  [R2, R3]
         { info_tbl: [(cdvRZ,
                       label: Control.Monad.Zip.$fMonadZipRec1_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvRZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdvS0; else goto cdvS1;
       cdvS0: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec1_$cmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvS1: // global
           I64[Sp - 8] = block_cdvRW_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip4_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdvRW() //  [R1, R2]
         { info_tbl: [(cdvRW,
                       label: block_cdvRW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvRW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvS4; else goto cdvS3;
       cdvS4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdvS3: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.877966926 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec1_closure" {
     Control.Monad.Zip.$fMonadZipRec1_closure:
         const Control.Monad.Zip.$fMonadZipRec1_info;
         const 0;
 },
 sat_sdvmI_entry() //  [R1, R2]
         { info_tbl: [(cdvSp,
                       label: sat_sdvmI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvSp: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZipRec1_$cmunzip_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdvmH_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdvSx,
                       label: sat_sdvmH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvSx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdvSy; else goto cdvSz;
       cdvSy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvSz: // global
           _sdvmE::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sdvmE::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sdvmD_entry() //  [R1, R2, R3]
         { info_tbl: [(cdvSF,
                       label: sat_sdvmD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvSF: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZipRec2_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdvmC_entry() //  [R1]
         { info_tbl: [(cdvSM,
                       label: sat_sdvmC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvSM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvSN; else goto cdvSO;
       cdvSN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvSO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipRec1_entry() //  [R2]
         { info_tbl: [(cdvSQ,
                       label: Control.Monad.Zip.$fMonadZipRec1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvSQ: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdvSU; else goto cdvST;
       cdvSU: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvST: // global
           I64[Hp - 104] = sat_sdvmI_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdvmH_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdvmD_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdvmC_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.889478897 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipPar1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipPar1_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdvTw,
                       label: Control.Monad.Zip.$fMonadZipPar1_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvTw: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdvTA; else goto cdvTz;
       cdvTA: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvTz: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.893442397 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipPar1_closure" {
     Control.Monad.Zip.$fMonadZipPar1_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Generics.$fMonadPar1_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipPar2_closure+3;
         const Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.895474038 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZipU1_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZipU1_$cmzip_info;
 },
 Control.Monad.Zip.$fMonadZipU1_$cmzip_entry() //  []
         { info_tbl: [(cdvTQ,
                       label: Control.Monad.Zip.$fMonadZipU1_$cmzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvTQ: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.899135051 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU2_closure" {
     Control.Monad.Zip.$fMonadZipU2_closure:
         const (,)_con_info;
         const GHC.Generics.U1_closure+1;
         const GHC.Generics.U1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.901602931 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipU1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipU1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipU1_$cmunzip_entry() //  []
         { info_tbl: [(cdvU4,
                       label: Control.Monad.Zip.$fMonadZipU1_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvU4: // global
           R1 = Control.Monad.Zip.$fMonadZipU2_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.904886577 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_closure" {
     Control.Monad.Zip.$fMonadZipU1_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Generics.$fMonadU1_closure;
         const Control.Monad.Zip.$fMonadZipU1_$cmzip_closure+2;
         const Control.Monad.Zip.$fMonadZipU1_$cmzipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipU1_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.906763241 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZipProxy_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZipProxy_$cmzip_info;
 },
 Control.Monad.Zip.$fMonadZipProxy_$cmzip_entry() //  []
         { info_tbl: [(cdvUh,
                       label: Control.Monad.Zip.$fMonadZipProxy_$cmzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvUh: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.910073199 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy1_closure" {
     Control.Monad.Zip.$fMonadZipProxy1_closure:
         const (,)_con_info;
         const Data.Proxy.Proxy_closure+1;
         const Data.Proxy.Proxy_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.912004292 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipProxy_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipProxy_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipProxy_$cmunzip_entry() //  []
         { info_tbl: [(cdvUv,
                       label: Control.Monad.Zip.$fMonadZipProxy_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvUv: // global
           R1 = Control.Monad.Zip.$fMonadZipProxy1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.915695117 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_closure" {
     Control.Monad.Zip.$fMonadZipProxy_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Proxy.$fMonadProxy_closure;
         const Control.Monad.Zip.$fMonadZipProxy_$cmzip_closure+2;
         const Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipProxy_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.917725841 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt1_closure" {
     Control.Monad.Zip.$fMonadZipAlt1_closure:
         const Control.Monad.Zip.$fMonadZipAlt1_info;
 },
 Control.Monad.Zip.$fMonadZipAlt1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdvUI,
                       label: Control.Monad.Zip.$fMonadZipAlt1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvUI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdvUJ; else goto cdvUK;
       cdvUJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvUK: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.922583271 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip1_closure" {
     Control.Monad.Zip.$w$cmunzip1_closure:
         const Control.Monad.Zip.$w$cmunzip1_info;
 },
 $dMonad_sdvn3_entry() //  [R1]
         { info_tbl: [(cdvV1,
                       label: $dMonad_sdvn3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvV1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvV2; else goto cdvV3;
       cdvV2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvV3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdvng_entry() //  [R1, R2]
         { info_tbl: [(cdvVe,
                       label: sat_sdvng_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvVe: // global
           _sdvnb::P64 = R2;
           _sdvng::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvVf; else goto cdvVg;
       cdvVg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvVi; else goto cdvVh;
       cdvVi: // global
           HpAlloc = 24;
           goto cdvVf;
       cdvVf: // global
           R2 = _sdvnb::P64;
           R1 = _sdvng::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvVh: // global
           _sdvn3::P64 = P64[_sdvng::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdvnb::P64;
           R2 = _sdvn3::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdvnh_entry() //  [R1]
         { info_tbl: [(cdvVj,
                       label: sat_sdvnh_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvVj: // global
           _sdvnh::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvVk; else goto cdvVl;
       cdvVl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvVn; else goto cdvVm;
       cdvVn: // global
           HpAlloc = 16;
           goto cdvVk;
       cdvVk: // global
           R1 = _sdvnh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvVm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvnh::P64;
           _sdvn2::P64 = P64[_sdvnh::P64 + 16];
           _sdvn3::P64 = P64[_sdvnh::P64 + 24];
           I64[Hp - 8] = sat_sdvng_info;
           P64[Hp] = _sdvn3::P64;
           R2 = _sdvn3::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvn2::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdvn9_entry() //  [R1, R2]
         { info_tbl: [(cdvVy,
                       label: sat_sdvn9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvVy: // global
           _sdvn4::P64 = R2;
           _sdvn9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvVz; else goto cdvVA;
       cdvVA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvVC; else goto cdvVB;
       cdvVC: // global
           HpAlloc = 24;
           goto cdvVz;
       cdvVz: // global
           R2 = _sdvn4::P64;
           R1 = _sdvn9::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvVB: // global
           _sdvn3::P64 = P64[_sdvn9::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdvn4::P64;
           R2 = _sdvn3::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdvna_entry() //  [R1]
         { info_tbl: [(cdvVD,
                       label: sat_sdvna_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvVD: // global
           _sdvna::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvVE; else goto cdvVF;
       cdvVF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvVH; else goto cdvVG;
       cdvVH: // global
           HpAlloc = 16;
           goto cdvVE;
       cdvVE: // global
           R1 = _sdvna::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvVG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvna::P64;
           _sdvn2::P64 = P64[_sdvna::P64 + 16];
           _sdvn3::P64 = P64[_sdvna::P64 + 24];
           I64[Hp - 8] = sat_sdvn9_info;
           P64[Hp] = _sdvn3::P64;
           R2 = _sdvn3::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvn2::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$w$cmunzip1_entry() //  [R2, R3]
         { info_tbl: [(cdvVI,
                       label: Control.Monad.Zip.$w$cmunzip1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvVI: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdvVM; else goto cdvVL;
       cdvVM: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvVL: // global
           I64[Hp - 80] = $dMonad_sdvn3_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdvnh_info;
           P64[Hp - 40] = R3;
           _cdvUX::P64 = Hp - 80;
           P64[Hp - 32] = _cdvUX::P64;
           I64[Hp - 24] = sat_sdvna_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdvUX::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.938506917 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipAlt_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipAlt_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipAlt_$cmunzip_entry() //  [R2, R3]
         { info_tbl: [(cdvWB,
                       label: Control.Monad.Zip.$fMonadZipAlt_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvWB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdvWC; else goto cdvWD;
       cdvWC: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt_$cmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvWD: // global
           I64[Sp - 8] = block_cdvWy_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip1_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdvWy() //  [R1, R2]
         { info_tbl: [(cdvWy,
                       label: block_cdvWy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvWy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvWG; else goto cdvWF;
       cdvWG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdvWF: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.944811194 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt_closure" {
     Control.Monad.Zip.$fMonadZipAlt_closure:
         const Control.Monad.Zip.$fMonadZipAlt_info;
 },
 sat_sdvnu_entry() //  [R1, R2]
         { info_tbl: [(cdvX1,
                       label: sat_sdvnu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvX1: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZipAlt_$cmunzip_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdvnt_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdvX9,
                       label: sat_sdvnt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvX9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdvXa; else goto cdvXb;
       cdvXa: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvXb: // global
           _sdvnq::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sdvnq::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sdvnp_entry() //  [R1, R2, R3]
         { info_tbl: [(cdvXh,
                       label: sat_sdvnp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvXh: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZipAlt1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdvno_entry() //  [R1]
         { info_tbl: [(cdvXo,
                       label: sat_sdvno_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvXo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvXp; else goto cdvXq;
       cdvXp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvXq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipAlt_entry() //  [R2]
         { info_tbl: [(cdvXs,
                       label: Control.Monad.Zip.$fMonadZipAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvXs: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdvXw; else goto cdvXv;
       cdvXw: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvXv: // global
           I64[Hp - 104] = sat_sdvnu_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdvnt_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdvnp_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdvno_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.956528891 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast2_closure" {
     Control.Monad.Zip.$fMonadZipLast2_closure:
         const Control.Monad.Zip.$fMonadZipLast2_info;
 },
 Control.Monad.Zip.$fMonadZipLast2_entry() //  [R2, R3]
         { info_tbl: [(cdvYc,
                       label: Control.Monad.Zip.$fMonadZipLast2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvYc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvYd; else goto cdvYe;
       cdvYd: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipLast2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvYe: // global
           I64[Sp - 16] = block_cdvY5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udvYG; else goto cdvY6;
       udvYG: // global
           call _cdvY5(R1) args: 0, res: 0, upd: 0;
       cdvY6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvY5() //  [R1]
         { info_tbl: [(cdvY5,
                       label: block_cdvY5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvY5: // global
           if (R1 & 7 == 1) goto udvYC; else goto cdvYa;
       udvYC: // global
           Sp = Sp + 16;
           call _cdvYs() args: 0, res: 0, upd: 0;
       cdvYa: // global
           I64[Sp] = block_cdvYk_info;
           _sdvny::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdvny::P64;
           if (R1 & 7 != 0) goto udvYE; else goto cdvYm;
       udvYE: // global
           call _cdvYk(R1) args: 0, res: 0, upd: 0;
       cdvYm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvYk() //  [R1]
         { info_tbl: [(cdvYk,
                       label: block_cdvYk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvYk: // global
           if (R1 & 7 == 1) goto udvYD; else goto cdvYx;
       udvYD: // global
           Sp = Sp + 16;
           call _cdvYs() args: 0, res: 0, upd: 0;
       cdvYx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvYA; else goto cdvYz;
       cdvYA: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvYz: // global
           _sdvnA::P64 = P64[R1 + 6];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sdvnA::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdvYs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvYs: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.96613041 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipLast_$cmunzip_info;
 },
 sat_sdvnQ_entry() //  [R1]
         { info_tbl: [(cdvZp,
                       label: sat_sdvnQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvZp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvZq; else goto cdvZr;
       cdvZq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvZr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvZi_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvZC; else goto cdvZj;
       udvZC: // global
           call _cdvZi(R1) args: 0, res: 0, upd: 0;
       cdvZj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdvZi() //  [R1]
         { info_tbl: [(cdvZi,
                       label: block_cdvZi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvZi: // global
           if (R1 & 7 == 1) goto cdvZm; else goto cdvZn;
       cdvZm: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdvZn: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvZB; else goto cdvZA;
       cdvZB: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvZA: // global
           _sdvnL::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_1_upd_info;
           P64[Hp - 16] = _sdvnL::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdvnJ_entry() //  [R1]
         { info_tbl: [(cdvZO,
                       label: sat_sdvnJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvZO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvZP; else goto cdvZQ;
       cdvZP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvZQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvZH_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udw01; else goto cdvZI;
       udw01: // global
           call _cdvZH(R1) args: 0, res: 0, upd: 0;
       cdvZI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdvZH() //  [R1]
         { info_tbl: [(cdvZH,
                       label: block_cdvZH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvZH: // global
           if (R1 & 7 == 1) goto cdvZL; else goto cdvZM;
       cdvZL: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdvZM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdw00; else goto cdvZZ;
       cdw00: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvZZ: // global
           _sdvnE::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdvnE::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipLast_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdw03,
                       label: Control.Monad.Zip.$fMonadZipLast_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw03: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdw07; else goto cdw06;
       cdw07: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdw06: // global
           I64[Hp - 64] = sat_sdvnQ_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdvnJ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.979050474 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast_closure" {
     Control.Monad.Zip.$fMonadZipLast_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Monoid.$fMonadLast_closure;
         const Control.Monad.Zip.$fMonadZipLast2_closure+2;
         const Control.Monad.Zip.$fMonadZipLast1_closure+3;
         const Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.981562484 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst2_closure" {
     Control.Monad.Zip.$fMonadZipFirst2_closure:
         const Control.Monad.Zip.$fMonadZipFirst2_info;
 },
 Control.Monad.Zip.$fMonadZipFirst2_entry() //  [R2, R3]
         { info_tbl: [(cdw14,
                       label: Control.Monad.Zip.$fMonadZipFirst2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw14: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdw15; else goto cdw16;
       cdw15: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipFirst2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdw16: // global
           I64[Sp - 16] = block_cdw0X_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udw1y; else goto cdw0Y;
       udw1y: // global
           call _cdw0X(R1) args: 0, res: 0, upd: 0;
       cdw0Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdw0X() //  [R1]
         { info_tbl: [(cdw0X,
                       label: block_cdw0X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw0X: // global
           if (R1 & 7 == 1) goto udw1u; else goto cdw12;
       udw1u: // global
           Sp = Sp + 16;
           call _cdw1k() args: 0, res: 0, upd: 0;
       cdw12: // global
           I64[Sp] = block_cdw1c_info;
           _sdvnU::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdvnU::P64;
           if (R1 & 7 != 0) goto udw1w; else goto cdw1e;
       udw1w: // global
           call _cdw1c(R1) args: 0, res: 0, upd: 0;
       cdw1e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdw1c() //  [R1]
         { info_tbl: [(cdw1c,
                       label: block_cdw1c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw1c: // global
           if (R1 & 7 == 1) goto udw1v; else goto cdw1p;
       udw1v: // global
           Sp = Sp + 16;
           call _cdw1k() args: 0, res: 0, upd: 0;
       cdw1p: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdw1s; else goto cdw1r;
       cdw1s: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdw1r: // global
           _sdvnW::P64 = P64[R1 + 6];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sdvnW::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdw1k() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw1k: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:41.991374971 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipFirst_$cmunzip_info;
 },
 sat_sdvoc_entry() //  [R1]
         { info_tbl: [(cdw2h,
                       label: sat_sdvoc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw2h: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdw2i; else goto cdw2j;
       cdw2i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdw2j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdw2a_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udw2u; else goto cdw2b;
       udw2u: // global
           call _cdw2a(R1) args: 0, res: 0, upd: 0;
       cdw2b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdw2a() //  [R1]
         { info_tbl: [(cdw2a,
                       label: block_cdw2a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw2a: // global
           if (R1 & 7 == 1) goto cdw2e; else goto cdw2f;
       cdw2e: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdw2f: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdw2t; else goto cdw2s;
       cdw2t: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdw2s: // global
           _sdvo7::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_1_upd_info;
           P64[Hp - 16] = _sdvo7::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdvo5_entry() //  [R1]
         { info_tbl: [(cdw2G,
                       label: sat_sdvo5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw2G: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdw2H; else goto cdw2I;
       cdw2H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdw2I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdw2z_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udw2T; else goto cdw2A;
       udw2T: // global
           call _cdw2z(R1) args: 0, res: 0, upd: 0;
       cdw2A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdw2z() //  [R1]
         { info_tbl: [(cdw2z,
                       label: block_cdw2z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw2z: // global
           if (R1 & 7 == 1) goto cdw2D; else goto cdw2E;
       cdw2D: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdw2E: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdw2S; else goto cdw2R;
       cdw2S: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdw2R: // global
           _sdvo0::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdvo0::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipFirst_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdw2V,
                       label: Control.Monad.Zip.$fMonadZipFirst_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw2V: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdw2Z; else goto cdw2Y;
       cdw2Z: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdw2Y: // global
           I64[Hp - 64] = sat_sdvoc_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdvo5_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.003218079 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst_closure" {
     Control.Monad.Zip.$fMonadZipFirst_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Monoid.$fMonadFirst_closure;
         const Control.Monad.Zip.$fMonadZipFirst2_closure+2;
         const Control.Monad.Zip.$fMonadZipFirst1_closure+3;
         const Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.005982077 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzip_info;
 },
 Control.Monad.Zip.$fMonadZipMaybe_$cmzip_entry() //  [R2, R3]
         { info_tbl: [(cdw3W,
                       label: Control.Monad.Zip.$fMonadZipMaybe_$cmzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw3W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdw3X; else goto cdw3Y;
       cdw3X: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdw3Y: // global
           I64[Sp - 16] = block_cdw3P_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udw4q; else goto cdw3Q;
       udw4q: // global
           call _cdw3P(R1) args: 0, res: 0, upd: 0;
       cdw3Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdw3P() //  [R1]
         { info_tbl: [(cdw3P,
                       label: block_cdw3P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw3P: // global
           if (R1 & 7 == 1) goto udw4m; else goto cdw3U;
       udw4m: // global
           Sp = Sp + 16;
           call _cdw4c() args: 0, res: 0, upd: 0;
       cdw3U: // global
           I64[Sp] = block_cdw44_info;
           _sdvog::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdvog::P64;
           if (R1 & 7 != 0) goto udw4o; else goto cdw46;
       udw4o: // global
           call _cdw44(R1) args: 0, res: 0, upd: 0;
       cdw46: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdw44() //  [R1]
         { info_tbl: [(cdw44,
                       label: block_cdw44_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw44: // global
           if (R1 & 7 == 1) goto udw4n; else goto cdw4h;
       udw4n: // global
           Sp = Sp + 16;
           call _cdw4c() args: 0, res: 0, upd: 0;
       cdw4h: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdw4k; else goto cdw4j;
       cdw4k: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdw4j: // global
           _sdvoi::P64 = P64[R1 + 6];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sdvoi::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdw4c() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw4c: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.015990653 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_info;
 },
 sat_sdvoy_entry() //  [R1]
         { info_tbl: [(cdw59,
                       label: sat_sdvoy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw59: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdw5a; else goto cdw5b;
       cdw5a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdw5b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdw52_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udw5m; else goto cdw53;
       udw5m: // global
           call _cdw52(R1) args: 0, res: 0, upd: 0;
       cdw53: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdw52() //  [R1]
         { info_tbl: [(cdw52,
                       label: block_cdw52_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw52: // global
           if (R1 & 7 == 1) goto cdw56; else goto cdw57;
       cdw56: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdw57: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdw5l; else goto cdw5k;
       cdw5l: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdw5k: // global
           _sdvot::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_1_upd_info;
           P64[Hp - 16] = _sdvot::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdvor_entry() //  [R1]
         { info_tbl: [(cdw5y,
                       label: sat_sdvor_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw5y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdw5z; else goto cdw5A;
       cdw5z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdw5A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdw5r_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udw5L; else goto cdw5s;
       udw5L: // global
           call _cdw5r(R1) args: 0, res: 0, upd: 0;
       cdw5s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdw5r() //  [R1]
         { info_tbl: [(cdw5r,
                       label: block_cdw5r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw5r: // global
           if (R1 & 7 == 1) goto cdw5v; else goto cdw5w;
       cdw5v: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdw5w: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdw5K; else goto cdw5J;
       cdw5K: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdw5J: // global
           _sdvom::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdvom::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdw5N,
                       label: Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw5N: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdw5R; else goto cdw5Q;
       cdw5R: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdw5Q: // global
           I64[Hp - 64] = sat_sdvoy_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdvor_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.028091118 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Base.$fMonadMaybe_closure;
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure+2;
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.030209511 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipProduct_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipProduct_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdw6K,
                       label: Control.Monad.Zip.$fMonadZipProduct_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw6K: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdw6O; else goto cdw6N;
       cdw6O: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdw6N: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.034006032 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProduct_closure" {
     Control.Monad.Zip.$fMonadZipProduct_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Semigroup.Internal.$fMonadProduct_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipProduct1_closure+3;
         const Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.035958966 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipSum_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipSum_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdw77,
                       label: Control.Monad.Zip.$fMonadZipSum_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw77: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdw7b; else goto cdw7a;
       cdw7b: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdw7a: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.04007984 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipSum_closure" {
     Control.Monad.Zip.$fMonadZipSum_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Semigroup.Internal.$fMonadSum_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipSum1_closure+3;
         const Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.042033306 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipDual_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipDual_$cmunzip_entry() //  [R2]
         { info_tbl: [(cdw7u,
                       label: Control.Monad.Zip.$fMonadZipDual_$cmunzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw7u: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdw7y; else goto cdw7x;
       cdw7y: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdw7x: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.045830603 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipDual_closure" {
     Control.Monad.Zip.$fMonadZipDual_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Semigroup.Internal.$fMonadDual_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipDual1_closure+3;
         const Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.047613401 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipIdentity_closure" {
     Control.Monad.Zip.$fMonadZipIdentity_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Functor.Identity.$fMonadIdentity_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipIdentity1_closure+3;
         const Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.05021186 UTC

[section ""cstring" . Control.Monad.Zip.$trModule4_bytes" {
     Control.Monad.Zip.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.051851419 UTC

[section ""data" . Control.Monad.Zip.$trModule3_closure" {
     Control.Monad.Zip.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Zip.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.053490028 UTC

[section ""cstring" . Control.Monad.Zip.$trModule2_bytes" {
     Control.Monad.Zip.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100,46,90,105,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.055097535 UTC

[section ""data" . Control.Monad.Zip.$trModule1_closure" {
     Control.Monad.Zip.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Zip.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.056706852 UTC

[section ""data" . Control.Monad.Zip.$trModule_closure" {
     Control.Monad.Zip.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.Zip.$trModule3_closure+1;
         const Control.Monad.Zip.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.058456233 UTC

[section ""data" . $krep_rdtIk_closure" {
     $krep_rdtIk_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.060209516 UTC

[section ""data" . Control.Monad.Zip.$tcMonadZip1_closure" {
     Control.Monad.Zip.$tcMonadZip1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep_rdtIk_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.061928491 UTC

[section ""cstring" . Control.Monad.Zip.$tcMonadZip3_bytes" {
     Control.Monad.Zip.$tcMonadZip3_bytes:
         I8[] [77,111,110,97,100,90,105,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.06359266 UTC

[section ""data" . Control.Monad.Zip.$tcMonadZip2_closure" {
     Control.Monad.Zip.$tcMonadZip2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Zip.$tcMonadZip3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.065764996 UTC

[section ""data" . Control.Monad.Zip.$tcMonadZip_closure" {
     Control.Monad.Zip.$tcMonadZip_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.Zip.$trModule_closure+1;
         const Control.Monad.Zip.$tcMonadZip2_closure+1;
         const Control.Monad.Zip.$tcMonadZip1_closure+4;
         const 4362170845454097361;
         const 3840659568565778968;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.067931514 UTC

[section ""data" . Control.Monad.Zip.C:MonadZip_closure" {
     Control.Monad.Zip.C:MonadZip_closure:
         const Control.Monad.Zip.C:MonadZip_info;
 },
 Control.Monad.Zip.C:MonadZip_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdw80,
                       label: Control.Monad.Zip.C:MonadZip_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw80: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdw84; else goto cdw83;
       cdw84: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.C:MonadZip_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdw83: // global
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.071794983 UTC

[Control.Monad.Zip.C:MonadZip_con_entry() //  [R1]
         { info_tbl: [(cdw8b,
                       label: Control.Monad.Zip.C:MonadZip_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,77,111,110,97,100,46,90,105,112,46,67,58,77,111,110,97,100,90,105,112]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdw8b: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:42.075004722 UTC

[section ""relreadonly" . Sdvz4_srt" {
     Sdvz4_srt:
         const GHC.Generics.$fMonadRec1_closure;
         const Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure;
         const GHC.Generics.$fMonad:*:_closure;
         const Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure;
         const Control.Monad.Zip.$fMonadZip:*:_closure;
         const Control.Monad.Zip.$fMonadZipRec1_closure;
 }]

