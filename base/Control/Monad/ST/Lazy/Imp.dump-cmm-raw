
==================== Raw Cmm ====================
2018-03-16 16:07:32.907932026 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:07:32.909663482 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST5_entry() //  [R2, R3]
         { []
         }
     {offset
       ccE3f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccE3j; else goto ccE3i;
       ccE3j: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE3i: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fApplicativeST5_info" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST5_info:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:32.914125626 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure:
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_info;
         const 0;
 },
 Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_entry() //  [R2]
         { []
         }
     {offset
       ccE3t: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_info" {
     Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_info:
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const ScDMD_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:32.917678388 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unST1_closure" {
     Control.Monad.ST.Lazy.Imp.unST1_closure:
         const Control.Monad.ST.Lazy.Imp.unST1_info;
 },
 Control.Monad.ST.Lazy.Imp.unST1_entry() //  [R2]
         { []
         }
     {offset
       ccE3E: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.unST1_info" {
     Control.Monad.ST.Lazy.Imp.unST1_info:
         const Control.Monad.ST.Lazy.Imp.unST1_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:32.921321581 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unST_closure" {
     Control.Monad.ST.Lazy.Imp.unST_closure:
         const Control.Monad.ST.Lazy.Imp.unST_info;
 },
 Control.Monad.ST.Lazy.Imp.unST_entry() //  [R2]
         { []
         }
     {offset
       ccE3P: // global
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.unST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.unST_info" {
     Control.Monad.ST.Lazy.Imp.unST_info:
         const Control.Monad.ST.Lazy.Imp.unST_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:32.925798171 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fMonadST1_info;
 },
 res_scDJp_entry() //  [R1]
         { []
         }
     {offset
       ccE46: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccE47; else goto ccE48;
       ccE47: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccE48: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccE44_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . res_scDJp_info" {
     res_scDJp_info:
         const res_scDJp_entry;
         const 2;
         const 18;
 },
 _ccE44() //  []
         { []
         }
     {offset
       ccE44: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccE44_info" {
     block_ccE44_info:
         const _ccE44;
         const 2;
         const 30;
 },
 Control.Monad.ST.Lazy.Imp.$fMonadST1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccE4c: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccE4g; else goto ccE4f;
       ccE4g: // global
           HpAlloc = 80;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fMonadST1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE4f: // global
           I64[Hp - 72] = res_scDJp_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = stg_sel_1_upd_info;
           _ccE40::P64 = Hp - 72;
           P64[Hp - 24] = _ccE40::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _ccE40::P64;
           _scDJn::P64 = R3;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _scDJn::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fMonadST1_info" {
     Control.Monad.ST.Lazy.Imp.$fMonadST1_info:
         const Control.Monad.ST.Lazy.Imp.$fMonadST1_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:32.936323626 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$w$c<*>_closure" {
     Control.Monad.ST.Lazy.Imp.$w$c<*>_closure:
         const Control.Monad.ST.Lazy.Imp.$w$c<*>_info;
 },
 res4_scDJK_entry() //  [R1]
         { []
         }
     {offset
       ccE4S: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccE4T; else goto ccE4U;
       ccE4T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccE4U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccE4Q_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . res4_scDJK_info" {
     res4_scDJK_info:
         const res4_scDJK_entry;
         const 2;
         const 18;
 },
 _ccE4Q() //  []
         { []
         }
     {offset
       ccE4Q: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccE4Q_info" {
     block_ccE4Q_info:
         const _ccE4Q;
         const 2;
         const 30;
 },
 sat_scDJQ_entry() //  [R1]
         { []
         }
     {offset
       ccE52: // global
           _scDJQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccE53; else goto ccE54;
       ccE54: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccE56; else goto ccE55;
       ccE56: // global
           HpAlloc = 24;
           goto ccE53;
       ccE53: // global
           R1 = _scDJQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccE55: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scDJQ::P64;
           _scDJI::P64 = P64[_scDJQ::P64 + 16];
           _scDJK::P64 = P64[_scDJQ::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _scDJK::P64;
           R2 = Hp - 16;
           R1 = _scDJI::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scDJQ_info" {
     sat_scDJQ_info:
         const sat_scDJQ_entry;
         const 2;
         const 18;
 },
 Control.Monad.ST.Lazy.Imp.$w$c<*>_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccE57: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccE58; else goto ccE59;
       ccE58: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$w$c<*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE59: // global
           I64[Sp - 16] = block_ccE4D_info;
           _scDJz::P64 = R2;
           R2 = R4;
           R1 = _scDJz::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$w$c<*>_info" {
     Control.Monad.ST.Lazy.Imp.$w$c<*>_info:
         const Control.Monad.ST.Lazy.Imp.$w$c<*>_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ccE4D() //  [R1]
         { []
         }
     {offset
       ccE4D: // global
           I64[Sp] = block_ccE4H_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucE5f; else goto ccE4I;
       ucE5f: // global
           call _ccE4H(R1) args: 0, res: 0, upd: 0;
       ccE4I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccE4D_info" {
     block_ccE4D_info:
         const _ccE4D;
         const 1;
         const 30;
 },
 _ccE4H() //  [R1]
         { []
         }
     {offset
       ccE4H: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccE5e; else goto ccE5d;
       ccE5e: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccE5d: // global
           _scDJI::P64 = P64[R1 + 7];
           _scDJJ::P64 = P64[R1 + 15];
           I64[Hp - 80] = res4_scDJK_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _scDJJ::P64;
           I64[Hp - 48] = stg_sel_1_upd_info;
           _ccE4M::P64 = Hp - 80;
           P64[Hp - 32] = _ccE4M::P64;
           I64[Hp - 24] = sat_scDJQ_info;
           P64[Hp - 8] = _scDJI::P64;
           P64[Hp] = _ccE4M::P64;
           R2 = Hp - 48;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccE4H_info" {
     block_ccE4H_info:
         const _ccE4H;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:32.949664218 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST4_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST4_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccE5O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccE5P; else goto ccE5Q;
       ccE5P: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE5Q: // global
           I64[Sp - 8] = block_ccE5L_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.ST.Lazy.Imp.$w$c<*>_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fApplicativeST4_info" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST4_info:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST4_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ccE5L() //  [R1, R2]
         { []
         }
     {offset
       ccE5L: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccE5T; else goto ccE5S;
       ccE5T: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccE5S: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccE5L_info" {
     block_ccE5L_info:
         const _ccE5L;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:32.957803069 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$w$cliftA2_closure" {
     Control.Monad.ST.Lazy.Imp.$w$cliftA2_closure:
         const Control.Monad.ST.Lazy.Imp.$w$cliftA2_info;
 },
 res1_scDK5_entry() //  [R1]
         { []
         }
     {offset
       ccE6d: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccE6e; else goto ccE6f;
       ccE6e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccE6f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccE6b_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . res1_scDK5_info" {
     res1_scDK5_info:
         const res1_scDK5_entry;
         const 2;
         const 18;
 },
 _ccE6b() //  []
         { []
         }
     {offset
       ccE6b: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccE6b_info" {
     block_ccE6b_info:
         const _ccE6b;
         const 2;
         const 30;
 },
 res2_scDK7_entry() //  [R1]
         { []
         }
     {offset
       ccE6o: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccE6p; else goto ccE6q;
       ccE6p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccE6q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccE6l_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . res2_scDK7_info" {
     res2_scDK7_info:
         const res2_scDK7_entry;
         const 2;
         const 18;
 },
 _ccE6l() //  []
         { []
         }
     {offset
       ccE6l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccE6t; else goto ccE6s;
       ccE6t: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       ccE6s: // global
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 16];
           R2 = Hp - 16;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccE6l_info" {
     block_ccE6l_info:
         const _ccE6l;
         const 2;
         const 30;
 },
 sat_scDKl_entry() //  [R1]
         { []
         }
     {offset
       ccE6B: // global
           _scDKl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccE6C; else goto ccE6D;
       ccE6D: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccE6F; else goto ccE6E;
       ccE6F: // global
           HpAlloc = 48;
           goto ccE6C;
       ccE6C: // global
           R1 = _scDKl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccE6E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scDKl::P64;
           _scDK1::P64 = P64[_scDKl::P64 + 16];
           _scDK5::P64 = P64[_scDKl::P64 + 24];
           _scDK7::P64 = P64[_scDKl::P64 + 32];
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _scDK7::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _scDK5::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _scDK1::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scDKl_info" {
     sat_scDKl_info:
         const sat_scDKl_entry;
         const 3;
         const 15;
 },
 Control.Monad.ST.Lazy.Imp.$w$cliftA2_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       ccE6G: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccE6K; else goto ccE6J;
       ccE6K: // global
           HpAlloc = 128;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$w$cliftA2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE6J: // global
           I64[Hp - 120] = res1_scDK5_info;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = res2_scDK7_info;
           P64[Hp - 72] = R4;
           _ccE67::P64 = Hp - 120;
           P64[Hp - 64] = _ccE67::P64;
           I64[Hp - 56] = stg_sel_1_upd_info;
           _ccE6h::P64 = Hp - 88;
           P64[Hp - 40] = _ccE6h::P64;
           I64[Hp - 32] = sat_scDKl_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _ccE67::P64;
           P64[Hp] = _ccE6h::P64;
           R2 = Hp - 56;
           R1 = Hp - 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$w$cliftA2_info" {
     Control.Monad.ST.Lazy.Imp.$w$cliftA2_info:
         const Control.Monad.ST.Lazy.Imp.$w$cliftA2_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:32.970830323 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST3_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST3_entry() //  [R2, R3, R4,
                                                         R5]
         { []
         }
     {offset
       ccE7k: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccE7l; else goto ccE7m;
       ccE7l: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE7m: // global
           I64[Sp - 8] = block_ccE7h_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.ST.Lazy.Imp.$w$cliftA2_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fApplicativeST3_info" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST3_info:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST3_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _ccE7h() //  [R1, R2]
         { []
         }
     {offset
       ccE7h: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccE7p; else goto ccE7o;
       ccE7p: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccE7o: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccE7h_info" {
     block_ccE7h_info:
         const _ccE7h;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:32.978313654 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_info;
 },
 s'_scDKA_entry() //  [R1]
         { []
         }
     {offset
       ccE7L: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccE7M; else goto ccE7N;
       ccE7M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccE7N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccE7H_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . s'_scDKA_info" {
     s'_scDKA_info:
         const s'_scDKA_entry;
         const 2;
         const 18;
 },
 _ccE7H() //  []
         { []
         }
     {offset
       ccE7H: // global
           _scDKz::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccE7J_info;
           R2 = _scDKz::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_ccE7H_info" {
     block_ccE7H_info:
         const _ccE7H;
         const 2;
         const 30;
 },
 _ccE7J() //  [R1]
         { []
         }
     {offset
       ccE7J: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccE7J_info" {
     block_ccE7J_info:
         const _ccE7J;
         const 0;
         const 30;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccE7S: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccE7W; else goto ccE7V;
       ccE7W: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE7V: // global
           I64[Hp - 24] = s'_scDKA_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 24;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fApplicativeST2_info" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST2_info:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:32.988478349 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$w$c<*_closure" {
     Control.Monad.ST.Lazy.Imp.$w$c<*_closure:
         const Control.Monad.ST.Lazy.Imp.$w$c<*_info;
 },
 s''_scDKQ_entry() //  [R1]
         { []
         }
     {offset
       ccE8F: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccE8G; else goto ccE8H;
       ccE8G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccE8H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccE8B_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . s''_scDKQ_info" {
     s''_scDKQ_info:
         const s''_scDKQ_entry;
         const 2;
         const 18;
 },
 _ccE8B() //  []
         { []
         }
     {offset
       ccE8B: // global
           _scDKP::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccE8D_info;
           R2 = _scDKP::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_ccE8B_info" {
     block_ccE8B_info:
         const _ccE8B;
         const 2;
         const 30;
 },
 _ccE8D() //  [R1]
         { []
         }
     {offset
       ccE8D: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccE8D_info" {
     block_ccE8D_info:
         const _ccE8D;
         const 0;
         const 30;
 },
 Control.Monad.ST.Lazy.Imp.$w$c<*_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccE8M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccE8N; else goto ccE8O;
       ccE8N: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$w$c<*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE8O: // global
           I64[Sp - 16] = block_ccE8o_info;
           _scDKF::P64 = R2;
           R2 = R4;
           R1 = _scDKF::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$w$c<*_info" {
     Control.Monad.ST.Lazy.Imp.$w$c<*_info:
         const Control.Monad.ST.Lazy.Imp.$w$c<*_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ccE8o() //  [R1]
         { []
         }
     {offset
       ccE8o: // global
           I64[Sp] = block_ccE8s_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucE8U; else goto ccE8t;
       ucE8U: // global
           call _ccE8s(R1) args: 0, res: 0, upd: 0;
       ccE8t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccE8o_info" {
     block_ccE8o_info:
         const _ccE8o;
         const 1;
         const 30;
 },
 _ccE8s() //  [R1]
         { []
         }
     {offset
       ccE8s: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccE8T; else goto ccE8S;
       ccE8T: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccE8S: // global
           _scDKO::P64 = P64[R1 + 7];
           _scDKP::P64 = P64[R1 + 15];
           I64[Hp - 24] = s''_scDKQ_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _scDKP::P64;
           R2 = Hp - 24;
           R1 = _scDKO::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccE8s_info" {
     block_ccE8s_info:
         const _ccE8s;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.000530565 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST1_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccE9u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccE9v; else goto ccE9w;
       ccE9v: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE9w: // global
           I64[Sp - 8] = block_ccE9r_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.ST.Lazy.Imp.$w$c<*_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fApplicativeST1_info" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST1_info:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST1_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ccE9r() //  [R1, R2]
         { []
         }
     {offset
       ccE9r: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccE9z; else goto ccE9y;
       ccE9z: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccE9y: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccE9r_info" {
     block_ccE9r_info:
         const _ccE9r;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.00765124 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure:
         const Control.Monad.ST.Lazy.Imp.$fFunctorST2_info;
 },
 res_scDL4_entry() //  [R1]
         { []
         }
     {offset
       ccE9T: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccE9U; else goto ccE9V;
       ccE9U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccE9V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccE9R_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . res_scDL4_info" {
     res_scDL4_info:
         const res_scDL4_entry;
         const 2;
         const 18;
 },
 _ccE9R() //  []
         { []
         }
     {offset
       ccE9R: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccE9R_info" {
     block_ccE9R_info:
         const _ccE9R;
         const 2;
         const 30;
 },
 sat_scDLa_entry() //  [R1]
         { []
         }
     {offset
       ccEa3: // global
           _scDLa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccEa4; else goto ccEa5;
       ccEa5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccEa7; else goto ccEa6;
       ccEa7: // global
           HpAlloc = 24;
           goto ccEa4;
       ccEa4: // global
           R1 = _scDLa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEa6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scDLa::P64;
           _scDL1::P64 = P64[_scDLa::P64 + 16];
           _scDL4::P64 = P64[_scDLa::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _scDL4::P64;
           R2 = Hp - 16;
           R1 = _scDL1::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scDLa_info" {
     sat_scDLa_info:
         const sat_scDLa_entry;
         const 2;
         const 18;
 },
 Control.Monad.ST.Lazy.Imp.$fFunctorST2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccEa9: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccEad; else goto ccEac;
       ccEad: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEac: // global
           I64[Hp - 104] = res_scDL4_info;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = stg_sel_1_upd_info;
           _ccE9N::P64 = Hp - 104;
           P64[Hp - 56] = _ccE9N::P64;
           I64[Hp - 48] = sat_scDLa_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = _ccE9N::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fFunctorST2_info" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST2_info:
         const Control.Monad.ST.Lazy.Imp.$fFunctorST2_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.018689355 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fFunctorST1_info;
 },
 s'_scDLi_entry() //  [R1]
         { []
         }
     {offset
       ccEaK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccEaL; else goto ccEaM;
       ccEaL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEaM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccEaG_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . s'_scDLi_info" {
     s'_scDLi_info:
         const s'_scDLi_entry;
         const 2;
         const 18;
 },
 _ccEaG() //  []
         { []
         }
     {offset
       ccEaG: // global
           _scDLh::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccEaI_info;
           R2 = _scDLh::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_ccEaG_info" {
     block_ccEaG_info:
         const _ccEaG;
         const 2;
         const 30;
 },
 _ccEaI() //  [R1]
         { []
         }
     {offset
       ccEaI: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccEaI_info" {
     block_ccEaI_info:
         const _ccEaI;
         const 0;
         const 30;
 },
 Control.Monad.ST.Lazy.Imp.$fFunctorST1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccEaS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccEaW; else goto ccEaV;
       ccEaW: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEaV: // global
           I64[Hp - 48] = s'_scDLi_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fFunctorST1_info" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST1_info:
         const Control.Monad.ST.Lazy.Imp.$fFunctorST1_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.026740462 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fFunctorST_closure" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST_closure:
         const GHC.Base.C:Functor_con_info;
         const Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure+3;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.028585446 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST_closure:
         const GHC.Base.C:Applicative_con_info;
         const Control.Monad.ST.Lazy.Imp.$fFunctorST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure+2;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure+4;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure+3;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.030546908 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadST_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadST_closure:
         const GHC.Base.C:Monad_con_info;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fMonadST1_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure+2;
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.032442648 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFailST_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFailST_closure:
         const Control.Monad.Fail.C:MonadFail_con_info;
         const Control.Monad.ST.Lazy.Imp.$fMonadST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.035116702 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.runST_closure" {
     Control.Monad.ST.Lazy.Imp.runST_closure:
         const Control.Monad.ST.Lazy.Imp.runST_info;
 },
 Control.Monad.ST.Lazy.Imp.runST_entry() //  [R2]
         { []
         }
     {offset
       ccEbs: // global
           _scDLn::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccEbt; else goto ccEbu;
       ccEbu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEbw; else goto ccEbv;
       ccEbw: // global
           HpAlloc = 16;
           goto ccEbt;
       ccEbt: // global
           R2 = _scDLn::P64;
           R1 = Control.Monad.ST.Lazy.Imp.runST_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccEbv: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Sp - 8] = block_ccEbq_info;
           R2 = Hp - 7;
           R1 = _scDLn::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.runST_info" {
     Control.Monad.ST.Lazy.Imp.runST_info:
         const Control.Monad.ST.Lazy.Imp.runST_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _ccEbq() //  [R1]
         { []
         }
     {offset
       ccEbq: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEbq_info" {
     block_ccEbq_info:
         const _ccEbq;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.042431331 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fMonadFixST1_info;
 },
 ds_scDLu_entry() //  [R1]
         { []
         }
     {offset
       ccEbT: // global
           _scDLu::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccEbX; else goto ccEbY;
       ccEbY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccEc0; else goto ccEbZ;
       ccEc0: // global
           HpAlloc = 24;
           goto ccEbX;
       ccEbX: // global
           R1 = _scDLu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEbZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scDLu::P64;
           _scDLs::P64 = P64[_scDLu::P64 + 16];
           _scDLt::P64 = P64[_scDLu::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _scDLu::P64;
           I64[Sp - 24] = block_ccEbR_info;
           R3 = _scDLt::P64;
           R2 = Hp - 16;
           R1 = _scDLs::P64;
           Sp = Sp - 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds_scDLu_info" {
     ds_scDLu_info:
         const ds_scDLu_entry;
         const 2;
         const 18;
 },
 _ccEbR() //  [R1]
         { []
         }
     {offset
       ccEbR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccEc3; else goto ccEc2;
       ccEc3: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccEc2: // global
           _scDLB::P64 = P64[R1 + 7];
           _scDLC::P64 = P64[R1 + 15];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = _scDLB::P64;
           P64[Hp] = _scDLC::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccEbR_info" {
     block_ccEbR_info:
         const _ccEbR;
         const 0;
         const 30;
 },
 Control.Monad.ST.Lazy.Imp.$fMonadFixST1_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEc7: // global
           _scDLt::P64 = R3;
           _scDLs::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccEc8; else goto ccEc9;
       ccEc9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccEcb; else goto ccEca;
       ccEcb: // global
           HpAlloc = 32;
           goto ccEc8;
       ccEc8: // global
           R3 = _scDLt::P64;
           R2 = _scDLs::P64;
           R1 = Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEca: // global
           I64[Hp - 24] = ds_scDLu_info;
           P64[Hp - 8] = _scDLs::P64;
           P64[Hp] = _scDLt::P64;
           I64[Sp - 8] = block_ccEc4_info;
           R1 = Hp - 24;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucEcf; else goto ccEc5;
       ucEcf: // global
           call _ccEc4(R1) args: 0, res: 0, upd: 0;
       ccEc5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fMonadFixST1_info" {
     Control.Monad.ST.Lazy.Imp.$fMonadFixST1_info:
         const Control.Monad.ST.Lazy.Imp.$fMonadFixST1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccEc4() //  [R1]
         { []
         }
     {offset
       ccEc4: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEc4_info" {
     block_ccEc4_info:
         const _ccEc4;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.052849677 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.fixST_closure" {
     Control.Monad.ST.Lazy.Imp.fixST_closure:
         const Control.Monad.ST.Lazy.Imp.fixST_info;
 },
 Control.Monad.ST.Lazy.Imp.fixST_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEcD: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.$fMonadFixST1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.fixST_info" {
     Control.Monad.ST.Lazy.Imp.fixST_info:
         const Control.Monad.ST.Lazy.Imp.fixST_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.056014404 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFixST_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFixST_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Control.Monad.ST.Lazy.Imp.$fMonadST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.059041025 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.strictToLazyST1_closure" {
     Control.Monad.ST.Lazy.Imp.strictToLazyST1_closure:
         const Control.Monad.ST.Lazy.Imp.strictToLazyST1_info;
 },
 Control.Monad.ST.Lazy.Imp.strictToLazyST1_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEcS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEcZ; else goto ccEd0;
       ccEcZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.strictToLazyST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEd0: // global
           I64[Sp - 16] = block_ccEcP_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEd5; else goto ccEcQ;
       ucEd5: // global
           call _ccEcP() args: 0, res: 0, upd: 0;
       ccEcQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.strictToLazyST1_info" {
     Control.Monad.ST.Lazy.Imp.strictToLazyST1_info:
         const Control.Monad.ST.Lazy.Imp.strictToLazyST1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccEcP() //  []
         { []
         }
     {offset
       ccEcP: // global
           _scDLH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEcV_info;
           R1 = _scDLH::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEcP_info" {
     block_ccEcP_info:
         const _ccEcP;
         const 1;
         const 30;
 },
 _ccEcV() //  [R1]
         { []
         }
     {offset
       ccEcV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEd4; else goto ccEd3;
       ccEd4: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEd3: // global
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEcV_info" {
     block_ccEcV_info:
         const _ccEcV;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.066487369 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.strictToLazyST_closure" {
     Control.Monad.ST.Lazy.Imp.strictToLazyST_closure:
         const Control.Monad.ST.Lazy.Imp.strictToLazyST_info;
 },
 Control.Monad.ST.Lazy.Imp.strictToLazyST_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEdo: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.strictToLazyST1_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.strictToLazyST_info" {
     Control.Monad.ST.Lazy.Imp.strictToLazyST_info:
         const Control.Monad.ST.Lazy.Imp.strictToLazyST_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.071568076 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeIOToST1_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeIOToST1_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeIOToST1_info;
 },
 Control.Monad.ST.Lazy.Imp.unsafeIOToST1_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEdC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEdJ; else goto ccEdK;
       ccEdJ: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.unsafeIOToST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEdK: // global
           I64[Sp - 16] = block_ccEdz_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEdP; else goto ccEdA;
       ucEdP: // global
           call _ccEdz() args: 0, res: 0, upd: 0;
       ccEdA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.unsafeIOToST1_info" {
     Control.Monad.ST.Lazy.Imp.unsafeIOToST1_info:
         const Control.Monad.ST.Lazy.Imp.unsafeIOToST1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccEdz() //  []
         { []
         }
     {offset
       ccEdz: // global
           _scDLP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEdF_info;
           R1 = _scDLP::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEdz_info" {
     block_ccEdz_info:
         const _ccEdz;
         const 1;
         const 30;
 },
 _ccEdF() //  [R1]
         { []
         }
     {offset
       ccEdF: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEdO; else goto ccEdN;
       ccEdO: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEdN: // global
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEdF_info" {
     block_ccEdF_info:
         const _ccEdF;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.078990042 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeIOToST_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeIOToST_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeIOToST_info;
 },
 Control.Monad.ST.Lazy.Imp.unsafeIOToST_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEe8: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.unsafeIOToST1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.unsafeIOToST_info" {
     Control.Monad.ST.Lazy.Imp.unsafeIOToST_info:
         const Control.Monad.ST.Lazy.Imp.unsafeIOToST_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.083671308 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.lazyToStrictST1_closure" {
     Control.Monad.ST.Lazy.Imp.lazyToStrictST1_closure:
         const Control.Monad.ST.Lazy.Imp.lazyToStrictST1_info;
 },
 Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry() //  [R2]
         { []
         }
     {offset
       ccEem: // global
           _scDLX::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto ccEeq; else goto ccEer;
       ccEer: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEet; else goto ccEes;
       ccEet: // global
           HpAlloc = 16;
           goto ccEeq;
       ccEeq: // global
           R2 = _scDLX::P64;
           R1 = Control.Monad.ST.Lazy.Imp.lazyToStrictST1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccEes: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Sp - 8] = block_ccEek_info;
           R2 = Hp - 7;
           R1 = _scDLX::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.lazyToStrictST1_info" {
     Control.Monad.ST.Lazy.Imp.lazyToStrictST1_info:
         const Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _ccEek() //  [R1]
         { []
         }
     {offset
       ccEek: // global
           I64[Sp - 8] = block_ccEep_info;
           _scDM1::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _scDM1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucEeA; else goto ccEev;
       ucEeA: // global
           call _ccEep() args: 0, res: 0, upd: 0;
       ccEev: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEek_info" {
     block_ccEek_info:
         const _ccEek;
         const 0;
         const 30;
 },
 _ccEep() //  []
         { []
         }
     {offset
       ccEep: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEep_info" {
     block_ccEep_info:
         const _ccEep;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.091273492 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.lazyToStrictST_closure" {
     Control.Monad.ST.Lazy.Imp.lazyToStrictST_closure:
         const Control.Monad.ST.Lazy.Imp.lazyToStrictST_info;
 },
 Control.Monad.ST.Lazy.Imp.lazyToStrictST_entry() //  [R2]
         { []
         }
     {offset
       ccEeS: // global
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.lazyToStrictST_info" {
     Control.Monad.ST.Lazy.Imp.lazyToStrictST_info:
         const Control.Monad.ST.Lazy.Imp.lazyToStrictST_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.095192721 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.stToIO_closure" {
     Control.Monad.ST.Lazy.Imp.stToIO_closure:
         const Control.Monad.ST.Lazy.Imp.stToIO_info;
 },
 Control.Monad.ST.Lazy.Imp.stToIO_entry() //  [R2]
         { []
         }
     {offset
       ccEf3: // global
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.stToIO_info" {
     Control.Monad.ST.Lazy.Imp.stToIO_info:
         const Control.Monad.ST.Lazy.Imp.stToIO_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.100715648 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_info;
 },
 sat_scDMh_entry() //  [R1]
         { []
         }
     {offset
       ccEft: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEfx; else goto ccEfy;
       ccEfx: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccEfy: // global
           I64[Sp - 16] = block_ccEfo_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_scDMh_info" {
     sat_scDMh_info:
         const sat_scDMh_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _ccEfo() //  []
         { []
         }
     {offset
       ccEfo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEfB; else goto ccEfA;
       ccEfB: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccEfA: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           _scDM5::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEfr_info;
           R2 = Hp - 7;
           R1 = _scDM5::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEfo_info" {
     block_ccEfo_info:
         const _ccEfo;
         const 1;
         const 30;
 },
 _ccEfr() //  [R1]
         { []
         }
     {offset
       ccEfr: // global
           I64[Sp - 8] = block_ccEfw_info;
           _scDMd::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _scDMd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucEfI; else goto ccEfD;
       ucEfI: // global
           call _ccEfw() args: 0, res: 0, upd: 0;
       ccEfD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEfr_info" {
     block_ccEfr_info:
         const _ccEfr;
         const 0;
         const 30;
 },
 _ccEfw() //  []
         { []
         }
     {offset
       ccEfw: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEfw_info" {
     block_ccEfw_info:
         const _ccEfw;
         const 1;
         const 30;
 },
 Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEfJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEfO; else goto ccEfP;
       ccEfO: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEfP: // global
           I64[Sp - 16] = block_ccEfe_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEfW; else goto ccEff;
       ucEfW: // global
           call _ccEfe(R1) args: 0, res: 0, upd: 0;
       ccEff: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_info" {
     Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_info:
         const Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccEfe() //  [R1]
         { []
         }
     {offset
       ccEfe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEfS; else goto ccEfR;
       ccEfS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEfR: // global
           I64[Hp - 8] = sat_scDMh_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccEfK_info;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.ST.unsafeDupableInterleaveST_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEfe_info" {
     block_ccEfe_info:
         const _ccEfe;
         const 1;
         const 30;
 },
 _ccEfK() //  [R1]
         { []
         }
     {offset
       ccEfK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEfV; else goto ccEfU;
       ccEfV: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEfU: // global
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEfK_info" {
     block_ccEfK_info:
         const _ccEfK;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.114503092 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_info;
 },
 Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEgw: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_info" {
     Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_info:
         const Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.117783226 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$trModule4_bytes" {
     Control.Monad.ST.Lazy.Imp.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.119618826 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$trModule3_closure" {
     Control.Monad.ST.Lazy.Imp.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.121922039 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$trModule2_bytes" {
     Control.Monad.ST.Lazy.Imp.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100,46,83,84,46,76,97,122,121,46,73,109,112]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.12376755 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$trModule1_closure" {
     Control.Monad.ST.Lazy.Imp.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.125516417 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$trModule_closure" {
     Control.Monad.ST.Lazy.Imp.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule3_closure+1;
         const Control.Monad.ST.Lazy.Imp.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.127437705 UTC

[section ""data" . $krep_rcDJ5_closure" {
     $krep_rcDJ5_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.129854039 UTC

[section ""data" . $krep1_rcDJ6_closure" {
     $krep1_rcDJ6_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.131662967 UTC

[section ""data" . $krep2_rcDJ7_closure" {
     $krep2_rcDJ7_closure:
         const :_con_info;
         const $krep1_rcDJ6_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.133558696 UTC

[section ""data" . $krep3_rcDJ8_closure" {
     $krep3_rcDJ8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcState#_closure;
         const $krep2_rcDJ7_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.135293658 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tcState2_bytes" {
     Control.Monad.ST.Lazy.Imp.$tcState2_bytes:
         I8[] [83,116,97,116,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.137133929 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcState1_closure" {
     Control.Monad.ST.Lazy.Imp.$tcState1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcState2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.139569034 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcState_closure" {
     Control.Monad.ST.Lazy.Imp.$tcState_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tcState1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 220923881781706094;
         const 12630832853168782158;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.141514278 UTC

[section ""data" . $krep4_rcDJ9_closure" {
     $krep4_rcDJ9_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcState_closure+1;
         const $krep2_rcDJ7_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.143291315 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'S#1_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'S#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rcDJ8_closure+1;
         const $krep4_rcDJ9_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.145103048 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tc'S#3_bytes" {
     Control.Monad.ST.Lazy.Imp.$tc'S#3_bytes:
         I8[] [39,83,35]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.146994439 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'S#2_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'S#2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tc'S#3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.149785307 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'S#_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'S#_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'S#2_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'S#1_closure+4;
         const 12704778602275544086;
         const 1928505377508739254;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.151760725 UTC

[section ""data" . $krep5_rcDJa_closure" {
     $krep5_rcDJa_closure:
         const :_con_info;
         const $krep4_rcDJ9_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.153582029 UTC

[section ""data" . $krep6_rcDJb_closure" {
     $krep6_rcDJb_closure:
         const :_con_info;
         const $krep_rcDJ5_closure+2;
         const $krep5_rcDJa_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.155442771 UTC

[section ""data" . $krep7_rcDJc_closure" {
     $krep7_rcDJc_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep6_rcDJb_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.157286978 UTC

[section ""data" . $krep8_rcDJd_closure" {
     $krep8_rcDJd_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rcDJ9_closure+1;
         const $krep7_rcDJc_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.159073334 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tcST2_bytes" {
     Control.Monad.ST.Lazy.Imp.$tcST2_bytes:
         I8[] [83,84]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.160789793 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcST1_closure" {
     Control.Monad.ST.Lazy.Imp.$tcST1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcST2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.162652018 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcST_closure" {
     Control.Monad.ST.Lazy.Imp.$tcST_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tcST1_closure+1;
         const GHC.Types.krep$*->*->*_closure;
         const 9758985700159114765;
         const 4154811637844139714;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.164563002 UTC

[section ""data" . $krep9_rcDJe_closure" {
     $krep9_rcDJe_closure:
         const :_con_info;
         const $krep_rcDJ5_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.166704937 UTC

[section ""data" . $krep10_rcDJf_closure" {
     $krep10_rcDJf_closure:
         const :_con_info;
         const $krep1_rcDJ6_closure+2;
         const $krep9_rcDJe_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.168525445 UTC

[section ""data" . $krep11_rcDJg_closure" {
     $krep11_rcDJg_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcST_closure+1;
         const $krep10_rcDJf_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.170379282 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'ST1_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'ST1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rcDJd_closure+4;
         const $krep11_rcDJg_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.172231662 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tc'ST3_bytes" {
     Control.Monad.ST.Lazy.Imp.$tc'ST3_bytes:
         I8[] [39,83,84]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.174108962 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'ST2_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'ST2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tc'ST3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.176530583 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'ST_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'ST_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'ST2_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'ST1_closure+4;
         const 5656684040178075861;
         const 6626797926801395533;
         const 2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.179602203 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.S#_closure" {
     Control.Monad.ST.Lazy.Imp.S#_closure:
         const Control.Monad.ST.Lazy.Imp.S#_info;
 },
 Control.Monad.ST.Lazy.Imp.S#_entry() //  []
         { []
         }
     {offset
       ccEhd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEhh; else goto ccEhg;
       ccEhh: // global
           HpAlloc = 16;
           R1 = Control.Monad.ST.Lazy.Imp.S#_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccEhg: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.S#_info" {
     Control.Monad.ST.Lazy.Imp.S#_info:
         const Control.Monad.ST.Lazy.Imp.S#_entry;
         const 0;
         const 14;
         const 4294967299;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.183209276 UTC

[section ""cstring" . icE39_str" {
     icE39_str:
         I8[] [98,97,115,101,58,67,111,110,116,114,111,108,46,77,111,110,97,100,46,83,84,46,76,97,122,121,46,73,109,112,46,83,35]
 },
 Control.Monad.ST.Lazy.Imp.S#_con_entry() //  [R1]
         { []
         }
     {offset
       ccEhn: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.S#_con_info" {
     Control.Monad.ST.Lazy.Imp.S#_con_info:
         const Control.Monad.ST.Lazy.Imp.S#_con_entry;
         const 4294967296;
         const 3;
         const icE39_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.18647902 UTC

[section ""relreadonly" . ScDMD_srt" {
     ScDMD_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.626386139 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:07:33.628283819 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST5_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEkD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccEkH; else goto ccEkG;
       ccEkH: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEkG: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fApplicativeST5_info" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST5_info:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.632471109 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure:
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_info;
         const 0;
 },
 Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_entry() //  [R2]
         { []
         }
     {offset
       ccEkS: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_info" {
     Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_info:
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const ScEkV_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.636139354 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unST1_closure" {
     Control.Monad.ST.Lazy.Imp.unST1_closure:
         const Control.Monad.ST.Lazy.Imp.unST1_info;
 },
 Control.Monad.ST.Lazy.Imp.unST1_entry() //  [R2]
         { []
         }
     {offset
       ccEl4: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.unST1_info" {
     Control.Monad.ST.Lazy.Imp.unST1_info:
         const Control.Monad.ST.Lazy.Imp.unST1_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.639691283 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unST_closure" {
     Control.Monad.ST.Lazy.Imp.unST_closure:
         const Control.Monad.ST.Lazy.Imp.unST_info;
 },
 Control.Monad.ST.Lazy.Imp.unST_entry() //  [R2]
         { []
         }
     {offset
       ccElf: // global
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.unST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.unST_info" {
     Control.Monad.ST.Lazy.Imp.unST_info:
         const Control.Monad.ST.Lazy.Imp.unST_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.644547519 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fMonadST1_info;
 },
 res_scEhB_entry() //  [R1]
         { []
         }
     {offset
       ccElw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccElx; else goto ccEly;
       ccElx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEly: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccElu_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . res_scEhB_info" {
     res_scEhB_info:
         const res_scEhB_entry;
         const 2;
         const 18;
 },
 _ccElu() //  []
         { []
         }
     {offset
       ccElu: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccElu_info" {
     block_ccElu_info:
         const _ccElu;
         const 2;
         const 30;
 },
 Control.Monad.ST.Lazy.Imp.$fMonadST1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccElC: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccElG; else goto ccElF;
       ccElG: // global
           HpAlloc = 80;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fMonadST1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccElF: // global
           I64[Hp - 72] = res_scEhB_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = stg_sel_1_upd_info;
           _ccElq::P64 = Hp - 72;
           P64[Hp - 24] = _ccElq::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _ccElq::P64;
           _scEhz::P64 = R3;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _scEhz::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fMonadST1_info" {
     Control.Monad.ST.Lazy.Imp.$fMonadST1_info:
         const Control.Monad.ST.Lazy.Imp.$fMonadST1_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.65413647 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$w$c<*>_closure" {
     Control.Monad.ST.Lazy.Imp.$w$c<*>_closure:
         const Control.Monad.ST.Lazy.Imp.$w$c<*>_info;
 },
 res4_scEhW_entry() //  [R1]
         { []
         }
     {offset
       ccEmn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccEmo; else goto ccEmp;
       ccEmo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEmp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccEml_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . res4_scEhW_info" {
     res4_scEhW_info:
         const res4_scEhW_entry;
         const 2;
         const 18;
 },
 _ccEml() //  []
         { []
         }
     {offset
       ccEml: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccEml_info" {
     block_ccEml_info:
         const _ccEml;
         const 2;
         const 30;
 },
 sat_scEi2_entry() //  [R1]
         { []
         }
     {offset
       ccEmx: // global
           _scEi2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccEmy; else goto ccEmz;
       ccEmz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccEmB; else goto ccEmA;
       ccEmB: // global
           HpAlloc = 24;
           goto ccEmy;
       ccEmy: // global
           R1 = _scEi2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEmA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scEi2::P64;
           _scEhU::P64 = P64[_scEi2::P64 + 16];
           _scEhW::P64 = P64[_scEi2::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _scEhW::P64;
           R2 = Hp - 16;
           R1 = _scEhU::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scEi2_info" {
     sat_scEi2_info:
         const sat_scEi2_entry;
         const 2;
         const 18;
 },
 Control.Monad.ST.Lazy.Imp.$w$c<*>_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccEmC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEmD; else goto ccEmE;
       ccEmD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$w$c<*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEmE: // global
           I64[Sp - 16] = block_ccEm8_info;
           _scEhL::P64 = R2;
           R2 = R4;
           R1 = _scEhL::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$w$c<*>_info" {
     Control.Monad.ST.Lazy.Imp.$w$c<*>_info:
         const Control.Monad.ST.Lazy.Imp.$w$c<*>_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ccEm8() //  [R1]
         { []
         }
     {offset
       ccEm8: // global
           I64[Sp] = block_ccEmc_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucEmK; else goto ccEmd;
       ucEmK: // global
           call _ccEmc(R1) args: 0, res: 0, upd: 0;
       ccEmd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEm8_info" {
     block_ccEm8_info:
         const _ccEm8;
         const 1;
         const 30;
 },
 _ccEmc() //  [R1]
         { []
         }
     {offset
       ccEmc: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccEmJ; else goto ccEmI;
       ccEmJ: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEmI: // global
           _scEhU::P64 = P64[R1 + 7];
           _scEhV::P64 = P64[R1 + 15];
           I64[Hp - 80] = res4_scEhW_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _scEhV::P64;
           I64[Hp - 48] = stg_sel_1_upd_info;
           _ccEmh::P64 = Hp - 80;
           P64[Hp - 32] = _ccEmh::P64;
           I64[Hp - 24] = sat_scEi2_info;
           P64[Hp - 8] = _scEhU::P64;
           P64[Hp] = _ccEmh::P64;
           R2 = Hp - 48;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEmc_info" {
     block_ccEmc_info:
         const _ccEmc;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.668610791 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST4_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST4_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccEns: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccEnt; else goto ccEnu;
       ccEnt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEnu: // global
           I64[Sp - 8] = block_ccEnp_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.ST.Lazy.Imp.$w$c<*>_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fApplicativeST4_info" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST4_info:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST4_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ccEnp() //  [R1, R2]
         { []
         }
     {offset
       ccEnp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccEnx; else goto ccEnw;
       ccEnx: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccEnw: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEnp_info" {
     block_ccEnp_info:
         const _ccEnp;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.676194945 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$w$cliftA2_closure" {
     Control.Monad.ST.Lazy.Imp.$w$cliftA2_closure:
         const Control.Monad.ST.Lazy.Imp.$w$cliftA2_info;
 },
 res1_scEih_entry() //  [R1]
         { []
         }
     {offset
       ccEnT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccEnU; else goto ccEnV;
       ccEnU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEnV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccEnR_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . res1_scEih_info" {
     res1_scEih_info:
         const res1_scEih_entry;
         const 2;
         const 18;
 },
 _ccEnR() //  []
         { []
         }
     {offset
       ccEnR: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccEnR_info" {
     block_ccEnR_info:
         const _ccEnR;
         const 2;
         const 30;
 },
 res2_scEij_entry() //  [R1]
         { []
         }
     {offset
       ccEo4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccEo5; else goto ccEo6;
       ccEo5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEo6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccEo1_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . res2_scEij_info" {
     res2_scEij_info:
         const res2_scEij_entry;
         const 2;
         const 18;
 },
 _ccEo1() //  []
         { []
         }
     {offset
       ccEo1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccEo9; else goto ccEo8;
       ccEo9: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       ccEo8: // global
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 16];
           R2 = Hp - 16;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccEo1_info" {
     block_ccEo1_info:
         const _ccEo1;
         const 2;
         const 30;
 },
 sat_scEix_entry() //  [R1]
         { []
         }
     {offset
       ccEoh: // global
           _scEix::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccEoi; else goto ccEoj;
       ccEoj: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccEol; else goto ccEok;
       ccEol: // global
           HpAlloc = 48;
           goto ccEoi;
       ccEoi: // global
           R1 = _scEix::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEok: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scEix::P64;
           _scEid::P64 = P64[_scEix::P64 + 16];
           _scEih::P64 = P64[_scEix::P64 + 24];
           _scEij::P64 = P64[_scEix::P64 + 32];
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _scEij::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _scEih::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _scEid::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scEix_info" {
     sat_scEix_info:
         const sat_scEix_entry;
         const 3;
         const 15;
 },
 Control.Monad.ST.Lazy.Imp.$w$cliftA2_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       ccEom: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccEoq; else goto ccEop;
       ccEoq: // global
           HpAlloc = 128;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$w$cliftA2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEop: // global
           I64[Hp - 120] = res1_scEih_info;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = res2_scEij_info;
           P64[Hp - 72] = R4;
           _ccEnN::P64 = Hp - 120;
           P64[Hp - 64] = _ccEnN::P64;
           I64[Hp - 56] = stg_sel_1_upd_info;
           _ccEnX::P64 = Hp - 88;
           P64[Hp - 40] = _ccEnX::P64;
           I64[Hp - 32] = sat_scEix_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _ccEnN::P64;
           P64[Hp] = _ccEnX::P64;
           R2 = Hp - 56;
           R1 = Hp - 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$w$cliftA2_info" {
     Control.Monad.ST.Lazy.Imp.$w$cliftA2_info:
         const Control.Monad.ST.Lazy.Imp.$w$cliftA2_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.690068067 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST3_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST3_entry() //  [R2, R3, R4,
                                                         R5]
         { []
         }
     {offset
       ccEpc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccEpd; else goto ccEpe;
       ccEpd: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEpe: // global
           I64[Sp - 8] = block_ccEp9_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.ST.Lazy.Imp.$w$cliftA2_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fApplicativeST3_info" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST3_info:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST3_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _ccEp9() //  [R1, R2]
         { []
         }
     {offset
       ccEp9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccEph; else goto ccEpg;
       ccEph: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccEpg: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEp9_info" {
     block_ccEp9_info:
         const _ccEp9;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.697303127 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_info;
 },
 s'_scEiM_entry() //  [R1]
         { []
         }
     {offset
       ccEpF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccEpG; else goto ccEpH;
       ccEpG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEpH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccEpB_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . s'_scEiM_info" {
     s'_scEiM_info:
         const s'_scEiM_entry;
         const 2;
         const 18;
 },
 _ccEpB() //  []
         { []
         }
     {offset
       ccEpB: // global
           _scEiL::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccEpD_info;
           R2 = _scEiL::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_ccEpB_info" {
     block_ccEpB_info:
         const _ccEpB;
         const 2;
         const 30;
 },
 _ccEpD() //  [R1]
         { []
         }
     {offset
       ccEpD: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccEpD_info" {
     block_ccEpD_info:
         const _ccEpD;
         const 0;
         const 30;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccEpM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccEpQ; else goto ccEpP;
       ccEpQ: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEpP: // global
           I64[Hp - 24] = s'_scEiM_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 24;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fApplicativeST2_info" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST2_info:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.708583153 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$w$c<*_closure" {
     Control.Monad.ST.Lazy.Imp.$w$c<*_closure:
         const Control.Monad.ST.Lazy.Imp.$w$c<*_info;
 },
 s''_scEj2_entry() //  [R1]
         { []
         }
     {offset
       ccEqD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccEqE; else goto ccEqF;
       ccEqE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEqF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccEqz_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . s''_scEj2_info" {
     s''_scEj2_info:
         const s''_scEj2_entry;
         const 2;
         const 18;
 },
 _ccEqz() //  []
         { []
         }
     {offset
       ccEqz: // global
           _scEj1::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccEqB_info;
           R2 = _scEj1::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_ccEqz_info" {
     block_ccEqz_info:
         const _ccEqz;
         const 2;
         const 30;
 },
 _ccEqB() //  [R1]
         { []
         }
     {offset
       ccEqB: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccEqB_info" {
     block_ccEqB_info:
         const _ccEqB;
         const 0;
         const 30;
 },
 Control.Monad.ST.Lazy.Imp.$w$c<*_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccEqK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEqL; else goto ccEqM;
       ccEqL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$w$c<*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEqM: // global
           I64[Sp - 16] = block_ccEqm_info;
           _scEiR::P64 = R2;
           R2 = R4;
           R1 = _scEiR::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$w$c<*_info" {
     Control.Monad.ST.Lazy.Imp.$w$c<*_info:
         const Control.Monad.ST.Lazy.Imp.$w$c<*_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ccEqm() //  [R1]
         { []
         }
     {offset
       ccEqm: // global
           I64[Sp] = block_ccEqq_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucEqS; else goto ccEqr;
       ucEqS: // global
           call _ccEqq(R1) args: 0, res: 0, upd: 0;
       ccEqr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEqm_info" {
     block_ccEqm_info:
         const _ccEqm;
         const 1;
         const 30;
 },
 _ccEqq() //  [R1]
         { []
         }
     {offset
       ccEqq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccEqR; else goto ccEqQ;
       ccEqR: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEqQ: // global
           _scEj0::P64 = P64[R1 + 7];
           _scEj1::P64 = P64[R1 + 15];
           I64[Hp - 24] = s''_scEj2_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _scEj1::P64;
           R2 = Hp - 24;
           R1 = _scEj0::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEqq_info" {
     block_ccEqq_info:
         const _ccEqq;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.721466755 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST1_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccEry: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccErz; else goto ccErA;
       ccErz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccErA: // global
           I64[Sp - 8] = block_ccErv_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.ST.Lazy.Imp.$w$c<*_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fApplicativeST1_info" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST1_info:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST1_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ccErv() //  [R1, R2]
         { []
         }
     {offset
       ccErv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccErD; else goto ccErC;
       ccErD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccErC: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccErv_info" {
     block_ccErv_info:
         const _ccErv;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.728501615 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure:
         const Control.Monad.ST.Lazy.Imp.$fFunctorST2_info;
 },
 res_scEjg_entry() //  [R1]
         { []
         }
     {offset
       ccErZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccEs0; else goto ccEs1;
       ccEs0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEs1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccErX_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . res_scEjg_info" {
     res_scEjg_info:
         const res_scEjg_entry;
         const 2;
         const 18;
 },
 _ccErX() //  []
         { []
         }
     {offset
       ccErX: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccErX_info" {
     block_ccErX_info:
         const _ccErX;
         const 2;
         const 30;
 },
 sat_scEjm_entry() //  [R1]
         { []
         }
     {offset
       ccEs9: // global
           _scEjm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccEsa; else goto ccEsb;
       ccEsb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccEsd; else goto ccEsc;
       ccEsd: // global
           HpAlloc = 24;
           goto ccEsa;
       ccEsa: // global
           R1 = _scEjm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEsc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scEjm::P64;
           _scEjd::P64 = P64[_scEjm::P64 + 16];
           _scEjg::P64 = P64[_scEjm::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _scEjg::P64;
           R2 = Hp - 16;
           R1 = _scEjd::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scEjm_info" {
     sat_scEjm_info:
         const sat_scEjm_entry;
         const 2;
         const 18;
 },
 Control.Monad.ST.Lazy.Imp.$fFunctorST2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccEsf: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccEsj; else goto ccEsi;
       ccEsj: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEsi: // global
           I64[Hp - 104] = res_scEjg_info;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = stg_sel_1_upd_info;
           _ccErT::P64 = Hp - 104;
           P64[Hp - 56] = _ccErT::P64;
           I64[Hp - 48] = sat_scEjm_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = _ccErT::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fFunctorST2_info" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST2_info:
         const Control.Monad.ST.Lazy.Imp.$fFunctorST2_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.7393631 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fFunctorST1_info;
 },
 s'_scEju_entry() //  [R1]
         { []
         }
     {offset
       ccEsY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccEsZ; else goto ccEt0;
       ccEsZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEt0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccEsU_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . s'_scEju_info" {
     s'_scEju_info:
         const s'_scEju_entry;
         const 2;
         const 18;
 },
 _ccEsU() //  []
         { []
         }
     {offset
       ccEsU: // global
           _scEjt::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccEsW_info;
           R2 = _scEjt::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_ccEsU_info" {
     block_ccEsU_info:
         const _ccEsU;
         const 2;
         const 30;
 },
 _ccEsW() //  [R1]
         { []
         }
     {offset
       ccEsW: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccEsW_info" {
     block_ccEsW_info:
         const _ccEsW;
         const 0;
         const 30;
 },
 Control.Monad.ST.Lazy.Imp.$fFunctorST1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccEt6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccEta; else goto ccEt9;
       ccEta: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEt9: // global
           I64[Hp - 48] = s'_scEju_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fFunctorST1_info" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST1_info:
         const Control.Monad.ST.Lazy.Imp.$fFunctorST1_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.748687232 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fFunctorST_closure" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST_closure:
         const GHC.Base.C:Functor_con_info;
         const Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure+3;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.750514152 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST_closure:
         const GHC.Base.C:Applicative_con_info;
         const Control.Monad.ST.Lazy.Imp.$fFunctorST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure+2;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure+4;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure+3;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.75234463 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadST_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadST_closure:
         const GHC.Base.C:Monad_con_info;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fMonadST1_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure+2;
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.754261466 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFailST_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFailST_closure:
         const Control.Monad.Fail.C:MonadFail_con_info;
         const Control.Monad.ST.Lazy.Imp.$fMonadST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.756931914 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.runST_closure" {
     Control.Monad.ST.Lazy.Imp.runST_closure:
         const Control.Monad.ST.Lazy.Imp.runST_info;
 },
 Control.Monad.ST.Lazy.Imp.runST_entry() //  [R2]
         { []
         }
     {offset
       ccEtL: // global
           _scEjz::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccEtM; else goto ccEtN;
       ccEtN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEtP; else goto ccEtO;
       ccEtP: // global
           HpAlloc = 16;
           goto ccEtM;
       ccEtM: // global
           R2 = _scEjz::P64;
           R1 = Control.Monad.ST.Lazy.Imp.runST_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccEtO: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Sp - 8] = block_ccEtJ_info;
           R2 = Hp - 7;
           R1 = _scEjz::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.runST_info" {
     Control.Monad.ST.Lazy.Imp.runST_info:
         const Control.Monad.ST.Lazy.Imp.runST_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _ccEtJ() //  [R1]
         { []
         }
     {offset
       ccEtJ: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEtJ_info" {
     block_ccEtJ_info:
         const _ccEtJ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.763789681 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fMonadFixST1_info;
 },
 ds_scEjG_entry() //  [R1]
         { []
         }
     {offset
       ccEue: // global
           _scEjG::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccEui; else goto ccEuj;
       ccEuj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccEul; else goto ccEuk;
       ccEul: // global
           HpAlloc = 24;
           goto ccEui;
       ccEui: // global
           R1 = _scEjG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEuk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scEjG::P64;
           _scEjE::P64 = P64[_scEjG::P64 + 16];
           _scEjF::P64 = P64[_scEjG::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _scEjG::P64;
           I64[Sp - 24] = block_ccEuc_info;
           R3 = _scEjF::P64;
           R2 = Hp - 16;
           R1 = _scEjE::P64;
           Sp = Sp - 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds_scEjG_info" {
     ds_scEjG_info:
         const ds_scEjG_entry;
         const 2;
         const 18;
 },
 _ccEuc() //  [R1]
         { []
         }
     {offset
       ccEuc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccEuo; else goto ccEun;
       ccEuo: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccEun: // global
           _scEjN::P64 = P64[R1 + 7];
           _scEjO::P64 = P64[R1 + 15];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = _scEjN::P64;
           P64[Hp] = _scEjO::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccEuc_info" {
     block_ccEuc_info:
         const _ccEuc;
         const 0;
         const 30;
 },
 Control.Monad.ST.Lazy.Imp.$fMonadFixST1_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEus: // global
           _scEjF::P64 = R3;
           _scEjE::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccEut; else goto ccEuu;
       ccEuu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccEuw; else goto ccEuv;
       ccEuw: // global
           HpAlloc = 32;
           goto ccEut;
       ccEut: // global
           R3 = _scEjF::P64;
           R2 = _scEjE::P64;
           R1 = Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEuv: // global
           I64[Hp - 24] = ds_scEjG_info;
           P64[Hp - 8] = _scEjE::P64;
           P64[Hp] = _scEjF::P64;
           I64[Sp - 8] = block_ccEup_info;
           R1 = Hp - 24;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucEuA; else goto ccEuq;
       ucEuA: // global
           call _ccEup(R1) args: 0, res: 0, upd: 0;
       ccEuq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.$fMonadFixST1_info" {
     Control.Monad.ST.Lazy.Imp.$fMonadFixST1_info:
         const Control.Monad.ST.Lazy.Imp.$fMonadFixST1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccEup() //  [R1]
         { []
         }
     {offset
       ccEup: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEup_info" {
     block_ccEup_info:
         const _ccEup;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.773932321 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.fixST_closure" {
     Control.Monad.ST.Lazy.Imp.fixST_closure:
         const Control.Monad.ST.Lazy.Imp.fixST_info;
 },
 Control.Monad.ST.Lazy.Imp.fixST_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEv4: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.$fMonadFixST1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.fixST_info" {
     Control.Monad.ST.Lazy.Imp.fixST_info:
         const Control.Monad.ST.Lazy.Imp.fixST_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.777214856 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFixST_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFixST_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Control.Monad.ST.Lazy.Imp.$fMonadST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.780749374 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.strictToLazyST1_closure" {
     Control.Monad.ST.Lazy.Imp.strictToLazyST1_closure:
         const Control.Monad.ST.Lazy.Imp.strictToLazyST1_info;
 },
 Control.Monad.ST.Lazy.Imp.strictToLazyST1_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEvj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEvq; else goto ccEvr;
       ccEvq: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.strictToLazyST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEvr: // global
           I64[Sp - 16] = block_ccEvg_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEvw; else goto ccEvh;
       ucEvw: // global
           call _ccEvg() args: 0, res: 0, upd: 0;
       ccEvh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.strictToLazyST1_info" {
     Control.Monad.ST.Lazy.Imp.strictToLazyST1_info:
         const Control.Monad.ST.Lazy.Imp.strictToLazyST1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccEvg() //  []
         { []
         }
     {offset
       ccEvg: // global
           _scEjT::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEvm_info;
           R1 = _scEjT::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEvg_info" {
     block_ccEvg_info:
         const _ccEvg;
         const 1;
         const 30;
 },
 _ccEvm() //  [R1]
         { []
         }
     {offset
       ccEvm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEvv; else goto ccEvu;
       ccEvv: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEvu: // global
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEvm_info" {
     block_ccEvm_info:
         const _ccEvm;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.788239783 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.strictToLazyST_closure" {
     Control.Monad.ST.Lazy.Imp.strictToLazyST_closure:
         const Control.Monad.ST.Lazy.Imp.strictToLazyST_info;
 },
 Control.Monad.ST.Lazy.Imp.strictToLazyST_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEvT: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.strictToLazyST1_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.strictToLazyST_info" {
     Control.Monad.ST.Lazy.Imp.strictToLazyST_info:
         const Control.Monad.ST.Lazy.Imp.strictToLazyST_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.79255301 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeIOToST1_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeIOToST1_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeIOToST1_info;
 },
 Control.Monad.ST.Lazy.Imp.unsafeIOToST1_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEw7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEwe; else goto ccEwf;
       ccEwe: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.unsafeIOToST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEwf: // global
           I64[Sp - 16] = block_ccEw4_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEwk; else goto ccEw5;
       ucEwk: // global
           call _ccEw4() args: 0, res: 0, upd: 0;
       ccEw5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.unsafeIOToST1_info" {
     Control.Monad.ST.Lazy.Imp.unsafeIOToST1_info:
         const Control.Monad.ST.Lazy.Imp.unsafeIOToST1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccEw4() //  []
         { []
         }
     {offset
       ccEw4: // global
           _scEk1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEwa_info;
           R1 = _scEk1::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEw4_info" {
     block_ccEw4_info:
         const _ccEw4;
         const 1;
         const 30;
 },
 _ccEwa() //  [R1]
         { []
         }
     {offset
       ccEwa: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEwj; else goto ccEwi;
       ccEwj: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEwi: // global
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEwa_info" {
     block_ccEwa_info:
         const _ccEwa;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.800080571 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeIOToST_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeIOToST_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeIOToST_info;
 },
 Control.Monad.ST.Lazy.Imp.unsafeIOToST_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEwH: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.unsafeIOToST1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.unsafeIOToST_info" {
     Control.Monad.ST.Lazy.Imp.unsafeIOToST_info:
         const Control.Monad.ST.Lazy.Imp.unsafeIOToST_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.804195404 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.lazyToStrictST1_closure" {
     Control.Monad.ST.Lazy.Imp.lazyToStrictST1_closure:
         const Control.Monad.ST.Lazy.Imp.lazyToStrictST1_info;
 },
 Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry() //  [R2]
         { []
         }
     {offset
       ccEwV: // global
           _scEk9::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto ccEwZ; else goto ccEx0;
       ccEx0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEx2; else goto ccEx1;
       ccEx2: // global
           HpAlloc = 16;
           goto ccEwZ;
       ccEwZ: // global
           R2 = _scEk9::P64;
           R1 = Control.Monad.ST.Lazy.Imp.lazyToStrictST1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccEx1: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Sp - 8] = block_ccEwT_info;
           R2 = Hp - 7;
           R1 = _scEk9::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.lazyToStrictST1_info" {
     Control.Monad.ST.Lazy.Imp.lazyToStrictST1_info:
         const Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _ccEwT() //  [R1]
         { []
         }
     {offset
       ccEwT: // global
           I64[Sp - 8] = block_ccEwY_info;
           _scEkd::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _scEkd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucEx9; else goto ccEx4;
       ucEx9: // global
           call _ccEwY() args: 0, res: 0, upd: 0;
       ccEx4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEwT_info" {
     block_ccEwT_info:
         const _ccEwT;
         const 0;
         const 30;
 },
 _ccEwY() //  []
         { []
         }
     {offset
       ccEwY: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEwY_info" {
     block_ccEwY_info:
         const _ccEwY;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.811632137 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.lazyToStrictST_closure" {
     Control.Monad.ST.Lazy.Imp.lazyToStrictST_closure:
         const Control.Monad.ST.Lazy.Imp.lazyToStrictST_info;
 },
 Control.Monad.ST.Lazy.Imp.lazyToStrictST_entry() //  [R2]
         { []
         }
     {offset
       ccExu: // global
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.lazyToStrictST_info" {
     Control.Monad.ST.Lazy.Imp.lazyToStrictST_info:
         const Control.Monad.ST.Lazy.Imp.lazyToStrictST_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.815639674 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.stToIO_closure" {
     Control.Monad.ST.Lazy.Imp.stToIO_closure:
         const Control.Monad.ST.Lazy.Imp.stToIO_info;
 },
 Control.Monad.ST.Lazy.Imp.stToIO_entry() //  [R2]
         { []
         }
     {offset
       ccExF: // global
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.stToIO_info" {
     Control.Monad.ST.Lazy.Imp.stToIO_info:
         const Control.Monad.ST.Lazy.Imp.stToIO_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.821510511 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_info;
 },
 sat_scEkt_entry() //  [R1]
         { []
         }
     {offset
       ccEy5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEy9; else goto ccEya;
       ccEy9: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccEya: // global
           I64[Sp - 16] = block_ccEy0_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_scEkt_info" {
     sat_scEkt_info:
         const sat_scEkt_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _ccEy0() //  []
         { []
         }
     {offset
       ccEy0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEyd; else goto ccEyc;
       ccEyd: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccEyc: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           _scEkh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEy3_info;
           R2 = Hp - 7;
           R1 = _scEkh::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEy0_info" {
     block_ccEy0_info:
         const _ccEy0;
         const 1;
         const 30;
 },
 _ccEy3() //  [R1]
         { []
         }
     {offset
       ccEy3: // global
           I64[Sp - 8] = block_ccEy8_info;
           _scEkp::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _scEkp::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucEyk; else goto ccEyf;
       ucEyk: // global
           call _ccEy8() args: 0, res: 0, upd: 0;
       ccEyf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEy3_info" {
     block_ccEy3_info:
         const _ccEy3;
         const 0;
         const 30;
 },
 _ccEy8() //  []
         { []
         }
     {offset
       ccEy8: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEy8_info" {
     block_ccEy8_info:
         const _ccEy8;
         const 1;
         const 30;
 },
 Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEyl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEyq; else goto ccEyr;
       ccEyq: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEyr: // global
           I64[Sp - 16] = block_ccExQ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEyy; else goto ccExR;
       ucEyy: // global
           call _ccExQ(R1) args: 0, res: 0, upd: 0;
       ccExR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_info" {
     Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_info:
         const Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccExQ() //  [R1]
         { []
         }
     {offset
       ccExQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEyu; else goto ccEyt;
       ccEyu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEyt: // global
           I64[Hp - 8] = sat_scEkt_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccEym_info;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.ST.unsafeDupableInterleaveST_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccExQ_info" {
     block_ccExQ_info:
         const _ccExQ;
         const 1;
         const 30;
 },
 _ccEym() //  [R1]
         { []
         }
     {offset
       ccEym: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEyx; else goto ccEyw;
       ccEyx: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEyw: // global
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEym_info" {
     block_ccEym_info:
         const _ccEym;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.835836666 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_info;
 },
 Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEzh: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_info" {
     Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_info:
         const Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.839086547 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$trModule4_bytes" {
     Control.Monad.ST.Lazy.Imp.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.840951902 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$trModule3_closure" {
     Control.Monad.ST.Lazy.Imp.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.842749643 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$trModule2_bytes" {
     Control.Monad.ST.Lazy.Imp.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100,46,83,84,46,76,97,122,121,46,73,109,112]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.84460049 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$trModule1_closure" {
     Control.Monad.ST.Lazy.Imp.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.846443133 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$trModule_closure" {
     Control.Monad.ST.Lazy.Imp.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule3_closure+1;
         const Control.Monad.ST.Lazy.Imp.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.848261376 UTC

[section ""data" . $krep_rcDJ5_closure" {
     $krep_rcDJ5_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.851067159 UTC

[section ""data" . $krep1_rcDJ6_closure" {
     $krep1_rcDJ6_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.852816072 UTC

[section ""data" . $krep2_rcDJ7_closure" {
     $krep2_rcDJ7_closure:
         const :_con_info;
         const $krep1_rcDJ6_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.854968017 UTC

[section ""data" . $krep3_rcDJ8_closure" {
     $krep3_rcDJ8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcState#_closure;
         const $krep2_rcDJ7_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.856779772 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tcState2_bytes" {
     Control.Monad.ST.Lazy.Imp.$tcState2_bytes:
         I8[] [83,116,97,116,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.858585133 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcState1_closure" {
     Control.Monad.ST.Lazy.Imp.$tcState1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcState2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.860483676 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcState_closure" {
     Control.Monad.ST.Lazy.Imp.$tcState_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tcState1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 220923881781706094;
         const 12630832853168782158;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.862399641 UTC

[section ""data" . $krep4_rcDJ9_closure" {
     $krep4_rcDJ9_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcState_closure+1;
         const $krep2_rcDJ7_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.864224475 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'S#1_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'S#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rcDJ8_closure+1;
         const $krep4_rcDJ9_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.86671689 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tc'S#3_bytes" {
     Control.Monad.ST.Lazy.Imp.$tc'S#3_bytes:
         I8[] [39,83,35]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.868484816 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'S#2_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'S#2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tc'S#3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.870437167 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'S#_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'S#_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'S#2_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'S#1_closure+4;
         const 12704778602275544086;
         const 1928505377508739254;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.8723393 UTC

[section ""data" . $krep5_rcDJa_closure" {
     $krep5_rcDJa_closure:
         const :_con_info;
         const $krep4_rcDJ9_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.874160142 UTC

[section ""data" . $krep6_rcDJb_closure" {
     $krep6_rcDJb_closure:
         const :_con_info;
         const $krep_rcDJ5_closure+2;
         const $krep5_rcDJa_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.876030167 UTC

[section ""data" . $krep7_rcDJc_closure" {
     $krep7_rcDJc_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep6_rcDJb_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.878546749 UTC

[section ""data" . $krep8_rcDJd_closure" {
     $krep8_rcDJd_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rcDJ9_closure+1;
         const $krep7_rcDJc_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.880337788 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tcST2_bytes" {
     Control.Monad.ST.Lazy.Imp.$tcST2_bytes:
         I8[] [83,84]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.882180113 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcST1_closure" {
     Control.Monad.ST.Lazy.Imp.$tcST1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcST2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.884022302 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcST_closure" {
     Control.Monad.ST.Lazy.Imp.$tcST_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tcST1_closure+1;
         const GHC.Types.krep$*->*->*_closure;
         const 9758985700159114765;
         const 4154811637844139714;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.886681996 UTC

[section ""data" . $krep9_rcDJe_closure" {
     $krep9_rcDJe_closure:
         const :_con_info;
         const $krep_rcDJ5_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.888506963 UTC

[section ""data" . $krep10_rcDJf_closure" {
     $krep10_rcDJf_closure:
         const :_con_info;
         const $krep1_rcDJ6_closure+2;
         const $krep9_rcDJe_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.890383028 UTC

[section ""data" . $krep11_rcDJg_closure" {
     $krep11_rcDJg_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcST_closure+1;
         const $krep10_rcDJf_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.892279441 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'ST1_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'ST1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rcDJd_closure+4;
         const $krep11_rcDJg_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.894131933 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tc'ST3_bytes" {
     Control.Monad.ST.Lazy.Imp.$tc'ST3_bytes:
         I8[] [39,83,84]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.895929996 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'ST2_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'ST2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tc'ST3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.897850641 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'ST_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'ST_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'ST2_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'ST1_closure+4;
         const 5656684040178075861;
         const 6626797926801395533;
         const 2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.900295609 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.S#_closure" {
     Control.Monad.ST.Lazy.Imp.S#_closure:
         const Control.Monad.ST.Lazy.Imp.S#_info;
 },
 Control.Monad.ST.Lazy.Imp.S#_entry() //  []
         { []
         }
     {offset
       ccEzY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEA2; else goto ccEA1;
       ccEA2: // global
           HpAlloc = 16;
           R1 = Control.Monad.ST.Lazy.Imp.S#_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccEA1: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.S#_info" {
     Control.Monad.ST.Lazy.Imp.S#_info:
         const Control.Monad.ST.Lazy.Imp.S#_entry;
         const 0;
         const 14;
         const 4294967299;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.90458414 UTC

[section ""cstring" . icEAa_str" {
     icEAa_str:
         I8[] [98,97,115,101,58,67,111,110,116,114,111,108,46,77,111,110,97,100,46,83,84,46,76,97,122,121,46,73,109,112,46,83,35]
 },
 Control.Monad.ST.Lazy.Imp.S#_con_entry() //  [R1]
         { []
         }
     {offset
       ccEA9: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.ST.Lazy.Imp.S#_con_info" {
     Control.Monad.ST.Lazy.Imp.S#_con_info:
         const Control.Monad.ST.Lazy.Imp.S#_con_entry;
         const 4294967296;
         const 3;
         const icEAa_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:33.908349777 UTC

[section ""relreadonly" . ScEkV_srt" {
     ScEkV_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
 }]

