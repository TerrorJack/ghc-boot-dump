
==================== Output Cmm ====================
2018-03-16 16:07:32.766995724 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:32.767967121 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST5_entry() //  [R2, R3]
         { info_tbl: [(ccDMr,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDMr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccDMv; else goto ccDMu;
       ccDMv: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDMu: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.769063495 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure:
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_info;
         const 0;
 },
 Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_entry() //  [R2]
         { info_tbl: [(ccDMA,
                       label: Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDMA: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.770047573 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unST1_closure" {
     Control.Monad.ST.Lazy.Imp.unST1_closure:
         const Control.Monad.ST.Lazy.Imp.unST1_info;
 },
 Control.Monad.ST.Lazy.Imp.unST1_entry() //  [R2]
         { info_tbl: [(ccDMI,
                       label: Control.Monad.ST.Lazy.Imp.unST1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDMI: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.770923256 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unST_closure" {
     Control.Monad.ST.Lazy.Imp.unST_closure:
         const Control.Monad.ST.Lazy.Imp.unST_info;
 },
 Control.Monad.ST.Lazy.Imp.unST_entry() //  [R2]
         { info_tbl: [(ccDMP,
                       label: Control.Monad.ST.Lazy.Imp.unST_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDMP: // global
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.unST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.772087034 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fMonadST1_info;
 },
 res_scDJp_entry() //  [R1]
         { info_tbl: [(ccDN2,
                       label: res_scDJp_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDN2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccDN3; else goto ccDN4;
       ccDN3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDN4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccDN0_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccDN0() //  []
         { info_tbl: [(ccDN0,
                       label: block_ccDN0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDN0: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fMonadST1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccDN8,
                       label: Control.Monad.ST.Lazy.Imp.$fMonadST1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDN8: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccDNc; else goto ccDNb;
       ccDNc: // global
           HpAlloc = 80;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fMonadST1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDNb: // global
           I64[Hp - 72] = res_scDJp_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = stg_sel_1_upd_info;
           _ccDMW::P64 = Hp - 72;
           P64[Hp - 24] = _ccDMW::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _ccDMW::P64;
           _scDJn::P64 = R3;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _scDJn::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.774189544 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$w$c<*>_closure" {
     Control.Monad.ST.Lazy.Imp.$w$c<*>_closure:
         const Control.Monad.ST.Lazy.Imp.$w$c<*>_info;
 },
 res4_scDJK_entry() //  [R1]
         { info_tbl: [(ccDNB,
                       label: res4_scDJK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDNB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccDNC; else goto ccDND;
       ccDNC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDND: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccDNz_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccDNz() //  []
         { info_tbl: [(ccDNz,
                       label: block_ccDNz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDNz: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scDJQ_entry() //  [R1]
         { info_tbl: [(ccDNL,
                       label: sat_scDJQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDNL: // global
           _scDJQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccDNM; else goto ccDNN;
       ccDNN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccDNP; else goto ccDNO;
       ccDNP: // global
           HpAlloc = 24;
           goto ccDNM;
       ccDNM: // global
           R1 = _scDJQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDNO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scDJQ::P64;
           _scDJI::P64 = P64[_scDJQ::P64 + 16];
           _scDJK::P64 = P64[_scDJQ::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _scDJK::P64;
           R2 = Hp - 16;
           R1 = _scDJI::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$w$c<*>_entry() //  [R2, R3, R4]
         { info_tbl: [(ccDNQ,
                       label: Control.Monad.ST.Lazy.Imp.$w$c<*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDNQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccDNR; else goto ccDNS;
       ccDNR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$w$c<*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDNS: // global
           I64[Sp - 16] = block_ccDNm_info;
           _scDJz::P64 = R2;
           R2 = R4;
           R1 = _scDJz::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDNm() //  [R1]
         { info_tbl: [(ccDNm,
                       label: block_ccDNm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDNm: // global
           I64[Sp] = block_ccDNq_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucDNY; else goto ccDNr;
       ucDNY: // global
           call _ccDNq(R1) args: 0, res: 0, upd: 0;
       ccDNr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDNq() //  [R1]
         { info_tbl: [(ccDNq,
                       label: block_ccDNq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDNq: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccDNX; else goto ccDNW;
       ccDNX: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccDNW: // global
           _scDJI::P64 = P64[R1 + 7];
           _scDJJ::P64 = P64[R1 + 15];
           I64[Hp - 80] = res4_scDJK_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _scDJJ::P64;
           I64[Hp - 48] = stg_sel_1_upd_info;
           _ccDNv::P64 = Hp - 80;
           P64[Hp - 32] = _ccDNv::P64;
           I64[Hp - 24] = sat_scDJQ_info;
           P64[Hp - 8] = _scDJI::P64;
           P64[Hp] = _ccDNv::P64;
           R2 = Hp - 48;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.776473637 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST4_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST4_entry() //  [R2, R3, R4]
         { info_tbl: [(ccDO6,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDO6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccDO7; else goto ccDO8;
       ccDO7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDO8: // global
           I64[Sp - 8] = block_ccDO3_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.ST.Lazy.Imp.$w$c<*>_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccDO3() //  [R1, R2]
         { info_tbl: [(ccDO3,
                       label: block_ccDO3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDO3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccDOb; else goto ccDOa;
       ccDOb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccDOa: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.778440821 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$w$cliftA2_closure" {
     Control.Monad.ST.Lazy.Imp.$w$cliftA2_closure:
         const Control.Monad.ST.Lazy.Imp.$w$cliftA2_info;
 },
 res1_scDK5_entry() //  [R1]
         { info_tbl: [(ccDOm,
                       label: res1_scDK5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDOm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccDOn; else goto ccDOo;
       ccDOn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDOo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccDOk_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccDOk() //  []
         { info_tbl: [(ccDOk,
                       label: block_ccDOk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDOk: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 res2_scDK7_entry() //  [R1]
         { info_tbl: [(ccDOx,
                       label: res2_scDK7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDOx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccDOy; else goto ccDOz;
       ccDOy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDOz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccDOu_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccDOu() //  []
         { info_tbl: [(ccDOu,
                       label: block_ccDOu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDOu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccDOC; else goto ccDOB;
       ccDOC: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       ccDOB: // global
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 16];
           R2 = Hp - 16;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scDKl_entry() //  [R1]
         { info_tbl: [(ccDOK,
                       label: sat_scDKl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDOK: // global
           _scDKl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccDOL; else goto ccDOM;
       ccDOM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccDOO; else goto ccDON;
       ccDOO: // global
           HpAlloc = 48;
           goto ccDOL;
       ccDOL: // global
           R1 = _scDKl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDON: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scDKl::P64;
           _scDK1::P64 = P64[_scDKl::P64 + 16];
           _scDK5::P64 = P64[_scDKl::P64 + 24];
           _scDK7::P64 = P64[_scDKl::P64 + 32];
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _scDK7::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _scDK5::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _scDK1::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$w$cliftA2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccDOP,
                       label: Control.Monad.ST.Lazy.Imp.$w$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDOP: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccDOT; else goto ccDOS;
       ccDOT: // global
           HpAlloc = 128;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$w$cliftA2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDOS: // global
           I64[Hp - 120] = res1_scDK5_info;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = res2_scDK7_info;
           P64[Hp - 72] = R4;
           _ccDOg::P64 = Hp - 120;
           P64[Hp - 64] = _ccDOg::P64;
           I64[Hp - 56] = stg_sel_1_upd_info;
           _ccDOq::P64 = Hp - 88;
           P64[Hp - 40] = _ccDOq::P64;
           I64[Hp - 32] = sat_scDKl_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _ccDOg::P64;
           P64[Hp] = _ccDOq::P64;
           R2 = Hp - 56;
           R1 = Hp - 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.780914975 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST3_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST3_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(ccDP1,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDP1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccDP2; else goto ccDP3;
       ccDP2: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDP3: // global
           I64[Sp - 8] = block_ccDOY_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.ST.Lazy.Imp.$w$cliftA2_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccDOY() //  [R1, R2]
         { info_tbl: [(ccDOY,
                       label: block_ccDOY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDOY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccDP6; else goto ccDP5;
       ccDP6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccDP5: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.782502441 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_info;
 },
 s'_scDKA_entry() //  [R1]
         { info_tbl: [(ccDPj,
                       label: s'_scDKA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDPj: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccDPk; else goto ccDPl;
       ccDPk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDPl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccDPf_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccDPf() //  []
         { info_tbl: [(ccDPf,
                       label: block_ccDPf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDPf: // global
           _scDKz::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccDPh_info;
           R2 = _scDKz::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccDPh() //  [R1]
         { info_tbl: [(ccDPh,
                       label: block_ccDPh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDPh: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST2_entry() //  [R2, R3, R4]
         { info_tbl: [(ccDPq,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDPq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccDPu; else goto ccDPt;
       ccDPu: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDPt: // global
           I64[Hp - 24] = s'_scDKA_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 24;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.784466772 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$w$c<*_closure" {
     Control.Monad.ST.Lazy.Imp.$w$c<*_closure:
         const Control.Monad.ST.Lazy.Imp.$w$c<*_info;
 },
 s''_scDKQ_entry() //  [R1]
         { info_tbl: [(ccDPV,
                       label: s''_scDKQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDPV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccDPW; else goto ccDPX;
       ccDPW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDPX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccDPR_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccDPR() //  []
         { info_tbl: [(ccDPR,
                       label: block_ccDPR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDPR: // global
           _scDKP::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccDPT_info;
           R2 = _scDKP::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccDPT() //  [R1]
         { info_tbl: [(ccDPT,
                       label: block_ccDPT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDPT: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$w$c<*_entry() //  [R2, R3, R4]
         { info_tbl: [(ccDQ2,
                       label: Control.Monad.ST.Lazy.Imp.$w$c<*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDQ2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccDQ3; else goto ccDQ4;
       ccDQ3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$w$c<*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDQ4: // global
           I64[Sp - 16] = block_ccDPE_info;
           _scDKF::P64 = R2;
           R2 = R4;
           R1 = _scDKF::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDPE() //  [R1]
         { info_tbl: [(ccDPE,
                       label: block_ccDPE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDPE: // global
           I64[Sp] = block_ccDPI_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucDQa; else goto ccDPJ;
       ucDQa: // global
           call _ccDPI(R1) args: 0, res: 0, upd: 0;
       ccDPJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDPI() //  [R1]
         { info_tbl: [(ccDPI,
                       label: block_ccDPI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDPI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccDQ9; else goto ccDQ8;
       ccDQ9: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccDQ8: // global
           _scDKO::P64 = P64[R1 + 7];
           _scDKP::P64 = P64[R1 + 15];
           I64[Hp - 24] = s''_scDKQ_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _scDKP::P64;
           R2 = Hp - 24;
           R1 = _scDKO::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.786579966 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST1_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccDQi,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDQi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccDQj; else goto ccDQk;
       ccDQj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDQk: // global
           I64[Sp - 8] = block_ccDQf_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.ST.Lazy.Imp.$w$c<*_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccDQf() //  [R1, R2]
         { info_tbl: [(ccDQf,
                       label: block_ccDQf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDQf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccDQn; else goto ccDQm;
       ccDQn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccDQm: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.788283169 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure:
         const Control.Monad.ST.Lazy.Imp.$fFunctorST2_info;
 },
 res_scDL4_entry() //  [R1]
         { info_tbl: [(ccDQy,
                       label: res_scDL4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDQy: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccDQz; else goto ccDQA;
       ccDQz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDQA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccDQw_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccDQw() //  []
         { info_tbl: [(ccDQw,
                       label: block_ccDQw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDQw: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scDLa_entry() //  [R1]
         { info_tbl: [(ccDQI,
                       label: sat_scDLa_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDQI: // global
           _scDLa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccDQJ; else goto ccDQK;
       ccDQK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccDQM; else goto ccDQL;
       ccDQM: // global
           HpAlloc = 24;
           goto ccDQJ;
       ccDQJ: // global
           R1 = _scDLa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDQL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scDLa::P64;
           _scDL1::P64 = P64[_scDLa::P64 + 16];
           _scDL4::P64 = P64[_scDLa::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _scDL4::P64;
           R2 = Hp - 16;
           R1 = _scDL1::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fFunctorST2_entry() //  [R2, R3, R4]
         { info_tbl: [(ccDQO,
                       label: Control.Monad.ST.Lazy.Imp.$fFunctorST2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDQO: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccDQS; else goto ccDQR;
       ccDQS: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDQR: // global
           I64[Hp - 104] = res_scDL4_info;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = stg_sel_1_upd_info;
           _ccDQs::P64 = Hp - 104;
           P64[Hp - 56] = _ccDQs::P64;
           I64[Hp - 48] = sat_scDLa_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = _ccDQs::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.790434132 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fFunctorST1_info;
 },
 s'_scDLi_entry() //  [R1]
         { info_tbl: [(ccDR5,
                       label: s'_scDLi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDR5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccDR6; else goto ccDR7;
       ccDR6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDR7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccDR1_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccDR1() //  []
         { info_tbl: [(ccDR1,
                       label: block_ccDR1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDR1: // global
           _scDLh::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccDR3_info;
           R2 = _scDLh::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccDR3() //  [R1]
         { info_tbl: [(ccDR3,
                       label: block_ccDR3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDR3: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fFunctorST1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccDRd,
                       label: Control.Monad.ST.Lazy.Imp.$fFunctorST1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDRd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccDRh; else goto ccDRg;
       ccDRh: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDRg: // global
           I64[Hp - 48] = s'_scDLi_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.791888869 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fFunctorST_closure" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST_closure:
         const GHC.Base.C:Functor_con_info;
         const Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.792580338 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST_closure:
         const GHC.Base.C:Applicative_con_info;
         const Control.Monad.ST.Lazy.Imp.$fFunctorST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure+2;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure+4;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.793321873 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadST_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadST_closure:
         const GHC.Base.C:Monad_con_info;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fMonadST1_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure+2;
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.7940186 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFailST_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFailST_closure:
         const Control.Monad.Fail.C:MonadFail_con_info;
         const Control.Monad.ST.Lazy.Imp.$fMonadST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.794887047 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.runST_closure" {
     Control.Monad.ST.Lazy.Imp.runST_closure:
         const Control.Monad.ST.Lazy.Imp.runST_info;
 },
 Control.Monad.ST.Lazy.Imp.runST_entry() //  [R2]
         { info_tbl: [(ccDRp,
                       label: Control.Monad.ST.Lazy.Imp.runST_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDRp: // global
           _scDLn::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccDRq; else goto ccDRr;
       ccDRr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccDRt; else goto ccDRs;
       ccDRt: // global
           HpAlloc = 16;
           goto ccDRq;
       ccDRq: // global
           R2 = _scDLn::P64;
           R1 = Control.Monad.ST.Lazy.Imp.runST_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccDRs: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Sp - 8] = block_ccDRn_info;
           R2 = Hp - 7;
           R1 = _scDLn::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDRn() //  [R1]
         { info_tbl: [(ccDRn,
                       label: block_ccDRn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDRn: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.796491406 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fMonadFixST1_info;
 },
 ds_scDLu_entry() //  [R1]
         { info_tbl: [(ccDRI,
                       label: ds_scDLu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDRI: // global
           _scDLu::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccDRM; else goto ccDRN;
       ccDRN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccDRP; else goto ccDRO;
       ccDRP: // global
           HpAlloc = 24;
           goto ccDRM;
       ccDRM: // global
           R1 = _scDLu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDRO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scDLu::P64;
           _scDLs::P64 = P64[_scDLu::P64 + 16];
           _scDLt::P64 = P64[_scDLu::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _scDLu::P64;
           I64[Sp - 24] = block_ccDRG_info;
           R3 = _scDLt::P64;
           R2 = Hp - 16;
           R1 = _scDLs::P64;
           Sp = Sp - 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccDRG() //  [R1]
         { info_tbl: [(ccDRG,
                       label: block_ccDRG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDRG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccDRS; else goto ccDRR;
       ccDRS: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccDRR: // global
           _scDLB::P64 = P64[R1 + 7];
           _scDLC::P64 = P64[R1 + 15];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = _scDLB::P64;
           P64[Hp] = _scDLC::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fMonadFixST1_entry() //  [R2, R3]
         { info_tbl: [(ccDRW,
                       label: Control.Monad.ST.Lazy.Imp.$fMonadFixST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDRW: // global
           _scDLt::P64 = R3;
           _scDLs::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccDRX; else goto ccDRY;
       ccDRY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccDS0; else goto ccDRZ;
       ccDS0: // global
           HpAlloc = 32;
           goto ccDRX;
       ccDRX: // global
           R3 = _scDLt::P64;
           R2 = _scDLs::P64;
           R1 = Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDRZ: // global
           I64[Hp - 24] = ds_scDLu_info;
           P64[Hp - 8] = _scDLs::P64;
           P64[Hp] = _scDLt::P64;
           I64[Sp - 8] = block_ccDRT_info;
           R1 = Hp - 24;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucDS4; else goto ccDRU;
       ucDS4: // global
           call _ccDRT(R1) args: 0, res: 0, upd: 0;
       ccDRU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDRT() //  [R1]
         { info_tbl: [(ccDRT,
                       label: block_ccDRT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDRT: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.798426401 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.fixST_closure" {
     Control.Monad.ST.Lazy.Imp.fixST_closure:
         const Control.Monad.ST.Lazy.Imp.fixST_info;
 },
 Control.Monad.ST.Lazy.Imp.fixST_entry() //  [R2, R3]
         { info_tbl: [(ccDS9,
                       label: Control.Monad.ST.Lazy.Imp.fixST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDS9: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.$fMonadFixST1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.799264769 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFixST_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFixST_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Control.Monad.ST.Lazy.Imp.$fMonadST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.800256957 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.strictToLazyST1_closure" {
     Control.Monad.ST.Lazy.Imp.strictToLazyST1_closure:
         const Control.Monad.ST.Lazy.Imp.strictToLazyST1_info;
 },
 Control.Monad.ST.Lazy.Imp.strictToLazyST1_entry() //  [R2, R3]
         { info_tbl: [(ccDSj,
                       label: Control.Monad.ST.Lazy.Imp.strictToLazyST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDSj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccDSq; else goto ccDSr;
       ccDSq: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.strictToLazyST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDSr: // global
           I64[Sp - 16] = block_ccDSg_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucDSw; else goto ccDSh;
       ucDSw: // global
           call _ccDSg() args: 0, res: 0, upd: 0;
       ccDSh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDSg() //  []
         { info_tbl: [(ccDSg,
                       label: block_ccDSg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDSg: // global
           _scDLH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccDSm_info;
           R1 = _scDLH::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDSm() //  [R1]
         { info_tbl: [(ccDSm,
                       label: block_ccDSm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDSm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccDSv; else goto ccDSu;
       ccDSv: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccDSu: // global
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.801802633 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.strictToLazyST_closure" {
     Control.Monad.ST.Lazy.Imp.strictToLazyST_closure:
         const Control.Monad.ST.Lazy.Imp.strictToLazyST_info;
 },
 Control.Monad.ST.Lazy.Imp.strictToLazyST_entry() //  [R2, R3]
         { info_tbl: [(ccDSB,
                       label: Control.Monad.ST.Lazy.Imp.strictToLazyST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDSB: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.strictToLazyST1_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.802918363 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeIOToST1_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeIOToST1_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeIOToST1_info;
 },
 Control.Monad.ST.Lazy.Imp.unsafeIOToST1_entry() //  [R2, R3]
         { info_tbl: [(ccDSL,
                       label: Control.Monad.ST.Lazy.Imp.unsafeIOToST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDSL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccDSS; else goto ccDST;
       ccDSS: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.unsafeIOToST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDST: // global
           I64[Sp - 16] = block_ccDSI_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucDSY; else goto ccDSJ;
       ucDSY: // global
           call _ccDSI() args: 0, res: 0, upd: 0;
       ccDSJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDSI() //  []
         { info_tbl: [(ccDSI,
                       label: block_ccDSI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDSI: // global
           _scDLP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccDSO_info;
           R1 = _scDLP::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDSO() //  [R1]
         { info_tbl: [(ccDSO,
                       label: block_ccDSO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDSO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccDSX; else goto ccDSW;
       ccDSX: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccDSW: // global
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.804337942 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeIOToST_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeIOToST_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeIOToST_info;
 },
 Control.Monad.ST.Lazy.Imp.unsafeIOToST_entry() //  [R2, R3]
         { info_tbl: [(ccDT3,
                       label: Control.Monad.ST.Lazy.Imp.unsafeIOToST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDT3: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.unsafeIOToST1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.80543972 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.lazyToStrictST1_closure" {
     Control.Monad.ST.Lazy.Imp.lazyToStrictST1_closure:
         const Control.Monad.ST.Lazy.Imp.lazyToStrictST1_info;
 },
 Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry() //  [R2]
         { info_tbl: [(ccDTd,
                       label: Control.Monad.ST.Lazy.Imp.lazyToStrictST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDTd: // global
           _scDLX::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto ccDTh; else goto ccDTi;
       ccDTi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccDTk; else goto ccDTj;
       ccDTk: // global
           HpAlloc = 16;
           goto ccDTh;
       ccDTh: // global
           R2 = _scDLX::P64;
           R1 = Control.Monad.ST.Lazy.Imp.lazyToStrictST1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccDTj: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Sp - 8] = block_ccDTb_info;
           R2 = Hp - 7;
           R1 = _scDLX::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDTb() //  [R1]
         { info_tbl: [(ccDTb,
                       label: block_ccDTb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDTb: // global
           I64[Sp - 8] = block_ccDTg_info;
           _scDM1::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _scDM1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucDTr; else goto ccDTm;
       ucDTr: // global
           call _ccDTg() args: 0, res: 0, upd: 0;
       ccDTm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDTg() //  []
         { info_tbl: [(ccDTg,
                       label: block_ccDTg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDTg: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.806825265 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.lazyToStrictST_closure" {
     Control.Monad.ST.Lazy.Imp.lazyToStrictST_closure:
         const Control.Monad.ST.Lazy.Imp.lazyToStrictST_info;
 },
 Control.Monad.ST.Lazy.Imp.lazyToStrictST_entry() //  [R2]
         { info_tbl: [(ccDTw,
                       label: Control.Monad.ST.Lazy.Imp.lazyToStrictST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDTw: // global
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.807745307 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.stToIO_closure" {
     Control.Monad.ST.Lazy.Imp.stToIO_closure:
         const Control.Monad.ST.Lazy.Imp.stToIO_info;
 },
 Control.Monad.ST.Lazy.Imp.stToIO_entry() //  [R2]
         { info_tbl: [(ccDTD,
                       label: Control.Monad.ST.Lazy.Imp.stToIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDTD: // global
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.809286345 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_info;
 },
 sat_scDMh_entry() //  [R1]
         { info_tbl: [(ccDTZ,
                       label: sat_scDMh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDTZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccDU3; else goto ccDU4;
       ccDU3: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccDU4: // global
           I64[Sp - 16] = block_ccDTU_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _ccDTU() //  []
         { info_tbl: [(ccDTU,
                       label: block_ccDTU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDTU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccDU7; else goto ccDU6;
       ccDU7: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccDU6: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           _scDM5::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccDTX_info;
           R2 = Hp - 7;
           R1 = _scDM5::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDTX() //  [R1]
         { info_tbl: [(ccDTX,
                       label: block_ccDTX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDTX: // global
           I64[Sp - 8] = block_ccDU2_info;
           _scDMd::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _scDMd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucDUe; else goto ccDU9;
       ucDUe: // global
           call _ccDU2() args: 0, res: 0, upd: 0;
       ccDU9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDU2() //  []
         { info_tbl: [(ccDU2,
                       label: block_ccDU2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDU2: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_entry() //  [R2, R3]
         { info_tbl: [(ccDUf,
                       label: Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDUf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccDUk; else goto ccDUl;
       ccDUk: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDUl: // global
           I64[Sp - 16] = block_ccDTK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucDUs; else goto ccDTL;
       ucDUs: // global
           call _ccDTK(R1) args: 0, res: 0, upd: 0;
       ccDTL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDTK() //  [R1]
         { info_tbl: [(ccDTK,
                       label: block_ccDTK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDTK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccDUo; else goto ccDUn;
       ccDUo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccDUn: // global
           I64[Hp - 8] = sat_scDMh_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccDUg_info;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.ST.unsafeDupableInterleaveST_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccDUg() //  [R1]
         { info_tbl: [(ccDUg,
                       label: block_ccDUg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDUg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccDUr; else goto ccDUq;
       ccDUr: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccDUq: // global
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.811641658 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_info;
 },
 Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_entry() //  [R2, R3]
         { info_tbl: [(ccDUx,
                       label: Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDUx: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.812416309 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$trModule4_bytes" {
     Control.Monad.ST.Lazy.Imp.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.813032217 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$trModule3_closure" {
     Control.Monad.ST.Lazy.Imp.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.815706658 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$trModule2_bytes" {
     Control.Monad.ST.Lazy.Imp.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100,46,83,84,46,76,97,122,121,46,73,109,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.816301769 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$trModule1_closure" {
     Control.Monad.ST.Lazy.Imp.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.816917735 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$trModule_closure" {
     Control.Monad.ST.Lazy.Imp.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule3_closure+1;
         const Control.Monad.ST.Lazy.Imp.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.817546228 UTC

[section ""data" . $krep_rcDJ5_closure" {
     $krep_rcDJ5_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.818174335 UTC

[section ""data" . $krep1_rcDJ6_closure" {
     $krep1_rcDJ6_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.818761038 UTC

[section ""data" . $krep2_rcDJ7_closure" {
     $krep2_rcDJ7_closure:
         const :_con_info;
         const $krep1_rcDJ6_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.819422869 UTC

[section ""data" . $krep3_rcDJ8_closure" {
     $krep3_rcDJ8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcState#_closure;
         const $krep2_rcDJ7_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.820048746 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tcState2_bytes" {
     Control.Monad.ST.Lazy.Imp.$tcState2_bytes:
         I8[] [83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.82072369 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcState1_closure" {
     Control.Monad.ST.Lazy.Imp.$tcState1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.821345358 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcState_closure" {
     Control.Monad.ST.Lazy.Imp.$tcState_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tcState1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 220923881781706094;
         const 12630832853168782158;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.822029599 UTC

[section ""data" . $krep4_rcDJ9_closure" {
     $krep4_rcDJ9_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcState_closure+1;
         const $krep2_rcDJ7_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.822652064 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'S#1_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'S#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rcDJ8_closure+1;
         const $krep4_rcDJ9_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.823275078 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tc'S#3_bytes" {
     Control.Monad.ST.Lazy.Imp.$tc'S#3_bytes:
         I8[] [39,83,35]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.823871805 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'S#2_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'S#2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tc'S#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.824483483 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'S#_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'S#_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'S#2_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'S#1_closure+4;
         const 12704778602275544086;
         const 1928505377508739254;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.825186057 UTC

[section ""data" . $krep5_rcDJa_closure" {
     $krep5_rcDJa_closure:
         const :_con_info;
         const $krep4_rcDJ9_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.825867058 UTC

[section ""data" . $krep6_rcDJb_closure" {
     $krep6_rcDJb_closure:
         const :_con_info;
         const $krep_rcDJ5_closure+2;
         const $krep5_rcDJa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.826498751 UTC

[section ""data" . $krep7_rcDJc_closure" {
     $krep7_rcDJc_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep6_rcDJb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.827127485 UTC

[section ""data" . $krep8_rcDJd_closure" {
     $krep8_rcDJd_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rcDJ9_closure+1;
         const $krep7_rcDJc_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.827738118 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tcST2_bytes" {
     Control.Monad.ST.Lazy.Imp.$tcST2_bytes:
         I8[] [83,84]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.828372829 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcST1_closure" {
     Control.Monad.ST.Lazy.Imp.$tcST1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcST2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.829011692 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcST_closure" {
     Control.Monad.ST.Lazy.Imp.$tcST_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tcST1_closure+1;
         const GHC.Types.krep$*->*->*_closure;
         const 9758985700159114765;
         const 4154811637844139714;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.829721083 UTC

[section ""data" . $krep9_rcDJe_closure" {
     $krep9_rcDJe_closure:
         const :_con_info;
         const $krep_rcDJ5_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.830353707 UTC

[section ""data" . $krep10_rcDJf_closure" {
     $krep10_rcDJf_closure:
         const :_con_info;
         const $krep1_rcDJ6_closure+2;
         const $krep9_rcDJe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.83098665 UTC

[section ""data" . $krep11_rcDJg_closure" {
     $krep11_rcDJg_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcST_closure+1;
         const $krep10_rcDJf_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.831589433 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'ST1_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'ST1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rcDJd_closure+4;
         const $krep11_rcDJg_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.832165432 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tc'ST3_bytes" {
     Control.Monad.ST.Lazy.Imp.$tc'ST3_bytes:
         I8[] [39,83,84]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.832743002 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'ST2_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'ST2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tc'ST3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.833414261 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'ST_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'ST_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'ST2_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'ST1_closure+4;
         const 5656684040178075861;
         const 6626797926801395533;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.834300144 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.S#_closure" {
     Control.Monad.ST.Lazy.Imp.S#_closure:
         const Control.Monad.ST.Lazy.Imp.S#_info;
 },
 Control.Monad.ST.Lazy.Imp.S#_entry() //  []
         { info_tbl: [(ccDUF,
                       label: Control.Monad.ST.Lazy.Imp.S#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDUF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccDUJ; else goto ccDUI;
       ccDUJ: // global
           HpAlloc = 16;
           R1 = Control.Monad.ST.Lazy.Imp.S#_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccDUI: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.83522517 UTC

[Control.Monad.ST.Lazy.Imp.S#_con_entry() //  [R1]
         { info_tbl: [(ccDUK,
                       label: Control.Monad.ST.Lazy.Imp.S#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,77,111,110,97,100,46,83,84,46,76,97,122,121,46,73,109,112,46,83,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDUK: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.835980638 UTC

[section ""relreadonly" . ScDMD_srt" {
     ScDMD_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.836586843 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:32.837894878 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST5_entry() //  [R2, R3]
         { info_tbl: [(ccDUQ,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDUQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccDUU; else goto ccDUT;
       ccDUU: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDUT: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.838859842 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure:
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_info;
         const 0;
 },
 Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_entry() //  [R2]
         { info_tbl: [(ccDUZ,
                       label: Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDUZ: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.839706434 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unST1_closure" {
     Control.Monad.ST.Lazy.Imp.unST1_closure:
         const Control.Monad.ST.Lazy.Imp.unST1_info;
 },
 Control.Monad.ST.Lazy.Imp.unST1_entry() //  [R2]
         { info_tbl: [(ccDV6,
                       label: Control.Monad.ST.Lazy.Imp.unST1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDV6: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.84055946 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unST_closure" {
     Control.Monad.ST.Lazy.Imp.unST_closure:
         const Control.Monad.ST.Lazy.Imp.unST_info;
 },
 Control.Monad.ST.Lazy.Imp.unST_entry() //  [R2]
         { info_tbl: [(ccDVd,
                       label: Control.Monad.ST.Lazy.Imp.unST_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDVd: // global
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.unST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.841743692 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fMonadST1_info;
 },
 res_scDJp_entry() //  [R1]
         { info_tbl: [(ccDVq,
                       label: res_scDJp_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDVq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccDVr; else goto ccDVs;
       ccDVr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDVs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccDVo_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccDVo() //  []
         { info_tbl: [(ccDVo,
                       label: block_ccDVo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDVo: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fMonadST1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccDVw,
                       label: Control.Monad.ST.Lazy.Imp.$fMonadST1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDVw: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccDVA; else goto ccDVz;
       ccDVA: // global
           HpAlloc = 80;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fMonadST1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDVz: // global
           I64[Hp - 72] = res_scDJp_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = stg_sel_1_upd_info;
           _ccDVk::P64 = Hp - 72;
           P64[Hp - 24] = _ccDVk::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _ccDVk::P64;
           _scDJn::P64 = R3;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _scDJn::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.843802108 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$w$c<*>_closure" {
     Control.Monad.ST.Lazy.Imp.$w$c<*>_closure:
         const Control.Monad.ST.Lazy.Imp.$w$c<*>_info;
 },
 res4_scDJK_entry() //  [R1]
         { info_tbl: [(ccDVZ,
                       label: res4_scDJK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDVZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccDW0; else goto ccDW1;
       ccDW0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDW1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccDVX_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccDVX() //  []
         { info_tbl: [(ccDVX,
                       label: block_ccDVX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDVX: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scDJQ_entry() //  [R1]
         { info_tbl: [(ccDW9,
                       label: sat_scDJQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDW9: // global
           _scDJQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccDWa; else goto ccDWb;
       ccDWb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccDWd; else goto ccDWc;
       ccDWd: // global
           HpAlloc = 24;
           goto ccDWa;
       ccDWa: // global
           R1 = _scDJQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDWc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scDJQ::P64;
           _scDJI::P64 = P64[_scDJQ::P64 + 16];
           _scDJK::P64 = P64[_scDJQ::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _scDJK::P64;
           R2 = Hp - 16;
           R1 = _scDJI::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$w$c<*>_entry() //  [R2, R3, R4]
         { info_tbl: [(ccDWe,
                       label: Control.Monad.ST.Lazy.Imp.$w$c<*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDWe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccDWf; else goto ccDWg;
       ccDWf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$w$c<*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDWg: // global
           I64[Sp - 16] = block_ccDVK_info;
           _scDJz::P64 = R2;
           R2 = R4;
           R1 = _scDJz::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDVK() //  [R1]
         { info_tbl: [(ccDVK,
                       label: block_ccDVK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDVK: // global
           I64[Sp] = block_ccDVO_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucDWm; else goto ccDVP;
       ucDWm: // global
           call _ccDVO(R1) args: 0, res: 0, upd: 0;
       ccDVP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDVO() //  [R1]
         { info_tbl: [(ccDVO,
                       label: block_ccDVO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDVO: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccDWl; else goto ccDWk;
       ccDWl: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccDWk: // global
           _scDJI::P64 = P64[R1 + 7];
           _scDJJ::P64 = P64[R1 + 15];
           I64[Hp - 80] = res4_scDJK_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _scDJJ::P64;
           I64[Hp - 48] = stg_sel_1_upd_info;
           _ccDVT::P64 = Hp - 80;
           P64[Hp - 32] = _ccDVT::P64;
           I64[Hp - 24] = sat_scDJQ_info;
           P64[Hp - 8] = _scDJI::P64;
           P64[Hp] = _ccDVT::P64;
           R2 = Hp - 48;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.846128958 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST4_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST4_entry() //  [R2, R3, R4]
         { info_tbl: [(ccDWu,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDWu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccDWv; else goto ccDWw;
       ccDWv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDWw: // global
           I64[Sp - 8] = block_ccDWr_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.ST.Lazy.Imp.$w$c<*>_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccDWr() //  [R1, R2]
         { info_tbl: [(ccDWr,
                       label: block_ccDWr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDWr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccDWz; else goto ccDWy;
       ccDWz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccDWy: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.848051102 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$w$cliftA2_closure" {
     Control.Monad.ST.Lazy.Imp.$w$cliftA2_closure:
         const Control.Monad.ST.Lazy.Imp.$w$cliftA2_info;
 },
 res1_scDK5_entry() //  [R1]
         { info_tbl: [(ccDWK,
                       label: res1_scDK5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDWK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccDWL; else goto ccDWM;
       ccDWL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDWM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccDWI_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccDWI() //  []
         { info_tbl: [(ccDWI,
                       label: block_ccDWI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDWI: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 res2_scDK7_entry() //  [R1]
         { info_tbl: [(ccDWV,
                       label: res2_scDK7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDWV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccDWW; else goto ccDWX;
       ccDWW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDWX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccDWS_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccDWS() //  []
         { info_tbl: [(ccDWS,
                       label: block_ccDWS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDWS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccDX0; else goto ccDWZ;
       ccDX0: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       ccDWZ: // global
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 16];
           R2 = Hp - 16;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scDKl_entry() //  [R1]
         { info_tbl: [(ccDX8,
                       label: sat_scDKl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDX8: // global
           _scDKl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccDX9; else goto ccDXa;
       ccDXa: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccDXc; else goto ccDXb;
       ccDXc: // global
           HpAlloc = 48;
           goto ccDX9;
       ccDX9: // global
           R1 = _scDKl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDXb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scDKl::P64;
           _scDK1::P64 = P64[_scDKl::P64 + 16];
           _scDK5::P64 = P64[_scDKl::P64 + 24];
           _scDK7::P64 = P64[_scDKl::P64 + 32];
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _scDK7::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _scDK5::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _scDK1::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$w$cliftA2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccDXd,
                       label: Control.Monad.ST.Lazy.Imp.$w$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDXd: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccDXh; else goto ccDXg;
       ccDXh: // global
           HpAlloc = 128;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$w$cliftA2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDXg: // global
           I64[Hp - 120] = res1_scDK5_info;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = res2_scDK7_info;
           P64[Hp - 72] = R4;
           _ccDWE::P64 = Hp - 120;
           P64[Hp - 64] = _ccDWE::P64;
           I64[Hp - 56] = stg_sel_1_upd_info;
           _ccDWO::P64 = Hp - 88;
           P64[Hp - 40] = _ccDWO::P64;
           I64[Hp - 32] = sat_scDKl_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _ccDWE::P64;
           P64[Hp] = _ccDWO::P64;
           R2 = Hp - 56;
           R1 = Hp - 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.850577286 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST3_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST3_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(ccDXp,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDXp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccDXq; else goto ccDXr;
       ccDXq: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDXr: // global
           I64[Sp - 8] = block_ccDXm_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.ST.Lazy.Imp.$w$cliftA2_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccDXm() //  [R1, R2]
         { info_tbl: [(ccDXm,
                       label: block_ccDXm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDXm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccDXu; else goto ccDXt;
       ccDXu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccDXt: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.854021415 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_info;
 },
 s'_scDKA_entry() //  [R1]
         { info_tbl: [(ccDXH,
                       label: s'_scDKA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDXH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccDXI; else goto ccDXJ;
       ccDXI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDXJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccDXD_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccDXD() //  []
         { info_tbl: [(ccDXD,
                       label: block_ccDXD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDXD: // global
           _scDKz::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccDXF_info;
           R2 = _scDKz::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccDXF() //  [R1]
         { info_tbl: [(ccDXF,
                       label: block_ccDXF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDXF: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST2_entry() //  [R2, R3, R4]
         { info_tbl: [(ccDXO,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDXO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccDXS; else goto ccDXR;
       ccDXS: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDXR: // global
           I64[Hp - 24] = s'_scDKA_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 24;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.856021027 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$w$c<*_closure" {
     Control.Monad.ST.Lazy.Imp.$w$c<*_closure:
         const Control.Monad.ST.Lazy.Imp.$w$c<*_info;
 },
 s''_scDKQ_entry() //  [R1]
         { info_tbl: [(ccDYj,
                       label: s''_scDKQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDYj: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccDYk; else goto ccDYl;
       ccDYk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDYl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccDYf_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccDYf() //  []
         { info_tbl: [(ccDYf,
                       label: block_ccDYf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDYf: // global
           _scDKP::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccDYh_info;
           R2 = _scDKP::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccDYh() //  [R1]
         { info_tbl: [(ccDYh,
                       label: block_ccDYh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDYh: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$w$c<*_entry() //  [R2, R3, R4]
         { info_tbl: [(ccDYq,
                       label: Control.Monad.ST.Lazy.Imp.$w$c<*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDYq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccDYr; else goto ccDYs;
       ccDYr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$w$c<*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDYs: // global
           I64[Sp - 16] = block_ccDY2_info;
           _scDKF::P64 = R2;
           R2 = R4;
           R1 = _scDKF::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDY2() //  [R1]
         { info_tbl: [(ccDY2,
                       label: block_ccDY2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDY2: // global
           I64[Sp] = block_ccDY6_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucDYy; else goto ccDY7;
       ucDYy: // global
           call _ccDY6(R1) args: 0, res: 0, upd: 0;
       ccDY7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDY6() //  [R1]
         { info_tbl: [(ccDY6,
                       label: block_ccDY6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDY6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccDYx; else goto ccDYw;
       ccDYx: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccDYw: // global
           _scDKO::P64 = P64[R1 + 7];
           _scDKP::P64 = P64[R1 + 15];
           I64[Hp - 24] = s''_scDKQ_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _scDKP::P64;
           R2 = Hp - 24;
           R1 = _scDKO::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.858067773 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST1_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccDYG,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDYG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccDYH; else goto ccDYI;
       ccDYH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDYI: // global
           I64[Sp - 8] = block_ccDYD_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.ST.Lazy.Imp.$w$c<*_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccDYD() //  [R1, R2]
         { info_tbl: [(ccDYD,
                       label: block_ccDYD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDYD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccDYL; else goto ccDYK;
       ccDYL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccDYK: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.859699914 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure:
         const Control.Monad.ST.Lazy.Imp.$fFunctorST2_info;
 },
 res_scDL4_entry() //  [R1]
         { info_tbl: [(ccDYW,
                       label: res_scDL4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDYW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccDYX; else goto ccDYY;
       ccDYX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDYY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccDYU_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccDYU() //  []
         { info_tbl: [(ccDYU,
                       label: block_ccDYU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDYU: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scDLa_entry() //  [R1]
         { info_tbl: [(ccDZ6,
                       label: sat_scDLa_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDZ6: // global
           _scDLa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccDZ7; else goto ccDZ8;
       ccDZ8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccDZa; else goto ccDZ9;
       ccDZa: // global
           HpAlloc = 24;
           goto ccDZ7;
       ccDZ7: // global
           R1 = _scDLa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDZ9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scDLa::P64;
           _scDL1::P64 = P64[_scDLa::P64 + 16];
           _scDL4::P64 = P64[_scDLa::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _scDL4::P64;
           R2 = Hp - 16;
           R1 = _scDL1::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fFunctorST2_entry() //  [R2, R3, R4]
         { info_tbl: [(ccDZc,
                       label: Control.Monad.ST.Lazy.Imp.$fFunctorST2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDZc: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccDZg; else goto ccDZf;
       ccDZg: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDZf: // global
           I64[Hp - 104] = res_scDL4_info;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = stg_sel_1_upd_info;
           _ccDYQ::P64 = Hp - 104;
           P64[Hp - 56] = _ccDYQ::P64;
           I64[Hp - 48] = sat_scDLa_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = _ccDYQ::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.861838174 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fFunctorST1_info;
 },
 s'_scDLi_entry() //  [R1]
         { info_tbl: [(ccDZt,
                       label: s'_scDLi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDZt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccDZu; else goto ccDZv;
       ccDZu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDZv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccDZp_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccDZp() //  []
         { info_tbl: [(ccDZp,
                       label: block_ccDZp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDZp: // global
           _scDLh::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccDZr_info;
           R2 = _scDLh::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccDZr() //  [R1]
         { info_tbl: [(ccDZr,
                       label: block_ccDZr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDZr: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fFunctorST1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccDZB,
                       label: Control.Monad.ST.Lazy.Imp.$fFunctorST1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDZB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccDZF; else goto ccDZE;
       ccDZF: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDZE: // global
           I64[Hp - 48] = s'_scDLi_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.863245209 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fFunctorST_closure" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST_closure:
         const GHC.Base.C:Functor_con_info;
         const Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.863918478 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST_closure:
         const GHC.Base.C:Applicative_con_info;
         const Control.Monad.ST.Lazy.Imp.$fFunctorST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure+2;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure+4;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.864605762 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadST_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadST_closure:
         const GHC.Base.C:Monad_con_info;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fMonadST1_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure+2;
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.865587512 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFailST_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFailST_closure:
         const Control.Monad.Fail.C:MonadFail_con_info;
         const Control.Monad.ST.Lazy.Imp.$fMonadST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.866436575 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.runST_closure" {
     Control.Monad.ST.Lazy.Imp.runST_closure:
         const Control.Monad.ST.Lazy.Imp.runST_info;
 },
 Control.Monad.ST.Lazy.Imp.runST_entry() //  [R2]
         { info_tbl: [(ccDZN,
                       label: Control.Monad.ST.Lazy.Imp.runST_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDZN: // global
           _scDLn::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccDZO; else goto ccDZP;
       ccDZP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccDZR; else goto ccDZQ;
       ccDZR: // global
           HpAlloc = 16;
           goto ccDZO;
       ccDZO: // global
           R2 = _scDLn::P64;
           R1 = Control.Monad.ST.Lazy.Imp.runST_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccDZQ: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Sp - 8] = block_ccDZL_info;
           R2 = Hp - 7;
           R1 = _scDLn::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDZL() //  [R1]
         { info_tbl: [(ccDZL,
                       label: block_ccDZL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDZL: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.867978334 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fMonadFixST1_info;
 },
 ds_scDLu_entry() //  [R1]
         { info_tbl: [(ccE06,
                       label: ds_scDLu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE06: // global
           _scDLu::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccE0a; else goto ccE0b;
       ccE0b: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccE0d; else goto ccE0c;
       ccE0d: // global
           HpAlloc = 24;
           goto ccE0a;
       ccE0a: // global
           R1 = _scDLu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccE0c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scDLu::P64;
           _scDLs::P64 = P64[_scDLu::P64 + 16];
           _scDLt::P64 = P64[_scDLu::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _scDLu::P64;
           I64[Sp - 24] = block_ccE04_info;
           R3 = _scDLt::P64;
           R2 = Hp - 16;
           R1 = _scDLs::P64;
           Sp = Sp - 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccE04() //  [R1]
         { info_tbl: [(ccE04,
                       label: block_ccE04_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE04: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccE0g; else goto ccE0f;
       ccE0g: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccE0f: // global
           _scDLB::P64 = P64[R1 + 7];
           _scDLC::P64 = P64[R1 + 15];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = _scDLB::P64;
           P64[Hp] = _scDLC::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fMonadFixST1_entry() //  [R2, R3]
         { info_tbl: [(ccE0k,
                       label: Control.Monad.ST.Lazy.Imp.$fMonadFixST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE0k: // global
           _scDLt::P64 = R3;
           _scDLs::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccE0l; else goto ccE0m;
       ccE0m: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccE0o; else goto ccE0n;
       ccE0o: // global
           HpAlloc = 32;
           goto ccE0l;
       ccE0l: // global
           R3 = _scDLt::P64;
           R2 = _scDLs::P64;
           R1 = Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE0n: // global
           I64[Hp - 24] = ds_scDLu_info;
           P64[Hp - 8] = _scDLs::P64;
           P64[Hp] = _scDLt::P64;
           I64[Sp - 8] = block_ccE0h_info;
           R1 = Hp - 24;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucE0s; else goto ccE0i;
       ucE0s: // global
           call _ccE0h(R1) args: 0, res: 0, upd: 0;
       ccE0i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccE0h() //  [R1]
         { info_tbl: [(ccE0h,
                       label: block_ccE0h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE0h: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.869912421 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.fixST_closure" {
     Control.Monad.ST.Lazy.Imp.fixST_closure:
         const Control.Monad.ST.Lazy.Imp.fixST_info;
 },
 Control.Monad.ST.Lazy.Imp.fixST_entry() //  [R2, R3]
         { info_tbl: [(ccE0x,
                       label: Control.Monad.ST.Lazy.Imp.fixST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE0x: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.$fMonadFixST1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.870694122 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFixST_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFixST_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Control.Monad.ST.Lazy.Imp.$fMonadST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.871671418 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.strictToLazyST1_closure" {
     Control.Monad.ST.Lazy.Imp.strictToLazyST1_closure:
         const Control.Monad.ST.Lazy.Imp.strictToLazyST1_info;
 },
 Control.Monad.ST.Lazy.Imp.strictToLazyST1_entry() //  [R2, R3]
         { info_tbl: [(ccE0H,
                       label: Control.Monad.ST.Lazy.Imp.strictToLazyST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE0H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccE0O; else goto ccE0P;
       ccE0O: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.strictToLazyST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE0P: // global
           I64[Sp - 16] = block_ccE0E_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucE0U; else goto ccE0F;
       ucE0U: // global
           call _ccE0E() args: 0, res: 0, upd: 0;
       ccE0F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccE0E() //  []
         { info_tbl: [(ccE0E,
                       label: block_ccE0E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE0E: // global
           _scDLH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccE0K_info;
           R1 = _scDLH::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccE0K() //  [R1]
         { info_tbl: [(ccE0K,
                       label: block_ccE0K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE0K: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccE0T; else goto ccE0S;
       ccE0T: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccE0S: // global
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.873097771 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.strictToLazyST_closure" {
     Control.Monad.ST.Lazy.Imp.strictToLazyST_closure:
         const Control.Monad.ST.Lazy.Imp.strictToLazyST_info;
 },
 Control.Monad.ST.Lazy.Imp.strictToLazyST_entry() //  [R2, R3]
         { info_tbl: [(ccE0Z,
                       label: Control.Monad.ST.Lazy.Imp.strictToLazyST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE0Z: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.strictToLazyST1_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.874222016 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeIOToST1_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeIOToST1_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeIOToST1_info;
 },
 Control.Monad.ST.Lazy.Imp.unsafeIOToST1_entry() //  [R2, R3]
         { info_tbl: [(ccE19,
                       label: Control.Monad.ST.Lazy.Imp.unsafeIOToST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE19: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccE1g; else goto ccE1h;
       ccE1g: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.unsafeIOToST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE1h: // global
           I64[Sp - 16] = block_ccE16_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucE1m; else goto ccE17;
       ucE1m: // global
           call _ccE16() args: 0, res: 0, upd: 0;
       ccE17: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccE16() //  []
         { info_tbl: [(ccE16,
                       label: block_ccE16_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE16: // global
           _scDLP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccE1c_info;
           R1 = _scDLP::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccE1c() //  [R1]
         { info_tbl: [(ccE1c,
                       label: block_ccE1c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE1c: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccE1l; else goto ccE1k;
       ccE1l: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccE1k: // global
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.875605025 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeIOToST_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeIOToST_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeIOToST_info;
 },
 Control.Monad.ST.Lazy.Imp.unsafeIOToST_entry() //  [R2, R3]
         { info_tbl: [(ccE1r,
                       label: Control.Monad.ST.Lazy.Imp.unsafeIOToST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE1r: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.unsafeIOToST1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.876645178 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.lazyToStrictST1_closure" {
     Control.Monad.ST.Lazy.Imp.lazyToStrictST1_closure:
         const Control.Monad.ST.Lazy.Imp.lazyToStrictST1_info;
 },
 Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry() //  [R2]
         { info_tbl: [(ccE1B,
                       label: Control.Monad.ST.Lazy.Imp.lazyToStrictST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE1B: // global
           _scDLX::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto ccE1F; else goto ccE1G;
       ccE1G: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccE1I; else goto ccE1H;
       ccE1I: // global
           HpAlloc = 16;
           goto ccE1F;
       ccE1F: // global
           R2 = _scDLX::P64;
           R1 = Control.Monad.ST.Lazy.Imp.lazyToStrictST1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccE1H: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Sp - 8] = block_ccE1z_info;
           R2 = Hp - 7;
           R1 = _scDLX::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccE1z() //  [R1]
         { info_tbl: [(ccE1z,
                       label: block_ccE1z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE1z: // global
           I64[Sp - 8] = block_ccE1E_info;
           _scDM1::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _scDM1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucE1P; else goto ccE1K;
       ucE1P: // global
           call _ccE1E() args: 0, res: 0, upd: 0;
       ccE1K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccE1E() //  []
         { info_tbl: [(ccE1E,
                       label: block_ccE1E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE1E: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.878180841 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.lazyToStrictST_closure" {
     Control.Monad.ST.Lazy.Imp.lazyToStrictST_closure:
         const Control.Monad.ST.Lazy.Imp.lazyToStrictST_info;
 },
 Control.Monad.ST.Lazy.Imp.lazyToStrictST_entry() //  [R2]
         { info_tbl: [(ccE1U,
                       label: Control.Monad.ST.Lazy.Imp.lazyToStrictST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE1U: // global
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.879021732 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.stToIO_closure" {
     Control.Monad.ST.Lazy.Imp.stToIO_closure:
         const Control.Monad.ST.Lazy.Imp.stToIO_info;
 },
 Control.Monad.ST.Lazy.Imp.stToIO_entry() //  [R2]
         { info_tbl: [(ccE21,
                       label: Control.Monad.ST.Lazy.Imp.stToIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE21: // global
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.880436504 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_info;
 },
 sat_scDMh_entry() //  [R1]
         { info_tbl: [(ccE2n,
                       label: sat_scDMh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE2n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccE2r; else goto ccE2s;
       ccE2r: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccE2s: // global
           I64[Sp - 16] = block_ccE2i_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _ccE2i() //  []
         { info_tbl: [(ccE2i,
                       label: block_ccE2i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE2i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccE2v; else goto ccE2u;
       ccE2v: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccE2u: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           _scDM5::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccE2l_info;
           R2 = Hp - 7;
           R1 = _scDM5::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccE2l() //  [R1]
         { info_tbl: [(ccE2l,
                       label: block_ccE2l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE2l: // global
           I64[Sp - 8] = block_ccE2q_info;
           _scDMd::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _scDMd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucE2C; else goto ccE2x;
       ucE2C: // global
           call _ccE2q() args: 0, res: 0, upd: 0;
       ccE2x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccE2q() //  []
         { info_tbl: [(ccE2q,
                       label: block_ccE2q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE2q: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_entry() //  [R2, R3]
         { info_tbl: [(ccE2D,
                       label: Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE2D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccE2I; else goto ccE2J;
       ccE2I: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE2J: // global
           I64[Sp - 16] = block_ccE28_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucE2Q; else goto ccE29;
       ucE2Q: // global
           call _ccE28(R1) args: 0, res: 0, upd: 0;
       ccE29: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccE28() //  [R1]
         { info_tbl: [(ccE28,
                       label: block_ccE28_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE28: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccE2M; else goto ccE2L;
       ccE2M: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccE2L: // global
           I64[Hp - 8] = sat_scDMh_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccE2E_info;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.ST.unsafeDupableInterleaveST_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccE2E() //  [R1]
         { info_tbl: [(ccE2E,
                       label: block_ccE2E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE2E: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccE2P; else goto ccE2O;
       ccE2P: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccE2O: // global
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.882672396 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_info;
 },
 Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_entry() //  [R2, R3]
         { info_tbl: [(ccE2V,
                       label: Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE2V: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.883435566 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$trModule4_bytes" {
     Control.Monad.ST.Lazy.Imp.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.884007145 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$trModule3_closure" {
     Control.Monad.ST.Lazy.Imp.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.884657953 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$trModule2_bytes" {
     Control.Monad.ST.Lazy.Imp.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100,46,83,84,46,76,97,122,121,46,73,109,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.885225674 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$trModule1_closure" {
     Control.Monad.ST.Lazy.Imp.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.88583629 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$trModule_closure" {
     Control.Monad.ST.Lazy.Imp.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule3_closure+1;
         const Control.Monad.ST.Lazy.Imp.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.886453851 UTC

[section ""data" . $krep_rcDJ5_closure" {
     $krep_rcDJ5_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.887086267 UTC

[section ""data" . $krep1_rcDJ6_closure" {
     $krep1_rcDJ6_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.887717387 UTC

[section ""data" . $krep2_rcDJ7_closure" {
     $krep2_rcDJ7_closure:
         const :_con_info;
         const $krep1_rcDJ6_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.888393973 UTC

[section ""data" . $krep3_rcDJ8_closure" {
     $krep3_rcDJ8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcState#_closure;
         const $krep2_rcDJ7_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.889008306 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tcState2_bytes" {
     Control.Monad.ST.Lazy.Imp.$tcState2_bytes:
         I8[] [83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.889853535 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcState1_closure" {
     Control.Monad.ST.Lazy.Imp.$tcState1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.890462927 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcState_closure" {
     Control.Monad.ST.Lazy.Imp.$tcState_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tcState1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 220923881781706094;
         const 12630832853168782158;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.891136524 UTC

[section ""data" . $krep4_rcDJ9_closure" {
     $krep4_rcDJ9_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcState_closure+1;
         const $krep2_rcDJ7_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.891756459 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'S#1_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'S#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rcDJ8_closure+1;
         const $krep4_rcDJ9_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.892359251 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tc'S#3_bytes" {
     Control.Monad.ST.Lazy.Imp.$tc'S#3_bytes:
         I8[] [39,83,35]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.892933254 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'S#2_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'S#2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tc'S#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.893569628 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'S#_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'S#_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'S#2_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'S#1_closure+4;
         const 12704778602275544086;
         const 1928505377508739254;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.89421314 UTC

[section ""data" . $krep5_rcDJa_closure" {
     $krep5_rcDJa_closure:
         const :_con_info;
         const $krep4_rcDJ9_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.894838173 UTC

[section ""data" . $krep6_rcDJb_closure" {
     $krep6_rcDJb_closure:
         const :_con_info;
         const $krep_rcDJ5_closure+2;
         const $krep5_rcDJa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.895451287 UTC

[section ""data" . $krep7_rcDJc_closure" {
     $krep7_rcDJc_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep6_rcDJb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.896130221 UTC

[section ""data" . $krep8_rcDJd_closure" {
     $krep8_rcDJd_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rcDJ9_closure+1;
         const $krep7_rcDJc_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.897995809 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tcST2_bytes" {
     Control.Monad.ST.Lazy.Imp.$tcST2_bytes:
         I8[] [83,84]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.898607933 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcST1_closure" {
     Control.Monad.ST.Lazy.Imp.$tcST1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcST2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.899228245 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcST_closure" {
     Control.Monad.ST.Lazy.Imp.$tcST_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tcST1_closure+1;
         const GHC.Types.krep$*->*->*_closure;
         const 9758985700159114765;
         const 4154811637844139714;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.899903213 UTC

[section ""data" . $krep9_rcDJe_closure" {
     $krep9_rcDJe_closure:
         const :_con_info;
         const $krep_rcDJ5_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.900546115 UTC

[section ""data" . $krep10_rcDJf_closure" {
     $krep10_rcDJf_closure:
         const :_con_info;
         const $krep1_rcDJ6_closure+2;
         const $krep9_rcDJe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.901119045 UTC

[section ""data" . $krep11_rcDJg_closure" {
     $krep11_rcDJg_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcST_closure+1;
         const $krep10_rcDJf_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.902121178 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'ST1_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'ST1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rcDJd_closure+4;
         const $krep11_rcDJg_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.90269624 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tc'ST3_bytes" {
     Control.Monad.ST.Lazy.Imp.$tc'ST3_bytes:
         I8[] [39,83,84]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.903278051 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'ST2_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'ST2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tc'ST3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.903884141 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'ST_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'ST_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'ST2_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'ST1_closure+4;
         const 5656684040178075861;
         const 6626797926801395533;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.90480459 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.S#_closure" {
     Control.Monad.ST.Lazy.Imp.S#_closure:
         const Control.Monad.ST.Lazy.Imp.S#_info;
 },
 Control.Monad.ST.Lazy.Imp.S#_entry() //  []
         { info_tbl: [(ccE33,
                       label: Control.Monad.ST.Lazy.Imp.S#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE33: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccE37; else goto ccE36;
       ccE37: // global
           HpAlloc = 16;
           R1 = Control.Monad.ST.Lazy.Imp.S#_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccE36: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.905728787 UTC

[Control.Monad.ST.Lazy.Imp.S#_con_entry() //  [R1]
         { info_tbl: [(ccE38,
                       label: Control.Monad.ST.Lazy.Imp.S#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,77,111,110,97,100,46,83,84,46,76,97,122,121,46,73,109,112,46,83,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE38: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.906461938 UTC

[section ""relreadonly" . ScDMD_srt" {
     ScDMD_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.907334686 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:32.908750669 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST5_entry() //  [R2, R3]
         { info_tbl: [(ccE3f,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE3f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccE3j; else goto ccE3i;
       ccE3j: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE3i: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.912927104 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure:
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_info;
         const 0;
 },
 Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_entry() //  [R2]
         { info_tbl: [(ccE3t,
                       label: Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE3t: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.916900397 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unST1_closure" {
     Control.Monad.ST.Lazy.Imp.unST1_closure:
         const Control.Monad.ST.Lazy.Imp.unST1_info;
 },
 Control.Monad.ST.Lazy.Imp.unST1_entry() //  [R2]
         { info_tbl: [(ccE3E,
                       label: Control.Monad.ST.Lazy.Imp.unST1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE3E: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.920517133 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unST_closure" {
     Control.Monad.ST.Lazy.Imp.unST_closure:
         const Control.Monad.ST.Lazy.Imp.unST_info;
 },
 Control.Monad.ST.Lazy.Imp.unST_entry() //  [R2]
         { info_tbl: [(ccE3P,
                       label: Control.Monad.ST.Lazy.Imp.unST_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE3P: // global
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.unST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.924407206 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fMonadST1_info;
 },
 res_scDJp_entry() //  [R1]
         { info_tbl: [(ccE46,
                       label: res_scDJp_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE46: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccE47; else goto ccE48;
       ccE47: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccE48: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccE44_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccE44() //  []
         { info_tbl: [(ccE44,
                       label: block_ccE44_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE44: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fMonadST1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccE4c,
                       label: Control.Monad.ST.Lazy.Imp.$fMonadST1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE4c: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccE4g; else goto ccE4f;
       ccE4g: // global
           HpAlloc = 80;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fMonadST1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE4f: // global
           I64[Hp - 72] = res_scDJp_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = stg_sel_1_upd_info;
           _ccE40::P64 = Hp - 72;
           P64[Hp - 24] = _ccE40::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _ccE40::P64;
           _scDJn::P64 = R3;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _scDJn::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.934195057 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$w$c<*>_closure" {
     Control.Monad.ST.Lazy.Imp.$w$c<*>_closure:
         const Control.Monad.ST.Lazy.Imp.$w$c<*>_info;
 },
 res4_scDJK_entry() //  [R1]
         { info_tbl: [(ccE4S,
                       label: res4_scDJK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE4S: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccE4T; else goto ccE4U;
       ccE4T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccE4U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccE4Q_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccE4Q() //  []
         { info_tbl: [(ccE4Q,
                       label: block_ccE4Q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE4Q: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scDJQ_entry() //  [R1]
         { info_tbl: [(ccE52,
                       label: sat_scDJQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE52: // global
           _scDJQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccE53; else goto ccE54;
       ccE54: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccE56; else goto ccE55;
       ccE56: // global
           HpAlloc = 24;
           goto ccE53;
       ccE53: // global
           R1 = _scDJQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccE55: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scDJQ::P64;
           _scDJI::P64 = P64[_scDJQ::P64 + 16];
           _scDJK::P64 = P64[_scDJQ::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _scDJK::P64;
           R2 = Hp - 16;
           R1 = _scDJI::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$w$c<*>_entry() //  [R2, R3, R4]
         { info_tbl: [(ccE57,
                       label: Control.Monad.ST.Lazy.Imp.$w$c<*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE57: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccE58; else goto ccE59;
       ccE58: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$w$c<*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE59: // global
           I64[Sp - 16] = block_ccE4D_info;
           _scDJz::P64 = R2;
           R2 = R4;
           R1 = _scDJz::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccE4D() //  [R1]
         { info_tbl: [(ccE4D,
                       label: block_ccE4D_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE4D: // global
           I64[Sp] = block_ccE4H_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucE5f; else goto ccE4I;
       ucE5f: // global
           call _ccE4H(R1) args: 0, res: 0, upd: 0;
       ccE4I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccE4H() //  [R1]
         { info_tbl: [(ccE4H,
                       label: block_ccE4H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE4H: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccE5e; else goto ccE5d;
       ccE5e: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccE5d: // global
           _scDJI::P64 = P64[R1 + 7];
           _scDJJ::P64 = P64[R1 + 15];
           I64[Hp - 80] = res4_scDJK_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _scDJJ::P64;
           I64[Hp - 48] = stg_sel_1_upd_info;
           _ccE4M::P64 = Hp - 80;
           P64[Hp - 32] = _ccE4M::P64;
           I64[Hp - 24] = sat_scDJQ_info;
           P64[Hp - 8] = _scDJI::P64;
           P64[Hp] = _ccE4M::P64;
           R2 = Hp - 48;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.948482162 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST4_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST4_entry() //  [R2, R3, R4]
         { info_tbl: [(ccE5O,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE5O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccE5P; else goto ccE5Q;
       ccE5P: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE5Q: // global
           I64[Sp - 8] = block_ccE5L_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.ST.Lazy.Imp.$w$c<*>_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccE5L() //  [R1, R2]
         { info_tbl: [(ccE5L,
                       label: block_ccE5L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE5L: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccE5T; else goto ccE5S;
       ccE5T: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccE5S: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.95517061 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$w$cliftA2_closure" {
     Control.Monad.ST.Lazy.Imp.$w$cliftA2_closure:
         const Control.Monad.ST.Lazy.Imp.$w$cliftA2_info;
 },
 res1_scDK5_entry() //  [R1]
         { info_tbl: [(ccE6d,
                       label: res1_scDK5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE6d: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccE6e; else goto ccE6f;
       ccE6e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccE6f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccE6b_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccE6b() //  []
         { info_tbl: [(ccE6b,
                       label: block_ccE6b_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE6b: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 res2_scDK7_entry() //  [R1]
         { info_tbl: [(ccE6o,
                       label: res2_scDK7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE6o: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccE6p; else goto ccE6q;
       ccE6p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccE6q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccE6l_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccE6l() //  []
         { info_tbl: [(ccE6l,
                       label: block_ccE6l_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE6l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccE6t; else goto ccE6s;
       ccE6t: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       ccE6s: // global
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 16];
           R2 = Hp - 16;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scDKl_entry() //  [R1]
         { info_tbl: [(ccE6B,
                       label: sat_scDKl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE6B: // global
           _scDKl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccE6C; else goto ccE6D;
       ccE6D: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccE6F; else goto ccE6E;
       ccE6F: // global
           HpAlloc = 48;
           goto ccE6C;
       ccE6C: // global
           R1 = _scDKl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccE6E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scDKl::P64;
           _scDK1::P64 = P64[_scDKl::P64 + 16];
           _scDK5::P64 = P64[_scDKl::P64 + 24];
           _scDK7::P64 = P64[_scDKl::P64 + 32];
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _scDK7::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _scDK5::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _scDK1::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$w$cliftA2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccE6G,
                       label: Control.Monad.ST.Lazy.Imp.$w$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE6G: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccE6K; else goto ccE6J;
       ccE6K: // global
           HpAlloc = 128;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$w$cliftA2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE6J: // global
           I64[Hp - 120] = res1_scDK5_info;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = res2_scDK7_info;
           P64[Hp - 72] = R4;
           _ccE67::P64 = Hp - 120;
           P64[Hp - 64] = _ccE67::P64;
           I64[Hp - 56] = stg_sel_1_upd_info;
           _ccE6h::P64 = Hp - 88;
           P64[Hp - 40] = _ccE6h::P64;
           I64[Hp - 32] = sat_scDKl_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _ccE67::P64;
           P64[Hp] = _ccE6h::P64;
           R2 = Hp - 56;
           R1 = Hp - 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.969650629 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST3_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST3_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(ccE7k,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE7k: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccE7l; else goto ccE7m;
       ccE7l: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE7m: // global
           I64[Sp - 8] = block_ccE7h_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.ST.Lazy.Imp.$w$cliftA2_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccE7h() //  [R1, R2]
         { info_tbl: [(ccE7h,
                       label: block_ccE7h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE7h: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccE7p; else goto ccE7o;
       ccE7p: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccE7o: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.9769214 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_info;
 },
 s'_scDKA_entry() //  [R1]
         { info_tbl: [(ccE7L,
                       label: s'_scDKA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE7L: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccE7M; else goto ccE7N;
       ccE7M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccE7N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccE7H_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccE7H() //  []
         { info_tbl: [(ccE7H,
                       label: block_ccE7H_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE7H: // global
           _scDKz::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccE7J_info;
           R2 = _scDKz::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccE7J() //  [R1]
         { info_tbl: [(ccE7J,
                       label: block_ccE7J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE7J: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST2_entry() //  [R2, R3, R4]
         { info_tbl: [(ccE7S,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE7S: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccE7W; else goto ccE7V;
       ccE7W: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE7V: // global
           I64[Hp - 24] = s'_scDKA_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 24;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.986719104 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$w$c<*_closure" {
     Control.Monad.ST.Lazy.Imp.$w$c<*_closure:
         const Control.Monad.ST.Lazy.Imp.$w$c<*_info;
 },
 s''_scDKQ_entry() //  [R1]
         { info_tbl: [(ccE8F,
                       label: s''_scDKQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE8F: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccE8G; else goto ccE8H;
       ccE8G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccE8H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccE8B_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccE8B() //  []
         { info_tbl: [(ccE8B,
                       label: block_ccE8B_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE8B: // global
           _scDKP::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccE8D_info;
           R2 = _scDKP::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccE8D() //  [R1]
         { info_tbl: [(ccE8D,
                       label: block_ccE8D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE8D: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$w$c<*_entry() //  [R2, R3, R4]
         { info_tbl: [(ccE8M,
                       label: Control.Monad.ST.Lazy.Imp.$w$c<*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE8M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccE8N; else goto ccE8O;
       ccE8N: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$w$c<*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE8O: // global
           I64[Sp - 16] = block_ccE8o_info;
           _scDKF::P64 = R2;
           R2 = R4;
           R1 = _scDKF::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccE8o() //  [R1]
         { info_tbl: [(ccE8o,
                       label: block_ccE8o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE8o: // global
           I64[Sp] = block_ccE8s_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucE8U; else goto ccE8t;
       ucE8U: // global
           call _ccE8s(R1) args: 0, res: 0, upd: 0;
       ccE8t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccE8s() //  [R1]
         { info_tbl: [(ccE8s,
                       label: block_ccE8s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE8s: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccE8T; else goto ccE8S;
       ccE8T: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccE8S: // global
           _scDKO::P64 = P64[R1 + 7];
           _scDKP::P64 = P64[R1 + 15];
           I64[Hp - 24] = s''_scDKQ_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _scDKP::P64;
           R2 = Hp - 24;
           R1 = _scDKO::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:32.999398269 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST1_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccE9u,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE9u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccE9v; else goto ccE9w;
       ccE9v: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccE9w: // global
           I64[Sp - 8] = block_ccE9r_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.ST.Lazy.Imp.$w$c<*_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccE9r() //  [R1, R2]
         { info_tbl: [(ccE9r,
                       label: block_ccE9r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE9r: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccE9z; else goto ccE9y;
       ccE9z: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccE9y: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.005988115 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure:
         const Control.Monad.ST.Lazy.Imp.$fFunctorST2_info;
 },
 res_scDL4_entry() //  [R1]
         { info_tbl: [(ccE9T,
                       label: res_scDL4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE9T: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccE9U; else goto ccE9V;
       ccE9U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccE9V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccE9R_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccE9R() //  []
         { info_tbl: [(ccE9R,
                       label: block_ccE9R_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE9R: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scDLa_entry() //  [R1]
         { info_tbl: [(ccEa3,
                       label: sat_scDLa_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEa3: // global
           _scDLa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccEa4; else goto ccEa5;
       ccEa5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccEa7; else goto ccEa6;
       ccEa7: // global
           HpAlloc = 24;
           goto ccEa4;
       ccEa4: // global
           R1 = _scDLa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEa6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scDLa::P64;
           _scDL1::P64 = P64[_scDLa::P64 + 16];
           _scDL4::P64 = P64[_scDLa::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _scDL4::P64;
           R2 = Hp - 16;
           R1 = _scDL1::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fFunctorST2_entry() //  [R2, R3, R4]
         { info_tbl: [(ccEa9,
                       label: Control.Monad.ST.Lazy.Imp.$fFunctorST2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEa9: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccEad; else goto ccEac;
       ccEad: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEac: // global
           I64[Hp - 104] = res_scDL4_info;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = stg_sel_1_upd_info;
           _ccE9N::P64 = Hp - 104;
           P64[Hp - 56] = _ccE9N::P64;
           I64[Hp - 48] = sat_scDLa_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = _ccE9N::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.016826696 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fFunctorST1_info;
 },
 s'_scDLi_entry() //  [R1]
         { info_tbl: [(ccEaK,
                       label: s'_scDLi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEaK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccEaL; else goto ccEaM;
       ccEaL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEaM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccEaG_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccEaG() //  []
         { info_tbl: [(ccEaG,
                       label: block_ccEaG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEaG: // global
           _scDLh::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccEaI_info;
           R2 = _scDLh::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccEaI() //  [R1]
         { info_tbl: [(ccEaI,
                       label: block_ccEaI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEaI: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fFunctorST1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccEaS,
                       label: Control.Monad.ST.Lazy.Imp.$fFunctorST1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEaS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccEaW; else goto ccEaV;
       ccEaW: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEaV: // global
           I64[Hp - 48] = s'_scDLi_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.026123303 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fFunctorST_closure" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST_closure:
         const GHC.Base.C:Functor_con_info;
         const Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.027966385 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST_closure:
         const GHC.Base.C:Applicative_con_info;
         const Control.Monad.ST.Lazy.Imp.$fFunctorST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure+2;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure+4;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.029905447 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadST_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadST_closure:
         const GHC.Base.C:Monad_con_info;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fMonadST1_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure+2;
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.031819947 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFailST_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFailST_closure:
         const Control.Monad.Fail.C:MonadFail_con_info;
         const Control.Monad.ST.Lazy.Imp.$fMonadST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.034067998 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.runST_closure" {
     Control.Monad.ST.Lazy.Imp.runST_closure:
         const Control.Monad.ST.Lazy.Imp.runST_info;
 },
 Control.Monad.ST.Lazy.Imp.runST_entry() //  [R2]
         { info_tbl: [(ccEbs,
                       label: Control.Monad.ST.Lazy.Imp.runST_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEbs: // global
           _scDLn::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccEbt; else goto ccEbu;
       ccEbu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEbw; else goto ccEbv;
       ccEbw: // global
           HpAlloc = 16;
           goto ccEbt;
       ccEbt: // global
           R2 = _scDLn::P64;
           R1 = Control.Monad.ST.Lazy.Imp.runST_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccEbv: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Sp - 8] = block_ccEbq_info;
           R2 = Hp - 7;
           R1 = _scDLn::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEbq() //  [R1]
         { info_tbl: [(ccEbq,
                       label: block_ccEbq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEbq: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.040658627 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fMonadFixST1_info;
 },
 ds_scDLu_entry() //  [R1]
         { info_tbl: [(ccEbT,
                       label: ds_scDLu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEbT: // global
           _scDLu::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccEbX; else goto ccEbY;
       ccEbY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccEc0; else goto ccEbZ;
       ccEc0: // global
           HpAlloc = 24;
           goto ccEbX;
       ccEbX: // global
           R1 = _scDLu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEbZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scDLu::P64;
           _scDLs::P64 = P64[_scDLu::P64 + 16];
           _scDLt::P64 = P64[_scDLu::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _scDLu::P64;
           I64[Sp - 24] = block_ccEbR_info;
           R3 = _scDLt::P64;
           R2 = Hp - 16;
           R1 = _scDLs::P64;
           Sp = Sp - 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccEbR() //  [R1]
         { info_tbl: [(ccEbR,
                       label: block_ccEbR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEbR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccEc3; else goto ccEc2;
       ccEc3: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccEc2: // global
           _scDLB::P64 = P64[R1 + 7];
           _scDLC::P64 = P64[R1 + 15];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = _scDLB::P64;
           P64[Hp] = _scDLC::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fMonadFixST1_entry() //  [R2, R3]
         { info_tbl: [(ccEc7,
                       label: Control.Monad.ST.Lazy.Imp.$fMonadFixST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEc7: // global
           _scDLt::P64 = R3;
           _scDLs::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccEc8; else goto ccEc9;
       ccEc9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccEcb; else goto ccEca;
       ccEcb: // global
           HpAlloc = 32;
           goto ccEc8;
       ccEc8: // global
           R3 = _scDLt::P64;
           R2 = _scDLs::P64;
           R1 = Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEca: // global
           I64[Hp - 24] = ds_scDLu_info;
           P64[Hp - 8] = _scDLs::P64;
           P64[Hp] = _scDLt::P64;
           I64[Sp - 8] = block_ccEc4_info;
           R1 = Hp - 24;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucEcf; else goto ccEc5;
       ucEcf: // global
           call _ccEc4(R1) args: 0, res: 0, upd: 0;
       ccEc5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEc4() //  [R1]
         { info_tbl: [(ccEc4,
                       label: block_ccEc4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEc4: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.052097362 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.fixST_closure" {
     Control.Monad.ST.Lazy.Imp.fixST_closure:
         const Control.Monad.ST.Lazy.Imp.fixST_info;
 },
 Control.Monad.ST.Lazy.Imp.fixST_entry() //  [R2, R3]
         { info_tbl: [(ccEcD,
                       label: Control.Monad.ST.Lazy.Imp.fixST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEcD: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.$fMonadFixST1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.055418488 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFixST_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFixST_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Control.Monad.ST.Lazy.Imp.$fMonadST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.057747102 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.strictToLazyST1_closure" {
     Control.Monad.ST.Lazy.Imp.strictToLazyST1_closure:
         const Control.Monad.ST.Lazy.Imp.strictToLazyST1_info;
 },
 Control.Monad.ST.Lazy.Imp.strictToLazyST1_entry() //  [R2, R3]
         { info_tbl: [(ccEcS,
                       label: Control.Monad.ST.Lazy.Imp.strictToLazyST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEcS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEcZ; else goto ccEd0;
       ccEcZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.strictToLazyST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEd0: // global
           I64[Sp - 16] = block_ccEcP_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEd5; else goto ccEcQ;
       ucEd5: // global
           call _ccEcP() args: 0, res: 0, upd: 0;
       ccEcQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEcP() //  []
         { info_tbl: [(ccEcP,
                       label: block_ccEcP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEcP: // global
           _scDLH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEcV_info;
           R1 = _scDLH::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEcV() //  [R1]
         { info_tbl: [(ccEcV,
                       label: block_ccEcV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEcV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEd4; else goto ccEd3;
       ccEd4: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEd3: // global
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.06511729 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.strictToLazyST_closure" {
     Control.Monad.ST.Lazy.Imp.strictToLazyST_closure:
         const Control.Monad.ST.Lazy.Imp.strictToLazyST_info;
 },
 Control.Monad.ST.Lazy.Imp.strictToLazyST_entry() //  [R2, R3]
         { info_tbl: [(ccEdo,
                       label: Control.Monad.ST.Lazy.Imp.strictToLazyST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEdo: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.strictToLazyST1_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.070254832 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeIOToST1_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeIOToST1_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeIOToST1_info;
 },
 Control.Monad.ST.Lazy.Imp.unsafeIOToST1_entry() //  [R2, R3]
         { info_tbl: [(ccEdC,
                       label: Control.Monad.ST.Lazy.Imp.unsafeIOToST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEdC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEdJ; else goto ccEdK;
       ccEdJ: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.unsafeIOToST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEdK: // global
           I64[Sp - 16] = block_ccEdz_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEdP; else goto ccEdA;
       ucEdP: // global
           call _ccEdz() args: 0, res: 0, upd: 0;
       ccEdA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEdz() //  []
         { info_tbl: [(ccEdz,
                       label: block_ccEdz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEdz: // global
           _scDLP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEdF_info;
           R1 = _scDLP::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEdF() //  [R1]
         { info_tbl: [(ccEdF,
                       label: block_ccEdF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEdF: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEdO; else goto ccEdN;
       ccEdO: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEdN: // global
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.078170068 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeIOToST_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeIOToST_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeIOToST_info;
 },
 Control.Monad.ST.Lazy.Imp.unsafeIOToST_entry() //  [R2, R3]
         { info_tbl: [(ccEe8,
                       label: Control.Monad.ST.Lazy.Imp.unsafeIOToST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEe8: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.unsafeIOToST1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.082450792 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.lazyToStrictST1_closure" {
     Control.Monad.ST.Lazy.Imp.lazyToStrictST1_closure:
         const Control.Monad.ST.Lazy.Imp.lazyToStrictST1_info;
 },
 Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry() //  [R2]
         { info_tbl: [(ccEem,
                       label: Control.Monad.ST.Lazy.Imp.lazyToStrictST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEem: // global
           _scDLX::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto ccEeq; else goto ccEer;
       ccEer: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEet; else goto ccEes;
       ccEet: // global
           HpAlloc = 16;
           goto ccEeq;
       ccEeq: // global
           R2 = _scDLX::P64;
           R1 = Control.Monad.ST.Lazy.Imp.lazyToStrictST1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccEes: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Sp - 8] = block_ccEek_info;
           R2 = Hp - 7;
           R1 = _scDLX::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEek() //  [R1]
         { info_tbl: [(ccEek,
                       label: block_ccEek_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEek: // global
           I64[Sp - 8] = block_ccEep_info;
           _scDM1::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _scDM1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucEeA; else goto ccEev;
       ucEeA: // global
           call _ccEep() args: 0, res: 0, upd: 0;
       ccEev: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEep() //  []
         { info_tbl: [(ccEep,
                       label: block_ccEep_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEep: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.090534377 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.lazyToStrictST_closure" {
     Control.Monad.ST.Lazy.Imp.lazyToStrictST_closure:
         const Control.Monad.ST.Lazy.Imp.lazyToStrictST_info;
 },
 Control.Monad.ST.Lazy.Imp.lazyToStrictST_entry() //  [R2]
         { info_tbl: [(ccEeS,
                       label: Control.Monad.ST.Lazy.Imp.lazyToStrictST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEeS: // global
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.094493555 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.stToIO_closure" {
     Control.Monad.ST.Lazy.Imp.stToIO_closure:
         const Control.Monad.ST.Lazy.Imp.stToIO_info;
 },
 Control.Monad.ST.Lazy.Imp.stToIO_entry() //  [R2]
         { info_tbl: [(ccEf3,
                       label: Control.Monad.ST.Lazy.Imp.stToIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEf3: // global
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.098631232 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_info;
 },
 sat_scDMh_entry() //  [R1]
         { info_tbl: [(ccEft,
                       label: sat_scDMh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEft: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEfx; else goto ccEfy;
       ccEfx: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccEfy: // global
           I64[Sp - 16] = block_ccEfo_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _ccEfo() //  []
         { info_tbl: [(ccEfo,
                       label: block_ccEfo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEfo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEfB; else goto ccEfA;
       ccEfB: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccEfA: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           _scDM5::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEfr_info;
           R2 = Hp - 7;
           R1 = _scDM5::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEfr() //  [R1]
         { info_tbl: [(ccEfr,
                       label: block_ccEfr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEfr: // global
           I64[Sp - 8] = block_ccEfw_info;
           _scDMd::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _scDMd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucEfI; else goto ccEfD;
       ucEfI: // global
           call _ccEfw() args: 0, res: 0, upd: 0;
       ccEfD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEfw() //  []
         { info_tbl: [(ccEfw,
                       label: block_ccEfw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEfw: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_entry() //  [R2, R3]
         { info_tbl: [(ccEfJ,
                       label: Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEfJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEfO; else goto ccEfP;
       ccEfO: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEfP: // global
           I64[Sp - 16] = block_ccEfe_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEfW; else goto ccEff;
       ucEfW: // global
           call _ccEfe(R1) args: 0, res: 0, upd: 0;
       ccEff: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEfe() //  [R1]
         { info_tbl: [(ccEfe,
                       label: block_ccEfe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEfe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEfS; else goto ccEfR;
       ccEfS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEfR: // global
           I64[Hp - 8] = sat_scDMh_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccEfK_info;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.ST.unsafeDupableInterleaveST_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccEfK() //  [R1]
         { info_tbl: [(ccEfK,
                       label: block_ccEfK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEfK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEfV; else goto ccEfU;
       ccEfV: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEfU: // global
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.113710728 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_info;
 },
 Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_entry() //  [R2, R3]
         { info_tbl: [(ccEgw,
                       label: Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEgw: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.117167164 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$trModule4_bytes" {
     Control.Monad.ST.Lazy.Imp.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.118994463 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$trModule3_closure" {
     Control.Monad.ST.Lazy.Imp.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.121355653 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$trModule2_bytes" {
     Control.Monad.ST.Lazy.Imp.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100,46,83,84,46,76,97,122,121,46,73,109,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.123184551 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$trModule1_closure" {
     Control.Monad.ST.Lazy.Imp.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.124934173 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$trModule_closure" {
     Control.Monad.ST.Lazy.Imp.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule3_closure+1;
         const Control.Monad.ST.Lazy.Imp.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.126815277 UTC

[section ""data" . $krep_rcDJ5_closure" {
     $krep_rcDJ5_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.128744454 UTC

[section ""data" . $krep1_rcDJ6_closure" {
     $krep1_rcDJ6_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.131071976 UTC

[section ""data" . $krep2_rcDJ7_closure" {
     $krep2_rcDJ7_closure:
         const :_con_info;
         const $krep1_rcDJ6_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.132927933 UTC

[section ""data" . $krep3_rcDJ8_closure" {
     $krep3_rcDJ8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcState#_closure;
         const $krep2_rcDJ7_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.134723138 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tcState2_bytes" {
     Control.Monad.ST.Lazy.Imp.$tcState2_bytes:
         I8[] [83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.136532961 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcState1_closure" {
     Control.Monad.ST.Lazy.Imp.$tcState1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.138920669 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcState_closure" {
     Control.Monad.ST.Lazy.Imp.$tcState_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tcState1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 220923881781706094;
         const 12630832853168782158;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.14089127 UTC

[section ""data" . $krep4_rcDJ9_closure" {
     $krep4_rcDJ9_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcState_closure+1;
         const $krep2_rcDJ7_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.142696779 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'S#1_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'S#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rcDJ8_closure+1;
         const $krep4_rcDJ9_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.144497513 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tc'S#3_bytes" {
     Control.Monad.ST.Lazy.Imp.$tc'S#3_bytes:
         I8[] [39,83,35]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.146383509 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'S#2_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'S#2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tc'S#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.148720476 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'S#_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'S#_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'S#2_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'S#1_closure+4;
         const 12704778602275544086;
         const 1928505377508739254;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.151151264 UTC

[section ""data" . $krep5_rcDJa_closure" {
     $krep5_rcDJa_closure:
         const :_con_info;
         const $krep4_rcDJ9_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.152969398 UTC

[section ""data" . $krep6_rcDJb_closure" {
     $krep6_rcDJb_closure:
         const :_con_info;
         const $krep_rcDJ5_closure+2;
         const $krep5_rcDJa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.154820014 UTC

[section ""data" . $krep7_rcDJc_closure" {
     $krep7_rcDJc_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep6_rcDJb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.156650937 UTC

[section ""data" . $krep8_rcDJd_closure" {
     $krep8_rcDJd_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rcDJ9_closure+1;
         const $krep7_rcDJc_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.158501847 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tcST2_bytes" {
     Control.Monad.ST.Lazy.Imp.$tcST2_bytes:
         I8[] [83,84]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.160246971 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcST1_closure" {
     Control.Monad.ST.Lazy.Imp.$tcST1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcST2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.162017339 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcST_closure" {
     Control.Monad.ST.Lazy.Imp.$tcST_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tcST1_closure+1;
         const GHC.Types.krep$*->*->*_closure;
         const 9758985700159114765;
         const 4154811637844139714;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.16396058 UTC

[section ""data" . $krep9_rcDJe_closure" {
     $krep9_rcDJe_closure:
         const :_con_info;
         const $krep_rcDJ5_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.166117346 UTC

[section ""data" . $krep10_rcDJf_closure" {
     $krep10_rcDJf_closure:
         const :_con_info;
         const $krep1_rcDJ6_closure+2;
         const $krep9_rcDJe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.167902117 UTC

[section ""data" . $krep11_rcDJg_closure" {
     $krep11_rcDJg_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcST_closure+1;
         const $krep10_rcDJf_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.169766074 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'ST1_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'ST1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rcDJd_closure+4;
         const $krep11_rcDJg_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.171638059 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tc'ST3_bytes" {
     Control.Monad.ST.Lazy.Imp.$tc'ST3_bytes:
         I8[] [39,83,84]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.173519788 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'ST2_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'ST2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tc'ST3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.17535664 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'ST_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'ST_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'ST2_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'ST1_closure+4;
         const 5656684040178075861;
         const 6626797926801395533;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.178750099 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.S#_closure" {
     Control.Monad.ST.Lazy.Imp.S#_closure:
         const Control.Monad.ST.Lazy.Imp.S#_info;
 },
 Control.Monad.ST.Lazy.Imp.S#_entry() //  []
         { info_tbl: [(ccEhd,
                       label: Control.Monad.ST.Lazy.Imp.S#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEhd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEhh; else goto ccEhg;
       ccEhh: // global
           HpAlloc = 16;
           R1 = Control.Monad.ST.Lazy.Imp.S#_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccEhg: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.182526803 UTC

[Control.Monad.ST.Lazy.Imp.S#_con_entry() //  [R1]
         { info_tbl: [(ccEhn,
                       label: Control.Monad.ST.Lazy.Imp.S#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,77,111,110,97,100,46,83,84,46,76,97,122,121,46,73,109,112,46,83,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEhn: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.185879954 UTC

[section ""relreadonly" . ScDMD_srt" {
     ScDMD_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.625778878 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:33.627296452 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST5_entry() //  [R2, R3]
         { info_tbl: [(ccEkD,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEkD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccEkH; else goto ccEkG;
       ccEkH: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEkG: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.631696788 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure:
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_info;
         const 0;
 },
 Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_entry() //  [R2]
         { info_tbl: [(ccEkS,
                       label: Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEkS: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.635410179 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unST1_closure" {
     Control.Monad.ST.Lazy.Imp.unST1_closure:
         const Control.Monad.ST.Lazy.Imp.unST1_info;
 },
 Control.Monad.ST.Lazy.Imp.unST1_entry() //  [R2]
         { info_tbl: [(ccEl4,
                       label: Control.Monad.ST.Lazy.Imp.unST1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEl4: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.638964139 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unST_closure" {
     Control.Monad.ST.Lazy.Imp.unST_closure:
         const Control.Monad.ST.Lazy.Imp.unST_info;
 },
 Control.Monad.ST.Lazy.Imp.unST_entry() //  [R2]
         { info_tbl: [(ccElf,
                       label: Control.Monad.ST.Lazy.Imp.unST_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccElf: // global
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.unST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.643132039 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fMonadST1_info;
 },
 res_scEhB_entry() //  [R1]
         { info_tbl: [(ccElw,
                       label: res_scEhB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccElw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccElx; else goto ccEly;
       ccElx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEly: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccElu_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccElu() //  []
         { info_tbl: [(ccElu,
                       label: block_ccElu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccElu: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fMonadST1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccElC,
                       label: Control.Monad.ST.Lazy.Imp.$fMonadST1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccElC: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccElG; else goto ccElF;
       ccElG: // global
           HpAlloc = 80;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fMonadST1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccElF: // global
           I64[Hp - 72] = res_scEhB_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = stg_sel_1_upd_info;
           _ccElq::P64 = Hp - 72;
           P64[Hp - 24] = _ccElq::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _ccElq::P64;
           _scEhz::P64 = R3;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _scEhz::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.651966252 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$w$c<*>_closure" {
     Control.Monad.ST.Lazy.Imp.$w$c<*>_closure:
         const Control.Monad.ST.Lazy.Imp.$w$c<*>_info;
 },
 res4_scEhW_entry() //  [R1]
         { info_tbl: [(ccEmn,
                       label: res4_scEhW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEmn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccEmo; else goto ccEmp;
       ccEmo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEmp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccEml_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccEml() //  []
         { info_tbl: [(ccEml,
                       label: block_ccEml_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEml: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scEi2_entry() //  [R1]
         { info_tbl: [(ccEmx,
                       label: sat_scEi2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEmx: // global
           _scEi2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccEmy; else goto ccEmz;
       ccEmz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccEmB; else goto ccEmA;
       ccEmB: // global
           HpAlloc = 24;
           goto ccEmy;
       ccEmy: // global
           R1 = _scEi2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEmA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scEi2::P64;
           _scEhU::P64 = P64[_scEi2::P64 + 16];
           _scEhW::P64 = P64[_scEi2::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _scEhW::P64;
           R2 = Hp - 16;
           R1 = _scEhU::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$w$c<*>_entry() //  [R2, R3, R4]
         { info_tbl: [(ccEmC,
                       label: Control.Monad.ST.Lazy.Imp.$w$c<*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEmC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEmD; else goto ccEmE;
       ccEmD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$w$c<*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEmE: // global
           I64[Sp - 16] = block_ccEm8_info;
           _scEhL::P64 = R2;
           R2 = R4;
           R1 = _scEhL::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEm8() //  [R1]
         { info_tbl: [(ccEm8,
                       label: block_ccEm8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEm8: // global
           I64[Sp] = block_ccEmc_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucEmK; else goto ccEmd;
       ucEmK: // global
           call _ccEmc(R1) args: 0, res: 0, upd: 0;
       ccEmd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEmc() //  [R1]
         { info_tbl: [(ccEmc,
                       label: block_ccEmc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEmc: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccEmJ; else goto ccEmI;
       ccEmJ: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEmI: // global
           _scEhU::P64 = P64[R1 + 7];
           _scEhV::P64 = P64[R1 + 15];
           I64[Hp - 80] = res4_scEhW_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _scEhV::P64;
           I64[Hp - 48] = stg_sel_1_upd_info;
           _ccEmh::P64 = Hp - 80;
           P64[Hp - 32] = _ccEmh::P64;
           I64[Hp - 24] = sat_scEi2_info;
           P64[Hp - 8] = _scEhU::P64;
           P64[Hp] = _ccEmh::P64;
           R2 = Hp - 48;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.667485366 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST4_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST4_entry() //  [R2, R3, R4]
         { info_tbl: [(ccEns,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEns: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccEnt; else goto ccEnu;
       ccEnt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEnu: // global
           I64[Sp - 8] = block_ccEnp_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.ST.Lazy.Imp.$w$c<*>_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccEnp() //  [R1, R2]
         { info_tbl: [(ccEnp,
                       label: block_ccEnp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEnp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccEnx; else goto ccEnw;
       ccEnx: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccEnw: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.67402069 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$w$cliftA2_closure" {
     Control.Monad.ST.Lazy.Imp.$w$cliftA2_closure:
         const Control.Monad.ST.Lazy.Imp.$w$cliftA2_info;
 },
 res1_scEih_entry() //  [R1]
         { info_tbl: [(ccEnT,
                       label: res1_scEih_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEnT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccEnU; else goto ccEnV;
       ccEnU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEnV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccEnR_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccEnR() //  []
         { info_tbl: [(ccEnR,
                       label: block_ccEnR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEnR: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 res2_scEij_entry() //  [R1]
         { info_tbl: [(ccEo4,
                       label: res2_scEij_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEo4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccEo5; else goto ccEo6;
       ccEo5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEo6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccEo1_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccEo1() //  []
         { info_tbl: [(ccEo1,
                       label: block_ccEo1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEo1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccEo9; else goto ccEo8;
       ccEo9: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       ccEo8: // global
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = P64[Sp + 16];
           R2 = Hp - 16;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scEix_entry() //  [R1]
         { info_tbl: [(ccEoh,
                       label: sat_scEix_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEoh: // global
           _scEix::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccEoi; else goto ccEoj;
       ccEoj: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccEol; else goto ccEok;
       ccEol: // global
           HpAlloc = 48;
           goto ccEoi;
       ccEoi: // global
           R1 = _scEix::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEok: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scEix::P64;
           _scEid::P64 = P64[_scEix::P64 + 16];
           _scEih::P64 = P64[_scEix::P64 + 24];
           _scEij::P64 = P64[_scEix::P64 + 32];
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _scEij::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _scEih::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _scEid::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$w$cliftA2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccEom,
                       label: Control.Monad.ST.Lazy.Imp.$w$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEom: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccEoq; else goto ccEop;
       ccEoq: // global
           HpAlloc = 128;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$w$cliftA2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEop: // global
           I64[Hp - 120] = res1_scEih_info;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = res2_scEij_info;
           P64[Hp - 72] = R4;
           _ccEnN::P64 = Hp - 120;
           P64[Hp - 64] = _ccEnN::P64;
           I64[Hp - 56] = stg_sel_1_upd_info;
           _ccEnX::P64 = Hp - 88;
           P64[Hp - 40] = _ccEnX::P64;
           I64[Hp - 32] = sat_scEix_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = _ccEnN::P64;
           P64[Hp] = _ccEnX::P64;
           R2 = Hp - 56;
           R1 = Hp - 32;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.688884268 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST3_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST3_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(ccEpc,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEpc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccEpd; else goto ccEpe;
       ccEpd: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEpe: // global
           I64[Sp - 8] = block_ccEp9_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.ST.Lazy.Imp.$w$cliftA2_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccEp9() //  [R1, R2]
         { info_tbl: [(ccEp9,
                       label: block_ccEp9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEp9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccEph; else goto ccEpg;
       ccEph: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccEpg: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.695879856 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_info;
 },
 s'_scEiM_entry() //  [R1]
         { info_tbl: [(ccEpF,
                       label: s'_scEiM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEpF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccEpG; else goto ccEpH;
       ccEpG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEpH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccEpB_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccEpB() //  []
         { info_tbl: [(ccEpB,
                       label: block_ccEpB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEpB: // global
           _scEiL::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccEpD_info;
           R2 = _scEiL::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccEpD() //  [R1]
         { info_tbl: [(ccEpD,
                       label: block_ccEpD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEpD: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST2_entry() //  [R2, R3, R4]
         { info_tbl: [(ccEpM,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEpM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccEpQ; else goto ccEpP;
       ccEpQ: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEpP: // global
           I64[Hp - 24] = s'_scEiM_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 24;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.706774327 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$w$c<*_closure" {
     Control.Monad.ST.Lazy.Imp.$w$c<*_closure:
         const Control.Monad.ST.Lazy.Imp.$w$c<*_info;
 },
 s''_scEj2_entry() //  [R1]
         { info_tbl: [(ccEqD,
                       label: s''_scEj2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEqD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccEqE; else goto ccEqF;
       ccEqE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEqF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccEqz_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccEqz() //  []
         { info_tbl: [(ccEqz,
                       label: block_ccEqz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEqz: // global
           _scEj1::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccEqB_info;
           R2 = _scEj1::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccEqB() //  [R1]
         { info_tbl: [(ccEqB,
                       label: block_ccEqB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEqB: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$w$c<*_entry() //  [R2, R3, R4]
         { info_tbl: [(ccEqK,
                       label: Control.Monad.ST.Lazy.Imp.$w$c<*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEqK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEqL; else goto ccEqM;
       ccEqL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$w$c<*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEqM: // global
           I64[Sp - 16] = block_ccEqm_info;
           _scEiR::P64 = R2;
           R2 = R4;
           R1 = _scEiR::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEqm() //  [R1]
         { info_tbl: [(ccEqm,
                       label: block_ccEqm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEqm: // global
           I64[Sp] = block_ccEqq_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucEqS; else goto ccEqr;
       ucEqS: // global
           call _ccEqq(R1) args: 0, res: 0, upd: 0;
       ccEqr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEqq() //  [R1]
         { info_tbl: [(ccEqq,
                       label: block_ccEqq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEqq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccEqR; else goto ccEqQ;
       ccEqR: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEqQ: // global
           _scEj0::P64 = P64[R1 + 7];
           _scEj1::P64 = P64[R1 + 15];
           I64[Hp - 24] = s''_scEj2_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _scEj1::P64;
           R2 = Hp - 24;
           R1 = _scEj0::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.720037694 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST1_info;
 },
 Control.Monad.ST.Lazy.Imp.$fApplicativeST1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccEry,
                       label: Control.Monad.ST.Lazy.Imp.$fApplicativeST1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEry: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccErz; else goto ccErA;
       ccErz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccErA: // global
           I64[Sp - 8] = block_ccErv_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.ST.Lazy.Imp.$w$c<*_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccErv() //  [R1, R2]
         { info_tbl: [(ccErv,
                       label: block_ccErv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccErv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccErD; else goto ccErC;
       ccErD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccErC: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.7268237 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure:
         const Control.Monad.ST.Lazy.Imp.$fFunctorST2_info;
 },
 res_scEjg_entry() //  [R1]
         { info_tbl: [(ccErZ,
                       label: res_scEjg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccErZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccEs0; else goto ccEs1;
       ccEs0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEs1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccErX_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccErX() //  []
         { info_tbl: [(ccErX,
                       label: block_ccErX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccErX: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scEjm_entry() //  [R1]
         { info_tbl: [(ccEs9,
                       label: sat_scEjm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEs9: // global
           _scEjm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccEsa; else goto ccEsb;
       ccEsb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccEsd; else goto ccEsc;
       ccEsd: // global
           HpAlloc = 24;
           goto ccEsa;
       ccEsa: // global
           R1 = _scEjm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEsc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scEjm::P64;
           _scEjd::P64 = P64[_scEjm::P64 + 16];
           _scEjg::P64 = P64[_scEjm::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _scEjg::P64;
           R2 = Hp - 16;
           R1 = _scEjd::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fFunctorST2_entry() //  [R2, R3, R4]
         { info_tbl: [(ccEsf,
                       label: Control.Monad.ST.Lazy.Imp.$fFunctorST2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEsf: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccEsj; else goto ccEsi;
       ccEsj: // global
           HpAlloc = 112;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEsi: // global
           I64[Hp - 104] = res_scEjg_info;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = stg_sel_1_upd_info;
           _ccErT::P64 = Hp - 104;
           P64[Hp - 56] = _ccErT::P64;
           I64[Hp - 48] = sat_scEjm_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = _ccErT::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.73796825 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fFunctorST1_info;
 },
 s'_scEju_entry() //  [R1]
         { info_tbl: [(ccEsY,
                       label: s'_scEju_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEsY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccEsZ; else goto ccEt0;
       ccEsZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEt0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccEsU_info;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _ccEsU() //  []
         { info_tbl: [(ccEsU,
                       label: block_ccEsU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEsU: // global
           _scEjt::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccEsW_info;
           R2 = _scEjt::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccEsW() //  [R1]
         { info_tbl: [(ccEsW,
                       label: block_ccEsW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEsW: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fFunctorST1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccEt6,
                       label: Control.Monad.ST.Lazy.Imp.$fFunctorST1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEt6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccEta; else goto ccEt9;
       ccEta: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEt9: // global
           I64[Hp - 48] = s'_scEju_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.748062199 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fFunctorST_closure" {
     Control.Monad.ST.Lazy.Imp.$fFunctorST_closure:
         const GHC.Base.C:Functor_con_info;
         const Control.Monad.ST.Lazy.Imp.$fFunctorST2_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fFunctorST1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.749878253 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fApplicativeST_closure" {
     Control.Monad.ST.Lazy.Imp.$fApplicativeST_closure:
         const GHC.Base.C:Applicative_con_info;
         const Control.Monad.ST.Lazy.Imp.$fFunctorST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure+2;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST4_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST3_closure+4;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.75177306 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadST_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadST_closure:
         const GHC.Base.C:Monad_con_info;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fMonadST1_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST2_closure+3;
         const Control.Monad.ST.Lazy.Imp.$fApplicativeST5_closure+2;
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.753656198 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFailST_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFailST_closure:
         const Control.Monad.Fail.C:MonadFail_con_info;
         const Control.Monad.ST.Lazy.Imp.$fMonadST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fMonadFailST_$cfail_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.755899304 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.runST_closure" {
     Control.Monad.ST.Lazy.Imp.runST_closure:
         const Control.Monad.ST.Lazy.Imp.runST_info;
 },
 Control.Monad.ST.Lazy.Imp.runST_entry() //  [R2]
         { info_tbl: [(ccEtL,
                       label: Control.Monad.ST.Lazy.Imp.runST_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEtL: // global
           _scEjz::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccEtM; else goto ccEtN;
       ccEtN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEtP; else goto ccEtO;
       ccEtP: // global
           HpAlloc = 16;
           goto ccEtM;
       ccEtM: // global
           R2 = _scEjz::P64;
           R1 = Control.Monad.ST.Lazy.Imp.runST_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccEtO: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Sp - 8] = block_ccEtJ_info;
           R2 = Hp - 7;
           R1 = _scEjz::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEtJ() //  [R1]
         { info_tbl: [(ccEtJ,
                       label: block_ccEtJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEtJ: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.762035967 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure:
         const Control.Monad.ST.Lazy.Imp.$fMonadFixST1_info;
 },
 ds_scEjG_entry() //  [R1]
         { info_tbl: [(ccEue,
                       label: ds_scEjG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEue: // global
           _scEjG::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccEui; else goto ccEuj;
       ccEuj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccEul; else goto ccEuk;
       ccEul: // global
           HpAlloc = 24;
           goto ccEui;
       ccEui: // global
           R1 = _scEjG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEuk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scEjG::P64;
           _scEjE::P64 = P64[_scEjG::P64 + 16];
           _scEjF::P64 = P64[_scEjG::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _scEjG::P64;
           I64[Sp - 24] = block_ccEuc_info;
           R3 = _scEjF::P64;
           R2 = Hp - 16;
           R1 = _scEjE::P64;
           Sp = Sp - 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccEuc() //  [R1]
         { info_tbl: [(ccEuc,
                       label: block_ccEuc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEuc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccEuo; else goto ccEun;
       ccEuo: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccEun: // global
           _scEjN::P64 = P64[R1 + 7];
           _scEjO::P64 = P64[R1 + 15];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = _scEjN::P64;
           P64[Hp] = _scEjO::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.ST.Lazy.Imp.$fMonadFixST1_entry() //  [R2, R3]
         { info_tbl: [(ccEus,
                       label: Control.Monad.ST.Lazy.Imp.$fMonadFixST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEus: // global
           _scEjF::P64 = R3;
           _scEjE::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccEut; else goto ccEuu;
       ccEuu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccEuw; else goto ccEuv;
       ccEuw: // global
           HpAlloc = 32;
           goto ccEut;
       ccEut: // global
           R3 = _scEjF::P64;
           R2 = _scEjE::P64;
           R1 = Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEuv: // global
           I64[Hp - 24] = ds_scEjG_info;
           P64[Hp - 8] = _scEjE::P64;
           P64[Hp] = _scEjF::P64;
           I64[Sp - 8] = block_ccEup_info;
           R1 = Hp - 24;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucEuA; else goto ccEuq;
       ucEuA: // global
           call _ccEup(R1) args: 0, res: 0, upd: 0;
       ccEuq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEup() //  [R1]
         { info_tbl: [(ccEup,
                       label: block_ccEup_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEup: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.773113387 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.fixST_closure" {
     Control.Monad.ST.Lazy.Imp.fixST_closure:
         const Control.Monad.ST.Lazy.Imp.fixST_info;
 },
 Control.Monad.ST.Lazy.Imp.fixST_entry() //  [R2, R3]
         { info_tbl: [(ccEv4,
                       label: Control.Monad.ST.Lazy.Imp.fixST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEv4: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.$fMonadFixST1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.776586856 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$fMonadFixST_closure" {
     Control.Monad.ST.Lazy.Imp.$fMonadFixST_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Control.Monad.ST.Lazy.Imp.$fMonadST_closure+1;
         const Control.Monad.ST.Lazy.Imp.$fMonadFixST1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.77889245 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.strictToLazyST1_closure" {
     Control.Monad.ST.Lazy.Imp.strictToLazyST1_closure:
         const Control.Monad.ST.Lazy.Imp.strictToLazyST1_info;
 },
 Control.Monad.ST.Lazy.Imp.strictToLazyST1_entry() //  [R2, R3]
         { info_tbl: [(ccEvj,
                       label: Control.Monad.ST.Lazy.Imp.strictToLazyST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEvj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEvq; else goto ccEvr;
       ccEvq: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.strictToLazyST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEvr: // global
           I64[Sp - 16] = block_ccEvg_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEvw; else goto ccEvh;
       ucEvw: // global
           call _ccEvg() args: 0, res: 0, upd: 0;
       ccEvh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEvg() //  []
         { info_tbl: [(ccEvg,
                       label: block_ccEvg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEvg: // global
           _scEjT::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEvm_info;
           R1 = _scEjT::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEvm() //  [R1]
         { info_tbl: [(ccEvm,
                       label: block_ccEvm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEvm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEvv; else goto ccEvu;
       ccEvv: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEvu: // global
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.787501854 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.strictToLazyST_closure" {
     Control.Monad.ST.Lazy.Imp.strictToLazyST_closure:
         const Control.Monad.ST.Lazy.Imp.strictToLazyST_info;
 },
 Control.Monad.ST.Lazy.Imp.strictToLazyST_entry() //  [R2, R3]
         { info_tbl: [(ccEvT,
                       label: Control.Monad.ST.Lazy.Imp.strictToLazyST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEvT: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.strictToLazyST1_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.7912773 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeIOToST1_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeIOToST1_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeIOToST1_info;
 },
 Control.Monad.ST.Lazy.Imp.unsafeIOToST1_entry() //  [R2, R3]
         { info_tbl: [(ccEw7,
                       label: Control.Monad.ST.Lazy.Imp.unsafeIOToST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEw7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEwe; else goto ccEwf;
       ccEwe: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.unsafeIOToST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEwf: // global
           I64[Sp - 16] = block_ccEw4_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEwk; else goto ccEw5;
       ucEwk: // global
           call _ccEw4() args: 0, res: 0, upd: 0;
       ccEw5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEw4() //  []
         { info_tbl: [(ccEw4,
                       label: block_ccEw4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEw4: // global
           _scEk1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEwa_info;
           R1 = _scEk1::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEwa() //  [R1]
         { info_tbl: [(ccEwa,
                       label: block_ccEwa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEwa: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEwj; else goto ccEwi;
       ccEwj: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEwi: // global
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.799324753 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeIOToST_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeIOToST_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeIOToST_info;
 },
 Control.Monad.ST.Lazy.Imp.unsafeIOToST_entry() //  [R2, R3]
         { info_tbl: [(ccEwH,
                       label: Control.Monad.ST.Lazy.Imp.unsafeIOToST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEwH: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.unsafeIOToST1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.802981392 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.lazyToStrictST1_closure" {
     Control.Monad.ST.Lazy.Imp.lazyToStrictST1_closure:
         const Control.Monad.ST.Lazy.Imp.lazyToStrictST1_info;
 },
 Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry() //  [R2]
         { info_tbl: [(ccEwV,
                       label: Control.Monad.ST.Lazy.Imp.lazyToStrictST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEwV: // global
           _scEk9::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto ccEwZ; else goto ccEx0;
       ccEx0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEx2; else goto ccEx1;
       ccEx2: // global
           HpAlloc = 16;
           goto ccEwZ;
       ccEwZ: // global
           R2 = _scEk9::P64;
           R1 = Control.Monad.ST.Lazy.Imp.lazyToStrictST1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccEx1: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Sp - 8] = block_ccEwT_info;
           R2 = Hp - 7;
           R1 = _scEk9::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEwT() //  [R1]
         { info_tbl: [(ccEwT,
                       label: block_ccEwT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEwT: // global
           I64[Sp - 8] = block_ccEwY_info;
           _scEkd::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _scEkd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucEx9; else goto ccEx4;
       ucEx9: // global
           call _ccEwY() args: 0, res: 0, upd: 0;
       ccEx4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEwY() //  []
         { info_tbl: [(ccEwY,
                       label: block_ccEwY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEwY: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.810901339 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.lazyToStrictST_closure" {
     Control.Monad.ST.Lazy.Imp.lazyToStrictST_closure:
         const Control.Monad.ST.Lazy.Imp.lazyToStrictST_info;
 },
 Control.Monad.ST.Lazy.Imp.lazyToStrictST_entry() //  [R2]
         { info_tbl: [(ccExu,
                       label: Control.Monad.ST.Lazy.Imp.lazyToStrictST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccExu: // global
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.81439237 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.stToIO_closure" {
     Control.Monad.ST.Lazy.Imp.stToIO_closure:
         const Control.Monad.ST.Lazy.Imp.stToIO_info;
 },
 Control.Monad.ST.Lazy.Imp.stToIO_entry() //  [R2]
         { info_tbl: [(ccExF,
                       label: Control.Monad.ST.Lazy.Imp.stToIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccExF: // global
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.lazyToStrictST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.819388233 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_info;
 },
 sat_scEkt_entry() //  [R1]
         { info_tbl: [(ccEy5,
                       label: sat_scEkt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEy5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEy9; else goto ccEya;
       ccEy9: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccEya: // global
           I64[Sp - 16] = block_ccEy0_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _ccEy0() //  []
         { info_tbl: [(ccEy0,
                       label: block_ccEy0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEy0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEyd; else goto ccEyc;
       ccEyd: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccEyc: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           _scEkh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEy3_info;
           R2 = Hp - 7;
           R1 = _scEkh::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEy3() //  [R1]
         { info_tbl: [(ccEy3,
                       label: block_ccEy3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEy3: // global
           I64[Sp - 8] = block_ccEy8_info;
           _scEkp::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _scEkp::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucEyk; else goto ccEyf;
       ucEyk: // global
           call _ccEy8() args: 0, res: 0, upd: 0;
       ccEyf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEy8() //  []
         { info_tbl: [(ccEy8,
                       label: block_ccEy8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEy8: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_entry() //  [R2, R3]
         { info_tbl: [(ccEyl,
                       label: Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEyl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEyq; else goto ccEyr;
       ccEyq: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEyr: // global
           I64[Sp - 16] = block_ccExQ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEyy; else goto ccExR;
       ucEyy: // global
           call _ccExQ(R1) args: 0, res: 0, upd: 0;
       ccExR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccExQ() //  [R1]
         { info_tbl: [(ccExQ,
                       label: block_ccExQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccExQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEyu; else goto ccEyt;
       ccEyu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEyt: // global
           I64[Hp - 8] = sat_scEkt_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccEym_info;
           R2 = Hp - 7;
           Sp = Sp + 8;
           call GHC.ST.unsafeDupableInterleaveST_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccEym() //  [R1]
         { info_tbl: [(ccEym,
                       label: block_ccEym_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEym: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEyx; else goto ccEyw;
       ccEyx: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEyw: // global
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.835009559 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_closure" {
     Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_closure:
         const Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_info;
 },
 Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_entry() //  [R2, R3]
         { info_tbl: [(ccEzh,
                       label: Control.Monad.ST.Lazy.Imp.unsafeInterleaveST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEzh: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.ST.Lazy.Imp.unsafeInterleaveST1_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.838505094 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$trModule4_bytes" {
     Control.Monad.ST.Lazy.Imp.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.840333995 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$trModule3_closure" {
     Control.Monad.ST.Lazy.Imp.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.84218881 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$trModule2_bytes" {
     Control.Monad.ST.Lazy.Imp.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100,46,83,84,46,76,97,122,121,46,73,109,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.843986476 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$trModule1_closure" {
     Control.Monad.ST.Lazy.Imp.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.845848439 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$trModule_closure" {
     Control.Monad.ST.Lazy.Imp.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule3_closure+1;
         const Control.Monad.ST.Lazy.Imp.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.847650818 UTC

[section ""data" . $krep_rcDJ5_closure" {
     $krep_rcDJ5_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.850435702 UTC

[section ""data" . $krep1_rcDJ6_closure" {
     $krep1_rcDJ6_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.852242948 UTC

[section ""data" . $krep2_rcDJ7_closure" {
     $krep2_rcDJ7_closure:
         const :_con_info;
         const $krep1_rcDJ6_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.854070002 UTC

[section ""data" . $krep3_rcDJ8_closure" {
     $krep3_rcDJ8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcState#_closure;
         const $krep2_rcDJ7_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.856224291 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tcState2_bytes" {
     Control.Monad.ST.Lazy.Imp.$tcState2_bytes:
         I8[] [83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.857984166 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcState1_closure" {
     Control.Monad.ST.Lazy.Imp.$tcState1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.859801379 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcState_closure" {
     Control.Monad.ST.Lazy.Imp.$tcState_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tcState1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 220923881781706094;
         const 12630832853168782158;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.861798714 UTC

[section ""data" . $krep4_rcDJ9_closure" {
     $krep4_rcDJ9_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcState_closure+1;
         const $krep2_rcDJ7_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.863630517 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'S#1_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'S#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rcDJ8_closure+1;
         const $krep4_rcDJ9_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.866118933 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tc'S#3_bytes" {
     Control.Monad.ST.Lazy.Imp.$tc'S#3_bytes:
         I8[] [39,83,35]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.867898668 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'S#2_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'S#2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tc'S#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.869793578 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'S#_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'S#_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'S#2_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'S#1_closure+4;
         const 12704778602275544086;
         const 1928505377508739254;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.871725895 UTC

[section ""data" . $krep5_rcDJa_closure" {
     $krep5_rcDJa_closure:
         const :_con_info;
         const $krep4_rcDJ9_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.873569679 UTC

[section ""data" . $krep6_rcDJb_closure" {
     $krep6_rcDJb_closure:
         const :_con_info;
         const $krep_rcDJ5_closure+2;
         const $krep5_rcDJa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.875422142 UTC

[section ""data" . $krep7_rcDJc_closure" {
     $krep7_rcDJc_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep6_rcDJb_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.877954077 UTC

[section ""data" . $krep8_rcDJd_closure" {
     $krep8_rcDJd_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rcDJ9_closure+1;
         const $krep7_rcDJc_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.879776595 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tcST2_bytes" {
     Control.Monad.ST.Lazy.Imp.$tcST2_bytes:
         I8[] [83,84]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.881562668 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcST1_closure" {
     Control.Monad.ST.Lazy.Imp.$tcST1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcST2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.883364461 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tcST_closure" {
     Control.Monad.ST.Lazy.Imp.$tcST_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tcST1_closure+1;
         const GHC.Types.krep$*->*->*_closure;
         const 9758985700159114765;
         const 4154811637844139714;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.886082724 UTC

[section ""data" . $krep9_rcDJe_closure" {
     $krep9_rcDJe_closure:
         const :_con_info;
         const $krep_rcDJ5_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.887905914 UTC

[section ""data" . $krep10_rcDJf_closure" {
     $krep10_rcDJf_closure:
         const :_con_info;
         const $krep1_rcDJ6_closure+2;
         const $krep9_rcDJe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.889746317 UTC

[section ""data" . $krep11_rcDJg_closure" {
     $krep11_rcDJg_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Monad.ST.Lazy.Imp.$tcST_closure+1;
         const $krep10_rcDJf_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.891675567 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'ST1_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'ST1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rcDJd_closure+4;
         const $krep11_rcDJg_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.893553109 UTC

[section ""cstring" . Control.Monad.ST.Lazy.Imp.$tc'ST3_bytes" {
     Control.Monad.ST.Lazy.Imp.$tc'ST3_bytes:
         I8[] [39,83,84]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.895349157 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'ST2_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'ST2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.ST.Lazy.Imp.$tc'ST3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.897161727 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.$tc'ST_closure" {
     Control.Monad.ST.Lazy.Imp.$tc'ST_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.ST.Lazy.Imp.$trModule_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'ST2_closure+1;
         const Control.Monad.ST.Lazy.Imp.$tc'ST1_closure+4;
         const 5656684040178075861;
         const 6626797926801395533;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.89941896 UTC

[section ""data" . Control.Monad.ST.Lazy.Imp.S#_closure" {
     Control.Monad.ST.Lazy.Imp.S#_closure:
         const Control.Monad.ST.Lazy.Imp.S#_info;
 },
 Control.Monad.ST.Lazy.Imp.S#_entry() //  []
         { info_tbl: [(ccEzY,
                       label: Control.Monad.ST.Lazy.Imp.S#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEzY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccEA2; else goto ccEA1;
       ccEA2: // global
           HpAlloc = 16;
           R1 = Control.Monad.ST.Lazy.Imp.S#_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccEA1: // global
           I64[Hp - 8] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.90389575 UTC

[Control.Monad.ST.Lazy.Imp.S#_con_entry() //  [R1]
         { info_tbl: [(ccEA9,
                       label: Control.Monad.ST.Lazy.Imp.S#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,77,111,110,97,100,46,83,84,46,76,97,122,121,46,73,109,112,46,83,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEA9: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:33.907752798 UTC

[section ""relreadonly" . ScEkV_srt" {
     ScEkV_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
 }]

