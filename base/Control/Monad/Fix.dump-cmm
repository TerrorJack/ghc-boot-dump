
==================== Output Cmm ====================
2018-03-16 16:06:34.179280063 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:34.180294578 UTC

[section ""data" . Control.Monad.Fix.$p1MonadFix_closure" {
     Control.Monad.Fix.$p1MonadFix_closure:
         const Control.Monad.Fix.$p1MonadFix_info;
 },
 Control.Monad.Fix.$p1MonadFix_entry() //  [R2]
         { info_tbl: [(cbGFh,
                       label: Control.Monad.Fix.$p1MonadFix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGFh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbGFi; else goto cbGFj;
       cbGFi: // global
           R2 = R2;
           R1 = Control.Monad.Fix.$p1MonadFix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGFj: // global
           I64[Sp - 8] = block_cbGFe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubGFn; else goto cbGFf;
       ubGFn: // global
           call _cbGFe(R1) args: 0, res: 0, upd: 0;
       cbGFf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbGFe() //  [R1]
         { info_tbl: [(cbGFe,
                       label: block_cbGFe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGFe: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.181568227 UTC

[section ""data" . Control.Monad.Fix.mfix_closure" {
     Control.Monad.Fix.mfix_closure:
         const Control.Monad.Fix.mfix_info;
 },
 Control.Monad.Fix.mfix_entry() //  [R2]
         { info_tbl: [(cbGFv,
                       label: Control.Monad.Fix.mfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGFv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbGFw; else goto cbGFx;
       cbGFw: // global
           R2 = R2;
           R1 = Control.Monad.Fix.mfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGFx: // global
           I64[Sp - 8] = block_cbGFs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubGFB; else goto cbGFt;
       ubGFB: // global
           call _cbGFs(R1) args: 0, res: 0, upd: 0;
       cbGFt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbGFs() //  [R1]
         { info_tbl: [(cbGFs,
                       label: block_cbGFs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGFs: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.182507138 UTC

[section ""cstring" . lvl_rbGDa_bytes" {
     lvl_rbGDa_bytes:
         I8[] [109,102,105,120,32,77,97,121,98,101,58,32,78,111,116,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.183385958 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixFirst1_closure" {
     Control.Monad.Fix.$fMonadFixFirst1_closure:
         const Control.Monad.Fix.$fMonadFixFirst1_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Monad.Fix.$fMonadFixFirst1_entry() //  [R1]
         { info_tbl: [(cbGFK,
                       label: Control.Monad.Fix.$fMonadFixFirst1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGFK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbGFL; else goto cbGFM;
       cbGFL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGFM: // global
           (_cbGFF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbGFF::I64 == 0) goto cbGFH; else goto cbGFG;
       cbGFH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbGFG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbGFF::I64;
           I64[Sp - 24] = block_cbGFI_info;
           R2 = lvl_rbGDa_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbGFI() //  [R1]
         { info_tbl: [(cbGFI,
                       label: block_cbGFI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGFI: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.185149406 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixMaybe_$cmfix_info;
         const 0;
 },
 sat_sbGDr_entry() //  [R1]
         { info_tbl: [(cbGGa,
                       label: sat_sbGDr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGGa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbGGb; else goto cbGGc;
       cbGGb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGGc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbGG3_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubGGj; else goto cbGG4;
       ubGGj: // global
           call _cbGG3(R1) args: 0, res: 0, upd: 0;
       cbGG4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbGG3() //  [R1]
         { info_tbl: [(cbGG3,
                       label: block_cbGG3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGG3: // global
           if (R1 & 7 == 1) goto cbGG7; else goto cbGG8;
       cbGG7: // global
           R1 = Control.Monad.Fix.$fMonadFixFirst1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cbGG8: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 a1_sbGDo_entry() //  [R1]
         { info_tbl: [(cbGGk,
                       label: a1_sbGDo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGGk: // global
           _sbGDo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGGl; else goto cbGGm;
       cbGGm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGGo; else goto cbGGn;
       cbGGo: // global
           HpAlloc = 24;
           goto cbGGl;
       cbGGl: // global
           R1 = _sbGDo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGGn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDo::P64;
           _sbGDn::P64 = P64[_sbGDo::P64 + 16];
           I64[Hp - 16] = sat_sbGDr_info;
           P64[Hp] = _sbGDo::P64;
           R2 = Hp - 16;
           R1 = _sbGDn::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixMaybe_$cmfix_entry() //  [R2]
         { info_tbl: [(cbGGp,
                       label: Control.Monad.Fix.$fMonadFixMaybe_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGGp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGGt; else goto cbGGs;
       cbGGt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGGs: // global
           I64[Hp - 16] = a1_sbGDo_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.186964201 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixMaybe_closure" {
     Control.Monad.Fix.$fMonadFixMaybe_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonadMaybe_closure;
         const Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.188619915 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure" {
     Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure:
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_info;
         const 0;
 },
 sat_sbGDu_entry() //  [R1]
         { info_tbl: [(cbGGG,
                       label: sat_sbGDu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGGG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbGGH; else goto cbGGI;
       cbGGH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGGI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.head_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sbGDt_entry() //  [R1]
         { info_tbl: [(cbGGJ,
                       label: x_sbGDt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGGJ: // global
           _sbGDt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGGK; else goto cbGGL;
       cbGGL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGGN; else goto cbGGM;
       cbGGN: // global
           HpAlloc = 24;
           goto cbGGK;
       cbGGK: // global
           R1 = _sbGDt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGGM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDt::P64;
           _sbGDs::P64 = P64[_sbGDt::P64 + 16];
           I64[Hp - 16] = sat_sbGDu_info;
           P64[Hp] = _sbGDt::P64;
           R2 = Hp - 16;
           R1 = _sbGDs::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbGDC_entry() //  [R1, R2]
         { info_tbl: [(cbGH9,
                       label: sat_sbGDC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGH9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbGHa; else goto cbGHb;
       cbGHa: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGHb: // global
           I64[Sp - 8] = block_cbGH3_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbGH3() //  [R1]
         { info_tbl: [(cbGH3,
                       label: block_cbGH3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGH3: // global
           if (R1 & 7 == 1) goto cbGH6; else goto cbGH7;
       cbGH6: // global
           R1 = GHC.List.scanl2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbGH7: // global
           R1 = P64[R1 + 14] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGDD_entry() //  [R1]
         { info_tbl: [(cbGHi,
                       label: sat_sbGDD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGHi: // global
           _sbGDD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGHj; else goto cbGHk;
       cbGHk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbGHm; else goto cbGHl;
       cbGHm: // global
           HpAlloc = 16;
           goto cbGHj;
       cbGHj: // global
           R1 = _sbGDD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGHl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDD::P64;
           _sbGDs::P64 = P64[_sbGDD::P64 + 16];
           I64[Hp - 8] = sat_sbGDC_info;
           P64[Hp] = _sbGDs::P64;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_entry() //  [R2]
         { info_tbl: [(cbGHr,
                       label: Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGHr: // global
           _sbGDs::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGHs; else goto cbGHt;
       cbGHt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGHv; else goto cbGHu;
       cbGHv: // global
           HpAlloc = 24;
           goto cbGHs;
       cbGHs: // global
           R2 = _sbGDs::P64;
           R1 = Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGHu: // global
           I64[Hp - 16] = x_sbGDt_info;
           P64[Hp] = _sbGDs::P64;
           I64[Sp - 16] = block_cbGGO_info;
           R1 = Hp - 16;
           P64[Sp - 8] = _sbGDs::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubGHC; else goto cbGGP;
       ubGHC: // global
           call _cbGGO(R1) args: 0, res: 0, upd: 0;
       cbGGP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbGGO() //  [R1]
         { info_tbl: [(cbGGO,
                       label: block_cbGGO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGGO: // global
           if (R1 & 7 == 1) goto cbGHo; else goto cbGHp;
       cbGHo: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbGHp: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbGHB; else goto cbGHA;
       cbGHB: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbGHA: // global
           _sbGDw::P64 = P64[R1 + 6];
           I64[Hp - 40] = sat_sbGDD_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sbGDw::P64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.191323108 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix[]_closure" {
     Control.Monad.Fix.$fMonadFix[]_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonad[]_closure;
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.192876667 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_info;
         const 0;
 },
 sat_sbGDS_entry() //  [R1, R2]
         { info_tbl: [(cbGHS,
                       label: sat_sbGDS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGHS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbGHT; else goto cbGHU;
       cbGHT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGHU: // global
           I64[Sp - 8] = block_cbGHQ_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbGHQ() //  [R1]
         { info_tbl: [(cbGHQ,
                       label: block_cbGHQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGHQ: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGDT_entry() //  [R1]
         { info_tbl: [(cbGHY,
                       label: sat_sbGDT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGHY: // global
           _sbGDT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGHZ; else goto cbGI0;
       cbGI0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbGI2; else goto cbGI1;
       cbGI2: // global
           HpAlloc = 16;
           goto cbGHZ;
       cbGHZ: // global
           R1 = _sbGDT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGI1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDT::P64;
           _sbGDE::P64 = P64[_sbGDT::P64 + 16];
           I64[Hp - 8] = sat_sbGDS_info;
           P64[Hp] = _sbGDE::P64;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sbGDF_entry() //  [R1]
         { info_tbl: [(cbGIc,
                       label: x_sbGDF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGIc: // global
           _sbGDF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGId; else goto cbGIe;
       cbGIe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGIg; else goto cbGIf;
       cbGIg: // global
           HpAlloc = 24;
           goto cbGId;
       cbGId: // global
           R1 = _sbGDF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGIf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDF::P64;
           _sbGDE::P64 = P64[_sbGDF::P64 + 16];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbGDF::P64;
           R2 = Hp - 16;
           R1 = _sbGDE::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbGDN_entry() //  [R1]
         { info_tbl: [(cbGIk,
                       label: sat_sbGDN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGIk: // global
           _sbGDN::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbGIl; else goto cbGIm;
       cbGIm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGIo; else goto cbGIn;
       cbGIo: // global
           HpAlloc = 24;
           goto cbGIl;
       cbGIl: // global
           R1 = _sbGDN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGIn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDN::P64;
           _sbGDE::P64 = P64[_sbGDN::P64 + 16];
           I64[Hp - 16] = x_sbGDF_info;
           P64[Hp] = _sbGDE::P64;
           I64[Sp - 24] = block_cbGIh_info;
           R1 = Hp - 16;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubGIs; else goto cbGIi;
       ubGIs: // global
           call _cbGIh(R1) args: 0, res: 0, upd: 0;
       cbGIi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbGIh() //  [R1]
         { info_tbl: [(cbGIh,
                       label: block_cbGIh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGIh: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_entry() //  [R2]
         { info_tbl: [(cbGIu,
                       label: Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGIu: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbGIy; else goto cbGIx;
       cbGIy: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGIx: // global
           I64[Hp - 64] = sat_sbGDT_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbGDN_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.195335082 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixNonEmpty_closure" {
     Control.Monad.Fix.$fMonadFixNonEmpty_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonadNonEmpty_closure;
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.195902911 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixIO_closure" {
     Control.Monad.Fix.$fMonadFixIO_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonadIO_closure;
         const System.IO.fixIO1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.196668567 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix(->)_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFix(->)_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFix(->)_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFix(->)_$cmfix_entry() //  [R2, R3]
         { info_tbl: [(cbGIE,
                       label: Control.Monad.Fix.$fMonadFix(->)_$cmfix_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGIE: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbGII; else goto cbGIH;
       cbGII: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFix(->)_$cmfix_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbGIH: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R2;
           _cbGID::P64 = Hp - 32;
           P64[Hp - 8] = _cbGID::P64;
           P64[Hp] = R3;
           R1 = _cbGID::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.197666878 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix(->)_closure" {
     Control.Monad.Fix.$fMonadFix(->)_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonad(->)_closure;
         const Control.Monad.Fix.$fMonadFix(->)_$cmfix_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.198225898 UTC

[section ""cstring" . lvl1_rbGDb_bytes" {
     lvl1_rbGDb_bytes:
         I8[] [109,102,105,120,32,69,105,116,104,101,114,58,32,76,101,102,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.199028624 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixEither1_closure" {
     Control.Monad.Fix.$fMonadFixEither1_closure:
         const Control.Monad.Fix.$fMonadFixEither1_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Monad.Fix.$fMonadFixEither1_entry() //  [R1]
         { info_tbl: [(cbGIR,
                       label: Control.Monad.Fix.$fMonadFixEither1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGIR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbGIS; else goto cbGIT;
       cbGIS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGIT: // global
           (_cbGIM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbGIM::I64 == 0) goto cbGIO; else goto cbGIN;
       cbGIO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbGIN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbGIM::I64;
           I64[Sp - 24] = block_cbGIP_info;
           R2 = lvl1_rbGDb_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbGIP() //  [R1]
         { info_tbl: [(cbGIP,
                       label: block_cbGIP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGIP: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.200611963 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixEither_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixEither_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixEither_$cmfix_info;
         const 0;
 },
 sat_sbGE3_entry() //  [R1]
         { info_tbl: [(cbGJg,
                       label: sat_sbGE3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGJg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbGJh; else goto cbGJi;
       cbGJh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGJi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbGJ9_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubGJp; else goto cbGJa;
       ubGJp: // global
           call _cbGJ9(R1) args: 0, res: 0, upd: 0;
       cbGJa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbGJ9() //  [R1]
         { info_tbl: [(cbGJ9,
                       label: block_cbGJ9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGJ9: // global
           if (R1 & 7 == 1) goto cbGJd; else goto cbGJe;
       cbGJd: // global
           R1 = Control.Monad.Fix.$fMonadFixEither1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cbGJe: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 a1_sbGDZ_entry() //  [R1]
         { info_tbl: [(cbGJq,
                       label: a1_sbGDZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGJq: // global
           _sbGDZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGJr; else goto cbGJs;
       cbGJs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGJu; else goto cbGJt;
       cbGJu: // global
           HpAlloc = 24;
           goto cbGJr;
       cbGJr: // global
           R1 = _sbGDZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGJt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDZ::P64;
           _sbGDY::P64 = P64[_sbGDZ::P64 + 16];
           I64[Hp - 16] = sat_sbGE3_info;
           P64[Hp] = _sbGDZ::P64;
           R2 = Hp - 16;
           R1 = _sbGDY::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixEither_$cmfix_entry() //  [R2]
         { info_tbl: [(cbGJv,
                       label: Control.Monad.Fix.$fMonadFixEither_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGJv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGJz; else goto cbGJy;
       cbGJz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixEither_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGJy: // global
           I64[Hp - 16] = a1_sbGDZ_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.202286094 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixEither_closure" {
     Control.Monad.Fix.$fMonadFixEither_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Either.$fMonadEither_closure;
         const Control.Monad.Fix.$fMonadFixEither_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.202889215 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixST_closure" {
     Control.Monad.Fix.$fMonadFixST_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.ST.$fMonadST_closure;
         const GHC.ST.fixST1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.203637582 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixDual_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixDual_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixDual_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFixDual_$cmfix_entry() //  [R2]
         { info_tbl: [(cbGJF,
                       label: Control.Monad.Fix.$fMonadFixDual_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGJF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbGJJ; else goto cbGJI;
       cbGJJ: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixDual_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGJI: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbGJE::P64 = Hp - 24;
           P64[Hp] = _cbGJE::P64;
           R1 = _cbGJE::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.204527765 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixDual_closure" {
     Control.Monad.Fix.$fMonadFixDual_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Semigroup.Internal.$fMonadDual_closure;
         const Control.Monad.Fix.$fMonadFixDual_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.205595477 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixSum_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixSum_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixSum_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFixSum_$cmfix_entry() //  [R2]
         { info_tbl: [(cbGJP,
                       label: Control.Monad.Fix.$fMonadFixSum_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGJP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbGJT; else goto cbGJS;
       cbGJT: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixSum_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGJS: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbGJO::P64 = Hp - 24;
           P64[Hp] = _cbGJO::P64;
           R1 = _cbGJO::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.206428368 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixSum_closure" {
     Control.Monad.Fix.$fMonadFixSum_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Semigroup.Internal.$fMonadSum_closure;
         const Control.Monad.Fix.$fMonadFixSum_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.207173297 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixProduct_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixProduct_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixProduct_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFixProduct_$cmfix_entry() //  [R2]
         { info_tbl: [(cbGJZ,
                       label: Control.Monad.Fix.$fMonadFixProduct_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGJZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbGK3; else goto cbGK2;
       cbGK3: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixProduct_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGK2: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbGJY::P64 = Hp - 24;
           P64[Hp] = _cbGJY::P64;
           R1 = _cbGJY::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.208001624 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixProduct_closure" {
     Control.Monad.Fix.$fMonadFixProduct_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Semigroup.Internal.$fMonadProduct_closure;
         const Control.Monad.Fix.$fMonadFixProduct_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.20914431 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixFirst_$cmfix_info;
         const 0;
 },
 sat_sbGEe_entry() //  [R1]
         { info_tbl: [(cbGKn,
                       label: sat_sbGEe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGKn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbGKo; else goto cbGKp;
       cbGKo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGKp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbGKg_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubGKw; else goto cbGKh;
       ubGKw: // global
           call _cbGKg(R1) args: 0, res: 0, upd: 0;
       cbGKh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbGKg() //  [R1]
         { info_tbl: [(cbGKg,
                       label: block_cbGKg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGKg: // global
           if (R1 & 7 == 1) goto cbGKk; else goto cbGKl;
       cbGKk: // global
           R1 = Control.Monad.Fix.$fMonadFixFirst1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cbGKl: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 a1_sbGEb_entry() //  [R1]
         { info_tbl: [(cbGKx,
                       label: a1_sbGEb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGKx: // global
           _sbGEb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGKy; else goto cbGKz;
       cbGKz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGKB; else goto cbGKA;
       cbGKB: // global
           HpAlloc = 24;
           goto cbGKy;
       cbGKy: // global
           R1 = _sbGEb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGKA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGEb::P64;
           _sbGEa::P64 = P64[_sbGEb::P64 + 16];
           I64[Hp - 16] = sat_sbGEe_info;
           P64[Hp] = _sbGEb::P64;
           R2 = Hp - 16;
           R1 = _sbGEa::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixFirst_$cmfix_entry() //  [R2]
         { info_tbl: [(cbGKC,
                       label: Control.Monad.Fix.$fMonadFixFirst_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGKC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGKG; else goto cbGKF;
       cbGKG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGKF: // global
           I64[Hp - 16] = a1_sbGEb_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.210829197 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixFirst_closure" {
     Control.Monad.Fix.$fMonadFixFirst_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Monoid.$fMonadFirst_closure;
         const Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.211982911 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixLast_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixLast_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixLast_$cmfix_info;
         const 0;
 },
 sat_sbGEj_entry() //  [R1]
         { info_tbl: [(cbGL0,
                       label: sat_sbGEj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGL0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbGL1; else goto cbGL2;
       cbGL1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGL2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbGKT_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubGL9; else goto cbGKU;
       ubGL9: // global
           call _cbGKT(R1) args: 0, res: 0, upd: 0;
       cbGKU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbGKT() //  [R1]
         { info_tbl: [(cbGKT,
                       label: block_cbGKT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGKT: // global
           if (R1 & 7 == 1) goto cbGKX; else goto cbGKY;
       cbGKX: // global
           R1 = Control.Monad.Fix.$fMonadFixFirst1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cbGKY: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 a1_sbGEg_entry() //  [R1]
         { info_tbl: [(cbGLa,
                       label: a1_sbGEg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGLa: // global
           _sbGEg::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGLb; else goto cbGLc;
       cbGLc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGLe; else goto cbGLd;
       cbGLe: // global
           HpAlloc = 24;
           goto cbGLb;
       cbGLb: // global
           R1 = _sbGEg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGLd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGEg::P64;
           _sbGEf::P64 = P64[_sbGEg::P64 + 16];
           I64[Hp - 16] = sat_sbGEj_info;
           P64[Hp] = _sbGEg::P64;
           R2 = Hp - 16;
           R1 = _sbGEf::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixLast_$cmfix_entry() //  [R2]
         { info_tbl: [(cbGLf,
                       label: Control.Monad.Fix.$fMonadFixLast_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGLf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGLj; else goto cbGLi;
       cbGLj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixLast_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGLi: // global
           I64[Hp - 16] = a1_sbGEg_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.213693647 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixLast_closure" {
     Control.Monad.Fix.$fMonadFixLast_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Monoid.$fMonadLast_closure;
         const Control.Monad.Fix.$fMonadFixLast_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.214618882 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixAlt1_closure" {
     Control.Monad.Fix.$fMonadFixAlt1_closure:
         const Control.Monad.Fix.$fMonadFixAlt1_info;
 },
 sat_sbGEn_entry() //  [R1, R2]
         { info_tbl: [(cbGLt,
                       label: sat_sbGEn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGLt: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.Fix.$fMonadFixAlt1_entry() //  [R2, R3]
         { info_tbl: [(cbGLw,
                       label: Control.Monad.Fix.$fMonadFixAlt1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGLw: // global
           _sbGEl::P64 = R3;
           _sbGEk::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGLx; else goto cbGLy;
       cbGLy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbGLA; else goto cbGLz;
       cbGLA: // global
           HpAlloc = 16;
           goto cbGLx;
       cbGLx: // global
           R3 = _sbGEl::P64;
           R2 = _sbGEk::P64;
           R1 = Control.Monad.Fix.$fMonadFixAlt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbGLz: // global
           I64[Hp - 8] = sat_sbGEn_info;
           P64[Hp] = _sbGEl::P64;
           R2 = _sbGEk::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.mfix_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.215929555 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_closure" {
     Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_closure:
         const Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_info;
 },
 sat_sbGEp_entry() //  [R1]
         { info_tbl: [(cbGLJ,
                       label: sat_sbGEp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGLJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbGLK; else goto cbGLL;
       cbGLK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGLL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_entry() //  [R2]
         { info_tbl: [(cbGLM,
                       label: Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGLM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGLQ; else goto cbGLP;
       cbGLQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGLP: // global
           I64[Hp - 16] = sat_sbGEp_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fMonadAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.217392226 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixAlt_closure" {
     Control.Monad.Fix.$fMonadFixAlt_closure:
         const Control.Monad.Fix.$fMonadFixAlt_info;
 },
 sat_sbGEs_entry() //  [R1, R2]
         { info_tbl: [(cbGM0,
                       label: sat_sbGEs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGM0: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Fix.$fMonadFixAlt1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGEr_entry() //  [R1]
         { info_tbl: [(cbGM7,
                       label: sat_sbGEr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGM7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbGM8; else goto cbGM9;
       cbGM8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGM9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixAlt_entry() //  [R2]
         { info_tbl: [(cbGMb,
                       label: Control.Monad.Fix.$fMonadFixAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGMb: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbGMf; else goto cbGMe;
       cbGMf: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGMe: // global
           I64[Hp - 56] = sat_sbGEs_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbGEr_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.218774493 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixPar1_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixPar1_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixPar1_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFixPar1_$cmfix_entry() //  [R2]
         { info_tbl: [(cbGMl,
                       label: Control.Monad.Fix.$fMonadFixPar1_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGMl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbGMp; else goto cbGMo;
       cbGMp: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixPar1_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGMo: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbGMk::P64 = Hp - 24;
           P64[Hp] = _cbGMk::P64;
           R1 = _cbGMk::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.219626092 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixPar1_closure" {
     Control.Monad.Fix.$fMonadFixPar1_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Generics.$fMonadPar1_closure;
         const Control.Monad.Fix.$fMonadFixPar1_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.220450812 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixRec2_closure" {
     Control.Monad.Fix.$fMonadFixRec2_closure:
         const Control.Monad.Fix.$fMonadFixRec2_info;
 },
 sat_sbGEy_entry() //  [R1, R2]
         { info_tbl: [(cbGMz,
                       label: sat_sbGEy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGMz: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.Fix.$fMonadFixRec2_entry() //  [R2, R3]
         { info_tbl: [(cbGMC,
                       label: Control.Monad.Fix.$fMonadFixRec2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGMC: // global
           _sbGEw::P64 = R3;
           _sbGEv::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGMD; else goto cbGME;
       cbGME: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbGMG; else goto cbGMF;
       cbGMG: // global
           HpAlloc = 16;
           goto cbGMD;
       cbGMD: // global
           R3 = _sbGEw::P64;
           R2 = _sbGEv::P64;
           R1 = Control.Monad.Fix.$fMonadFixRec2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbGMF: // global
           I64[Hp - 8] = sat_sbGEy_info;
           P64[Hp] = _sbGEw::P64;
           R2 = _sbGEv::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.mfix_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.222180093 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_closure" {
     Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_closure:
         const Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_info;
         const 0;
 },
 sat_sbGEA_entry() //  [R1]
         { info_tbl: [(cbGMP,
                       label: sat_sbGEA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGMP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbGMQ; else goto cbGMR;
       cbGMQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGMR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_entry() //  [R2]
         { info_tbl: [(cbGMS,
                       label: Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGMS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGMW; else goto cbGMV;
       cbGMW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGMV: // global
           I64[Hp - 16] = sat_sbGEA_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadRec1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.223601798 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixRec1_closure" {
     Control.Monad.Fix.$fMonadFixRec1_closure:
         const Control.Monad.Fix.$fMonadFixRec1_info;
         const 0;
 },
 sat_sbGED_entry() //  [R1, R2]
         { info_tbl: [(cbGN6,
                       label: sat_sbGED_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGN6: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Fix.$fMonadFixRec2_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGEC_entry() //  [R1]
         { info_tbl: [(cbGNd,
                       label: sat_sbGEC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGNd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbGNe; else goto cbGNf;
       cbGNe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGNf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixRec1_entry() //  [R2]
         { info_tbl: [(cbGNh,
                       label: Control.Monad.Fix.$fMonadFixRec1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGNh: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbGNl; else goto cbGNk;
       cbGNl: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixRec1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGNk: // global
           I64[Hp - 56] = sat_sbGED_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbGEC_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.225135529 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixM2_closure" {
     Control.Monad.Fix.$fMonadFixM2_closure:
         const Control.Monad.Fix.$fMonadFixM2_info;
 },
 sat_sbGEH_entry() //  [R1, R2]
         { info_tbl: [(cbGNv,
                       label: sat_sbGEH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGNv: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.Fix.$fMonadFixM2_entry() //  [R2, R3]
         { info_tbl: [(cbGNy,
                       label: Control.Monad.Fix.$fMonadFixM2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGNy: // global
           _sbGEF::P64 = R3;
           _sbGEE::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGNz; else goto cbGNA;
       cbGNA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbGNC; else goto cbGNB;
       cbGNC: // global
           HpAlloc = 16;
           goto cbGNz;
       cbGNz: // global
           R3 = _sbGEF::P64;
           R2 = _sbGEE::P64;
           R1 = Control.Monad.Fix.$fMonadFixM2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbGNB: // global
           I64[Hp - 8] = sat_sbGEH_info;
           P64[Hp] = _sbGEF::P64;
           R2 = _sbGEE::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.mfix_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.226584813 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_closure" {
     Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_closure:
         const Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_info;
 },
 sat_sbGEJ_entry() //  [R1]
         { info_tbl: [(cbGNL,
                       label: sat_sbGEJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGNL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbGNM; else goto cbGNN;
       cbGNM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGNN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_entry() //  [R2]
         { info_tbl: [(cbGNO,
                       label: Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGNO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGNS; else goto cbGNR;
       cbGNS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGNR: // global
           I64[Hp - 16] = sat_sbGEJ_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.228069375 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixM1_closure" {
     Control.Monad.Fix.$fMonadFixM1_closure:
         const Control.Monad.Fix.$fMonadFixM1_info;
 },
 sat_sbGEM_entry() //  [R1, R2]
         { info_tbl: [(cbGO2,
                       label: sat_sbGEM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGO2: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Fix.$fMonadFixM2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGEL_entry() //  [R1]
         { info_tbl: [(cbGO9,
                       label: sat_sbGEL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGO9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbGOa; else goto cbGOb;
       cbGOa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGOb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixM1_entry() //  [R2]
         { info_tbl: [(cbGOd,
                       label: Control.Monad.Fix.$fMonadFixM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGOd: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbGOh; else goto cbGOg;
       cbGOh: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGOg: // global
           I64[Hp - 56] = sat_sbGEM_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbGEL_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.231725829 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix:*:_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFix:*:_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFix:*:_$cmfix_info;
 },
 sat_sbGF0_entry() //  [R1, R2]
         { info_tbl: [(cbGOx,
                       label: sat_sbGF0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGOx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbGOy; else goto cbGOz;
       cbGOy: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGOz: // global
           I64[Sp - 8] = block_cbGOv_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbGOv() //  [R1]
         { info_tbl: [(cbGOv,
                       label: block_cbGOv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGOv: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGF1_entry() //  [R1]
         { info_tbl: [(cbGOD,
                       label: sat_sbGF1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGOD: // global
           _sbGF1::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbGOE; else goto cbGOF;
       cbGOF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbGOH; else goto cbGOG;
       cbGOH: // global
           HpAlloc = 16;
           goto cbGOE;
       cbGOE: // global
           R1 = _sbGF1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGOG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGF1::P64;
           _sbGEO::P64 = P64[_sbGF1::P64 + 16];
           _sbGEP::P64 = P64[_sbGF1::P64 + 24];
           I64[Hp - 8] = sat_sbGF0_info;
           P64[Hp] = _sbGEP::P64;
           R2 = _sbGEO::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbGEU_entry() //  [R1, R2]
         { info_tbl: [(cbGOT,
                       label: sat_sbGEU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGOT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbGOU; else goto cbGOV;
       cbGOU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGOV: // global
           I64[Sp - 8] = block_cbGOR_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbGOR() //  [R1]
         { info_tbl: [(cbGOR,
                       label: block_cbGOR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGOR: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGEV_entry() //  [R1]
         { info_tbl: [(cbGOZ,
                       label: sat_sbGEV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGOZ: // global
           _sbGEV::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbGP0; else goto cbGP1;
       cbGP1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbGP3; else goto cbGP2;
       cbGP3: // global
           HpAlloc = 16;
           goto cbGP0;
       cbGP0: // global
           R1 = _sbGEV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGP2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGEV::P64;
           _sbGEN::P64 = P64[_sbGEV::P64 + 16];
           _sbGEP::P64 = P64[_sbGEV::P64 + 24];
           I64[Hp - 8] = sat_sbGEU_info;
           P64[Hp] = _sbGEP::P64;
           R2 = _sbGEN::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFix:*:_$cmfix_entry() //  [R2, R3, R4]
         { info_tbl: [(cbGP5,
                       label: Control.Monad.Fix.$fMonadFix:*:_$cmfix_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGP5: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbGP9; else goto cbGP8;
       cbGP9: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFix:*:_$cmfix_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbGP8: // global
           I64[Hp - 80] = sat_sbGF1_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sbGEV_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.234330669 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_closure" {
     Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_closure:
         const Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_info;
         const 0;
 },
 sat_sbGF5_entry() //  [R1]
         { info_tbl: [(cbGPi,
                       label: sat_sbGF5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGPi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbGPj; else goto cbGPk;
       cbGPj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGPk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbGF4_entry() //  [R1]
         { info_tbl: [(cbGPp,
                       label: sat_sbGF4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGPp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbGPq; else goto cbGPr;
       cbGPq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGPr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_entry() //  [R2, R3]
         { info_tbl: [(cbGPs,
                       label: Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGPs: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbGPw; else goto cbGPv;
       cbGPw: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbGPv: // global
           I64[Hp - 40] = sat_sbGF5_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbGF4_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fMonad:*:_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.236030512 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix:*:_closure" {
     Control.Monad.Fix.$fMonadFix:*:_closure:
         const Control.Monad.Fix.$fMonadFix:*:_info;
         const 0;
 },
 sat_sbGF9_entry() //  [R1, R2]
         { info_tbl: [(cbGPG,
                       label: sat_sbGF9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGPG: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Monad.Fix.$fMonadFix:*:_$cmfix_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGF8_entry() //  [R1]
         { info_tbl: [(cbGPN,
                       label: sat_sbGF8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGPN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbGPO; else goto cbGPP;
       cbGPO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGPP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_entry(R3,
                                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFix:*:_entry() //  [R2, R3]
         { info_tbl: [(cbGPR,
                       label: Control.Monad.Fix.$fMonadFix:*:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGPR: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbGPV; else goto cbGPU;
       cbGPV: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFix:*:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbGPU: // global
           I64[Hp - 72] = sat_sbGF9_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sbGF8_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 71;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.237339285 UTC

[section ""cstring" . Control.Monad.Fix.$trModule4_bytes" {
     Control.Monad.Fix.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.237876845 UTC

[section ""data" . Control.Monad.Fix.$trModule3_closure" {
     Control.Monad.Fix.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Fix.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.238442791 UTC

[section ""cstring" . Control.Monad.Fix.$trModule2_bytes" {
     Control.Monad.Fix.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100,46,70,105,120]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.238981226 UTC

[section ""data" . Control.Monad.Fix.$trModule1_closure" {
     Control.Monad.Fix.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Fix.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.239547472 UTC

[section ""data" . Control.Monad.Fix.$trModule_closure" {
     Control.Monad.Fix.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.Fix.$trModule3_closure+1;
         const Control.Monad.Fix.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.24010556 UTC

[section ""data" . $krep_rbGDc_closure" {
     $krep_rbGDc_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.240638173 UTC

[section ""data" . Control.Monad.Fix.$tcMonadFix1_closure" {
     Control.Monad.Fix.$tcMonadFix1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep_rbGDc_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.241234501 UTC

[section ""cstring" . Control.Monad.Fix.$tcMonadFix3_bytes" {
     Control.Monad.Fix.$tcMonadFix3_bytes:
         I8[] [77,111,110,97,100,70,105,120]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.242140852 UTC

[section ""data" . Control.Monad.Fix.$tcMonadFix2_closure" {
     Control.Monad.Fix.$tcMonadFix2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Fix.$tcMonadFix3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.242708327 UTC

[section ""data" . Control.Monad.Fix.$tcMonadFix_closure" {
     Control.Monad.Fix.$tcMonadFix_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.Fix.$trModule_closure+1;
         const Control.Monad.Fix.$tcMonadFix2_closure+1;
         const Control.Monad.Fix.$tcMonadFix1_closure+4;
         const 9994897379720692231;
         const 15179622530544898162;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.243495609 UTC

[section ""data" . Control.Monad.Fix.C:MonadFix_closure" {
     Control.Monad.Fix.C:MonadFix_closure:
         const Control.Monad.Fix.C:MonadFix_info;
 },
 Control.Monad.Fix.C:MonadFix_entry() //  [R2, R3]
         { info_tbl: [(cbGQ1,
                       label: Control.Monad.Fix.C:MonadFix_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGQ1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGQ5; else goto cbGQ4;
       cbGQ5: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.C:MonadFix_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbGQ4: // global
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.244381664 UTC

[Control.Monad.Fix.C:MonadFix_con_entry() //  [R1]
         { info_tbl: [(cbGQ6,
                       label: Control.Monad.Fix.C:MonadFix_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,77,111,110,97,100,46,70,105,120,46,67,58,77,111,110,97,100,70,105,120]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGQ6: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.245039072 UTC

[section ""relreadonly" . SbGFQ_srt" {
     SbGFQ_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Control.Monad.Fix.$fMonadFixFirst1_closure;
         const Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure;
         const GHC.List.head_closure;
         const GHC.List.scanl2_closure;
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure;
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure;
         const Control.Monad.Fix.$fMonadFixEither1_closure;
         const Control.Monad.Fix.$fMonadFixEither_$cmfix_closure;
         const Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure;
         const Control.Monad.Fix.$fMonadFixLast_$cmfix_closure;
         const GHC.Generics.$fMonadRec1_closure;
         const Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_closure;
         const Control.Monad.Fix.$fMonadFixRec1_closure;
         const GHC.Generics.$fMonad:*:_closure;
         const Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_closure;
         const Control.Monad.Fix.$fMonadFix:*:_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.245704583 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:34.246439695 UTC

[section ""data" . Control.Monad.Fix.$p1MonadFix_closure" {
     Control.Monad.Fix.$p1MonadFix_closure:
         const Control.Monad.Fix.$p1MonadFix_info;
 },
 Control.Monad.Fix.$p1MonadFix_entry() //  [R2]
         { info_tbl: [(cbGQe,
                       label: Control.Monad.Fix.$p1MonadFix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGQe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbGQf; else goto cbGQg;
       cbGQf: // global
           R2 = R2;
           R1 = Control.Monad.Fix.$p1MonadFix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGQg: // global
           I64[Sp - 8] = block_cbGQb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubGQk; else goto cbGQc;
       ubGQk: // global
           call _cbGQb(R1) args: 0, res: 0, upd: 0;
       cbGQc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbGQb() //  [R1]
         { info_tbl: [(cbGQb,
                       label: block_cbGQb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGQb: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.247563037 UTC

[section ""data" . Control.Monad.Fix.mfix_closure" {
     Control.Monad.Fix.mfix_closure:
         const Control.Monad.Fix.mfix_info;
 },
 Control.Monad.Fix.mfix_entry() //  [R2]
         { info_tbl: [(cbGQs,
                       label: Control.Monad.Fix.mfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGQs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbGQt; else goto cbGQu;
       cbGQt: // global
           R2 = R2;
           R1 = Control.Monad.Fix.mfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGQu: // global
           I64[Sp - 8] = block_cbGQp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubGQy; else goto cbGQq;
       ubGQy: // global
           call _cbGQp(R1) args: 0, res: 0, upd: 0;
       cbGQq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbGQp() //  [R1]
         { info_tbl: [(cbGQp,
                       label: block_cbGQp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGQp: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.248498991 UTC

[section ""cstring" . lvl_rbGDa_bytes" {
     lvl_rbGDa_bytes:
         I8[] [109,102,105,120,32,77,97,121,98,101,58,32,78,111,116,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.249366661 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixFirst1_closure" {
     Control.Monad.Fix.$fMonadFixFirst1_closure:
         const Control.Monad.Fix.$fMonadFixFirst1_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Monad.Fix.$fMonadFixFirst1_entry() //  [R1]
         { info_tbl: [(cbGQH,
                       label: Control.Monad.Fix.$fMonadFixFirst1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGQH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbGQI; else goto cbGQJ;
       cbGQI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGQJ: // global
           (_cbGQC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbGQC::I64 == 0) goto cbGQE; else goto cbGQD;
       cbGQE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbGQD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbGQC::I64;
           I64[Sp - 24] = block_cbGQF_info;
           R2 = lvl_rbGDa_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbGQF() //  [R1]
         { info_tbl: [(cbGQF,
                       label: block_cbGQF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGQF: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.250951516 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixMaybe_$cmfix_info;
         const 0;
 },
 sat_sbGDr_entry() //  [R1]
         { info_tbl: [(cbGR6,
                       label: sat_sbGDr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGR6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbGR7; else goto cbGR8;
       cbGR7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGR8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbGQZ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubGRf; else goto cbGR0;
       ubGRf: // global
           call _cbGQZ(R1) args: 0, res: 0, upd: 0;
       cbGR0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbGQZ() //  [R1]
         { info_tbl: [(cbGQZ,
                       label: block_cbGQZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGQZ: // global
           if (R1 & 7 == 1) goto cbGR3; else goto cbGR4;
       cbGR3: // global
           R1 = Control.Monad.Fix.$fMonadFixFirst1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cbGR4: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 a1_sbGDo_entry() //  [R1]
         { info_tbl: [(cbGRg,
                       label: a1_sbGDo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGRg: // global
           _sbGDo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGRh; else goto cbGRi;
       cbGRi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGRk; else goto cbGRj;
       cbGRk: // global
           HpAlloc = 24;
           goto cbGRh;
       cbGRh: // global
           R1 = _sbGDo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGRj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDo::P64;
           _sbGDn::P64 = P64[_sbGDo::P64 + 16];
           I64[Hp - 16] = sat_sbGDr_info;
           P64[Hp] = _sbGDo::P64;
           R2 = Hp - 16;
           R1 = _sbGDn::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixMaybe_$cmfix_entry() //  [R2]
         { info_tbl: [(cbGRl,
                       label: Control.Monad.Fix.$fMonadFixMaybe_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGRl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGRp; else goto cbGRo;
       cbGRp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGRo: // global
           I64[Hp - 16] = a1_sbGDo_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.252532537 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixMaybe_closure" {
     Control.Monad.Fix.$fMonadFixMaybe_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonadMaybe_closure;
         const Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.254243615 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure" {
     Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure:
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_info;
         const 0;
 },
 sat_sbGDu_entry() //  [R1]
         { info_tbl: [(cbGRC,
                       label: sat_sbGDu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGRC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbGRD; else goto cbGRE;
       cbGRD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGRE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.head_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sbGDt_entry() //  [R1]
         { info_tbl: [(cbGRF,
                       label: x_sbGDt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGRF: // global
           _sbGDt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGRG; else goto cbGRH;
       cbGRH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGRJ; else goto cbGRI;
       cbGRJ: // global
           HpAlloc = 24;
           goto cbGRG;
       cbGRG: // global
           R1 = _sbGDt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGRI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDt::P64;
           _sbGDs::P64 = P64[_sbGDt::P64 + 16];
           I64[Hp - 16] = sat_sbGDu_info;
           P64[Hp] = _sbGDt::P64;
           R2 = Hp - 16;
           R1 = _sbGDs::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbGDC_entry() //  [R1, R2]
         { info_tbl: [(cbGS5,
                       label: sat_sbGDC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGS5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbGS6; else goto cbGS7;
       cbGS6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGS7: // global
           I64[Sp - 8] = block_cbGRZ_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbGRZ() //  [R1]
         { info_tbl: [(cbGRZ,
                       label: block_cbGRZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGRZ: // global
           if (R1 & 7 == 1) goto cbGS2; else goto cbGS3;
       cbGS2: // global
           R1 = GHC.List.scanl2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbGS3: // global
           R1 = P64[R1 + 14] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGDD_entry() //  [R1]
         { info_tbl: [(cbGSe,
                       label: sat_sbGDD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGSe: // global
           _sbGDD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGSf; else goto cbGSg;
       cbGSg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbGSi; else goto cbGSh;
       cbGSi: // global
           HpAlloc = 16;
           goto cbGSf;
       cbGSf: // global
           R1 = _sbGDD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGSh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDD::P64;
           _sbGDs::P64 = P64[_sbGDD::P64 + 16];
           I64[Hp - 8] = sat_sbGDC_info;
           P64[Hp] = _sbGDs::P64;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_entry() //  [R2]
         { info_tbl: [(cbGSn,
                       label: Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGSn: // global
           _sbGDs::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGSo; else goto cbGSp;
       cbGSp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGSr; else goto cbGSq;
       cbGSr: // global
           HpAlloc = 24;
           goto cbGSo;
       cbGSo: // global
           R2 = _sbGDs::P64;
           R1 = Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGSq: // global
           I64[Hp - 16] = x_sbGDt_info;
           P64[Hp] = _sbGDs::P64;
           I64[Sp - 16] = block_cbGRK_info;
           R1 = Hp - 16;
           P64[Sp - 8] = _sbGDs::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubGSy; else goto cbGRL;
       ubGSy: // global
           call _cbGRK(R1) args: 0, res: 0, upd: 0;
       cbGRL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbGRK() //  [R1]
         { info_tbl: [(cbGRK,
                       label: block_cbGRK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGRK: // global
           if (R1 & 7 == 1) goto cbGSk; else goto cbGSl;
       cbGSk: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbGSl: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbGSx; else goto cbGSw;
       cbGSx: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbGSw: // global
           _sbGDw::P64 = P64[R1 + 6];
           I64[Hp - 40] = sat_sbGDD_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sbGDw::P64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.256730113 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix[]_closure" {
     Control.Monad.Fix.$fMonadFix[]_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonad[]_closure;
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.25857067 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_info;
         const 0;
 },
 sat_sbGDS_entry() //  [R1, R2]
         { info_tbl: [(cbGSO,
                       label: sat_sbGDS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGSO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbGSP; else goto cbGSQ;
       cbGSP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGSQ: // global
           I64[Sp - 8] = block_cbGSM_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbGSM() //  [R1]
         { info_tbl: [(cbGSM,
                       label: block_cbGSM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGSM: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGDT_entry() //  [R1]
         { info_tbl: [(cbGSU,
                       label: sat_sbGDT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGSU: // global
           _sbGDT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGSV; else goto cbGSW;
       cbGSW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbGSY; else goto cbGSX;
       cbGSY: // global
           HpAlloc = 16;
           goto cbGSV;
       cbGSV: // global
           R1 = _sbGDT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGSX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDT::P64;
           _sbGDE::P64 = P64[_sbGDT::P64 + 16];
           I64[Hp - 8] = sat_sbGDS_info;
           P64[Hp] = _sbGDE::P64;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sbGDF_entry() //  [R1]
         { info_tbl: [(cbGT8,
                       label: x_sbGDF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGT8: // global
           _sbGDF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGT9; else goto cbGTa;
       cbGTa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGTc; else goto cbGTb;
       cbGTc: // global
           HpAlloc = 24;
           goto cbGT9;
       cbGT9: // global
           R1 = _sbGDF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGTb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDF::P64;
           _sbGDE::P64 = P64[_sbGDF::P64 + 16];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbGDF::P64;
           R2 = Hp - 16;
           R1 = _sbGDE::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbGDN_entry() //  [R1]
         { info_tbl: [(cbGTg,
                       label: sat_sbGDN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGTg: // global
           _sbGDN::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbGTh; else goto cbGTi;
       cbGTi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGTk; else goto cbGTj;
       cbGTk: // global
           HpAlloc = 24;
           goto cbGTh;
       cbGTh: // global
           R1 = _sbGDN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGTj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDN::P64;
           _sbGDE::P64 = P64[_sbGDN::P64 + 16];
           I64[Hp - 16] = x_sbGDF_info;
           P64[Hp] = _sbGDE::P64;
           I64[Sp - 24] = block_cbGTd_info;
           R1 = Hp - 16;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubGTo; else goto cbGTe;
       ubGTo: // global
           call _cbGTd(R1) args: 0, res: 0, upd: 0;
       cbGTe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbGTd() //  [R1]
         { info_tbl: [(cbGTd,
                       label: block_cbGTd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGTd: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_entry() //  [R2]
         { info_tbl: [(cbGTq,
                       label: Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGTq: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbGTu; else goto cbGTt;
       cbGTu: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGTt: // global
           I64[Hp - 64] = sat_sbGDT_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbGDN_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.260860055 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixNonEmpty_closure" {
     Control.Monad.Fix.$fMonadFixNonEmpty_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonadNonEmpty_closure;
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.2614315 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixIO_closure" {
     Control.Monad.Fix.$fMonadFixIO_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonadIO_closure;
         const System.IO.fixIO1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.262155244 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix(->)_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFix(->)_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFix(->)_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFix(->)_$cmfix_entry() //  [R2, R3]
         { info_tbl: [(cbGTA,
                       label: Control.Monad.Fix.$fMonadFix(->)_$cmfix_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGTA: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbGTE; else goto cbGTD;
       cbGTE: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFix(->)_$cmfix_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbGTD: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R2;
           _cbGTz::P64 = Hp - 32;
           P64[Hp - 8] = _cbGTz::P64;
           P64[Hp] = R3;
           R1 = _cbGTz::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.262973774 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix(->)_closure" {
     Control.Monad.Fix.$fMonadFix(->)_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonad(->)_closure;
         const Control.Monad.Fix.$fMonadFix(->)_$cmfix_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.263578512 UTC

[section ""cstring" . lvl1_rbGDb_bytes" {
     lvl1_rbGDb_bytes:
         I8[] [109,102,105,120,32,69,105,116,104,101,114,58,32,76,101,102,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.264349099 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixEither1_closure" {
     Control.Monad.Fix.$fMonadFixEither1_closure:
         const Control.Monad.Fix.$fMonadFixEither1_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Monad.Fix.$fMonadFixEither1_entry() //  [R1]
         { info_tbl: [(cbGTN,
                       label: Control.Monad.Fix.$fMonadFixEither1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGTN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbGTO; else goto cbGTP;
       cbGTO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGTP: // global
           (_cbGTI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbGTI::I64 == 0) goto cbGTK; else goto cbGTJ;
       cbGTK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbGTJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbGTI::I64;
           I64[Sp - 24] = block_cbGTL_info;
           R2 = lvl1_rbGDb_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbGTL() //  [R1]
         { info_tbl: [(cbGTL,
                       label: block_cbGTL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGTL: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.265962946 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixEither_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixEither_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixEither_$cmfix_info;
         const 0;
 },
 sat_sbGE3_entry() //  [R1]
         { info_tbl: [(cbGUc,
                       label: sat_sbGE3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGUc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbGUd; else goto cbGUe;
       cbGUd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGUe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbGU5_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubGUl; else goto cbGU6;
       ubGUl: // global
           call _cbGU5(R1) args: 0, res: 0, upd: 0;
       cbGU6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbGU5() //  [R1]
         { info_tbl: [(cbGU5,
                       label: block_cbGU5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGU5: // global
           if (R1 & 7 == 1) goto cbGU9; else goto cbGUa;
       cbGU9: // global
           R1 = Control.Monad.Fix.$fMonadFixEither1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cbGUa: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 a1_sbGDZ_entry() //  [R1]
         { info_tbl: [(cbGUm,
                       label: a1_sbGDZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGUm: // global
           _sbGDZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGUn; else goto cbGUo;
       cbGUo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGUq; else goto cbGUp;
       cbGUq: // global
           HpAlloc = 24;
           goto cbGUn;
       cbGUn: // global
           R1 = _sbGDZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGUp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDZ::P64;
           _sbGDY::P64 = P64[_sbGDZ::P64 + 16];
           I64[Hp - 16] = sat_sbGE3_info;
           P64[Hp] = _sbGDZ::P64;
           R2 = Hp - 16;
           R1 = _sbGDY::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixEither_$cmfix_entry() //  [R2]
         { info_tbl: [(cbGUr,
                       label: Control.Monad.Fix.$fMonadFixEither_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGUr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGUv; else goto cbGUu;
       cbGUv: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixEither_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGUu: // global
           I64[Hp - 16] = a1_sbGDZ_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.267543812 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixEither_closure" {
     Control.Monad.Fix.$fMonadFixEither_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Either.$fMonadEither_closure;
         const Control.Monad.Fix.$fMonadFixEither_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.268114606 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixST_closure" {
     Control.Monad.Fix.$fMonadFixST_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.ST.$fMonadST_closure;
         const GHC.ST.fixST1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.268855501 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixDual_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixDual_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixDual_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFixDual_$cmfix_entry() //  [R2]
         { info_tbl: [(cbGUB,
                       label: Control.Monad.Fix.$fMonadFixDual_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGUB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbGUF; else goto cbGUE;
       cbGUF: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixDual_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGUE: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbGUA::P64 = Hp - 24;
           P64[Hp] = _cbGUA::P64;
           R1 = _cbGUA::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.27007238 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixDual_closure" {
     Control.Monad.Fix.$fMonadFixDual_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Semigroup.Internal.$fMonadDual_closure;
         const Control.Monad.Fix.$fMonadFixDual_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.270798784 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixSum_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixSum_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixSum_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFixSum_$cmfix_entry() //  [R2]
         { info_tbl: [(cbGUL,
                       label: Control.Monad.Fix.$fMonadFixSum_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGUL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbGUP; else goto cbGUO;
       cbGUP: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixSum_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGUO: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbGUK::P64 = Hp - 24;
           P64[Hp] = _cbGUK::P64;
           R1 = _cbGUK::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.27160973 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixSum_closure" {
     Control.Monad.Fix.$fMonadFixSum_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Semigroup.Internal.$fMonadSum_closure;
         const Control.Monad.Fix.$fMonadFixSum_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.272338809 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixProduct_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixProduct_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixProduct_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFixProduct_$cmfix_entry() //  [R2]
         { info_tbl: [(cbGUV,
                       label: Control.Monad.Fix.$fMonadFixProduct_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGUV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbGUZ; else goto cbGUY;
       cbGUZ: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixProduct_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGUY: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbGUU::P64 = Hp - 24;
           P64[Hp] = _cbGUU::P64;
           R1 = _cbGUU::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.273168718 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixProduct_closure" {
     Control.Monad.Fix.$fMonadFixProduct_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Semigroup.Internal.$fMonadProduct_closure;
         const Control.Monad.Fix.$fMonadFixProduct_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.274342337 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixFirst_$cmfix_info;
         const 0;
 },
 sat_sbGEe_entry() //  [R1]
         { info_tbl: [(cbGVj,
                       label: sat_sbGEe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGVj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbGVk; else goto cbGVl;
       cbGVk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGVl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbGVc_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubGVs; else goto cbGVd;
       ubGVs: // global
           call _cbGVc(R1) args: 0, res: 0, upd: 0;
       cbGVd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbGVc() //  [R1]
         { info_tbl: [(cbGVc,
                       label: block_cbGVc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGVc: // global
           if (R1 & 7 == 1) goto cbGVg; else goto cbGVh;
       cbGVg: // global
           R1 = Control.Monad.Fix.$fMonadFixFirst1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cbGVh: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 a1_sbGEb_entry() //  [R1]
         { info_tbl: [(cbGVt,
                       label: a1_sbGEb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGVt: // global
           _sbGEb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGVu; else goto cbGVv;
       cbGVv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGVx; else goto cbGVw;
       cbGVx: // global
           HpAlloc = 24;
           goto cbGVu;
       cbGVu: // global
           R1 = _sbGEb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGVw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGEb::P64;
           _sbGEa::P64 = P64[_sbGEb::P64 + 16];
           I64[Hp - 16] = sat_sbGEe_info;
           P64[Hp] = _sbGEb::P64;
           R2 = Hp - 16;
           R1 = _sbGEa::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixFirst_$cmfix_entry() //  [R2]
         { info_tbl: [(cbGVy,
                       label: Control.Monad.Fix.$fMonadFixFirst_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGVy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGVC; else goto cbGVB;
       cbGVC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGVB: // global
           I64[Hp - 16] = a1_sbGEb_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.277531535 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixFirst_closure" {
     Control.Monad.Fix.$fMonadFixFirst_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Monoid.$fMonadFirst_closure;
         const Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.278643771 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixLast_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixLast_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixLast_$cmfix_info;
         const 0;
 },
 sat_sbGEj_entry() //  [R1]
         { info_tbl: [(cbGVW,
                       label: sat_sbGEj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGVW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbGVX; else goto cbGVY;
       cbGVX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGVY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbGVP_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubGW5; else goto cbGVQ;
       ubGW5: // global
           call _cbGVP(R1) args: 0, res: 0, upd: 0;
       cbGVQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbGVP() //  [R1]
         { info_tbl: [(cbGVP,
                       label: block_cbGVP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGVP: // global
           if (R1 & 7 == 1) goto cbGVT; else goto cbGVU;
       cbGVT: // global
           R1 = Control.Monad.Fix.$fMonadFixFirst1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cbGVU: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 a1_sbGEg_entry() //  [R1]
         { info_tbl: [(cbGW6,
                       label: a1_sbGEg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGW6: // global
           _sbGEg::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGW7; else goto cbGW8;
       cbGW8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGWa; else goto cbGW9;
       cbGWa: // global
           HpAlloc = 24;
           goto cbGW7;
       cbGW7: // global
           R1 = _sbGEg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGW9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGEg::P64;
           _sbGEf::P64 = P64[_sbGEg::P64 + 16];
           I64[Hp - 16] = sat_sbGEj_info;
           P64[Hp] = _sbGEg::P64;
           R2 = Hp - 16;
           R1 = _sbGEf::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixLast_$cmfix_entry() //  [R2]
         { info_tbl: [(cbGWb,
                       label: Control.Monad.Fix.$fMonadFixLast_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGWb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGWf; else goto cbGWe;
       cbGWf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixLast_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGWe: // global
           I64[Hp - 16] = a1_sbGEg_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.28022066 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixLast_closure" {
     Control.Monad.Fix.$fMonadFixLast_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Monoid.$fMonadLast_closure;
         const Control.Monad.Fix.$fMonadFixLast_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.28104637 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixAlt1_closure" {
     Control.Monad.Fix.$fMonadFixAlt1_closure:
         const Control.Monad.Fix.$fMonadFixAlt1_info;
 },
 sat_sbGEn_entry() //  [R1, R2]
         { info_tbl: [(cbGWp,
                       label: sat_sbGEn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGWp: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.Fix.$fMonadFixAlt1_entry() //  [R2, R3]
         { info_tbl: [(cbGWs,
                       label: Control.Monad.Fix.$fMonadFixAlt1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGWs: // global
           _sbGEl::P64 = R3;
           _sbGEk::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGWt; else goto cbGWu;
       cbGWu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbGWw; else goto cbGWv;
       cbGWw: // global
           HpAlloc = 16;
           goto cbGWt;
       cbGWt: // global
           R3 = _sbGEl::P64;
           R2 = _sbGEk::P64;
           R1 = Control.Monad.Fix.$fMonadFixAlt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbGWv: // global
           I64[Hp - 8] = sat_sbGEn_info;
           P64[Hp] = _sbGEl::P64;
           R2 = _sbGEk::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.mfix_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.282649449 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_closure" {
     Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_closure:
         const Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_info;
 },
 sat_sbGEp_entry() //  [R1]
         { info_tbl: [(cbGWF,
                       label: sat_sbGEp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGWF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbGWG; else goto cbGWH;
       cbGWG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGWH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_entry() //  [R2]
         { info_tbl: [(cbGWI,
                       label: Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGWI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGWM; else goto cbGWL;
       cbGWM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGWL: // global
           I64[Hp - 16] = sat_sbGEp_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fMonadAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.28401857 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixAlt_closure" {
     Control.Monad.Fix.$fMonadFixAlt_closure:
         const Control.Monad.Fix.$fMonadFixAlt_info;
 },
 sat_sbGEs_entry() //  [R1, R2]
         { info_tbl: [(cbGWW,
                       label: sat_sbGEs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGWW: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Fix.$fMonadFixAlt1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGEr_entry() //  [R1]
         { info_tbl: [(cbGX3,
                       label: sat_sbGEr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGX3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbGX4; else goto cbGX5;
       cbGX4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGX5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixAlt_entry() //  [R2]
         { info_tbl: [(cbGX7,
                       label: Control.Monad.Fix.$fMonadFixAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGX7: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbGXb; else goto cbGXa;
       cbGXb: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGXa: // global
           I64[Hp - 56] = sat_sbGEs_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbGEr_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.285452898 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixPar1_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixPar1_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixPar1_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFixPar1_$cmfix_entry() //  [R2]
         { info_tbl: [(cbGXh,
                       label: Control.Monad.Fix.$fMonadFixPar1_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGXh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbGXl; else goto cbGXk;
       cbGXl: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixPar1_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGXk: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbGXg::P64 = Hp - 24;
           P64[Hp] = _cbGXg::P64;
           R1 = _cbGXg::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.286267559 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixPar1_closure" {
     Control.Monad.Fix.$fMonadFixPar1_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Generics.$fMonadPar1_closure;
         const Control.Monad.Fix.$fMonadFixPar1_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.287100369 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixRec2_closure" {
     Control.Monad.Fix.$fMonadFixRec2_closure:
         const Control.Monad.Fix.$fMonadFixRec2_info;
 },
 sat_sbGEy_entry() //  [R1, R2]
         { info_tbl: [(cbGXv,
                       label: sat_sbGEy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGXv: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.Fix.$fMonadFixRec2_entry() //  [R2, R3]
         { info_tbl: [(cbGXy,
                       label: Control.Monad.Fix.$fMonadFixRec2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGXy: // global
           _sbGEw::P64 = R3;
           _sbGEv::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGXz; else goto cbGXA;
       cbGXA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbGXC; else goto cbGXB;
       cbGXC: // global
           HpAlloc = 16;
           goto cbGXz;
       cbGXz: // global
           R3 = _sbGEw::P64;
           R2 = _sbGEv::P64;
           R1 = Control.Monad.Fix.$fMonadFixRec2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbGXB: // global
           I64[Hp - 8] = sat_sbGEy_info;
           P64[Hp] = _sbGEw::P64;
           R2 = _sbGEv::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.mfix_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.288439129 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_closure" {
     Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_closure:
         const Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_info;
         const 0;
 },
 sat_sbGEA_entry() //  [R1]
         { info_tbl: [(cbGXL,
                       label: sat_sbGEA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGXL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbGXM; else goto cbGXN;
       cbGXM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGXN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_entry() //  [R2]
         { info_tbl: [(cbGXO,
                       label: Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGXO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGXS; else goto cbGXR;
       cbGXS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGXR: // global
           I64[Hp - 16] = sat_sbGEA_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadRec1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.289935394 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixRec1_closure" {
     Control.Monad.Fix.$fMonadFixRec1_closure:
         const Control.Monad.Fix.$fMonadFixRec1_info;
         const 0;
 },
 sat_sbGED_entry() //  [R1, R2]
         { info_tbl: [(cbGY2,
                       label: sat_sbGED_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGY2: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Fix.$fMonadFixRec2_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGEC_entry() //  [R1]
         { info_tbl: [(cbGY9,
                       label: sat_sbGEC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGY9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbGYa; else goto cbGYb;
       cbGYa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGYb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixRec1_entry() //  [R2]
         { info_tbl: [(cbGYd,
                       label: Control.Monad.Fix.$fMonadFixRec1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGYd: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbGYh; else goto cbGYg;
       cbGYh: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixRec1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGYg: // global
           I64[Hp - 56] = sat_sbGED_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbGEC_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.291442754 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixM2_closure" {
     Control.Monad.Fix.$fMonadFixM2_closure:
         const Control.Monad.Fix.$fMonadFixM2_info;
 },
 sat_sbGEH_entry() //  [R1, R2]
         { info_tbl: [(cbGYr,
                       label: sat_sbGEH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGYr: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.Fix.$fMonadFixM2_entry() //  [R2, R3]
         { info_tbl: [(cbGYu,
                       label: Control.Monad.Fix.$fMonadFixM2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGYu: // global
           _sbGEF::P64 = R3;
           _sbGEE::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGYv; else goto cbGYw;
       cbGYw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbGYy; else goto cbGYx;
       cbGYy: // global
           HpAlloc = 16;
           goto cbGYv;
       cbGYv: // global
           R3 = _sbGEF::P64;
           R2 = _sbGEE::P64;
           R1 = Control.Monad.Fix.$fMonadFixM2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbGYx: // global
           I64[Hp - 8] = sat_sbGEH_info;
           P64[Hp] = _sbGEF::P64;
           R2 = _sbGEE::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.mfix_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.29273611 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_closure" {
     Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_closure:
         const Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_info;
 },
 sat_sbGEJ_entry() //  [R1]
         { info_tbl: [(cbGYH,
                       label: sat_sbGEJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGYH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbGYI; else goto cbGYJ;
       cbGYI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGYJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_entry() //  [R2]
         { info_tbl: [(cbGYK,
                       label: Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGYK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGYO; else goto cbGYN;
       cbGYO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGYN: // global
           I64[Hp - 16] = sat_sbGEJ_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.294201218 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixM1_closure" {
     Control.Monad.Fix.$fMonadFixM1_closure:
         const Control.Monad.Fix.$fMonadFixM1_info;
 },
 sat_sbGEM_entry() //  [R1, R2]
         { info_tbl: [(cbGYY,
                       label: sat_sbGEM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGYY: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Fix.$fMonadFixM2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGEL_entry() //  [R1]
         { info_tbl: [(cbGZ5,
                       label: sat_sbGEL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGZ5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbGZ6; else goto cbGZ7;
       cbGZ6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGZ7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixM1_entry() //  [R2]
         { info_tbl: [(cbGZ9,
                       label: Control.Monad.Fix.$fMonadFixM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGZ9: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbGZd; else goto cbGZc;
       cbGZd: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGZc: // global
           I64[Hp - 56] = sat_sbGEM_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbGEL_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.296291803 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix:*:_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFix:*:_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFix:*:_$cmfix_info;
 },
 sat_sbGF0_entry() //  [R1, R2]
         { info_tbl: [(cbGZt,
                       label: sat_sbGF0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGZt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbGZu; else goto cbGZv;
       cbGZu: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGZv: // global
           I64[Sp - 8] = block_cbGZr_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbGZr() //  [R1]
         { info_tbl: [(cbGZr,
                       label: block_cbGZr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGZr: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGF1_entry() //  [R1]
         { info_tbl: [(cbGZz,
                       label: sat_sbGF1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGZz: // global
           _sbGF1::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbGZA; else goto cbGZB;
       cbGZB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbGZD; else goto cbGZC;
       cbGZD: // global
           HpAlloc = 16;
           goto cbGZA;
       cbGZA: // global
           R1 = _sbGF1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGZC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGF1::P64;
           _sbGEO::P64 = P64[_sbGF1::P64 + 16];
           _sbGEP::P64 = P64[_sbGF1::P64 + 24];
           I64[Hp - 8] = sat_sbGF0_info;
           P64[Hp] = _sbGEP::P64;
           R2 = _sbGEO::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbGEU_entry() //  [R1, R2]
         { info_tbl: [(cbGZP,
                       label: sat_sbGEU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGZP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbGZQ; else goto cbGZR;
       cbGZQ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGZR: // global
           I64[Sp - 8] = block_cbGZN_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbGZN() //  [R1]
         { info_tbl: [(cbGZN,
                       label: block_cbGZN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGZN: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGEV_entry() //  [R1]
         { info_tbl: [(cbGZV,
                       label: sat_sbGEV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGZV: // global
           _sbGEV::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbGZW; else goto cbGZX;
       cbGZX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbGZZ; else goto cbGZY;
       cbGZZ: // global
           HpAlloc = 16;
           goto cbGZW;
       cbGZW: // global
           R1 = _sbGEV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGZY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGEV::P64;
           _sbGEN::P64 = P64[_sbGEV::P64 + 16];
           _sbGEP::P64 = P64[_sbGEV::P64 + 24];
           I64[Hp - 8] = sat_sbGEU_info;
           P64[Hp] = _sbGEP::P64;
           R2 = _sbGEN::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFix:*:_$cmfix_entry() //  [R2, R3, R4]
         { info_tbl: [(cbH01,
                       label: Control.Monad.Fix.$fMonadFix:*:_$cmfix_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH01: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbH05; else goto cbH04;
       cbH05: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFix:*:_$cmfix_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbH04: // global
           I64[Hp - 80] = sat_sbGF1_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sbGEV_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.298977227 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_closure" {
     Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_closure:
         const Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_info;
         const 0;
 },
 sat_sbGF5_entry() //  [R1]
         { info_tbl: [(cbH0e,
                       label: sat_sbGF5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH0e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbH0f; else goto cbH0g;
       cbH0f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbH0g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbGF4_entry() //  [R1]
         { info_tbl: [(cbH0l,
                       label: sat_sbGF4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH0l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbH0m; else goto cbH0n;
       cbH0m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbH0n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_entry() //  [R2, R3]
         { info_tbl: [(cbH0o,
                       label: Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH0o: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbH0s; else goto cbH0r;
       cbH0s: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbH0r: // global
           I64[Hp - 40] = sat_sbGF5_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbGF4_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fMonad:*:_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.300645269 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix:*:_closure" {
     Control.Monad.Fix.$fMonadFix:*:_closure:
         const Control.Monad.Fix.$fMonadFix:*:_info;
         const 0;
 },
 sat_sbGF9_entry() //  [R1, R2]
         { info_tbl: [(cbH0C,
                       label: sat_sbGF9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH0C: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Monad.Fix.$fMonadFix:*:_$cmfix_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGF8_entry() //  [R1]
         { info_tbl: [(cbH0J,
                       label: sat_sbGF8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH0J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbH0K; else goto cbH0L;
       cbH0K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbH0L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_entry(R3,
                                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFix:*:_entry() //  [R2, R3]
         { info_tbl: [(cbH0N,
                       label: Control.Monad.Fix.$fMonadFix:*:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH0N: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbH0R; else goto cbH0Q;
       cbH0R: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFix:*:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbH0Q: // global
           I64[Hp - 72] = sat_sbGF9_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sbGF8_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 71;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.302041489 UTC

[section ""cstring" . Control.Monad.Fix.$trModule4_bytes" {
     Control.Monad.Fix.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.302613322 UTC

[section ""data" . Control.Monad.Fix.$trModule3_closure" {
     Control.Monad.Fix.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Fix.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.303170291 UTC

[section ""cstring" . Control.Monad.Fix.$trModule2_bytes" {
     Control.Monad.Fix.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100,46,70,105,120]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.303721467 UTC

[section ""data" . Control.Monad.Fix.$trModule1_closure" {
     Control.Monad.Fix.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Fix.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.304287815 UTC

[section ""data" . Control.Monad.Fix.$trModule_closure" {
     Control.Monad.Fix.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.Fix.$trModule3_closure+1;
         const Control.Monad.Fix.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.304874545 UTC

[section ""data" . $krep_rbGDc_closure" {
     $krep_rbGDc_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.305700715 UTC

[section ""data" . Control.Monad.Fix.$tcMonadFix1_closure" {
     Control.Monad.Fix.$tcMonadFix1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep_rbGDc_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.306252655 UTC

[section ""cstring" . Control.Monad.Fix.$tcMonadFix3_bytes" {
     Control.Monad.Fix.$tcMonadFix3_bytes:
         I8[] [77,111,110,97,100,70,105,120]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.306781689 UTC

[section ""data" . Control.Monad.Fix.$tcMonadFix2_closure" {
     Control.Monad.Fix.$tcMonadFix2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Fix.$tcMonadFix3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.30736634 UTC

[section ""data" . Control.Monad.Fix.$tcMonadFix_closure" {
     Control.Monad.Fix.$tcMonadFix_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.Fix.$trModule_closure+1;
         const Control.Monad.Fix.$tcMonadFix2_closure+1;
         const Control.Monad.Fix.$tcMonadFix1_closure+4;
         const 9994897379720692231;
         const 15179622530544898162;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.308180596 UTC

[section ""data" . Control.Monad.Fix.C:MonadFix_closure" {
     Control.Monad.Fix.C:MonadFix_closure:
         const Control.Monad.Fix.C:MonadFix_info;
 },
 Control.Monad.Fix.C:MonadFix_entry() //  [R2, R3]
         { info_tbl: [(cbH0X,
                       label: Control.Monad.Fix.C:MonadFix_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH0X: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbH11; else goto cbH10;
       cbH11: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.C:MonadFix_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbH10: // global
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.309078206 UTC

[Control.Monad.Fix.C:MonadFix_con_entry() //  [R1]
         { info_tbl: [(cbH12,
                       label: Control.Monad.Fix.C:MonadFix_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,77,111,110,97,100,46,70,105,120,46,67,58,77,111,110,97,100,70,105,120]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH12: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.309852052 UTC

[section ""relreadonly" . SbGFQ_srt" {
     SbGFQ_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Control.Monad.Fix.$fMonadFixFirst1_closure;
         const Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure;
         const GHC.List.head_closure;
         const GHC.List.scanl2_closure;
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure;
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure;
         const Control.Monad.Fix.$fMonadFixEither1_closure;
         const Control.Monad.Fix.$fMonadFixEither_$cmfix_closure;
         const Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure;
         const Control.Monad.Fix.$fMonadFixLast_$cmfix_closure;
         const GHC.Generics.$fMonadRec1_closure;
         const Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_closure;
         const Control.Monad.Fix.$fMonadFixRec1_closure;
         const GHC.Generics.$fMonad:*:_closure;
         const Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_closure;
         const Control.Monad.Fix.$fMonadFix:*:_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.31068782 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:34.312067971 UTC

[section ""data" . Control.Monad.Fix.$p1MonadFix_closure" {
     Control.Monad.Fix.$p1MonadFix_closure:
         const Control.Monad.Fix.$p1MonadFix_info;
 },
 Control.Monad.Fix.$p1MonadFix_entry() //  [R2]
         { info_tbl: [(cbH1b,
                       label: Control.Monad.Fix.$p1MonadFix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH1b: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbH1c; else goto cbH1d;
       cbH1c: // global
           R2 = R2;
           R1 = Control.Monad.Fix.$p1MonadFix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbH1d: // global
           I64[Sp - 8] = block_cbH18_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubH1h; else goto cbH19;
       ubH1h: // global
           call _cbH18(R1) args: 0, res: 0, upd: 0;
       cbH19: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbH18() //  [R1]
         { info_tbl: [(cbH18,
                       label: block_cbH18_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH18: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.317746942 UTC

[section ""data" . Control.Monad.Fix.mfix_closure" {
     Control.Monad.Fix.mfix_closure:
         const Control.Monad.Fix.mfix_info;
 },
 Control.Monad.Fix.mfix_entry() //  [R2]
         { info_tbl: [(cbH1A,
                       label: Control.Monad.Fix.mfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH1A: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbH1B; else goto cbH1C;
       cbH1B: // global
           R2 = R2;
           R1 = Control.Monad.Fix.mfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbH1C: // global
           I64[Sp - 8] = block_cbH1x_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubH1G; else goto cbH1y;
       ubH1G: // global
           call _cbH1x(R1) args: 0, res: 0, upd: 0;
       cbH1y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbH1x() //  [R1]
         { info_tbl: [(cbH1x,
                       label: block_cbH1x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH1x: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.32443299 UTC

[section ""cstring" . lvl_rbGDa_bytes" {
     lvl_rbGDa_bytes:
         I8[] [109,102,105,120,32,77,97,121,98,101,58,32,78,111,116,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.326344502 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixFirst1_closure" {
     Control.Monad.Fix.$fMonadFixFirst1_closure:
         const Control.Monad.Fix.$fMonadFixFirst1_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Monad.Fix.$fMonadFixFirst1_entry() //  [R1]
         { info_tbl: [(cbH1Z,
                       label: Control.Monad.Fix.$fMonadFixFirst1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH1Z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbH20; else goto cbH21;
       cbH20: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbH21: // global
           (_cbH1U::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbH1U::I64 == 0) goto cbH1W; else goto cbH1V;
       cbH1W: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbH1V: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbH1U::I64;
           I64[Sp - 24] = block_cbH1X_info;
           R2 = lvl_rbGDa_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbH1X() //  [R1]
         { info_tbl: [(cbH1X,
                       label: block_cbH1X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH1X: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.332665328 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixMaybe_$cmfix_info;
         const 0;
 },
 sat_sbGDr_entry() //  [R1]
         { info_tbl: [(cbH2y,
                       label: sat_sbGDr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH2y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbH2z; else goto cbH2A;
       cbH2z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbH2A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbH2r_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubH2H; else goto cbH2s;
       ubH2H: // global
           call _cbH2r(R1) args: 0, res: 0, upd: 0;
       cbH2s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbH2r() //  [R1]
         { info_tbl: [(cbH2r,
                       label: block_cbH2r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH2r: // global
           if (R1 & 7 == 1) goto cbH2v; else goto cbH2w;
       cbH2v: // global
           R1 = Control.Monad.Fix.$fMonadFixFirst1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cbH2w: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 a1_sbGDo_entry() //  [R1]
         { info_tbl: [(cbH2I,
                       label: a1_sbGDo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH2I: // global
           _sbGDo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbH2J; else goto cbH2K;
       cbH2K: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbH2M; else goto cbH2L;
       cbH2M: // global
           HpAlloc = 24;
           goto cbH2J;
       cbH2J: // global
           R1 = _sbGDo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbH2L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDo::P64;
           _sbGDn::P64 = P64[_sbGDo::P64 + 16];
           I64[Hp - 16] = sat_sbGDr_info;
           P64[Hp] = _sbGDo::P64;
           R2 = Hp - 16;
           R1 = _sbGDn::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixMaybe_$cmfix_entry() //  [R2]
         { info_tbl: [(cbH2N,
                       label: Control.Monad.Fix.$fMonadFixMaybe_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH2N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbH2R; else goto cbH2Q;
       cbH2R: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbH2Q: // global
           I64[Hp - 16] = a1_sbGDo_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.341971815 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixMaybe_closure" {
     Control.Monad.Fix.$fMonadFixMaybe_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonadMaybe_closure;
         const Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.344841704 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure" {
     Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure:
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_info;
         const 0;
 },
 sat_sbGDu_entry() //  [R1]
         { info_tbl: [(cbH3p,
                       label: sat_sbGDu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH3p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbH3q; else goto cbH3r;
       cbH3q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbH3r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.head_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sbGDt_entry() //  [R1]
         { info_tbl: [(cbH3s,
                       label: x_sbGDt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH3s: // global
           _sbGDt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbH3t; else goto cbH3u;
       cbH3u: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbH3w; else goto cbH3v;
       cbH3w: // global
           HpAlloc = 24;
           goto cbH3t;
       cbH3t: // global
           R1 = _sbGDt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbH3v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDt::P64;
           _sbGDs::P64 = P64[_sbGDt::P64 + 16];
           I64[Hp - 16] = sat_sbGDu_info;
           P64[Hp] = _sbGDt::P64;
           R2 = Hp - 16;
           R1 = _sbGDs::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbGDC_entry() //  [R1, R2]
         { info_tbl: [(cbH3S,
                       label: sat_sbGDC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH3S: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbH3T; else goto cbH3U;
       cbH3T: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbH3U: // global
           I64[Sp - 8] = block_cbH3M_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbH3M() //  [R1]
         { info_tbl: [(cbH3M,
                       label: block_cbH3M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH3M: // global
           if (R1 & 7 == 1) goto cbH3P; else goto cbH3Q;
       cbH3P: // global
           R1 = GHC.List.scanl2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbH3Q: // global
           R1 = P64[R1 + 14] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGDD_entry() //  [R1]
         { info_tbl: [(cbH41,
                       label: sat_sbGDD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH41: // global
           _sbGDD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbH42; else goto cbH43;
       cbH43: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbH45; else goto cbH44;
       cbH45: // global
           HpAlloc = 16;
           goto cbH42;
       cbH42: // global
           R1 = _sbGDD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbH44: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDD::P64;
           _sbGDs::P64 = P64[_sbGDD::P64 + 16];
           I64[Hp - 8] = sat_sbGDC_info;
           P64[Hp] = _sbGDs::P64;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_entry() //  [R2]
         { info_tbl: [(cbH4a,
                       label: Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH4a: // global
           _sbGDs::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbH4b; else goto cbH4c;
       cbH4c: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbH4e; else goto cbH4d;
       cbH4e: // global
           HpAlloc = 24;
           goto cbH4b;
       cbH4b: // global
           R2 = _sbGDs::P64;
           R1 = Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbH4d: // global
           I64[Hp - 16] = x_sbGDt_info;
           P64[Hp] = _sbGDs::P64;
           I64[Sp - 16] = block_cbH3x_info;
           R1 = Hp - 16;
           P64[Sp - 8] = _sbGDs::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubH4l; else goto cbH3y;
       ubH4l: // global
           call _cbH3x(R1) args: 0, res: 0, upd: 0;
       cbH3y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbH3x() //  [R1]
         { info_tbl: [(cbH3x,
                       label: block_cbH3x_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH3x: // global
           if (R1 & 7 == 1) goto cbH47; else goto cbH48;
       cbH47: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbH48: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbH4k; else goto cbH4j;
       cbH4k: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbH4j: // global
           _sbGDw::P64 = P64[R1 + 6];
           I64[Hp - 40] = sat_sbGDD_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sbGDw::P64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.361564755 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix[]_closure" {
     Control.Monad.Fix.$fMonadFix[]_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonad[]_closure;
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.364402152 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_info;
         const 0;
 },
 sat_sbGDS_entry() //  [R1, R2]
         { info_tbl: [(cbH5f,
                       label: sat_sbGDS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH5f: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbH5g; else goto cbH5h;
       cbH5g: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbH5h: // global
           I64[Sp - 8] = block_cbH5d_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbH5d() //  [R1]
         { info_tbl: [(cbH5d,
                       label: block_cbH5d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH5d: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGDT_entry() //  [R1]
         { info_tbl: [(cbH5l,
                       label: sat_sbGDT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH5l: // global
           _sbGDT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbH5m; else goto cbH5n;
       cbH5n: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbH5p; else goto cbH5o;
       cbH5p: // global
           HpAlloc = 16;
           goto cbH5m;
       cbH5m: // global
           R1 = _sbGDT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbH5o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDT::P64;
           _sbGDE::P64 = P64[_sbGDT::P64 + 16];
           I64[Hp - 8] = sat_sbGDS_info;
           P64[Hp] = _sbGDE::P64;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sbGDF_entry() //  [R1]
         { info_tbl: [(cbH5z,
                       label: x_sbGDF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH5z: // global
           _sbGDF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbH5A; else goto cbH5B;
       cbH5B: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbH5D; else goto cbH5C;
       cbH5D: // global
           HpAlloc = 24;
           goto cbH5A;
       cbH5A: // global
           R1 = _sbGDF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbH5C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDF::P64;
           _sbGDE::P64 = P64[_sbGDF::P64 + 16];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbGDF::P64;
           R2 = Hp - 16;
           R1 = _sbGDE::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbGDN_entry() //  [R1]
         { info_tbl: [(cbH5H,
                       label: sat_sbGDN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH5H: // global
           _sbGDN::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbH5I; else goto cbH5J;
       cbH5J: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbH5L; else goto cbH5K;
       cbH5L: // global
           HpAlloc = 24;
           goto cbH5I;
       cbH5I: // global
           R1 = _sbGDN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbH5K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDN::P64;
           _sbGDE::P64 = P64[_sbGDN::P64 + 16];
           I64[Hp - 16] = x_sbGDF_info;
           P64[Hp] = _sbGDE::P64;
           I64[Sp - 24] = block_cbH5E_info;
           R1 = Hp - 16;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubH5P; else goto cbH5F;
       ubH5P: // global
           call _cbH5E(R1) args: 0, res: 0, upd: 0;
       cbH5F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbH5E() //  [R1]
         { info_tbl: [(cbH5E,
                       label: block_cbH5E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH5E: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_entry() //  [R2]
         { info_tbl: [(cbH5R,
                       label: Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH5R: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbH5V; else goto cbH5U;
       cbH5V: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbH5U: // global
           I64[Hp - 64] = sat_sbGDT_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbGDN_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.379608452 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixNonEmpty_closure" {
     Control.Monad.Fix.$fMonadFixNonEmpty_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonadNonEmpty_closure;
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.381532004 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixIO_closure" {
     Control.Monad.Fix.$fMonadFixIO_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonadIO_closure;
         const System.IO.fixIO1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.383631414 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix(->)_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFix(->)_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFix(->)_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFix(->)_$cmfix_entry() //  [R2, R3]
         { info_tbl: [(cbH6z,
                       label: Control.Monad.Fix.$fMonadFix(->)_$cmfix_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH6z: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbH6D; else goto cbH6C;
       cbH6D: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFix(->)_$cmfix_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbH6C: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R2;
           _cbH6y::P64 = Hp - 32;
           P64[Hp - 8] = _cbH6y::P64;
           P64[Hp] = R3;
           R1 = _cbH6y::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.387352493 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix(->)_closure" {
     Control.Monad.Fix.$fMonadFix(->)_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonad(->)_closure;
         const Control.Monad.Fix.$fMonadFix(->)_$cmfix_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.38912157 UTC

[section ""cstring" . lvl1_rbGDb_bytes" {
     lvl1_rbGDb_bytes:
         I8[] [109,102,105,120,32,69,105,116,104,101,114,58,32,76,101,102,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.391081187 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixEither1_closure" {
     Control.Monad.Fix.$fMonadFixEither1_closure:
         const Control.Monad.Fix.$fMonadFixEither1_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Monad.Fix.$fMonadFixEither1_entry() //  [R1]
         { info_tbl: [(cbH6S,
                       label: Control.Monad.Fix.$fMonadFixEither1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH6S: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbH6T; else goto cbH6U;
       cbH6T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbH6U: // global
           (_cbH6N::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbH6N::I64 == 0) goto cbH6P; else goto cbH6O;
       cbH6P: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbH6O: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbH6N::I64;
           I64[Sp - 24] = block_cbH6Q_info;
           R2 = lvl1_rbGDb_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbH6Q() //  [R1]
         { info_tbl: [(cbH6Q,
                       label: block_cbH6Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH6Q: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.397832795 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixEither_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixEither_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixEither_$cmfix_info;
         const 0;
 },
 sat_sbGE3_entry() //  [R1]
         { info_tbl: [(cbH7r,
                       label: sat_sbGE3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH7r: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbH7s; else goto cbH7t;
       cbH7s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbH7t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbH7k_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubH7A; else goto cbH7l;
       ubH7A: // global
           call _cbH7k(R1) args: 0, res: 0, upd: 0;
       cbH7l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbH7k() //  [R1]
         { info_tbl: [(cbH7k,
                       label: block_cbH7k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH7k: // global
           if (R1 & 7 == 1) goto cbH7o; else goto cbH7p;
       cbH7o: // global
           R1 = Control.Monad.Fix.$fMonadFixEither1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cbH7p: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 a1_sbGDZ_entry() //  [R1]
         { info_tbl: [(cbH7B,
                       label: a1_sbGDZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH7B: // global
           _sbGDZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbH7C; else goto cbH7D;
       cbH7D: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbH7F; else goto cbH7E;
       cbH7F: // global
           HpAlloc = 24;
           goto cbH7C;
       cbH7C: // global
           R1 = _sbGDZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbH7E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGDZ::P64;
           _sbGDY::P64 = P64[_sbGDZ::P64 + 16];
           I64[Hp - 16] = sat_sbGE3_info;
           P64[Hp] = _sbGDZ::P64;
           R2 = Hp - 16;
           R1 = _sbGDY::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixEither_$cmfix_entry() //  [R2]
         { info_tbl: [(cbH7G,
                       label: Control.Monad.Fix.$fMonadFixEither_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH7G: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbH7K; else goto cbH7J;
       cbH7K: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixEither_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbH7J: // global
           I64[Hp - 16] = a1_sbGDZ_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.407374681 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixEither_closure" {
     Control.Monad.Fix.$fMonadFixEither_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Either.$fMonadEither_closure;
         const Control.Monad.Fix.$fMonadFixEither_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.409133598 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixST_closure" {
     Control.Monad.Fix.$fMonadFixST_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.ST.$fMonadST_closure;
         const GHC.ST.fixST1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.411164042 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixDual_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixDual_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixDual_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFixDual_$cmfix_entry() //  [R2]
         { info_tbl: [(cbH8c,
                       label: Control.Monad.Fix.$fMonadFixDual_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH8c: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbH8g; else goto cbH8f;
       cbH8g: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixDual_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbH8f: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbH8b::P64 = Hp - 24;
           P64[Hp] = _cbH8b::P64;
           R1 = _cbH8b::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.415873572 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixDual_closure" {
     Control.Monad.Fix.$fMonadFixDual_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Semigroup.Internal.$fMonadDual_closure;
         const Control.Monad.Fix.$fMonadFixDual_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.417872905 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixSum_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixSum_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixSum_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFixSum_$cmfix_entry() //  [R2]
         { info_tbl: [(cbH8r,
                       label: Control.Monad.Fix.$fMonadFixSum_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH8r: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbH8v; else goto cbH8u;
       cbH8v: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixSum_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbH8u: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbH8q::P64 = Hp - 24;
           P64[Hp] = _cbH8q::P64;
           R1 = _cbH8q::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.421510599 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixSum_closure" {
     Control.Monad.Fix.$fMonadFixSum_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Semigroup.Internal.$fMonadSum_closure;
         const Control.Monad.Fix.$fMonadFixSum_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.423441653 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixProduct_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixProduct_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixProduct_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFixProduct_$cmfix_entry() //  [R2]
         { info_tbl: [(cbH8G,
                       label: Control.Monad.Fix.$fMonadFixProduct_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH8G: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbH8K; else goto cbH8J;
       cbH8K: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixProduct_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbH8J: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbH8F::P64 = Hp - 24;
           P64[Hp] = _cbH8F::P64;
           R1 = _cbH8F::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.427083122 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixProduct_closure" {
     Control.Monad.Fix.$fMonadFixProduct_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Semigroup.Internal.$fMonadProduct_closure;
         const Control.Monad.Fix.$fMonadFixProduct_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.430209507 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixFirst_$cmfix_info;
         const 0;
 },
 sat_sbGEe_entry() //  [R1]
         { info_tbl: [(cbH99,
                       label: sat_sbGEe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH99: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbH9a; else goto cbH9b;
       cbH9a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbH9b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbH92_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubH9i; else goto cbH93;
       ubH9i: // global
           call _cbH92(R1) args: 0, res: 0, upd: 0;
       cbH93: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbH92() //  [R1]
         { info_tbl: [(cbH92,
                       label: block_cbH92_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH92: // global
           if (R1 & 7 == 1) goto cbH96; else goto cbH97;
       cbH96: // global
           R1 = Control.Monad.Fix.$fMonadFixFirst1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cbH97: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 a1_sbGEb_entry() //  [R1]
         { info_tbl: [(cbH9j,
                       label: a1_sbGEb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH9j: // global
           _sbGEb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbH9k; else goto cbH9l;
       cbH9l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbH9n; else goto cbH9m;
       cbH9n: // global
           HpAlloc = 24;
           goto cbH9k;
       cbH9k: // global
           R1 = _sbGEb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbH9m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGEb::P64;
           _sbGEa::P64 = P64[_sbGEb::P64 + 16];
           I64[Hp - 16] = sat_sbGEe_info;
           P64[Hp] = _sbGEb::P64;
           R2 = Hp - 16;
           R1 = _sbGEa::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixFirst_$cmfix_entry() //  [R2]
         { info_tbl: [(cbH9o,
                       label: Control.Monad.Fix.$fMonadFixFirst_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH9o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbH9s; else goto cbH9r;
       cbH9s: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbH9r: // global
           I64[Hp - 16] = a1_sbGEb_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.439793134 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixFirst_closure" {
     Control.Monad.Fix.$fMonadFixFirst_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Monoid.$fMonadFirst_closure;
         const Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.442377635 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixLast_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixLast_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixLast_$cmfix_info;
         const 0;
 },
 sat_sbGEj_entry() //  [R1]
         { info_tbl: [(cbHa7,
                       label: sat_sbGEj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHa7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbHa8; else goto cbHa9;
       cbHa8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHa9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbHa0_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubHag; else goto cbHa1;
       ubHag: // global
           call _cbHa0(R1) args: 0, res: 0, upd: 0;
       cbHa1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbHa0() //  [R1]
         { info_tbl: [(cbHa0,
                       label: block_cbHa0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHa0: // global
           if (R1 & 7 == 1) goto cbHa4; else goto cbHa5;
       cbHa4: // global
           R1 = Control.Monad.Fix.$fMonadFixFirst1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cbHa5: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 a1_sbGEg_entry() //  [R1]
         { info_tbl: [(cbHah,
                       label: a1_sbGEg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHah: // global
           _sbGEg::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbHai; else goto cbHaj;
       cbHaj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHal; else goto cbHak;
       cbHal: // global
           HpAlloc = 24;
           goto cbHai;
       cbHai: // global
           R1 = _sbGEg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHak: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGEg::P64;
           _sbGEf::P64 = P64[_sbGEg::P64 + 16];
           I64[Hp - 16] = sat_sbGEj_info;
           P64[Hp] = _sbGEg::P64;
           R2 = Hp - 16;
           R1 = _sbGEf::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixLast_$cmfix_entry() //  [R2]
         { info_tbl: [(cbHam,
                       label: Control.Monad.Fix.$fMonadFixLast_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHam: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHaq; else goto cbHap;
       cbHaq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixLast_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHap: // global
           I64[Hp - 16] = a1_sbGEg_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.452005791 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixLast_closure" {
     Control.Monad.Fix.$fMonadFixLast_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Monoid.$fMonadLast_closure;
         const Control.Monad.Fix.$fMonadFixLast_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.45432739 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixAlt1_closure" {
     Control.Monad.Fix.$fMonadFixAlt1_closure:
         const Control.Monad.Fix.$fMonadFixAlt1_info;
 },
 sat_sbGEn_entry() //  [R1, R2]
         { info_tbl: [(cbHaV,
                       label: sat_sbGEn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHaV: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.Fix.$fMonadFixAlt1_entry() //  [R2, R3]
         { info_tbl: [(cbHaY,
                       label: Control.Monad.Fix.$fMonadFixAlt1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHaY: // global
           _sbGEl::P64 = R3;
           _sbGEk::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbHaZ; else goto cbHb0;
       cbHb0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbHb2; else goto cbHb1;
       cbHb2: // global
           HpAlloc = 16;
           goto cbHaZ;
       cbHaZ: // global
           R3 = _sbGEl::P64;
           R2 = _sbGEk::P64;
           R1 = Control.Monad.Fix.$fMonadFixAlt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbHb1: // global
           I64[Hp - 8] = sat_sbGEn_info;
           P64[Hp] = _sbGEl::P64;
           R2 = _sbGEk::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.mfix_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.459956276 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_closure" {
     Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_closure:
         const Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_info;
 },
 sat_sbGEp_entry() //  [R1]
         { info_tbl: [(cbHbk,
                       label: sat_sbGEp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHbk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbHbl; else goto cbHbm;
       cbHbl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHbm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_entry() //  [R2]
         { info_tbl: [(cbHbn,
                       label: Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHbn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHbr; else goto cbHbq;
       cbHbr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHbq: // global
           I64[Hp - 16] = sat_sbGEp_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fMonadAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.466152029 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixAlt_closure" {
     Control.Monad.Fix.$fMonadFixAlt_closure:
         const Control.Monad.Fix.$fMonadFixAlt_info;
 },
 sat_sbGEs_entry() //  [R1, R2]
         { info_tbl: [(cbHbJ,
                       label: sat_sbGEs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHbJ: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Fix.$fMonadFixAlt1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGEr_entry() //  [R1]
         { info_tbl: [(cbHbQ,
                       label: sat_sbGEr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHbQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbHbR; else goto cbHbS;
       cbHbR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHbS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixAlt_entry() //  [R2]
         { info_tbl: [(cbHbU,
                       label: Control.Monad.Fix.$fMonadFixAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHbU: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbHbY; else goto cbHbX;
       cbHbY: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHbX: // global
           I64[Hp - 56] = sat_sbGEs_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbGEr_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.473604619 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixPar1_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixPar1_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixPar1_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFixPar1_$cmfix_entry() //  [R2]
         { info_tbl: [(cbHci,
                       label: Control.Monad.Fix.$fMonadFixPar1_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHci: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbHcm; else goto cbHcl;
       cbHcm: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixPar1_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHcl: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbHch::P64 = Hp - 24;
           P64[Hp] = _cbHch::P64;
           R1 = _cbHch::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.47729397 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixPar1_closure" {
     Control.Monad.Fix.$fMonadFixPar1_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Generics.$fMonadPar1_closure;
         const Control.Monad.Fix.$fMonadFixPar1_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.479331965 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixRec2_closure" {
     Control.Monad.Fix.$fMonadFixRec2_closure:
         const Control.Monad.Fix.$fMonadFixRec2_info;
 },
 sat_sbGEy_entry() //  [R1, R2]
         { info_tbl: [(cbHcB,
                       label: sat_sbGEy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHcB: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.Fix.$fMonadFixRec2_entry() //  [R2, R3]
         { info_tbl: [(cbHcE,
                       label: Control.Monad.Fix.$fMonadFixRec2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHcE: // global
           _sbGEw::P64 = R3;
           _sbGEv::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbHcF; else goto cbHcG;
       cbHcG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbHcI; else goto cbHcH;
       cbHcI: // global
           HpAlloc = 16;
           goto cbHcF;
       cbHcF: // global
           R3 = _sbGEw::P64;
           R2 = _sbGEv::P64;
           R1 = Control.Monad.Fix.$fMonadFixRec2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbHcH: // global
           I64[Hp - 8] = sat_sbGEy_info;
           P64[Hp] = _sbGEw::P64;
           R2 = _sbGEv::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.mfix_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.48521383 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_closure" {
     Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_closure:
         const Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_info;
         const 0;
 },
 sat_sbGEA_entry() //  [R1]
         { info_tbl: [(cbHd0,
                       label: sat_sbGEA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHd0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbHd1; else goto cbHd2;
       cbHd1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHd2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_entry() //  [R2]
         { info_tbl: [(cbHd3,
                       label: Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHd3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHd7; else goto cbHd6;
       cbHd7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHd6: // global
           I64[Hp - 16] = sat_sbGEA_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadRec1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.49084735 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixRec1_closure" {
     Control.Monad.Fix.$fMonadFixRec1_closure:
         const Control.Monad.Fix.$fMonadFixRec1_info;
         const 0;
 },
 sat_sbGED_entry() //  [R1, R2]
         { info_tbl: [(cbHdp,
                       label: sat_sbGED_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHdp: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Fix.$fMonadFixRec2_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGEC_entry() //  [R1]
         { info_tbl: [(cbHdw,
                       label: sat_sbGEC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHdw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbHdx; else goto cbHdy;
       cbHdx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHdy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixRec1_entry() //  [R2]
         { info_tbl: [(cbHdA,
                       label: Control.Monad.Fix.$fMonadFixRec1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHdA: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbHdE; else goto cbHdD;
       cbHdE: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixRec1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHdD: // global
           I64[Hp - 56] = sat_sbGED_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbGEC_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.49837936 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixM2_closure" {
     Control.Monad.Fix.$fMonadFixM2_closure:
         const Control.Monad.Fix.$fMonadFixM2_info;
 },
 sat_sbGEH_entry() //  [R1, R2]
         { info_tbl: [(cbHe2,
                       label: sat_sbGEH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHe2: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.Fix.$fMonadFixM2_entry() //  [R2, R3]
         { info_tbl: [(cbHe5,
                       label: Control.Monad.Fix.$fMonadFixM2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHe5: // global
           _sbGEF::P64 = R3;
           _sbGEE::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbHe6; else goto cbHe7;
       cbHe7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbHe9; else goto cbHe8;
       cbHe9: // global
           HpAlloc = 16;
           goto cbHe6;
       cbHe6: // global
           R3 = _sbGEF::P64;
           R2 = _sbGEE::P64;
           R1 = Control.Monad.Fix.$fMonadFixM2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbHe8: // global
           I64[Hp - 8] = sat_sbGEH_info;
           P64[Hp] = _sbGEF::P64;
           R2 = _sbGEE::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.mfix_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.504418412 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_closure" {
     Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_closure:
         const Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_info;
 },
 sat_sbGEJ_entry() //  [R1]
         { info_tbl: [(cbHer,
                       label: sat_sbGEJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHer: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbHes; else goto cbHet;
       cbHes: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHet: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_entry() //  [R2]
         { info_tbl: [(cbHeu,
                       label: Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHeu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHey; else goto cbHex;
       cbHey: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHex: // global
           I64[Hp - 16] = sat_sbGEJ_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.510596308 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixM1_closure" {
     Control.Monad.Fix.$fMonadFixM1_closure:
         const Control.Monad.Fix.$fMonadFixM1_info;
 },
 sat_sbGEM_entry() //  [R1, R2]
         { info_tbl: [(cbHeQ,
                       label: sat_sbGEM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHeQ: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Fix.$fMonadFixM2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGEL_entry() //  [R1]
         { info_tbl: [(cbHeX,
                       label: sat_sbGEL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHeX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbHeY; else goto cbHeZ;
       cbHeY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHeZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixM1_entry() //  [R2]
         { info_tbl: [(cbHf1,
                       label: Control.Monad.Fix.$fMonadFixM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHf1: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbHf5; else goto cbHf4;
       cbHf5: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHf4: // global
           I64[Hp - 56] = sat_sbGEM_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbGEL_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.518793711 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix:*:_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFix:*:_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFix:*:_$cmfix_info;
 },
 sat_sbGF0_entry() //  [R1, R2]
         { info_tbl: [(cbHfz,
                       label: sat_sbGF0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHfz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbHfA; else goto cbHfB;
       cbHfA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHfB: // global
           I64[Sp - 8] = block_cbHfx_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbHfx() //  [R1]
         { info_tbl: [(cbHfx,
                       label: block_cbHfx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHfx: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGF1_entry() //  [R1]
         { info_tbl: [(cbHfF,
                       label: sat_sbGF1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHfF: // global
           _sbGF1::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbHfG; else goto cbHfH;
       cbHfH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbHfJ; else goto cbHfI;
       cbHfJ: // global
           HpAlloc = 16;
           goto cbHfG;
       cbHfG: // global
           R1 = _sbGF1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHfI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGF1::P64;
           _sbGEO::P64 = P64[_sbGF1::P64 + 16];
           _sbGEP::P64 = P64[_sbGF1::P64 + 24];
           I64[Hp - 8] = sat_sbGF0_info;
           P64[Hp] = _sbGEP::P64;
           R2 = _sbGEO::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbGEU_entry() //  [R1, R2]
         { info_tbl: [(cbHfV,
                       label: sat_sbGEU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHfV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbHfW; else goto cbHfX;
       cbHfW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHfX: // global
           I64[Sp - 8] = block_cbHfT_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbHfT() //  [R1]
         { info_tbl: [(cbHfT,
                       label: block_cbHfT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHfT: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGEV_entry() //  [R1]
         { info_tbl: [(cbHg1,
                       label: sat_sbGEV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHg1: // global
           _sbGEV::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbHg2; else goto cbHg3;
       cbHg3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbHg5; else goto cbHg4;
       cbHg5: // global
           HpAlloc = 16;
           goto cbHg2;
       cbHg2: // global
           R1 = _sbGEV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHg4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbGEV::P64;
           _sbGEN::P64 = P64[_sbGEV::P64 + 16];
           _sbGEP::P64 = P64[_sbGEV::P64 + 24];
           I64[Hp - 8] = sat_sbGEU_info;
           P64[Hp] = _sbGEP::P64;
           R2 = _sbGEN::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFix:*:_$cmfix_entry() //  [R2, R3, R4]
         { info_tbl: [(cbHg7,
                       label: Control.Monad.Fix.$fMonadFix:*:_$cmfix_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHg7: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbHgb; else goto cbHga;
       cbHgb: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFix:*:_$cmfix_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbHga: // global
           I64[Hp - 80] = sat_sbGF1_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sbGEV_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.533841064 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_closure" {
     Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_closure:
         const Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_info;
         const 0;
 },
 sat_sbGF5_entry() //  [R1]
         { info_tbl: [(cbHgP,
                       label: sat_sbGF5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHgP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbHgQ; else goto cbHgR;
       cbHgQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHgR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbGF4_entry() //  [R1]
         { info_tbl: [(cbHgW,
                       label: sat_sbGF4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHgW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbHgX; else goto cbHgY;
       cbHgX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHgY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_entry() //  [R2, R3]
         { info_tbl: [(cbHgZ,
                       label: Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHgZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbHh3; else goto cbHh2;
       cbHh3: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbHh2: // global
           I64[Hp - 40] = sat_sbGF5_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbGF4_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fMonad:*:_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.542356258 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix:*:_closure" {
     Control.Monad.Fix.$fMonadFix:*:_closure:
         const Control.Monad.Fix.$fMonadFix:*:_info;
         const 0;
 },
 sat_sbGF9_entry() //  [R1, R2]
         { info_tbl: [(cbHhp,
                       label: sat_sbGF9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHhp: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Monad.Fix.$fMonadFix:*:_$cmfix_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbGF8_entry() //  [R1]
         { info_tbl: [(cbHhw,
                       label: sat_sbGF8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHhw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbHhx; else goto cbHhy;
       cbHhx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHhy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_entry(R3,
                                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFix:*:_entry() //  [R2, R3]
         { info_tbl: [(cbHhA,
                       label: Control.Monad.Fix.$fMonadFix:*:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHhA: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbHhE; else goto cbHhD;
       cbHhE: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFix:*:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbHhD: // global
           I64[Hp - 72] = sat_sbGF9_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sbGF8_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 71;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.549461826 UTC

[section ""cstring" . Control.Monad.Fix.$trModule4_bytes" {
     Control.Monad.Fix.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.551171463 UTC

[section ""data" . Control.Monad.Fix.$trModule3_closure" {
     Control.Monad.Fix.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Fix.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.552911352 UTC

[section ""cstring" . Control.Monad.Fix.$trModule2_bytes" {
     Control.Monad.Fix.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100,46,70,105,120]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.554871618 UTC

[section ""data" . Control.Monad.Fix.$trModule1_closure" {
     Control.Monad.Fix.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Fix.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.556580889 UTC

[section ""data" . Control.Monad.Fix.$trModule_closure" {
     Control.Monad.Fix.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.Fix.$trModule3_closure+1;
         const Control.Monad.Fix.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.558360004 UTC

[section ""data" . $krep_rbGDc_closure" {
     $krep_rbGDc_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.560127025 UTC

[section ""data" . Control.Monad.Fix.$tcMonadFix1_closure" {
     Control.Monad.Fix.$tcMonadFix1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep_rbGDc_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.561909514 UTC

[section ""cstring" . Control.Monad.Fix.$tcMonadFix3_bytes" {
     Control.Monad.Fix.$tcMonadFix3_bytes:
         I8[] [77,111,110,97,100,70,105,120]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.563565455 UTC

[section ""data" . Control.Monad.Fix.$tcMonadFix2_closure" {
     Control.Monad.Fix.$tcMonadFix2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Fix.$tcMonadFix3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.565702554 UTC

[section ""data" . Control.Monad.Fix.$tcMonadFix_closure" {
     Control.Monad.Fix.$tcMonadFix_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.Fix.$trModule_closure+1;
         const Control.Monad.Fix.$tcMonadFix2_closure+1;
         const Control.Monad.Fix.$tcMonadFix1_closure+4;
         const 9994897379720692231;
         const 15179622530544898162;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.568366692 UTC

[section ""data" . Control.Monad.Fix.C:MonadFix_closure" {
     Control.Monad.Fix.C:MonadFix_closure:
         const Control.Monad.Fix.C:MonadFix_info;
 },
 Control.Monad.Fix.C:MonadFix_entry() //  [R2, R3]
         { info_tbl: [(cbHi8,
                       label: Control.Monad.Fix.C:MonadFix_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHi8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHic; else goto cbHib;
       cbHic: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.C:MonadFix_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbHib: // global
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.572220263 UTC

[Control.Monad.Fix.C:MonadFix_con_entry() //  [R1]
         { info_tbl: [(cbHii,
                       label: Control.Monad.Fix.C:MonadFix_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,77,111,110,97,100,46,70,105,120,46,67,58,77,111,110,97,100,70,105,120]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHii: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.575321886 UTC

[section ""relreadonly" . SbGFQ_srt" {
     SbGFQ_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Control.Monad.Fix.$fMonadFixFirst1_closure;
         const Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure;
         const GHC.List.head_closure;
         const GHC.List.scanl2_closure;
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure;
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure;
         const Control.Monad.Fix.$fMonadFixEither1_closure;
         const Control.Monad.Fix.$fMonadFixEither_$cmfix_closure;
         const Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure;
         const Control.Monad.Fix.$fMonadFixLast_$cmfix_closure;
         const GHC.Generics.$fMonadRec1_closure;
         const Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_closure;
         const Control.Monad.Fix.$fMonadFixRec1_closure;
         const GHC.Generics.$fMonad:*:_closure;
         const Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_closure;
         const Control.Monad.Fix.$fMonadFix:*:_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.974239296 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:34.97563053 UTC

[section ""data" . Control.Monad.Fix.$p1MonadFix_closure" {
     Control.Monad.Fix.$p1MonadFix_closure:
         const Control.Monad.Fix.$p1MonadFix_info;
 },
 Control.Monad.Fix.$p1MonadFix_entry() //  [R2]
         { info_tbl: [(cbHks,
                       label: Control.Monad.Fix.$p1MonadFix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHks: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbHkt; else goto cbHku;
       cbHkt: // global
           R2 = R2;
           R1 = Control.Monad.Fix.$p1MonadFix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHku: // global
           I64[Sp - 8] = block_cbHkp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubHky; else goto cbHkq;
       ubHky: // global
           call _cbHkp(R1) args: 0, res: 0, upd: 0;
       cbHkq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbHkp() //  [R1]
         { info_tbl: [(cbHkp,
                       label: block_cbHkp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHkp: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.981450128 UTC

[section ""data" . Control.Monad.Fix.mfix_closure" {
     Control.Monad.Fix.mfix_closure:
         const Control.Monad.Fix.mfix_info;
 },
 Control.Monad.Fix.mfix_entry() //  [R2]
         { info_tbl: [(cbHkS,
                       label: Control.Monad.Fix.mfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHkS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbHkT; else goto cbHkU;
       cbHkT: // global
           R2 = R2;
           R1 = Control.Monad.Fix.mfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHkU: // global
           I64[Sp - 8] = block_cbHkP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubHkY; else goto cbHkQ;
       ubHkY: // global
           call _cbHkP(R1) args: 0, res: 0, upd: 0;
       cbHkQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbHkP() //  [R1]
         { info_tbl: [(cbHkP,
                       label: block_cbHkP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHkP: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.987314749 UTC

[section ""cstring" . lvl_rbGDa_bytes" {
     lvl_rbGDa_bytes:
         I8[] [109,102,105,120,32,77,97,121,98,101,58,32,78,111,116,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.989190839 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixFirst1_closure" {
     Control.Monad.Fix.$fMonadFixFirst1_closure:
         const Control.Monad.Fix.$fMonadFixFirst1_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Monad.Fix.$fMonadFixFirst1_entry() //  [R1]
         { info_tbl: [(cbHli,
                       label: Control.Monad.Fix.$fMonadFixFirst1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHli: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbHlj; else goto cbHlk;
       cbHlj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHlk: // global
           (_cbHld::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbHld::I64 == 0) goto cbHlf; else goto cbHle;
       cbHlf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbHle: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbHld::I64;
           I64[Sp - 24] = block_cbHlg_info;
           R2 = lvl_rbGDa_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbHlg() //  [R1]
         { info_tbl: [(cbHlg,
                       label: block_cbHlg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHlg: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.99505325 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixMaybe_$cmfix_info;
         const 0;
 },
 sat_sbHiC_entry() //  [R1]
         { info_tbl: [(cbHlU,
                       label: sat_sbHiC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHlU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbHlV; else goto cbHlW;
       cbHlV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHlW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbHlN_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubHm3; else goto cbHlO;
       ubHm3: // global
           call _cbHlN(R1) args: 0, res: 0, upd: 0;
       cbHlO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbHlN() //  [R1]
         { info_tbl: [(cbHlN,
                       label: block_cbHlN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHlN: // global
           if (R1 & 7 == 1) goto cbHlR; else goto cbHlS;
       cbHlR: // global
           R1 = Control.Monad.Fix.$fMonadFixFirst1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cbHlS: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 a1_sbHiz_entry() //  [R1]
         { info_tbl: [(cbHm4,
                       label: a1_sbHiz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHm4: // global
           _sbHiz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbHm5; else goto cbHm6;
       cbHm6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHm8; else goto cbHm7;
       cbHm8: // global
           HpAlloc = 24;
           goto cbHm5;
       cbHm5: // global
           R1 = _sbHiz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHm7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbHiz::P64;
           _sbHiy::P64 = P64[_sbHiz::P64 + 16];
           I64[Hp - 16] = sat_sbHiC_info;
           P64[Hp] = _sbHiz::P64;
           R2 = Hp - 16;
           R1 = _sbHiy::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixMaybe_$cmfix_entry() //  [R2]
         { info_tbl: [(cbHm9,
                       label: Control.Monad.Fix.$fMonadFixMaybe_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHm9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHmd; else goto cbHmc;
       cbHmd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHmc: // global
           I64[Hp - 16] = a1_sbHiz_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.004400378 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixMaybe_closure" {
     Control.Monad.Fix.$fMonadFixMaybe_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonadMaybe_closure;
         const Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.007222603 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure" {
     Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure:
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_info;
         const 0;
 },
 sat_sbHiF_entry() //  [R1]
         { info_tbl: [(cbHmQ,
                       label: sat_sbHiF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHmQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbHmR; else goto cbHmS;
       cbHmR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHmS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.head_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sbHiE_entry() //  [R1]
         { info_tbl: [(cbHmT,
                       label: x_sbHiE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHmT: // global
           _sbHiE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbHmU; else goto cbHmV;
       cbHmV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHmX; else goto cbHmW;
       cbHmX: // global
           HpAlloc = 24;
           goto cbHmU;
       cbHmU: // global
           R1 = _sbHiE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHmW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbHiE::P64;
           _sbHiD::P64 = P64[_sbHiE::P64 + 16];
           I64[Hp - 16] = sat_sbHiF_info;
           P64[Hp] = _sbHiE::P64;
           R2 = Hp - 16;
           R1 = _sbHiD::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbHiN_entry() //  [R1, R2]
         { info_tbl: [(cbHnj,
                       label: sat_sbHiN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHnj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbHnk; else goto cbHnl;
       cbHnk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHnl: // global
           I64[Sp - 8] = block_cbHnd_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbHnd() //  [R1]
         { info_tbl: [(cbHnd,
                       label: block_cbHnd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHnd: // global
           if (R1 & 7 == 1) goto cbHng; else goto cbHnh;
       cbHng: // global
           R1 = GHC.List.scanl2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbHnh: // global
           R1 = P64[R1 + 14] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbHiO_entry() //  [R1]
         { info_tbl: [(cbHns,
                       label: sat_sbHiO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHns: // global
           _sbHiO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbHnt; else goto cbHnu;
       cbHnu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbHnw; else goto cbHnv;
       cbHnw: // global
           HpAlloc = 16;
           goto cbHnt;
       cbHnt: // global
           R1 = _sbHiO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHnv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbHiO::P64;
           _sbHiD::P64 = P64[_sbHiO::P64 + 16];
           I64[Hp - 8] = sat_sbHiN_info;
           P64[Hp] = _sbHiD::P64;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_entry() //  [R2]
         { info_tbl: [(cbHnB,
                       label: Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHnB: // global
           _sbHiD::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbHnC; else goto cbHnD;
       cbHnD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHnF; else goto cbHnE;
       cbHnF: // global
           HpAlloc = 24;
           goto cbHnC;
       cbHnC: // global
           R2 = _sbHiD::P64;
           R1 = Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHnE: // global
           I64[Hp - 16] = x_sbHiE_info;
           P64[Hp] = _sbHiD::P64;
           I64[Sp - 16] = block_cbHmY_info;
           R1 = Hp - 16;
           P64[Sp - 8] = _sbHiD::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubHnM; else goto cbHmZ;
       ubHnM: // global
           call _cbHmY(R1) args: 0, res: 0, upd: 0;
       cbHmZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbHmY() //  [R1]
         { info_tbl: [(cbHmY,
                       label: block_cbHmY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHmY: // global
           if (R1 & 7 == 1) goto cbHny; else goto cbHnz;
       cbHny: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbHnz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbHnL; else goto cbHnK;
       cbHnL: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbHnK: // global
           _sbHiH::P64 = P64[R1 + 6];
           I64[Hp - 40] = sat_sbHiO_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sbHiH::P64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.023096573 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix[]_closure" {
     Control.Monad.Fix.$fMonadFix[]_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonad[]_closure;
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.026447042 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_info;
         const 0;
 },
 sat_sbHj3_entry() //  [R1, R2]
         { info_tbl: [(cbHoR,
                       label: sat_sbHj3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHoR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbHoS; else goto cbHoT;
       cbHoS: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHoT: // global
           I64[Sp - 8] = block_cbHoP_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbHoP() //  [R1]
         { info_tbl: [(cbHoP,
                       label: block_cbHoP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHoP: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbHj4_entry() //  [R1]
         { info_tbl: [(cbHoX,
                       label: sat_sbHj4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHoX: // global
           _sbHj4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbHoY; else goto cbHoZ;
       cbHoZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbHp1; else goto cbHp0;
       cbHp1: // global
           HpAlloc = 16;
           goto cbHoY;
       cbHoY: // global
           R1 = _sbHj4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHp0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbHj4::P64;
           _sbHiP::P64 = P64[_sbHj4::P64 + 16];
           I64[Hp - 8] = sat_sbHj3_info;
           P64[Hp] = _sbHiP::P64;
           R2 = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 x_sbHiQ_entry() //  [R1]
         { info_tbl: [(cbHpb,
                       label: x_sbHiQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHpb: // global
           _sbHiQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbHpc; else goto cbHpd;
       cbHpd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHpf; else goto cbHpe;
       cbHpf: // global
           HpAlloc = 24;
           goto cbHpc;
       cbHpc: // global
           R1 = _sbHiQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHpe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbHiQ::P64;
           _sbHiP::P64 = P64[_sbHiQ::P64 + 16];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbHiQ::P64;
           R2 = Hp - 16;
           R1 = _sbHiP::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbHiY_entry() //  [R1]
         { info_tbl: [(cbHpj,
                       label: sat_sbHiY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHpj: // global
           _sbHiY::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbHpk; else goto cbHpl;
       cbHpl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHpn; else goto cbHpm;
       cbHpn: // global
           HpAlloc = 24;
           goto cbHpk;
       cbHpk: // global
           R1 = _sbHiY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHpm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbHiY::P64;
           _sbHiP::P64 = P64[_sbHiY::P64 + 16];
           I64[Hp - 16] = x_sbHiQ_info;
           P64[Hp] = _sbHiP::P64;
           I64[Sp - 24] = block_cbHpg_info;
           R1 = Hp - 16;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubHpr; else goto cbHph;
       ubHpr: // global
           call _cbHpg(R1) args: 0, res: 0, upd: 0;
       cbHph: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbHpg() //  [R1]
         { info_tbl: [(cbHpg,
                       label: block_cbHpg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHpg: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_entry() //  [R2]
         { info_tbl: [(cbHpt,
                       label: Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHpt: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbHpx; else goto cbHpw;
       cbHpx: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHpw: // global
           I64[Hp - 64] = sat_sbHj4_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbHiY_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.041582035 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixNonEmpty_closure" {
     Control.Monad.Fix.$fMonadFixNonEmpty_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonadNonEmpty_closure;
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.04329836 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixIO_closure" {
     Control.Monad.Fix.$fMonadFixIO_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonadIO_closure;
         const System.IO.fixIO1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.045283646 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix(->)_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFix(->)_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFix(->)_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFix(->)_$cmfix_entry() //  [R2, R3]
         { info_tbl: [(cbHqm,
                       label: Control.Monad.Fix.$fMonadFix(->)_$cmfix_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHqm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbHqq; else goto cbHqp;
       cbHqq: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFix(->)_$cmfix_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbHqp: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R2;
           _cbHql::P64 = Hp - 32;
           P64[Hp - 8] = _cbHql::P64;
           P64[Hp] = R3;
           R1 = _cbHql::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.048958037 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix(->)_closure" {
     Control.Monad.Fix.$fMonadFix(->)_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Base.$fMonad(->)_closure;
         const Control.Monad.Fix.$fMonadFix(->)_$cmfix_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.050990909 UTC

[section ""cstring" . lvl1_rbGDb_bytes" {
     lvl1_rbGDb_bytes:
         I8[] [109,102,105,120,32,69,105,116,104,101,114,58,32,76,101,102,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.052961408 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixEither1_closure" {
     Control.Monad.Fix.$fMonadFixEither1_closure:
         const Control.Monad.Fix.$fMonadFixEither1_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Monad.Fix.$fMonadFixEither1_entry() //  [R1]
         { info_tbl: [(cbHqG,
                       label: Control.Monad.Fix.$fMonadFixEither1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHqG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbHqH; else goto cbHqI;
       cbHqH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHqI: // global
           (_cbHqB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbHqB::I64 == 0) goto cbHqD; else goto cbHqC;
       cbHqD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbHqC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbHqB::I64;
           I64[Sp - 24] = block_cbHqE_info;
           R2 = lvl1_rbGDb_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbHqE() //  [R1]
         { info_tbl: [(cbHqE,
                       label: block_cbHqE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHqE: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.059338839 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixEither_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixEither_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixEither_$cmfix_info;
         const 0;
 },
 sat_sbHje_entry() //  [R1]
         { info_tbl: [(cbHrh,
                       label: sat_sbHje_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHrh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbHri; else goto cbHrj;
       cbHri: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHrj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbHra_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubHrq; else goto cbHrb;
       ubHrq: // global
           call _cbHra(R1) args: 0, res: 0, upd: 0;
       cbHrb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbHra() //  [R1]
         { info_tbl: [(cbHra,
                       label: block_cbHra_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHra: // global
           if (R1 & 7 == 1) goto cbHre; else goto cbHrf;
       cbHre: // global
           R1 = Control.Monad.Fix.$fMonadFixEither1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cbHrf: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 a1_sbHja_entry() //  [R1]
         { info_tbl: [(cbHrr,
                       label: a1_sbHja_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHrr: // global
           _sbHja::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbHrs; else goto cbHrt;
       cbHrt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHrv; else goto cbHru;
       cbHrv: // global
           HpAlloc = 24;
           goto cbHrs;
       cbHrs: // global
           R1 = _sbHja::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHru: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbHja::P64;
           _sbHj9::P64 = P64[_sbHja::P64 + 16];
           I64[Hp - 16] = sat_sbHje_info;
           P64[Hp] = _sbHja::P64;
           R2 = Hp - 16;
           R1 = _sbHj9::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixEither_$cmfix_entry() //  [R2]
         { info_tbl: [(cbHrw,
                       label: Control.Monad.Fix.$fMonadFixEither_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHrw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHrA; else goto cbHrz;
       cbHrA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixEither_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHrz: // global
           I64[Hp - 16] = a1_sbHja_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.069014383 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixEither_closure" {
     Control.Monad.Fix.$fMonadFixEither_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Either.$fMonadEither_closure;
         const Control.Monad.Fix.$fMonadFixEither_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.070840802 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixST_closure" {
     Control.Monad.Fix.$fMonadFixST_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.ST.$fMonadST_closure;
         const GHC.ST.fixST1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.072909063 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixDual_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixDual_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixDual_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFixDual_$cmfix_entry() //  [R2]
         { info_tbl: [(cbHs7,
                       label: Control.Monad.Fix.$fMonadFixDual_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHs7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbHsb; else goto cbHsa;
       cbHsb: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixDual_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHsa: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbHs6::P64 = Hp - 24;
           P64[Hp] = _cbHs6::P64;
           R1 = _cbHs6::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.076636455 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixDual_closure" {
     Control.Monad.Fix.$fMonadFixDual_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Semigroup.Internal.$fMonadDual_closure;
         const Control.Monad.Fix.$fMonadFixDual_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.078856421 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixSum_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixSum_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixSum_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFixSum_$cmfix_entry() //  [R2]
         { info_tbl: [(cbHsn,
                       label: Control.Monad.Fix.$fMonadFixSum_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHsn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbHsr; else goto cbHsq;
       cbHsr: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixSum_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHsq: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbHsm::P64 = Hp - 24;
           P64[Hp] = _cbHsm::P64;
           R1 = _cbHsm::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.082513693 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixSum_closure" {
     Control.Monad.Fix.$fMonadFixSum_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Semigroup.Internal.$fMonadSum_closure;
         const Control.Monad.Fix.$fMonadFixSum_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.08441036 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixProduct_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixProduct_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixProduct_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFixProduct_$cmfix_entry() //  [R2]
         { info_tbl: [(cbHsD,
                       label: Control.Monad.Fix.$fMonadFixProduct_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHsD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbHsH; else goto cbHsG;
       cbHsH: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixProduct_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHsG: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbHsC::P64 = Hp - 24;
           P64[Hp] = _cbHsC::P64;
           R1 = _cbHsC::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.088499035 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixProduct_closure" {
     Control.Monad.Fix.$fMonadFixProduct_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Semigroup.Internal.$fMonadProduct_closure;
         const Control.Monad.Fix.$fMonadFixProduct_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.091380414 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixFirst_$cmfix_info;
         const 0;
 },
 sat_sbHjp_entry() //  [R1]
         { info_tbl: [(cbHt7,
                       label: sat_sbHjp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHt7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbHt8; else goto cbHt9;
       cbHt8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHt9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbHt0_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubHtg; else goto cbHt1;
       ubHtg: // global
           call _cbHt0(R1) args: 0, res: 0, upd: 0;
       cbHt1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbHt0() //  [R1]
         { info_tbl: [(cbHt0,
                       label: block_cbHt0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHt0: // global
           if (R1 & 7 == 1) goto cbHt4; else goto cbHt5;
       cbHt4: // global
           R1 = Control.Monad.Fix.$fMonadFixFirst1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cbHt5: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 a1_sbHjm_entry() //  [R1]
         { info_tbl: [(cbHth,
                       label: a1_sbHjm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHth: // global
           _sbHjm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbHti; else goto cbHtj;
       cbHtj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHtl; else goto cbHtk;
       cbHtl: // global
           HpAlloc = 24;
           goto cbHti;
       cbHti: // global
           R1 = _sbHjm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHtk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbHjm::P64;
           _sbHjl::P64 = P64[_sbHjm::P64 + 16];
           I64[Hp - 16] = sat_sbHjp_info;
           P64[Hp] = _sbHjm::P64;
           R2 = Hp - 16;
           R1 = _sbHjl::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixFirst_$cmfix_entry() //  [R2]
         { info_tbl: [(cbHtm,
                       label: Control.Monad.Fix.$fMonadFixFirst_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHtm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHtq; else goto cbHtp;
       cbHtq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHtp: // global
           I64[Hp - 16] = a1_sbHjm_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.100623172 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixFirst_closure" {
     Control.Monad.Fix.$fMonadFixFirst_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Monoid.$fMonadFirst_closure;
         const Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.103025366 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixLast_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixLast_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixLast_$cmfix_info;
         const 0;
 },
 sat_sbHju_entry() //  [R1]
         { info_tbl: [(cbHua,
                       label: sat_sbHju_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHua: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbHub; else goto cbHuc;
       cbHub: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHuc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbHu3_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubHuj; else goto cbHu4;
       ubHuj: // global
           call _cbHu3(R1) args: 0, res: 0, upd: 0;
       cbHu4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbHu3() //  [R1]
         { info_tbl: [(cbHu3,
                       label: block_cbHu3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHu3: // global
           if (R1 & 7 == 1) goto cbHu7; else goto cbHu8;
       cbHu7: // global
           R1 = Control.Monad.Fix.$fMonadFixFirst1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cbHu8: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 a1_sbHjr_entry() //  [R1]
         { info_tbl: [(cbHuk,
                       label: a1_sbHjr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHuk: // global
           _sbHjr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbHul; else goto cbHum;
       cbHum: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHuo; else goto cbHun;
       cbHuo: // global
           HpAlloc = 24;
           goto cbHul;
       cbHul: // global
           R1 = _sbHjr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHun: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbHjr::P64;
           _sbHjq::P64 = P64[_sbHjr::P64 + 16];
           I64[Hp - 16] = sat_sbHju_info;
           P64[Hp] = _sbHjr::P64;
           R2 = Hp - 16;
           R1 = _sbHjq::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixLast_$cmfix_entry() //  [R2]
         { info_tbl: [(cbHup,
                       label: Control.Monad.Fix.$fMonadFixLast_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHup: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHut; else goto cbHus;
       cbHut: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixLast_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHus: // global
           I64[Hp - 16] = a1_sbHjr_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.112727009 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixLast_closure" {
     Control.Monad.Fix.$fMonadFixLast_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const Data.Monoid.$fMonadLast_closure;
         const Control.Monad.Fix.$fMonadFixLast_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.114847931 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixAlt1_closure" {
     Control.Monad.Fix.$fMonadFixAlt1_closure:
         const Control.Monad.Fix.$fMonadFixAlt1_info;
 },
 sat_sbHjy_entry() //  [R1, R2]
         { info_tbl: [(cbHv3,
                       label: sat_sbHjy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHv3: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.Fix.$fMonadFixAlt1_entry() //  [R2, R3]
         { info_tbl: [(cbHv6,
                       label: Control.Monad.Fix.$fMonadFixAlt1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHv6: // global
           _sbHjw::P64 = R3;
           _sbHjv::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbHv7; else goto cbHv8;
       cbHv8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbHva; else goto cbHv9;
       cbHva: // global
           HpAlloc = 16;
           goto cbHv7;
       cbHv7: // global
           R3 = _sbHjw::P64;
           R2 = _sbHjv::P64;
           R1 = Control.Monad.Fix.$fMonadFixAlt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbHv9: // global
           I64[Hp - 8] = sat_sbHjy_info;
           P64[Hp] = _sbHjw::P64;
           R2 = _sbHjv::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.mfix_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.120388944 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_closure" {
     Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_closure:
         const Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_info;
 },
 sat_sbHjA_entry() //  [R1]
         { info_tbl: [(cbHvu,
                       label: sat_sbHjA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHvu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbHvv; else goto cbHvw;
       cbHvv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHvw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_entry() //  [R2]
         { info_tbl: [(cbHvx,
                       label: Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHvx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHvB; else goto cbHvA;
       cbHvB: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHvA: // global
           I64[Hp - 16] = sat_sbHjA_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fMonadAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.12696704 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixAlt_closure" {
     Control.Monad.Fix.$fMonadFixAlt_closure:
         const Control.Monad.Fix.$fMonadFixAlt_info;
 },
 sat_sbHjD_entry() //  [R1, R2]
         { info_tbl: [(cbHvV,
                       label: sat_sbHjD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHvV: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Fix.$fMonadFixAlt1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbHjC_entry() //  [R1]
         { info_tbl: [(cbHw2,
                       label: sat_sbHjC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHw2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbHw3; else goto cbHw4;
       cbHw3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHw4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixAlt_$cp1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixAlt_entry() //  [R2]
         { info_tbl: [(cbHw6,
                       label: Control.Monad.Fix.$fMonadFixAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHw6: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbHwa; else goto cbHw9;
       cbHwa: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHw9: // global
           I64[Hp - 56] = sat_sbHjD_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbHjC_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.134363994 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixPar1_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFixPar1_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFixPar1_$cmfix_info;
 },
 Control.Monad.Fix.$fMonadFixPar1_$cmfix_entry() //  [R2]
         { info_tbl: [(cbHwy,
                       label: Control.Monad.Fix.$fMonadFixPar1_$cmfix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHwy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbHwC; else goto cbHwB;
       cbHwC: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixPar1_$cmfix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHwB: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           _cbHwx::P64 = Hp - 24;
           P64[Hp] = _cbHwx::P64;
           R1 = _cbHwx::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.13803912 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixPar1_closure" {
     Control.Monad.Fix.$fMonadFixPar1_closure:
         const Control.Monad.Fix.C:MonadFix_con_info;
         const GHC.Generics.$fMonadPar1_closure;
         const Control.Monad.Fix.$fMonadFixPar1_$cmfix_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.140050376 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixRec2_closure" {
     Control.Monad.Fix.$fMonadFixRec2_closure:
         const Control.Monad.Fix.$fMonadFixRec2_info;
 },
 sat_sbHjJ_entry() //  [R1, R2]
         { info_tbl: [(cbHwS,
                       label: sat_sbHjJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHwS: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.Fix.$fMonadFixRec2_entry() //  [R2, R3]
         { info_tbl: [(cbHwV,
                       label: Control.Monad.Fix.$fMonadFixRec2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHwV: // global
           _sbHjH::P64 = R3;
           _sbHjG::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbHwW; else goto cbHwX;
       cbHwX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbHwZ; else goto cbHwY;
       cbHwZ: // global
           HpAlloc = 16;
           goto cbHwW;
       cbHwW: // global
           R3 = _sbHjH::P64;
           R2 = _sbHjG::P64;
           R1 = Control.Monad.Fix.$fMonadFixRec2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbHwY: // global
           I64[Hp - 8] = sat_sbHjJ_info;
           P64[Hp] = _sbHjH::P64;
           R2 = _sbHjG::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.mfix_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.145719904 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_closure" {
     Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_closure:
         const Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_info;
         const 0;
 },
 sat_sbHjL_entry() //  [R1]
         { info_tbl: [(cbHxj,
                       label: sat_sbHjL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHxj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbHxk; else goto cbHxl;
       cbHxk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHxl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_entry() //  [R2]
         { info_tbl: [(cbHxm,
                       label: Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHxm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHxq; else goto cbHxp;
       cbHxq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHxp: // global
           I64[Hp - 16] = sat_sbHjL_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadRec1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.151408638 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixRec1_closure" {
     Control.Monad.Fix.$fMonadFixRec1_closure:
         const Control.Monad.Fix.$fMonadFixRec1_info;
         const 0;
 },
 sat_sbHjO_entry() //  [R1, R2]
         { info_tbl: [(cbHxK,
                       label: sat_sbHjO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHxK: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Fix.$fMonadFixRec2_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbHjN_entry() //  [R1]
         { info_tbl: [(cbHxR,
                       label: sat_sbHjN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHxR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbHxS; else goto cbHxT;
       cbHxS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHxT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixRec1_entry() //  [R2]
         { info_tbl: [(cbHxV,
                       label: Control.Monad.Fix.$fMonadFixRec1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHxV: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbHxZ; else goto cbHxY;
       cbHxZ: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixRec1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHxY: // global
           I64[Hp - 56] = sat_sbHjO_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbHjN_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.159199124 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixM2_closure" {
     Control.Monad.Fix.$fMonadFixM2_closure:
         const Control.Monad.Fix.$fMonadFixM2_info;
 },
 sat_sbHjS_entry() //  [R1, R2]
         { info_tbl: [(cbHyr,
                       label: sat_sbHjS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHyr: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.Fix.$fMonadFixM2_entry() //  [R2, R3]
         { info_tbl: [(cbHyu,
                       label: Control.Monad.Fix.$fMonadFixM2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHyu: // global
           _sbHjQ::P64 = R3;
           _sbHjP::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbHyv; else goto cbHyw;
       cbHyw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbHyy; else goto cbHyx;
       cbHyy: // global
           HpAlloc = 16;
           goto cbHyv;
       cbHyv: // global
           R3 = _sbHjQ::P64;
           R2 = _sbHjP::P64;
           R1 = Control.Monad.Fix.$fMonadFixM2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbHyx: // global
           I64[Hp - 8] = sat_sbHjS_info;
           P64[Hp] = _sbHjQ::P64;
           R2 = _sbHjP::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Monad.Fix.mfix_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.165142691 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_closure" {
     Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_closure:
         const Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_info;
 },
 sat_sbHjU_entry() //  [R1]
         { info_tbl: [(cbHyS,
                       label: sat_sbHjU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHyS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbHyT; else goto cbHyU;
       cbHyT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHyU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_entry() //  [R2]
         { info_tbl: [(cbHyV,
                       label: Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHyV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHyZ; else goto cbHyY;
       cbHyZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHyY: // global
           I64[Hp - 16] = sat_sbHjU_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.170830193 UTC

[section ""data" . Control.Monad.Fix.$fMonadFixM1_closure" {
     Control.Monad.Fix.$fMonadFixM1_closure:
         const Control.Monad.Fix.$fMonadFixM1_info;
 },
 sat_sbHjX_entry() //  [R1, R2]
         { info_tbl: [(cbHzj,
                       label: sat_sbHjX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHzj: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Fix.$fMonadFixM2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbHjW_entry() //  [R1]
         { info_tbl: [(cbHzq,
                       label: sat_sbHjW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHzq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbHzr; else goto cbHzs;
       cbHzr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHzs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFixM1_$cp1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFixM1_entry() //  [R2]
         { info_tbl: [(cbHzu,
                       label: Control.Monad.Fix.$fMonadFixM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHzu: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbHzy; else goto cbHzx;
       cbHzy: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFixM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHzx: // global
           I64[Hp - 56] = sat_sbHjX_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbHjW_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.179180255 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix:*:_$cmfix_closure" {
     Control.Monad.Fix.$fMonadFix:*:_$cmfix_closure:
         const Control.Monad.Fix.$fMonadFix:*:_$cmfix_info;
 },
 sat_sbHkb_entry() //  [R1, R2]
         { info_tbl: [(cbHA6,
                       label: sat_sbHkb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHA6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbHA7; else goto cbHA8;
       cbHA7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHA8: // global
           I64[Sp - 8] = block_cbHA4_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbHA4() //  [R1]
         { info_tbl: [(cbHA4,
                       label: block_cbHA4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHA4: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbHkc_entry() //  [R1]
         { info_tbl: [(cbHAc,
                       label: sat_sbHkc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHAc: // global
           _sbHkc::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbHAd; else goto cbHAe;
       cbHAe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbHAg; else goto cbHAf;
       cbHAg: // global
           HpAlloc = 16;
           goto cbHAd;
       cbHAd: // global
           R1 = _sbHkc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHAf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbHkc::P64;
           _sbHjZ::P64 = P64[_sbHkc::P64 + 16];
           _sbHk0::P64 = P64[_sbHkc::P64 + 24];
           I64[Hp - 8] = sat_sbHkb_info;
           P64[Hp] = _sbHk0::P64;
           R2 = _sbHjZ::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbHk5_entry() //  [R1, R2]
         { info_tbl: [(cbHAs,
                       label: sat_sbHk5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHAs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbHAt; else goto cbHAu;
       cbHAt: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHAu: // global
           I64[Sp - 8] = block_cbHAq_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbHAq() //  [R1]
         { info_tbl: [(cbHAq,
                       label: block_cbHAq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHAq: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbHk6_entry() //  [R1]
         { info_tbl: [(cbHAy,
                       label: sat_sbHk6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHAy: // global
           _sbHk6::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbHAz; else goto cbHAA;
       cbHAA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbHAC; else goto cbHAB;
       cbHAC: // global
           HpAlloc = 16;
           goto cbHAz;
       cbHAz: // global
           R1 = _sbHk6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHAB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbHk6::P64;
           _sbHjY::P64 = P64[_sbHk6::P64 + 16];
           _sbHk0::P64 = P64[_sbHk6::P64 + 24];
           I64[Hp - 8] = sat_sbHk5_info;
           P64[Hp] = _sbHk0::P64;
           R2 = _sbHjY::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Monad.Fix.mfix_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFix:*:_$cmfix_entry() //  [R2, R3, R4]
         { info_tbl: [(cbHAE,
                       label: Control.Monad.Fix.$fMonadFix:*:_$cmfix_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHAE: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbHAI; else goto cbHAH;
       cbHAI: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFix:*:_$cmfix_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbHAH: // global
           I64[Hp - 80] = sat_sbHkc_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           I64[Hp - 48] = sat_sbHk6_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.194671413 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_closure" {
     Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_closure:
         const Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_info;
         const 0;
 },
 sat_sbHkg_entry() //  [R1]
         { info_tbl: [(cbHBx,
                       label: sat_sbHkg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHBx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbHBy; else goto cbHBz;
       cbHBy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHBz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbHkf_entry() //  [R1]
         { info_tbl: [(cbHBE,
                       label: sat_sbHkf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHBE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbHBF; else goto cbHBG;
       cbHBF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHBG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$p1MonadFix_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_entry() //  [R2, R3]
         { info_tbl: [(cbHBH,
                       label: Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHBH: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbHBL; else goto cbHBK;
       cbHBL: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbHBK: // global
           I64[Hp - 40] = sat_sbHkg_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbHkf_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fMonad:*:_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.203154215 UTC

[section ""data" . Control.Monad.Fix.$fMonadFix:*:_closure" {
     Control.Monad.Fix.$fMonadFix:*:_closure:
         const Control.Monad.Fix.$fMonadFix:*:_info;
         const 0;
 },
 sat_sbHkk_entry() //  [R1, R2]
         { info_tbl: [(cbHCb,
                       label: sat_sbHkk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHCb: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Monad.Fix.$fMonadFix:*:_$cmfix_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbHkj_entry() //  [R1]
         { info_tbl: [(cbHCi,
                       label: sat_sbHkj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHCi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbHCj; else goto cbHCk;
       cbHCj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHCk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_entry(R3,
                                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.Fix.$fMonadFix:*:_entry() //  [R2, R3]
         { info_tbl: [(cbHCm,
                       label: Control.Monad.Fix.$fMonadFix:*:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHCm: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbHCq; else goto cbHCp;
       cbHCq: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.$fMonadFix:*:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbHCp: // global
           I64[Hp - 72] = sat_sbHkk_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sbHkj_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 71;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.210494229 UTC

[section ""cstring" . Control.Monad.Fix.$trModule4_bytes" {
     Control.Monad.Fix.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.212138948 UTC

[section ""data" . Control.Monad.Fix.$trModule3_closure" {
     Control.Monad.Fix.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Fix.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.213873346 UTC

[section ""cstring" . Control.Monad.Fix.$trModule2_bytes" {
     Control.Monad.Fix.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100,46,70,105,120]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.215557032 UTC

[section ""data" . Control.Monad.Fix.$trModule1_closure" {
     Control.Monad.Fix.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Fix.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.217220797 UTC

[section ""data" . Control.Monad.Fix.$trModule_closure" {
     Control.Monad.Fix.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.Fix.$trModule3_closure+1;
         const Control.Monad.Fix.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.219323337 UTC

[section ""data" . $krep_rbGDc_closure" {
     $krep_rbGDc_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.221068864 UTC

[section ""data" . Control.Monad.Fix.$tcMonadFix1_closure" {
     Control.Monad.Fix.$tcMonadFix1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep_rbGDc_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.222792417 UTC

[section ""cstring" . Control.Monad.Fix.$tcMonadFix3_bytes" {
     Control.Monad.Fix.$tcMonadFix3_bytes:
         I8[] [77,111,110,97,100,70,105,120]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.224435062 UTC

[section ""data" . Control.Monad.Fix.$tcMonadFix2_closure" {
     Control.Monad.Fix.$tcMonadFix2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Fix.$tcMonadFix3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.226658804 UTC

[section ""data" . Control.Monad.Fix.$tcMonadFix_closure" {
     Control.Monad.Fix.$tcMonadFix_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.Fix.$trModule_closure+1;
         const Control.Monad.Fix.$tcMonadFix2_closure+1;
         const Control.Monad.Fix.$tcMonadFix1_closure+4;
         const 9994897379720692231;
         const 15179622530544898162;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.228819441 UTC

[section ""data" . Control.Monad.Fix.C:MonadFix_closure" {
     Control.Monad.Fix.C:MonadFix_closure:
         const Control.Monad.Fix.C:MonadFix_info;
 },
 Control.Monad.Fix.C:MonadFix_entry() //  [R2, R3]
         { info_tbl: [(cbHCY,
                       label: Control.Monad.Fix.C:MonadFix_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHCY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHD2; else goto cbHD1;
       cbHD2: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Fix.C:MonadFix_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbHD1: // global
           I64[Hp - 16] = Control.Monad.Fix.C:MonadFix_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.23264165 UTC

[Control.Monad.Fix.C:MonadFix_con_entry() //  [R1]
         { info_tbl: [(cbHD9,
                       label: Control.Monad.Fix.C:MonadFix_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,67,111,110,116,114,111,108,46,77,111,110,97,100,46,70,105,120,46,67,58,77,111,110,97,100,70,105,120]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHD9: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:35.236345243 UTC

[section ""relreadonly" . SbHlo_srt" {
     SbHlo_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Control.Monad.Fix.$fMonadFixFirst1_closure;
         const Control.Monad.Fix.$fMonadFixMaybe_$cmfix_closure;
         const GHC.List.head_closure;
         const GHC.List.scanl2_closure;
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix1_closure;
         const Control.Monad.Fix.$fMonadFixNonEmpty_$cmfix_closure;
         const Control.Monad.Fix.$fMonadFixEither1_closure;
         const Control.Monad.Fix.$fMonadFixEither_$cmfix_closure;
         const Control.Monad.Fix.$fMonadFixFirst_$cmfix_closure;
         const Control.Monad.Fix.$fMonadFixLast_$cmfix_closure;
         const GHC.Generics.$fMonadRec1_closure;
         const Control.Monad.Fix.$fMonadFixRec1_$cp1MonadFix_closure;
         const Control.Monad.Fix.$fMonadFixRec1_closure;
         const GHC.Generics.$fMonad:*:_closure;
         const Control.Monad.Fix.$fMonadFix:*:_$cp1MonadFix_closure;
         const Control.Monad.Fix.$fMonadFix:*:_closure;
 }]

