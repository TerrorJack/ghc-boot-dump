
==================== Raw Cmm ====================
2018-03-16 16:08:39.676093594 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:08:39.678133241 UTC

[section ""data" . Control.Monad.Zip.$p1MonadZip_closure" {
     Control.Monad.Zip.$p1MonadZip_closure:
         const Control.Monad.Zip.$p1MonadZip_info;
 },
 Control.Monad.Zip.$p1MonadZip_entry() //  [R2]
         { []
         }
     {offset
       cduDF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cduDG; else goto cduDH;
       cduDG: // global
           R2 = R2;
           R1 = Control.Monad.Zip.$p1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduDH: // global
           I64[Sp - 8] = block_cduDC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uduDL; else goto cduDD;
       uduDL: // global
           call _cduDC(R1) args: 0, res: 0, upd: 0;
       cduDD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$p1MonadZip_info" {
     Control.Monad.Zip.$p1MonadZip_info:
         const Control.Monad.Zip.$p1MonadZip_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cduDC() //  [R1]
         { []
         }
     {offset
       cduDC: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cduDC_info" {
     block_cduDC_info:
         const _cduDC;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.684271977 UTC

[section ""data" . Control.Monad.Zip.mzip_closure" {
     Control.Monad.Zip.mzip_closure:
         const Control.Monad.Zip.mzip_info;
 },
 Control.Monad.Zip.mzip_entry() //  [R2]
         { []
         }
     {offset
       cduE4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cduE5; else goto cduE6;
       cduE5: // global
           R2 = R2;
           R1 = Control.Monad.Zip.mzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduE6: // global
           I64[Sp - 8] = block_cduE1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uduEa; else goto cduE2;
       uduEa: // global
           call _cduE1(R1) args: 0, res: 0, upd: 0;
       cduE2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.mzip_info" {
     Control.Monad.Zip.mzip_info:
         const Control.Monad.Zip.mzip_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cduE1() //  [R1]
         { []
         }
     {offset
       cduE1: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cduE1_info" {
     block_cduE1_info:
         const _cduE1;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.690418954 UTC

[section ""data" . Control.Monad.Zip.mzipWith_closure" {
     Control.Monad.Zip.mzipWith_closure:
         const Control.Monad.Zip.mzipWith_info;
 },
 Control.Monad.Zip.mzipWith_entry() //  [R2]
         { []
         }
     {offset
       cduEr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cduEs; else goto cduEt;
       cduEs: // global
           R2 = R2;
           R1 = Control.Monad.Zip.mzipWith_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduEt: // global
           I64[Sp - 8] = block_cduEo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uduEx; else goto cduEp;
       uduEx: // global
           call _cduEo(R1) args: 0, res: 0, upd: 0;
       cduEp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.mzipWith_info" {
     Control.Monad.Zip.mzipWith_info:
         const Control.Monad.Zip.mzipWith_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cduEo() //  [R1]
         { []
         }
     {offset
       cduEo: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cduEo_info" {
     block_cduEo_info:
         const _cduEo;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.695713691 UTC

[section ""data" . Control.Monad.Zip.munzip_closure" {
     Control.Monad.Zip.munzip_closure:
         const Control.Monad.Zip.munzip_info;
 },
 Control.Monad.Zip.munzip_entry() //  [R2]
         { []
         }
     {offset
       cduEO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cduEP; else goto cduEQ;
       cduEP: // global
           R2 = R2;
           R1 = Control.Monad.Zip.munzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduEQ: // global
           I64[Sp - 8] = block_cduEL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uduEU; else goto cduEM;
       uduEU: // global
           call _cduEL(R1) args: 0, res: 0, upd: 0;
       cduEM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.munzip_info" {
     Control.Monad.Zip.munzip_info:
         const Control.Monad.Zip.munzip_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cduEL() //  [R1]
         { []
         }
     {offset
       cduEL: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cduEL_info" {
     block_cduEL_info:
         const _cduEL;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.700999185 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip[]_closure" {
     Control.Monad.Zip.$fMonadZip[]_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Base.$fMonad[]_closure;
         const GHC.List.zip_closure+2;
         const GHC.List.zipWith_closure+3;
         const GHC.List.unzip_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.706298763 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip3_closure" {
     Control.Monad.Zip.$w$cmunzip3_closure:
         const Control.Monad.Zip.$w$cmunzip3_info;
 },
 sat_sdtJ7_entry() //  [R1]
         { []
         }
     {offset
       cduFg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduFh; else goto cduFi;
       cduFh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduFi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cduFd_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduFm; else goto cduFe;
       uduFm: // global
           call _cduFd(R1) args: 0, res: 0, upd: 0;
       cduFe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtJ7_info" {
     sat_sdtJ7_info:
         const sat_sdtJ7_entry;
         const 1;
         const 16;
 },
 _cduFd() //  [R1]
         { []
         }
     {offset
       cduFd: // global
           R3 = P64[R1 + 15];
           R2 = Data.Tuple.snd_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cduFd_info" {
     block_cduFd_info:
         const _cduFd;
         const 0;
         const 30;
 },
 sat_sdtJ3_entry() //  [R1]
         { []
         }
     {offset
       cduFu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduFy; else goto cduFz;
       cduFy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduFz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cduFr_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduFH; else goto cduFs;
       uduFH: // global
           call _cduFr(R1) args: 0, res: 0, upd: 0;
       cduFs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtJ3_info" {
     sat_sdtJ3_info:
         const sat_sdtJ3_entry;
         const 1;
         const 16;
 },
 _cduFr() //  [R1]
         { []
         }
     {offset
       cduFr: // global
           I64[Sp] = block_cduFx_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto uduFG; else goto cduFB;
       uduFG: // global
           call _cduFx(R1) args: 0, res: 0, upd: 0;
       cduFB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cduFr_info" {
     block_cduFr_info:
         const _cduFr;
         const 0;
         const 30;
 },
 _cduFx() //  [R1]
         { []
         }
     {offset
       cduFx: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cduFx_info" {
     block_cduFx_info:
         const _cduFx;
         const 0;
         const 30;
 },
 sat_sdtIV_entry() //  [R1]
         { []
         }
     {offset
       cduFQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduFR; else goto cduFS;
       cduFR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduFS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cduFN_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduFW; else goto cduFO;
       uduFW: // global
           call _cduFN(R1) args: 0, res: 0, upd: 0;
       cduFO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtIV_info" {
     sat_sdtIV_info:
         const sat_sdtIV_entry;
         const 1;
         const 16;
 },
 _cduFN() //  [R1]
         { []
         }
     {offset
       cduFN: // global
           R3 = P64[R1 + 15];
           R2 = Data.Tuple.fst_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cduFN_info" {
     block_cduFN_info:
         const _cduFN;
         const 0;
         const 30;
 },
 sat_sdtIR_entry() //  [R1]
         { []
         }
     {offset
       cduG4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduG8; else goto cduG9;
       cduG8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduG9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cduG1_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduGh; else goto cduG2;
       uduGh: // global
           call _cduG1(R1) args: 0, res: 0, upd: 0;
       cduG2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtIR_info" {
     sat_sdtIR_info:
         const sat_sdtIR_entry;
         const 1;
         const 16;
 },
 _cduG1() //  [R1]
         { []
         }
     {offset
       cduG1: // global
           I64[Sp] = block_cduG7_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto uduGg; else goto cduGb;
       uduGg: // global
           call _cduG7(R1) args: 0, res: 0, upd: 0;
       cduGb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cduG1_info" {
     block_cduG1_info:
         const _cduG1;
         const 0;
         const 30;
 },
 _cduG7() //  [R1]
         { []
         }
     {offset
       cduG7: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cduG7_info" {
     block_cduG7_info:
         const _cduG7;
         const 0;
         const 30;
 },
 Control.Monad.Zip.$w$cmunzip3_entry() //  [R2]
         { []
         }
     {offset
       cduGj: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cduGn; else goto cduGm;
       cduGn: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduGm: // global
           I64[Hp - 136] = sat_sdtJ7_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sdtJ3_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = GHC.Base.:|_con_info;
           P64[Hp - 80] = Hp - 112;
           P64[Hp - 72] = Hp - 136;
           I64[Hp - 64] = sat_sdtIV_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdtIR_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = Hp - 87;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$w$cmunzip3_info" {
     Control.Monad.Zip.$w$cmunzip3_info:
         const Control.Monad.Zip.$w$cmunzip3_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.727237668 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_entry() //  [R2]
         { []
         }
     {offset
       cduHi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cduHj; else goto cduHk;
       cduHj: // global
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduHk: // global
           I64[Sp - 8] = block_cduHf_info;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cduHf() //  [R1, R2]
         { []
         }
     {offset
       cduHf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduHn; else goto cduHm;
       cduHn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cduHm: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cduHf_info" {
     block_cduHf_info:
         const _cduHf;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.732071062 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipNonEmpty_closure" {
     Control.Monad.Zip.$fMonadZipNonEmpty_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Base.$fMonadNonEmpty_closure;
         const Data.List.NonEmpty.zip_closure+2;
         const Data.List.NonEmpty.zipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.734283149 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_entry() //  [R2]
         { []
         }
     {offset
       cduHC: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.738348878 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipIdentity1_closure" {
     Control.Monad.Zip.$fMonadZipIdentity1_closure:
         const Control.Monad.Zip.$fMonadZipIdentity1_info;
 },
 Control.Monad.Zip.$fMonadZipIdentity1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cduHP: // global
           _sdtJi::P64 = R3;
           R3 = R4;
           _sdtJh::P64 = R2;
           R2 = _sdtJi::P64;
           R1 = _sdtJh::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipIdentity1_info" {
     Control.Monad.Zip.$fMonadZipIdentity1_info:
         const Control.Monad.Zip.$fMonadZipIdentity1_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.742366716 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipDual1_closure" {
     Control.Monad.Zip.$fMonadZipDual1_closure:
         const Control.Monad.Zip.$fMonadZipDual1_info;
 },
 Control.Monad.Zip.$fMonadZipDual1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cduI0: // global
           _sdtJl::P64 = R3;
           R3 = R4;
           _sdtJk::P64 = R2;
           R2 = _sdtJl::P64;
           R1 = _sdtJk::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipDual1_info" {
     Control.Monad.Zip.$fMonadZipDual1_info:
         const Control.Monad.Zip.$fMonadZipDual1_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.745940748 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipSum1_closure" {
     Control.Monad.Zip.$fMonadZipSum1_closure:
         const Control.Monad.Zip.$fMonadZipSum1_info;
 },
 Control.Monad.Zip.$fMonadZipSum1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cduIb: // global
           _sdtJo::P64 = R3;
           R3 = R4;
           _sdtJn::P64 = R2;
           R2 = _sdtJo::P64;
           R1 = _sdtJn::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipSum1_info" {
     Control.Monad.Zip.$fMonadZipSum1_info:
         const Control.Monad.Zip.$fMonadZipSum1_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.749811324 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProduct1_closure" {
     Control.Monad.Zip.$fMonadZipProduct1_closure:
         const Control.Monad.Zip.$fMonadZipProduct1_info;
 },
 Control.Monad.Zip.$fMonadZipProduct1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cduIm: // global
           _sdtJr::P64 = R3;
           R3 = R4;
           _sdtJq::P64 = R2;
           R2 = _sdtJr::P64;
           R1 = _sdtJq::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipProduct1_info" {
     Control.Monad.Zip.$fMonadZipProduct1_info:
         const Control.Monad.Zip.$fMonadZipProduct1_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.754604238 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_info;
 },
 Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_entry() //  [R2, R3,
                                                           R4]
         { []
         }
     {offset
       cduIE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduIF; else goto cduIG;
       cduIF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduIG: // global
           I64[Sp - 24] = block_cduIx_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduJ8; else goto cduIy;
       uduJ8: // global
           call _cduIx(R1) args: 0, res: 0, upd: 0;
       cduIy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_info" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_info:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cduIx() //  [R1]
         { []
         }
     {offset
       cduIx: // global
           if (R1 & 7 == 1) goto uduJ4; else goto cduIC;
       uduJ4: // global
           Sp = Sp + 24;
           call _cduIU() args: 0, res: 0, upd: 0;
       cduIC: // global
           I64[Sp] = block_cduIM_info;
           _sdtJx::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdtJx::P64;
           if (R1 & 7 != 0) goto uduJ6; else goto cduIO;
       uduJ6: // global
           call _cduIM(R1) args: 0, res: 0, upd: 0;
       cduIO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cduIx_info" {
     block_cduIx_info:
         const _cduIx;
         const 2;
         const 30;
 },
 _cduIM() //  [R1]
         { []
         }
     {offset
       cduIM: // global
           if (R1 & 7 == 1) goto uduJ5; else goto cduIZ;
       uduJ5: // global
           Sp = Sp + 24;
           call _cduIU() args: 0, res: 0, upd: 0;
       cduIZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cduJ2; else goto cduJ1;
       cduJ2: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cduJ1: // global
           _sdtJz::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sdtJz::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cduIM_info" {
     block_cduIM_info:
         const _cduIM;
         const 2;
         const 30;
 },
 _cduIU() //  []
         { []
         }
     {offset
       cduIU: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.76397223 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst1_closure" {
     Control.Monad.Zip.$fMonadZipFirst1_closure:
         const Control.Monad.Zip.$fMonadZipFirst1_info;
 },
 Control.Monad.Zip.$fMonadZipFirst1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cduJJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduJK; else goto cduJL;
       cduJK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipFirst1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduJL: // global
           I64[Sp - 24] = block_cduJC_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduKd; else goto cduJD;
       uduKd: // global
           call _cduJC(R1) args: 0, res: 0, upd: 0;
       cduJD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipFirst1_info" {
     Control.Monad.Zip.$fMonadZipFirst1_info:
         const Control.Monad.Zip.$fMonadZipFirst1_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cduJC() //  [R1]
         { []
         }
     {offset
       cduJC: // global
           if (R1 & 7 == 1) goto uduK9; else goto cduJH;
       uduK9: // global
           Sp = Sp + 24;
           call _cduJZ() args: 0, res: 0, upd: 0;
       cduJH: // global
           I64[Sp] = block_cduJR_info;
           _sdtJF::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdtJF::P64;
           if (R1 & 7 != 0) goto uduKb; else goto cduJT;
       uduKb: // global
           call _cduJR(R1) args: 0, res: 0, upd: 0;
       cduJT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cduJC_info" {
     block_cduJC_info:
         const _cduJC;
         const 2;
         const 30;
 },
 _cduJR() //  [R1]
         { []
         }
     {offset
       cduJR: // global
           if (R1 & 7 == 1) goto uduKa; else goto cduK4;
       uduKa: // global
           Sp = Sp + 24;
           call _cduJZ() args: 0, res: 0, upd: 0;
       cduK4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cduK7; else goto cduK6;
       cduK7: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cduK6: // global
           _sdtJH::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sdtJH::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cduJR_info" {
     block_cduJR_info:
         const _cduJR;
         const 2;
         const 30;
 },
 _cduJZ() //  []
         { []
         }
     {offset
       cduJZ: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.774065444 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast1_closure" {
     Control.Monad.Zip.$fMonadZipLast1_closure:
         const Control.Monad.Zip.$fMonadZipLast1_info;
 },
 Control.Monad.Zip.$fMonadZipLast1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cduKO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cduKP; else goto cduKQ;
       cduKP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipLast1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduKQ: // global
           I64[Sp - 24] = block_cduKH_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uduLi; else goto cduKI;
       uduLi: // global
           call _cduKH(R1) args: 0, res: 0, upd: 0;
       cduKI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipLast1_info" {
     Control.Monad.Zip.$fMonadZipLast1_info:
         const Control.Monad.Zip.$fMonadZipLast1_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cduKH() //  [R1]
         { []
         }
     {offset
       cduKH: // global
           if (R1 & 7 == 1) goto uduLe; else goto cduKM;
       uduLe: // global
           Sp = Sp + 24;
           call _cduL4() args: 0, res: 0, upd: 0;
       cduKM: // global
           I64[Sp] = block_cduKW_info;
           _sdtJN::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdtJN::P64;
           if (R1 & 7 != 0) goto uduLg; else goto cduKY;
       uduLg: // global
           call _cduKW(R1) args: 0, res: 0, upd: 0;
       cduKY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cduKH_info" {
     block_cduKH_info:
         const _cduKH;
         const 2;
         const 30;
 },
 _cduKW() //  [R1]
         { []
         }
     {offset
       cduKW: // global
           if (R1 & 7 == 1) goto uduLf; else goto cduL9;
       uduLf: // global
           Sp = Sp + 24;
           call _cduL4() args: 0, res: 0, upd: 0;
       cduL9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cduLc; else goto cduLb;
       cduLc: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cduLb: // global
           _sdtJP::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sdtJP::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cduKW_info" {
     block_cduKW_info:
         const _cduKW;
         const 2;
         const 30;
 },
 _cduL4() //  []
         { []
         }
     {offset
       cduL4: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.783218786 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_info;
 },
 sat_sdtJS_entry() //  [R1]
         { []
         }
     {offset
       cduLQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduLR; else goto cduLS;
       cduLR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduLS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtJS_info" {
     sat_sdtJS_info:
         const sat_sdtJS_entry;
         const 1;
         const 16;
 },
 Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_entry() //  [R2]
         { []
         }
     {offset
       cduLT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduLX; else goto cduLW;
       cduLX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduLW: // global
           I64[Hp - 16] = sat_sdtJS_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fMonadAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_info" {
     Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_info:
         const Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.788673197 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_info;
 },
 Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_entry() //  []
         { []
         }
     {offset
       cduMa: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_info" {
     Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_info:
         const Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.792031113 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZipU1_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZipU1_$cmzipWith_info;
 },
 Control.Monad.Zip.$fMonadZipU1_$cmzipWith_entry() //  []
         { []
         }
     {offset
       cduMm: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipU1_$cmzipWith_info" {
     Control.Monad.Zip.$fMonadZipU1_$cmzipWith_info:
         const Control.Monad.Zip.$fMonadZipU1_$cmzipWith_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.795555044 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipPar2_closure" {
     Control.Monad.Zip.$fMonadZipPar2_closure:
         const Control.Monad.Zip.$fMonadZipPar2_info;
 },
 Control.Monad.Zip.$fMonadZipPar2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cduMy: // global
           _sdtK0::P64 = R3;
           R3 = R4;
           _sdtJZ::P64 = R2;
           R2 = _sdtK0::P64;
           R1 = _sdtJZ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipPar2_info" {
     Control.Monad.Zip.$fMonadZipPar2_info:
         const Control.Monad.Zip.$fMonadZipPar2_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.799801539 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_info;
         const 0;
 },
 sat_sdtK3_entry() //  [R1]
         { []
         }
     {offset
       cduMN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduMO; else goto cduMP;
       cduMO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduMP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtK3_info" {
     sat_sdtK3_info:
         const sat_sdtK3_entry;
         const 1;
         const 16;
 },
 Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_entry() //  [R2]
         { []
         }
     {offset
       cduMQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduMU; else goto cduMT;
       cduMU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduMT: // global
           I64[Hp - 16] = sat_sdtK3_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadRec1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_info" {
     Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_info:
         const Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SdtVj_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.80561021 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_info;
 },
 sat_sdtK5_entry() //  [R1]
         { []
         }
     {offset
       cduNb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduNc; else goto cduNd;
       cduNc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduNd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtK5_info" {
     sat_sdtK5_info:
         const sat_sdtK5_entry;
         const 1;
         const 16;
 },
 Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_entry() //  [R2]
         { []
         }
     {offset
       cduNe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduNi; else goto cduNh;
       cduNi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduNh: // global
           I64[Hp - 16] = sat_sdtK5_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_info" {
     Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_info:
         const Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.812774435 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_info;
 },
 sat_sdtKi_entry() //  [R1]
         { []
         }
     {offset
       cduNJ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cduNK; else goto cduNL;
       cduNK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduNL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtKi_info" {
     sat_sdtKi_info:
         const sat_sdtKi_entry;
         const 4;
         const 15;
 },
 sat_sdtKh_entry() //  [R1]
         { []
         }
     {offset
       cduNQ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cduNR; else goto cduNS;
       cduNR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduNS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtKh_info" {
     sat_sdtKh_info:
         const sat_sdtKh_entry;
         const 4;
         const 15;
 },
 Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { []
         }
     {offset
       cduNT: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cduNV; else goto cduNW;
       cduNV: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduNW: // global
           I64[Sp - 40] = block_cduNv_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uduO2; else goto cduNw;
       uduO2: // global
           call _cduNv(R1) args: 0, res: 0, upd: 0;
       cduNw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_info" {
     Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_info:
         const Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cduNv() //  [R1]
         { []
         }
     {offset
       cduNv: // global
           I64[Sp - 8] = block_cduNA_info;
           _sdtKc::P64 = P64[R1 + 7];
           _sdtKd::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sdtKd::P64;
           P64[Sp + 32] = _sdtKc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uduO1; else goto cduNB;
       uduO1: // global
           call _cduNA(R1) args: 0, res: 0, upd: 0;
       cduNB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cduNv_info" {
     block_cduNv_info:
         const _cduNv;
         const 4;
         const 30;
 },
 _cduNA() //  [R1]
         { []
         }
     {offset
       cduNA: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cduO0; else goto cduNZ;
       cduO0: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cduNZ: // global
           _sdtKf::P64 = P64[R1 + 7];
           _sdtKg::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_sdtKi_info;
           P64[Hp - 96] = P64[Sp + 24];
           _sdtK8::P64 = P64[Sp + 32];
           P64[Hp - 88] = _sdtK8::P64;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sdtKg::P64;
           I64[Hp - 64] = sat_sdtKh_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _sdtK8::P64;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = _sdtKf::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cduNA_info" {
     block_cduNA_info:
         const _cduNA;
         const 5;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.825441165 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_info;
         const 0;
 },
 sat_sdtKm_entry() //  [R1]
         { []
         }
     {offset
       cduOJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduOK; else goto cduOL;
       cduOK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduOL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtKm_info" {
     sat_sdtKm_info:
         const sat_sdtKm_entry;
         const 1;
         const 16;
 },
 sat_sdtKl_entry() //  [R1]
         { []
         }
     {offset
       cduOQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduOR; else goto cduOS;
       cduOR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduOS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtKl_info" {
     sat_sdtKl_info:
         const sat_sdtKl_entry;
         const 1;
         const 16;
 },
 Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_entry() //  [R2, R3]
         { []
         }
     {offset
       cduOT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cduOX; else goto cduOW;
       cduOX: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cduOW: // global
           I64[Hp - 40] = sat_sdtKm_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sdtKl_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fMonad:*:_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_info" {
     Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_info:
         const Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const SdtVj_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.835221759 UTC

[section ""data" . Control.Monad.Zip.$dmmunzip_closure" {
     Control.Monad.Zip.$dmmunzip_closure:
         const Control.Monad.Zip.$dmmunzip_info;
 },
 $dMonad_sdtKp_entry() //  [R1]
         { []
         }
     {offset
       cduPi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduPj; else goto cduPk;
       cduPj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduPk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dMonad_sdtKp_info" {
     $dMonad_sdtKp_info:
         const $dMonad_sdtKp_entry;
         const 1;
         const 16;
 },
 sat_sdtKC_entry() //  [R1, R2]
         { []
         }
     {offset
       cduPv: // global
           _sdtKx::P64 = R2;
           _sdtKC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduPw; else goto cduPx;
       cduPx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduPz; else goto cduPy;
       cduPz: // global
           HpAlloc = 24;
           goto cduPw;
       cduPw: // global
           R2 = _sdtKx::P64;
           R1 = _sdtKC::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduPy: // global
           _sdtKp::P64 = P64[_sdtKC::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtKx::P64;
           R2 = _sdtKp::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtKC_info" {
     sat_sdtKC_info:
         const sat_sdtKC_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdtKD_entry() //  [R1]
         { []
         }
     {offset
       cduPA: // global
           _sdtKD::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduPB; else goto cduPC;
       cduPC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduPE; else goto cduPD;
       cduPE: // global
           HpAlloc = 16;
           goto cduPB;
       cduPB: // global
           R1 = _sdtKD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduPD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtKD::P64;
           _sdtKo::P64 = P64[_sdtKD::P64 + 16];
           _sdtKp::P64 = P64[_sdtKD::P64 + 24];
           I64[Hp - 8] = sat_sdtKC_info;
           P64[Hp] = _sdtKp::P64;
           R2 = _sdtKp::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtKo::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtKD_info" {
     sat_sdtKD_info:
         const sat_sdtKD_entry;
         const 2;
         const 18;
 },
 sat_sdtKv_entry() //  [R1, R2]
         { []
         }
     {offset
       cduPP: // global
           _sdtKq::P64 = R2;
           _sdtKv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduPQ; else goto cduPR;
       cduPR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduPT; else goto cduPS;
       cduPT: // global
           HpAlloc = 24;
           goto cduPQ;
       cduPQ: // global
           R2 = _sdtKq::P64;
           R1 = _sdtKv::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduPS: // global
           _sdtKp::P64 = P64[_sdtKv::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtKq::P64;
           R2 = _sdtKp::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtKv_info" {
     sat_sdtKv_info:
         const sat_sdtKv_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdtKw_entry() //  [R1]
         { []
         }
     {offset
       cduPU: // global
           _sdtKw::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduPV; else goto cduPW;
       cduPW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduPY; else goto cduPX;
       cduPY: // global
           HpAlloc = 16;
           goto cduPV;
       cduPV: // global
           R1 = _sdtKw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduPX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtKw::P64;
           _sdtKo::P64 = P64[_sdtKw::P64 + 16];
           _sdtKp::P64 = P64[_sdtKw::P64 + 24];
           I64[Hp - 8] = sat_sdtKv_info;
           P64[Hp] = _sdtKp::P64;
           R2 = _sdtKp::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtKo::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtKw_info" {
     sat_sdtKw_info:
         const sat_sdtKw_entry;
         const 2;
         const 18;
 },
 Control.Monad.Zip.$dmmunzip_entry() //  [R2, R3]
         { []
         }
     {offset
       cduQ0: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cduQ4; else goto cduQ3;
       cduQ4: // global
           HpAlloc = 112;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$dmmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cduQ3: // global
           I64[Hp - 104] = $dMonad_sdtKp_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sdtKD_info;
           P64[Hp - 64] = R3;
           _cduPe::P64 = Hp - 104;
           P64[Hp - 56] = _cduPe::P64;
           I64[Hp - 48] = sat_sdtKw_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = _cduPe::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$dmmunzip_info" {
     Control.Monad.Zip.$dmmunzip_info:
         const Control.Monad.Zip.$dmmunzip_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.8504938 UTC

[section ""data" . Control.Monad.Zip.$dmmzipWith_closure" {
     Control.Monad.Zip.$dmmzipWith_closure:
         const Control.Monad.Zip.$dmmzipWith_info;
 },
 sat_sdtKT_entry() //  [R1]
         { []
         }
     {offset
       cduQT: // global
           _sdtKT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduQU; else goto cduQV;
       cduQV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cduQX; else goto cduQW;
       cduQX: // global
           HpAlloc = 48;
           goto cduQU;
       cduQU: // global
           R1 = _sdtKT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduQW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtKT::P64;
           _sdtKF::P64 = P64[_sdtKT::P64 + 16];
           _sdtKK::P64 = P64[_sdtKT::P64 + 24];
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sdtKK::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtKK::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _sdtKF::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtKT_info" {
     sat_sdtKT_info:
         const sat_sdtKT_entry;
         const 2;
         const 18;
 },
 sat_sdtKU_entry() //  [R1, R2]
         { []
         }
     {offset
       cduQY: // global
           _sdtKK::P64 = R2;
           _sdtKU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduQZ; else goto cduR0;
       cduR0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cduR2; else goto cduR1;
       cduR2: // global
           HpAlloc = 32;
           goto cduQZ;
       cduQZ: // global
           R2 = _sdtKK::P64;
           R1 = _sdtKU::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduR1: // global
           _sdtKF::P64 = P64[_sdtKU::P64 + 7];
           _sdtKI::P64 = P64[_sdtKU::P64 + 15];
           I64[Hp - 24] = sat_sdtKT_info;
           P64[Hp - 8] = _sdtKF::P64;
           P64[Hp] = _sdtKK::P64;
           R2 = _sdtKI::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtKU_info" {
     sat_sdtKU_info:
         const sat_sdtKU_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 sat_sdtKJ_entry() //  [R1]
         { []
         }
     {offset
       cduR7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cduR8; else goto cduR9;
       cduR8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduR9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Monad.Zip.mzip_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtKJ_info" {
     sat_sdtKJ_info:
         const sat_sdtKJ_entry;
         const 3;
         const 15;
 },
 Control.Monad.Zip.$dmmzipWith_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cduRa: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cduRb; else goto cduRc;
       cduRb: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$dmmzipWith_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduRc: // global
           I64[Sp - 40] = block_cduQE_info;
           _sdtKE::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _sdtKE::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$dmmzipWith_info" {
     Control.Monad.Zip.$dmmzipWith_info:
         const Control.Monad.Zip.$dmmzipWith_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cduQE() //  [R1]
         { []
         }
     {offset
       cduQE: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cduRf; else goto cduRe;
       cduRf: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cduRe: // global
           I64[Hp - 56] = sat_sdtKU_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdtKJ_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 55;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cduQE_info" {
     block_cduQE_info:
         const _cduQE;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.861979129 UTC

[section ""data" . Control.Monad.Zip.$dmmzip_closure" {
     Control.Monad.Zip.$dmmzip_closure:
         const Control.Monad.Zip.$dmmzip_info;
 },
 Control.Monad.Zip.$dmmzip_entry() //  [R2]
         { []
         }
     {offset
       cduRN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduRO; else goto cduRP;
       cduRO: // global
           R2 = R2;
           R1 = Control.Monad.Zip.$dmmzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduRP: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Tuple.(,)_closure+2;
           Sp = Sp - 16;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$dmmzip_info" {
     Control.Monad.Zip.$dmmzip_info:
         const Control.Monad.Zip.$dmmzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.867763606 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cmzip_info;
 },
 sat_sdtL7_entry() //  [R1]
         { []
         }
     {offset
       cduSd: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cduSe; else goto cduSf;
       cduSe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduSf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtL7_info" {
     sat_sdtL7_info:
         const sat_sdtL7_entry;
         const 3;
         const 15;
 },
 sat_sdtL6_entry() //  [R1]
         { []
         }
     {offset
       cduSk: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cduSl; else goto cduSm;
       cduSl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduSm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtL6_info" {
     sat_sdtL6_info:
         const sat_sdtL6_entry;
         const 3;
         const 15;
 },
 Control.Monad.Zip.$fMonadZip:*:_$cmzip_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cduSn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cduSp; else goto cduSq;
       cduSp: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cmzip_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduSq: // global
           I64[Sp - 32] = block_cduRZ_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uduSw; else goto cduS0;
       uduSw: // global
           call _cduRZ(R1) args: 0, res: 0, upd: 0;
       cduS0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZip:*:_$cmzip_info" {
     Control.Monad.Zip.$fMonadZip:*:_$cmzip_info:
         const Control.Monad.Zip.$fMonadZip:*:_$cmzip_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cduRZ() //  [R1]
         { []
         }
     {offset
       cduRZ: // global
           I64[Sp - 8] = block_cduS4_info;
           _sdtL1::P64 = P64[R1 + 7];
           _sdtL2::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdtL2::P64;
           P64[Sp + 24] = _sdtL1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uduSv; else goto cduS5;
       uduSv: // global
           call _cduS4(R1) args: 0, res: 0, upd: 0;
       cduS5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cduRZ_info" {
     block_cduRZ_info:
         const _cduRZ;
         const 3;
         const 30;
 },
 _cduS4() //  [R1]
         { []
         }
     {offset
       cduS4: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cduSu; else goto cduSt;
       cduSu: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cduSt: // global
           _sdtL4::P64 = P64[R1 + 7];
           _sdtL5::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sdtL7_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sdtL5::P64;
           I64[Hp - 56] = sat_sdtL6_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdtL4::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cduS4_info" {
     block_cduS4_info:
         const _cduS4;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.886860896 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip_closure" {
     Control.Monad.Zip.$w$cmunzip_closure:
         const Control.Monad.Zip.$w$cmunzip_info;
 },
 $dMonad_sdtLb_entry() //  [R1]
         { []
         }
     {offset
       cduTb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduTc; else goto cduTd;
       cduTc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduTd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dMonad_sdtLb_info" {
     $dMonad_sdtLb_info:
         const $dMonad_sdtLb_entry;
         const 1;
         const 16;
 },
 lvl_sdtLc_entry() //  [R1]
         { []
         }
     {offset
       cduTi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduTj; else goto cduTk;
       cduTj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduTk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_sdtLc_info" {
     lvl_sdtLc_info:
         const lvl_sdtLc_entry;
         const 1;
         const 16;
 },
 $dMonad1_sdtLd_entry() //  [R1]
         { []
         }
     {offset
       cduTp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduTq; else goto cduTr;
       cduTq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduTr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dMonad1_sdtLd_info" {
     $dMonad1_sdtLd_info:
         const $dMonad1_sdtLd_entry;
         const 1;
         const 16;
 },
 lvl1_sdtLe_entry() //  [R1]
         { []
         }
     {offset
       cduTw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduTx; else goto cduTy;
       cduTx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduTy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl1_sdtLe_info" {
     lvl1_sdtLe_info:
         const lvl1_sdtLe_entry;
         const 1;
         const 16;
 },
 sat_sdtLM_entry() //  [R1, R2]
         { []
         }
     {offset
       cduTS: // global
           _sdtLH::P64 = R2;
           _sdtLM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduTT; else goto cduTU;
       cduTU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduTW; else goto cduTV;
       cduTW: // global
           HpAlloc = 24;
           goto cduTT;
       cduTT: // global
           R2 = _sdtLH::P64;
           R1 = _sdtLM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduTV: // global
           _sdtLc::P64 = P64[_sdtLM::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtLH::P64;
           R2 = _sdtLc::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtLM_info" {
     sat_sdtLM_info:
         const sat_sdtLM_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdtLN_entry() //  [R1]
         { []
         }
     {offset
       cduTX: // global
           _sdtLN::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduTY; else goto cduTZ;
       cduTZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduU1; else goto cduU0;
       cduU1: // global
           HpAlloc = 16;
           goto cduTY;
       cduTY: // global
           R1 = _sdtLN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduU0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtLN::P64;
           _sdtLb::P64 = P64[_sdtLN::P64 + 16];
           _sdtLc::P64 = P64[_sdtLN::P64 + 24];
           _sdtLz::P64 = P64[_sdtLN::P64 + 32];
           I64[Hp - 8] = sat_sdtLM_info;
           P64[Hp] = _sdtLc::P64;
           R2 = _sdtLb::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtLz::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtLN_info" {
     sat_sdtLN_info:
         const sat_sdtLN_entry;
         const 3;
         const 15;
 },
 sat_sdtLF_entry() //  [R1, R2]
         { []
         }
     {offset
       cduUc: // global
           _sdtLA::P64 = R2;
           _sdtLF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduUd; else goto cduUe;
       cduUe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduUg; else goto cduUf;
       cduUg: // global
           HpAlloc = 24;
           goto cduUd;
       cduUd: // global
           R2 = _sdtLA::P64;
           R1 = _sdtLF::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduUf: // global
           _sdtLe::P64 = P64[_sdtLF::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtLA::P64;
           R2 = _sdtLe::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtLF_info" {
     sat_sdtLF_info:
         const sat_sdtLF_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdtLG_entry() //  [R1]
         { []
         }
     {offset
       cduUh: // global
           _sdtLG::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduUi; else goto cduUj;
       cduUj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduUl; else goto cduUk;
       cduUl: // global
           HpAlloc = 16;
           goto cduUi;
       cduUi: // global
           R1 = _sdtLG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduUk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtLG::P64;
           _sdtLd::P64 = P64[_sdtLG::P64 + 16];
           _sdtLe::P64 = P64[_sdtLG::P64 + 24];
           _sdtLy::P64 = P64[_sdtLG::P64 + 32];
           I64[Hp - 8] = sat_sdtLF_info;
           P64[Hp] = _sdtLe::P64;
           R2 = _sdtLd::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtLy::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtLG_info" {
     sat_sdtLG_info:
         const sat_sdtLG_entry;
         const 3;
         const 15;
 },
 sat_sdtLO_entry() //  [R1]
         { []
         }
     {offset
       cduUm: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cduUo; else goto cduUp;
       cduUo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduUp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cduTD_info;
           _sdtLb::P64 = P64[R1 + 24];
           _sdtLc::P64 = P64[R1 + 32];
           _sdtLd::P64 = P64[R1 + 40];
           _sdtLe::P64 = P64[R1 + 48];
           R1 = P64[R1 + 16];
           P64[Sp - 48] = _sdtLb::P64;
           P64[Sp - 40] = _sdtLc::P64;
           P64[Sp - 32] = _sdtLd::P64;
           P64[Sp - 24] = _sdtLe::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uduUt; else goto cduTE;
       uduUt: // global
           call _cduTD(R1) args: 0, res: 0, upd: 0;
       cduTE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtLO_info" {
     sat_sdtLO_info:
         const sat_sdtLO_entry;
         const 5;
         const 15;
 },
 _cduTD() //  [R1]
         { []
         }
     {offset
       cduTD: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cduUs; else goto cduUr;
       cduUs: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cduUr: // global
           _sdtLy::P64 = P64[R1 + 7];
           _sdtLz::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sdtLN_info;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sdtLz::P64;
           I64[Hp - 56] = sat_sdtLG_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdtLy::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cduTD_info" {
     block_cduTD_info:
         const _cduTD;
         const 4;
         const 30;
 },
 sat_sdtLu_entry() //  [R1, R2]
         { []
         }
     {offset
       cduUN: // global
           _sdtLp::P64 = R2;
           _sdtLu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduUO; else goto cduUP;
       cduUP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduUR; else goto cduUQ;
       cduUR: // global
           HpAlloc = 24;
           goto cduUO;
       cduUO: // global
           R2 = _sdtLp::P64;
           R1 = _sdtLu::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduUQ: // global
           _sdtLc::P64 = P64[_sdtLu::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtLp::P64;
           R2 = _sdtLc::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtLu_info" {
     sat_sdtLu_info:
         const sat_sdtLu_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdtLv_entry() //  [R1]
         { []
         }
     {offset
       cduUS: // global
           _sdtLv::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduUT; else goto cduUU;
       cduUU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduUW; else goto cduUV;
       cduUW: // global
           HpAlloc = 16;
           goto cduUT;
       cduUT: // global
           R1 = _sdtLv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduUV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtLv::P64;
           _sdtLb::P64 = P64[_sdtLv::P64 + 16];
           _sdtLc::P64 = P64[_sdtLv::P64 + 24];
           _sdtLh::P64 = P64[_sdtLv::P64 + 32];
           I64[Hp - 8] = sat_sdtLu_info;
           P64[Hp] = _sdtLc::P64;
           R2 = _sdtLb::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtLh::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtLv_info" {
     sat_sdtLv_info:
         const sat_sdtLv_entry;
         const 3;
         const 15;
 },
 sat_sdtLn_entry() //  [R1, R2]
         { []
         }
     {offset
       cduV7: // global
           _sdtLi::P64 = R2;
           _sdtLn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduV8; else goto cduV9;
       cduV9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduVb; else goto cduVa;
       cduVb: // global
           HpAlloc = 24;
           goto cduV8;
       cduV8: // global
           R2 = _sdtLi::P64;
           R1 = _sdtLn::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduVa: // global
           _sdtLe::P64 = P64[_sdtLn::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtLi::P64;
           R2 = _sdtLe::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtLn_info" {
     sat_sdtLn_info:
         const sat_sdtLn_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdtLo_entry() //  [R1]
         { []
         }
     {offset
       cduVc: // global
           _sdtLo::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduVd; else goto cduVe;
       cduVe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduVg; else goto cduVf;
       cduVg: // global
           HpAlloc = 16;
           goto cduVd;
       cduVd: // global
           R1 = _sdtLo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduVf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtLo::P64;
           _sdtLd::P64 = P64[_sdtLo::P64 + 16];
           _sdtLe::P64 = P64[_sdtLo::P64 + 24];
           _sdtLg::P64 = P64[_sdtLo::P64 + 32];
           I64[Hp - 8] = sat_sdtLn_info;
           P64[Hp] = _sdtLe::P64;
           R2 = _sdtLd::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtLg::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtLo_info" {
     sat_sdtLo_info:
         const sat_sdtLo_entry;
         const 3;
         const 15;
 },
 sat_sdtLw_entry() //  [R1]
         { []
         }
     {offset
       cduVh: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cduVj; else goto cduVk;
       cduVj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduVk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cduUy_info;
           _sdtLb::P64 = P64[R1 + 24];
           _sdtLc::P64 = P64[R1 + 32];
           _sdtLd::P64 = P64[R1 + 40];
           _sdtLe::P64 = P64[R1 + 48];
           R1 = P64[R1 + 16];
           P64[Sp - 48] = _sdtLb::P64;
           P64[Sp - 40] = _sdtLc::P64;
           P64[Sp - 32] = _sdtLd::P64;
           P64[Sp - 24] = _sdtLe::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uduVo; else goto cduUz;
       uduVo: // global
           call _cduUy(R1) args: 0, res: 0, upd: 0;
       cduUz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtLw_info" {
     sat_sdtLw_info:
         const sat_sdtLw_entry;
         const 5;
         const 15;
 },
 _cduUy() //  [R1]
         { []
         }
     {offset
       cduUy: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cduVn; else goto cduVm;
       cduVn: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cduVm: // global
           _sdtLg::P64 = P64[R1 + 7];
           _sdtLh::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sdtLv_info;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sdtLh::P64;
           I64[Hp - 56] = sat_sdtLo_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdtLg::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cduUy_info" {
     block_cduUy_info:
         const _cduUy;
         const 4;
         const 30;
 },
 Control.Monad.Zip.$w$cmunzip_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cduVp: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cduVt; else goto cduVs;
       cduVt: // global
           HpAlloc = 208;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduVs: // global
           I64[Hp - 200] = $dMonad_sdtLb_info;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = lvl_sdtLc_info;
           _cduT7::P64 = Hp - 200;
           P64[Hp - 160] = _cduT7::P64;
           I64[Hp - 152] = $dMonad1_sdtLd_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = lvl1_sdtLe_info;
           _cduTl::P64 = Hp - 152;
           P64[Hp - 112] = _cduTl::P64;
           I64[Hp - 104] = sat_sdtLO_info;
           P64[Hp - 88] = R4;
           P64[Hp - 80] = _cduT7::P64;
           _cduTe::P64 = Hp - 176;
           P64[Hp - 72] = _cduTe::P64;
           P64[Hp - 64] = _cduTl::P64;
           _cduTs::P64 = Hp - 128;
           P64[Hp - 56] = _cduTs::P64;
           I64[Hp - 48] = sat_sdtLw_info;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = _cduT7::P64;
           P64[Hp - 16] = _cduTe::P64;
           P64[Hp - 8] = _cduTl::P64;
           P64[Hp] = _cduTs::P64;
           R2 = Hp - 104;
           R1 = Hp - 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$w$cmunzip_info" {
     Control.Monad.Zip.$w$cmunzip_info:
         const Control.Monad.Zip.$w$cmunzip_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.920898527 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZip:*:_$cmunzip_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cduX4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cduX5; else goto cduX6;
       cduX5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduX6: // global
           I64[Sp - 8] = block_cduX1_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZip:*:_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZip:*:_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZip:*:_$cmunzip_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cduX1() //  [R1, R2]
         { []
         }
     {offset
       cduX1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduX9; else goto cduX8;
       cduX9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cduX8: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cduX1_info" {
     block_cduX1_info:
         const _cduX1;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.927748629 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_closure" {
     Control.Monad.Zip.$fMonadZip:*:_closure:
         const Control.Monad.Zip.$fMonadZip:*:_info;
         const 0;
 },
 sat_sdtM0_entry() //  [R1, R2]
         { []
         }
     {offset
       cduXs: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZip:*:_$cmunzip_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtM0_info" {
     sat_sdtM0_info:
         const sat_sdtM0_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 sat_sdtLZ_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cduXA: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtLZ_info" {
     sat_sdtLZ_info:
         const sat_sdtLZ_entry;
         const 2;
         const 11;
         const 12884901911;
 },
 sat_sdtLY_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cduXI: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZip:*:_$cmzip_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtLY_info" {
     sat_sdtLY_info:
         const sat_sdtLY_entry;
         const 2;
         const 11;
         const 8589934607;
 },
 sat_sdtLX_entry() //  [R1]
         { []
         }
     {offset
       cduXP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduXQ; else goto cduXR;
       cduXQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduXR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_entry(R3,
                                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtLX_info" {
     sat_sdtLX_info:
         const sat_sdtLX_entry;
         const 2;
         const 4294967314;
         const SdtVj_srt+24;
 },
 Control.Monad.Zip.$fMonadZip:*:_entry() //  [R2, R3]
         { []
         }
     {offset
       cduXT: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cduXX; else goto cduXW;
       cduXX: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cduXW: // global
           I64[Hp - 136] = sat_sdtM0_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sdtLZ_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sdtLY_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_sdtLX_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 86;
           P64[Hp - 8] = Hp - 109;
           P64[Hp] = Hp - 135;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZip:*:_info" {
     Control.Monad.Zip.$fMonadZip:*:_info:
         const Control.Monad.Zip.$fMonadZip:*:_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const SdtVj_srt+24;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.938229495 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM2_closure" {
     Control.Monad.Zip.$fMonadZipM2_closure:
         const Control.Monad.Zip.$fMonadZipM2_info;
 },
 Control.Monad.Zip.$fMonadZipM2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cduYo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cduYp; else goto cduYq;
       cduYp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cduYq: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipM2_info" {
     Control.Monad.Zip.$fMonadZipM2_info:
         const Control.Monad.Zip.$fMonadZipM2_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.9445884 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip2_closure" {
     Control.Monad.Zip.$w$cmunzip2_closure:
         const Control.Monad.Zip.$w$cmunzip2_info;
 },
 $dMonad_sdtM6_entry() //  [R1]
         { []
         }
     {offset
       cduYE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cduYF; else goto cduYG;
       cduYF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduYG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dMonad_sdtM6_info" {
     $dMonad_sdtM6_info:
         const $dMonad_sdtM6_entry;
         const 1;
         const 16;
 },
 sat_sdtMj_entry() //  [R1, R2]
         { []
         }
     {offset
       cduYR: // global
           _sdtMe::P64 = R2;
           _sdtMj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduYS; else goto cduYT;
       cduYT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduYV; else goto cduYU;
       cduYV: // global
           HpAlloc = 24;
           goto cduYS;
       cduYS: // global
           R2 = _sdtMe::P64;
           R1 = _sdtMj::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduYU: // global
           _sdtM6::P64 = P64[_sdtMj::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtMe::P64;
           R2 = _sdtM6::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtMj_info" {
     sat_sdtMj_info:
         const sat_sdtMj_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdtMk_entry() //  [R1]
         { []
         }
     {offset
       cduYW: // global
           _sdtMk::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduYX; else goto cduYY;
       cduYY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduZ0; else goto cduYZ;
       cduZ0: // global
           HpAlloc = 16;
           goto cduYX;
       cduYX: // global
           R1 = _sdtMk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduYZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtMk::P64;
           _sdtM5::P64 = P64[_sdtMk::P64 + 16];
           _sdtM6::P64 = P64[_sdtMk::P64 + 24];
           I64[Hp - 8] = sat_sdtMj_info;
           P64[Hp] = _sdtM6::P64;
           R2 = _sdtM6::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtM5::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtMk_info" {
     sat_sdtMk_info:
         const sat_sdtMk_entry;
         const 2;
         const 18;
 },
 sat_sdtMc_entry() //  [R1, R2]
         { []
         }
     {offset
       cduZb: // global
           _sdtM7::P64 = R2;
           _sdtMc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cduZc; else goto cduZd;
       cduZd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cduZf; else goto cduZe;
       cduZf: // global
           HpAlloc = 24;
           goto cduZc;
       cduZc: // global
           R2 = _sdtM7::P64;
           R1 = _sdtMc::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cduZe: // global
           _sdtM6::P64 = P64[_sdtMc::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtM7::P64;
           R2 = _sdtM6::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtMc_info" {
     sat_sdtMc_info:
         const sat_sdtMc_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdtMd_entry() //  [R1]
         { []
         }
     {offset
       cduZg: // global
           _sdtMd::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cduZh; else goto cduZi;
       cduZi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduZk; else goto cduZj;
       cduZk: // global
           HpAlloc = 16;
           goto cduZh;
       cduZh: // global
           R1 = _sdtMd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cduZj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtMd::P64;
           _sdtM5::P64 = P64[_sdtMd::P64 + 16];
           _sdtM6::P64 = P64[_sdtMd::P64 + 24];
           I64[Hp - 8] = sat_sdtMc_info;
           P64[Hp] = _sdtM6::P64;
           R2 = _sdtM6::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtM5::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtMd_info" {
     sat_sdtMd_info:
         const sat_sdtMd_entry;
         const 2;
         const 18;
 },
 Control.Monad.Zip.$w$cmunzip2_entry() //  [R2, R3]
         { []
         }
     {offset
       cduZl: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cduZp; else goto cduZo;
       cduZp: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cduZo: // global
           I64[Hp - 80] = $dMonad_sdtM6_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtMk_info;
           P64[Hp - 40] = R3;
           _cduYA::P64 = Hp - 80;
           P64[Hp - 32] = _cduYA::P64;
           I64[Hp - 24] = sat_sdtMd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cduYA::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$w$cmunzip2_info" {
     Control.Monad.Zip.$w$cmunzip2_info:
         const Control.Monad.Zip.$w$cmunzip2_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.958876606 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipM1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipM1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipM1_$cmunzip_entry() //  [R2, R3]
         { []
         }
     {offset
       cdv00: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdv01; else goto cdv02;
       cdv01: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM1_$cmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv02: // global
           I64[Sp - 8] = block_cduZX_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip2_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipM1_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipM1_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipM1_$cmunzip_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cduZX() //  [R1, R2]
         { []
         }
     {offset
       cduZX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdv05; else goto cdv04;
       cdv05: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdv04: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cduZX_info" {
     block_cduZX_info:
         const _cduZX;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.965752797 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM1_closure" {
     Control.Monad.Zip.$fMonadZipM1_closure:
         const Control.Monad.Zip.$fMonadZipM1_info;
 },
 sat_sdtMx_entry() //  [R1, R2]
         { []
         }
     {offset
       cdv0o: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZipM1_$cmunzip_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtMx_info" {
     sat_sdtMx_info:
         const sat_sdtMx_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdtMw_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cdv0w: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdv0x; else goto cdv0y;
       cdv0x: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv0y: // global
           _sdtMt::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sdtMt::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtMw_info" {
     sat_sdtMw_info:
         const sat_sdtMw_entry;
         const 1;
         const 9;
         const 12884901911;
 },
 sat_sdtMs_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cdv0E: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZipM2_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtMs_info" {
     sat_sdtMs_info:
         const sat_sdtMs_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sdtMr_entry() //  [R1]
         { []
         }
     {offset
       cdv0L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdv0M; else goto cdv0N;
       cdv0M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv0N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtMr_info" {
     sat_sdtMr_info:
         const sat_sdtMr_entry;
         const 1;
         const 16;
 },
 Control.Monad.Zip.$fMonadZipM1_entry() //  [R2]
         { []
         }
     {offset
       cdv0P: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdv0T; else goto cdv0S;
       cdv0T: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdv0S: // global
           I64[Hp - 104] = sat_sdtMx_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdtMw_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdtMs_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtMr_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipM1_info" {
     Control.Monad.Zip.$fMonadZipM1_info:
         const Control.Monad.Zip.$fMonadZipM1_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.975953475 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec2_closure" {
     Control.Monad.Zip.$fMonadZipRec2_closure:
         const Control.Monad.Zip.$fMonadZipRec2_info;
 },
 Control.Monad.Zip.$fMonadZipRec2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdv1l: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdv1m; else goto cdv1n;
       cdv1m: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv1n: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipRec2_info" {
     Control.Monad.Zip.$fMonadZipRec2_info:
         const Control.Monad.Zip.$fMonadZipRec2_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.982895239 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip4_closure" {
     Control.Monad.Zip.$w$cmunzip4_closure:
         const Control.Monad.Zip.$w$cmunzip4_info;
 },
 $dMonad_sdtMD_entry() //  [R1]
         { []
         }
     {offset
       cdv1B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdv1C; else goto cdv1D;
       cdv1C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv1D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dMonad_sdtMD_info" {
     $dMonad_sdtMD_info:
         const $dMonad_sdtMD_entry;
         const 1;
         const 16;
 },
 lvl_sdtMM_entry() //  [R1]
         { []
         }
     {offset
       cdv1M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdv1N; else goto cdv1O;
       cdv1N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv1O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_sdtMM_info" {
     lvl_sdtMM_info:
         const lvl_sdtMM_entry;
         const 1;
         const 16;
 },
 sat_sdtMS_entry() //  [R1, R2]
         { []
         }
     {offset
       cdv1V: // global
           _sdtMN::P64 = R2;
           _sdtMS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdv1W; else goto cdv1X;
       cdv1X: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdv1Z; else goto cdv1Y;
       cdv1Z: // global
           HpAlloc = 24;
           goto cdv1W;
       cdv1W: // global
           R2 = _sdtMN::P64;
           R1 = _sdtMS::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdv1Y: // global
           _sdtMM::P64 = P64[_sdtMS::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtMN::P64;
           R2 = _sdtMM::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtMS_info" {
     sat_sdtMS_info:
         const sat_sdtMS_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdtMT_entry() //  [R1]
         { []
         }
     {offset
       cdv20: // global
           _sdtMT::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdv21; else goto cdv22;
       cdv22: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdv24; else goto cdv23;
       cdv24: // global
           HpAlloc = 40;
           goto cdv21;
       cdv21: // global
           R1 = _sdtMT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv23: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtMT::P64;
           _sdtMC::P64 = P64[_sdtMT::P64 + 16];
           _sdtMD::P64 = P64[_sdtMT::P64 + 24];
           I64[Hp - 32] = lvl_sdtMM_info;
           P64[Hp - 16] = _sdtMD::P64;
           I64[Hp - 8] = sat_sdtMS_info;
           P64[Hp] = Hp - 32;
           R2 = _sdtMD::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtMC::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtMT_info" {
     sat_sdtMT_info:
         const sat_sdtMT_entry;
         const 2;
         const 18;
 },
 lvl_sdtME_entry() //  [R1]
         { []
         }
     {offset
       cdv2d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdv2e; else goto cdv2f;
       cdv2e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv2f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_sdtME_info" {
     lvl_sdtME_info:
         const lvl_sdtME_entry;
         const 1;
         const 16;
 },
 sat_sdtMK_entry() //  [R1, R2]
         { []
         }
     {offset
       cdv2m: // global
           _sdtMF::P64 = R2;
           _sdtMK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdv2n; else goto cdv2o;
       cdv2o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdv2q; else goto cdv2p;
       cdv2q: // global
           HpAlloc = 24;
           goto cdv2n;
       cdv2n: // global
           R2 = _sdtMF::P64;
           R1 = _sdtMK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdv2p: // global
           _sdtME::P64 = P64[_sdtMK::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtMF::P64;
           R2 = _sdtME::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtMK_info" {
     sat_sdtMK_info:
         const sat_sdtMK_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdtML_entry() //  [R1]
         { []
         }
     {offset
       cdv2r: // global
           _sdtML::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdv2s; else goto cdv2t;
       cdv2t: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdv2v; else goto cdv2u;
       cdv2v: // global
           HpAlloc = 40;
           goto cdv2s;
       cdv2s: // global
           R1 = _sdtML::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv2u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtML::P64;
           _sdtMC::P64 = P64[_sdtML::P64 + 16];
           _sdtMD::P64 = P64[_sdtML::P64 + 24];
           I64[Hp - 32] = lvl_sdtME_info;
           P64[Hp - 16] = _sdtMD::P64;
           I64[Hp - 8] = sat_sdtMK_info;
           P64[Hp] = Hp - 32;
           R2 = _sdtMD::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtMC::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtML_info" {
     sat_sdtML_info:
         const sat_sdtML_entry;
         const 2;
         const 18;
 },
 Control.Monad.Zip.$w$cmunzip4_entry() //  [R2, R3]
         { []
         }
     {offset
       cdv2w: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdv2A; else goto cdv2z;
       cdv2A: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv2z: // global
           I64[Hp - 80] = $dMonad_sdtMD_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtMT_info;
           P64[Hp - 40] = R3;
           _cdv1x::P64 = Hp - 80;
           P64[Hp - 32] = _cdv1x::P64;
           I64[Hp - 24] = sat_sdtML_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdv1x::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$w$cmunzip4_info" {
     Control.Monad.Zip.$w$cmunzip4_info:
         const Control.Monad.Zip.$w$cmunzip4_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:39.999843486 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipRec1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipRec1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipRec1_$cmunzip_entry() //  [R2, R3]
         { []
         }
     {offset
       cdv3l: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdv3m; else goto cdv3n;
       cdv3m: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec1_$cmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv3n: // global
           I64[Sp - 8] = block_cdv3i_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip4_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipRec1_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipRec1_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipRec1_$cmunzip_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdv3i() //  [R1, R2]
         { []
         }
     {offset
       cdv3i: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdv3q; else goto cdv3p;
       cdv3q: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdv3p: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdv3i_info" {
     block_cdv3i_info:
         const _cdv3i;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.006415715 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec1_closure" {
     Control.Monad.Zip.$fMonadZipRec1_closure:
         const Control.Monad.Zip.$fMonadZipRec1_info;
         const 0;
 },
 sat_sdtN6_entry() //  [R1, R2]
         { []
         }
     {offset
       cdv3J: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZipRec1_$cmunzip_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtN6_info" {
     sat_sdtN6_info:
         const sat_sdtN6_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdtN5_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cdv3R: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdv3S; else goto cdv3T;
       cdv3S: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv3T: // global
           _sdtN2::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sdtN2::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtN5_info" {
     sat_sdtN5_info:
         const sat_sdtN5_entry;
         const 1;
         const 9;
         const 12884901911;
 },
 sat_sdtN1_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cdv3Z: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZipRec2_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtN1_info" {
     sat_sdtN1_info:
         const sat_sdtN1_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sdtN0_entry() //  [R1]
         { []
         }
     {offset
       cdv46: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdv47; else goto cdv48;
       cdv47: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv48: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtN0_info" {
     sat_sdtN0_info:
         const sat_sdtN0_entry;
         const 1;
         const 4294967312;
         const SdtVj_srt+8;
 },
 Control.Monad.Zip.$fMonadZipRec1_entry() //  [R2]
         { []
         }
     {offset
       cdv4a: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdv4e; else goto cdv4d;
       cdv4e: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdv4d: // global
           I64[Hp - 104] = sat_sdtN6_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdtN5_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdtN1_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtN0_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipRec1_info" {
     Control.Monad.Zip.$fMonadZipRec1_info:
         const Control.Monad.Zip.$fMonadZipRec1_entry;
         const 0;
         const 73014444046;
         const 4294967301;
         const SdtVj_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.016637281 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipPar1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipPar1_$cmunzip_entry() //  [R2]
         { []
         }
     {offset
       cdv4J: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdv4N; else goto cdv4M;
       cdv4N: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdv4M: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipPar1_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipPar1_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipPar1_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.020092677 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipPar1_closure" {
     Control.Monad.Zip.$fMonadZipPar1_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Generics.$fMonadPar1_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipPar2_closure+3;
         const Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.022096952 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZipU1_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZipU1_$cmzip_info;
 },
 Control.Monad.Zip.$fMonadZipU1_$cmzip_entry() //  []
         { []
         }
     {offset
       cdv50: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipU1_$cmzip_info" {
     Control.Monad.Zip.$fMonadZipU1_$cmzip_info:
         const Control.Monad.Zip.$fMonadZipU1_$cmzip_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.026198157 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU2_closure" {
     Control.Monad.Zip.$fMonadZipU2_closure:
         const (,)_con_info;
         const GHC.Generics.U1_closure+1;
         const GHC.Generics.U1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.028038011 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipU1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipU1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipU1_$cmunzip_entry() //  []
         { []
         }
     {offset
       cdv5d: // global
           R1 = Control.Monad.Zip.$fMonadZipU2_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipU1_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipU1_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipU1_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.03108155 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_closure" {
     Control.Monad.Zip.$fMonadZipU1_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Generics.$fMonadU1_closure;
         const Control.Monad.Zip.$fMonadZipU1_$cmzip_closure+2;
         const Control.Monad.Zip.$fMonadZipU1_$cmzipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipU1_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.033058256 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZipProxy_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZipProxy_$cmzip_info;
 },
 Control.Monad.Zip.$fMonadZipProxy_$cmzip_entry() //  []
         { []
         }
     {offset
       cdv5q: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipProxy_$cmzip_info" {
     Control.Monad.Zip.$fMonadZipProxy_$cmzip_info:
         const Control.Monad.Zip.$fMonadZipProxy_$cmzip_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.035983689 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy1_closure" {
     Control.Monad.Zip.$fMonadZipProxy1_closure:
         const (,)_con_info;
         const Data.Proxy.Proxy_closure+1;
         const Data.Proxy.Proxy_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.037962888 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipProxy_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipProxy_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipProxy_$cmunzip_entry() //  []
         { []
         }
     {offset
       cdv5D: // global
           R1 = Control.Monad.Zip.$fMonadZipProxy1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipProxy_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipProxy_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipProxy_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.041014958 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_closure" {
     Control.Monad.Zip.$fMonadZipProxy_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Proxy.$fMonadProxy_closure;
         const Control.Monad.Zip.$fMonadZipProxy_$cmzip_closure+2;
         const Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipProxy_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.043337707 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt1_closure" {
     Control.Monad.Zip.$fMonadZipAlt1_closure:
         const Control.Monad.Zip.$fMonadZipAlt1_info;
 },
 Control.Monad.Zip.$fMonadZipAlt1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdv5Q: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdv5R; else goto cdv5S;
       cdv5R: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv5S: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipAlt1_info" {
     Control.Monad.Zip.$fMonadZipAlt1_info:
         const Control.Monad.Zip.$fMonadZipAlt1_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.049550058 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip1_closure" {
     Control.Monad.Zip.$w$cmunzip1_closure:
         const Control.Monad.Zip.$w$cmunzip1_info;
 },
 $dMonad_sdtNr_entry() //  [R1]
         { []
         }
     {offset
       cdv66: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdv67; else goto cdv68;
       cdv67: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv68: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dMonad_sdtNr_info" {
     $dMonad_sdtNr_info:
         const $dMonad_sdtNr_entry;
         const 1;
         const 16;
 },
 sat_sdtNE_entry() //  [R1, R2]
         { []
         }
     {offset
       cdv6j: // global
           _sdtNz::P64 = R2;
           _sdtNE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdv6k; else goto cdv6l;
       cdv6l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdv6n; else goto cdv6m;
       cdv6n: // global
           HpAlloc = 24;
           goto cdv6k;
       cdv6k: // global
           R2 = _sdtNz::P64;
           R1 = _sdtNE::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdv6m: // global
           _sdtNr::P64 = P64[_sdtNE::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdtNz::P64;
           R2 = _sdtNr::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtNE_info" {
     sat_sdtNE_info:
         const sat_sdtNE_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdtNF_entry() //  [R1]
         { []
         }
     {offset
       cdv6o: // global
           _sdtNF::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdv6p; else goto cdv6q;
       cdv6q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdv6s; else goto cdv6r;
       cdv6s: // global
           HpAlloc = 16;
           goto cdv6p;
       cdv6p: // global
           R1 = _sdtNF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv6r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtNF::P64;
           _sdtNq::P64 = P64[_sdtNF::P64 + 16];
           _sdtNr::P64 = P64[_sdtNF::P64 + 24];
           I64[Hp - 8] = sat_sdtNE_info;
           P64[Hp] = _sdtNr::P64;
           R2 = _sdtNr::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtNq::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtNF_info" {
     sat_sdtNF_info:
         const sat_sdtNF_entry;
         const 2;
         const 18;
 },
 sat_sdtNx_entry() //  [R1, R2]
         { []
         }
     {offset
       cdv6D: // global
           _sdtNs::P64 = R2;
           _sdtNx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdv6E; else goto cdv6F;
       cdv6F: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdv6H; else goto cdv6G;
       cdv6H: // global
           HpAlloc = 24;
           goto cdv6E;
       cdv6E: // global
           R2 = _sdtNs::P64;
           R1 = _sdtNx::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdv6G: // global
           _sdtNr::P64 = P64[_sdtNx::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdtNs::P64;
           R2 = _sdtNr::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtNx_info" {
     sat_sdtNx_info:
         const sat_sdtNx_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdtNy_entry() //  [R1]
         { []
         }
     {offset
       cdv6I: // global
           _sdtNy::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdv6J; else goto cdv6K;
       cdv6K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdv6M; else goto cdv6L;
       cdv6M: // global
           HpAlloc = 16;
           goto cdv6J;
       cdv6J: // global
           R1 = _sdtNy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv6L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdtNy::P64;
           _sdtNq::P64 = P64[_sdtNy::P64 + 16];
           _sdtNr::P64 = P64[_sdtNy::P64 + 24];
           I64[Hp - 8] = sat_sdtNx_info;
           P64[Hp] = _sdtNr::P64;
           R2 = _sdtNr::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdtNq::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtNy_info" {
     sat_sdtNy_info:
         const sat_sdtNy_entry;
         const 2;
         const 18;
 },
 Control.Monad.Zip.$w$cmunzip1_entry() //  [R2, R3]
         { []
         }
     {offset
       cdv6N: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdv6R; else goto cdv6Q;
       cdv6R: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv6Q: // global
           I64[Hp - 80] = $dMonad_sdtNr_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtNF_info;
           P64[Hp - 40] = R3;
           _cdv62::P64 = Hp - 80;
           P64[Hp - 32] = _cdv62::P64;
           I64[Hp - 24] = sat_sdtNy_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdv62::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$w$cmunzip1_info" {
     Control.Monad.Zip.$w$cmunzip1_info:
         const Control.Monad.Zip.$w$cmunzip1_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.06382761 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipAlt_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipAlt_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipAlt_$cmunzip_entry() //  [R2, R3]
         { []
         }
     {offset
       cdv7s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdv7t; else goto cdv7u;
       cdv7t: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt_$cmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv7u: // global
           I64[Sp - 8] = block_cdv7p_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip1_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipAlt_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipAlt_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipAlt_$cmunzip_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdv7p() //  [R1, R2]
         { []
         }
     {offset
       cdv7p: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdv7x; else goto cdv7w;
       cdv7x: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdv7w: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdv7p_info" {
     block_cdv7p_info:
         const _cdv7p;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.070825014 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt_closure" {
     Control.Monad.Zip.$fMonadZipAlt_closure:
         const Control.Monad.Zip.$fMonadZipAlt_info;
 },
 sat_sdtNS_entry() //  [R1, R2]
         { []
         }
     {offset
       cdv7Q: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZipAlt_$cmunzip_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtNS_info" {
     sat_sdtNS_info:
         const sat_sdtNS_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdtNR_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cdv7Y: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdv7Z; else goto cdv80;
       cdv7Z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv80: // global
           _sdtNO::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sdtNO::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtNR_info" {
     sat_sdtNR_info:
         const sat_sdtNR_entry;
         const 1;
         const 9;
         const 12884901911;
 },
 sat_sdtNN_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cdv86: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZipAlt1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdtNN_info" {
     sat_sdtNN_info:
         const sat_sdtNN_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sdtNM_entry() //  [R1]
         { []
         }
     {offset
       cdv8d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdv8e; else goto cdv8f;
       cdv8e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdv8f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtNM_info" {
     sat_sdtNM_info:
         const sat_sdtNM_entry;
         const 1;
         const 16;
 },
 Control.Monad.Zip.$fMonadZipAlt_entry() //  [R2]
         { []
         }
     {offset
       cdv8h: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdv8l; else goto cdv8k;
       cdv8l: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdv8k: // global
           I64[Hp - 104] = sat_sdtNS_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdtNR_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdtNN_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdtNM_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipAlt_info" {
     Control.Monad.Zip.$fMonadZipAlt_info:
         const Control.Monad.Zip.$fMonadZipAlt_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.08187163 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast2_closure" {
     Control.Monad.Zip.$fMonadZipLast2_closure:
         const Control.Monad.Zip.$fMonadZipLast2_info;
 },
 Control.Monad.Zip.$fMonadZipLast2_entry() //  [R2, R3]
         { []
         }
     {offset
       cdv8U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdv8V; else goto cdv8W;
       cdv8V: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipLast2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdv8W: // global
           I64[Sp - 16] = block_cdv8N_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udv9o; else goto cdv8O;
       udv9o: // global
           call _cdv8N(R1) args: 0, res: 0, upd: 0;
       cdv8O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipLast2_info" {
     Control.Monad.Zip.$fMonadZipLast2_info:
         const Control.Monad.Zip.$fMonadZipLast2_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdv8N() //  [R1]
         { []
         }
     {offset
       cdv8N: // global
           if (R1 & 7 == 1) goto udv9k; else goto cdv8S;
       udv9k: // global
           Sp = Sp + 16;
           call _cdv9a() args: 0, res: 0, upd: 0;
       cdv8S: // global
           I64[Sp] = block_cdv92_info;
           _sdtNW::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdtNW::P64;
           if (R1 & 7 != 0) goto udv9m; else goto cdv94;
       udv9m: // global
           call _cdv92(R1) args: 0, res: 0, upd: 0;
       cdv94: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdv8N_info" {
     block_cdv8N_info:
         const _cdv8N;
         const 1;
         const 30;
 },
 _cdv92() //  [R1]
         { []
         }
     {offset
       cdv92: // global
           if (R1 & 7 == 1) goto udv9l; else goto cdv9f;
       udv9l: // global
           Sp = Sp + 16;
           call _cdv9a() args: 0, res: 0, upd: 0;
       cdv9f: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdv9i; else goto cdv9h;
       cdv9i: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdv9h: // global
           _sdtNY::P64 = P64[R1 + 6];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sdtNY::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdv92_info" {
     block_cdv92_info:
         const _cdv92;
         const 1;
         const 30;
 },
 _cdv9a() //  []
         { []
         }
     {offset
       cdv9a: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.094021695 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipLast_$cmunzip_info;
 },
 sat_sdtOe_entry() //  [R1]
         { []
         }
     {offset
       cdva2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdva3; else goto cdva4;
       cdva3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdva4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdv9V_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvaf; else goto cdv9W;
       udvaf: // global
           call _cdv9V(R1) args: 0, res: 0, upd: 0;
       cdv9W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtOe_info" {
     sat_sdtOe_info:
         const sat_sdtOe_entry;
         const 1;
         const 16;
 },
 _cdv9V() //  [R1]
         { []
         }
     {offset
       cdv9V: // global
           if (R1 & 7 == 1) goto cdv9Z; else goto cdva0;
       cdv9Z: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdva0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvae; else goto cdvad;
       cdvae: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvad: // global
           _sdtO9::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_1_upd_info;
           P64[Hp - 16] = _sdtO9::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdv9V_info" {
     block_cdv9V_info:
         const _cdv9V;
         const 0;
         const 30;
 },
 sat_sdtO7_entry() //  [R1]
         { []
         }
     {offset
       cdvar: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvas; else goto cdvat;
       cdvas: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvat: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvak_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvaE; else goto cdval;
       udvaE: // global
           call _cdvak(R1) args: 0, res: 0, upd: 0;
       cdval: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtO7_info" {
     sat_sdtO7_info:
         const sat_sdtO7_entry;
         const 1;
         const 16;
 },
 _cdvak() //  [R1]
         { []
         }
     {offset
       cdvak: // global
           if (R1 & 7 == 1) goto cdvao; else goto cdvap;
       cdvao: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdvap: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvaD; else goto cdvaC;
       cdvaD: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvaC: // global
           _sdtO2::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdtO2::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdvak_info" {
     block_cdvak_info:
         const _cdvak;
         const 0;
         const 30;
 },
 Control.Monad.Zip.$fMonadZipLast_$cmunzip_entry() //  [R2]
         { []
         }
     {offset
       cdvaG: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdvaK; else goto cdvaJ;
       cdvaK: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvaJ: // global
           I64[Hp - 64] = sat_sdtOe_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdtO7_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipLast_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipLast_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipLast_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.105772579 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast_closure" {
     Control.Monad.Zip.$fMonadZipLast_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Monoid.$fMonadLast_closure;
         const Control.Monad.Zip.$fMonadZipLast2_closure+2;
         const Control.Monad.Zip.$fMonadZipLast1_closure+3;
         const Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.109397981 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst2_closure" {
     Control.Monad.Zip.$fMonadZipFirst2_closure:
         const Control.Monad.Zip.$fMonadZipFirst2_info;
 },
 Control.Monad.Zip.$fMonadZipFirst2_entry() //  [R2, R3]
         { []
         }
     {offset
       cdvbu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvbv; else goto cdvbw;
       cdvbv: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipFirst2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvbw: // global
           I64[Sp - 16] = block_cdvbn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udvbY; else goto cdvbo;
       udvbY: // global
           call _cdvbn(R1) args: 0, res: 0, upd: 0;
       cdvbo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipFirst2_info" {
     Control.Monad.Zip.$fMonadZipFirst2_info:
         const Control.Monad.Zip.$fMonadZipFirst2_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdvbn() //  [R1]
         { []
         }
     {offset
       cdvbn: // global
           if (R1 & 7 == 1) goto udvbU; else goto cdvbs;
       udvbU: // global
           Sp = Sp + 16;
           call _cdvbK() args: 0, res: 0, upd: 0;
       cdvbs: // global
           I64[Sp] = block_cdvbC_info;
           _sdtOi::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdtOi::P64;
           if (R1 & 7 != 0) goto udvbW; else goto cdvbE;
       udvbW: // global
           call _cdvbC(R1) args: 0, res: 0, upd: 0;
       cdvbE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvbn_info" {
     block_cdvbn_info:
         const _cdvbn;
         const 1;
         const 30;
 },
 _cdvbC() //  [R1]
         { []
         }
     {offset
       cdvbC: // global
           if (R1 & 7 == 1) goto udvbV; else goto cdvbP;
       udvbV: // global
           Sp = Sp + 16;
           call _cdvbK() args: 0, res: 0, upd: 0;
       cdvbP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvbS; else goto cdvbR;
       cdvbS: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvbR: // global
           _sdtOk::P64 = P64[R1 + 6];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sdtOk::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvbC_info" {
     block_cdvbC_info:
         const _cdvbC;
         const 1;
         const 30;
 },
 _cdvbK() //  []
         { []
         }
     {offset
       cdvbK: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.12008557 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipFirst_$cmunzip_info;
 },
 sat_sdtOA_entry() //  [R1]
         { []
         }
     {offset
       cdvcC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvcD; else goto cdvcE;
       cdvcD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvcE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvcv_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvcP; else goto cdvcw;
       udvcP: // global
           call _cdvcv(R1) args: 0, res: 0, upd: 0;
       cdvcw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtOA_info" {
     sat_sdtOA_info:
         const sat_sdtOA_entry;
         const 1;
         const 16;
 },
 _cdvcv() //  [R1]
         { []
         }
     {offset
       cdvcv: // global
           if (R1 & 7 == 1) goto cdvcz; else goto cdvcA;
       cdvcz: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdvcA: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvcO; else goto cdvcN;
       cdvcO: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvcN: // global
           _sdtOv::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_1_upd_info;
           P64[Hp - 16] = _sdtOv::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdvcv_info" {
     block_cdvcv_info:
         const _cdvcv;
         const 0;
         const 30;
 },
 sat_sdtOt_entry() //  [R1]
         { []
         }
     {offset
       cdvd1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvd2; else goto cdvd3;
       cdvd2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvd3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvcU_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvde; else goto cdvcV;
       udvde: // global
           call _cdvcU(R1) args: 0, res: 0, upd: 0;
       cdvcV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtOt_info" {
     sat_sdtOt_info:
         const sat_sdtOt_entry;
         const 1;
         const 16;
 },
 _cdvcU() //  [R1]
         { []
         }
     {offset
       cdvcU: // global
           if (R1 & 7 == 1) goto cdvcY; else goto cdvcZ;
       cdvcY: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdvcZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvdd; else goto cdvdc;
       cdvdd: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvdc: // global
           _sdtOo::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdtOo::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdvcU_info" {
     block_cdvcU_info:
         const _cdvcU;
         const 0;
         const 30;
 },
 Control.Monad.Zip.$fMonadZipFirst_$cmunzip_entry() //  [R2]
         { []
         }
     {offset
       cdvdg: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdvdk; else goto cdvdj;
       cdvdk: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvdj: // global
           I64[Hp - 64] = sat_sdtOA_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdtOt_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipFirst_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipFirst_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipFirst_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.131298835 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst_closure" {
     Control.Monad.Zip.$fMonadZipFirst_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Monoid.$fMonadFirst_closure;
         const Control.Monad.Zip.$fMonadZipFirst2_closure+2;
         const Control.Monad.Zip.$fMonadZipFirst1_closure+3;
         const Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.134807053 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzip_info;
 },
 Control.Monad.Zip.$fMonadZipMaybe_$cmzip_entry() //  [R2, R3]
         { []
         }
     {offset
       cdve4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdve5; else goto cdve6;
       cdve5: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdve6: // global
           I64[Sp - 16] = block_cdvdX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udvey; else goto cdvdY;
       udvey: // global
           call _cdvdX(R1) args: 0, res: 0, upd: 0;
       cdvdY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipMaybe_$cmzip_info" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmzip_info:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzip_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdvdX() //  [R1]
         { []
         }
     {offset
       cdvdX: // global
           if (R1 & 7 == 1) goto udveu; else goto cdve2;
       udveu: // global
           Sp = Sp + 16;
           call _cdvek() args: 0, res: 0, upd: 0;
       cdve2: // global
           I64[Sp] = block_cdvec_info;
           _sdtOE::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdtOE::P64;
           if (R1 & 7 != 0) goto udvew; else goto cdvee;
       udvew: // global
           call _cdvec(R1) args: 0, res: 0, upd: 0;
       cdvee: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvdX_info" {
     block_cdvdX_info:
         const _cdvdX;
         const 1;
         const 30;
 },
 _cdvec() //  [R1]
         { []
         }
     {offset
       cdvec: // global
           if (R1 & 7 == 1) goto udvev; else goto cdvep;
       udvev: // global
           Sp = Sp + 16;
           call _cdvek() args: 0, res: 0, upd: 0;
       cdvep: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdves; else goto cdver;
       cdves: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdver: // global
           _sdtOG::P64 = P64[R1 + 6];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sdtOG::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvec_info" {
     block_cdvec_info:
         const _cdvec;
         const 1;
         const 30;
 },
 _cdvek() //  []
         { []
         }
     {offset
       cdvek: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.145723497 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_info;
 },
 sat_sdtOW_entry() //  [R1]
         { []
         }
     {offset
       cdvfc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvfd; else goto cdvfe;
       cdvfd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvfe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvf5_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvfp; else goto cdvf6;
       udvfp: // global
           call _cdvf5(R1) args: 0, res: 0, upd: 0;
       cdvf6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtOW_info" {
     sat_sdtOW_info:
         const sat_sdtOW_entry;
         const 1;
         const 16;
 },
 _cdvf5() //  [R1]
         { []
         }
     {offset
       cdvf5: // global
           if (R1 & 7 == 1) goto cdvf9; else goto cdvfa;
       cdvf9: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdvfa: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvfo; else goto cdvfn;
       cdvfo: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvfn: // global
           _sdtOR::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_1_upd_info;
           P64[Hp - 16] = _sdtOR::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdvf5_info" {
     block_cdvf5_info:
         const _cdvf5;
         const 0;
         const 30;
 },
 sat_sdtOP_entry() //  [R1]
         { []
         }
     {offset
       cdvfB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvfC; else goto cdvfD;
       cdvfC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvfD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvfu_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvfO; else goto cdvfv;
       udvfO: // global
           call _cdvfu(R1) args: 0, res: 0, upd: 0;
       cdvfv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdtOP_info" {
     sat_sdtOP_info:
         const sat_sdtOP_entry;
         const 1;
         const 16;
 },
 _cdvfu() //  [R1]
         { []
         }
     {offset
       cdvfu: // global
           if (R1 & 7 == 1) goto cdvfy; else goto cdvfz;
       cdvfy: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdvfz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvfN; else goto cdvfM;
       cdvfN: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvfM: // global
           _sdtOK::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdtOK::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdvfu_info" {
     block_cdvfu_info:
         const _cdvfu;
         const 0;
         const 30;
 },
 Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_entry() //  [R2]
         { []
         }
     {offset
       cdvfQ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdvfU; else goto cdvfT;
       cdvfU: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvfT: // global
           I64[Hp - 64] = sat_sdtOW_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdtOP_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.156091256 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Base.$fMonadMaybe_closure;
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure+2;
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.158530752 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipProduct_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipProduct_$cmunzip_entry() //  [R2]
         { []
         }
     {offset
       cdvgA: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdvgE; else goto cdvgD;
       cdvgE: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvgD: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipProduct_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipProduct_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipProduct_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.162311255 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProduct_closure" {
     Control.Monad.Zip.$fMonadZipProduct_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Semigroup.Internal.$fMonadProduct_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipProduct1_closure+3;
         const Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.164573005 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipSum_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipSum_$cmunzip_entry() //  [R2]
         { []
         }
     {offset
       cdvgU: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdvgY; else goto cdvgX;
       cdvgY: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvgX: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipSum_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipSum_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipSum_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.167962964 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipSum_closure" {
     Control.Monad.Zip.$fMonadZipSum_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Semigroup.Internal.$fMonadSum_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipSum1_closure+3;
         const Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.170227347 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipDual_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipDual_$cmunzip_entry() //  [R2]
         { []
         }
     {offset
       cdvhe: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdvhi; else goto cdvhh;
       cdvhi: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvhh: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipDual_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipDual_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipDual_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.174282016 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipDual_closure" {
     Control.Monad.Zip.$fMonadZipDual_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Semigroup.Internal.$fMonadDual_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipDual1_closure+3;
         const Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.176646644 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipIdentity_closure" {
     Control.Monad.Zip.$fMonadZipIdentity_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Functor.Identity.$fMonadIdentity_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipIdentity1_closure+3;
         const Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.178336597 UTC

[section ""cstring" . Control.Monad.Zip.$trModule4_bytes" {
     Control.Monad.Zip.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.180075517 UTC

[section ""data" . Control.Monad.Zip.$trModule3_closure" {
     Control.Monad.Zip.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Zip.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.181744255 UTC

[section ""cstring" . Control.Monad.Zip.$trModule2_bytes" {
     Control.Monad.Zip.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100,46,90,105,112]
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.183376686 UTC

[section ""data" . Control.Monad.Zip.$trModule1_closure" {
     Control.Monad.Zip.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Zip.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.185037683 UTC

[section ""data" . Control.Monad.Zip.$trModule_closure" {
     Control.Monad.Zip.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.Zip.$trModule3_closure+1;
         const Control.Monad.Zip.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.186798397 UTC

[section ""data" . $krep_rdtIk_closure" {
     $krep_rdtIk_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.18845583 UTC

[section ""data" . Control.Monad.Zip.$tcMonadZip1_closure" {
     Control.Monad.Zip.$tcMonadZip1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep_rdtIk_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.190544917 UTC

[section ""cstring" . Control.Monad.Zip.$tcMonadZip3_bytes" {
     Control.Monad.Zip.$tcMonadZip3_bytes:
         I8[] [77,111,110,97,100,90,105,112]
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.192239119 UTC

[section ""data" . Control.Monad.Zip.$tcMonadZip2_closure" {
     Control.Monad.Zip.$tcMonadZip2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Zip.$tcMonadZip3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.193994263 UTC

[section ""data" . Control.Monad.Zip.$tcMonadZip_closure" {
     Control.Monad.Zip.$tcMonadZip_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.Zip.$trModule_closure+1;
         const Control.Monad.Zip.$tcMonadZip2_closure+1;
         const Control.Monad.Zip.$tcMonadZip1_closure+4;
         const 4362170845454097361;
         const 3840659568565778968;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.196461982 UTC

[section ""data" . Control.Monad.Zip.C:MonadZip_closure" {
     Control.Monad.Zip.C:MonadZip_closure:
         const Control.Monad.Zip.C:MonadZip_info;
 },
 Control.Monad.Zip.C:MonadZip_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cdvhH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvhL; else goto cdvhK;
       cdvhL: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.C:MonadZip_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvhK: // global
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.C:MonadZip_info" {
     Control.Monad.Zip.C:MonadZip_info:
         const Control.Monad.Zip.C:MonadZip_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.200006471 UTC

[section ""cstring" . iduDx_str" {
     iduDx_str:
         I8[] [98,97,115,101,58,67,111,110,116,114,111,108,46,77,111,110,97,100,46,90,105,112,46,67,58,77,111,110,97,100,90,105,112]
 },
 Control.Monad.Zip.C:MonadZip_con_entry() //  [R1]
         { []
         }
     {offset
       cdvhR: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.C:MonadZip_con_info" {
     Control.Monad.Zip.C:MonadZip_con_info:
         const Control.Monad.Zip.C:MonadZip_con_entry;
         const 4;
         const 1;
         const iduDx_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:40.204171195 UTC

[section ""relreadonly" . SdtVj_srt" {
     SdtVj_srt:
         const GHC.Generics.$fMonadRec1_closure;
         const Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure;
         const GHC.Generics.$fMonad:*:_closure;
         const Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure;
         const Control.Monad.Zip.$fMonadZip:*:_closure;
         const Control.Monad.Zip.$fMonadZipRec1_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.526126674 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:08:41.528102191 UTC

[section ""data" . Control.Monad.Zip.$p1MonadZip_closure" {
     Control.Monad.Zip.$p1MonadZip_closure:
         const Control.Monad.Zip.$p1MonadZip_info;
 },
 Control.Monad.Zip.$p1MonadZip_entry() //  [R2]
         { []
         }
     {offset
       cdvp7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdvp8; else goto cdvp9;
       cdvp8: // global
           R2 = R2;
           R1 = Control.Monad.Zip.$p1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvp9: // global
           I64[Sp - 8] = block_cdvp4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udvpd; else goto cdvp5;
       udvpd: // global
           call _cdvp4(R1) args: 0, res: 0, upd: 0;
       cdvp5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$p1MonadZip_info" {
     Control.Monad.Zip.$p1MonadZip_info:
         const Control.Monad.Zip.$p1MonadZip_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cdvp4() //  [R1]
         { []
         }
     {offset
       cdvp4: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvp4_info" {
     block_cdvp4_info:
         const _cdvp4;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.53373582 UTC

[section ""data" . Control.Monad.Zip.mzip_closure" {
     Control.Monad.Zip.mzip_closure:
         const Control.Monad.Zip.mzip_info;
 },
 Control.Monad.Zip.mzip_entry() //  [R2]
         { []
         }
     {offset
       cdvpx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdvpy; else goto cdvpz;
       cdvpy: // global
           R2 = R2;
           R1 = Control.Monad.Zip.mzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvpz: // global
           I64[Sp - 8] = block_cdvpu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udvpD; else goto cdvpv;
       udvpD: // global
           call _cdvpu(R1) args: 0, res: 0, upd: 0;
       cdvpv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.mzip_info" {
     Control.Monad.Zip.mzip_info:
         const Control.Monad.Zip.mzip_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cdvpu() //  [R1]
         { []
         }
     {offset
       cdvpu: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvpu_info" {
     block_cdvpu_info:
         const _cdvpu;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.539183898 UTC

[section ""data" . Control.Monad.Zip.mzipWith_closure" {
     Control.Monad.Zip.mzipWith_closure:
         const Control.Monad.Zip.mzipWith_info;
 },
 Control.Monad.Zip.mzipWith_entry() //  [R2]
         { []
         }
     {offset
       cdvpV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdvpW; else goto cdvpX;
       cdvpW: // global
           R2 = R2;
           R1 = Control.Monad.Zip.mzipWith_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvpX: // global
           I64[Sp - 8] = block_cdvpS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udvq1; else goto cdvpT;
       udvq1: // global
           call _cdvpS(R1) args: 0, res: 0, upd: 0;
       cdvpT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.mzipWith_info" {
     Control.Monad.Zip.mzipWith_info:
         const Control.Monad.Zip.mzipWith_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cdvpS() //  [R1]
         { []
         }
     {offset
       cdvpS: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvpS_info" {
     block_cdvpS_info:
         const _cdvpS;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.544729744 UTC

[section ""data" . Control.Monad.Zip.munzip_closure" {
     Control.Monad.Zip.munzip_closure:
         const Control.Monad.Zip.munzip_info;
 },
 Control.Monad.Zip.munzip_entry() //  [R2]
         { []
         }
     {offset
       cdvqj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdvqk; else goto cdvql;
       cdvqk: // global
           R2 = R2;
           R1 = Control.Monad.Zip.munzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvql: // global
           I64[Sp - 8] = block_cdvqg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udvqp; else goto cdvqh;
       udvqp: // global
           call _cdvqg(R1) args: 0, res: 0, upd: 0;
       cdvqh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.munzip_info" {
     Control.Monad.Zip.munzip_info:
         const Control.Monad.Zip.munzip_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cdvqg() //  [R1]
         { []
         }
     {offset
       cdvqg: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvqg_info" {
     block_cdvqg_info:
         const _cdvqg;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.549888823 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip[]_closure" {
     Control.Monad.Zip.$fMonadZip[]_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Base.$fMonad[]_closure;
         const GHC.List.zip_closure+2;
         const GHC.List.zipWith_closure+3;
         const GHC.List.unzip_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.555351859 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip3_closure" {
     Control.Monad.Zip.$w$cmunzip3_closure:
         const Control.Monad.Zip.$w$cmunzip3_info;
 },
 sat_sdviJ_entry() //  [R1]
         { []
         }
     {offset
       cdvqM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvqN; else goto cdvqO;
       cdvqN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvqO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvqJ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvqS; else goto cdvqK;
       udvqS: // global
           call _cdvqJ(R1) args: 0, res: 0, upd: 0;
       cdvqK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdviJ_info" {
     sat_sdviJ_info:
         const sat_sdviJ_entry;
         const 1;
         const 16;
 },
 _cdvqJ() //  [R1]
         { []
         }
     {offset
       cdvqJ: // global
           R3 = P64[R1 + 15];
           R2 = Data.Tuple.snd_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdvqJ_info" {
     block_cdvqJ_info:
         const _cdvqJ;
         const 0;
         const 30;
 },
 sat_sdviF_entry() //  [R1]
         { []
         }
     {offset
       cdvr0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvr4; else goto cdvr5;
       cdvr4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvr5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvqX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvrd; else goto cdvqY;
       udvrd: // global
           call _cdvqX(R1) args: 0, res: 0, upd: 0;
       cdvqY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdviF_info" {
     sat_sdviF_info:
         const sat_sdviF_entry;
         const 1;
         const 16;
 },
 _cdvqX() //  [R1]
         { []
         }
     {offset
       cdvqX: // global
           I64[Sp] = block_cdvr3_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udvrc; else goto cdvr7;
       udvrc: // global
           call _cdvr3(R1) args: 0, res: 0, upd: 0;
       cdvr7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cdvqX_info" {
     block_cdvqX_info:
         const _cdvqX;
         const 0;
         const 30;
 },
 _cdvr3() //  [R1]
         { []
         }
     {offset
       cdvr3: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdvr3_info" {
     block_cdvr3_info:
         const _cdvr3;
         const 0;
         const 30;
 },
 sat_sdvix_entry() //  [R1]
         { []
         }
     {offset
       cdvrm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvrn; else goto cdvro;
       cdvrn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvro: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvrj_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvrs; else goto cdvrk;
       udvrs: // global
           call _cdvrj(R1) args: 0, res: 0, upd: 0;
       cdvrk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvix_info" {
     sat_sdvix_info:
         const sat_sdvix_entry;
         const 1;
         const 16;
 },
 _cdvrj() //  [R1]
         { []
         }
     {offset
       cdvrj: // global
           R3 = P64[R1 + 15];
           R2 = Data.Tuple.fst_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdvrj_info" {
     block_cdvrj_info:
         const _cdvrj;
         const 0;
         const 30;
 },
 sat_sdvit_entry() //  [R1]
         { []
         }
     {offset
       cdvrA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvrE; else goto cdvrF;
       cdvrE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvrF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvrx_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvrN; else goto cdvry;
       udvrN: // global
           call _cdvrx(R1) args: 0, res: 0, upd: 0;
       cdvry: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvit_info" {
     sat_sdvit_info:
         const sat_sdvit_entry;
         const 1;
         const 16;
 },
 _cdvrx() //  [R1]
         { []
         }
     {offset
       cdvrx: // global
           I64[Sp] = block_cdvrD_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udvrM; else goto cdvrH;
       udvrM: // global
           call _cdvrD(R1) args: 0, res: 0, upd: 0;
       cdvrH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cdvrx_info" {
     block_cdvrx_info:
         const _cdvrx;
         const 0;
         const 30;
 },
 _cdvrD() //  [R1]
         { []
         }
     {offset
       cdvrD: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdvrD_info" {
     block_cdvrD_info:
         const _cdvrD;
         const 0;
         const 30;
 },
 Control.Monad.Zip.$w$cmunzip3_entry() //  [R2]
         { []
         }
     {offset
       cdvrP: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdvrT; else goto cdvrS;
       cdvrT: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvrS: // global
           I64[Hp - 136] = sat_sdviJ_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sdviF_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = GHC.Base.:|_con_info;
           P64[Hp - 80] = Hp - 112;
           P64[Hp - 72] = Hp - 136;
           I64[Hp - 64] = sat_sdvix_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdvit_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = Hp - 87;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$w$cmunzip3_info" {
     Control.Monad.Zip.$w$cmunzip3_info:
         const Control.Monad.Zip.$w$cmunzip3_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.576824369 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_entry() //  [R2]
         { []
         }
     {offset
       cdvt6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdvt7; else goto cdvt8;
       cdvt7: // global
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvt8: // global
           I64[Sp - 8] = block_cdvt3_info;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cdvt3() //  [R1, R2]
         { []
         }
     {offset
       cdvt3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvtb; else goto cdvta;
       cdvtb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdvta: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvt3_info" {
     block_cdvt3_info:
         const _cdvt3;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.583849281 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipNonEmpty_closure" {
     Control.Monad.Zip.$fMonadZipNonEmpty_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Base.$fMonadNonEmpty_closure;
         const Data.List.NonEmpty.zip_closure+2;
         const Data.List.NonEmpty.zipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipNonEmpty_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.58655069 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_entry() //  [R2]
         { []
         }
     {offset
       cdvts: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.590913166 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipIdentity1_closure" {
     Control.Monad.Zip.$fMonadZipIdentity1_closure:
         const Control.Monad.Zip.$fMonadZipIdentity1_info;
 },
 Control.Monad.Zip.$fMonadZipIdentity1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdvtF: // global
           _sdviU::P64 = R3;
           R3 = R4;
           _sdviT::P64 = R2;
           R2 = _sdviU::P64;
           R1 = _sdviT::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipIdentity1_info" {
     Control.Monad.Zip.$fMonadZipIdentity1_info:
         const Control.Monad.Zip.$fMonadZipIdentity1_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.595307569 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipDual1_closure" {
     Control.Monad.Zip.$fMonadZipDual1_closure:
         const Control.Monad.Zip.$fMonadZipDual1_info;
 },
 Control.Monad.Zip.$fMonadZipDual1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdvtQ: // global
           _sdviX::P64 = R3;
           R3 = R4;
           _sdviW::P64 = R2;
           R2 = _sdviX::P64;
           R1 = _sdviW::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipDual1_info" {
     Control.Monad.Zip.$fMonadZipDual1_info:
         const Control.Monad.Zip.$fMonadZipDual1_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.600191092 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipSum1_closure" {
     Control.Monad.Zip.$fMonadZipSum1_closure:
         const Control.Monad.Zip.$fMonadZipSum1_info;
 },
 Control.Monad.Zip.$fMonadZipSum1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdvu1: // global
           _sdvj0::P64 = R3;
           R3 = R4;
           _sdviZ::P64 = R2;
           R2 = _sdvj0::P64;
           R1 = _sdviZ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipSum1_info" {
     Control.Monad.Zip.$fMonadZipSum1_info:
         const Control.Monad.Zip.$fMonadZipSum1_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.603861977 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProduct1_closure" {
     Control.Monad.Zip.$fMonadZipProduct1_closure:
         const Control.Monad.Zip.$fMonadZipProduct1_info;
 },
 Control.Monad.Zip.$fMonadZipProduct1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdvuc: // global
           _sdvj3::P64 = R3;
           R3 = R4;
           _sdvj2::P64 = R2;
           R2 = _sdvj3::P64;
           R1 = _sdvj2::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipProduct1_info" {
     Control.Monad.Zip.$fMonadZipProduct1_info:
         const Control.Monad.Zip.$fMonadZipProduct1_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.609989559 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_info;
 },
 Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_entry() //  [R2, R3,
                                                           R4]
         { []
         }
     {offset
       cdvuu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvuv; else goto cdvuw;
       cdvuv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvuw: // global
           I64[Sp - 24] = block_cdvun_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvuY; else goto cdvuo;
       udvuY: // global
           call _cdvun(R1) args: 0, res: 0, upd: 0;
       cdvuo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_info" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_info:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cdvun() //  [R1]
         { []
         }
     {offset
       cdvun: // global
           if (R1 & 7 == 1) goto udvuU; else goto cdvus;
       udvuU: // global
           Sp = Sp + 24;
           call _cdvuK() args: 0, res: 0, upd: 0;
       cdvus: // global
           I64[Sp] = block_cdvuC_info;
           _sdvj9::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdvj9::P64;
           if (R1 & 7 != 0) goto udvuW; else goto cdvuE;
       udvuW: // global
           call _cdvuC(R1) args: 0, res: 0, upd: 0;
       cdvuE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvun_info" {
     block_cdvun_info:
         const _cdvun;
         const 2;
         const 30;
 },
 _cdvuC() //  [R1]
         { []
         }
     {offset
       cdvuC: // global
           if (R1 & 7 == 1) goto udvuV; else goto cdvuP;
       udvuV: // global
           Sp = Sp + 24;
           call _cdvuK() args: 0, res: 0, upd: 0;
       cdvuP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdvuS; else goto cdvuR;
       cdvuS: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvuR: // global
           _sdvjb::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sdvjb::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvuC_info" {
     block_cdvuC_info:
         const _cdvuC;
         const 2;
         const 30;
 },
 _cdvuK() //  []
         { []
         }
     {offset
       cdvuK: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.622147181 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst1_closure" {
     Control.Monad.Zip.$fMonadZipFirst1_closure:
         const Control.Monad.Zip.$fMonadZipFirst1_info;
 },
 Control.Monad.Zip.$fMonadZipFirst1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdvvE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvvF; else goto cdvvG;
       cdvvF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipFirst1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvvG: // global
           I64[Sp - 24] = block_cdvvx_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvw8; else goto cdvvy;
       udvw8: // global
           call _cdvvx(R1) args: 0, res: 0, upd: 0;
       cdvvy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipFirst1_info" {
     Control.Monad.Zip.$fMonadZipFirst1_info:
         const Control.Monad.Zip.$fMonadZipFirst1_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cdvvx() //  [R1]
         { []
         }
     {offset
       cdvvx: // global
           if (R1 & 7 == 1) goto udvw4; else goto cdvvC;
       udvw4: // global
           Sp = Sp + 24;
           call _cdvvU() args: 0, res: 0, upd: 0;
       cdvvC: // global
           I64[Sp] = block_cdvvM_info;
           _sdvjh::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdvjh::P64;
           if (R1 & 7 != 0) goto udvw6; else goto cdvvO;
       udvw6: // global
           call _cdvvM(R1) args: 0, res: 0, upd: 0;
       cdvvO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvvx_info" {
     block_cdvvx_info:
         const _cdvvx;
         const 2;
         const 30;
 },
 _cdvvM() //  [R1]
         { []
         }
     {offset
       cdvvM: // global
           if (R1 & 7 == 1) goto udvw5; else goto cdvvZ;
       udvw5: // global
           Sp = Sp + 24;
           call _cdvvU() args: 0, res: 0, upd: 0;
       cdvvZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdvw2; else goto cdvw1;
       cdvw2: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvw1: // global
           _sdvjj::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sdvjj::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvvM_info" {
     block_cdvvM_info:
         const _cdvvM;
         const 2;
         const 30;
 },
 _cdvvU() //  []
         { []
         }
     {offset
       cdvvU: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.63219071 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast1_closure" {
     Control.Monad.Zip.$fMonadZipLast1_closure:
         const Control.Monad.Zip.$fMonadZipLast1_info;
 },
 Control.Monad.Zip.$fMonadZipLast1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdvwO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvwP; else goto cdvwQ;
       cdvwP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipLast1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvwQ: // global
           I64[Sp - 24] = block_cdvwH_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvxi; else goto cdvwI;
       udvxi: // global
           call _cdvwH(R1) args: 0, res: 0, upd: 0;
       cdvwI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipLast1_info" {
     Control.Monad.Zip.$fMonadZipLast1_info:
         const Control.Monad.Zip.$fMonadZipLast1_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cdvwH() //  [R1]
         { []
         }
     {offset
       cdvwH: // global
           if (R1 & 7 == 1) goto udvxe; else goto cdvwM;
       udvxe: // global
           Sp = Sp + 24;
           call _cdvx4() args: 0, res: 0, upd: 0;
       cdvwM: // global
           I64[Sp] = block_cdvwW_info;
           _sdvjp::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sdvjp::P64;
           if (R1 & 7 != 0) goto udvxg; else goto cdvwY;
       udvxg: // global
           call _cdvwW(R1) args: 0, res: 0, upd: 0;
       cdvwY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvwH_info" {
     block_cdvwH_info:
         const _cdvwH;
         const 2;
         const 30;
 },
 _cdvwW() //  [R1]
         { []
         }
     {offset
       cdvwW: // global
           if (R1 & 7 == 1) goto udvxf; else goto cdvx9;
       udvxf: // global
           Sp = Sp + 24;
           call _cdvx4() args: 0, res: 0, upd: 0;
       cdvx9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdvxc; else goto cdvxb;
       cdvxc: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvxb: // global
           _sdvjr::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sdvjr::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvwW_info" {
     block_cdvwW_info:
         const _cdvwW;
         const 2;
         const 30;
 },
 _cdvx4() //  []
         { []
         }
     {offset
       cdvx4: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.643625919 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_info;
 },
 sat_sdvju_entry() //  [R1]
         { []
         }
     {offset
       cdvxV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvxW; else goto cdvxX;
       cdvxW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvxX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvju_info" {
     sat_sdvju_info:
         const sat_sdvju_entry;
         const 1;
         const 16;
 },
 Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_entry() //  [R2]
         { []
         }
     {offset
       cdvxY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvy2; else goto cdvy1;
       cdvy2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvy1: // global
           I64[Hp - 16] = sat_sdvju_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fMonadAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_info" {
     Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_info:
         const Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.651069101 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_info;
 },
 Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_entry() //  []
         { []
         }
     {offset
       cdvyh: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_info" {
     Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_info:
         const Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.65486245 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZipU1_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZipU1_$cmzipWith_info;
 },
 Control.Monad.Zip.$fMonadZipU1_$cmzipWith_entry() //  []
         { []
         }
     {offset
       cdvyu: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipU1_$cmzipWith_info" {
     Control.Monad.Zip.$fMonadZipU1_$cmzipWith_info:
         const Control.Monad.Zip.$fMonadZipU1_$cmzipWith_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.658857041 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipPar2_closure" {
     Control.Monad.Zip.$fMonadZipPar2_closure:
         const Control.Monad.Zip.$fMonadZipPar2_info;
 },
 Control.Monad.Zip.$fMonadZipPar2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdvyH: // global
           _sdvjC::P64 = R3;
           R3 = R4;
           _sdvjB::P64 = R2;
           R2 = _sdvjC::P64;
           R1 = _sdvjB::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipPar2_info" {
     Control.Monad.Zip.$fMonadZipPar2_info:
         const Control.Monad.Zip.$fMonadZipPar2_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.663450764 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_info;
         const 0;
 },
 sat_sdvjF_entry() //  [R1]
         { []
         }
     {offset
       cdvyW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvyX; else goto cdvyY;
       cdvyX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvyY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvjF_info" {
     sat_sdvjF_info:
         const sat_sdvjF_entry;
         const 1;
         const 16;
 },
 Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_entry() //  [R2]
         { []
         }
     {offset
       cdvyZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvz3; else goto cdvz2;
       cdvz3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvz2: // global
           I64[Hp - 16] = sat_sdvjF_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadRec1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_info" {
     Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_info:
         const Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const Sdvz4_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.669742769 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_info;
 },
 sat_sdvjH_entry() //  [R1]
         { []
         }
     {offset
       cdvzn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvzo; else goto cdvzp;
       cdvzo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvzp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvjH_info" {
     sat_sdvjH_info:
         const sat_sdvjH_entry;
         const 1;
         const 16;
 },
 Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_entry() //  [R2]
         { []
         }
     {offset
       cdvzq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvzu; else goto cdvzt;
       cdvzu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvzt: // global
           I64[Hp - 16] = sat_sdvjH_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fMonadM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_info" {
     Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_info:
         const Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.676972445 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_info;
 },
 sat_sdvjU_entry() //  [R1]
         { []
         }
     {offset
       cdvzX: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdvzY; else goto cdvzZ;
       cdvzY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvzZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvjU_info" {
     sat_sdvjU_info:
         const sat_sdvjU_entry;
         const 4;
         const 15;
 },
 sat_sdvjT_entry() //  [R1]
         { []
         }
     {offset
       cdvA4: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdvA5; else goto cdvA6;
       cdvA5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvA6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvjT_info" {
     sat_sdvjT_info:
         const sat_sdvjT_entry;
         const 4;
         const 15;
 },
 Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_entry() //  [R2, R3, R4,
                                                         R5, R6]
         { []
         }
     {offset
       cdvA7: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdvA9; else goto cdvAa;
       cdvA9: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvAa: // global
           I64[Sp - 40] = block_cdvzJ_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udvAg; else goto cdvzK;
       udvAg: // global
           call _cdvzJ(R1) args: 0, res: 0, upd: 0;
       cdvzK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_info" {
     Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_info:
         const Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cdvzJ() //  [R1]
         { []
         }
     {offset
       cdvzJ: // global
           I64[Sp - 8] = block_cdvzO_info;
           _sdvjO::P64 = P64[R1 + 7];
           _sdvjP::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp] = _sdvjP::P64;
           P64[Sp + 32] = _sdvjO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udvAf; else goto cdvzP;
       udvAf: // global
           call _cdvzO(R1) args: 0, res: 0, upd: 0;
       cdvzP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvzJ_info" {
     block_cdvzJ_info:
         const _cdvzJ;
         const 4;
         const 30;
 },
 _cdvzO() //  [R1]
         { []
         }
     {offset
       cdvzO: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cdvAe; else goto cdvAd;
       cdvAe: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvAd: // global
           _sdvjR::P64 = P64[R1 + 7];
           _sdvjS::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_sdvjU_info;
           P64[Hp - 96] = P64[Sp + 24];
           _sdvjK::P64 = P64[Sp + 32];
           P64[Hp - 88] = _sdvjK::P64;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sdvjS::P64;
           I64[Hp - 64] = sat_sdvjT_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _sdvjK::P64;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = _sdvjR::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvzO_info" {
     block_cdvzO_info:
         const _cdvzO;
         const 5;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.690227828 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_info;
         const 0;
 },
 sat_sdvjY_entry() //  [R1]
         { []
         }
     {offset
       cdvB6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvB7; else goto cdvB8;
       cdvB7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvB8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvjY_info" {
     sat_sdvjY_info:
         const sat_sdvjY_entry;
         const 1;
         const 16;
 },
 sat_sdvjX_entry() //  [R1]
         { []
         }
     {offset
       cdvBd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvBe; else goto cdvBf;
       cdvBe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvBf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvjX_info" {
     sat_sdvjX_info:
         const sat_sdvjX_entry;
         const 1;
         const 16;
 },
 Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_entry() //  [R2, R3]
         { []
         }
     {offset
       cdvBg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdvBk; else goto cdvBj;
       cdvBk: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvBj: // global
           I64[Hp - 40] = sat_sdvjY_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sdvjX_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fMonad:*:_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_info" {
     Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_info:
         const Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const Sdvz4_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.700350591 UTC

[section ""data" . Control.Monad.Zip.$dmmunzip_closure" {
     Control.Monad.Zip.$dmmunzip_closure:
         const Control.Monad.Zip.$dmmunzip_info;
 },
 $dMonad_sdvk1_entry() //  [R1]
         { []
         }
     {offset
       cdvBJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvBK; else goto cdvBL;
       cdvBK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvBL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dMonad_sdvk1_info" {
     $dMonad_sdvk1_info:
         const $dMonad_sdvk1_entry;
         const 1;
         const 16;
 },
 sat_sdvke_entry() //  [R1, R2]
         { []
         }
     {offset
       cdvBW: // global
           _sdvk9::P64 = R2;
           _sdvke::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvBX; else goto cdvBY;
       cdvBY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvC0; else goto cdvBZ;
       cdvC0: // global
           HpAlloc = 24;
           goto cdvBX;
       cdvBX: // global
           R2 = _sdvk9::P64;
           R1 = _sdvke::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvBZ: // global
           _sdvk1::P64 = P64[_sdvke::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdvk9::P64;
           R2 = _sdvk1::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvke_info" {
     sat_sdvke_info:
         const sat_sdvke_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdvkf_entry() //  [R1]
         { []
         }
     {offset
       cdvC1: // global
           _sdvkf::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvC2; else goto cdvC3;
       cdvC3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvC5; else goto cdvC4;
       cdvC5: // global
           HpAlloc = 16;
           goto cdvC2;
       cdvC2: // global
           R1 = _sdvkf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvC4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvkf::P64;
           _sdvk0::P64 = P64[_sdvkf::P64 + 16];
           _sdvk1::P64 = P64[_sdvkf::P64 + 24];
           I64[Hp - 8] = sat_sdvke_info;
           P64[Hp] = _sdvk1::P64;
           R2 = _sdvk1::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvk0::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvkf_info" {
     sat_sdvkf_info:
         const sat_sdvkf_entry;
         const 2;
         const 18;
 },
 sat_sdvk7_entry() //  [R1, R2]
         { []
         }
     {offset
       cdvCg: // global
           _sdvk2::P64 = R2;
           _sdvk7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvCh; else goto cdvCi;
       cdvCi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvCk; else goto cdvCj;
       cdvCk: // global
           HpAlloc = 24;
           goto cdvCh;
       cdvCh: // global
           R2 = _sdvk2::P64;
           R1 = _sdvk7::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvCj: // global
           _sdvk1::P64 = P64[_sdvk7::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdvk2::P64;
           R2 = _sdvk1::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvk7_info" {
     sat_sdvk7_info:
         const sat_sdvk7_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdvk8_entry() //  [R1]
         { []
         }
     {offset
       cdvCl: // global
           _sdvk8::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvCm; else goto cdvCn;
       cdvCn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvCp; else goto cdvCo;
       cdvCp: // global
           HpAlloc = 16;
           goto cdvCm;
       cdvCm: // global
           R1 = _sdvk8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvCo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvk8::P64;
           _sdvk0::P64 = P64[_sdvk8::P64 + 16];
           _sdvk1::P64 = P64[_sdvk8::P64 + 24];
           I64[Hp - 8] = sat_sdvk7_info;
           P64[Hp] = _sdvk1::P64;
           R2 = _sdvk1::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvk0::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvk8_info" {
     sat_sdvk8_info:
         const sat_sdvk8_entry;
         const 2;
         const 18;
 },
 Control.Monad.Zip.$dmmunzip_entry() //  [R2, R3]
         { []
         }
     {offset
       cdvCr: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdvCv; else goto cdvCu;
       cdvCv: // global
           HpAlloc = 112;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$dmmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvCu: // global
           I64[Hp - 104] = $dMonad_sdvk1_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sdvkf_info;
           P64[Hp - 64] = R3;
           _cdvBF::P64 = Hp - 104;
           P64[Hp - 56] = _cdvBF::P64;
           I64[Hp - 48] = sat_sdvk8_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = _cdvBF::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$dmmunzip_info" {
     Control.Monad.Zip.$dmmunzip_info:
         const Control.Monad.Zip.$dmmunzip_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.716108133 UTC

[section ""data" . Control.Monad.Zip.$dmmzipWith_closure" {
     Control.Monad.Zip.$dmmzipWith_closure:
         const Control.Monad.Zip.$dmmzipWith_info;
 },
 sat_sdvkv_entry() //  [R1]
         { []
         }
     {offset
       cdvDz: // global
           _sdvkv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvDA; else goto cdvDB;
       cdvDB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdvDD; else goto cdvDC;
       cdvDD: // global
           HpAlloc = 48;
           goto cdvDA;
       cdvDA: // global
           R1 = _sdvkv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvDC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvkv::P64;
           _sdvkh::P64 = P64[_sdvkv::P64 + 16];
           _sdvkm::P64 = P64[_sdvkv::P64 + 24];
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sdvkm::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdvkm::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _sdvkh::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvkv_info" {
     sat_sdvkv_info:
         const sat_sdvkv_entry;
         const 2;
         const 18;
 },
 sat_sdvkw_entry() //  [R1, R2]
         { []
         }
     {offset
       cdvDE: // global
           _sdvkm::P64 = R2;
           _sdvkw::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvDF; else goto cdvDG;
       cdvDG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdvDI; else goto cdvDH;
       cdvDI: // global
           HpAlloc = 32;
           goto cdvDF;
       cdvDF: // global
           R2 = _sdvkm::P64;
           R1 = _sdvkw::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvDH: // global
           _sdvkh::P64 = P64[_sdvkw::P64 + 7];
           _sdvkk::P64 = P64[_sdvkw::P64 + 15];
           I64[Hp - 24] = sat_sdvkv_info;
           P64[Hp - 8] = _sdvkh::P64;
           P64[Hp] = _sdvkm::P64;
           R2 = _sdvkk::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvkw_info" {
     sat_sdvkw_info:
         const sat_sdvkw_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 sat_sdvkl_entry() //  [R1]
         { []
         }
     {offset
       cdvDN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdvDO; else goto cdvDP;
       cdvDO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvDP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Monad.Zip.mzip_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvkl_info" {
     sat_sdvkl_info:
         const sat_sdvkl_entry;
         const 3;
         const 15;
 },
 Control.Monad.Zip.$dmmzipWith_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cdvDQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdvDR; else goto cdvDS;
       cdvDR: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$dmmzipWith_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvDS: // global
           I64[Sp - 40] = block_cdvDk_info;
           _sdvkg::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _sdvkg::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$dmmzipWith_info" {
     Control.Monad.Zip.$dmmzipWith_info:
         const Control.Monad.Zip.$dmmzipWith_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cdvDk() //  [R1]
         { []
         }
     {offset
       cdvDk: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdvDV; else goto cdvDU;
       cdvDV: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvDU: // global
           I64[Hp - 56] = sat_sdvkw_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sdvkl_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           R2 = R1;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 32;
           P64[Sp + 32] = Hp - 55;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvDk_info" {
     block_cdvDk_info:
         const _cdvDk;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.728329197 UTC

[section ""data" . Control.Monad.Zip.$dmmzip_closure" {
     Control.Monad.Zip.$dmmzip_closure:
         const Control.Monad.Zip.$dmmzip_info;
 },
 Control.Monad.Zip.$dmmzip_entry() //  [R2]
         { []
         }
     {offset
       cdvEE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvEF; else goto cdvEG;
       cdvEF: // global
           R2 = R2;
           R1 = Control.Monad.Zip.$dmmzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvEG: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Tuple.(,)_closure+2;
           Sp = Sp - 16;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$dmmzip_info" {
     Control.Monad.Zip.$dmmzip_info:
         const Control.Monad.Zip.$dmmzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.734932701 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cmzip_info;
 },
 sat_sdvkJ_entry() //  [R1]
         { []
         }
     {offset
       cdvF7: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdvF8; else goto cdvF9;
       cdvF8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvF9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvkJ_info" {
     sat_sdvkJ_info:
         const sat_sdvkJ_entry;
         const 3;
         const 15;
 },
 sat_sdvkI_entry() //  [R1]
         { []
         }
     {offset
       cdvFe: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdvFf; else goto cdvFg;
       cdvFf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvFg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvkI_info" {
     sat_sdvkI_info:
         const sat_sdvkI_entry;
         const 3;
         const 15;
 },
 Control.Monad.Zip.$fMonadZip:*:_$cmzip_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cdvFh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdvFj; else goto cdvFk;
       cdvFj: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cmzip_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvFk: // global
           I64[Sp - 32] = block_cdvET_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udvFq; else goto cdvEU;
       udvFq: // global
           call _cdvET(R1) args: 0, res: 0, upd: 0;
       cdvEU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZip:*:_$cmzip_info" {
     Control.Monad.Zip.$fMonadZip:*:_$cmzip_info:
         const Control.Monad.Zip.$fMonadZip:*:_$cmzip_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cdvET() //  [R1]
         { []
         }
     {offset
       cdvET: // global
           I64[Sp - 8] = block_cdvEY_info;
           _sdvkD::P64 = P64[R1 + 7];
           _sdvkE::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sdvkE::P64;
           P64[Sp + 24] = _sdvkD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udvFp; else goto cdvEZ;
       udvFp: // global
           call _cdvEY(R1) args: 0, res: 0, upd: 0;
       cdvEZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvET_info" {
     block_cdvET_info:
         const _cdvET;
         const 3;
         const 30;
 },
 _cdvEY() //  [R1]
         { []
         }
     {offset
       cdvEY: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdvFo; else goto cdvFn;
       cdvFo: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvFn: // global
           _sdvkG::P64 = P64[R1 + 7];
           _sdvkH::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sdvkJ_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sdvkH::P64;
           I64[Hp - 56] = sat_sdvkI_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdvkG::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvEY_info" {
     block_cdvEY_info:
         const _cdvEY;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.754223666 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip_closure" {
     Control.Monad.Zip.$w$cmunzip_closure:
         const Control.Monad.Zip.$w$cmunzip_info;
 },
 $dMonad_sdvkN_entry() //  [R1]
         { []
         }
     {offset
       cdvGi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvGj; else goto cdvGk;
       cdvGj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvGk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dMonad_sdvkN_info" {
     $dMonad_sdvkN_info:
         const $dMonad_sdvkN_entry;
         const 1;
         const 16;
 },
 lvl_sdvkO_entry() //  [R1]
         { []
         }
     {offset
       cdvGp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvGq; else goto cdvGr;
       cdvGq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvGr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_sdvkO_info" {
     lvl_sdvkO_info:
         const lvl_sdvkO_entry;
         const 1;
         const 16;
 },
 $dMonad1_sdvkP_entry() //  [R1]
         { []
         }
     {offset
       cdvGw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvGx; else goto cdvGy;
       cdvGx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvGy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dMonad1_sdvkP_info" {
     $dMonad1_sdvkP_info:
         const $dMonad1_sdvkP_entry;
         const 1;
         const 16;
 },
 lvl1_sdvkQ_entry() //  [R1]
         { []
         }
     {offset
       cdvGD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvGE; else goto cdvGF;
       cdvGE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvGF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl1_sdvkQ_info" {
     lvl1_sdvkQ_info:
         const lvl1_sdvkQ_entry;
         const 1;
         const 16;
 },
 sat_sdvlo_entry() //  [R1, R2]
         { []
         }
     {offset
       cdvGZ: // global
           _sdvlj::P64 = R2;
           _sdvlo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvH0; else goto cdvH1;
       cdvH1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvH3; else goto cdvH2;
       cdvH3: // global
           HpAlloc = 24;
           goto cdvH0;
       cdvH0: // global
           R2 = _sdvlj::P64;
           R1 = _sdvlo::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvH2: // global
           _sdvkO::P64 = P64[_sdvlo::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdvlj::P64;
           R2 = _sdvkO::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvlo_info" {
     sat_sdvlo_info:
         const sat_sdvlo_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdvlp_entry() //  [R1]
         { []
         }
     {offset
       cdvH4: // global
           _sdvlp::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvH5; else goto cdvH6;
       cdvH6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvH8; else goto cdvH7;
       cdvH8: // global
           HpAlloc = 16;
           goto cdvH5;
       cdvH5: // global
           R1 = _sdvlp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvH7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvlp::P64;
           _sdvkN::P64 = P64[_sdvlp::P64 + 16];
           _sdvkO::P64 = P64[_sdvlp::P64 + 24];
           _sdvlb::P64 = P64[_sdvlp::P64 + 32];
           I64[Hp - 8] = sat_sdvlo_info;
           P64[Hp] = _sdvkO::P64;
           R2 = _sdvkN::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvlb::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvlp_info" {
     sat_sdvlp_info:
         const sat_sdvlp_entry;
         const 3;
         const 15;
 },
 sat_sdvlh_entry() //  [R1, R2]
         { []
         }
     {offset
       cdvHj: // global
           _sdvlc::P64 = R2;
           _sdvlh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvHk; else goto cdvHl;
       cdvHl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvHn; else goto cdvHm;
       cdvHn: // global
           HpAlloc = 24;
           goto cdvHk;
       cdvHk: // global
           R2 = _sdvlc::P64;
           R1 = _sdvlh::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvHm: // global
           _sdvkQ::P64 = P64[_sdvlh::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdvlc::P64;
           R2 = _sdvkQ::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvlh_info" {
     sat_sdvlh_info:
         const sat_sdvlh_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdvli_entry() //  [R1]
         { []
         }
     {offset
       cdvHo: // global
           _sdvli::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvHp; else goto cdvHq;
       cdvHq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvHs; else goto cdvHr;
       cdvHs: // global
           HpAlloc = 16;
           goto cdvHp;
       cdvHp: // global
           R1 = _sdvli::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvHr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvli::P64;
           _sdvkP::P64 = P64[_sdvli::P64 + 16];
           _sdvkQ::P64 = P64[_sdvli::P64 + 24];
           _sdvla::P64 = P64[_sdvli::P64 + 32];
           I64[Hp - 8] = sat_sdvlh_info;
           P64[Hp] = _sdvkQ::P64;
           R2 = _sdvkP::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvla::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvli_info" {
     sat_sdvli_info:
         const sat_sdvli_entry;
         const 3;
         const 15;
 },
 sat_sdvlq_entry() //  [R1]
         { []
         }
     {offset
       cdvHt: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cdvHv; else goto cdvHw;
       cdvHv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvHw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cdvGK_info;
           _sdvkN::P64 = P64[R1 + 24];
           _sdvkO::P64 = P64[R1 + 32];
           _sdvkP::P64 = P64[R1 + 40];
           _sdvkQ::P64 = P64[R1 + 48];
           R1 = P64[R1 + 16];
           P64[Sp - 48] = _sdvkN::P64;
           P64[Sp - 40] = _sdvkO::P64;
           P64[Sp - 32] = _sdvkP::P64;
           P64[Sp - 24] = _sdvkQ::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto udvHA; else goto cdvGL;
       udvHA: // global
           call _cdvGK(R1) args: 0, res: 0, upd: 0;
       cdvGL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvlq_info" {
     sat_sdvlq_info:
         const sat_sdvlq_entry;
         const 5;
         const 15;
 },
 _cdvGK() //  [R1]
         { []
         }
     {offset
       cdvGK: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdvHz; else goto cdvHy;
       cdvHz: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvHy: // global
           _sdvla::P64 = P64[R1 + 7];
           _sdvlb::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sdvlp_info;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sdvlb::P64;
           I64[Hp - 56] = sat_sdvli_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdvla::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdvGK_info" {
     block_cdvGK_info:
         const _cdvGK;
         const 4;
         const 30;
 },
 sat_sdvl6_entry() //  [R1, R2]
         { []
         }
     {offset
       cdvHU: // global
           _sdvl1::P64 = R2;
           _sdvl6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvHV; else goto cdvHW;
       cdvHW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvHY; else goto cdvHX;
       cdvHY: // global
           HpAlloc = 24;
           goto cdvHV;
       cdvHV: // global
           R2 = _sdvl1::P64;
           R1 = _sdvl6::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvHX: // global
           _sdvkO::P64 = P64[_sdvl6::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdvl1::P64;
           R2 = _sdvkO::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvl6_info" {
     sat_sdvl6_info:
         const sat_sdvl6_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdvl7_entry() //  [R1]
         { []
         }
     {offset
       cdvHZ: // global
           _sdvl7::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvI0; else goto cdvI1;
       cdvI1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvI3; else goto cdvI2;
       cdvI3: // global
           HpAlloc = 16;
           goto cdvI0;
       cdvI0: // global
           R1 = _sdvl7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvI2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvl7::P64;
           _sdvkN::P64 = P64[_sdvl7::P64 + 16];
           _sdvkO::P64 = P64[_sdvl7::P64 + 24];
           _sdvkT::P64 = P64[_sdvl7::P64 + 32];
           I64[Hp - 8] = sat_sdvl6_info;
           P64[Hp] = _sdvkO::P64;
           R2 = _sdvkN::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvkT::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvl7_info" {
     sat_sdvl7_info:
         const sat_sdvl7_entry;
         const 3;
         const 15;
 },
 sat_sdvkZ_entry() //  [R1, R2]
         { []
         }
     {offset
       cdvIe: // global
           _sdvkU::P64 = R2;
           _sdvkZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvIf; else goto cdvIg;
       cdvIg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvIi; else goto cdvIh;
       cdvIi: // global
           HpAlloc = 24;
           goto cdvIf;
       cdvIf: // global
           R2 = _sdvkU::P64;
           R1 = _sdvkZ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvIh: // global
           _sdvkQ::P64 = P64[_sdvkZ::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdvkU::P64;
           R2 = _sdvkQ::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvkZ_info" {
     sat_sdvkZ_info:
         const sat_sdvkZ_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdvl0_entry() //  [R1]
         { []
         }
     {offset
       cdvIj: // global
           _sdvl0::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvIk; else goto cdvIl;
       cdvIl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvIn; else goto cdvIm;
       cdvIn: // global
           HpAlloc = 16;
           goto cdvIk;
       cdvIk: // global
           R1 = _sdvl0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvIm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvl0::P64;
           _sdvkP::P64 = P64[_sdvl0::P64 + 16];
           _sdvkQ::P64 = P64[_sdvl0::P64 + 24];
           _sdvkS::P64 = P64[_sdvl0::P64 + 32];
           I64[Hp - 8] = sat_sdvkZ_info;
           P64[Hp] = _sdvkQ::P64;
           R2 = _sdvkP::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvkS::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvl0_info" {
     sat_sdvl0_info:
         const sat_sdvl0_entry;
         const 3;
         const 15;
 },
 sat_sdvl8_entry() //  [R1]
         { []
         }
     {offset
       cdvIo: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cdvIq; else goto cdvIr;
       cdvIq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvIr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cdvHF_info;
           _sdvkN::P64 = P64[R1 + 24];
           _sdvkO::P64 = P64[R1 + 32];
           _sdvkP::P64 = P64[R1 + 40];
           _sdvkQ::P64 = P64[R1 + 48];
           R1 = P64[R1 + 16];
           P64[Sp - 48] = _sdvkN::P64;
           P64[Sp - 40] = _sdvkO::P64;
           P64[Sp - 32] = _sdvkP::P64;
           P64[Sp - 24] = _sdvkQ::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto udvIv; else goto cdvHG;
       udvIv: // global
           call _cdvHF(R1) args: 0, res: 0, upd: 0;
       cdvHG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvl8_info" {
     sat_sdvl8_info:
         const sat_sdvl8_entry;
         const 5;
         const 15;
 },
 _cdvHF() //  [R1]
         { []
         }
     {offset
       cdvHF: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdvIu; else goto cdvIt;
       cdvIu: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvIt: // global
           _sdvkS::P64 = P64[R1 + 7];
           _sdvkT::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sdvl7_info;
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sdvkT::P64;
           I64[Hp - 56] = sat_sdvl0_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sdvkS::P64;
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdvHF_info" {
     block_cdvHF_info:
         const _cdvHF;
         const 4;
         const 30;
 },
 Control.Monad.Zip.$w$cmunzip_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdvIw: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cdvIA; else goto cdvIz;
       cdvIA: // global
           HpAlloc = 208;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvIz: // global
           I64[Hp - 200] = $dMonad_sdvkN_info;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = lvl_sdvkO_info;
           _cdvGe::P64 = Hp - 200;
           P64[Hp - 160] = _cdvGe::P64;
           I64[Hp - 152] = $dMonad1_sdvkP_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = lvl1_sdvkQ_info;
           _cdvGs::P64 = Hp - 152;
           P64[Hp - 112] = _cdvGs::P64;
           I64[Hp - 104] = sat_sdvlq_info;
           P64[Hp - 88] = R4;
           P64[Hp - 80] = _cdvGe::P64;
           _cdvGl::P64 = Hp - 176;
           P64[Hp - 72] = _cdvGl::P64;
           P64[Hp - 64] = _cdvGs::P64;
           _cdvGz::P64 = Hp - 128;
           P64[Hp - 56] = _cdvGz::P64;
           I64[Hp - 48] = sat_sdvl8_info;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = _cdvGe::P64;
           P64[Hp - 16] = _cdvGl::P64;
           P64[Hp - 8] = _cdvGs::P64;
           P64[Hp] = _cdvGz::P64;
           R2 = Hp - 104;
           R1 = Hp - 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$w$cmunzip_info" {
     Control.Monad.Zip.$w$cmunzip_info:
         const Control.Monad.Zip.$w$cmunzip_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.791336196 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZip:*:_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZip:*:_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZip:*:_$cmunzip_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdvKP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdvKQ; else goto cdvKR;
       cdvKQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_$cmunzip_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvKR: // global
           I64[Sp - 8] = block_cdvKM_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZip:*:_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZip:*:_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZip:*:_$cmunzip_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cdvKM() //  [R1, R2]
         { []
         }
     {offset
       cdvKM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvKU; else goto cdvKT;
       cdvKU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdvKT: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvKM_info" {
     block_cdvKM_info:
         const _cdvKM;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.798401156 UTC

[section ""data" . Control.Monad.Zip.$fMonadZip:*:_closure" {
     Control.Monad.Zip.$fMonadZip:*:_closure:
         const Control.Monad.Zip.$fMonadZip:*:_info;
         const 0;
 },
 sat_sdvlC_entry() //  [R1, R2]
         { []
         }
     {offset
       cdvLf: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZip:*:_$cmunzip_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvlC_info" {
     sat_sdvlC_info:
         const sat_sdvlC_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 sat_sdvlB_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cdvLn: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Control.Monad.Zip.$fMonadZip:*:_$cmzipWith_entry(R6,
                                                                 R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvlB_info" {
     sat_sdvlB_info:
         const sat_sdvlB_entry;
         const 2;
         const 11;
         const 12884901911;
 },
 sat_sdvlA_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cdvLv: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZip:*:_$cmzip_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvlA_info" {
     sat_sdvlA_info:
         const sat_sdvlA_entry;
         const 2;
         const 11;
         const 8589934607;
 },
 sat_sdvlz_entry() //  [R1]
         { []
         }
     {offset
       cdvLC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvLD; else goto cdvLE;
       cdvLD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvLE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_entry(R3,
                                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvlz_info" {
     sat_sdvlz_info:
         const sat_sdvlz_entry;
         const 2;
         const 4294967314;
         const Sdvz4_srt+24;
 },
 Control.Monad.Zip.$fMonadZip:*:_entry() //  [R2, R3]
         { []
         }
     {offset
       cdvLG: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdvLK; else goto cdvLJ;
       cdvLK: // global
           HpAlloc = 144;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZip:*:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvLJ: // global
           I64[Hp - 136] = sat_sdvlC_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sdvlB_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = sat_sdvlA_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_sdvlz_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 86;
           P64[Hp - 8] = Hp - 109;
           P64[Hp] = Hp - 135;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZip:*:_info" {
     Control.Monad.Zip.$fMonadZip:*:_info:
         const Control.Monad.Zip.$fMonadZip:*:_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const Sdvz4_srt+24;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.809108616 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM2_closure" {
     Control.Monad.Zip.$fMonadZipM2_closure:
         const Control.Monad.Zip.$fMonadZipM2_info;
 },
 Control.Monad.Zip.$fMonadZipM2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdvMh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdvMi; else goto cdvMj;
       cdvMi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvMj: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipM2_info" {
     Control.Monad.Zip.$fMonadZipM2_info:
         const Control.Monad.Zip.$fMonadZipM2_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.815704185 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip2_closure" {
     Control.Monad.Zip.$w$cmunzip2_closure:
         const Control.Monad.Zip.$w$cmunzip2_info;
 },
 $dMonad_sdvlI_entry() //  [R1]
         { []
         }
     {offset
       cdvMA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvMB; else goto cdvMC;
       cdvMB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvMC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dMonad_sdvlI_info" {
     $dMonad_sdvlI_info:
         const $dMonad_sdvlI_entry;
         const 1;
         const 16;
 },
 sat_sdvlV_entry() //  [R1, R2]
         { []
         }
     {offset
       cdvMN: // global
           _sdvlQ::P64 = R2;
           _sdvlV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvMO; else goto cdvMP;
       cdvMP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvMR; else goto cdvMQ;
       cdvMR: // global
           HpAlloc = 24;
           goto cdvMO;
       cdvMO: // global
           R2 = _sdvlQ::P64;
           R1 = _sdvlV::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvMQ: // global
           _sdvlI::P64 = P64[_sdvlV::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdvlQ::P64;
           R2 = _sdvlI::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvlV_info" {
     sat_sdvlV_info:
         const sat_sdvlV_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdvlW_entry() //  [R1]
         { []
         }
     {offset
       cdvMS: // global
           _sdvlW::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvMT; else goto cdvMU;
       cdvMU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvMW; else goto cdvMV;
       cdvMW: // global
           HpAlloc = 16;
           goto cdvMT;
       cdvMT: // global
           R1 = _sdvlW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvMV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvlW::P64;
           _sdvlH::P64 = P64[_sdvlW::P64 + 16];
           _sdvlI::P64 = P64[_sdvlW::P64 + 24];
           I64[Hp - 8] = sat_sdvlV_info;
           P64[Hp] = _sdvlI::P64;
           R2 = _sdvlI::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvlH::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvlW_info" {
     sat_sdvlW_info:
         const sat_sdvlW_entry;
         const 2;
         const 18;
 },
 sat_sdvlO_entry() //  [R1, R2]
         { []
         }
     {offset
       cdvN7: // global
           _sdvlJ::P64 = R2;
           _sdvlO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvN8; else goto cdvN9;
       cdvN9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvNb; else goto cdvNa;
       cdvNb: // global
           HpAlloc = 24;
           goto cdvN8;
       cdvN8: // global
           R2 = _sdvlJ::P64;
           R1 = _sdvlO::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvNa: // global
           _sdvlI::P64 = P64[_sdvlO::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdvlJ::P64;
           R2 = _sdvlI::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvlO_info" {
     sat_sdvlO_info:
         const sat_sdvlO_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdvlP_entry() //  [R1]
         { []
         }
     {offset
       cdvNc: // global
           _sdvlP::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvNd; else goto cdvNe;
       cdvNe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvNg; else goto cdvNf;
       cdvNg: // global
           HpAlloc = 16;
           goto cdvNd;
       cdvNd: // global
           R1 = _sdvlP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvNf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvlP::P64;
           _sdvlH::P64 = P64[_sdvlP::P64 + 16];
           _sdvlI::P64 = P64[_sdvlP::P64 + 24];
           I64[Hp - 8] = sat_sdvlO_info;
           P64[Hp] = _sdvlI::P64;
           R2 = _sdvlI::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvlH::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvlP_info" {
     sat_sdvlP_info:
         const sat_sdvlP_entry;
         const 2;
         const 18;
 },
 Control.Monad.Zip.$w$cmunzip2_entry() //  [R2, R3]
         { []
         }
     {offset
       cdvNh: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdvNl; else goto cdvNk;
       cdvNl: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvNk: // global
           I64[Hp - 80] = $dMonad_sdvlI_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdvlW_info;
           P64[Hp - 40] = R3;
           _cdvMw::P64 = Hp - 80;
           P64[Hp - 32] = _cdvMw::P64;
           I64[Hp - 24] = sat_sdvlP_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdvMw::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$w$cmunzip2_info" {
     Control.Monad.Zip.$w$cmunzip2_info:
         const Control.Monad.Zip.$w$cmunzip2_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.830195922 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipM1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipM1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipM1_$cmunzip_entry() //  [R2, R3]
         { []
         }
     {offset
       cdvOa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdvOb; else goto cdvOc;
       cdvOb: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM1_$cmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvOc: // global
           I64[Sp - 8] = block_cdvO7_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip2_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipM1_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipM1_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipM1_$cmunzip_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdvO7() //  [R1, R2]
         { []
         }
     {offset
       cdvO7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvOf; else goto cdvOe;
       cdvOf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdvOe: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvO7_info" {
     block_cdvO7_info:
         const _cdvO7;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.83727126 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipM1_closure" {
     Control.Monad.Zip.$fMonadZipM1_closure:
         const Control.Monad.Zip.$fMonadZipM1_info;
 },
 sat_sdvm9_entry() //  [R1, R2]
         { []
         }
     {offset
       cdvOA: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZipM1_$cmunzip_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvm9_info" {
     sat_sdvm9_info:
         const sat_sdvm9_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdvm8_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cdvOI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdvOJ; else goto cdvOK;
       cdvOJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvOK: // global
           _sdvm5::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sdvm5::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvm8_info" {
     sat_sdvm8_info:
         const sat_sdvm8_entry;
         const 1;
         const 9;
         const 12884901911;
 },
 sat_sdvm4_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cdvOQ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZipM2_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvm4_info" {
     sat_sdvm4_info:
         const sat_sdvm4_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sdvm3_entry() //  [R1]
         { []
         }
     {offset
       cdvOX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvOY; else goto cdvOZ;
       cdvOY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvOZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZipM1_$cp1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvm3_info" {
     sat_sdvm3_info:
         const sat_sdvm3_entry;
         const 1;
         const 16;
 },
 Control.Monad.Zip.$fMonadZipM1_entry() //  [R2]
         { []
         }
     {offset
       cdvP1: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdvP5; else goto cdvP4;
       cdvP5: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvP4: // global
           I64[Hp - 104] = sat_sdvm9_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdvm8_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdvm4_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdvm3_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipM1_info" {
     Control.Monad.Zip.$fMonadZipM1_info:
         const Control.Monad.Zip.$fMonadZipM1_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.84765938 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec2_closure" {
     Control.Monad.Zip.$fMonadZipRec2_closure:
         const Control.Monad.Zip.$fMonadZipRec2_info;
 },
 Control.Monad.Zip.$fMonadZipRec2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdvPE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdvPF; else goto cdvPG;
       cdvPF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvPG: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipRec2_info" {
     Control.Monad.Zip.$fMonadZipRec2_info:
         const Control.Monad.Zip.$fMonadZipRec2_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.855073613 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip4_closure" {
     Control.Monad.Zip.$w$cmunzip4_closure:
         const Control.Monad.Zip.$w$cmunzip4_info;
 },
 $dMonad_sdvmf_entry() //  [R1]
         { []
         }
     {offset
       cdvPX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvPY; else goto cdvPZ;
       cdvPY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvPZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dMonad_sdvmf_info" {
     $dMonad_sdvmf_info:
         const $dMonad_sdvmf_entry;
         const 1;
         const 16;
 },
 lvl_sdvmo_entry() //  [R1]
         { []
         }
     {offset
       cdvQ8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvQ9; else goto cdvQa;
       cdvQ9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvQa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_sdvmo_info" {
     lvl_sdvmo_info:
         const lvl_sdvmo_entry;
         const 1;
         const 16;
 },
 sat_sdvmu_entry() //  [R1, R2]
         { []
         }
     {offset
       cdvQh: // global
           _sdvmp::P64 = R2;
           _sdvmu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvQi; else goto cdvQj;
       cdvQj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvQl; else goto cdvQk;
       cdvQl: // global
           HpAlloc = 24;
           goto cdvQi;
       cdvQi: // global
           R2 = _sdvmp::P64;
           R1 = _sdvmu::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvQk: // global
           _sdvmo::P64 = P64[_sdvmu::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdvmp::P64;
           R2 = _sdvmo::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvmu_info" {
     sat_sdvmu_info:
         const sat_sdvmu_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdvmv_entry() //  [R1]
         { []
         }
     {offset
       cdvQm: // global
           _sdvmv::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvQn; else goto cdvQo;
       cdvQo: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvQq; else goto cdvQp;
       cdvQq: // global
           HpAlloc = 40;
           goto cdvQn;
       cdvQn: // global
           R1 = _sdvmv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvQp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvmv::P64;
           _sdvme::P64 = P64[_sdvmv::P64 + 16];
           _sdvmf::P64 = P64[_sdvmv::P64 + 24];
           I64[Hp - 32] = lvl_sdvmo_info;
           P64[Hp - 16] = _sdvmf::P64;
           I64[Hp - 8] = sat_sdvmu_info;
           P64[Hp] = Hp - 32;
           R2 = _sdvmf::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvme::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvmv_info" {
     sat_sdvmv_info:
         const sat_sdvmv_entry;
         const 2;
         const 18;
 },
 lvl_sdvmg_entry() //  [R1]
         { []
         }
     {offset
       cdvQz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvQA; else goto cdvQB;
       cdvQA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvQB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_sdvmg_info" {
     lvl_sdvmg_info:
         const lvl_sdvmg_entry;
         const 1;
         const 16;
 },
 sat_sdvmm_entry() //  [R1, R2]
         { []
         }
     {offset
       cdvQI: // global
           _sdvmh::P64 = R2;
           _sdvmm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvQJ; else goto cdvQK;
       cdvQK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvQM; else goto cdvQL;
       cdvQM: // global
           HpAlloc = 24;
           goto cdvQJ;
       cdvQJ: // global
           R2 = _sdvmh::P64;
           R1 = _sdvmm::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvQL: // global
           _sdvmg::P64 = P64[_sdvmm::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdvmh::P64;
           R2 = _sdvmg::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvmm_info" {
     sat_sdvmm_info:
         const sat_sdvmm_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdvmn_entry() //  [R1]
         { []
         }
     {offset
       cdvQN: // global
           _sdvmn::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvQO; else goto cdvQP;
       cdvQP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvQR; else goto cdvQQ;
       cdvQR: // global
           HpAlloc = 40;
           goto cdvQO;
       cdvQO: // global
           R1 = _sdvmn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvQQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvmn::P64;
           _sdvme::P64 = P64[_sdvmn::P64 + 16];
           _sdvmf::P64 = P64[_sdvmn::P64 + 24];
           I64[Hp - 32] = lvl_sdvmg_info;
           P64[Hp - 16] = _sdvmf::P64;
           I64[Hp - 8] = sat_sdvmm_info;
           P64[Hp] = Hp - 32;
           R2 = _sdvmf::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvme::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvmn_info" {
     sat_sdvmn_info:
         const sat_sdvmn_entry;
         const 2;
         const 18;
 },
 Control.Monad.Zip.$w$cmunzip4_entry() //  [R2, R3]
         { []
         }
     {offset
       cdvQS: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdvQW; else goto cdvQV;
       cdvQW: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvQV: // global
           I64[Hp - 80] = $dMonad_sdvmf_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdvmv_info;
           P64[Hp - 40] = R3;
           _cdvPT::P64 = Hp - 80;
           P64[Hp - 32] = _cdvPT::P64;
           I64[Hp - 24] = sat_sdvmn_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdvPT::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$w$cmunzip4_info" {
     Control.Monad.Zip.$w$cmunzip4_info:
         const Control.Monad.Zip.$w$cmunzip4_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.872734731 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipRec1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipRec1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipRec1_$cmunzip_entry() //  [R2, R3]
         { []
         }
     {offset
       cdvRZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdvS0; else goto cdvS1;
       cdvS0: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec1_$cmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvS1: // global
           I64[Sp - 8] = block_cdvRW_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip4_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipRec1_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipRec1_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipRec1_$cmunzip_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdvRW() //  [R1, R2]
         { []
         }
     {offset
       cdvRW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvS4; else goto cdvS3;
       cdvS4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdvS3: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvRW_info" {
     block_cdvRW_info:
         const _cdvRW;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.879792241 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipRec1_closure" {
     Control.Monad.Zip.$fMonadZipRec1_closure:
         const Control.Monad.Zip.$fMonadZipRec1_info;
         const 0;
 },
 sat_sdvmI_entry() //  [R1, R2]
         { []
         }
     {offset
       cdvSp: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZipRec1_$cmunzip_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvmI_info" {
     sat_sdvmI_info:
         const sat_sdvmI_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdvmH_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cdvSx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdvSy; else goto cdvSz;
       cdvSy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvSz: // global
           _sdvmE::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sdvmE::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvmH_info" {
     sat_sdvmH_info:
         const sat_sdvmH_entry;
         const 1;
         const 9;
         const 12884901911;
 },
 sat_sdvmD_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cdvSF: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZipRec2_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvmD_info" {
     sat_sdvmD_info:
         const sat_sdvmD_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sdvmC_entry() //  [R1]
         { []
         }
     {offset
       cdvSM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvSN; else goto cdvSO;
       cdvSN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvSO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvmC_info" {
     sat_sdvmC_info:
         const sat_sdvmC_entry;
         const 1;
         const 4294967312;
         const Sdvz4_srt+8;
 },
 Control.Monad.Zip.$fMonadZipRec1_entry() //  [R2]
         { []
         }
     {offset
       cdvSQ: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdvSU; else goto cdvST;
       cdvSU: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipRec1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvST: // global
           I64[Hp - 104] = sat_sdvmI_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdvmH_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdvmD_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdvmC_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipRec1_info" {
     Control.Monad.Zip.$fMonadZipRec1_info:
         const Control.Monad.Zip.$fMonadZipRec1_entry;
         const 0;
         const 73014444046;
         const 4294967301;
         const Sdvz4_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.890440817 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipPar1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipPar1_$cmunzip_entry() //  [R2]
         { []
         }
     {offset
       cdvTw: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdvTA; else goto cdvTz;
       cdvTA: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvTz: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipPar1_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipPar1_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipPar1_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.894033611 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipPar1_closure" {
     Control.Monad.Zip.$fMonadZipPar1_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Generics.$fMonadPar1_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipPar2_closure+3;
         const Control.Monad.Zip.$fMonadZipPar1_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.89619942 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZipU1_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZipU1_$cmzip_info;
 },
 Control.Monad.Zip.$fMonadZipU1_$cmzip_entry() //  []
         { []
         }
     {offset
       cdvTQ: // global
           R1 = GHC.Generics.U1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipU1_$cmzip_info" {
     Control.Monad.Zip.$fMonadZipU1_$cmzip_info:
         const Control.Monad.Zip.$fMonadZipU1_$cmzip_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.900189597 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU2_closure" {
     Control.Monad.Zip.$fMonadZipU2_closure:
         const (,)_con_info;
         const GHC.Generics.U1_closure+1;
         const GHC.Generics.U1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.902318453 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipU1_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipU1_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipU1_$cmunzip_entry() //  []
         { []
         }
     {offset
       cdvU4: // global
           R1 = Control.Monad.Zip.$fMonadZipU2_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipU1_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipU1_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipU1_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.905505968 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipU1_closure" {
     Control.Monad.Zip.$fMonadZipU1_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Generics.$fMonadU1_closure;
         const Control.Monad.Zip.$fMonadZipU1_$cmzip_closure+2;
         const Control.Monad.Zip.$fMonadZipU1_$cmzipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipU1_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.907517956 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZipProxy_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZipProxy_$cmzip_info;
 },
 Control.Monad.Zip.$fMonadZipProxy_$cmzip_entry() //  []
         { []
         }
     {offset
       cdvUh: // global
           R1 = Data.Proxy.Proxy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipProxy_$cmzip_info" {
     Control.Monad.Zip.$fMonadZipProxy_$cmzip_info:
         const Control.Monad.Zip.$fMonadZipProxy_$cmzip_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.910626193 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy1_closure" {
     Control.Monad.Zip.$fMonadZipProxy1_closure:
         const (,)_con_info;
         const Data.Proxy.Proxy_closure+1;
         const Data.Proxy.Proxy_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.91268615 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipProxy_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipProxy_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipProxy_$cmunzip_entry() //  []
         { []
         }
     {offset
       cdvUv: // global
           R1 = Control.Monad.Zip.$fMonadZipProxy1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipProxy_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipProxy_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipProxy_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.916299815 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProxy_closure" {
     Control.Monad.Zip.$fMonadZipProxy_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Proxy.$fMonadProxy_closure;
         const Control.Monad.Zip.$fMonadZipProxy_$cmzip_closure+2;
         const Control.Monad.Zip.$fMonadZipProxy_$cmzipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipProxy_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.918610226 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt1_closure" {
     Control.Monad.Zip.$fMonadZipAlt1_closure:
         const Control.Monad.Zip.$fMonadZipAlt1_info;
 },
 Control.Monad.Zip.$fMonadZipAlt1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdvUI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdvUJ; else goto cdvUK;
       cdvUJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvUK: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipAlt1_info" {
     Control.Monad.Zip.$fMonadZipAlt1_info:
         const Control.Monad.Zip.$fMonadZipAlt1_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.925062639 UTC

[section ""data" . Control.Monad.Zip.$w$cmunzip1_closure" {
     Control.Monad.Zip.$w$cmunzip1_closure:
         const Control.Monad.Zip.$w$cmunzip1_info;
 },
 $dMonad_sdvn3_entry() //  [R1]
         { []
         }
     {offset
       cdvV1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvV2; else goto cdvV3;
       cdvV2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvV3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$p1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dMonad_sdvn3_info" {
     $dMonad_sdvn3_info:
         const $dMonad_sdvn3_entry;
         const 1;
         const 16;
 },
 sat_sdvng_entry() //  [R1, R2]
         { []
         }
     {offset
       cdvVe: // global
           _sdvnb::P64 = R2;
           _sdvng::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvVf; else goto cdvVg;
       cdvVg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvVi; else goto cdvVh;
       cdvVi: // global
           HpAlloc = 24;
           goto cdvVf;
       cdvVf: // global
           R2 = _sdvnb::P64;
           R1 = _sdvng::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvVh: // global
           _sdvn3::P64 = P64[_sdvng::P64 + 7];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdvnb::P64;
           R2 = _sdvn3::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvng_info" {
     sat_sdvng_info:
         const sat_sdvng_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdvnh_entry() //  [R1]
         { []
         }
     {offset
       cdvVj: // global
           _sdvnh::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvVk; else goto cdvVl;
       cdvVl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvVn; else goto cdvVm;
       cdvVn: // global
           HpAlloc = 16;
           goto cdvVk;
       cdvVk: // global
           R1 = _sdvnh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvVm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvnh::P64;
           _sdvn2::P64 = P64[_sdvnh::P64 + 16];
           _sdvn3::P64 = P64[_sdvnh::P64 + 24];
           I64[Hp - 8] = sat_sdvng_info;
           P64[Hp] = _sdvn3::P64;
           R2 = _sdvn3::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvn2::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvnh_info" {
     sat_sdvnh_info:
         const sat_sdvnh_entry;
         const 2;
         const 18;
 },
 sat_sdvn9_entry() //  [R1, R2]
         { []
         }
     {offset
       cdvVy: // global
           _sdvn4::P64 = R2;
           _sdvn9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdvVz; else goto cdvVA;
       cdvVA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvVC; else goto cdvVB;
       cdvVC: // global
           HpAlloc = 24;
           goto cdvVz;
       cdvVz: // global
           R2 = _sdvn4::P64;
           R1 = _sdvn9::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvVB: // global
           _sdvn3::P64 = P64[_sdvn9::P64 + 7];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdvn4::P64;
           R2 = _sdvn3::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvn9_info" {
     sat_sdvn9_info:
         const sat_sdvn9_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdvna_entry() //  [R1]
         { []
         }
     {offset
       cdvVD: // global
           _sdvna::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cdvVE; else goto cdvVF;
       cdvVF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvVH; else goto cdvVG;
       cdvVH: // global
           HpAlloc = 16;
           goto cdvVE;
       cdvVE: // global
           R1 = _sdvna::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvVG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdvna::P64;
           _sdvn2::P64 = P64[_sdvna::P64 + 16];
           _sdvn3::P64 = P64[_sdvna::P64 + 24];
           I64[Hp - 8] = sat_sdvn9_info;
           P64[Hp] = _sdvn3::P64;
           R2 = _sdvn3::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sdvn2::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvna_info" {
     sat_sdvna_info:
         const sat_sdvna_entry;
         const 2;
         const 18;
 },
 Control.Monad.Zip.$w$cmunzip1_entry() //  [R2, R3]
         { []
         }
     {offset
       cdvVI: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdvVM; else goto cdvVL;
       cdvVM: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$w$cmunzip1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvVL: // global
           I64[Hp - 80] = $dMonad_sdvn3_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdvnh_info;
           P64[Hp - 40] = R3;
           _cdvUX::P64 = Hp - 80;
           P64[Hp - 32] = _cdvUX::P64;
           I64[Hp - 24] = sat_sdvna_info;
           P64[Hp - 8] = R3;
           P64[Hp] = _cdvUX::P64;
           R2 = Hp - 56;
           R1 = Hp - 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$w$cmunzip1_info" {
     Control.Monad.Zip.$w$cmunzip1_info:
         const Control.Monad.Zip.$w$cmunzip1_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.939610894 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipAlt_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipAlt_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipAlt_$cmunzip_entry() //  [R2, R3]
         { []
         }
     {offset
       cdvWB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdvWC; else goto cdvWD;
       cdvWC: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt_$cmunzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvWD: // global
           I64[Sp - 8] = block_cdvWy_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Control.Monad.Zip.$w$cmunzip1_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipAlt_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipAlt_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipAlt_$cmunzip_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdvWy() //  [R1, R2]
         { []
         }
     {offset
       cdvWy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdvWG; else goto cdvWF;
       cdvWG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdvWF: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvWy_info" {
     block_cdvWy_info:
         const _cdvWy;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.946531408 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipAlt_closure" {
     Control.Monad.Zip.$fMonadZipAlt_closure:
         const Control.Monad.Zip.$fMonadZipAlt_info;
 },
 sat_sdvnu_entry() //  [R1, R2]
         { []
         }
     {offset
       cdvX1: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Monad.Zip.$fMonadZipAlt_$cmunzip_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvnu_info" {
     sat_sdvnu_info:
         const sat_sdvnu_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sdvnt_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cdvX9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdvXa; else goto cdvXb;
       cdvXa: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvXb: // global
           _sdvnq::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _sdvnq::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call Control.Monad.Zip.mzipWith_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvnt_info" {
     sat_sdvnt_info:
         const sat_sdvnt_entry;
         const 1;
         const 9;
         const 12884901911;
 },
 sat_sdvnp_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cdvXh: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Monad.Zip.$fMonadZipAlt1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sdvnp_info" {
     sat_sdvnp_info:
         const sat_sdvnp_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sdvno_entry() //  [R1]
         { []
         }
     {offset
       cdvXo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvXp; else goto cdvXq;
       cdvXp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvXq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Monad.Zip.$fMonadZipAlt_$cp1MonadZip_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvno_info" {
     sat_sdvno_info:
         const sat_sdvno_entry;
         const 1;
         const 16;
 },
 Control.Monad.Zip.$fMonadZipAlt_entry() //  [R2]
         { []
         }
     {offset
       cdvXs: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cdvXw; else goto cdvXv;
       cdvXw: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdvXv: // global
           I64[Hp - 104] = sat_sdvnu_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sdvnt_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sdvnp_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sdvno_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 103;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipAlt_info" {
     Control.Monad.Zip.$fMonadZipAlt_info:
         const Control.Monad.Zip.$fMonadZipAlt_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.958118762 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast2_closure" {
     Control.Monad.Zip.$fMonadZipLast2_closure:
         const Control.Monad.Zip.$fMonadZipLast2_info;
 },
 Control.Monad.Zip.$fMonadZipLast2_entry() //  [R2, R3]
         { []
         }
     {offset
       cdvYc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvYd; else goto cdvYe;
       cdvYd: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipLast2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvYe: // global
           I64[Sp - 16] = block_cdvY5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udvYG; else goto cdvY6;
       udvYG: // global
           call _cdvY5(R1) args: 0, res: 0, upd: 0;
       cdvY6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipLast2_info" {
     Control.Monad.Zip.$fMonadZipLast2_info:
         const Control.Monad.Zip.$fMonadZipLast2_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdvY5() //  [R1]
         { []
         }
     {offset
       cdvY5: // global
           if (R1 & 7 == 1) goto udvYC; else goto cdvYa;
       udvYC: // global
           Sp = Sp + 16;
           call _cdvYs() args: 0, res: 0, upd: 0;
       cdvYa: // global
           I64[Sp] = block_cdvYk_info;
           _sdvny::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdvny::P64;
           if (R1 & 7 != 0) goto udvYE; else goto cdvYm;
       udvYE: // global
           call _cdvYk(R1) args: 0, res: 0, upd: 0;
       cdvYm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvY5_info" {
     block_cdvY5_info:
         const _cdvY5;
         const 1;
         const 30;
 },
 _cdvYk() //  [R1]
         { []
         }
     {offset
       cdvYk: // global
           if (R1 & 7 == 1) goto udvYD; else goto cdvYx;
       udvYD: // global
           Sp = Sp + 16;
           call _cdvYs() args: 0, res: 0, upd: 0;
       cdvYx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvYA; else goto cdvYz;
       cdvYA: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvYz: // global
           _sdvnA::P64 = P64[R1 + 6];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sdvnA::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvYk_info" {
     block_cdvYk_info:
         const _cdvYk;
         const 1;
         const 30;
 },
 _cdvYs() //  []
         { []
         }
     {offset
       cdvYs: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.96820133 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipLast_$cmunzip_info;
 },
 sat_sdvnQ_entry() //  [R1]
         { []
         }
     {offset
       cdvZp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvZq; else goto cdvZr;
       cdvZq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvZr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvZi_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udvZC; else goto cdvZj;
       udvZC: // global
           call _cdvZi(R1) args: 0, res: 0, upd: 0;
       cdvZj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvnQ_info" {
     sat_sdvnQ_info:
         const sat_sdvnQ_entry;
         const 1;
         const 16;
 },
 _cdvZi() //  [R1]
         { []
         }
     {offset
       cdvZi: // global
           if (R1 & 7 == 1) goto cdvZm; else goto cdvZn;
       cdvZm: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdvZn: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdvZB; else goto cdvZA;
       cdvZB: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvZA: // global
           _sdvnL::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_1_upd_info;
           P64[Hp - 16] = _sdvnL::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdvZi_info" {
     block_cdvZi_info:
         const _cdvZi;
         const 0;
         const 30;
 },
 sat_sdvnJ_entry() //  [R1]
         { []
         }
     {offset
       cdvZO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdvZP; else goto cdvZQ;
       cdvZP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdvZQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdvZH_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udw01; else goto cdvZI;
       udw01: // global
           call _cdvZH(R1) args: 0, res: 0, upd: 0;
       cdvZI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvnJ_info" {
     sat_sdvnJ_info:
         const sat_sdvnJ_entry;
         const 1;
         const 16;
 },
 _cdvZH() //  [R1]
         { []
         }
     {offset
       cdvZH: // global
           if (R1 & 7 == 1) goto cdvZL; else goto cdvZM;
       cdvZL: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdvZM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdw00; else goto cdvZZ;
       cdw00: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdvZZ: // global
           _sdvnE::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdvnE::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdvZH_info" {
     block_cdvZH_info:
         const _cdvZH;
         const 0;
         const 30;
 },
 Control.Monad.Zip.$fMonadZipLast_$cmunzip_entry() //  [R2]
         { []
         }
     {offset
       cdw03: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdw07; else goto cdw06;
       cdw07: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdw06: // global
           I64[Hp - 64] = sat_sdvnQ_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdvnJ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipLast_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipLast_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipLast_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.979634549 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipLast_closure" {
     Control.Monad.Zip.$fMonadZipLast_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Monoid.$fMonadLast_closure;
         const Control.Monad.Zip.$fMonadZipLast2_closure+2;
         const Control.Monad.Zip.$fMonadZipLast1_closure+3;
         const Control.Monad.Zip.$fMonadZipLast_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.983079402 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst2_closure" {
     Control.Monad.Zip.$fMonadZipFirst2_closure:
         const Control.Monad.Zip.$fMonadZipFirst2_info;
 },
 Control.Monad.Zip.$fMonadZipFirst2_entry() //  [R2, R3]
         { []
         }
     {offset
       cdw14: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdw15; else goto cdw16;
       cdw15: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipFirst2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdw16: // global
           I64[Sp - 16] = block_cdw0X_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udw1y; else goto cdw0Y;
       udw1y: // global
           call _cdw0X(R1) args: 0, res: 0, upd: 0;
       cdw0Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipFirst2_info" {
     Control.Monad.Zip.$fMonadZipFirst2_info:
         const Control.Monad.Zip.$fMonadZipFirst2_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdw0X() //  [R1]
         { []
         }
     {offset
       cdw0X: // global
           if (R1 & 7 == 1) goto udw1u; else goto cdw12;
       udw1u: // global
           Sp = Sp + 16;
           call _cdw1k() args: 0, res: 0, upd: 0;
       cdw12: // global
           I64[Sp] = block_cdw1c_info;
           _sdvnU::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdvnU::P64;
           if (R1 & 7 != 0) goto udw1w; else goto cdw1e;
       udw1w: // global
           call _cdw1c(R1) args: 0, res: 0, upd: 0;
       cdw1e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdw0X_info" {
     block_cdw0X_info:
         const _cdw0X;
         const 1;
         const 30;
 },
 _cdw1c() //  [R1]
         { []
         }
     {offset
       cdw1c: // global
           if (R1 & 7 == 1) goto udw1v; else goto cdw1p;
       udw1v: // global
           Sp = Sp + 16;
           call _cdw1k() args: 0, res: 0, upd: 0;
       cdw1p: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdw1s; else goto cdw1r;
       cdw1s: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdw1r: // global
           _sdvnW::P64 = P64[R1 + 6];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sdvnW::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdw1c_info" {
     block_cdw1c_info:
         const _cdw1c;
         const 1;
         const 30;
 },
 _cdw1k() //  []
         { []
         }
     {offset
       cdw1k: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:41.993478712 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipFirst_$cmunzip_info;
 },
 sat_sdvoc_entry() //  [R1]
         { []
         }
     {offset
       cdw2h: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdw2i; else goto cdw2j;
       cdw2i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdw2j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdw2a_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udw2u; else goto cdw2b;
       udw2u: // global
           call _cdw2a(R1) args: 0, res: 0, upd: 0;
       cdw2b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvoc_info" {
     sat_sdvoc_info:
         const sat_sdvoc_entry;
         const 1;
         const 16;
 },
 _cdw2a() //  [R1]
         { []
         }
     {offset
       cdw2a: // global
           if (R1 & 7 == 1) goto cdw2e; else goto cdw2f;
       cdw2e: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdw2f: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdw2t; else goto cdw2s;
       cdw2t: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdw2s: // global
           _sdvo7::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_1_upd_info;
           P64[Hp - 16] = _sdvo7::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdw2a_info" {
     block_cdw2a_info:
         const _cdw2a;
         const 0;
         const 30;
 },
 sat_sdvo5_entry() //  [R1]
         { []
         }
     {offset
       cdw2G: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdw2H; else goto cdw2I;
       cdw2H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdw2I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdw2z_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udw2T; else goto cdw2A;
       udw2T: // global
           call _cdw2z(R1) args: 0, res: 0, upd: 0;
       cdw2A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvo5_info" {
     sat_sdvo5_info:
         const sat_sdvo5_entry;
         const 1;
         const 16;
 },
 _cdw2z() //  [R1]
         { []
         }
     {offset
       cdw2z: // global
           if (R1 & 7 == 1) goto cdw2D; else goto cdw2E;
       cdw2D: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdw2E: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdw2S; else goto cdw2R;
       cdw2S: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdw2R: // global
           _sdvo0::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdvo0::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdw2z_info" {
     block_cdw2z_info:
         const _cdw2z;
         const 0;
         const 30;
 },
 Control.Monad.Zip.$fMonadZipFirst_$cmunzip_entry() //  [R2]
         { []
         }
     {offset
       cdw2V: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdw2Z; else goto cdw2Y;
       cdw2Z: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdw2Y: // global
           I64[Hp - 64] = sat_sdvoc_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdvo5_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipFirst_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipFirst_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipFirst_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.003825782 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipFirst_closure" {
     Control.Monad.Zip.$fMonadZipFirst_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Monoid.$fMonadFirst_closure;
         const Control.Monad.Zip.$fMonadZipFirst2_closure+2;
         const Control.Monad.Zip.$fMonadZipFirst1_closure+3;
         const Control.Monad.Zip.$fMonadZipFirst_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.007502237 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzip_info;
 },
 Control.Monad.Zip.$fMonadZipMaybe_$cmzip_entry() //  [R2, R3]
         { []
         }
     {offset
       cdw3W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdw3X; else goto cdw3Y;
       cdw3X: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdw3Y: // global
           I64[Sp - 16] = block_cdw3P_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udw4q; else goto cdw3Q;
       udw4q: // global
           call _cdw3P(R1) args: 0, res: 0, upd: 0;
       cdw3Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipMaybe_$cmzip_info" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmzip_info:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzip_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdw3P() //  [R1]
         { []
         }
     {offset
       cdw3P: // global
           if (R1 & 7 == 1) goto udw4m; else goto cdw3U;
       udw4m: // global
           Sp = Sp + 16;
           call _cdw4c() args: 0, res: 0, upd: 0;
       cdw3U: // global
           I64[Sp] = block_cdw44_info;
           _sdvog::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdvog::P64;
           if (R1 & 7 != 0) goto udw4o; else goto cdw46;
       udw4o: // global
           call _cdw44(R1) args: 0, res: 0, upd: 0;
       cdw46: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdw3P_info" {
     block_cdw3P_info:
         const _cdw3P;
         const 1;
         const 30;
 },
 _cdw44() //  [R1]
         { []
         }
     {offset
       cdw44: // global
           if (R1 & 7 == 1) goto udw4n; else goto cdw4h;
       udw4n: // global
           Sp = Sp + 16;
           call _cdw4c() args: 0, res: 0, upd: 0;
       cdw4h: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdw4k; else goto cdw4j;
       cdw4k: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdw4j: // global
           _sdvoi::P64 = P64[R1 + 6];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sdvoi::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdw44_info" {
     block_cdw44_info:
         const _cdw44;
         const 1;
         const 30;
 },
 _cdw4c() //  []
         { []
         }
     {offset
       cdw4c: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.018094047 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_info;
 },
 sat_sdvoy_entry() //  [R1]
         { []
         }
     {offset
       cdw59: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdw5a; else goto cdw5b;
       cdw5a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdw5b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdw52_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udw5m; else goto cdw53;
       udw5m: // global
           call _cdw52(R1) args: 0, res: 0, upd: 0;
       cdw53: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvoy_info" {
     sat_sdvoy_info:
         const sat_sdvoy_entry;
         const 1;
         const 16;
 },
 _cdw52() //  [R1]
         { []
         }
     {offset
       cdw52: // global
           if (R1 & 7 == 1) goto cdw56; else goto cdw57;
       cdw56: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdw57: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdw5l; else goto cdw5k;
       cdw5l: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdw5k: // global
           _sdvot::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_1_upd_info;
           P64[Hp - 16] = _sdvot::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdw52_info" {
     block_cdw52_info:
         const _cdw52;
         const 0;
         const 30;
 },
 sat_sdvor_entry() //  [R1]
         { []
         }
     {offset
       cdw5y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdw5z; else goto cdw5A;
       cdw5z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdw5A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdw5r_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udw5L; else goto cdw5s;
       udw5L: // global
           call _cdw5r(R1) args: 0, res: 0, upd: 0;
       cdw5s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sdvor_info" {
     sat_sdvor_info:
         const sat_sdvor_entry;
         const 1;
         const 16;
 },
 _cdw5r() //  [R1]
         { []
         }
     {offset
       cdw5r: // global
           if (R1 & 7 == 1) goto cdw5v; else goto cdw5w;
       cdw5v: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdw5w: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdw5K; else goto cdw5J;
       cdw5K: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdw5J: // global
           _sdvom::P64 = P64[R1 + 6];
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdvom::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdw5r_info" {
     block_cdw5r_info:
         const _cdw5r;
         const 0;
         const 30;
 },
 Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_entry() //  [R2]
         { []
         }
     {offset
       cdw5N: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdw5R; else goto cdw5Q;
       cdw5R: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdw5Q: // global
           I64[Hp - 64] = sat_sdvoy_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdvor_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.028662116 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipMaybe_closure" {
     Control.Monad.Zip.$fMonadZipMaybe_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const GHC.Base.$fMonadMaybe_closure;
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzip_closure+2;
         const Control.Monad.Zip.$fMonadZipMaybe_$cmzipWith_closure+3;
         const Control.Monad.Zip.$fMonadZipMaybe_$cmunzip_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.031097655 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipProduct_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipProduct_$cmunzip_entry() //  [R2]
         { []
         }
     {offset
       cdw6K: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdw6O; else goto cdw6N;
       cdw6O: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdw6N: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipProduct_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipProduct_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipProduct_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.034612895 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipProduct_closure" {
     Control.Monad.Zip.$fMonadZipProduct_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Semigroup.Internal.$fMonadProduct_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipProduct1_closure+3;
         const Control.Monad.Zip.$fMonadZipProduct_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.036787121 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipSum_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipSum_$cmunzip_entry() //  [R2]
         { []
         }
     {offset
       cdw77: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdw7b; else goto cdw7a;
       cdw7b: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdw7a: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipSum_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipSum_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipSum_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.040623147 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipSum_closure" {
     Control.Monad.Zip.$fMonadZipSum_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Semigroup.Internal.$fMonadSum_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipSum1_closure+3;
         const Control.Monad.Zip.$fMonadZipSum_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.042903692 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure" {
     Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure:
         const Control.Monad.Zip.$fMonadZipDual_$cmunzip_info;
 },
 Control.Monad.Zip.$fMonadZipDual_$cmunzip_entry() //  [R2]
         { []
         }
     {offset
       cdw7u: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdw7y; else goto cdw7x;
       cdw7y: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdw7x: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.$fMonadZipDual_$cmunzip_info" {
     Control.Monad.Zip.$fMonadZipDual_$cmunzip_info:
         const Control.Monad.Zip.$fMonadZipDual_$cmunzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.046460648 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipDual_closure" {
     Control.Monad.Zip.$fMonadZipDual_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Semigroup.Internal.$fMonadDual_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipDual1_closure+3;
         const Control.Monad.Zip.$fMonadZipDual_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.048168546 UTC

[section ""data" . Control.Monad.Zip.$fMonadZipIdentity_closure" {
     Control.Monad.Zip.$fMonadZipIdentity_closure:
         const Control.Monad.Zip.C:MonadZip_con_info;
         const Data.Functor.Identity.$fMonadIdentity_closure;
         const GHC.Tuple.(,)_closure+2;
         const Control.Monad.Zip.$fMonadZipIdentity1_closure+3;
         const Control.Monad.Zip.$fMonadZipIdentity_$cmunzip_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.050746401 UTC

[section ""cstring" . Control.Monad.Zip.$trModule4_bytes" {
     Control.Monad.Zip.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.052368326 UTC

[section ""data" . Control.Monad.Zip.$trModule3_closure" {
     Control.Monad.Zip.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Zip.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.0540484 UTC

[section ""cstring" . Control.Monad.Zip.$trModule2_bytes" {
     Control.Monad.Zip.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100,46,90,105,112]
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.055616884 UTC

[section ""data" . Control.Monad.Zip.$trModule1_closure" {
     Control.Monad.Zip.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Zip.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.057296828 UTC

[section ""data" . Control.Monad.Zip.$trModule_closure" {
     Control.Monad.Zip.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.Zip.$trModule3_closure+1;
         const Control.Monad.Zip.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.059043694 UTC

[section ""data" . $krep_rdtIk_closure" {
     $krep_rdtIk_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.060745087 UTC

[section ""data" . Control.Monad.Zip.$tcMonadZip1_closure" {
     Control.Monad.Zip.$tcMonadZip1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep_rdtIk_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.062474905 UTC

[section ""cstring" . Control.Monad.Zip.$tcMonadZip3_bytes" {
     Control.Monad.Zip.$tcMonadZip3_bytes:
         I8[] [77,111,110,97,100,90,105,112]
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.064154679 UTC

[section ""data" . Control.Monad.Zip.$tcMonadZip2_closure" {
     Control.Monad.Zip.$tcMonadZip2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.Zip.$tcMonadZip3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.066355431 UTC

[section ""data" . Control.Monad.Zip.$tcMonadZip_closure" {
     Control.Monad.Zip.$tcMonadZip_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Monad.Zip.$trModule_closure+1;
         const Control.Monad.Zip.$tcMonadZip2_closure+1;
         const Control.Monad.Zip.$tcMonadZip1_closure+4;
         const 4362170845454097361;
         const 3840659568565778968;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.068908436 UTC

[section ""data" . Control.Monad.Zip.C:MonadZip_closure" {
     Control.Monad.Zip.C:MonadZip_closure:
         const Control.Monad.Zip.C:MonadZip_info;
 },
 Control.Monad.Zip.C:MonadZip_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cdw80: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdw84; else goto cdw83;
       cdw84: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.Zip.C:MonadZip_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdw83: // global
           I64[Hp - 32] = Control.Monad.Zip.C:MonadZip_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.C:MonadZip_info" {
     Control.Monad.Zip.C:MonadZip_info:
         const Control.Monad.Zip.C:MonadZip_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.072487009 UTC

[section ""cstring" . idw8c_str" {
     idw8c_str:
         I8[] [98,97,115,101,58,67,111,110,116,114,111,108,46,77,111,110,97,100,46,90,105,112,46,67,58,77,111,110,97,100,90,105,112]
 },
 Control.Monad.Zip.C:MonadZip_con_entry() //  [R1]
         { []
         }
     {offset
       cdw8b: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Control.Monad.Zip.C:MonadZip_con_info" {
     Control.Monad.Zip.C:MonadZip_con_info:
         const Control.Monad.Zip.C:MonadZip_con_entry;
         const 4;
         const 1;
         const idw8c_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:08:42.075556899 UTC

[section ""relreadonly" . Sdvz4_srt" {
     Sdvz4_srt:
         const GHC.Generics.$fMonadRec1_closure;
         const Control.Monad.Zip.$fMonadZipRec1_$cp1MonadZip_closure;
         const GHC.Generics.$fMonad:*:_closure;
         const Control.Monad.Zip.$fMonadZip:*:_$cp1MonadZip_closure;
         const Control.Monad.Zip.$fMonadZip:*:_closure;
         const Control.Monad.Zip.$fMonadZipRec1_closure;
 }]

