
==================== Tidy Core ====================
2018-03-16 16:06:45.174219902 UTC

Result size of Tidy Core
  = {terms: 1,173, types: 2,329, coercions: 2,280, joins: 0/19}

-- RHS size: {terms: 15, types: 22, coercions: 3, joins: 0/1}
Control.Applicative.$fFunctorWrappedMonad1
  :: forall (m :: * -> *).
     Monad m =>
     forall a b. a -> WrappedMonad m b -> m a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,1*C1(U),A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_XbS7L :: * -> *))
                 ($dMonad_XbS7N :: Monad m_XbS7L)
                 (@ a_abS5L)
                 (@ b_abS5M)
                 (x_i9DkS [Occ=Once] :: a_abS5L)
                 (eta_B1 [Occ=Once] :: WrappedMonad m_XbS7L b_abS5M) ->
                 let {
                   lvl_sbSm4 [Occ=OnceL] :: m_XbS7L a_abS5L
                   [LclId]
                   lvl_sbSm4 = return @ m_XbS7L $dMonad_XbS7N @ a_abS5L x_i9DkS } in
                 >>=
                   @ m_XbS7L
                   $dMonad_XbS7N
                   @ b_abS5M
                   @ a_abS5L
                   (eta_B1
                    `cast` (Control.Applicative.N:WrappedMonad[0]
                                <m_XbS7L>_R <b_abS5M>_N
                            :: (WrappedMonad m_XbS7L b_abS5M :: *) ~R# (m_XbS7L b_abS5M :: *)))
                   (\ _ [Occ=Dead] -> lvl_sbSm4)}]
Control.Applicative.$fFunctorWrappedMonad1
  = \ (@ (m_XbS7L :: * -> *))
      ($dMonad_XbS7N :: Monad m_XbS7L)
      (@ a_abS5L)
      (@ b_abS5M)
      (x_i9DkS :: a_abS5L)
      (eta_B1 :: WrappedMonad m_XbS7L b_abS5M) ->
      let {
        lvl_sbSm4 :: m_XbS7L a_abS5L
        [LclId]
        lvl_sbSm4 = return @ m_XbS7L $dMonad_XbS7N @ a_abS5L x_i9DkS } in
      >>=
        @ m_XbS7L
        $dMonad_XbS7N
        @ b_abS5M
        @ a_abS5L
        (eta_B1
         `cast` (Control.Applicative.N:WrappedMonad[0]
                     <m_XbS7L>_R <b_abS5M>_N
                 :: (WrappedMonad m_XbS7L b_abS5M :: *) ~R# (m_XbS7L b_abS5M :: *)))
        (\ _ [Occ=Dead] -> lvl_sbSm4)

-- RHS size: {terms: 13, types: 21, coercions: 36, joins: 0/0}
Control.Applicative.$fFunctorWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *). Monad m => Functor (WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,C(U),A)>m,
 Unf=DFun: \ (@ (m_abRqb :: * -> *)) (v_X2a :: Monad m_abRqb) ->
       GHC.Base.C:Functor TYPE: WrappedMonad m_abRqb
                          (\ (@ a_XbS7S)
                             (@ b_XbS7U)
                             (f_XbRsy [Occ=Once] :: a_XbS7S -> b_XbS7U)
                             (ds_XbSh0 [Occ=Once] :: WrappedMonad m_abRqb a_XbS7S) ->
                             liftM
                               @ m_abRqb
                               @ a_XbS7S
                               @ b_XbS7U
                               v_X2a
                               f_XbRsy
                               (ds_XbSh0
                                `cast` (Control.Applicative.N:WrappedMonad[0]
                                            <m_abRqb>_R <a_XbS7S>_N
                                        :: (WrappedMonad m_abRqb a_XbS7S :: *)
                                           ~R# (m_abRqb a_XbS7S :: *))))
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a -> b>_R
                                  ->_R <WrappedMonad m_abRqb a>_R
                                  ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_abRqb>_R) <b>_N
                                  :: (forall a b.
                                      (a -> b) -> WrappedMonad m_abRqb a -> m_abRqb b :: *)
                                     ~R# (forall a b.
                                          (a -> b)
                                          -> WrappedMonad m_abRqb a -> WrappedMonad m_abRqb b :: *))
                          (Control.Applicative.$fFunctorWrappedMonad1 @ m_abRqb v_X2a)
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a>_R
                                  ->_R <WrappedMonad m_abRqb b>_R
                                  ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_abRqb>_R) <a>_N
                                  :: (forall a b. a -> WrappedMonad m_abRqb b -> m_abRqb a :: *)
                                     ~R# (forall a b.
                                          a
                                          -> WrappedMonad m_abRqb b
                                          -> WrappedMonad m_abRqb a :: *))]
Control.Applicative.$fFunctorWrappedMonad
  = \ (@ (m_XbS7K :: * -> *)) ($dMonad_XbS7M :: Monad m_XbS7K) ->
      GHC.Base.C:Functor
        @ (WrappedMonad m_XbS7K)
        ((\ (@ a_XbS7S)
            (@ b_XbS7U)
            (f_XbRsy :: a_XbS7S -> b_XbS7U)
            (ds_XbSh0 :: WrappedMonad m_XbS7K a_XbS7S) ->
            liftM
              @ m_XbS7K
              @ a_XbS7S
              @ b_XbS7U
              $dMonad_XbS7M
              f_XbRsy
              (ds_XbSh0
               `cast` (Control.Applicative.N:WrappedMonad[0]
                           <m_XbS7K>_R <a_XbS7S>_N
                       :: (WrappedMonad m_XbS7K a_XbS7S :: *)
                          ~R# (m_XbS7K a_XbS7S :: *))))
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <WrappedMonad m_XbS7K a>_R
                 ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_XbS7K>_R) <b>_N
                 :: (forall a b.
                     (a -> b) -> WrappedMonad m_XbS7K a -> m_XbS7K b :: *)
                    ~R# (forall a b.
                         (a -> b)
                         -> WrappedMonad m_XbS7K a -> WrappedMonad m_XbS7K b :: *)))
        ((Control.Applicative.$fFunctorWrappedMonad1
            @ m_XbS7K $dMonad_XbS7M)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <a>_R
                 ->_R <WrappedMonad m_XbS7K b>_R
                 ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_XbS7K>_R) <a>_N
                 :: (forall a b. a -> WrappedMonad m_XbS7K b -> m_XbS7K a :: *)
                    ~R# (forall a b.
                         a -> WrappedMonad m_XbS7K b -> WrappedMonad m_XbS7K a :: *)))

-- RHS size: {terms: 8, types: 12, coercions: 0, joins: 0/0}
Control.Applicative.$fApplicativeWrappedMonad3
  :: forall (m :: * -> *). Monad m => forall a. a -> m a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_XbS6W :: * -> *))
                 ($dMonad_XbS6Y [Occ=Once] :: Monad m_XbS6W)
                 (@ a_abS4u)
                 (eta_X2d [Occ=Once] :: a_abS4u) ->
                 pure
                   @ m_XbS6W
                   (GHC.Base.$p1Monad @ m_XbS6W $dMonad_XbS6Y)
                   @ a_abS4u
                   eta_X2d}]
Control.Applicative.$fApplicativeWrappedMonad3
  = \ (@ (m_XbS6W :: * -> *))
      ($dMonad_XbS6Y :: Monad m_XbS6W)
      (@ a_abS4u)
      (eta_X2d :: a_abS4u) ->
      pure
        @ m_XbS6W
        (GHC.Base.$p1Monad @ m_XbS6W $dMonad_XbS6Y)
        @ a_abS4u
        eta_X2d

-- RHS size: {terms: 18, types: 31, coercions: 6, joins: 0/1}
Control.Applicative.$fApplicativeWrappedMonad2
  :: forall (m :: * -> *).
     Monad m =>
     forall a b. WrappedMonad m a -> WrappedMonad m b -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 130 0}]
Control.Applicative.$fApplicativeWrappedMonad2
  = \ (@ (m_XbS74 :: * -> *))
      ($dMonad_XbS76 :: Monad m_XbS74)
      (@ a_abS5a)
      (@ b_abS5b)
      (a1_ibJeW :: WrappedMonad m_XbS74 a_abS5a)
      (a2_ibJeX :: WrappedMonad m_XbS74 b_abS5b) ->
      ap
        @ m_XbS74
        @ b_abS5b
        @ b_abS5b
        $dMonad_XbS76
        (let {
           lvl_sbSm5 :: m_XbS74 (b_abS5b -> b_abS5b)
           [LclId]
           lvl_sbSm5
             = return
                 @ m_XbS74
                 $dMonad_XbS76
                 @ (b_abS5b -> b_abS5b)
                 (breakpoint @ b_abS5b) } in
         >>=
           @ m_XbS74
           $dMonad_XbS76
           @ a_abS5a
           @ (b_abS5b -> b_abS5b)
           (a1_ibJeW
            `cast` (Control.Applicative.N:WrappedMonad[0]
                        <m_XbS74>_R <a_abS5a>_N
                    :: (WrappedMonad m_XbS74 a_abS5a :: *) ~R# (m_XbS74 a_abS5a :: *)))
           (\ _ [Occ=Dead] -> lvl_sbSm5))
        (a2_ibJeX
         `cast` (Control.Applicative.N:WrappedMonad[0]
                     <m_XbS74>_R <b_abS5b>_N
                 :: (WrappedMonad m_XbS74 b_abS5b :: *) ~R# (m_XbS74 b_abS5b :: *)))

-- RHS size: {terms: 19, types: 28, coercions: 6, joins: 0/1}
Control.Applicative.$fApplicativeWrappedMonad1
  :: forall (m :: * -> *).
     Monad m =>
     forall a b. WrappedMonad m a -> WrappedMonad m b -> m a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 0 0] 140 0}]
Control.Applicative.$fApplicativeWrappedMonad1
  = \ (@ (m_XbS9j :: * -> *))
      ($dMonad_XbS70 :: Monad m_XbS9j)
      (@ a_abS5k)
      (@ b_abS5l)
      (ds_XbShd :: WrappedMonad m_XbS9j a_abS5k)
      (ds1_XbShf :: WrappedMonad m_XbS9j b_abS5l) ->
      >>=
        @ m_XbS9j
        $dMonad_XbS70
        @ a_abS5k
        @ a_abS5k
        (ds_XbShd
         `cast` (Control.Applicative.N:WrappedMonad[0]
                     <m_XbS9j>_R <a_abS5k>_N
                 :: (WrappedMonad m_XbS9j a_abS5k :: *) ~R# (m_XbS9j a_abS5k :: *)))
        (\ (x1_i9DkE :: a_abS5k) ->
           let {
             lvl_sbSm6 :: m_XbS9j a_abS5k
             [LclId]
             lvl_sbSm6 = return @ m_XbS9j $dMonad_XbS70 @ a_abS5k x1_i9DkE } in
           >>=
             @ m_XbS9j
             $dMonad_XbS70
             @ b_abS5l
             @ a_abS5k
             (ds1_XbShf
              `cast` (Control.Applicative.N:WrappedMonad[0]
                          <m_XbS9j>_R <b_abS5l>_N
                      :: (WrappedMonad m_XbS9j b_abS5l :: *) ~R# (m_XbS9j b_abS5l :: *)))
             (\ _ [Occ=Dead] -> lvl_sbSm6))

-- RHS size: {terms: 30, types: 45, coercions: 102, joins: 0/0}
Control.Applicative.$fApplicativeWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *). Monad m => Applicative (WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A)>m,
 Unf=DFun: \ (@ (m_abRq5 :: * -> *)) (v_X2p :: Monad m_abRq5) ->
       GHC.Base.C:Applicative TYPE: WrappedMonad m_abRq5
                              Control.Applicative.$fFunctorWrappedMonad @ m_abRq5 v_X2p
                              (Control.Applicative.$fApplicativeWrappedMonad3 @ m_abRq5 v_X2p)
                              `cast` (forall (a :: <*>_N).
                                      <a>_R
                                      ->_R Sym (Control.Applicative.N:WrappedMonad[0]
                                                    <m_abRq5>_R) <a>_N
                                      :: (forall a. a -> m_abRq5 a :: *)
                                         ~R# (forall a. a -> WrappedMonad m_abRq5 a :: *))
                              (\ (@ a_XbS7n)
                                 (@ b_XbS7p)
                                 (ds_XbSh2 [Occ=Once] :: WrappedMonad m_abRq5 (a_XbS7n -> b_XbS7p))
                                 (ds1_XbSh4 [Occ=Once] :: WrappedMonad m_abRq5 a_XbS7n) ->
                                 ap
                                   @ m_abRq5
                                   @ a_XbS7n
                                   @ b_XbS7p
                                   v_X2p
                                   (ds_XbSh2
                                    `cast` (Control.Applicative.N:WrappedMonad[0]
                                                <m_abRq5>_R <a_XbS7n -> b_XbS7p>_N
                                            :: (WrappedMonad m_abRq5 (a_XbS7n -> b_XbS7p) :: *)
                                               ~R# (m_abRq5 (a_XbS7n -> b_XbS7p) :: *)))
                                   (ds1_XbSh4
                                    `cast` (Control.Applicative.N:WrappedMonad[0]
                                                <m_abRq5>_R <a_XbS7n>_N
                                            :: (WrappedMonad m_abRq5 a_XbS7n :: *)
                                               ~R# (m_abRq5 a_XbS7n :: *))))
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <WrappedMonad m_abRq5 (a -> b)>_R
                                      ->_R <WrappedMonad m_abRq5 a>_R
                                      ->_R Sym (Control.Applicative.N:WrappedMonad[0]
                                                    <m_abRq5>_R) <b>_N
                                      :: (forall a b.
                                          WrappedMonad m_abRq5 (a -> b)
                                          -> WrappedMonad m_abRq5 a -> m_abRq5 b :: *)
                                         ~R# (forall a b.
                                              WrappedMonad m_abRq5 (a -> b)
                                              -> WrappedMonad m_abRq5 a
                                              -> WrappedMonad m_abRq5 b :: *))
                              (\ (@ a_XbS7A)
                                 (@ b_XbS7C)
                                 (@ c_XbS7E)
                                 (f_XbRsQ [Occ=Once] :: a_XbS7A -> b_XbS7C -> c_XbS7E)
                                 (ds_XbShd [Occ=Once] :: WrappedMonad m_abRq5 a_XbS7A)
                                 (ds1_XbShf [Occ=Once] :: WrappedMonad m_abRq5 b_XbS7C) ->
                                 liftM2
                                   @ m_abRq5
                                   @ a_XbS7A
                                   @ b_XbS7C
                                   @ c_XbS7E
                                   v_X2p
                                   f_XbRsQ
                                   (ds_XbShd
                                    `cast` (Control.Applicative.N:WrappedMonad[0]
                                                <m_abRq5>_R <a_XbS7A>_N
                                            :: (WrappedMonad m_abRq5 a_XbS7A :: *)
                                               ~R# (m_abRq5 a_XbS7A :: *)))
                                   (ds1_XbShf
                                    `cast` (Control.Applicative.N:WrappedMonad[0]
                                                <m_abRq5>_R <b_XbS7C>_N
                                            :: (WrappedMonad m_abRq5 b_XbS7C :: *)
                                               ~R# (m_abRq5 b_XbS7C :: *))))
                              `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                                      <a -> b -> c>_R
                                      ->_R <WrappedMonad m_abRq5 a>_R
                                      ->_R <WrappedMonad m_abRq5 b>_R
                                      ->_R Sym (Control.Applicative.N:WrappedMonad[0]
                                                    <m_abRq5>_R) <c>_N
                                      :: (forall a b c.
                                          (a -> b -> c)
                                          -> WrappedMonad m_abRq5 a
                                          -> WrappedMonad m_abRq5 b
                                          -> m_abRq5 c :: *)
                                         ~R# (forall a b c.
                                              (a -> b -> c)
                                              -> WrappedMonad m_abRq5 a
                                              -> WrappedMonad m_abRq5 b
                                              -> WrappedMonad m_abRq5 c :: *))
                              (Control.Applicative.$fApplicativeWrappedMonad2 @ m_abRq5 v_X2p)
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <WrappedMonad m_abRq5 a>_R
                                      ->_R <WrappedMonad m_abRq5 b>_R
                                      ->_R Sym (Control.Applicative.N:WrappedMonad[0]
                                                    <m_abRq5>_R) <b>_N
                                      :: (forall a b.
                                          WrappedMonad m_abRq5 a
                                          -> WrappedMonad m_abRq5 b -> m_abRq5 b :: *)
                                         ~R# (forall a b.
                                              WrappedMonad m_abRq5 a
                                              -> WrappedMonad m_abRq5 b
                                              -> WrappedMonad m_abRq5 b :: *))
                              (Control.Applicative.$fApplicativeWrappedMonad1 @ m_abRq5 v_X2p)
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <WrappedMonad m_abRq5 a>_R
                                      ->_R <WrappedMonad m_abRq5 b>_R
                                      ->_R Sym (Control.Applicative.N:WrappedMonad[0]
                                                    <m_abRq5>_R) <a>_N
                                      :: (forall a b.
                                          WrappedMonad m_abRq5 a
                                          -> WrappedMonad m_abRq5 b -> m_abRq5 a :: *)
                                         ~R# (forall a b.
                                              WrappedMonad m_abRq5 a
                                              -> WrappedMonad m_abRq5 b
                                              -> WrappedMonad m_abRq5 a :: *))]
Control.Applicative.$fApplicativeWrappedMonad
  = \ (@ (m_XbS6X :: * -> *)) ($dMonad_XbS6Z :: Monad m_XbS6X) ->
      GHC.Base.C:Applicative
        @ (WrappedMonad m_XbS6X)
        (Control.Applicative.$fFunctorWrappedMonad @ m_XbS6X $dMonad_XbS6Z)
        ((Control.Applicative.$fApplicativeWrappedMonad3
            @ m_XbS6X $dMonad_XbS6Z)
         `cast` (forall (a :: <*>_N).
                 <a>_R
                 ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_XbS6X>_R) <a>_N
                 :: (forall a. a -> m_XbS6X a :: *)
                    ~R# (forall a. a -> WrappedMonad m_XbS6X a :: *)))
        ((\ (@ a_XbS7n)
            (@ b_XbS7p)
            (ds_XbSh2 :: WrappedMonad m_XbS6X (a_XbS7n -> b_XbS7p))
            (ds1_XbSh4 :: WrappedMonad m_XbS6X a_XbS7n) ->
            ap
              @ m_XbS6X
              @ a_XbS7n
              @ b_XbS7p
              $dMonad_XbS6Z
              (ds_XbSh2
               `cast` (Control.Applicative.N:WrappedMonad[0] <m_XbS6X>_R <a_XbS7n
                                                                          -> b_XbS7p>_N
                       :: (WrappedMonad m_XbS6X (a_XbS7n -> b_XbS7p) :: *)
                          ~R# (m_XbS6X (a_XbS7n -> b_XbS7p) :: *)))
              (ds1_XbSh4
               `cast` (Control.Applicative.N:WrappedMonad[0]
                           <m_XbS6X>_R <a_XbS7n>_N
                       :: (WrappedMonad m_XbS6X a_XbS7n :: *)
                          ~R# (m_XbS6X a_XbS7n :: *))))
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <WrappedMonad m_XbS6X (a -> b)>_R
                 ->_R <WrappedMonad m_XbS6X a>_R
                 ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_XbS6X>_R) <b>_N
                 :: (forall a b.
                     WrappedMonad m_XbS6X (a -> b)
                     -> WrappedMonad m_XbS6X a -> m_XbS6X b :: *)
                    ~R# (forall a b.
                         WrappedMonad m_XbS6X (a -> b)
                         -> WrappedMonad m_XbS6X a -> WrappedMonad m_XbS6X b :: *)))
        ((\ (@ a_XbS7A)
            (@ b_XbS7C)
            (@ c_XbS7E)
            (f_XbRsQ :: a_XbS7A -> b_XbS7C -> c_XbS7E)
            (ds_XbShd :: WrappedMonad m_XbS6X a_XbS7A)
            (ds1_XbShf :: WrappedMonad m_XbS6X b_XbS7C) ->
            liftM2
              @ m_XbS6X
              @ a_XbS7A
              @ b_XbS7C
              @ c_XbS7E
              $dMonad_XbS6Z
              f_XbRsQ
              (ds_XbShd
               `cast` (Control.Applicative.N:WrappedMonad[0]
                           <m_XbS6X>_R <a_XbS7A>_N
                       :: (WrappedMonad m_XbS6X a_XbS7A :: *) ~R# (m_XbS6X a_XbS7A :: *)))
              (ds1_XbShf
               `cast` (Control.Applicative.N:WrappedMonad[0]
                           <m_XbS6X>_R <b_XbS7C>_N
                       :: (WrappedMonad m_XbS6X b_XbS7C :: *)
                          ~R# (m_XbS6X b_XbS7C :: *))))
         `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                 <a -> b -> c>_R
                 ->_R <WrappedMonad m_XbS6X a>_R
                 ->_R <WrappedMonad m_XbS6X b>_R
                 ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_XbS6X>_R) <c>_N
                 :: (forall a b c.
                     (a -> b -> c)
                     -> WrappedMonad m_XbS6X a
                     -> WrappedMonad m_XbS6X b
                     -> m_XbS6X c :: *)
                    ~R# (forall a b c.
                         (a -> b -> c)
                         -> WrappedMonad m_XbS6X a
                         -> WrappedMonad m_XbS6X b
                         -> WrappedMonad m_XbS6X c :: *)))
        ((Control.Applicative.$fApplicativeWrappedMonad2
            @ m_XbS6X $dMonad_XbS6Z)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <WrappedMonad m_XbS6X a>_R
                 ->_R <WrappedMonad m_XbS6X b>_R
                 ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_XbS6X>_R) <b>_N
                 :: (forall a b.
                     WrappedMonad m_XbS6X a -> WrappedMonad m_XbS6X b -> m_XbS6X b :: *)
                    ~R# (forall a b.
                         WrappedMonad m_XbS6X a
                         -> WrappedMonad m_XbS6X b -> WrappedMonad m_XbS6X b :: *)))
        ((Control.Applicative.$fApplicativeWrappedMonad1
            @ m_XbS6X $dMonad_XbS6Z)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 <WrappedMonad m_XbS6X a>_R
                 ->_R <WrappedMonad m_XbS6X b>_R
                 ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_XbS6X>_R) <a>_N
                 :: (forall a b.
                     WrappedMonad m_XbS6X a -> WrappedMonad m_XbS6X b -> m_XbS6X a :: *)
                    ~R# (forall a b.
                         WrappedMonad m_XbS6X a
                         -> WrappedMonad m_XbS6X b -> WrappedMonad m_XbS6X a :: *)))

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative
  :: forall (m :: * -> *).
     MonadPlus m =>
     Applicative (WrappedMonad m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_XbS6t :: * -> *))
                 ($dMonadPlus_XbS6v [Occ=Once] :: MonadPlus m_XbS6t) ->
                 Control.Applicative.$fApplicativeWrappedMonad
                   @ m_XbS6t (GHC.Base.$p2MonadPlus @ m_XbS6t $dMonadPlus_XbS6v)}]
Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative
  = \ (@ (m_XbS6t :: * -> *))
      ($dMonadPlus_XbS6v :: MonadPlus m_XbS6t) ->
      Control.Applicative.$fApplicativeWrappedMonad
        @ m_XbS6t (GHC.Base.$p2MonadPlus @ m_XbS6t $dMonadPlus_XbS6v)

-- RHS size: {terms: 30, types: 44, coercions: 8, joins: 0/3}
Control.Applicative.$fAlternativeWrappedMonad_$csome
  :: forall (m :: * -> *).
     MonadPlus m =>
     forall a. WrappedMonad m a -> WrappedMonad m [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),A,C(C1(U)))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 280 0}]
Control.Applicative.$fAlternativeWrappedMonad_$csome
  = \ (@ (m_XbS6w :: * -> *))
      ($dMonadPlus_XbS6y :: MonadPlus m_XbS6w)
      (@ a_abS46)
      (eta_B1 :: WrappedMonad m_XbS6w a_abS46) ->
      let {
        $dApplicative_sbSm2 [Dmd=<S(LC(C(S))LLL),U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A)>]
          :: Monad m_XbS6w
        [LclId]
        $dApplicative_sbSm2
          = GHC.Base.$p2MonadPlus @ m_XbS6w $dMonadPlus_XbS6y } in
      letrec {
        m2_sbSm0 :: m_XbS6w [a_abS46]
        [LclId]
        m2_sbSm0
          = mplus
              @ m_XbS6w
              $dMonadPlus_XbS6y
              @ [a_abS46]
              some_v_sbSm1
              (pure
                 @ m_XbS6w
                 (GHC.Base.$p1Monad @ m_XbS6w $dApplicative_sbSm2)
                 @ [a_abS46]
                 (GHC.Types.[] @ a_abS46));
        some_v_sbSm1 [Occ=LoopBreaker] :: m_XbS6w [a_abS46]
        [LclId]
        some_v_sbSm1
          = >>=
              @ m_XbS6w
              $dApplicative_sbSm2
              @ a_abS46
              @ [a_abS46]
              (eta_B1
               `cast` (Control.Applicative.N:WrappedMonad[0]
                           <m_XbS6w>_R <a_abS46>_N
                       :: (WrappedMonad m_XbS6w a_abS46 :: *) ~R# (m_XbS6w a_abS46 :: *)))
              (\ (x1_i9DkE :: a_abS46) ->
                 >>=
                   @ m_XbS6w
                   $dApplicative_sbSm2
                   @ [a_abS46]
                   @ [a_abS46]
                   m2_sbSm0
                   (\ (x2_i9DkF :: [a_abS46]) ->
                      return
                        @ m_XbS6w
                        $dApplicative_sbSm2
                        @ [a_abS46]
                        (GHC.Types.: @ a_abS46 x1_i9DkE x2_i9DkF))); } in
      some_v_sbSm1
      `cast` (Sym (Control.Applicative.N:WrappedMonad[0]
                       <m_XbS6w>_R) <[a_abS46]>_N
              :: (m_XbS6w [a_abS46] :: *)
                 ~R# (WrappedMonad m_XbS6w [a_abS46] :: *))

-- RHS size: {terms: 28, types: 41, coercions: 8, joins: 0/2}
Control.Applicative.$fAlternativeWrappedMonad_$cmany
  :: forall (m :: * -> *).
     MonadPlus m =>
     forall a. WrappedMonad m a -> WrappedMonad m [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))),U(A,U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),A,C(C1(U)))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 270 0}]
Control.Applicative.$fAlternativeWrappedMonad_$cmany
  = \ (@ (m_XbS6v :: * -> *))
      ($dMonadPlus_XbS6x :: MonadPlus m_XbS6v)
      (@ a_abS4e)
      (eta_B1 :: WrappedMonad m_XbS6v a_abS4e) ->
      letrec {
        many_v_sbSlW [Occ=LoopBreaker] :: m_XbS6v [a_abS4e]
        [LclId]
        many_v_sbSlW
          = let {
              $dApplicative_sbSlX [Dmd=<L,U(1*U(A,1*C1(U),A,A,A,A),C(C1(U)),A,C(U),A)>]
                :: Monad m_XbS6v
              [LclId]
              $dApplicative_sbSlX
                = GHC.Base.$p2MonadPlus @ m_XbS6v $dMonadPlus_XbS6x } in
            mplus
              @ m_XbS6v
              $dMonadPlus_XbS6x
              @ [a_abS4e]
              (>>=
                 @ m_XbS6v
                 $dApplicative_sbSlX
                 @ a_abS4e
                 @ [a_abS4e]
                 (eta_B1
                  `cast` (Control.Applicative.N:WrappedMonad[0]
                              <m_XbS6v>_R <a_abS4e>_N
                          :: (WrappedMonad m_XbS6v a_abS4e :: *) ~R# (m_XbS6v a_abS4e :: *)))
                 (\ (x1_i9DkE :: a_abS4e) ->
                    >>=
                      @ m_XbS6v
                      $dApplicative_sbSlX
                      @ [a_abS4e]
                      @ [a_abS4e]
                      many_v_sbSlW
                      (\ (x2_i9DkF :: [a_abS4e]) ->
                         return
                           @ m_XbS6v
                           $dApplicative_sbSlX
                           @ [a_abS4e]
                           (GHC.Types.: @ a_abS4e x1_i9DkE x2_i9DkF))))
              (pure
                 @ m_XbS6v
                 (GHC.Base.$p1Monad @ m_XbS6v $dApplicative_sbSlX)
                 @ [a_abS4e]
                 (GHC.Types.[] @ a_abS4e)); } in
      many_v_sbSlW
      `cast` (Sym (Control.Applicative.N:WrappedMonad[0]
                       <m_XbS6v>_R) <[a_abS4e]>_N
              :: (m_XbS6v [a_abS4e] :: *)
                 ~R# (WrappedMonad m_XbS6v [a_abS4e] :: *))

-- RHS size: {terms: 18, types: 22, coercions: 28, joins: 0/0}
Control.Applicative.$fAlternativeWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     MonadPlus m =>
     Alternative (WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),1*U,C(C1(U)))>m,
 Unf=DFun: \ (@ (m_abRq2 :: * -> *)) (v_X2t :: MonadPlus m_abRq2) ->
       GHC.Base.C:Alternative TYPE: WrappedMonad m_abRq2
                              Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative
                                @ m_abRq2 v_X2t
                              (mzero @ m_abRq2 v_X2t)
                              `cast` (forall (a :: <*>_N).
                                      Sym (Control.Applicative.N:WrappedMonad[0] <m_abRq2>_R) <a>_N
                                      :: (forall a. m_abRq2 a :: *)
                                         ~R# (forall a. WrappedMonad m_abRq2 a :: *))
                              (\ (@ a_XbS6R)
                                 (ds_XbSh2 [Occ=Once] :: WrappedMonad m_abRq2 a_XbS6R)
                                 (ds1_XbSh4 [Occ=Once] :: WrappedMonad m_abRq2 a_XbS6R) ->
                                 mplus
                                   @ m_abRq2
                                   v_X2t
                                   @ a_XbS6R
                                   (ds_XbSh2
                                    `cast` (Control.Applicative.N:WrappedMonad[0]
                                                <m_abRq2>_R <a_XbS6R>_N
                                            :: (WrappedMonad m_abRq2 a_XbS6R :: *)
                                               ~R# (m_abRq2 a_XbS6R :: *)))
                                   (ds1_XbSh4
                                    `cast` (Control.Applicative.N:WrappedMonad[0]
                                                <m_abRq2>_R <a_XbS6R>_N
                                            :: (WrappedMonad m_abRq2 a_XbS6R :: *)
                                               ~R# (m_abRq2 a_XbS6R :: *))))
                              `cast` (forall (a :: <*>_N).
                                      <WrappedMonad m_abRq2 a>_R
                                      ->_R <WrappedMonad m_abRq2 a>_R
                                      ->_R Sym (Control.Applicative.N:WrappedMonad[0]
                                                    <m_abRq2>_R) <a>_N
                                      :: (forall a.
                                          WrappedMonad m_abRq2 a
                                          -> WrappedMonad m_abRq2 a -> m_abRq2 a :: *)
                                         ~R# (forall a.
                                              WrappedMonad m_abRq2 a
                                              -> WrappedMonad m_abRq2 a
                                              -> WrappedMonad m_abRq2 a :: *))
                              Control.Applicative.$fAlternativeWrappedMonad_$csome
                                @ m_abRq2 v_X2t
                              Control.Applicative.$fAlternativeWrappedMonad_$cmany
                                @ m_abRq2 v_X2t]
Control.Applicative.$fAlternativeWrappedMonad
  = \ (@ (m_XbS6u :: * -> *))
      ($dMonadPlus_XbS6w :: MonadPlus m_XbS6u) ->
      GHC.Base.C:Alternative
        @ (WrappedMonad m_XbS6u)
        (Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative
           @ m_XbS6u $dMonadPlus_XbS6w)
        ((mzero @ m_XbS6u $dMonadPlus_XbS6w)
         `cast` (forall (a :: <*>_N).
                 Sym (Control.Applicative.N:WrappedMonad[0] <m_XbS6u>_R) <a>_N
                 :: (forall a. m_XbS6u a :: *)
                    ~R# (forall a. WrappedMonad m_XbS6u a :: *)))
        ((\ (@ a_XbS6R)
            (ds_XbSh2 :: WrappedMonad m_XbS6u a_XbS6R)
            (ds1_XbSh4 :: WrappedMonad m_XbS6u a_XbS6R) ->
            mplus
              @ m_XbS6u
              $dMonadPlus_XbS6w
              @ a_XbS6R
              (ds_XbSh2
               `cast` (Control.Applicative.N:WrappedMonad[0]
                           <m_XbS6u>_R <a_XbS6R>_N
                       :: (WrappedMonad m_XbS6u a_XbS6R :: *) ~R# (m_XbS6u a_XbS6R :: *)))
              (ds1_XbSh4
               `cast` (Control.Applicative.N:WrappedMonad[0]
                           <m_XbS6u>_R <a_XbS6R>_N
                       :: (WrappedMonad m_XbS6u a_XbS6R :: *)
                          ~R# (m_XbS6u a_XbS6R :: *))))
         `cast` (forall (a :: <*>_N).
                 <WrappedMonad m_XbS6u a>_R
                 ->_R <WrappedMonad m_XbS6u a>_R
                 ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_XbS6u>_R) <a>_N
                 :: (forall a.
                     WrappedMonad m_XbS6u a -> WrappedMonad m_XbS6u a -> m_XbS6u a :: *)
                    ~R# (forall a.
                         WrappedMonad m_XbS6u a
                         -> WrappedMonad m_XbS6u a -> WrappedMonad m_XbS6u a :: *)))
        (Control.Applicative.$fAlternativeWrappedMonad_$csome
           @ m_XbS6u $dMonadPlus_XbS6w)
        (Control.Applicative.$fAlternativeWrappedMonad_$cmany
           @ m_XbS6u $dMonadPlus_XbS6w)

-- RHS size: {terms: 14, types: 30, coercions: 4, joins: 0/0}
Control.Applicative.$fFunctorWrappedArrow2
  :: forall (a :: * -> * -> *) b.
     Arrow a =>
     forall a1 b1. (a1 -> b1) -> WrappedArrow a b a1 -> a b b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_abS32 :: * -> * -> *))
                 (@ b_abS33)
                 ($dArrow_abS34 :: Arrow a_abS32)
                 (@ a1_abS38)
                 (@ b1_abS39)
                 (eta_B2 [Occ=Once] :: a1_abS38 -> b1_abS39)
                 (eta1_X2z [Occ=Once] :: WrappedArrow a_abS32 b_abS33 a1_abS38) ->
                 Control.Category..
                   @ *
                   @ a_abS32
                   (Control.Arrow.$p1Arrow @ a_abS32 $dArrow_abS34)
                   @ a1_abS38
                   @ b1_abS39
                   @ b_abS33
                   (arr @ a_abS32 $dArrow_abS34 @ a1_abS38 @ b1_abS39 eta_B2)
                   (eta1_X2z
                    `cast` (Control.Applicative.N:WrappedArrow[0]
                                <a_abS32>_R <b_abS33>_N <a1_abS38>_N
                            :: (WrappedArrow a_abS32 b_abS33 a1_abS38 :: *)
                               ~R# (a_abS32 b_abS33 a1_abS38 :: *)))}]
Control.Applicative.$fFunctorWrappedArrow2
  = \ (@ (a_abS32 :: * -> * -> *))
      (@ b_abS33)
      ($dArrow_abS34 :: Arrow a_abS32)
      (@ a1_abS38)
      (@ b1_abS39)
      (eta_B2 :: a1_abS38 -> b1_abS39)
      (eta1_X2z :: WrappedArrow a_abS32 b_abS33 a1_abS38) ->
      Control.Category..
        @ *
        @ a_abS32
        (Control.Arrow.$p1Arrow @ a_abS32 $dArrow_abS34)
        @ a1_abS38
        @ b1_abS39
        @ b_abS33
        (arr @ a_abS32 $dArrow_abS34 @ a1_abS38 @ b1_abS39 eta_B2)
        (eta1_X2z
         `cast` (Control.Applicative.N:WrappedArrow[0]
                     <a_abS32>_R <b_abS33>_N <a1_abS38>_N
                 :: (WrappedArrow a_abS32 b_abS33 a1_abS38 :: *)
                    ~R# (a_abS32 b_abS33 a1_abS38 :: *)))

-- RHS size: {terms: 15, types: 30, coercions: 4, joins: 0/0}
Control.Applicative.$fFunctorWrappedArrow1
  :: forall (a :: * -> * -> *) b.
     Arrow a =>
     forall a1 b1. a1 -> WrappedArrow a b b1 -> a b a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_XbS5D :: * -> * -> *))
                 (@ b_XbS5F)
                 ($dArrow_XbS5H :: Arrow a_XbS5D)
                 (@ a1_abS3s)
                 (@ b1_abS3t)
                 (x_X9Dny [Occ=OnceL] :: a1_abS3s)
                 (eta_X2I [Occ=Once] :: WrappedArrow a_XbS5D b_XbS5F b1_abS3t) ->
                 Control.Category..
                   @ *
                   @ a_XbS5D
                   (Control.Arrow.$p1Arrow @ a_XbS5D $dArrow_XbS5H)
                   @ b1_abS3t
                   @ a1_abS3s
                   @ b_XbS5F
                   (arr
                      @ a_XbS5D
                      $dArrow_XbS5H
                      @ b1_abS3t
                      @ a1_abS3s
                      (\ _ [Occ=Dead] -> x_X9Dny))
                   (eta_X2I
                    `cast` (Control.Applicative.N:WrappedArrow[0]
                                <a_XbS5D>_R <b_XbS5F>_N <b1_abS3t>_N
                            :: (WrappedArrow a_XbS5D b_XbS5F b1_abS3t :: *)
                               ~R# (a_XbS5D b_XbS5F b1_abS3t :: *)))}]
Control.Applicative.$fFunctorWrappedArrow1
  = \ (@ (a_XbS5D :: * -> * -> *))
      (@ b_XbS5F)
      ($dArrow_XbS5H :: Arrow a_XbS5D)
      (@ a1_abS3s)
      (@ b1_abS3t)
      (x_X9Dny :: a1_abS3s)
      (eta_X2I :: WrappedArrow a_XbS5D b_XbS5F b1_abS3t) ->
      Control.Category..
        @ *
        @ a_XbS5D
        (Control.Arrow.$p1Arrow @ a_XbS5D $dArrow_XbS5H)
        @ b1_abS3t
        @ a1_abS3s
        @ b_XbS5F
        (arr
           @ a_XbS5D
           $dArrow_XbS5H
           @ b1_abS3t
           @ a1_abS3s
           (\ _ [Occ=Dead] -> x_X9Dny))
        (eta_X2I
         `cast` (Control.Applicative.N:WrappedArrow[0]
                     <a_XbS5D>_R <b_XbS5F>_N <b1_abS3t>_N
                 :: (WrappedArrow a_XbS5D b_XbS5F b1_abS3t :: *)
                    ~R# (a_XbS5D b_XbS5F b1_abS3t :: *)))

-- RHS size: {terms: 8, types: 17, coercions: 37, joins: 0/0}
Control.Applicative.$fFunctorWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b.
     Arrow a =>
     Functor (WrappedArrow a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,A)>m,
 Unf=DFun: \ (@ (a_abRpY :: * -> * -> *))
             (@ b_abRpZ)
             (v_X2N :: Arrow a_abRpY) ->
       GHC.Base.C:Functor TYPE: WrappedArrow a_abRpY b_abRpZ
                          (Control.Applicative.$fFunctorWrappedArrow2
                             @ a_abRpY @ b_abRpZ v_X2N)
                          `cast` (forall (a1 :: <*>_N) (b1 :: <*>_N).
                                  <a1 -> b1>_R
                                  ->_R <WrappedArrow a_abRpY b_abRpZ a1>_R
                                  ->_R Sym (Control.Applicative.N:WrappedArrow[0]
                                                <a_abRpY>_R) <b_abRpZ>_N <b1>_N
                                  :: (forall a1 b1.
                                      (a1 -> b1)
                                      -> WrappedArrow a_abRpY b_abRpZ a1 -> a_abRpY b_abRpZ b1 :: *)
                                     ~R# (forall a1 b1.
                                          (a1 -> b1)
                                          -> WrappedArrow a_abRpY b_abRpZ a1
                                          -> WrappedArrow a_abRpY b_abRpZ b1 :: *))
                          (Control.Applicative.$fFunctorWrappedArrow1
                             @ a_abRpY @ b_abRpZ v_X2N)
                          `cast` (forall (a1 :: <*>_N) (b1 :: <*>_N).
                                  <a1>_R
                                  ->_R <WrappedArrow a_abRpY b_abRpZ b1>_R
                                  ->_R Sym (Control.Applicative.N:WrappedArrow[0]
                                                <a_abRpY>_R) <b_abRpZ>_N <a1>_N
                                  :: (forall a1 b1.
                                      a1
                                      -> WrappedArrow a_abRpY b_abRpZ b1 -> a_abRpY b_abRpZ a1 :: *)
                                     ~R# (forall a1 b1.
                                          a1
                                          -> WrappedArrow a_abRpY b_abRpZ b1
                                          -> WrappedArrow a_abRpY b_abRpZ a1 :: *))]
Control.Applicative.$fFunctorWrappedArrow
  = \ (@ (a_XbS5M :: * -> * -> *))
      (@ b_XbS5O)
      ($dArrow_XbS5Q :: Arrow a_XbS5M) ->
      GHC.Base.C:Functor
        @ (WrappedArrow a_XbS5M b_XbS5O)
        ((Control.Applicative.$fFunctorWrappedArrow2
            @ a_XbS5M @ b_XbS5O $dArrow_XbS5Q)
         `cast` (forall (a1 :: <*>_N) (b1 :: <*>_N).
                 <a1 -> b1>_R
                 ->_R <WrappedArrow a_XbS5M b_XbS5O a1>_R
                 ->_R Sym (Control.Applicative.N:WrappedArrow[0]
                               <a_XbS5M>_R) <b_XbS5O>_N <b1>_N
                 :: (forall a1 b1.
                     (a1 -> b1)
                     -> WrappedArrow a_XbS5M b_XbS5O a1 -> a_XbS5M b_XbS5O b1 :: *)
                    ~R# (forall a1 b1.
                         (a1 -> b1)
                         -> WrappedArrow a_XbS5M b_XbS5O a1
                         -> WrappedArrow a_XbS5M b_XbS5O b1 :: *)))
        ((Control.Applicative.$fFunctorWrappedArrow1
            @ a_XbS5M @ b_XbS5O $dArrow_XbS5Q)
         `cast` (forall (a1 :: <*>_N) (b1 :: <*>_N).
                 <a1>_R
                 ->_R <WrappedArrow a_XbS5M b_XbS5O b1>_R
                 ->_R Sym (Control.Applicative.N:WrappedArrow[0]
                               <a_XbS5M>_R) <b_XbS5O>_N <a1>_N
                 :: (forall a1 b1.
                     a1 -> WrappedArrow a_XbS5M b_XbS5O b1 -> a_XbS5M b_XbS5O a1 :: *)
                    ~R# (forall a1 b1.
                         a1
                         -> WrappedArrow a_XbS5M b_XbS5O b1
                         -> WrappedArrow a_XbS5M b_XbS5O a1 :: *)))

-- RHS size: {terms: 20, types: 48, coercions: 8, joins: 0/0}
Control.Applicative.$fAlternativeWrappedArrow2
  :: forall (a :: * -> * -> *) b.
     Arrow a =>
     forall a1 b1 c.
     (a1 -> b1 -> c)
     -> WrappedArrow a b a1 -> WrappedArrow a b b1 -> a b c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,1*C1(C1(U)))><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 0 0 0] 150 0}]
Control.Applicative.$fAlternativeWrappedArrow2
  = \ (@ (a_abS1H :: * -> * -> *))
      (@ b_abS1I)
      ($dArrow_abS1J :: Arrow a_abS1H)
      (@ a1_abS2g)
      (@ b1_abS2h)
      (@ c_abS2i)
      (eta_B3 :: a1_abS2g -> b1_abS2h -> c_abS2i)
      (eta1_X2U :: WrappedArrow a_abS1H b_abS1I a1_abS2g)
      (eta2_X5N :: WrappedArrow a_abS1H b_abS1I b1_abS2h) ->
      Control.Category..
        @ *
        @ a_abS1H
        (Control.Arrow.$p1Arrow @ a_abS1H $dArrow_abS1J)
        @ (a1_abS2g, b1_abS2h)
        @ c_abS2i
        @ b_abS1I
        (arr
           @ a_abS1H
           $dArrow_abS1J
           @ (a1_abS2g, b1_abS2h)
           @ c_abS2i
           (uncurry @ a1_abS2g @ b1_abS2h @ c_abS2i eta_B3))
        (&&&
           @ a_abS1H
           $dArrow_abS1J
           @ b_abS1I
           @ a1_abS2g
           @ b1_abS2h
           (eta1_X2U
            `cast` (Control.Applicative.N:WrappedArrow[0]
                        <a_abS1H>_R <b_abS1I>_N <a1_abS2g>_N
                    :: (WrappedArrow a_abS1H b_abS1I a1_abS2g :: *)
                       ~R# (a_abS1H b_abS1I a1_abS2g :: *)))
           (eta2_X5N
            `cast` (Control.Applicative.N:WrappedArrow[0]
                        <a_abS1H>_R <b_abS1I>_N <b1_abS2h>_N
                    :: (WrappedArrow a_abS1H b_abS1I b1_abS2h :: *)
                       ~R# (a_abS1H b_abS1I b1_abS2h :: *))))

-- RHS size: {terms: 9, types: 17, coercions: 0, joins: 0/0}
Control.Applicative.$fApplicativeWrappedArrow5
  :: forall (a :: * -> * -> *) b. Arrow a => forall a1. a1 -> a b a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_XbS4D :: * -> * -> *))
                 (@ b_XbS4F)
                 ($dArrow_XbS4H [Occ=Once] :: Arrow a_XbS4D)
                 (@ a1_abS1R)
                 (x_abRpU [Occ=OnceL] :: a1_abS1R) ->
                 arr
                   @ a_XbS4D
                   $dArrow_XbS4H
                   @ b_XbS4F
                   @ a1_abS1R
                   (\ _ [Occ=Dead] -> x_abRpU)}]
Control.Applicative.$fApplicativeWrappedArrow5
  = \ (@ (a_XbS4D :: * -> * -> *))
      (@ b_XbS4F)
      ($dArrow_XbS4H :: Arrow a_XbS4D)
      (@ a1_abS1R)
      (x_abRpU :: a1_abS1R) ->
      arr
        @ a_XbS4D
        $dArrow_XbS4H
        @ b_XbS4F
        @ a1_abS1R
        (\ _ [Occ=Dead] -> x_abRpU)

-- RHS size: {terms: 8, types: 22, coercions: 0, joins: 0/0}
Control.Applicative.$fApplicativeWrappedArrow4
  :: forall (a :: * -> * -> *) b.
     Arrow a =>
     forall a1 b1.
     WrappedArrow a b (a1 -> b1) -> WrappedArrow a b a1 -> a b b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_XbS4R :: * -> * -> *))
                 (@ b_XbS4T)
                 ($dArrow_XbS4V [Occ=Once] :: Arrow a_XbS4R)
                 (@ a1_abS26)
                 (@ b1_abS27) ->
                 Control.Applicative.$fAlternativeWrappedArrow2
                   @ a_XbS4R
                   @ b_XbS4T
                   $dArrow_XbS4V
                   @ (a1_abS26 -> b1_abS27)
                   @ a1_abS26
                   @ b1_abS27
                   (breakpoint @ (a1_abS26 -> b1_abS27))}]
Control.Applicative.$fApplicativeWrappedArrow4
  = \ (@ (a_XbS4R :: * -> * -> *))
      (@ b_XbS4T)
      ($dArrow_XbS4V :: Arrow a_XbS4R)
      (@ a1_abS26)
      (@ b1_abS27) ->
      Control.Applicative.$fAlternativeWrappedArrow2
        @ a_XbS4R
        @ b_XbS4T
        $dArrow_XbS4V
        @ (a1_abS26 -> b1_abS27)
        @ a1_abS26
        @ b1_abS27
        (breakpoint @ (a1_abS26 -> b1_abS27))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Control.Applicative.$fApplicativeWrappedArrow3
  :: forall b a. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_abS2K)
                 (@ a_abS2J)
                 _ [Occ=Dead]
                 (eta_B1 [Occ=Once] :: b_abS2K) ->
                 eta_B1}]
Control.Applicative.$fApplicativeWrappedArrow3
  = \ (@ b_abS2K) (@ a_abS2J) _ [Occ=Dead] (eta_B1 :: b_abS2K) ->
      eta_B1

-- RHS size: {terms: 18, types: 44, coercions: 10, joins: 0/0}
Control.Applicative.$fApplicativeWrappedArrow2
  :: forall (a :: * -> * -> *) b.
     Arrow a =>
     forall a1 b1. WrappedArrow a b a1 -> WrappedArrow a b b1 -> a b b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 140 0}]
Control.Applicative.$fApplicativeWrappedArrow2
  = \ (@ (a_XbS4Q :: * -> * -> *))
      (@ b_XbS4S)
      ($dArrow_XbS4U :: Arrow a_XbS4Q)
      (@ a1_abS2J)
      (@ b1_abS2K)
      (a2_ibJeW :: WrappedArrow a_XbS4Q b_XbS4S a1_abS2J)
      (a3_ibJeX :: WrappedArrow a_XbS4Q b_XbS4S b1_abS2K) ->
      Control.Applicative.$fAlternativeWrappedArrow2
        @ a_XbS4Q
        @ b_XbS4S
        $dArrow_XbS4U
        @ (b1_abS2K -> b1_abS2K)
        @ b1_abS2K
        @ b1_abS2K
        (breakpoint @ (b1_abS2K -> b1_abS2K))
        ((Control.Category..
            @ *
            @ a_XbS4Q
            (Control.Arrow.$p1Arrow @ a_XbS4Q $dArrow_XbS4U)
            @ a1_abS2J
            @ (b1_abS2K -> b1_abS2K)
            @ b_XbS4S
            (arr
               @ a_XbS4Q
               $dArrow_XbS4U
               @ a1_abS2J
               @ (b1_abS2K -> b1_abS2K)
               (Control.Applicative.$fApplicativeWrappedArrow3
                  @ b1_abS2K @ a1_abS2J))
            (a2_ibJeW
             `cast` (Control.Applicative.N:WrappedArrow[0]
                         <a_XbS4Q>_R <b_XbS4S>_N <a1_abS2J>_N
                     :: (WrappedArrow a_XbS4Q b_XbS4S a1_abS2J :: *)
                        ~R# (a_XbS4Q b_XbS4S a1_abS2J :: *))))
         `cast` (Sym (Control.Applicative.N:WrappedArrow[0]
                          <a_XbS4Q>_R) <b_XbS4S>_N <b1_abS2K -> b1_abS2K>_N
                 :: (a_XbS4Q b_XbS4S (b1_abS2K -> b1_abS2K) :: *)
                    ~R# (WrappedArrow a_XbS4Q b_XbS4S (b1_abS2K -> b1_abS2K) :: *)))
        a3_ibJeX

-- RHS size: {terms: 8, types: 21, coercions: 0, joins: 0/0}
Control.Applicative.$fApplicativeWrappedArrow1
  :: forall (a :: * -> * -> *) b.
     Arrow a =>
     forall a1 b1. WrappedArrow a b a1 -> WrappedArrow a b b1 -> a b a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_XbS4P :: * -> * -> *))
                 (@ b_XbS85)
                 ($dArrow_XbS88 [Occ=Once] :: Arrow a_XbS4P)
                 (@ a1_abS2T)
                 (@ b1_abS2U) ->
                 Control.Applicative.$fAlternativeWrappedArrow2
                   @ a_XbS4P
                   @ b_XbS85
                   $dArrow_XbS88
                   @ a1_abS2T
                   @ b1_abS2U
                   @ a1_abS2T
                   (const @ a1_abS2T @ b1_abS2U)}]
Control.Applicative.$fApplicativeWrappedArrow1
  = \ (@ (a_XbS4P :: * -> * -> *))
      (@ b_XbS85)
      ($dArrow_XbS88 :: Arrow a_XbS4P)
      (@ a1_abS2T)
      (@ b1_abS2U) ->
      Control.Applicative.$fAlternativeWrappedArrow2
        @ a_XbS4P
        @ b_XbS85
        $dArrow_XbS88
        @ a1_abS2T
        @ b1_abS2U
        @ a1_abS2T
        (const @ a1_abS2T @ b1_abS2U)

-- RHS size: {terms: 16, types: 25, coercions: 102, joins: 0/0}
Control.Applicative.$fApplicativeWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b.
     Arrow a =>
     Applicative (WrappedArrow a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>m,
 Unf=DFun: \ (@ (a_abRpS :: * -> * -> *))
             (@ b_abRpT)
             (v_X3n :: Arrow a_abRpS) ->
       GHC.Base.C:Applicative TYPE: WrappedArrow a_abRpS b_abRpT
                              Control.Applicative.$fFunctorWrappedArrow @ a_abRpS @ b_abRpT v_X3n
                              (Control.Applicative.$fApplicativeWrappedArrow5
                                 @ a_abRpS @ b_abRpT v_X3n)
                              `cast` (forall (a1 :: <*>_N).
                                      <a1>_R
                                      ->_R Sym (Control.Applicative.N:WrappedArrow[0]
                                                    <a_abRpS>_R) <b_abRpT>_N <a1>_N
                                      :: (forall a1. a1 -> a_abRpS b_abRpT a1 :: *)
                                         ~R# (forall a1.
                                              a1 -> WrappedArrow a_abRpS b_abRpT a1 :: *))
                              (Control.Applicative.$fApplicativeWrappedArrow4
                                 @ a_abRpS @ b_abRpT v_X3n)
                              `cast` (forall (a1 :: <*>_N) (b1 :: <*>_N).
                                      <WrappedArrow a_abRpS b_abRpT (a1 -> b1)>_R
                                      ->_R <WrappedArrow a_abRpS b_abRpT a1>_R
                                      ->_R Sym (Control.Applicative.N:WrappedArrow[0]
                                                    <a_abRpS>_R) <b_abRpT>_N <b1>_N
                                      :: (forall a1 b1.
                                          WrappedArrow a_abRpS b_abRpT (a1 -> b1)
                                          -> WrappedArrow a_abRpS b_abRpT a1
                                          -> a_abRpS b_abRpT b1 :: *)
                                         ~R# (forall a1 b1.
                                              WrappedArrow a_abRpS b_abRpT (a1 -> b1)
                                              -> WrappedArrow a_abRpS b_abRpT a1
                                              -> WrappedArrow a_abRpS b_abRpT b1 :: *))
                              (Control.Applicative.$fAlternativeWrappedArrow2
                                 @ a_abRpS @ b_abRpT v_X3n)
                              `cast` (forall (a1 :: <*>_N) (b1 :: <*>_N) (c :: <*>_N).
                                      <a1 -> b1 -> c>_R
                                      ->_R <WrappedArrow a_abRpS b_abRpT a1>_R
                                      ->_R <WrappedArrow a_abRpS b_abRpT b1>_R
                                      ->_R Sym (Control.Applicative.N:WrappedArrow[0]
                                                    <a_abRpS>_R) <b_abRpT>_N <c>_N
                                      :: (forall a1 b1 c.
                                          (a1 -> b1 -> c)
                                          -> WrappedArrow a_abRpS b_abRpT a1
                                          -> WrappedArrow a_abRpS b_abRpT b1
                                          -> a_abRpS b_abRpT c :: *)
                                         ~R# (forall a1 b1 c.
                                              (a1 -> b1 -> c)
                                              -> WrappedArrow a_abRpS b_abRpT a1
                                              -> WrappedArrow a_abRpS b_abRpT b1
                                              -> WrappedArrow a_abRpS b_abRpT c :: *))
                              (Control.Applicative.$fApplicativeWrappedArrow2
                                 @ a_abRpS @ b_abRpT v_X3n)
                              `cast` (forall (a1 :: <*>_N) (b1 :: <*>_N).
                                      <WrappedArrow a_abRpS b_abRpT a1>_R
                                      ->_R <WrappedArrow a_abRpS b_abRpT b1>_R
                                      ->_R Sym (Control.Applicative.N:WrappedArrow[0]
                                                    <a_abRpS>_R) <b_abRpT>_N <b1>_N
                                      :: (forall a1 b1.
                                          WrappedArrow a_abRpS b_abRpT a1
                                          -> WrappedArrow a_abRpS b_abRpT b1
                                          -> a_abRpS b_abRpT b1 :: *)
                                         ~R# (forall a1 b1.
                                              WrappedArrow a_abRpS b_abRpT a1
                                              -> WrappedArrow a_abRpS b_abRpT b1
                                              -> WrappedArrow a_abRpS b_abRpT b1 :: *))
                              (Control.Applicative.$fApplicativeWrappedArrow1
                                 @ a_abRpS @ b_abRpT v_X3n)
                              `cast` (forall (a1 :: <*>_N) (b1 :: <*>_N).
                                      <WrappedArrow a_abRpS b_abRpT a1>_R
                                      ->_R <WrappedArrow a_abRpS b_abRpT b1>_R
                                      ->_R Sym (Control.Applicative.N:WrappedArrow[0]
                                                    <a_abRpS>_R) <b_abRpT>_N <a1>_N
                                      :: (forall a1 b1.
                                          WrappedArrow a_abRpS b_abRpT a1
                                          -> WrappedArrow a_abRpS b_abRpT b1
                                          -> a_abRpS b_abRpT a1 :: *)
                                         ~R# (forall a1 b1.
                                              WrappedArrow a_abRpS b_abRpT a1
                                              -> WrappedArrow a_abRpS b_abRpT b1
                                              -> WrappedArrow a_abRpS b_abRpT a1 :: *))]
Control.Applicative.$fApplicativeWrappedArrow
  = \ (@ (a_XbS4O :: * -> * -> *))
      (@ b_XbS8b)
      ($dArrow_XbS8e :: Arrow a_XbS4O) ->
      GHC.Base.C:Applicative
        @ (WrappedArrow a_XbS4O b_XbS8b)
        (Control.Applicative.$fFunctorWrappedArrow
           @ a_XbS4O @ b_XbS8b $dArrow_XbS8e)
        ((Control.Applicative.$fApplicativeWrappedArrow5
            @ a_XbS4O @ b_XbS8b $dArrow_XbS8e)
         `cast` (forall (a1 :: <*>_N).
                 <a1>_R
                 ->_R Sym (Control.Applicative.N:WrappedArrow[0]
                               <a_XbS4O>_R) <b_XbS8b>_N <a1>_N
                 :: (forall a1. a1 -> a_XbS4O b_XbS8b a1 :: *)
                    ~R# (forall a1. a1 -> WrappedArrow a_XbS4O b_XbS8b a1 :: *)))
        ((Control.Applicative.$fApplicativeWrappedArrow4
            @ a_XbS4O @ b_XbS8b $dArrow_XbS8e)
         `cast` (forall (a1 :: <*>_N) (b1 :: <*>_N).
                 <WrappedArrow a_XbS4O b_XbS8b (a1 -> b1)>_R
                 ->_R <WrappedArrow a_XbS4O b_XbS8b a1>_R
                 ->_R Sym (Control.Applicative.N:WrappedArrow[0]
                               <a_XbS4O>_R) <b_XbS8b>_N <b1>_N
                 :: (forall a1 b1.
                     WrappedArrow a_XbS4O b_XbS8b (a1 -> b1)
                     -> WrappedArrow a_XbS4O b_XbS8b a1 -> a_XbS4O b_XbS8b b1 :: *)
                    ~R# (forall a1 b1.
                         WrappedArrow a_XbS4O b_XbS8b (a1 -> b1)
                         -> WrappedArrow a_XbS4O b_XbS8b a1
                         -> WrappedArrow a_XbS4O b_XbS8b b1 :: *)))
        ((Control.Applicative.$fAlternativeWrappedArrow2
            @ a_XbS4O @ b_XbS8b $dArrow_XbS8e)
         `cast` (forall (a1 :: <*>_N) (b1 :: <*>_N) (c :: <*>_N).
                 <a1 -> b1 -> c>_R
                 ->_R <WrappedArrow a_XbS4O b_XbS8b a1>_R
                 ->_R <WrappedArrow a_XbS4O b_XbS8b b1>_R
                 ->_R Sym (Control.Applicative.N:WrappedArrow[0]
                               <a_XbS4O>_R) <b_XbS8b>_N <c>_N
                 :: (forall a1 b1 c.
                     (a1 -> b1 -> c)
                     -> WrappedArrow a_XbS4O b_XbS8b a1
                     -> WrappedArrow a_XbS4O b_XbS8b b1
                     -> a_XbS4O b_XbS8b c :: *)
                    ~R# (forall a1 b1 c.
                         (a1 -> b1 -> c)
                         -> WrappedArrow a_XbS4O b_XbS8b a1
                         -> WrappedArrow a_XbS4O b_XbS8b b1
                         -> WrappedArrow a_XbS4O b_XbS8b c :: *)))
        ((Control.Applicative.$fApplicativeWrappedArrow2
            @ a_XbS4O @ b_XbS8b $dArrow_XbS8e)
         `cast` (forall (a1 :: <*>_N) (b1 :: <*>_N).
                 <WrappedArrow a_XbS4O b_XbS8b a1>_R
                 ->_R <WrappedArrow a_XbS4O b_XbS8b b1>_R
                 ->_R Sym (Control.Applicative.N:WrappedArrow[0]
                               <a_XbS4O>_R) <b_XbS8b>_N <b1>_N
                 :: (forall a1 b1.
                     WrappedArrow a_XbS4O b_XbS8b a1
                     -> WrappedArrow a_XbS4O b_XbS8b b1 -> a_XbS4O b_XbS8b b1 :: *)
                    ~R# (forall a1 b1.
                         WrappedArrow a_XbS4O b_XbS8b a1
                         -> WrappedArrow a_XbS4O b_XbS8b b1
                         -> WrappedArrow a_XbS4O b_XbS8b b1 :: *)))
        ((Control.Applicative.$fApplicativeWrappedArrow1
            @ a_XbS4O @ b_XbS8b $dArrow_XbS8e)
         `cast` (forall (a1 :: <*>_N) (b1 :: <*>_N).
                 <WrappedArrow a_XbS4O b_XbS8b a1>_R
                 ->_R <WrappedArrow a_XbS4O b_XbS8b b1>_R
                 ->_R Sym (Control.Applicative.N:WrappedArrow[0]
                               <a_XbS4O>_R) <b_XbS8b>_N <a1>_N
                 :: (forall a1 b1.
                     WrappedArrow a_XbS4O b_XbS8b a1
                     -> WrappedArrow a_XbS4O b_XbS8b b1 -> a_XbS4O b_XbS8b a1 :: *)
                    ~R# (forall a1 b1.
                         WrappedArrow a_XbS4O b_XbS8b a1
                         -> WrappedArrow a_XbS4O b_XbS8b b1
                         -> WrappedArrow a_XbS4O b_XbS8b a1 :: *)))

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative
  :: forall (a :: * -> * -> *) b.
     (ArrowZero a, ArrowPlus a) =>
     Applicative (WrappedArrow a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)><L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (a_XbS4i :: * -> * -> *))
                 (@ b_XbS4k)
                 ($dArrowZero_XbS4m [Occ=Once] :: ArrowZero a_XbS4i)
                 _ [Occ=Dead] ->
                 Control.Applicative.$fApplicativeWrappedArrow
                   @ a_XbS4i
                   @ b_XbS4k
                   (Control.Arrow.$p1ArrowZero @ a_XbS4i $dArrowZero_XbS4m)}]
Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative
  = \ (@ (a_XbS4i :: * -> * -> *))
      (@ b_XbS4k)
      ($dArrowZero_XbS4m :: ArrowZero a_XbS4i)
      _ [Occ=Dead] ->
      Control.Applicative.$fApplicativeWrappedArrow
        @ a_XbS4i
        @ b_XbS4k
        (Control.Arrow.$p1ArrowZero @ a_XbS4i $dArrowZero_XbS4m)

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Control.Applicative.$fAlternativeWrappedArrow1
  :: forall b a. b -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_XbS4n) (@ a_abS1s) _ [Occ=Dead] ->
                 GHC.Types.[] @ a_abS1s}]
Control.Applicative.$fAlternativeWrappedArrow1
  = \ (@ b_XbS4n) (@ a_abS1s) _ [Occ=Dead] -> GHC.Types.[] @ a_abS1s

-- RHS size: {terms: 21, types: 43, coercions: 12, joins: 0/2}
Control.Applicative.$fAlternativeWrappedArrow_$csome
  :: forall (a :: * -> * -> *) b.
     (ArrowZero a, ArrowPlus a) =>
     forall a1. WrappedArrow a b a1 -> WrappedArrow a b [a1]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)><L,U(A,C(C1(U)))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30 0] 160 0}]
Control.Applicative.$fAlternativeWrappedArrow_$csome
  = \ (@ (a_XbS4l :: * -> * -> *))
      (@ b_XbS4n)
      ($dArrowZero_XbS4p :: ArrowZero a_XbS4l)
      ($dArrowPlus_XbS4r :: ArrowPlus a_XbS4l)
      (@ a1_abS1s)
      (eta_B1 :: WrappedArrow a_XbS4l b_XbS4n a1_abS1s) ->
      letrec {
        some_v_sbSlS [Occ=LoopBreaker] :: a_XbS4l b_XbS4n [a1_abS1s]
        [LclId]
        some_v_sbSlS
          = let {
              $dApplicative_sbSlT [Dmd=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
                :: Arrow a_XbS4l
              [LclId]
              $dApplicative_sbSlT
                = Control.Arrow.$p1ArrowZero @ a_XbS4l $dArrowZero_XbS4p } in
            Control.Applicative.$fAlternativeWrappedArrow2
              @ a_XbS4l
              @ b_XbS4n
              $dApplicative_sbSlT
              @ a1_abS1s
              @ [a1_abS1s]
              @ [a1_abS1s]
              (GHC.Types.: @ a1_abS1s)
              eta_B1
              ((<+>
                  @ a_XbS4l
                  $dArrowPlus_XbS4r
                  @ b_XbS4n
                  @ [a1_abS1s]
                  some_v_sbSlS
                  (arr
                     @ a_XbS4l
                     $dApplicative_sbSlT
                     @ b_XbS4n
                     @ [a1_abS1s]
                     (Control.Applicative.$fAlternativeWrappedArrow1
                        @ b_XbS4n @ a1_abS1s)))
               `cast` (Sym (Control.Applicative.N:WrappedArrow[0]
                                <a_XbS4l>_R) <b_XbS4n>_N <[a1_abS1s]>_N
                       :: (a_XbS4l b_XbS4n [a1_abS1s] :: *)
                          ~R# (WrappedArrow a_XbS4l b_XbS4n [a1_abS1s] :: *))); } in
      some_v_sbSlS
      `cast` (Sym (Control.Applicative.N:WrappedArrow[0]
                       <a_XbS4l>_R) <b_XbS4n>_N <[a1_abS1s]>_N
              :: (a_XbS4l b_XbS4n [a1_abS1s] :: *)
                 ~R# (WrappedArrow a_XbS4l b_XbS4n [a1_abS1s] :: *))

-- RHS size: {terms: 21, types: 43, coercions: 12, joins: 0/2}
Control.Applicative.$fAlternativeWrappedArrow_$cmany
  :: forall (a :: * -> * -> *) b.
     (ArrowZero a, ArrowPlus a) =>
     forall a1. WrappedArrow a b a1 -> WrappedArrow a b [a1]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)><S(LC(C(S))),U(A,C(C1(U)))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30 0] 160 0}]
Control.Applicative.$fAlternativeWrappedArrow_$cmany
  = \ (@ (a_XbS4k :: * -> * -> *))
      (@ b_XbS4m)
      ($dArrowZero_XbS4o :: ArrowZero a_XbS4k)
      ($dArrowPlus_XbS4q :: ArrowPlus a_XbS4k)
      (@ a1_abS1A)
      (eta_B1 :: WrappedArrow a_XbS4k b_XbS4m a1_abS1A) ->
      letrec {
        many_v_sbSlO [Occ=LoopBreaker] :: a_XbS4k b_XbS4m [a1_abS1A]
        [LclId]
        many_v_sbSlO
          = let {
              $dApplicative_sbSlP [Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
                :: Arrow a_XbS4k
              [LclId]
              $dApplicative_sbSlP
                = Control.Arrow.$p1ArrowZero @ a_XbS4k $dArrowZero_XbS4o } in
            <+>
              @ a_XbS4k
              $dArrowPlus_XbS4q
              @ b_XbS4m
              @ [a1_abS1A]
              (Control.Applicative.$fAlternativeWrappedArrow2
                 @ a_XbS4k
                 @ b_XbS4m
                 $dApplicative_sbSlP
                 @ a1_abS1A
                 @ [a1_abS1A]
                 @ [a1_abS1A]
                 (GHC.Types.: @ a1_abS1A)
                 eta_B1
                 (many_v_sbSlO
                  `cast` (Sym (Control.Applicative.N:WrappedArrow[0]
                                   <a_XbS4k>_R) <b_XbS4m>_N <[a1_abS1A]>_N
                          :: (a_XbS4k b_XbS4m [a1_abS1A] :: *)
                             ~R# (WrappedArrow a_XbS4k b_XbS4m [a1_abS1A] :: *))))
              (arr
                 @ a_XbS4k
                 $dApplicative_sbSlP
                 @ b_XbS4m
                 @ [a1_abS1A]
                 (Control.Applicative.$fAlternativeWrappedArrow1
                    @ b_XbS4m @ a1_abS1A)); } in
      many_v_sbSlO
      `cast` (Sym (Control.Applicative.N:WrappedArrow[0]
                       <a_XbS4k>_R) <b_XbS4m>_N <[a1_abS1A]>_N
              :: (a_XbS4k b_XbS4m [a1_abS1A] :: *)
                 ~R# (WrappedArrow a_XbS4k b_XbS4m [a1_abS1A] :: *))

-- RHS size: {terms: 24, types: 39, coercions: 34, joins: 0/0}
Control.Applicative.$fAlternativeWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b.
     (ArrowZero a, ArrowPlus a) =>
     Alternative (WrappedArrow a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),1*U)><L,U(A,C(C1(U)))>m,
 Unf=DFun: \ (@ (a_abRpO :: * -> * -> *))
             (@ b_abRpP)
             (v_X3r :: ArrowZero a_abRpO)
             (v1_X3t :: ArrowPlus a_abRpO) ->
       GHC.Base.C:Alternative TYPE: WrappedArrow a_abRpO b_abRpP
                              Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative
                                @ a_abRpO @ b_abRpP v_X3r v1_X3t
                              (\ (@ a1_XbS4y) -> zeroArrow @ a_abRpO v_X3r @ b_abRpP @ a1_XbS4y)
                              `cast` (forall (a1 :: <*>_N).
                                      Sym (Control.Applicative.N:WrappedArrow[0]
                                               <a_abRpO>_R) <b_abRpP>_N <a1>_N
                                      :: (forall a1. a_abRpO b_abRpP a1 :: *)
                                         ~R# (forall a1. WrappedArrow a_abRpO b_abRpP a1 :: *))
                              (\ (@ a1_XbS4M)
                                 (ds_XbSh5 [Occ=Once] :: WrappedArrow a_abRpO b_abRpP a1_XbS4M)
                                 (ds1_XbSh7 [Occ=Once] :: WrappedArrow a_abRpO b_abRpP a1_XbS4M) ->
                                 <+>
                                   @ a_abRpO
                                   v1_X3t
                                   @ b_abRpP
                                   @ a1_XbS4M
                                   (ds_XbSh5
                                    `cast` (Control.Applicative.N:WrappedArrow[0]
                                                <a_abRpO>_R <b_abRpP>_N <a1_XbS4M>_N
                                            :: (WrappedArrow a_abRpO b_abRpP a1_XbS4M :: *)
                                               ~R# (a_abRpO b_abRpP a1_XbS4M :: *)))
                                   (ds1_XbSh7
                                    `cast` (Control.Applicative.N:WrappedArrow[0]
                                                <a_abRpO>_R <b_abRpP>_N <a1_XbS4M>_N
                                            :: (WrappedArrow a_abRpO b_abRpP a1_XbS4M :: *)
                                               ~R# (a_abRpO b_abRpP a1_XbS4M :: *))))
                              `cast` (forall (a1 :: <*>_N).
                                      <WrappedArrow a_abRpO b_abRpP a1>_R
                                      ->_R <WrappedArrow a_abRpO b_abRpP a1>_R
                                      ->_R Sym (Control.Applicative.N:WrappedArrow[0]
                                                    <a_abRpO>_R) <b_abRpP>_N <a1>_N
                                      :: (forall a1.
                                          WrappedArrow a_abRpO b_abRpP a1
                                          -> WrappedArrow a_abRpO b_abRpP a1
                                          -> a_abRpO b_abRpP a1 :: *)
                                         ~R# (forall a1.
                                              WrappedArrow a_abRpO b_abRpP a1
                                              -> WrappedArrow a_abRpO b_abRpP a1
                                              -> WrappedArrow a_abRpO b_abRpP a1 :: *))
                              Control.Applicative.$fAlternativeWrappedArrow_$csome
                                @ a_abRpO @ b_abRpP v_X3r v1_X3t
                              Control.Applicative.$fAlternativeWrappedArrow_$cmany
                                @ a_abRpO @ b_abRpP v_X3r v1_X3t]
Control.Applicative.$fAlternativeWrappedArrow
  = \ (@ (a_XbS4j :: * -> * -> *))
      (@ b_XbS4l)
      ($dArrowZero_XbS4n :: ArrowZero a_XbS4j)
      ($dArrowPlus_XbS4p :: ArrowPlus a_XbS4j) ->
      GHC.Base.C:Alternative
        @ (WrappedArrow a_XbS4j b_XbS4l)
        (Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative
           @ a_XbS4j @ b_XbS4l $dArrowZero_XbS4n $dArrowPlus_XbS4p)
        ((\ (@ a1_XbS4y) ->
            zeroArrow @ a_XbS4j $dArrowZero_XbS4n @ b_XbS4l @ a1_XbS4y)
         `cast` (forall (a1 :: <*>_N).
                 Sym (Control.Applicative.N:WrappedArrow[0]
                          <a_XbS4j>_R) <b_XbS4l>_N <a1>_N
                 :: (forall a1. a_XbS4j b_XbS4l a1 :: *)
                    ~R# (forall a1. WrappedArrow a_XbS4j b_XbS4l a1 :: *)))
        ((\ (@ a1_XbS4M)
            (ds_XbSh5 :: WrappedArrow a_XbS4j b_XbS4l a1_XbS4M)
            (ds1_XbSh7 :: WrappedArrow a_XbS4j b_XbS4l a1_XbS4M) ->
            <+>
              @ a_XbS4j
              $dArrowPlus_XbS4p
              @ b_XbS4l
              @ a1_XbS4M
              (ds_XbSh5
               `cast` (Control.Applicative.N:WrappedArrow[0]
                           <a_XbS4j>_R <b_XbS4l>_N <a1_XbS4M>_N
                       :: (WrappedArrow a_XbS4j b_XbS4l a1_XbS4M :: *)
                          ~R# (a_XbS4j b_XbS4l a1_XbS4M :: *)))
              (ds1_XbSh7
               `cast` (Control.Applicative.N:WrappedArrow[0]
                           <a_XbS4j>_R <b_XbS4l>_N <a1_XbS4M>_N
                       :: (WrappedArrow a_XbS4j b_XbS4l a1_XbS4M :: *)
                          ~R# (a_XbS4j b_XbS4l a1_XbS4M :: *))))
         `cast` (forall (a1 :: <*>_N).
                 <WrappedArrow a_XbS4j b_XbS4l a1>_R
                 ->_R <WrappedArrow a_XbS4j b_XbS4l a1>_R
                 ->_R Sym (Control.Applicative.N:WrappedArrow[0]
                               <a_XbS4j>_R) <b_XbS4l>_N <a1>_N
                 :: (forall a1.
                     WrappedArrow a_XbS4j b_XbS4l a1
                     -> WrappedArrow a_XbS4j b_XbS4l a1 -> a_XbS4j b_XbS4l a1 :: *)
                    ~R# (forall a1.
                         WrappedArrow a_XbS4j b_XbS4l a1
                         -> WrappedArrow a_XbS4j b_XbS4l a1
                         -> WrappedArrow a_XbS4j b_XbS4l a1 :: *)))
        (Control.Applicative.$fAlternativeWrappedArrow_$csome
           @ a_XbS4j @ b_XbS4l $dArrowZero_XbS4n $dArrowPlus_XbS4p)
        (Control.Applicative.$fAlternativeWrappedArrow_$cmany
           @ a_XbS4j @ b_XbS4l $dArrowZero_XbS4n $dArrowPlus_XbS4p)

Rec {
-- RHS size: {terms: 18, types: 13, coercions: 0, joins: 0/0}
Control.Applicative.$wunsafeDrop [InlPrag=NOUSERINLINE[0],
                                  Occ=LoopBreaker]
  :: forall a1. Int# -> [a1] -> [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []]
Control.Applicative.$wunsafeDrop
  = \ (@ a1_sbSr8) (ww_sbSrd :: Int#) (w_sbSra :: [a1_sbSr8]) ->
      case w_sbSra of {
        [] -> GHC.Types.[] @ a1_sbSr8;
        : ipv1_ibScY ipv2_ibScZ ->
          case ww_sbSrd of ds3_ibSd1 {
            __DEFAULT ->
              Control.Applicative.$wunsafeDrop
                @ a1_sbSr8 (-# ds3_ibSd1 1#) ipv2_ibScZ;
            1# -> ipv2_ibScZ
          }
      }
end Rec }

-- RHS size: {terms: 20, types: 11, coercions: 8, joins: 0/0}
Control.Applicative.$fAlternativeZipList2
  :: forall a. ZipList a -> ZipList a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 121 0}]
Control.Applicative.$fAlternativeZipList2
  = \ (@ a_abRZs)
      (ds_dbScH :: ZipList a_abRZs)
      (ds1_dbScI :: ZipList a_abRZs) ->
      ++
        @ a_abRZs
        (ds_dbScH
         `cast` (Control.Applicative.N:ZipList[0] <a_abRZs>_N
                 :: (ZipList a_abRZs :: *) ~R# ([a_abRZs] :: *)))
        (case GHC.List.$wlenAcc
                @ a_abRZs
                (ds_dbScH
                 `cast` (Control.Applicative.N:ZipList[0] <a_abRZs>_N
                         :: (ZipList a_abRZs :: *) ~R# ([a_abRZs] :: *)))
                0#
         of ww2_i8PwI
         { __DEFAULT ->
         case <=# ww2_i8PwI 0# of {
           __DEFAULT ->
             Control.Applicative.$wunsafeDrop
               @ a_abRZs
               ww2_i8PwI
               (ds1_dbScI
                `cast` (Control.Applicative.N:ZipList[0] <a_abRZs>_N
                        :: (ZipList a_abRZs :: *) ~R# ([a_abRZs] :: *)));
           1# ->
             ds1_dbScI
             `cast` (Control.Applicative.N:ZipList[0] <a_abRZs>_N
                     :: (ZipList a_abRZs :: *) ~R# ([a_abRZs] :: *))
         }
         })

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Control.Applicative.$fGeneric1ZipList1
  :: forall a. Rep1 ZipList a -> Rep1 ZipList a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_abRYO)
                 (ds_dbScC [Occ=Once] :: Rep1 ZipList a_abRYO) ->
                 ds_dbScC}]
Control.Applicative.$fGeneric1ZipList1
  = \ (@ a_abRYO) (ds_dbScC :: Rep1 ZipList a_abRYO) -> ds_dbScC

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Control.Applicative.$fGeneric1ZipList2
  :: forall a. ZipList a -> ZipList a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_abRYn) (x_abREg [Occ=Once] :: ZipList a_abRYn) ->
                 x_abREg}]
Control.Applicative.$fGeneric1ZipList2
  = \ (@ a_abRYn) (x_abREg :: ZipList a_abRYn) -> x_abREg

-- RHS size: {terms: 3, types: 3, coercions: 184, joins: 0/0}
Control.Applicative.$fGeneric1ZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: Generic1 ZipList
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Generics.C:Generic1 TYPE: *
                               TYPE: ZipList
                               Control.Applicative.$fGeneric1ZipList2
                               `cast` (forall (a :: <*>_N).
                                       <ZipList a>_R
                                       ->_R (Sym (GHC.Generics.N:Rec1[0]
                                                      <*>_N
                                                      (Sym (Control.Applicative.N:ZipList[0]))) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                            <*>_N
                                                                                                            <S>_P
                                                                                                            <'MetaSel
                                                                                                               ('Just
                                                                                                                  "getZipList")
                                                                                                               'NoSourceUnpackedness
                                                                                                               'NoSourceStrictness
                                                                                                               'DecidedLazy>_P
                                                                                                            <Rec1
                                                                                                               []>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                  <*>_N
                                                                                                                                  <C>_P
                                                                                                                                  <'MetaCons
                                                                                                                                     "ZipList"
                                                                                                                                     'PrefixI
                                                                                                                                     'True>_P
                                                                                                                                  <M1
                                                                                                                                     S
                                                                                                                                     ('MetaSel
                                                                                                                                        ('Just
                                                                                                                                           "getZipList")
                                                                                                                                        'NoSourceUnpackedness
                                                                                                                                        'NoSourceStrictness
                                                                                                                                        'DecidedLazy)
                                                                                                                                     (Rec1
                                                                                                                                        [])>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                            <*>_N
                                                                                                                                                            <D>_P
                                                                                                                                                            <'MetaData
                                                                                                                                                               "ZipList"
                                                                                                                                                               "Control.Applicative"
                                                                                                                                                               "base"
                                                                                                                                                               'True>_P
                                                                                                                                                            <M1
                                                                                                                                                               C
                                                                                                                                                               ('MetaCons
                                                                                                                                                                  "ZipList"
                                                                                                                                                                  'PrefixI
                                                                                                                                                                  'True)
                                                                                                                                                               (M1
                                                                                                                                                                  S
                                                                                                                                                                  ('MetaSel
                                                                                                                                                                     ('Just
                                                                                                                                                                        "getZipList")
                                                                                                                                                                     'NoSourceUnpackedness
                                                                                                                                                                     'NoSourceStrictness
                                                                                                                                                                     'DecidedLazy)
                                                                                                                                                                  (Rec1
                                                                                                                                                                     []))>_R) ; Sub (Sym (Control.Applicative.Rep1_ZipList[0])))))) <a>_N
                                       :: (forall a. ZipList a -> ZipList a :: *)
                                          ~R# (forall a. ZipList a -> Rep1 ZipList a :: *))
                               Control.Applicative.$fGeneric1ZipList1
                               `cast` (forall (a :: <*>_N).
                                       <Rep1 ZipList a>_R
                                       ->_R (Sub (Control.Applicative.Rep1_ZipList[0]) ; (GHC.Generics.N:M1[0]
                                                                                              <*>_N
                                                                                              <D>_P
                                                                                              <'MetaData
                                                                                                 "ZipList"
                                                                                                 "Control.Applicative"
                                                                                                 "base"
                                                                                                 'True>_P
                                                                                              <M1
                                                                                                 C
                                                                                                 ('MetaCons
                                                                                                    "ZipList"
                                                                                                    'PrefixI
                                                                                                    'True)
                                                                                                 (M1
                                                                                                    S
                                                                                                    ('MetaSel
                                                                                                       ('Just
                                                                                                          "getZipList")
                                                                                                       'NoSourceUnpackedness
                                                                                                       'NoSourceStrictness
                                                                                                       'DecidedLazy)
                                                                                                    (Rec1
                                                                                                       []))>_R ; (GHC.Generics.N:M1[0]
                                                                                                                      <*>_N
                                                                                                                      <C>_P
                                                                                                                      <'MetaCons
                                                                                                                         "ZipList"
                                                                                                                         'PrefixI
                                                                                                                         'True>_P
                                                                                                                      <M1
                                                                                                                         S
                                                                                                                         ('MetaSel
                                                                                                                            ('Just
                                                                                                                               "getZipList")
                                                                                                                            'NoSourceUnpackedness
                                                                                                                            'NoSourceStrictness
                                                                                                                            'DecidedLazy)
                                                                                                                         (Rec1
                                                                                                                            [])>_R ; (GHC.Generics.N:M1[0]
                                                                                                                                          <*>_N
                                                                                                                                          <S>_P
                                                                                                                                          <'MetaSel
                                                                                                                                             ('Just
                                                                                                                                                "getZipList")
                                                                                                                                             'NoSourceUnpackedness
                                                                                                                                             'NoSourceStrictness
                                                                                                                                             'DecidedLazy>_P
                                                                                                                                          <Rec1
                                                                                                                                             []>_R ; GHC.Generics.N:Rec1[0]
                                                                                                                                                         <*>_N
                                                                                                                                                         (Sym (Control.Applicative.N:ZipList[0])))))) <a>_N
                                       :: (forall a. Rep1 ZipList a -> Rep1 ZipList a :: *)
                                          ~R# (forall a. Rep1 ZipList a -> ZipList a :: *))]
Control.Applicative.$fGeneric1ZipList
  = GHC.Generics.C:Generic1
      @ *
      @ ZipList
      (Control.Applicative.$fGeneric1ZipList2
       `cast` (forall (a :: <*>_N).
               <ZipList a>_R
               ->_R (Sym (GHC.Generics.N:Rec1[0]
                              <*>_N
                              (Sym (Control.Applicative.N:ZipList[0]))) ; (Sym (GHC.Generics.N:M1[0]
                                                                                    <*>_N
                                                                                    <S>_P
                                                                                    <'MetaSel
                                                                                       ('Just
                                                                                          "getZipList")
                                                                                       'NoSourceUnpackedness
                                                                                       'NoSourceStrictness
                                                                                       'DecidedLazy>_P
                                                                                    <Rec1
                                                                                       []>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                          <*>_N
                                                                                                          <C>_P
                                                                                                          <'MetaCons
                                                                                                             "ZipList"
                                                                                                             'PrefixI
                                                                                                             'True>_P
                                                                                                          <M1
                                                                                                             S
                                                                                                             ('MetaSel
                                                                                                                ('Just
                                                                                                                   "getZipList")
                                                                                                                'NoSourceUnpackedness
                                                                                                                'NoSourceStrictness
                                                                                                                'DecidedLazy)
                                                                                                             (Rec1
                                                                                                                [])>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                    <*>_N
                                                                                                                                    <D>_P
                                                                                                                                    <'MetaData
                                                                                                                                       "ZipList"
                                                                                                                                       "Control.Applicative"
                                                                                                                                       "base"
                                                                                                                                       'True>_P
                                                                                                                                    <M1
                                                                                                                                       C
                                                                                                                                       ('MetaCons
                                                                                                                                          "ZipList"
                                                                                                                                          'PrefixI
                                                                                                                                          'True)
                                                                                                                                       (M1
                                                                                                                                          S
                                                                                                                                          ('MetaSel
                                                                                                                                             ('Just
                                                                                                                                                "getZipList")
                                                                                                                                             'NoSourceUnpackedness
                                                                                                                                             'NoSourceStrictness
                                                                                                                                             'DecidedLazy)
                                                                                                                                          (Rec1
                                                                                                                                             []))>_R) ; Sub (Sym (Control.Applicative.Rep1_ZipList[0])))))) <a>_N
               :: (forall a. ZipList a -> ZipList a :: *)
                  ~R# (forall a. ZipList a -> Rep1 ZipList a :: *)))
      (Control.Applicative.$fGeneric1ZipList1
       `cast` (forall (a :: <*>_N).
               <Rep1 ZipList a>_R
               ->_R (Sub (Control.Applicative.Rep1_ZipList[0]) ; (GHC.Generics.N:M1[0]
                                                                      <*>_N
                                                                      <D>_P
                                                                      <'MetaData
                                                                         "ZipList"
                                                                         "Control.Applicative"
                                                                         "base"
                                                                         'True>_P
                                                                      <M1
                                                                         C
                                                                         ('MetaCons
                                                                            "ZipList"
                                                                            'PrefixI
                                                                            'True)
                                                                         (M1
                                                                            S
                                                                            ('MetaSel
                                                                               ('Just "getZipList")
                                                                               'NoSourceUnpackedness
                                                                               'NoSourceStrictness
                                                                               'DecidedLazy)
                                                                            (Rec1
                                                                               []))>_R ; (GHC.Generics.N:M1[0]
                                                                                              <*>_N
                                                                                              <C>_P
                                                                                              <'MetaCons
                                                                                                 "ZipList"
                                                                                                 'PrefixI
                                                                                                 'True>_P
                                                                                              <M1
                                                                                                 S
                                                                                                 ('MetaSel
                                                                                                    ('Just
                                                                                                       "getZipList")
                                                                                                    'NoSourceUnpackedness
                                                                                                    'NoSourceStrictness
                                                                                                    'DecidedLazy)
                                                                                                 (Rec1
                                                                                                    [])>_R ; (GHC.Generics.N:M1[0]
                                                                                                                  <*>_N
                                                                                                                  <S>_P
                                                                                                                  <'MetaSel
                                                                                                                     ('Just
                                                                                                                        "getZipList")
                                                                                                                     'NoSourceUnpackedness
                                                                                                                     'NoSourceStrictness
                                                                                                                     'DecidedLazy>_P
                                                                                                                  <Rec1
                                                                                                                     []>_R ; GHC.Generics.N:Rec1[0]
                                                                                                                                 <*>_N
                                                                                                                                 (Sym (Control.Applicative.N:ZipList[0])))))) <a>_N
               :: (forall a. Rep1 ZipList a -> Rep1 ZipList a :: *)
                  ~R# (forall a. Rep1 ZipList a -> ZipList a :: *)))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Control.Applicative.$fGenericZipList1
  :: forall a x. Rep (ZipList a) x -> Rep (ZipList a) x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_abRXm)
                 (@ x_abRXS)
                 (ds_dbScw [Occ=Once] :: Rep (ZipList a_abRXm) x_abRXS) ->
                 ds_dbScw}]
Control.Applicative.$fGenericZipList1
  = \ (@ a_abRXm)
      (@ x_abRXS)
      (ds_dbScw :: Rep (ZipList a_abRXm) x_abRXS) ->
      ds_dbScw

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Control.Applicative.$fGenericZipList2
  :: forall a x. ZipList a -> ZipList a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_XbS1m)
                 (@ x_abRXq)
                 (x1_abREc [Occ=Once] :: ZipList a_XbS1m) ->
                 x1_abREc}]
Control.Applicative.$fGenericZipList2
  = \ (@ a_XbS1m) (@ x_abRXq) (x1_abREc :: ZipList a_XbS1m) ->
      x1_abREc

-- RHS size: {terms: 4, types: 6, coercions: 206, joins: 0/0}
Control.Applicative.$fGenericZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Generic (ZipList a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_abRpC) ->
       GHC.Generics.C:Generic TYPE: ZipList a_abRpC
                              (Control.Applicative.$fGenericZipList2 @ a_abRpC)
                              `cast` (forall (x :: <*>_N).
                                      <ZipList a_abRpC>_R
                                      ->_R Control.Applicative.N:ZipList[0] <a_abRpC>_N ; (Sym (GHC.Generics.N:K1[0]
                                                                                                    <*>_N
                                                                                                    <R>_P
                                                                                                    <[a_abRpC]>_R
                                                                                                    <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                       <*>_N
                                                                                                                       <S>_P
                                                                                                                       <'MetaSel
                                                                                                                          ('Just
                                                                                                                             "getZipList")
                                                                                                                          'NoSourceUnpackedness
                                                                                                                          'NoSourceStrictness
                                                                                                                          'DecidedLazy>_P
                                                                                                                       <K1
                                                                                                                          R
                                                                                                                          [a_abRpC]>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                    <*>_N
                                                                                                                                                    <C>_P
                                                                                                                                                    <'MetaCons
                                                                                                                                                       "ZipList"
                                                                                                                                                       'PrefixI
                                                                                                                                                       'True>_P
                                                                                                                                                    <M1
                                                                                                                                                       S
                                                                                                                                                       ('MetaSel
                                                                                                                                                          ('Just
                                                                                                                                                             "getZipList")
                                                                                                                                                          'NoSourceUnpackedness
                                                                                                                                                          'NoSourceStrictness
                                                                                                                                                          'DecidedLazy)
                                                                                                                                                       (K1
                                                                                                                                                          R
                                                                                                                                                          [a_abRpC])>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                                                     <*>_N
                                                                                                                                                                                     <D>_P
                                                                                                                                                                                     <'MetaData
                                                                                                                                                                                        "ZipList"
                                                                                                                                                                                        "Control.Applicative"
                                                                                                                                                                                        "base"
                                                                                                                                                                                        'True>_P
                                                                                                                                                                                     <M1
                                                                                                                                                                                        C
                                                                                                                                                                                        ('MetaCons
                                                                                                                                                                                           "ZipList"
                                                                                                                                                                                           'PrefixI
                                                                                                                                                                                           'True)
                                                                                                                                                                                        (M1
                                                                                                                                                                                           S
                                                                                                                                                                                           ('MetaSel
                                                                                                                                                                                              ('Just
                                                                                                                                                                                                 "getZipList")
                                                                                                                                                                                              'NoSourceUnpackedness
                                                                                                                                                                                              'NoSourceStrictness
                                                                                                                                                                                              'DecidedLazy)
                                                                                                                                                                                           (K1
                                                                                                                                                                                              R
                                                                                                                                                                                              [a_abRpC]))>_R) ; Sub (Sym (Control.Applicative.Rep_ZipList[0]
                                                                                                                                                                                                                              <a_abRpC>_N))))) <x>_N)
                                      :: (forall x. ZipList a_abRpC -> ZipList a_abRpC :: *)
                                         ~R# (forall x.
                                              ZipList a_abRpC -> Rep (ZipList a_abRpC) x :: *))
                              (Control.Applicative.$fGenericZipList1 @ a_abRpC)
                              `cast` (forall (x :: <*>_N).
                                      <Rep (ZipList a_abRpC) x>_R
                                      ->_R (Sub (Control.Applicative.Rep_ZipList[0]
                                                     <a_abRpC>_N) ; (GHC.Generics.N:M1[0]
                                                                         <*>_N
                                                                         <D>_P
                                                                         <'MetaData
                                                                            "ZipList"
                                                                            "Control.Applicative"
                                                                            "base"
                                                                            'True>_P
                                                                         <M1
                                                                            C
                                                                            ('MetaCons
                                                                               "ZipList"
                                                                               'PrefixI
                                                                               'True)
                                                                            (M1
                                                                               S
                                                                               ('MetaSel
                                                                                  ('Just
                                                                                     "getZipList")
                                                                                  'NoSourceUnpackedness
                                                                                  'NoSourceStrictness
                                                                                  'DecidedLazy)
                                                                               (K1
                                                                                  R
                                                                                  [a_abRpC]))>_R ; (GHC.Generics.N:M1[0]
                                                                                                        <*>_N
                                                                                                        <C>_P
                                                                                                        <'MetaCons
                                                                                                           "ZipList"
                                                                                                           'PrefixI
                                                                                                           'True>_P
                                                                                                        <M1
                                                                                                           S
                                                                                                           ('MetaSel
                                                                                                              ('Just
                                                                                                                 "getZipList")
                                                                                                              'NoSourceUnpackedness
                                                                                                              'NoSourceStrictness
                                                                                                              'DecidedLazy)
                                                                                                           (K1
                                                                                                              R
                                                                                                              [a_abRpC])>_R ; GHC.Generics.N:M1[0]
                                                                                                                                  <*>_N
                                                                                                                                  <S>_P
                                                                                                                                  <'MetaSel
                                                                                                                                     ('Just
                                                                                                                                        "getZipList")
                                                                                                                                     'NoSourceUnpackedness
                                                                                                                                     'NoSourceStrictness
                                                                                                                                     'DecidedLazy>_P
                                                                                                                                  <K1
                                                                                                                                     R
                                                                                                                                     [a_abRpC]>_R))) <x>_N ; (GHC.Generics.N:K1[0]
                                                                                                                                                                  <*>_N
                                                                                                                                                                  <R>_P
                                                                                                                                                                  <[a_abRpC]>_R
                                                                                                                                                                  <x>_P ; Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N)
                                      :: (forall x.
                                          Rep (ZipList a_abRpC) x -> Rep (ZipList a_abRpC) x :: *)
                                         ~R# (forall x.
                                              Rep (ZipList a_abRpC) x -> ZipList a_abRpC :: *))]
Control.Applicative.$fGenericZipList
  = \ (@ a_XbS1r) ->
      GHC.Generics.C:Generic
        @ (ZipList a_XbS1r)
        ((Control.Applicative.$fGenericZipList2 @ a_XbS1r)
         `cast` (forall (x :: <*>_N).
                 <ZipList a_XbS1r>_R
                 ->_R Control.Applicative.N:ZipList[0] <a_XbS1r>_N ; (Sym (GHC.Generics.N:K1[0]
                                                                               <*>_N
                                                                               <R>_P
                                                                               <[a_XbS1r]>_R
                                                                               <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                  <*>_N
                                                                                                  <S>_P
                                                                                                  <'MetaSel
                                                                                                     ('Just
                                                                                                        "getZipList")
                                                                                                     'NoSourceUnpackedness
                                                                                                     'NoSourceStrictness
                                                                                                     'DecidedLazy>_P
                                                                                                  <K1
                                                                                                     R
                                                                                                     [a_XbS1r]>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                               <*>_N
                                                                                                                               <C>_P
                                                                                                                               <'MetaCons
                                                                                                                                  "ZipList"
                                                                                                                                  'PrefixI
                                                                                                                                  'True>_P
                                                                                                                               <M1
                                                                                                                                  S
                                                                                                                                  ('MetaSel
                                                                                                                                     ('Just
                                                                                                                                        "getZipList")
                                                                                                                                     'NoSourceUnpackedness
                                                                                                                                     'NoSourceStrictness
                                                                                                                                     'DecidedLazy)
                                                                                                                                  (K1
                                                                                                                                     R
                                                                                                                                     [a_XbS1r])>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                                <*>_N
                                                                                                                                                                <D>_P
                                                                                                                                                                <'MetaData
                                                                                                                                                                   "ZipList"
                                                                                                                                                                   "Control.Applicative"
                                                                                                                                                                   "base"
                                                                                                                                                                   'True>_P
                                                                                                                                                                <M1
                                                                                                                                                                   C
                                                                                                                                                                   ('MetaCons
                                                                                                                                                                      "ZipList"
                                                                                                                                                                      'PrefixI
                                                                                                                                                                      'True)
                                                                                                                                                                   (M1
                                                                                                                                                                      S
                                                                                                                                                                      ('MetaSel
                                                                                                                                                                         ('Just
                                                                                                                                                                            "getZipList")
                                                                                                                                                                         'NoSourceUnpackedness
                                                                                                                                                                         'NoSourceStrictness
                                                                                                                                                                         'DecidedLazy)
                                                                                                                                                                      (K1
                                                                                                                                                                         R
                                                                                                                                                                         [a_XbS1r]))>_R) ; Sub (Sym (Control.Applicative.Rep_ZipList[0]
                                                                                                                                                                                                         <a_XbS1r>_N))))) <x>_N)
                 :: (forall x. ZipList a_XbS1r -> ZipList a_XbS1r :: *)
                    ~R# (forall x. ZipList a_XbS1r -> Rep (ZipList a_XbS1r) x :: *)))
        ((Control.Applicative.$fGenericZipList1 @ a_XbS1r)
         `cast` (forall (x :: <*>_N).
                 <Rep (ZipList a_XbS1r) x>_R
                 ->_R (Sub (Control.Applicative.Rep_ZipList[0]
                                <a_XbS1r>_N) ; (GHC.Generics.N:M1[0]
                                                    <*>_N
                                                    <D>_P
                                                    <'MetaData
                                                       "ZipList"
                                                       "Control.Applicative"
                                                       "base"
                                                       'True>_P
                                                    <M1
                                                       C
                                                       ('MetaCons "ZipList" 'PrefixI 'True)
                                                       (M1
                                                          S
                                                          ('MetaSel
                                                             ('Just "getZipList")
                                                             'NoSourceUnpackedness
                                                             'NoSourceStrictness
                                                             'DecidedLazy)
                                                          (K1
                                                             R
                                                             [a_XbS1r]))>_R ; (GHC.Generics.N:M1[0]
                                                                                   <*>_N
                                                                                   <C>_P
                                                                                   <'MetaCons
                                                                                      "ZipList"
                                                                                      'PrefixI
                                                                                      'True>_P
                                                                                   <M1
                                                                                      S
                                                                                      ('MetaSel
                                                                                         ('Just
                                                                                            "getZipList")
                                                                                         'NoSourceUnpackedness
                                                                                         'NoSourceStrictness
                                                                                         'DecidedLazy)
                                                                                      (K1
                                                                                         R
                                                                                         [a_XbS1r])>_R ; GHC.Generics.N:M1[0]
                                                                                                             <*>_N
                                                                                                             <S>_P
                                                                                                             <'MetaSel
                                                                                                                ('Just
                                                                                                                   "getZipList")
                                                                                                                'NoSourceUnpackedness
                                                                                                                'NoSourceStrictness
                                                                                                                'DecidedLazy>_P
                                                                                                             <K1
                                                                                                                R
                                                                                                                [a_XbS1r]>_R))) <x>_N ; (GHC.Generics.N:K1[0]
                                                                                                                                             <*>_N
                                                                                                                                             <R>_P
                                                                                                                                             <[a_XbS1r]>_R
                                                                                                                                             <x>_P ; Sym (Control.Applicative.N:ZipList[0]) <a_XbS1r>_N)
                 :: (forall x.
                     Rep (ZipList a_XbS1r) x -> Rep (ZipList a_XbS1r) x :: *)
                    ~R# (forall x. Rep (ZipList a_XbS1r) x -> ZipList a_XbS1r :: *)))

-- RHS size: {terms: 22, types: 17, coercions: 202, joins: 0/0}
Control.Applicative.$fFoldableZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable ZipList
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: ZipList
                                Data.Foldable.$fFoldableNonEmpty_$cfold1
                                `cast` (forall (m :: <*>_N).
                                        <Monoid m>_R
                                        ->_R Sym (Control.Applicative.N:ZipList[0]) <m>_N
                                        ->_R <m>_R
                                        :: (forall m. Monoid m => [m] -> m :: *)
                                           ~R# (forall m. Monoid m => ZipList m -> m :: *))
                                Data.Foldable.$fFoldable[]_$cfoldMap
                                `cast` (forall (m :: <*>_N) (a :: <*>_N).
                                        <Monoid m>_R
                                        ->_R <a -> m>_R
                                        ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
                                        ->_R <m>_R
                                        :: (forall m a. Monoid m => (a -> m) -> [a] -> m :: *)
                                           ~R# (forall m a.
                                                Monoid m =>
                                                (a -> m) -> ZipList a -> m :: *))
                                GHC.Base.foldr
                                `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                        <a -> b -> b>_R
                                        ->_R <b>_R
                                        ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
                                        ->_R <b>_R
                                        :: (forall a b. (a -> b -> b) -> b -> [a] -> b :: *)
                                           ~R# (forall a b.
                                                (a -> b -> b) -> b -> ZipList a -> b :: *))
                                Data.Foldable.$fFoldable[]_$cfoldr'
                                `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                        <a -> b -> b>_R
                                        ->_R <b>_R
                                        ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
                                        ->_R <b>_R
                                        :: (forall a b. (a -> b -> b) -> b -> [a] -> b :: *)
                                           ~R# (forall a b.
                                                (a -> b -> b) -> b -> ZipList a -> b :: *))
                                (\ (@ b_abRSb) (@ a_abRSc) -> GHC.List.foldl @ a_abRSc @ b_abRSb)
                                `cast` (forall (b :: <*>_N) (a :: <*>_N).
                                        <b -> a -> b>_R
                                        ->_R <b>_R
                                        ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
                                        ->_R <b>_R
                                        :: (forall b a. (b -> a -> b) -> b -> [a] -> b :: *)
                                           ~R# (forall b a.
                                                (b -> a -> b) -> b -> ZipList a -> b :: *))
                                (\ (@ b_abRSN) (@ a_abRSO) -> GHC.List.foldl' @ a_abRSO @ b_abRSN)
                                `cast` (forall (b :: <*>_N) (a :: <*>_N).
                                        <b -> a -> b>_R
                                        ->_R <b>_R
                                        ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
                                        ->_R <b>_R
                                        :: (forall b a. (b -> a -> b) -> b -> [a] -> b :: *)
                                           ~R# (forall b a.
                                                (b -> a -> b) -> b -> ZipList a -> b :: *))
                                GHC.List.foldr1
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
                                        ->_R <a>_R
                                        :: (forall a. (a -> a -> a) -> [a] -> a :: *)
                                           ~R# (forall a. (a -> a -> a) -> ZipList a -> a :: *))
                                GHC.List.foldl1
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
                                        ->_R <a>_R
                                        :: (forall a. (a -> a -> a) -> [a] -> a :: *)
                                           ~R# (forall a. (a -> a -> a) -> ZipList a -> a :: *))
                                (\ (@ a_abRUn) -> id @ [a_abRUn])
                                `cast` (forall (a :: <*>_N).
                                        Sym (Control.Applicative.N:ZipList[0]) <a>_N ->_R <[a]>_R
                                        :: (forall a. [a] -> [a] :: *)
                                           ~R# (forall a. ZipList a -> [a] :: *))
                                GHC.List.null
                                `cast` (forall (a :: <*>_N).
                                        Sym (Control.Applicative.N:ZipList[0]) <a>_N ->_R <Bool>_R
                                        :: (forall a. [a] -> Bool :: *)
                                           ~R# (forall a. ZipList a -> Bool :: *))
                                GHC.List.length
                                `cast` (forall (a :: <*>_N).
                                        Sym (Control.Applicative.N:ZipList[0]) <a>_N ->_R <Int>_R
                                        :: (forall a. [a] -> Int :: *)
                                           ~R# (forall a. ZipList a -> Int :: *))
                                GHC.List.elem
                                `cast` (forall (a :: <*>_N).
                                        <Eq a>_R
                                        ->_R <a>_R
                                        ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
                                        ->_R <Bool>_R
                                        :: (forall a. Eq a => a -> [a] -> Bool :: *)
                                           ~R# (forall a. Eq a => a -> ZipList a -> Bool :: *))
                                GHC.List.maximum
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R
                                        ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
                                        ->_R <a>_R
                                        :: (forall a. Ord a => [a] -> a :: *)
                                           ~R# (forall a. Ord a => ZipList a -> a :: *))
                                GHC.List.minimum
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R
                                        ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
                                        ->_R <a>_R
                                        :: (forall a. Ord a => [a] -> a :: *)
                                           ~R# (forall a. Ord a => ZipList a -> a :: *))
                                GHC.List.sum
                                `cast` (forall (a :: <*>_N).
                                        <GHC.Num.Num a>_R
                                        ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
                                        ->_R <a>_R
                                        :: (forall a. GHC.Num.Num a => [a] -> a :: *)
                                           ~R# (forall a. GHC.Num.Num a => ZipList a -> a :: *))
                                GHC.List.product
                                `cast` (forall (a :: <*>_N).
                                        <GHC.Num.Num a>_R
                                        ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
                                        ->_R <a>_R
                                        :: (forall a. GHC.Num.Num a => [a] -> a :: *)
                                           ~R# (forall a. GHC.Num.Num a => ZipList a -> a :: *))]
Control.Applicative.$fFoldableZipList
  = Data.Foldable.C:Foldable
      @ ZipList
      (Data.Foldable.$fFoldableNonEmpty_$cfold1
       `cast` (forall (m :: <*>_N).
               <Monoid m>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <m>_N
               ->_R <m>_R
               :: (forall m. Monoid m => [m] -> m :: *)
                  ~R# (forall m. Monoid m => ZipList m -> m :: *)))
      (Data.Foldable.$fFoldable[]_$cfoldMap
       `cast` (forall (m :: <*>_N) (a :: <*>_N).
               <Monoid m>_R
               ->_R <a -> m>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
               ->_R <m>_R
               :: (forall m a. Monoid m => (a -> m) -> [a] -> m :: *)
                  ~R# (forall m a. Monoid m => (a -> m) -> ZipList a -> m :: *)))
      (GHC.Base.foldr
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a -> b -> b>_R
               ->_R <b>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
               ->_R <b>_R
               :: (forall a b. (a -> b -> b) -> b -> [a] -> b :: *)
                  ~R# (forall a b. (a -> b -> b) -> b -> ZipList a -> b :: *)))
      (Data.Foldable.$fFoldable[]_$cfoldr'
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a -> b -> b>_R
               ->_R <b>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
               ->_R <b>_R
               :: (forall a b. (a -> b -> b) -> b -> [a] -> b :: *)
                  ~R# (forall a b. (a -> b -> b) -> b -> ZipList a -> b :: *)))
      ((\ (@ b_abRSb) (@ a_abRSc) -> GHC.List.foldl @ a_abRSc @ b_abRSb)
       `cast` (forall (b :: <*>_N) (a :: <*>_N).
               <b -> a -> b>_R
               ->_R <b>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
               ->_R <b>_R
               :: (forall b a. (b -> a -> b) -> b -> [a] -> b :: *)
                  ~R# (forall b a. (b -> a -> b) -> b -> ZipList a -> b :: *)))
      ((\ (@ b_abRSN) (@ a_abRSO) -> GHC.List.foldl' @ a_abRSO @ b_abRSN)
       `cast` (forall (b :: <*>_N) (a :: <*>_N).
               <b -> a -> b>_R
               ->_R <b>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
               ->_R <b>_R
               :: (forall b a. (b -> a -> b) -> b -> [a] -> b :: *)
                  ~R# (forall b a. (b -> a -> b) -> b -> ZipList a -> b :: *)))
      (GHC.List.foldr1
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
               ->_R <a>_R
               :: (forall a. (a -> a -> a) -> [a] -> a :: *)
                  ~R# (forall a. (a -> a -> a) -> ZipList a -> a :: *)))
      (GHC.List.foldl1
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
               ->_R <a>_R
               :: (forall a. (a -> a -> a) -> [a] -> a :: *)
                  ~R# (forall a. (a -> a -> a) -> ZipList a -> a :: *)))
      ((\ (@ a_abRUn) -> id @ [a_abRUn])
       `cast` (forall (a :: <*>_N).
               Sym (Control.Applicative.N:ZipList[0]) <a>_N ->_R <[a]>_R
               :: (forall a. [a] -> [a] :: *)
                  ~R# (forall a. ZipList a -> [a] :: *)))
      (GHC.List.null
       `cast` (forall (a :: <*>_N).
               Sym (Control.Applicative.N:ZipList[0]) <a>_N ->_R <Bool>_R
               :: (forall a. [a] -> Bool :: *)
                  ~R# (forall a. ZipList a -> Bool :: *)))
      (GHC.List.length
       `cast` (forall (a :: <*>_N).
               Sym (Control.Applicative.N:ZipList[0]) <a>_N ->_R <Int>_R
               :: (forall a. [a] -> Int :: *)
                  ~R# (forall a. ZipList a -> Int :: *)))
      (GHC.List.elem
       `cast` (forall (a :: <*>_N).
               <Eq a>_R
               ->_R <a>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
               ->_R <Bool>_R
               :: (forall a. Eq a => a -> [a] -> Bool :: *)
                  ~R# (forall a. Eq a => a -> ZipList a -> Bool :: *)))
      (GHC.List.maximum
       `cast` (forall (a :: <*>_N).
               <Ord a>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
               ->_R <a>_R
               :: (forall a. Ord a => [a] -> a :: *)
                  ~R# (forall a. Ord a => ZipList a -> a :: *)))
      (GHC.List.minimum
       `cast` (forall (a :: <*>_N).
               <Ord a>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
               ->_R <a>_R
               :: (forall a. Ord a => [a] -> a :: *)
                  ~R# (forall a. Ord a => ZipList a -> a :: *)))
      (GHC.List.sum
       `cast` (forall (a :: <*>_N).
               <GHC.Num.Num a>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
               ->_R <a>_R
               :: (forall a. GHC.Num.Num a => [a] -> a :: *)
                  ~R# (forall a. GHC.Num.Num a => ZipList a -> a :: *)))
      (GHC.List.product
       `cast` (forall (a :: <*>_N).
               <GHC.Num.Num a>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
               ->_R <a>_R
               :: (forall a. GHC.Num.Num a => [a] -> a :: *)
                  ~R# (forall a. GHC.Num.Num a => ZipList a -> a :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 31, joins: 0/0}
Control.Applicative.$fFunctorZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: Functor ZipList
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: ZipList
                          map
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a -> b>_R
                                  ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
                                  ->_R Sym (Control.Applicative.N:ZipList[0]) <b>_N
                                  :: (forall a b. (a -> b) -> [a] -> [b] :: *)
                                     ~R# (forall a b. (a -> b) -> ZipList a -> ZipList b :: *))
                          GHC.Base.$fFunctor[]_$c<$
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a>_R
                                  ->_R Sym (Control.Applicative.N:ZipList[0]) <b>_N
                                  ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
                                  :: (forall a b. a -> [b] -> [a] :: *)
                                     ~R# (forall a b. a -> ZipList b -> ZipList a :: *))]
Control.Applicative.$fFunctorZipList
  = GHC.Base.C:Functor
      @ ZipList
      (map
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a -> b>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
               ->_R Sym (Control.Applicative.N:ZipList[0]) <b>_N
               :: (forall a b. (a -> b) -> [a] -> [b] :: *)
                  ~R# (forall a b. (a -> b) -> ZipList a -> ZipList b :: *)))
      (GHC.Base.$fFunctor[]_$c<$
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <b>_N
               ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
               :: (forall a b. a -> [b] -> [a] :: *)
                  ~R# (forall a b. a -> ZipList b -> ZipList a :: *)))

Rec {
-- RHS size: {terms: 20, types: 27, coercions: 0, joins: 0/0}
Control.Applicative.$fApplicativeZipList6 [Occ=LoopBreaker]
  :: forall a b. [a -> b] -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []]
Control.Applicative.$fApplicativeZipList6
  = \ (@ a_abS0d)
      (@ b_abS0e)
      (ds_iaIkM :: [a_abS0d -> b_abS0e])
      (ds1_iaIkN :: [a_abS0d]) ->
      case ds_iaIkM of {
        [] -> GHC.Types.[] @ b_abS0e;
        : ipv_iaIkR ipv1_iaIkS ->
          case ds1_iaIkN of {
            [] -> GHC.Types.[] @ b_abS0e;
            : ipv2_iaIkX ipv3_iaIkY ->
              GHC.Types.:
                @ b_abS0e
                (ipv_iaIkR ipv2_iaIkX)
                (Control.Applicative.$fApplicativeZipList6
                   @ a_abS0d @ b_abS0e ipv1_iaIkS ipv3_iaIkY)
          }
      }
end Rec }

-- RHS size: {terms: 7, types: 11, coercions: 5, joins: 0/0}
Control.Applicative.$fApplicativeZipList5
  :: forall a b. ZipList (a -> b) -> ZipList a -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
Control.Applicative.$fApplicativeZipList5
  = \ (@ a_abS0d)
      (@ b_abS0e)
      (ds_XbSmr :: ZipList (a_abS0d -> b_abS0e))
      (ds1_XbSmu :: ZipList a_abS0d) ->
      Control.Applicative.$fApplicativeZipList6
        @ a_abS0d
        @ b_abS0e
        (ds_XbSmr
         `cast` (Control.Applicative.N:ZipList[0] <a_abS0d -> b_abS0e>_N
                 :: (ZipList (a_abS0d -> b_abS0e) :: *)
                    ~R# ([a_abS0d -> b_abS0e] :: *)))
        (ds1_XbSmu
         `cast` (Control.Applicative.N:ZipList[0] <a_abS0d>_N
                 :: (ZipList a_abS0d :: *) ~R# ([a_abS0d] :: *)))

Rec {
-- RHS size: {terms: 19, types: 23, coercions: 0, joins: 0/0}
Control.Applicative.$fApplicativeZipList4 [Occ=LoopBreaker]
  :: forall a b. [a] -> [b] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []]
Control.Applicative.$fApplicativeZipList4
  = \ (@ a_abS0y)
      (@ b_abS0z)
      (ds_i7Jck :: [a_abS0y])
      (eta_B1 :: [b_abS0z]) ->
      case ds_i7Jck of {
        [] -> GHC.Types.[] @ b_abS0z;
        : y_i7Jcp ys_i7Jcq ->
          case eta_B1 of {
            [] -> GHC.Types.[] @ b_abS0z;
            : y1_ibSkK ys1_ibSkL ->
              GHC.Types.:
                @ b_abS0z
                y1_ibSkK
                (Control.Applicative.$fApplicativeZipList4
                   @ a_abS0y @ b_abS0z ys_i7Jcq ys1_ibSkL)
          }
      }
end Rec }

-- RHS size: {terms: 7, types: 10, coercions: 4, joins: 0/0}
Control.Applicative.$fApplicativeZipList3
  :: forall a b. ZipList a -> ZipList b -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
Control.Applicative.$fApplicativeZipList3
  = \ (@ a_abS0y)
      (@ b_abS0z)
      (a1_XbJiA :: ZipList a_abS0y)
      (a2_XbJiC :: ZipList b_abS0z) ->
      Control.Applicative.$fApplicativeZipList4
        @ a_abS0y
        @ b_abS0z
        (a1_XbJiA
         `cast` (Control.Applicative.N:ZipList[0] <a_abS0y>_N
                 :: (ZipList a_abS0y :: *) ~R# ([a_abS0y] :: *)))
        (a2_XbJiC
         `cast` (Control.Applicative.N:ZipList[0] <b_abS0z>_N
                 :: (ZipList b_abS0z :: *) ~R# ([b_abS0z] :: *)))

Rec {
-- RHS size: {terms: 19, types: 23, coercions: 0, joins: 0/0}
Control.Applicative.$fApplicativeZipList2 [Occ=LoopBreaker]
  :: forall b a. [a] -> [b] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []]
Control.Applicative.$fApplicativeZipList2
  = \ (@ b_abS0J)
      (@ a_abS0I)
      (ds_iaIkM :: [a_abS0I])
      (ds1_iaIkN :: [b_abS0J]) ->
      case ds_iaIkM of {
        [] -> GHC.Types.[] @ a_abS0I;
        : ipv_iaIkR ipv1_iaIkS ->
          case ds1_iaIkN of {
            [] -> GHC.Types.[] @ a_abS0I;
            : ipv2_iaIkX ipv3_iaIkY ->
              GHC.Types.:
                @ a_abS0I
                ipv_iaIkR
                (Control.Applicative.$fApplicativeZipList2
                   @ b_abS0J @ a_abS0I ipv1_iaIkS ipv3_iaIkY)
          }
      }
end Rec }

-- RHS size: {terms: 7, types: 10, coercions: 4, joins: 0/0}
Control.Applicative.$fApplicativeZipList1
  :: forall b a. ZipList a -> ZipList b -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
Control.Applicative.$fApplicativeZipList1
  = \ (@ b_abS0J)
      (@ a_abS0I)
      (ds_XbSml :: ZipList a_abS0I)
      (ds1_XbSmo :: ZipList b_abS0J) ->
      Control.Applicative.$fApplicativeZipList2
        @ b_abS0J
        @ a_abS0I
        (ds_XbSml
         `cast` (Control.Applicative.N:ZipList[0] <a_abS0I>_N
                 :: (ZipList a_abS0I :: *) ~R# ([a_abS0I] :: *)))
        (ds1_XbSmo
         `cast` (Control.Applicative.N:ZipList[0] <b_abS0J>_N
                 :: (ZipList b_abS0J :: *) ~R# ([b_abS0J] :: *)))

-- RHS size: {terms: 9, types: 7, coercions: 78, joins: 0/0}
Control.Applicative.$fApplicativeZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: Applicative ZipList
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Applicative TYPE: ZipList
                              Control.Applicative.$fFunctorZipList
                              repeat
                              `cast` (forall (a :: <*>_N).
                                      <a>_R ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
                                      :: (forall a. a -> [a] :: *)
                                         ~R# (forall a. a -> ZipList a :: *))
                              Control.Applicative.$fApplicativeZipList5
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <ZipList (a -> b)>_R
                                      ->_R <ZipList a>_R
                                      ->_R Sym (Control.Applicative.N:ZipList[0]) <b>_N
                                      :: (forall a b. ZipList (a -> b) -> ZipList a -> [b] :: *)
                                         ~R# (forall a b.
                                              ZipList (a -> b) -> ZipList a -> ZipList b :: *))
                              zipWith
                              `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                                      <a -> b -> c>_R
                                      ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
                                      ->_R Sym (Control.Applicative.N:ZipList[0]) <b>_N
                                      ->_R Sym (Control.Applicative.N:ZipList[0]) <c>_N
                                      :: (forall a b c. (a -> b -> c) -> [a] -> [b] -> [c] :: *)
                                         ~R# (forall a b c.
                                              (a -> b -> c)
                                              -> ZipList a -> ZipList b -> ZipList c :: *))
                              Control.Applicative.$fApplicativeZipList3
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <ZipList a>_R
                                      ->_R <ZipList b>_R
                                      ->_R Sym (Control.Applicative.N:ZipList[0]) <b>_N
                                      :: (forall a b. ZipList a -> ZipList b -> [b] :: *)
                                         ~R# (forall a b. ZipList a -> ZipList b -> ZipList b :: *))
                              (\ (@ a_abS0I) (@ b_abS0J) ->
                                 Control.Applicative.$fApplicativeZipList1 @ b_abS0J @ a_abS0I)
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <ZipList a>_R
                                      ->_R <ZipList b>_R
                                      ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
                                      :: (forall a b. ZipList a -> ZipList b -> [a] :: *)
                                         ~R# (forall a b.
                                              ZipList a -> ZipList b -> ZipList a :: *))]
Control.Applicative.$fApplicativeZipList
  = GHC.Base.C:Applicative
      @ ZipList
      Control.Applicative.$fFunctorZipList
      (repeat
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
               :: (forall a. a -> [a] :: *) ~R# (forall a. a -> ZipList a :: *)))
      (Control.Applicative.$fApplicativeZipList5
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <ZipList (a -> b)>_R
               ->_R <ZipList a>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <b>_N
               :: (forall a b. ZipList (a -> b) -> ZipList a -> [b] :: *)
                  ~R# (forall a b. ZipList (a -> b) -> ZipList a -> ZipList b :: *)))
      (zipWith
       `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
               <a -> b -> c>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
               ->_R Sym (Control.Applicative.N:ZipList[0]) <b>_N
               ->_R Sym (Control.Applicative.N:ZipList[0]) <c>_N
               :: (forall a b c. (a -> b -> c) -> [a] -> [b] -> [c] :: *)
                  ~R# (forall a b c.
                       (a -> b -> c) -> ZipList a -> ZipList b -> ZipList c :: *)))
      (Control.Applicative.$fApplicativeZipList3
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <ZipList a>_R
               ->_R <ZipList b>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <b>_N
               :: (forall a b. ZipList a -> ZipList b -> [b] :: *)
                  ~R# (forall a b. ZipList a -> ZipList b -> ZipList b :: *)))
      ((\ (@ a_abS0I) (@ b_abS0J) ->
          Control.Applicative.$fApplicativeZipList1 @ b_abS0J @ a_abS0I)
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <ZipList a>_R
               ->_R <ZipList b>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
               :: (forall a b. ZipList a -> ZipList b -> [a] :: *)
                  ~R# (forall a b. ZipList a -> ZipList b -> ZipList a :: *)))

Rec {
-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Control.Applicative.$fAlternativeZipList_xs [Occ=LoopBreaker]
  :: forall a. [[a]]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
Control.Applicative.$fAlternativeZipList_xs
  = \ (@ a_abRZG) ->
      GHC.Types.:
        @ [a_abRZG]
        (GHC.Types.[] @ a_abRZG)
        (Control.Applicative.$fAlternativeZipList_xs @ a_abRZG)
end Rec }

Rec {
-- RHS size: {terms: 20, types: 28, coercions: 0, joins: 0/0}
Control.Applicative.$fAlternativeZipList1 [Occ=LoopBreaker]
  :: forall a. [a] -> [[a]] -> [[a]]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []]
Control.Applicative.$fAlternativeZipList1
  = \ (@ a_abRZG)
      (ds_iaIkM :: [a_abRZG])
      (ds1_iaIkN :: [[a_abRZG]]) ->
      case ds_iaIkM of {
        [] -> GHC.Types.[] @ [a_abRZG];
        : ipv_iaIkR ipv1_iaIkS ->
          case ds1_iaIkN of {
            [] -> GHC.Types.[] @ [a_abRZG];
            : ipv2_iaIkX ipv3_iaIkY ->
              GHC.Types.:
                @ [a_abRZG]
                (GHC.Types.: @ a_abRZG ipv_iaIkR ipv2_iaIkX)
                (Control.Applicative.$fAlternativeZipList1
                   @ a_abRZG ipv1_iaIkS ipv3_iaIkY)
          }
      }
end Rec }

-- RHS size: {terms: 9, types: 11, coercions: 14, joins: 0/1}
Control.Applicative.$fAlternativeZipList_$csome
  :: forall a. ZipList a -> ZipList [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 70 0}]
Control.Applicative.$fAlternativeZipList_$csome
  = \ (@ a_abRZG) (v_i9Dk5 :: ZipList a_abRZG) ->
      letrec {
        some_v_sbSlH [Occ=LoopBreaker] :: [[a_abRZG]]
        [LclId]
        some_v_sbSlH
          = Control.Applicative.$fAlternativeZipList1
              @ a_abRZG
              (v_i9Dk5
               `cast` (Control.Applicative.N:ZipList[0] <a_abRZG>_N
                       :: (ZipList a_abRZG :: *) ~R# ([a_abRZG] :: *)))
              (Control.Applicative.$fAlternativeZipList2
                 @ [a_abRZG]
                 (some_v_sbSlH
                  `cast` (Sym (Control.Applicative.N:ZipList[0]) <[a_abRZG]>_N
                          :: ([[a_abRZG]] :: *) ~R# (ZipList [a_abRZG] :: *)))
                 ((Control.Applicative.$fAlternativeZipList_xs @ a_abRZG)
                  `cast` (Sym (Control.Applicative.N:ZipList[0]) <[a_abRZG]>_N
                          :: ([[a_abRZG]] :: *) ~R# (ZipList [a_abRZG] :: *)))); } in
      some_v_sbSlH
      `cast` (Sym (Control.Applicative.N:ZipList[0]) <[a_abRZG]>_N
              :: ([[a_abRZG]] :: *) ~R# (ZipList [a_abRZG] :: *))

-- RHS size: {terms: 9, types: 11, coercions: 14, joins: 0/1}
Control.Applicative.$fAlternativeZipList_$cmany
  :: forall a. ZipList a -> ZipList [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 70 0}]
Control.Applicative.$fAlternativeZipList_$cmany
  = \ (@ a_abRZO) (v_i9Dkb :: ZipList a_abRZO) ->
      letrec {
        many_v_sbSlF [Occ=LoopBreaker] :: [[a_abRZO]]
        [LclId]
        many_v_sbSlF
          = Control.Applicative.$fAlternativeZipList2
              @ [a_abRZO]
              ((Control.Applicative.$fAlternativeZipList1
                  @ a_abRZO
                  (v_i9Dkb
                   `cast` (Control.Applicative.N:ZipList[0] <a_abRZO>_N
                           :: (ZipList a_abRZO :: *) ~R# ([a_abRZO] :: *)))
                  many_v_sbSlF)
               `cast` (Sym (Control.Applicative.N:ZipList[0]) <[a_abRZO]>_N
                       :: ([[a_abRZO]] :: *) ~R# (ZipList [a_abRZO] :: *)))
              ((Control.Applicative.$fAlternativeZipList_xs @ a_abRZO)
               `cast` (Sym (Control.Applicative.N:ZipList[0]) <[a_abRZO]>_N
                       :: ([[a_abRZO]] :: *) ~R# (ZipList [a_abRZO] :: *))); } in
      many_v_sbSlF
      `cast` (Sym (Control.Applicative.N:ZipList[0]) <[a_abRZO]>_N
              :: ([[a_abRZO]] :: *) ~R# (ZipList [a_abRZO] :: *))

-- RHS size: {terms: 6, types: 1, coercions: 18, joins: 0/0}
Control.Applicative.$fAlternativeZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: Alternative ZipList
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Alternative TYPE: ZipList
                              Control.Applicative.$fApplicativeZipList
                              GHC.Types.[]
                              `cast` (forall (a :: <*>_N).
                                      Sym (Control.Applicative.N:ZipList[0]) <a>_N
                                      :: (forall a. [a] :: *) ~R# (forall a. ZipList a :: *))
                              Control.Applicative.$fAlternativeZipList2
                              `cast` (forall (a :: <*>_N).
                                      <ZipList a>_R
                                      ->_R <ZipList a>_R
                                      ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
                                      :: (forall a. ZipList a -> ZipList a -> [a] :: *)
                                         ~R# (forall a. ZipList a -> ZipList a -> ZipList a :: *))
                              Control.Applicative.$fAlternativeZipList_$csome
                              Control.Applicative.$fAlternativeZipList_$cmany]
Control.Applicative.$fAlternativeZipList
  = GHC.Base.C:Alternative
      @ ZipList
      Control.Applicative.$fApplicativeZipList
      (GHC.Types.[]
       `cast` (forall (a :: <*>_N).
               Sym (Control.Applicative.N:ZipList[0]) <a>_N
               :: (forall a. [a] :: *) ~R# (forall a. ZipList a :: *)))
      (Control.Applicative.$fAlternativeZipList2
       `cast` (forall (a :: <*>_N).
               <ZipList a>_R
               ->_R <ZipList a>_R
               ->_R Sym (Control.Applicative.N:ZipList[0]) <a>_N
               :: (forall a. ZipList a -> ZipList a -> [a] :: *)
                  ~R# (forall a. ZipList a -> ZipList a -> ZipList a :: *)))
      Control.Applicative.$fAlternativeZipList_$csome
      Control.Applicative.$fAlternativeZipList_$cmany

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$fReadZipList11 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Control.Applicative.$fReadZipList11 = "ZipList"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$fReadZipList10 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Control.Applicative.$fReadZipList10
  = unpackCString# Control.Applicative.$fReadZipList11

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$fReadZipList_lexeme1 :: Text.Read.Lex.Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Applicative.$fReadZipList_lexeme1
  = Text.Read.Lex.Ident Control.Applicative.$fReadZipList10

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$fReadZipList9 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Control.Applicative.$fReadZipList9 = "{"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$fReadZipList8 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Control.Applicative.$fReadZipList8
  = unpackCString# Control.Applicative.$fReadZipList9

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$fReadZipList_lexeme :: Text.Read.Lex.Lexeme
[GblId,
 Str=m3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Applicative.$fReadZipList_lexeme
  = Text.Read.Lex.Punc Control.Applicative.$fReadZipList8

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$fReadZipList7 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Applicative.$fReadZipList7 = "getZipList"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$fReadZipList6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Control.Applicative.$fReadZipList6
  = unpackCString# Control.Applicative.$fReadZipList7

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$fReadZipList5 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Applicative.$fReadZipList5 = GHC.Types.I# 11#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$fReadZipList4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Control.Applicative.$fReadZipList4 = "}"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$fReadZipList3 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Control.Applicative.$fReadZipList3
  = unpackCString# Control.Applicative.$fReadZipList4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$fReadZipList2 :: Text.Read.Lex.Lexeme
[GblId,
 Str=m3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Applicative.$fReadZipList2
  = Text.Read.Lex.Punc Control.Applicative.$fReadZipList3

-- RHS size: {terms: 51, types: 64, coercions: 27, joins: 0/2}
Control.Applicative.$fReadZipList1
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (ZipList a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,A,1*C1(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30] 391 60}]
Control.Applicative.$fReadZipList1
  = \ (@ a_abRO3) ($dRead_abRO4 :: Read a_abRO3) ->
      GHC.Read.list3
        @ (ZipList a_abRO3)
        (let {
           lvl_sbSmD :: Text.ParserCombinators.ReadP.ReadP [a_abRO3]
           [LclId]
           lvl_sbSmD
             = ((GHC.Read.readListPrec @ a_abRO3 $dRead_abRO4)
                `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[a_abRO3]>_R
                        :: (Text.ParserCombinators.ReadPrec.ReadPrec [a_abRO3] :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.Prec
                                -> Text.ParserCombinators.ReadP.ReadP [a_abRO3] :: *)))
                 Text.ParserCombinators.ReadPrec.minPrec } in
         let {
           ds_sbSlx [Dmd=<L,C(C1(U))>]
             :: Text.ParserCombinators.ReadPrec.Prec
                -> Text.ParserCombinators.ReadP.ReadP [a_abRO3]
           [LclId,
            Arity=1,
            Str=<L,A>,
            Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                    WorkFree=True, Expandable=True,
                    Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
                    Tmpl= \ _ [Occ=Dead] -> lvl_sbSmD}]
           ds_sbSlx = \ _ [Occ=Dead] -> lvl_sbSmD } in
         (\ (c_i88VW :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b_i815E)
            (eta_X48
               :: ZipList a_abRO3 -> Text.ParserCombinators.ReadP.P b_i815E) ->
            case c_i88VW of { I# x_i88VZ ->
            case <=# x_i88VZ 11# of {
              __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b_i815E;
              1# ->
                case Text.Read.Lex.$wexpect
                       Control.Applicative.$fReadZipList_lexeme1
                       @ b_i815E
                       (\ _ [Occ=Dead, OS=OneShot] ->
                          case Text.Read.Lex.$wexpect
                                 Control.Applicative.$fReadZipList_lexeme
                                 @ b_i815E
                                 (\ _ [Occ=Dead, OS=OneShot] ->
                                    ((((GHC.Read.readField
                                          @ [a_abRO3]
                                          Control.Applicative.$fReadZipList6
                                          (ds_sbSlx
                                           `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                            <[a_abRO3]>_R)
                                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                                       -> Text.ParserCombinators.ReadP.ReadP
                                                            [a_abRO3] :: *)
                                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                                             [a_abRO3] :: *))))
                                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                   <[a_abRO3]>_R
                                               :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                                     [a_abRO3] :: *)
                                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                       -> Text.ParserCombinators.ReadP.ReadP
                                                            [a_abRO3] :: *)))
                                        Control.Applicative.$fReadZipList5)
                                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[a_abRO3]>_R
                                             :: (Text.ParserCombinators.ReadP.ReadP [a_abRO3] :: *)
                                                ~R# (forall b.
                                                     ([a_abRO3] -> Text.ParserCombinators.ReadP.P b)
                                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                                      @ b_i815E
                                      (\ (a3_i88WJ :: [a_abRO3]) ->
                                         case Text.Read.Lex.$wexpect
                                                Control.Applicative.$fReadZipList2
                                                @ b_i815E
                                                (\ _ [Occ=Dead, OS=OneShot] ->
                                                   eta_X48
                                                     (a3_i88WJ
                                                      `cast` (Sym (Control.Applicative.N:ZipList[0]) <a_abRO3>_N
                                                              :: ([a_abRO3] :: *)
                                                                 ~R# (ZipList a_abRO3 :: *))))
                                         of
                                         { (# ww1_i88Ww #) ->
                                         Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
                                         }))
                          of
                          { (# ww1_i88Ww #) ->
                          Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
                          })
                of
                { (# ww1_i88Ww #) ->
                Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
                }
            }
            })
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <ZipList
                                   a_abRO3>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <ZipList a_abRO3>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (ZipList a_abRO3 -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (ZipList a_abRO3) :: *)))

-- RHS size: {terms: 10, types: 21, coercions: 0, joins: 0/1}
Control.Applicative.$fReadZipList_$creadsPrec
  :: forall a.
     Read a =>
     Int -> Text.ParserCombinators.ReadP.ReadS (ZipList a)
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,A,1*C1(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 90 60}]
Control.Applicative.$fReadZipList_$creadsPrec
  = \ (@ a_XbRSJ) ($dRead_XbRSL :: Read a_XbRSJ) ->
      let {
        ds_sbSlp [Dmd=<L,C(C1(U))>]
          :: Text.ParserCombinators.ReadPrec.Prec
             -> forall b.
                (ZipList a_XbRSJ -> Text.ParserCombinators.ReadP.P b)
                -> Text.ParserCombinators.ReadP.P b
        [LclId]
        ds_sbSlp
          = Control.Applicative.$fReadZipList1 @ a_XbRSJ $dRead_XbRSL } in
      \ (n_i8156 :: Int) ->
        Text.ParserCombinators.ReadP.run
          @ (ZipList a_XbRSJ)
          (ds_sbSlp
             n_i8156
             @ (ZipList a_XbRSJ)
             (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                @ (ZipList a_XbRSJ)))

-- RHS size: {terms: 5, types: 7, coercions: 11, joins: 0/0}
Control.Applicative.$fReadZipList_$creadListPrec
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [ZipList a]
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,A,1*C1(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XbRSH) ($dRead_XbRSJ [Occ=Once] :: Read a_XbRSH) ->
                 GHC.Read.list
                   @ (ZipList a_XbRSH)
                   ((Control.Applicative.$fReadZipList1 @ a_XbRSH $dRead_XbRSJ)
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <ZipList
                                              a_XbRSH>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <ZipList a_XbRSH>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   (ZipList a_XbRSH -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                      (ZipList a_XbRSH) :: *)))}]
Control.Applicative.$fReadZipList_$creadListPrec
  = \ (@ a_XbRSH) ($dRead_XbRSJ :: Read a_XbRSH) ->
      GHC.Read.list
        @ (ZipList a_XbRSH)
        ((Control.Applicative.$fReadZipList1 @ a_XbRSH $dRead_XbRSJ)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <ZipList
                                   a_XbRSH>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <ZipList a_XbRSH>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (ZipList a_XbRSH -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (ZipList a_XbRSH) :: *)))

-- RHS size: {terms: 8, types: 16, coercions: 19, joins: 0/0}
Control.Applicative.$fReadZipList_$creadList
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadP.ReadS [ZipList a]
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,A,1*C1(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XbRSI) ($dRead_XbRSK [Occ=Once] :: Read a_XbRSI) ->
                 Text.ParserCombinators.ReadP.run
                   @ [ZipList a_XbRSI]
                   (((((GHC.Read.list
                          @ (ZipList a_XbRSI)
                          ((Control.Applicative.$fReadZipList1 @ a_XbRSI $dRead_XbRSK)
                           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                  <ZipList
                                                     a_XbRSI>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                             <ZipList a_XbRSI>_R)
                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                       -> forall b.
                                          (ZipList a_XbRSI -> Text.ParserCombinators.ReadP.P b)
                                          -> Text.ParserCombinators.ReadP.P b :: *)
                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                             (ZipList a_XbRSI) :: *))))
                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <[ZipList a_XbRSI]>_R
                               :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                     [ZipList a_XbRSI] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                       -> Text.ParserCombinators.ReadP.ReadP
                                            [ZipList a_XbRSI] :: *)))
                        GHC.Read.$fRead()7)
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                                 <[ZipList a_XbRSI]>_R
                             :: (Text.ParserCombinators.ReadP.ReadP [ZipList a_XbRSI] :: *)
                                ~R# (forall b.
                                     ([ZipList a_XbRSI] -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                      @ [ZipList a_XbRSI]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [ZipList a_XbRSI]))}]
Control.Applicative.$fReadZipList_$creadList
  = \ (@ a_XbRSI) ($dRead_XbRSK :: Read a_XbRSI) ->
      Text.ParserCombinators.ReadP.run
        @ [ZipList a_XbRSI]
        (((((GHC.Read.list
               @ (ZipList a_XbRSI)
               ((Control.Applicative.$fReadZipList1 @ a_XbRSI $dRead_XbRSK)
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <ZipList
                                          a_XbRSI>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <ZipList a_XbRSI>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               (ZipList a_XbRSI -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                  (ZipList a_XbRSI) :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[ZipList a_XbRSI]>_R
                    :: (Text.ParserCombinators.ReadPrec.ReadPrec
                          [ZipList a_XbRSI] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP [ZipList a_XbRSI] :: *)))
             GHC.Read.$fRead()7)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                      <[ZipList a_XbRSI]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP [ZipList a_XbRSI] :: *)
                     ~R# (forall b.
                          ([ZipList a_XbRSI] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [ZipList a_XbRSI]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [ZipList a_XbRSI]))

-- RHS size: {terms: 11, types: 10, coercions: 11, joins: 0/0}
Control.Applicative.$fReadZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Read a => Read (ZipList a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,A,C(U))>m,
 Unf=DFun: \ (@ a_abRpC) (v_X3U :: Read a_abRpC) ->
       GHC.Read.C:Read TYPE: ZipList a_abRpC
                       Control.Applicative.$fReadZipList_$creadsPrec @ a_abRpC v_X3U
                       Control.Applicative.$fReadZipList_$creadList @ a_abRpC v_X3U
                       (Control.Applicative.$fReadZipList1 @ a_abRpC v_X3U)
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <ZipList
                                                 a_abRpC>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <ZipList a_abRpC>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (ZipList a_abRpC -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                         (ZipList a_abRpC) :: *))
                       Control.Applicative.$fReadZipList_$creadListPrec @ a_abRpC v_X3U]
Control.Applicative.$fReadZipList
  = \ (@ a_XbRSG) ($dRead_XbRSI :: Read a_XbRSG) ->
      GHC.Read.C:Read
        @ (ZipList a_XbRSG)
        (Control.Applicative.$fReadZipList_$creadsPrec
           @ a_XbRSG $dRead_XbRSI)
        (Control.Applicative.$fReadZipList_$creadList
           @ a_XbRSG $dRead_XbRSI)
        ((Control.Applicative.$fReadZipList1 @ a_XbRSG $dRead_XbRSI)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <ZipList
                                   a_XbRSG>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <ZipList a_XbRSG>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (ZipList a_XbRSG -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (ZipList a_XbRSG) :: *)))
        (Control.Applicative.$fReadZipList_$creadListPrec
           @ a_XbRSG $dRead_XbRSI)

-- RHS size: {terms: 7, types: 8, coercions: 18, joins: 0/0}
Control.Applicative.$fEqZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Eq a => Eq (ZipList a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)>m,
 Unf=DFun: \ (@ a_abRpC) (v_X3V :: Eq a_abRpC) ->
       GHC.Classes.C:Eq TYPE: ZipList a_abRpC
                        (GHC.Classes.$fEq[]_$c== @ a_abRpC v_X3V)
                        `cast` (Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                ->_R <Bool>_R
                                :: ([a_abRpC] -> [a_abRpC] -> Bool :: *)
                                   ~R# (ZipList a_abRpC -> ZipList a_abRpC -> Bool :: *))
                        (GHC.Classes.$fEq[]_$c/= @ a_abRpC v_X3V)
                        `cast` (Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                ->_R <Bool>_R
                                :: ([a_abRpC] -> [a_abRpC] -> Bool :: *)
                                   ~R# (ZipList a_abRpC -> ZipList a_abRpC -> Bool :: *))]
Control.Applicative.$fEqZipList
  = \ (@ a_abRLG) ($dEq_abRLH :: Eq a_abRLG) ->
      GHC.Classes.C:Eq
        @ (ZipList a_abRLG)
        ((GHC.Classes.$fEq[]_$c== @ a_abRLG $dEq_abRLH)
         `cast` (Sym (Control.Applicative.N:ZipList[0]) <a_abRLG>_N
                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRLG>_N
                 ->_R <Bool>_R
                 :: ([a_abRLG] -> [a_abRLG] -> Bool :: *)
                    ~R# (ZipList a_abRLG -> ZipList a_abRLG -> Bool :: *)))
        ((GHC.Classes.$fEq[]_$c/= @ a_abRLG $dEq_abRLH)
         `cast` (Sym (Control.Applicative.N:ZipList[0]) <a_abRLG>_N
                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRLG>_N
                 ->_R <Bool>_R
                 :: ([a_abRLG] -> [a_abRLG] -> Bool :: *)
                    ~R# (ZipList a_abRLG -> ZipList a_abRLG -> Bool :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Control.Applicative.$fOrdZipList_$cp1Ord
  :: forall a. Ord a => Eq (ZipList a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abRMe) ($dOrd_abRMf [Occ=Once] :: Ord a_abRMe) ->
                 Control.Applicative.$fEqZipList
                   @ a_abRMe (GHC.Classes.$p1Ord @ a_abRMe $dOrd_abRMf)}]
Control.Applicative.$fOrdZipList_$cp1Ord
  = \ (@ a_abRMe) ($dOrd_abRMf :: Ord a_abRMe) ->
      Control.Applicative.$fEqZipList
        @ a_abRMe (GHC.Classes.$p1Ord @ a_abRMe $dOrd_abRMf)

-- RHS size: {terms: 19, types: 14, coercions: 67, joins: 0/0}
Control.Applicative.$fOrdZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Ord (ZipList a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m,
 Unf=DFun: \ (@ a_abRpC) (v_X3X :: Ord a_abRpC) ->
       GHC.Classes.C:Ord TYPE: ZipList a_abRpC
                         Control.Applicative.$fOrdZipList_$cp1Ord @ a_abRpC v_X3X
                         (GHC.Classes.$fOrd[]_$ccompare @ a_abRpC v_X3X)
                         `cast` (Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                 ->_R <Ordering>_R
                                 :: ([a_abRpC] -> [a_abRpC] -> Ordering :: *)
                                    ~R# (ZipList a_abRpC -> ZipList a_abRpC -> Ordering :: *))
                         (GHC.Classes.$fOrd[]_$c< @ a_abRpC v_X3X)
                         `cast` (Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                 ->_R <Bool>_R
                                 :: ([a_abRpC] -> [a_abRpC] -> Bool :: *)
                                    ~R# (ZipList a_abRpC -> ZipList a_abRpC -> Bool :: *))
                         (GHC.Classes.$fOrd[]_$c<= @ a_abRpC v_X3X)
                         `cast` (Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                 ->_R <Bool>_R
                                 :: ([a_abRpC] -> [a_abRpC] -> Bool :: *)
                                    ~R# (ZipList a_abRpC -> ZipList a_abRpC -> Bool :: *))
                         (GHC.Classes.$fOrd[]_$c> @ a_abRpC v_X3X)
                         `cast` (Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                 ->_R <Bool>_R
                                 :: ([a_abRpC] -> [a_abRpC] -> Bool :: *)
                                    ~R# (ZipList a_abRpC -> ZipList a_abRpC -> Bool :: *))
                         (GHC.Classes.$fOrd[]_$c>= @ a_abRpC v_X3X)
                         `cast` (Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                 ->_R <Bool>_R
                                 :: ([a_abRpC] -> [a_abRpC] -> Bool :: *)
                                    ~R# (ZipList a_abRpC -> ZipList a_abRpC -> Bool :: *))
                         (GHC.Classes.$fOrd[]_$cmax @ a_abRpC v_X3X)
                         `cast` (Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                 :: ([a_abRpC] -> [a_abRpC] -> [a_abRpC] :: *)
                                    ~R# (ZipList a_abRpC
                                         -> ZipList a_abRpC -> ZipList a_abRpC :: *))
                         (GHC.Classes.$fOrd[]_$cmin @ a_abRpC v_X3X)
                         `cast` (Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRpC>_N
                                 :: ([a_abRpC] -> [a_abRpC] -> [a_abRpC] :: *)
                                    ~R# (ZipList a_abRpC
                                         -> ZipList a_abRpC -> ZipList a_abRpC :: *))]
Control.Applicative.$fOrdZipList
  = \ (@ a_abRMe) ($dOrd_abRMf :: Ord a_abRMe) ->
      GHC.Classes.C:Ord
        @ (ZipList a_abRMe)
        (Control.Applicative.$fOrdZipList_$cp1Ord @ a_abRMe $dOrd_abRMf)
        ((GHC.Classes.$fOrd[]_$ccompare @ a_abRMe $dOrd_abRMf)
         `cast` (Sym (Control.Applicative.N:ZipList[0]) <a_abRMe>_N
                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRMe>_N
                 ->_R <Ordering>_R
                 :: ([a_abRMe] -> [a_abRMe] -> Ordering :: *)
                    ~R# (ZipList a_abRMe -> ZipList a_abRMe -> Ordering :: *)))
        ((GHC.Classes.$fOrd[]_$c< @ a_abRMe $dOrd_abRMf)
         `cast` (Sym (Control.Applicative.N:ZipList[0]) <a_abRMe>_N
                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRMe>_N
                 ->_R <Bool>_R
                 :: ([a_abRMe] -> [a_abRMe] -> Bool :: *)
                    ~R# (ZipList a_abRMe -> ZipList a_abRMe -> Bool :: *)))
        ((GHC.Classes.$fOrd[]_$c<= @ a_abRMe $dOrd_abRMf)
         `cast` (Sym (Control.Applicative.N:ZipList[0]) <a_abRMe>_N
                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRMe>_N
                 ->_R <Bool>_R
                 :: ([a_abRMe] -> [a_abRMe] -> Bool :: *)
                    ~R# (ZipList a_abRMe -> ZipList a_abRMe -> Bool :: *)))
        ((GHC.Classes.$fOrd[]_$c> @ a_abRMe $dOrd_abRMf)
         `cast` (Sym (Control.Applicative.N:ZipList[0]) <a_abRMe>_N
                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRMe>_N
                 ->_R <Bool>_R
                 :: ([a_abRMe] -> [a_abRMe] -> Bool :: *)
                    ~R# (ZipList a_abRMe -> ZipList a_abRMe -> Bool :: *)))
        ((GHC.Classes.$fOrd[]_$c>= @ a_abRMe $dOrd_abRMf)
         `cast` (Sym (Control.Applicative.N:ZipList[0]) <a_abRMe>_N
                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRMe>_N
                 ->_R <Bool>_R
                 :: ([a_abRMe] -> [a_abRMe] -> Bool :: *)
                    ~R# (ZipList a_abRMe -> ZipList a_abRMe -> Bool :: *)))
        ((GHC.Classes.$fOrd[]_$cmax @ a_abRMe $dOrd_abRMf)
         `cast` (Sym (Control.Applicative.N:ZipList[0]) <a_abRMe>_N
                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRMe>_N
                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRMe>_N
                 :: ([a_abRMe] -> [a_abRMe] -> [a_abRMe] :: *)
                    ~R# (ZipList a_abRMe -> ZipList a_abRMe -> ZipList a_abRMe :: *)))
        ((GHC.Classes.$fOrd[]_$cmin @ a_abRMe $dOrd_abRMf)
         `cast` (Sym (Control.Applicative.N:ZipList[0]) <a_abRMe>_N
                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRMe>_N
                 ->_R Sym (Control.Applicative.N:ZipList[0]) <a_abRMe>_N
                 :: ([a_abRMe] -> [a_abRMe] -> [a_abRMe] :: *)
                    ~R# (ZipList a_abRMe -> ZipList a_abRMe -> ZipList a_abRMe :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$fShowZipList3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Applicative.$fShowZipList3 = "ZipList {"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$fShowZipList2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Control.Applicative.$fShowZipList2 = "getZipList = "#

-- RHS size: {terms: 36, types: 15, coercions: 2, joins: 0/1}
Control.Applicative.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => Int# -> ZipList a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C(U)))><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 321 120}]
Control.Applicative.$w$cshowsPrec
  = \ (@ a_sbSrN)
      (w_sbSrO :: Show a_sbSrN)
      (ww_sbSrT :: Int#)
      (w1_sbSrQ :: ZipList a_sbSrN) ->
      let {
        f_sbSll [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        f_sbSll
          = GHC.Show.showList
              @ a_sbSrN
              w_sbSrO
              (w1_sbSrQ
               `cast` (Control.Applicative.N:ZipList[0] <a_sbSrN>_N
                       :: (ZipList a_sbSrN :: *) ~R# ([a_sbSrN] :: *))) } in
      case >=# ww_sbSrT 11# of {
        __DEFAULT ->
          \ (x_X7RCw :: String) ->
            unpackAppendCString#
              Control.Applicative.$fShowZipList3
              (unpackAppendCString#
                 Control.Applicative.$fShowZipList2
                 (f_sbSll
                    (unpackAppendCString#
                       Control.Applicative.$fReadZipList4 x_X7RCw)));
        1# ->
          \ (x_i88RR :: String) ->
            GHC.Types.:
              @ Char
              GHC.Show.$fShow(,)4
              (unpackAppendCString#
                 Control.Applicative.$fShowZipList3
                 (unpackAppendCString#
                    Control.Applicative.$fShowZipList2
                    (f_sbSll
                       (unpackAppendCString#
                          Control.Applicative.$fReadZipList4
                          (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i88RR)))))
      }

-- RHS size: {terms: 11, types: 10, coercions: 0, joins: 0/0}
Control.Applicative.$fShowZipList_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => Int -> ZipList a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C(U)))><S(S),1*U(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sbSrN)
                 (w_sbSrO [Occ=Once] :: Show a_sbSrN)
                 (w1_sbSrP [Occ=Once!] :: Int)
                 (w2_sbSrQ [Occ=Once] :: ZipList a_sbSrN) ->
                 case w1_sbSrP of { I# ww1_sbSrT [Occ=Once] ->
                 Control.Applicative.$w$cshowsPrec
                   @ a_sbSrN w_sbSrO ww1_sbSrT w2_sbSrQ
                 }}]
Control.Applicative.$fShowZipList_$cshowsPrec
  = \ (@ a_sbSrN)
      (w_sbSrO :: Show a_sbSrN)
      (w1_sbSrP :: Int)
      (w2_sbSrQ :: ZipList a_sbSrN) ->
      case w1_sbSrP of { I# ww1_sbSrT ->
      Control.Applicative.$w$cshowsPrec
        @ a_sbSrN w_sbSrO ww1_sbSrT w2_sbSrQ
      }

-- RHS size: {terms: 11, types: 7, coercions: 2, joins: 0/0}
Control.Applicative.$fShowZipList_$cshow
  :: forall a. Show a => ZipList a -> String
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C1(C1(U)))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 100 0}]
Control.Applicative.$fShowZipList_$cshow
  = \ (@ a_abRLb)
      ($dShow_abRLc :: Show a_abRLb)
      (x_i7Jay :: ZipList a_abRLb) ->
      unpackAppendCString#
        Control.Applicative.$fShowZipList3
        (unpackAppendCString#
           Control.Applicative.$fShowZipList2
           (GHC.Show.showList
              @ a_abRLb
              $dShow_abRLc
              (x_i7Jay
               `cast` (Control.Applicative.N:ZipList[0] <a_abRLb>_N
                       :: (ZipList a_abRLb :: *) ~R# ([a_abRLb] :: *)))
              Control.Applicative.$fReadZipList3))

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$fShowZipList1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Applicative.$fShowZipList1 = GHC.Types.I# 0#

-- RHS size: {terms: 12, types: 13, coercions: 0, joins: 0/0}
Control.Applicative.$fShowZipList_$cshowList
  :: forall a. Show a => [ZipList a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C(U)))><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_abRLb)
                 ($dShow_abRLc [Occ=Once] :: Show a_abRLb)
                 (ls_i7JaB [Occ=Once] :: [ZipList a_abRLb])
                 (s_i7JaC [Occ=Once] :: String) ->
                 GHC.Show.showList__
                   @ (ZipList a_abRLb)
                   (Control.Applicative.$fShowZipList_$cshowsPrec
                      @ a_abRLb $dShow_abRLc Control.Applicative.$fShowZipList1)
                   ls_i7JaB
                   s_i7JaC}]
Control.Applicative.$fShowZipList_$cshowList
  = \ (@ a_abRLb)
      ($dShow_abRLc :: Show a_abRLb)
      (ls_i7JaB :: [ZipList a_abRLb])
      (s_i7JaC :: String) ->
      GHC.Show.showList__
        @ (ZipList a_abRLb)
        (\ (w_sbSrQ :: ZipList a_abRLb) ->
           Control.Applicative.$w$cshowsPrec
             @ a_abRLb $dShow_abRLc 0# w_sbSrQ)
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
Control.Applicative.$fShowZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Show a => Show (ZipList a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,C(C(U)))>m,
 Unf=DFun: \ (@ a_abRpC) (v_X41 :: Show a_abRpC) ->
       GHC.Show.C:Show TYPE: ZipList a_abRpC
                       Control.Applicative.$fShowZipList_$cshowsPrec @ a_abRpC v_X41
                       Control.Applicative.$fShowZipList_$cshow @ a_abRpC v_X41
                       Control.Applicative.$fShowZipList_$cshowList @ a_abRpC v_X41]
Control.Applicative.$fShowZipList
  = \ (@ a_abRLb) ($dShow_abRLc :: Show a_abRLb) ->
      GHC.Show.C:Show
        @ (ZipList a_abRLb)
        (Control.Applicative.$fShowZipList_$cshowsPrec
           @ a_abRLb $dShow_abRLc)
        (Control.Applicative.$fShowZipList_$cshow @ a_abRLb $dShow_abRLc)
        (Control.Applicative.$fShowZipList_$cshowList
           @ a_abRLb $dShow_abRLc)

-- RHS size: {terms: 5, types: 17, coercions: 0, joins: 0/0}
Control.Applicative.$fGeneric1WrappedArrow1
  :: forall (a1 :: * -> * -> *) b a2.
     Rep1 (WrappedArrow a1 b) a2 -> Rep1 (WrappedArrow a1 b) a2
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (a_abRKc :: * -> * -> *))
                 (@ b_abRKd)
                 (@ a1_abRKI)
                 (ds_dbScp [Occ=Once]
                    :: Rep1 (WrappedArrow a_abRKc b_abRKd) a1_abRKI) ->
                 ds_dbScp}]
Control.Applicative.$fGeneric1WrappedArrow1
  = \ (@ (a_abRKc :: * -> * -> *))
      (@ b_abRKd)
      (@ a1_abRKI)
      (ds_dbScp :: Rep1 (WrappedArrow a_abRKc b_abRKd) a1_abRKI) ->
      ds_dbScp

-- RHS size: {terms: 5, types: 14, coercions: 0, joins: 0/0}
Control.Applicative.$fGeneric1WrappedArrow2
  :: forall (a1 :: * -> * -> *) b a2.
     WrappedArrow a1 b a2 -> WrappedArrow a1 b a2
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (a_XbRPf :: * -> * -> *))
                 (@ b_XbRPh)
                 (@ a1_abRKh)
                 (x_abRE5 [Occ=Once] :: WrappedArrow a_XbRPf b_XbRPh a1_abRKh) ->
                 x_abRE5}]
Control.Applicative.$fGeneric1WrappedArrow2
  = \ (@ (a_XbRPf :: * -> * -> *))
      (@ b_XbRPh)
      (@ a1_abRKh)
      (x_abRE5 :: WrappedArrow a_XbRPf b_XbRPh a1_abRKh) ->
      x_abRE5

-- RHS size: {terms: 5, types: 17, coercions: 202, joins: 0/0}
Control.Applicative.$fGeneric1WrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b. Generic1 (WrappedArrow a b)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ (a_abRpD :: * -> * -> *)) (@ b_abRpE) ->
       GHC.Generics.C:Generic1 TYPE: *
                               TYPE: WrappedArrow a_abRpD b_abRpE
                               (Control.Applicative.$fGeneric1WrappedArrow2 @ a_abRpD @ b_abRpE)
                               `cast` (forall (a1 :: <*>_N).
                                       <WrappedArrow a_abRpD b_abRpE a1>_R
                                       ->_R (Sym (GHC.Generics.N:Rec1[0]
                                                      <*>_N
                                                      (Sym (Control.Applicative.N:WrappedArrow[0]
                                                                <a_abRpD>_R) <b_abRpE>_N)) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                       <*>_N
                                                                                                       <S>_P
                                                                                                       <'MetaSel
                                                                                                          ('Just
                                                                                                             "unwrapArrow")
                                                                                                          'NoSourceUnpackedness
                                                                                                          'NoSourceStrictness
                                                                                                          'DecidedLazy>_P
                                                                                                       <Rec1
                                                                                                          (a_abRpD b_abRpE)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                            <*>_N
                                                                                                                                            <C>_P
                                                                                                                                            <'MetaCons
                                                                                                                                               "WrapArrow"
                                                                                                                                               'PrefixI
                                                                                                                                               'True>_P
                                                                                                                                            <M1
                                                                                                                                               S
                                                                                                                                               ('MetaSel
                                                                                                                                                  ('Just
                                                                                                                                                     "unwrapArrow")
                                                                                                                                                  'NoSourceUnpackedness
                                                                                                                                                  'NoSourceStrictness
                                                                                                                                                  'DecidedLazy)
                                                                                                                                               (Rec1
                                                                                                                                                  (a_abRpD b_abRpE))>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                                                     <*>_N
                                                                                                                                                                                     <D>_P
                                                                                                                                                                                     <'MetaData
                                                                                                                                                                                        "WrappedArrow"
                                                                                                                                                                                        "Control.Applicative"
                                                                                                                                                                                        "base"
                                                                                                                                                                                        'True>_P
                                                                                                                                                                                     <M1
                                                                                                                                                                                        C
                                                                                                                                                                                        ('MetaCons
                                                                                                                                                                                           "WrapArrow"
                                                                                                                                                                                           'PrefixI
                                                                                                                                                                                           'True)
                                                                                                                                                                                        (M1
                                                                                                                                                                                           S
                                                                                                                                                                                           ('MetaSel
                                                                                                                                                                                              ('Just
                                                                                                                                                                                                 "unwrapArrow")
                                                                                                                                                                                              'NoSourceUnpackedness
                                                                                                                                                                                              'NoSourceStrictness
                                                                                                                                                                                              'DecidedLazy)
                                                                                                                                                                                           (Rec1
                                                                                                                                                                                              (a_abRpD b_abRpE)))>_R) ; Sub (Sym (Control.Applicative.Rep1_WrappedArrow[0]
                                                                                                                                                                                                                                      <a_abRpD>_N
                                                                                                                                                                                                                                      <b_abRpE>_N)))))) <a1>_N
                                       :: (forall a1.
                                           WrappedArrow a_abRpD b_abRpE a1
                                           -> WrappedArrow a_abRpD b_abRpE a1 :: *)
                                          ~R# (forall a1.
                                               WrappedArrow a_abRpD b_abRpE a1
                                               -> Rep1 (WrappedArrow a_abRpD b_abRpE) a1 :: *))
                               (Control.Applicative.$fGeneric1WrappedArrow1 @ a_abRpD @ b_abRpE)
                               `cast` (forall (a1 :: <*>_N).
                                       <Rep1 (WrappedArrow a_abRpD b_abRpE) a1>_R
                                       ->_R (Sub (Control.Applicative.Rep1_WrappedArrow[0]
                                                      <a_abRpD>_N
                                                      <b_abRpE>_N) ; (GHC.Generics.N:M1[0]
                                                                          <*>_N
                                                                          <D>_P
                                                                          <'MetaData
                                                                             "WrappedArrow"
                                                                             "Control.Applicative"
                                                                             "base"
                                                                             'True>_P
                                                                          <M1
                                                                             C
                                                                             ('MetaCons
                                                                                "WrapArrow"
                                                                                'PrefixI
                                                                                'True)
                                                                             (M1
                                                                                S
                                                                                ('MetaSel
                                                                                   ('Just
                                                                                      "unwrapArrow")
                                                                                   'NoSourceUnpackedness
                                                                                   'NoSourceStrictness
                                                                                   'DecidedLazy)
                                                                                (Rec1
                                                                                   (a_abRpD b_abRpE)))>_R ; (GHC.Generics.N:M1[0]
                                                                                                                 <*>_N
                                                                                                                 <C>_P
                                                                                                                 <'MetaCons
                                                                                                                    "WrapArrow"
                                                                                                                    'PrefixI
                                                                                                                    'True>_P
                                                                                                                 <M1
                                                                                                                    S
                                                                                                                    ('MetaSel
                                                                                                                       ('Just
                                                                                                                          "unwrapArrow")
                                                                                                                       'NoSourceUnpackedness
                                                                                                                       'NoSourceStrictness
                                                                                                                       'DecidedLazy)
                                                                                                                    (Rec1
                                                                                                                       (a_abRpD b_abRpE))>_R ; (GHC.Generics.N:M1[0]
                                                                                                                                                    <*>_N
                                                                                                                                                    <S>_P
                                                                                                                                                    <'MetaSel
                                                                                                                                                       ('Just
                                                                                                                                                          "unwrapArrow")
                                                                                                                                                       'NoSourceUnpackedness
                                                                                                                                                       'NoSourceStrictness
                                                                                                                                                       'DecidedLazy>_P
                                                                                                                                                    <Rec1
                                                                                                                                                       (a_abRpD b_abRpE)>_R ; GHC.Generics.N:Rec1[0]
                                                                                                                                                                                  <*>_N
                                                                                                                                                                                  (Sym (Control.Applicative.N:WrappedArrow[0]
                                                                                                                                                                                            <a_abRpD>_R) <b_abRpE>_N))))) <a1>_N
                                       :: (forall a1.
                                           Rep1 (WrappedArrow a_abRpD b_abRpE) a1
                                           -> Rep1 (WrappedArrow a_abRpD b_abRpE) a1 :: *)
                                          ~R# (forall a1.
                                               Rep1 (WrappedArrow a_abRpD b_abRpE) a1
                                               -> WrappedArrow a_abRpD b_abRpE a1 :: *))]
Control.Applicative.$fGeneric1WrappedArrow
  = \ (@ (a_XbRPl :: * -> * -> *)) (@ b_XbRPn) ->
      GHC.Generics.C:Generic1
        @ *
        @ (WrappedArrow a_XbRPl b_XbRPn)
        ((Control.Applicative.$fGeneric1WrappedArrow2 @ a_XbRPl @ b_XbRPn)
         `cast` (forall (a1 :: <*>_N).
                 <WrappedArrow a_XbRPl b_XbRPn a1>_R
                 ->_R (Sym (GHC.Generics.N:Rec1[0]
                                <*>_N
                                (Sym (Control.Applicative.N:WrappedArrow[0]
                                          <a_XbRPl>_R) <b_XbRPn>_N)) ; (Sym (GHC.Generics.N:M1[0]
                                                                                 <*>_N
                                                                                 <S>_P
                                                                                 <'MetaSel
                                                                                    ('Just
                                                                                       "unwrapArrow")
                                                                                    'NoSourceUnpackedness
                                                                                    'NoSourceStrictness
                                                                                    'DecidedLazy>_P
                                                                                 <Rec1
                                                                                    (a_XbRPl b_XbRPn)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                      <*>_N
                                                                                                                      <C>_P
                                                                                                                      <'MetaCons
                                                                                                                         "WrapArrow"
                                                                                                                         'PrefixI
                                                                                                                         'True>_P
                                                                                                                      <M1
                                                                                                                         S
                                                                                                                         ('MetaSel
                                                                                                                            ('Just
                                                                                                                               "unwrapArrow")
                                                                                                                            'NoSourceUnpackedness
                                                                                                                            'NoSourceStrictness
                                                                                                                            'DecidedLazy)
                                                                                                                         (Rec1
                                                                                                                            (a_XbRPl b_XbRPn))>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                               <*>_N
                                                                                                                                                               <D>_P
                                                                                                                                                               <'MetaData
                                                                                                                                                                  "WrappedArrow"
                                                                                                                                                                  "Control.Applicative"
                                                                                                                                                                  "base"
                                                                                                                                                                  'True>_P
                                                                                                                                                               <M1
                                                                                                                                                                  C
                                                                                                                                                                  ('MetaCons
                                                                                                                                                                     "WrapArrow"
                                                                                                                                                                     'PrefixI
                                                                                                                                                                     'True)
                                                                                                                                                                  (M1
                                                                                                                                                                     S
                                                                                                                                                                     ('MetaSel
                                                                                                                                                                        ('Just
                                                                                                                                                                           "unwrapArrow")
                                                                                                                                                                        'NoSourceUnpackedness
                                                                                                                                                                        'NoSourceStrictness
                                                                                                                                                                        'DecidedLazy)
                                                                                                                                                                     (Rec1
                                                                                                                                                                        (a_XbRPl b_XbRPn)))>_R) ; Sub (Sym (Control.Applicative.Rep1_WrappedArrow[0]
                                                                                                                                                                                                                <a_XbRPl>_N
                                                                                                                                                                                                                <b_XbRPn>_N)))))) <a1>_N
                 :: (forall a1.
                     WrappedArrow a_XbRPl b_XbRPn a1
                     -> WrappedArrow a_XbRPl b_XbRPn a1 :: *)
                    ~R# (forall a1.
                         WrappedArrow a_XbRPl b_XbRPn a1
                         -> Rep1 (WrappedArrow a_XbRPl b_XbRPn) a1 :: *)))
        ((Control.Applicative.$fGeneric1WrappedArrow1 @ a_XbRPl @ b_XbRPn)
         `cast` (forall (a1 :: <*>_N).
                 <Rep1 (WrappedArrow a_XbRPl b_XbRPn) a1>_R
                 ->_R (Sub (Control.Applicative.Rep1_WrappedArrow[0]
                                <a_XbRPl>_N <b_XbRPn>_N) ; (GHC.Generics.N:M1[0]
                                                                <*>_N
                                                                <D>_P
                                                                <'MetaData
                                                                   "WrappedArrow"
                                                                   "Control.Applicative"
                                                                   "base"
                                                                   'True>_P
                                                                <M1
                                                                   C
                                                                   ('MetaCons
                                                                      "WrapArrow" 'PrefixI 'True)
                                                                   (M1
                                                                      S
                                                                      ('MetaSel
                                                                         ('Just "unwrapArrow")
                                                                         'NoSourceUnpackedness
                                                                         'NoSourceStrictness
                                                                         'DecidedLazy)
                                                                      (Rec1
                                                                         (a_XbRPl b_XbRPn)))>_R ; (GHC.Generics.N:M1[0]
                                                                                                       <*>_N
                                                                                                       <C>_P
                                                                                                       <'MetaCons
                                                                                                          "WrapArrow"
                                                                                                          'PrefixI
                                                                                                          'True>_P
                                                                                                       <M1
                                                                                                          S
                                                                                                          ('MetaSel
                                                                                                             ('Just
                                                                                                                "unwrapArrow")
                                                                                                             'NoSourceUnpackedness
                                                                                                             'NoSourceStrictness
                                                                                                             'DecidedLazy)
                                                                                                          (Rec1
                                                                                                             (a_XbRPl b_XbRPn))>_R ; (GHC.Generics.N:M1[0]
                                                                                                                                          <*>_N
                                                                                                                                          <S>_P
                                                                                                                                          <'MetaSel
                                                                                                                                             ('Just
                                                                                                                                                "unwrapArrow")
                                                                                                                                             'NoSourceUnpackedness
                                                                                                                                             'NoSourceStrictness
                                                                                                                                             'DecidedLazy>_P
                                                                                                                                          <Rec1
                                                                                                                                             (a_XbRPl b_XbRPn)>_R ; GHC.Generics.N:Rec1[0]
                                                                                                                                                                        <*>_N
                                                                                                                                                                        (Sym (Control.Applicative.N:WrappedArrow[0]
                                                                                                                                                                                  <a_XbRPl>_R) <b_XbRPn>_N))))) <a1>_N
                 :: (forall a1.
                     Rep1 (WrappedArrow a_XbRPl b_XbRPn) a1
                     -> Rep1 (WrappedArrow a_XbRPl b_XbRPn) a1 :: *)
                    ~R# (forall a1.
                         Rep1 (WrappedArrow a_XbRPl b_XbRPn) a1
                         -> WrappedArrow a_XbRPl b_XbRPn a1 :: *)))

-- RHS size: {terms: 6, types: 17, coercions: 0, joins: 0/0}
Control.Applicative.$fGenericWrappedArrow1
  :: forall (a :: * -> * -> *) b c x.
     Rep (WrappedArrow a b c) x -> Rep (WrappedArrow a b c) x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (a_abRJa :: * -> * -> *))
                 (@ b_abRJb)
                 (@ c_abRJc)
                 (@ x_abRJI)
                 (ds_dbScj [Occ=Once]
                    :: Rep (WrappedArrow a_abRJa b_abRJb c_abRJc) x_abRJI) ->
                 ds_dbScj}]
Control.Applicative.$fGenericWrappedArrow1
  = \ (@ (a_abRJa :: * -> * -> *))
      (@ b_abRJb)
      (@ c_abRJc)
      (@ x_abRJI)
      (ds_dbScj :: Rep (WrappedArrow a_abRJa b_abRJb c_abRJc) x_abRJI) ->
      ds_dbScj

-- RHS size: {terms: 6, types: 15, coercions: 0, joins: 0/0}
Control.Applicative.$fGenericWrappedArrow2
  :: forall (a :: * -> * -> *) b c x.
     WrappedArrow a b c -> WrappedArrow a b c
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (a_XbROr :: * -> * -> *))
                 (@ b_XbROt)
                 (@ c_XbROv)
                 (@ x_abRJg)
                 (x1_abRE1 [Occ=Once] :: WrappedArrow a_XbROr b_XbROt c_XbROv) ->
                 x1_abRE1}]
Control.Applicative.$fGenericWrappedArrow2
  = \ (@ (a_XbROr :: * -> * -> *))
      (@ b_XbROt)
      (@ c_XbROv)
      (@ x_abRJg)
      (x1_abRE1 :: WrappedArrow a_XbROr b_XbROt c_XbROv) ->
      x1_abRE1

-- RHS size: {terms: 6, types: 20, coercions: 226, joins: 0/0}
Control.Applicative.$fGenericWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b c. Generic (WrappedArrow a b c)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ (a_abRpD :: * -> * -> *)) (@ b_abRpE) (@ c_abRpF) ->
       GHC.Generics.C:Generic TYPE: WrappedArrow a_abRpD b_abRpE c_abRpF
                              (Control.Applicative.$fGenericWrappedArrow2
                                 @ a_abRpD @ b_abRpE @ c_abRpF)
                              `cast` (forall (x :: <*>_N).
                                      <WrappedArrow a_abRpD b_abRpE c_abRpF>_R
                                      ->_R Control.Applicative.N:WrappedArrow[0]
                                               <a_abRpD>_R <b_abRpE>_N <c_abRpF>_N ; (Sym (GHC.Generics.N:K1[0]
                                                                                               <*>_N
                                                                                               <R>_P
                                                                                               <a_abRpD b_abRpE c_abRpF>_R
                                                                                               <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                  <*>_N
                                                                                                                  <S>_P
                                                                                                                  <'MetaSel
                                                                                                                     ('Just
                                                                                                                        "unwrapArrow")
                                                                                                                     'NoSourceUnpackedness
                                                                                                                     'NoSourceStrictness
                                                                                                                     'DecidedLazy>_P
                                                                                                                  <K1
                                                                                                                     R
                                                                                                                     (a_abRpD b_abRpE c_abRpF)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                               <*>_N
                                                                                                                                                               <C>_P
                                                                                                                                                               <'MetaCons
                                                                                                                                                                  "WrapArrow"
                                                                                                                                                                  'PrefixI
                                                                                                                                                                  'True>_P
                                                                                                                                                               <M1
                                                                                                                                                                  S
                                                                                                                                                                  ('MetaSel
                                                                                                                                                                     ('Just
                                                                                                                                                                        "unwrapArrow")
                                                                                                                                                                     'NoSourceUnpackedness
                                                                                                                                                                     'NoSourceStrictness
                                                                                                                                                                     'DecidedLazy)
                                                                                                                                                                  (K1
                                                                                                                                                                     R
                                                                                                                                                                     (a_abRpD b_abRpE c_abRpF))>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                                                                                <*>_N
                                                                                                                                                                                                                <D>_P
                                                                                                                                                                                                                <'MetaData
                                                                                                                                                                                                                   "WrappedArrow"
                                                                                                                                                                                                                   "Control.Applicative"
                                                                                                                                                                                                                   "base"
                                                                                                                                                                                                                   'True>_P
                                                                                                                                                                                                                <M1
                                                                                                                                                                                                                   C
                                                                                                                                                                                                                   ('MetaCons
                                                                                                                                                                                                                      "WrapArrow"
                                                                                                                                                                                                                      'PrefixI
                                                                                                                                                                                                                      'True)
                                                                                                                                                                                                                   (M1
                                                                                                                                                                                                                      S
                                                                                                                                                                                                                      ('MetaSel
                                                                                                                                                                                                                         ('Just
                                                                                                                                                                                                                            "unwrapArrow")
                                                                                                                                                                                                                         'NoSourceUnpackedness
                                                                                                                                                                                                                         'NoSourceStrictness
                                                                                                                                                                                                                         'DecidedLazy)
                                                                                                                                                                                                                      (K1
                                                                                                                                                                                                                         R
                                                                                                                                                                                                                         (a_abRpD b_abRpE c_abRpF)))>_R) ; Sub (Sym (Control.Applicative.Rep_WrappedArrow[0]
                                                                                                                                                                                                                                                                         <a_abRpD>_N
                                                                                                                                                                                                                                                                         <b_abRpE>_N
                                                                                                                                                                                                                                                                         <c_abRpF>_N))))) <x>_N)
                                      :: (forall x.
                                          WrappedArrow a_abRpD b_abRpE c_abRpF
                                          -> WrappedArrow a_abRpD b_abRpE c_abRpF :: *)
                                         ~R# (forall x.
                                              WrappedArrow a_abRpD b_abRpE c_abRpF
                                              -> Rep (WrappedArrow a_abRpD b_abRpE c_abRpF) x :: *))
                              (Control.Applicative.$fGenericWrappedArrow1
                                 @ a_abRpD @ b_abRpE @ c_abRpF)
                              `cast` (forall (x :: <*>_N).
                                      <Rep (WrappedArrow a_abRpD b_abRpE c_abRpF) x>_R
                                      ->_R (Sub (Control.Applicative.Rep_WrappedArrow[0]
                                                     <a_abRpD>_N
                                                     <b_abRpE>_N
                                                     <c_abRpF>_N) ; (GHC.Generics.N:M1[0]
                                                                         <*>_N
                                                                         <D>_P
                                                                         <'MetaData
                                                                            "WrappedArrow"
                                                                            "Control.Applicative"
                                                                            "base"
                                                                            'True>_P
                                                                         <M1
                                                                            C
                                                                            ('MetaCons
                                                                               "WrapArrow"
                                                                               'PrefixI
                                                                               'True)
                                                                            (M1
                                                                               S
                                                                               ('MetaSel
                                                                                  ('Just
                                                                                     "unwrapArrow")
                                                                                  'NoSourceUnpackedness
                                                                                  'NoSourceStrictness
                                                                                  'DecidedLazy)
                                                                               (K1
                                                                                  R
                                                                                  (a_abRpD b_abRpE c_abRpF)))>_R ; (GHC.Generics.N:M1[0]
                                                                                                                        <*>_N
                                                                                                                        <C>_P
                                                                                                                        <'MetaCons
                                                                                                                           "WrapArrow"
                                                                                                                           'PrefixI
                                                                                                                           'True>_P
                                                                                                                        <M1
                                                                                                                           S
                                                                                                                           ('MetaSel
                                                                                                                              ('Just
                                                                                                                                 "unwrapArrow")
                                                                                                                              'NoSourceUnpackedness
                                                                                                                              'NoSourceStrictness
                                                                                                                              'DecidedLazy)
                                                                                                                           (K1
                                                                                                                              R
                                                                                                                              (a_abRpD b_abRpE c_abRpF))>_R ; GHC.Generics.N:M1[0]
                                                                                                                                                                  <*>_N
                                                                                                                                                                  <S>_P
                                                                                                                                                                  <'MetaSel
                                                                                                                                                                     ('Just
                                                                                                                                                                        "unwrapArrow")
                                                                                                                                                                     'NoSourceUnpackedness
                                                                                                                                                                     'NoSourceStrictness
                                                                                                                                                                     'DecidedLazy>_P
                                                                                                                                                                  <K1
                                                                                                                                                                     R
                                                                                                                                                                     (a_abRpD b_abRpE c_abRpF)>_R))) <x>_N ; (GHC.Generics.N:K1[0]
                                                                                                                                                                                                                  <*>_N
                                                                                                                                                                                                                  <R>_P
                                                                                                                                                                                                                  <a_abRpD b_abRpE c_abRpF>_R
                                                                                                                                                                                                                  <x>_P ; Sym (Control.Applicative.N:WrappedArrow[0]
                                                                                                                                                                                                                                   <a_abRpD>_R) <b_abRpE>_N <c_abRpF>_N)
                                      :: (forall x.
                                          Rep (WrappedArrow a_abRpD b_abRpE c_abRpF) x
                                          -> Rep (WrappedArrow a_abRpD b_abRpE c_abRpF) x :: *)
                                         ~R# (forall x.
                                              Rep (WrappedArrow a_abRpD b_abRpE c_abRpF) x
                                              -> WrappedArrow a_abRpD b_abRpE c_abRpF :: *))]
Control.Applicative.$fGenericWrappedArrow
  = \ (@ (a_XbROy :: * -> * -> *)) (@ b_XbROA) (@ c_XbROC) ->
      GHC.Generics.C:Generic
        @ (WrappedArrow a_XbROy b_XbROA c_XbROC)
        ((Control.Applicative.$fGenericWrappedArrow2
            @ a_XbROy @ b_XbROA @ c_XbROC)
         `cast` (forall (x :: <*>_N).
                 <WrappedArrow a_XbROy b_XbROA c_XbROC>_R
                 ->_R Control.Applicative.N:WrappedArrow[0]
                          <a_XbROy>_R <b_XbROA>_N <c_XbROC>_N ; (Sym (GHC.Generics.N:K1[0]
                                                                          <*>_N
                                                                          <R>_P
                                                                          <a_XbROy b_XbROA c_XbROC>_R
                                                                          <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                             <*>_N
                                                                                             <S>_P
                                                                                             <'MetaSel
                                                                                                ('Just
                                                                                                   "unwrapArrow")
                                                                                                'NoSourceUnpackedness
                                                                                                'NoSourceStrictness
                                                                                                'DecidedLazy>_P
                                                                                             <K1
                                                                                                R
                                                                                                (a_XbROy b_XbROA c_XbROC)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                          <*>_N
                                                                                                                                          <C>_P
                                                                                                                                          <'MetaCons
                                                                                                                                             "WrapArrow"
                                                                                                                                             'PrefixI
                                                                                                                                             'True>_P
                                                                                                                                          <M1
                                                                                                                                             S
                                                                                                                                             ('MetaSel
                                                                                                                                                ('Just
                                                                                                                                                   "unwrapArrow")
                                                                                                                                                'NoSourceUnpackedness
                                                                                                                                                'NoSourceStrictness
                                                                                                                                                'DecidedLazy)
                                                                                                                                             (K1
                                                                                                                                                R
                                                                                                                                                (a_XbROy b_XbROA c_XbROC))>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                                                           <*>_N
                                                                                                                                                                                           <D>_P
                                                                                                                                                                                           <'MetaData
                                                                                                                                                                                              "WrappedArrow"
                                                                                                                                                                                              "Control.Applicative"
                                                                                                                                                                                              "base"
                                                                                                                                                                                              'True>_P
                                                                                                                                                                                           <M1
                                                                                                                                                                                              C
                                                                                                                                                                                              ('MetaCons
                                                                                                                                                                                                 "WrapArrow"
                                                                                                                                                                                                 'PrefixI
                                                                                                                                                                                                 'True)
                                                                                                                                                                                              (M1
                                                                                                                                                                                                 S
                                                                                                                                                                                                 ('MetaSel
                                                                                                                                                                                                    ('Just
                                                                                                                                                                                                       "unwrapArrow")
                                                                                                                                                                                                    'NoSourceUnpackedness
                                                                                                                                                                                                    'NoSourceStrictness
                                                                                                                                                                                                    'DecidedLazy)
                                                                                                                                                                                                 (K1
                                                                                                                                                                                                    R
                                                                                                                                                                                                    (a_XbROy b_XbROA c_XbROC)))>_R) ; Sub (Sym (Control.Applicative.Rep_WrappedArrow[0]
                                                                                                                                                                                                                                                    <a_XbROy>_N
                                                                                                                                                                                                                                                    <b_XbROA>_N
                                                                                                                                                                                                                                                    <c_XbROC>_N))))) <x>_N)
                 :: (forall x.
                     WrappedArrow a_XbROy b_XbROA c_XbROC
                     -> WrappedArrow a_XbROy b_XbROA c_XbROC :: *)
                    ~R# (forall x.
                         WrappedArrow a_XbROy b_XbROA c_XbROC
                         -> Rep (WrappedArrow a_XbROy b_XbROA c_XbROC) x :: *)))
        ((Control.Applicative.$fGenericWrappedArrow1
            @ a_XbROy @ b_XbROA @ c_XbROC)
         `cast` (forall (x :: <*>_N).
                 <Rep (WrappedArrow a_XbROy b_XbROA c_XbROC) x>_R
                 ->_R (Sub (Control.Applicative.Rep_WrappedArrow[0]
                                <a_XbROy>_N <b_XbROA>_N <c_XbROC>_N) ; (GHC.Generics.N:M1[0]
                                                                            <*>_N
                                                                            <D>_P
                                                                            <'MetaData
                                                                               "WrappedArrow"
                                                                               "Control.Applicative"
                                                                               "base"
                                                                               'True>_P
                                                                            <M1
                                                                               C
                                                                               ('MetaCons
                                                                                  "WrapArrow"
                                                                                  'PrefixI
                                                                                  'True)
                                                                               (M1
                                                                                  S
                                                                                  ('MetaSel
                                                                                     ('Just
                                                                                        "unwrapArrow")
                                                                                     'NoSourceUnpackedness
                                                                                     'NoSourceStrictness
                                                                                     'DecidedLazy)
                                                                                  (K1
                                                                                     R
                                                                                     (a_XbROy b_XbROA c_XbROC)))>_R ; (GHC.Generics.N:M1[0]
                                                                                                                           <*>_N
                                                                                                                           <C>_P
                                                                                                                           <'MetaCons
                                                                                                                              "WrapArrow"
                                                                                                                              'PrefixI
                                                                                                                              'True>_P
                                                                                                                           <M1
                                                                                                                              S
                                                                                                                              ('MetaSel
                                                                                                                                 ('Just
                                                                                                                                    "unwrapArrow")
                                                                                                                                 'NoSourceUnpackedness
                                                                                                                                 'NoSourceStrictness
                                                                                                                                 'DecidedLazy)
                                                                                                                              (K1
                                                                                                                                 R
                                                                                                                                 (a_XbROy b_XbROA c_XbROC))>_R ; GHC.Generics.N:M1[0]
                                                                                                                                                                     <*>_N
                                                                                                                                                                     <S>_P
                                                                                                                                                                     <'MetaSel
                                                                                                                                                                        ('Just
                                                                                                                                                                           "unwrapArrow")
                                                                                                                                                                        'NoSourceUnpackedness
                                                                                                                                                                        'NoSourceStrictness
                                                                                                                                                                        'DecidedLazy>_P
                                                                                                                                                                     <K1
                                                                                                                                                                        R
                                                                                                                                                                        (a_XbROy b_XbROA c_XbROC)>_R))) <x>_N ; (GHC.Generics.N:K1[0]
                                                                                                                                                                                                                     <*>_N
                                                                                                                                                                                                                     <R>_P
                                                                                                                                                                                                                     <a_XbROy b_XbROA c_XbROC>_R
                                                                                                                                                                                                                     <x>_P ; Sym (Control.Applicative.N:WrappedArrow[0]
                                                                                                                                                                                                                                      <a_XbROy>_R) <b_XbROA>_N <c_XbROC>_N)
                 :: (forall x.
                     Rep (WrappedArrow a_XbROy b_XbROA c_XbROC) x
                     -> Rep (WrappedArrow a_XbROy b_XbROA c_XbROC) x :: *)
                    ~R# (forall x.
                         Rep (WrappedArrow a_XbROy b_XbROA c_XbROC) x
                         -> WrappedArrow a_XbROy b_XbROA c_XbROC :: *)))

-- RHS size: {terms: 13, types: 13, coercions: 61, joins: 0/0}
Control.Applicative.$fMonadWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *). Monad m => Monad (WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(U),A,A,A,A),U,1*U,U,1*U)>m,
 Unf=DFun: \ (@ (m_abRpG :: * -> *)) (v_X48 :: Monad m_abRpG) ->
       GHC.Base.C:Monad TYPE: WrappedMonad m_abRpG
                        Control.Applicative.$fApplicativeWrappedMonad @ m_abRpG v_X48
                        (>>= @ m_abRpG v_X48)
                        `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                Sym (Control.Applicative.N:WrappedMonad[0] <m_abRpG>_R) <a>_N
                                ->_R (<a>_R
                                      ->_R Sym (Control.Applicative.N:WrappedMonad[0]
                                                    <m_abRpG>_R) <b>_N)
                                ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_abRpG>_R) <b>_N
                                :: (forall a b. m_abRpG a -> (a -> m_abRpG b) -> m_abRpG b :: *)
                                   ~R# (forall a b.
                                        WrappedMonad m_abRpG a
                                        -> (a -> WrappedMonad m_abRpG b)
                                        -> WrappedMonad m_abRpG b :: *))
                        (>> @ m_abRpG v_X48)
                        `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                Sym (Control.Applicative.N:WrappedMonad[0] <m_abRpG>_R) <a>_N
                                ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_abRpG>_R) <b>_N
                                ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_abRpG>_R) <b>_N
                                :: (forall a b. m_abRpG a -> m_abRpG b -> m_abRpG b :: *)
                                   ~R# (forall a b.
                                        WrappedMonad m_abRpG a
                                        -> WrappedMonad m_abRpG b -> WrappedMonad m_abRpG b :: *))
                        (return @ m_abRpG v_X48)
                        `cast` (forall (a :: <*>_N).
                                <a>_R
                                ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_abRpG>_R) <a>_N
                                :: (forall a. a -> m_abRpG a :: *)
                                   ~R# (forall a. a -> WrappedMonad m_abRpG a :: *))
                        (fail @ m_abRpG v_X48)
                        `cast` (forall (a :: <*>_N).
                                <[Char]>_R
                                ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_abRpG>_R) <a>_N
                                :: (forall a. [Char] -> m_abRpG a :: *)
                                   ~R# (forall a. [Char] -> WrappedMonad m_abRpG a :: *))]
Control.Applicative.$fMonadWrappedMonad
  = \ (@ (m_abRHy :: * -> *)) ($dMonad_abRHz :: Monad m_abRHy) ->
      GHC.Base.C:Monad
        @ (WrappedMonad m_abRHy)
        (Control.Applicative.$fApplicativeWrappedMonad
           @ m_abRHy $dMonad_abRHz)
        ((>>= @ m_abRHy $dMonad_abRHz)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 Sym (Control.Applicative.N:WrappedMonad[0] <m_abRHy>_R) <a>_N
                 ->_R (<a>_R
                       ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_abRHy>_R) <b>_N)
                 ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_abRHy>_R) <b>_N
                 :: (forall a b. m_abRHy a -> (a -> m_abRHy b) -> m_abRHy b :: *)
                    ~R# (forall a b.
                         WrappedMonad m_abRHy a
                         -> (a -> WrappedMonad m_abRHy b) -> WrappedMonad m_abRHy b :: *)))
        ((>> @ m_abRHy $dMonad_abRHz)
         `cast` (forall (a :: <*>_N) (b :: <*>_N).
                 Sym (Control.Applicative.N:WrappedMonad[0] <m_abRHy>_R) <a>_N
                 ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_abRHy>_R) <b>_N
                 ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_abRHy>_R) <b>_N
                 :: (forall a b. m_abRHy a -> m_abRHy b -> m_abRHy b :: *)
                    ~R# (forall a b.
                         WrappedMonad m_abRHy a
                         -> WrappedMonad m_abRHy b -> WrappedMonad m_abRHy b :: *)))
        ((return @ m_abRHy $dMonad_abRHz)
         `cast` (forall (a :: <*>_N).
                 <a>_R
                 ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_abRHy>_R) <a>_N
                 :: (forall a. a -> m_abRHy a :: *)
                    ~R# (forall a. a -> WrappedMonad m_abRHy a :: *)))
        ((fail @ m_abRHy $dMonad_abRHz)
         `cast` (forall (a :: <*>_N).
                 <[Char]>_R
                 ->_R Sym (Control.Applicative.N:WrappedMonad[0] <m_abRHy>_R) <a>_N
                 :: (forall a. [Char] -> m_abRHy a :: *)
                    ~R# (forall a. [Char] -> WrappedMonad m_abRHy a :: *)))

-- RHS size: {terms: 4, types: 12, coercions: 0, joins: 0/0}
Control.Applicative.$fGeneric1WrappedMonad1
  :: forall (m :: * -> *) a.
     Rep1 (WrappedMonad m) a -> Rep1 (WrappedMonad m) a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_abRGB :: * -> *))
                 (@ a_abRH6)
                 (ds_dbSce [Occ=Once] :: Rep1 (WrappedMonad m_abRGB) a_abRH6) ->
                 ds_dbSce}]
Control.Applicative.$fGeneric1WrappedMonad1
  = \ (@ (m_abRGB :: * -> *))
      (@ a_abRH6)
      (ds_dbSce :: Rep1 (WrappedMonad m_abRGB) a_abRH6) ->
      ds_dbSce

-- RHS size: {terms: 4, types: 9, coercions: 0, joins: 0/0}
Control.Applicative.$fGeneric1WrappedMonad2
  :: forall (m :: * -> *) a. WrappedMonad m a -> WrappedMonad m a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_XbRMa :: * -> *))
                 (@ a_abRGF)
                 (x_abRDX [Occ=Once] :: WrappedMonad m_XbRMa a_abRGF) ->
                 x_abRDX}]
Control.Applicative.$fGeneric1WrappedMonad2
  = \ (@ (m_XbRMa :: * -> *))
      (@ a_abRGF)
      (x_abRDX :: WrappedMonad m_XbRMa a_abRGF) ->
      x_abRDX

-- RHS size: {terms: 4, types: 10, coercions: 189, joins: 0/0}
Control.Applicative.$fGeneric1WrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *). Generic1 (WrappedMonad m)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ (m_abRpG :: * -> *)) ->
       GHC.Generics.C:Generic1 TYPE: *
                               TYPE: WrappedMonad m_abRpG
                               (Control.Applicative.$fGeneric1WrappedMonad2 @ m_abRpG)
                               `cast` (forall (a :: <*>_N).
                                       <WrappedMonad m_abRpG a>_R
                                       ->_R Control.Applicative.N:WrappedMonad[0]
                                                (Sym (GHC.Generics.N:Rec1[0]
                                                          <*>_N
                                                          <m_abRpG>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                   <*>_N
                                                                                   <S>_P
                                                                                   <'MetaSel
                                                                                      ('Just
                                                                                         "unwrapMonad")
                                                                                      'NoSourceUnpackedness
                                                                                      'NoSourceStrictness
                                                                                      'DecidedLazy>_P
                                                                                   <Rec1
                                                                                      m_abRpG>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                              <*>_N
                                                                                                              <C>_P
                                                                                                              <'MetaCons
                                                                                                                 "WrapMonad"
                                                                                                                 'PrefixI
                                                                                                                 'True>_P
                                                                                                              <M1
                                                                                                                 S
                                                                                                                 ('MetaSel
                                                                                                                    ('Just
                                                                                                                       "unwrapMonad")
                                                                                                                    'NoSourceUnpackedness
                                                                                                                    'NoSourceStrictness
                                                                                                                    'DecidedLazy)
                                                                                                                 (Rec1
                                                                                                                    m_abRpG)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                             <*>_N
                                                                                                                                             <D>_P
                                                                                                                                             <'MetaData
                                                                                                                                                "WrappedMonad"
                                                                                                                                                "Control.Applicative"
                                                                                                                                                "base"
                                                                                                                                                'True>_P
                                                                                                                                             <M1
                                                                                                                                                C
                                                                                                                                                ('MetaCons
                                                                                                                                                   "WrapMonad"
                                                                                                                                                   'PrefixI
                                                                                                                                                   'True)
                                                                                                                                                (M1
                                                                                                                                                   S
                                                                                                                                                   ('MetaSel
                                                                                                                                                      ('Just
                                                                                                                                                         "unwrapMonad")
                                                                                                                                                      'NoSourceUnpackedness
                                                                                                                                                      'NoSourceStrictness
                                                                                                                                                      'DecidedLazy)
                                                                                                                                                   (Rec1
                                                                                                                                                      m_abRpG))>_R) ; Sub (Sym (Control.Applicative.Rep1_WrappedMonad[0]
                                                                                                                                                                                    <m_abRpG>_N)))))) <a>_N
                                       :: (forall a.
                                           WrappedMonad m_abRpG a -> WrappedMonad m_abRpG a :: *)
                                          ~R# (forall a.
                                               WrappedMonad m_abRpG a
                                               -> Rep1 (WrappedMonad m_abRpG) a :: *))
                               (Control.Applicative.$fGeneric1WrappedMonad1 @ m_abRpG)
                               `cast` (forall (a :: <*>_N).
                                       <Rep1 (WrappedMonad m_abRpG) a>_R
                                       ->_R (Sub (Control.Applicative.Rep1_WrappedMonad[0]
                                                      <m_abRpG>_N) ; (GHC.Generics.N:M1[0]
                                                                          <*>_N
                                                                          <D>_P
                                                                          <'MetaData
                                                                             "WrappedMonad"
                                                                             "Control.Applicative"
                                                                             "base"
                                                                             'True>_P
                                                                          <M1
                                                                             C
                                                                             ('MetaCons
                                                                                "WrapMonad"
                                                                                'PrefixI
                                                                                'True)
                                                                             (M1
                                                                                S
                                                                                ('MetaSel
                                                                                   ('Just
                                                                                      "unwrapMonad")
                                                                                   'NoSourceUnpackedness
                                                                                   'NoSourceStrictness
                                                                                   'DecidedLazy)
                                                                                (Rec1
                                                                                   m_abRpG))>_R ; (GHC.Generics.N:M1[0]
                                                                                                       <*>_N
                                                                                                       <C>_P
                                                                                                       <'MetaCons
                                                                                                          "WrapMonad"
                                                                                                          'PrefixI
                                                                                                          'True>_P
                                                                                                       <M1
                                                                                                          S
                                                                                                          ('MetaSel
                                                                                                             ('Just
                                                                                                                "unwrapMonad")
                                                                                                             'NoSourceUnpackedness
                                                                                                             'NoSourceStrictness
                                                                                                             'DecidedLazy)
                                                                                                          (Rec1
                                                                                                             m_abRpG)>_R ; (GHC.Generics.N:M1[0]
                                                                                                                                <*>_N
                                                                                                                                <S>_P
                                                                                                                                <'MetaSel
                                                                                                                                   ('Just
                                                                                                                                      "unwrapMonad")
                                                                                                                                   'NoSourceUnpackedness
                                                                                                                                   'NoSourceStrictness
                                                                                                                                   'DecidedLazy>_P
                                                                                                                                <Rec1
                                                                                                                                   m_abRpG>_R ; GHC.Generics.N:Rec1[0]
                                                                                                                                                    <*>_N
                                                                                                                                                    (Sym (Control.Applicative.N:WrappedMonad[0]
                                                                                                                                                              <m_abRpG>_R)))))) <a>_N
                                       :: (forall a.
                                           Rep1 (WrappedMonad m_abRpG) a
                                           -> Rep1 (WrappedMonad m_abRpG) a :: *)
                                          ~R# (forall a.
                                               Rep1 (WrappedMonad m_abRpG) a
                                               -> WrappedMonad m_abRpG a :: *))]
Control.Applicative.$fGeneric1WrappedMonad
  = \ (@ (m_XbRMf :: * -> *)) ->
      GHC.Generics.C:Generic1
        @ *
        @ (WrappedMonad m_XbRMf)
        ((Control.Applicative.$fGeneric1WrappedMonad2 @ m_XbRMf)
         `cast` (forall (a :: <*>_N).
                 <WrappedMonad m_XbRMf a>_R
                 ->_R Control.Applicative.N:WrappedMonad[0]
                          (Sym (GHC.Generics.N:Rec1[0]
                                    <*>_N <m_XbRMf>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                   <*>_N
                                                                   <S>_P
                                                                   <'MetaSel
                                                                      ('Just "unwrapMonad")
                                                                      'NoSourceUnpackedness
                                                                      'NoSourceStrictness
                                                                      'DecidedLazy>_P
                                                                   <Rec1
                                                                      m_XbRMf>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                              <*>_N
                                                                                              <C>_P
                                                                                              <'MetaCons
                                                                                                 "WrapMonad"
                                                                                                 'PrefixI
                                                                                                 'True>_P
                                                                                              <M1
                                                                                                 S
                                                                                                 ('MetaSel
                                                                                                    ('Just
                                                                                                       "unwrapMonad")
                                                                                                    'NoSourceUnpackedness
                                                                                                    'NoSourceStrictness
                                                                                                    'DecidedLazy)
                                                                                                 (Rec1
                                                                                                    m_XbRMf)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                             <*>_N
                                                                                                                             <D>_P
                                                                                                                             <'MetaData
                                                                                                                                "WrappedMonad"
                                                                                                                                "Control.Applicative"
                                                                                                                                "base"
                                                                                                                                'True>_P
                                                                                                                             <M1
                                                                                                                                C
                                                                                                                                ('MetaCons
                                                                                                                                   "WrapMonad"
                                                                                                                                   'PrefixI
                                                                                                                                   'True)
                                                                                                                                (M1
                                                                                                                                   S
                                                                                                                                   ('MetaSel
                                                                                                                                      ('Just
                                                                                                                                         "unwrapMonad")
                                                                                                                                      'NoSourceUnpackedness
                                                                                                                                      'NoSourceStrictness
                                                                                                                                      'DecidedLazy)
                                                                                                                                   (Rec1
                                                                                                                                      m_XbRMf))>_R) ; Sub (Sym (Control.Applicative.Rep1_WrappedMonad[0]
                                                                                                                                                                    <m_XbRMf>_N)))))) <a>_N
                 :: (forall a.
                     WrappedMonad m_XbRMf a -> WrappedMonad m_XbRMf a :: *)
                    ~R# (forall a.
                         WrappedMonad m_XbRMf a -> Rep1 (WrappedMonad m_XbRMf) a :: *)))
        ((Control.Applicative.$fGeneric1WrappedMonad1 @ m_XbRMf)
         `cast` (forall (a :: <*>_N).
                 <Rep1 (WrappedMonad m_XbRMf) a>_R
                 ->_R (Sub (Control.Applicative.Rep1_WrappedMonad[0]
                                <m_XbRMf>_N) ; (GHC.Generics.N:M1[0]
                                                    <*>_N
                                                    <D>_P
                                                    <'MetaData
                                                       "WrappedMonad"
                                                       "Control.Applicative"
                                                       "base"
                                                       'True>_P
                                                    <M1
                                                       C
                                                       ('MetaCons "WrapMonad" 'PrefixI 'True)
                                                       (M1
                                                          S
                                                          ('MetaSel
                                                             ('Just "unwrapMonad")
                                                             'NoSourceUnpackedness
                                                             'NoSourceStrictness
                                                             'DecidedLazy)
                                                          (Rec1 m_XbRMf))>_R ; (GHC.Generics.N:M1[0]
                                                                                    <*>_N
                                                                                    <C>_P
                                                                                    <'MetaCons
                                                                                       "WrapMonad"
                                                                                       'PrefixI
                                                                                       'True>_P
                                                                                    <M1
                                                                                       S
                                                                                       ('MetaSel
                                                                                          ('Just
                                                                                             "unwrapMonad")
                                                                                          'NoSourceUnpackedness
                                                                                          'NoSourceStrictness
                                                                                          'DecidedLazy)
                                                                                       (Rec1
                                                                                          m_XbRMf)>_R ; (GHC.Generics.N:M1[0]
                                                                                                             <*>_N
                                                                                                             <S>_P
                                                                                                             <'MetaSel
                                                                                                                ('Just
                                                                                                                   "unwrapMonad")
                                                                                                                'NoSourceUnpackedness
                                                                                                                'NoSourceStrictness
                                                                                                                'DecidedLazy>_P
                                                                                                             <Rec1
                                                                                                                m_XbRMf>_R ; GHC.Generics.N:Rec1[0]
                                                                                                                                 <*>_N
                                                                                                                                 (Sym (Control.Applicative.N:WrappedMonad[0]
                                                                                                                                           <m_XbRMf>_R)))))) <a>_N
                 :: (forall a.
                     Rep1 (WrappedMonad m_XbRMf) a
                     -> Rep1 (WrappedMonad m_XbRMf) a :: *)
                    ~R# (forall a.
                         Rep1 (WrappedMonad m_XbRMf) a -> WrappedMonad m_XbRMf a :: *)))

-- RHS size: {terms: 5, types: 12, coercions: 0, joins: 0/0}
Control.Applicative.$fGenericWrappedMonad1
  :: forall (m :: * -> *) a x.
     Rep (WrappedMonad m a) x -> Rep (WrappedMonad m a) x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_abRFB :: * -> *))
                 (@ a_abRFC)
                 (@ x_abRG8)
                 (ds_dbSc8 [Occ=Once]
                    :: Rep (WrappedMonad m_abRFB a_abRFC) x_abRG8) ->
                 ds_dbSc8}]
Control.Applicative.$fGenericWrappedMonad1
  = \ (@ (m_abRFB :: * -> *))
      (@ a_abRFC)
      (@ x_abRG8)
      (ds_dbSc8 :: Rep (WrappedMonad m_abRFB a_abRFC) x_abRG8) ->
      ds_dbSc8

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Control.Applicative.$fGenericWrappedMonad2
  :: forall (m :: * -> *) a x. WrappedMonad m a -> WrappedMonad m a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_XbRLm :: * -> *))
                 (@ a_XbRLo)
                 (@ x_abRFG)
                 (x1_abRDT [Occ=Once] :: WrappedMonad m_XbRLm a_XbRLo) ->
                 x1_abRDT}]
Control.Applicative.$fGenericWrappedMonad2
  = \ (@ (m_XbRLm :: * -> *))
      (@ a_XbRLo)
      (@ x_abRFG)
      (x1_abRDT :: WrappedMonad m_XbRLm a_XbRLo) ->
      x1_abRDT

-- RHS size: {terms: 5, types: 13, coercions: 212, joins: 0/0}
Control.Applicative.$fGenericWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *) a. Generic (WrappedMonad m a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ (m_abRpG :: * -> *)) (@ a_abRpH) ->
       GHC.Generics.C:Generic TYPE: WrappedMonad m_abRpG a_abRpH
                              (Control.Applicative.$fGenericWrappedMonad2 @ m_abRpG @ a_abRpH)
                              `cast` (forall (x :: <*>_N).
                                      <WrappedMonad m_abRpG a_abRpH>_R
                                      ->_R Control.Applicative.N:WrappedMonad[0]
                                               <m_abRpG>_R <a_abRpH>_N ; (Sym (GHC.Generics.N:K1[0]
                                                                                   <*>_N
                                                                                   <R>_P
                                                                                   <m_abRpG a_abRpH>_R
                                                                                   <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                      <*>_N
                                                                                                      <S>_P
                                                                                                      <'MetaSel
                                                                                                         ('Just
                                                                                                            "unwrapMonad")
                                                                                                         'NoSourceUnpackedness
                                                                                                         'NoSourceStrictness
                                                                                                         'DecidedLazy>_P
                                                                                                      <K1
                                                                                                         R
                                                                                                         (m_abRpG a_abRpH)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                           <*>_N
                                                                                                                                           <C>_P
                                                                                                                                           <'MetaCons
                                                                                                                                              "WrapMonad"
                                                                                                                                              'PrefixI
                                                                                                                                              'True>_P
                                                                                                                                           <M1
                                                                                                                                              S
                                                                                                                                              ('MetaSel
                                                                                                                                                 ('Just
                                                                                                                                                    "unwrapMonad")
                                                                                                                                                 'NoSourceUnpackedness
                                                                                                                                                 'NoSourceStrictness
                                                                                                                                                 'DecidedLazy)
                                                                                                                                              (K1
                                                                                                                                                 R
                                                                                                                                                 (m_abRpG a_abRpH))>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                                                    <*>_N
                                                                                                                                                                                    <D>_P
                                                                                                                                                                                    <'MetaData
                                                                                                                                                                                       "WrappedMonad"
                                                                                                                                                                                       "Control.Applicative"
                                                                                                                                                                                       "base"
                                                                                                                                                                                       'True>_P
                                                                                                                                                                                    <M1
                                                                                                                                                                                       C
                                                                                                                                                                                       ('MetaCons
                                                                                                                                                                                          "WrapMonad"
                                                                                                                                                                                          'PrefixI
                                                                                                                                                                                          'True)
                                                                                                                                                                                       (M1
                                                                                                                                                                                          S
                                                                                                                                                                                          ('MetaSel
                                                                                                                                                                                             ('Just
                                                                                                                                                                                                "unwrapMonad")
                                                                                                                                                                                             'NoSourceUnpackedness
                                                                                                                                                                                             'NoSourceStrictness
                                                                                                                                                                                             'DecidedLazy)
                                                                                                                                                                                          (K1
                                                                                                                                                                                             R
                                                                                                                                                                                             (m_abRpG a_abRpH)))>_R) ; Sub (Sym (Control.Applicative.Rep_WrappedMonad[0]
                                                                                                                                                                                                                                     <m_abRpG>_N
                                                                                                                                                                                                                                     <a_abRpH>_N))))) <x>_N)
                                      :: (forall x.
                                          WrappedMonad m_abRpG a_abRpH
                                          -> WrappedMonad m_abRpG a_abRpH :: *)
                                         ~R# (forall x.
                                              WrappedMonad m_abRpG a_abRpH
                                              -> Rep (WrappedMonad m_abRpG a_abRpH) x :: *))
                              (Control.Applicative.$fGenericWrappedMonad1 @ m_abRpG @ a_abRpH)
                              `cast` (forall (x :: <*>_N).
                                      <Rep (WrappedMonad m_abRpG a_abRpH) x>_R
                                      ->_R (Sub (Control.Applicative.Rep_WrappedMonad[0]
                                                     <m_abRpG>_N
                                                     <a_abRpH>_N) ; (GHC.Generics.N:M1[0]
                                                                         <*>_N
                                                                         <D>_P
                                                                         <'MetaData
                                                                            "WrappedMonad"
                                                                            "Control.Applicative"
                                                                            "base"
                                                                            'True>_P
                                                                         <M1
                                                                            C
                                                                            ('MetaCons
                                                                               "WrapMonad"
                                                                               'PrefixI
                                                                               'True)
                                                                            (M1
                                                                               S
                                                                               ('MetaSel
                                                                                  ('Just
                                                                                     "unwrapMonad")
                                                                                  'NoSourceUnpackedness
                                                                                  'NoSourceStrictness
                                                                                  'DecidedLazy)
                                                                               (K1
                                                                                  R
                                                                                  (m_abRpG a_abRpH)))>_R ; (GHC.Generics.N:M1[0]
                                                                                                                <*>_N
                                                                                                                <C>_P
                                                                                                                <'MetaCons
                                                                                                                   "WrapMonad"
                                                                                                                   'PrefixI
                                                                                                                   'True>_P
                                                                                                                <M1
                                                                                                                   S
                                                                                                                   ('MetaSel
                                                                                                                      ('Just
                                                                                                                         "unwrapMonad")
                                                                                                                      'NoSourceUnpackedness
                                                                                                                      'NoSourceStrictness
                                                                                                                      'DecidedLazy)
                                                                                                                   (K1
                                                                                                                      R
                                                                                                                      (m_abRpG a_abRpH))>_R ; GHC.Generics.N:M1[0]
                                                                                                                                                  <*>_N
                                                                                                                                                  <S>_P
                                                                                                                                                  <'MetaSel
                                                                                                                                                     ('Just
                                                                                                                                                        "unwrapMonad")
                                                                                                                                                     'NoSourceUnpackedness
                                                                                                                                                     'NoSourceStrictness
                                                                                                                                                     'DecidedLazy>_P
                                                                                                                                                  <K1
                                                                                                                                                     R
                                                                                                                                                     (m_abRpG a_abRpH)>_R))) <x>_N ; (GHC.Generics.N:K1[0]
                                                                                                                                                                                          <*>_N
                                                                                                                                                                                          <R>_P
                                                                                                                                                                                          <m_abRpG a_abRpH>_R
                                                                                                                                                                                          <x>_P ; Sym (Control.Applicative.N:WrappedMonad[0]
                                                                                                                                                                                                           <m_abRpG>_R) <a_abRpH>_N)
                                      :: (forall x.
                                          Rep (WrappedMonad m_abRpG a_abRpH) x
                                          -> Rep (WrappedMonad m_abRpG a_abRpH) x :: *)
                                         ~R# (forall x.
                                              Rep (WrappedMonad m_abRpG a_abRpH) x
                                              -> WrappedMonad m_abRpG a_abRpH :: *))]
Control.Applicative.$fGenericWrappedMonad
  = \ (@ (m_XbRLs :: * -> *)) (@ a_XbRLu) ->
      GHC.Generics.C:Generic
        @ (WrappedMonad m_XbRLs a_XbRLu)
        ((Control.Applicative.$fGenericWrappedMonad2 @ m_XbRLs @ a_XbRLu)
         `cast` (forall (x :: <*>_N).
                 <WrappedMonad m_XbRLs a_XbRLu>_R
                 ->_R Control.Applicative.N:WrappedMonad[0]
                          <m_XbRLs>_R <a_XbRLu>_N ; (Sym (GHC.Generics.N:K1[0]
                                                              <*>_N
                                                              <R>_P
                                                              <m_XbRLs a_XbRLu>_R
                                                              <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                 <*>_N
                                                                                 <S>_P
                                                                                 <'MetaSel
                                                                                    ('Just
                                                                                       "unwrapMonad")
                                                                                    'NoSourceUnpackedness
                                                                                    'NoSourceStrictness
                                                                                    'DecidedLazy>_P
                                                                                 <K1
                                                                                    R
                                                                                    (m_XbRLs a_XbRLu)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                      <*>_N
                                                                                                                      <C>_P
                                                                                                                      <'MetaCons
                                                                                                                         "WrapMonad"
                                                                                                                         'PrefixI
                                                                                                                         'True>_P
                                                                                                                      <M1
                                                                                                                         S
                                                                                                                         ('MetaSel
                                                                                                                            ('Just
                                                                                                                               "unwrapMonad")
                                                                                                                            'NoSourceUnpackedness
                                                                                                                            'NoSourceStrictness
                                                                                                                            'DecidedLazy)
                                                                                                                         (K1
                                                                                                                            R
                                                                                                                            (m_XbRLs a_XbRLu))>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                               <*>_N
                                                                                                                                                               <D>_P
                                                                                                                                                               <'MetaData
                                                                                                                                                                  "WrappedMonad"
                                                                                                                                                                  "Control.Applicative"
                                                                                                                                                                  "base"
                                                                                                                                                                  'True>_P
                                                                                                                                                               <M1
                                                                                                                                                                  C
                                                                                                                                                                  ('MetaCons
                                                                                                                                                                     "WrapMonad"
                                                                                                                                                                     'PrefixI
                                                                                                                                                                     'True)
                                                                                                                                                                  (M1
                                                                                                                                                                     S
                                                                                                                                                                     ('MetaSel
                                                                                                                                                                        ('Just
                                                                                                                                                                           "unwrapMonad")
                                                                                                                                                                        'NoSourceUnpackedness
                                                                                                                                                                        'NoSourceStrictness
                                                                                                                                                                        'DecidedLazy)
                                                                                                                                                                     (K1
                                                                                                                                                                        R
                                                                                                                                                                        (m_XbRLs a_XbRLu)))>_R) ; Sub (Sym (Control.Applicative.Rep_WrappedMonad[0]
                                                                                                                                                                                                                <m_XbRLs>_N
                                                                                                                                                                                                                <a_XbRLu>_N))))) <x>_N)
                 :: (forall x.
                     WrappedMonad m_XbRLs a_XbRLu -> WrappedMonad m_XbRLs a_XbRLu :: *)
                    ~R# (forall x.
                         WrappedMonad m_XbRLs a_XbRLu
                         -> Rep (WrappedMonad m_XbRLs a_XbRLu) x :: *)))
        ((Control.Applicative.$fGenericWrappedMonad1 @ m_XbRLs @ a_XbRLu)
         `cast` (forall (x :: <*>_N).
                 <Rep (WrappedMonad m_XbRLs a_XbRLu) x>_R
                 ->_R (Sub (Control.Applicative.Rep_WrappedMonad[0]
                                <m_XbRLs>_N <a_XbRLu>_N) ; (GHC.Generics.N:M1[0]
                                                                <*>_N
                                                                <D>_P
                                                                <'MetaData
                                                                   "WrappedMonad"
                                                                   "Control.Applicative"
                                                                   "base"
                                                                   'True>_P
                                                                <M1
                                                                   C
                                                                   ('MetaCons
                                                                      "WrapMonad" 'PrefixI 'True)
                                                                   (M1
                                                                      S
                                                                      ('MetaSel
                                                                         ('Just "unwrapMonad")
                                                                         'NoSourceUnpackedness
                                                                         'NoSourceStrictness
                                                                         'DecidedLazy)
                                                                      (K1
                                                                         R
                                                                         (m_XbRLs a_XbRLu)))>_R ; (GHC.Generics.N:M1[0]
                                                                                                       <*>_N
                                                                                                       <C>_P
                                                                                                       <'MetaCons
                                                                                                          "WrapMonad"
                                                                                                          'PrefixI
                                                                                                          'True>_P
                                                                                                       <M1
                                                                                                          S
                                                                                                          ('MetaSel
                                                                                                             ('Just
                                                                                                                "unwrapMonad")
                                                                                                             'NoSourceUnpackedness
                                                                                                             'NoSourceStrictness
                                                                                                             'DecidedLazy)
                                                                                                          (K1
                                                                                                             R
                                                                                                             (m_XbRLs a_XbRLu))>_R ; GHC.Generics.N:M1[0]
                                                                                                                                         <*>_N
                                                                                                                                         <S>_P
                                                                                                                                         <'MetaSel
                                                                                                                                            ('Just
                                                                                                                                               "unwrapMonad")
                                                                                                                                            'NoSourceUnpackedness
                                                                                                                                            'NoSourceStrictness
                                                                                                                                            'DecidedLazy>_P
                                                                                                                                         <K1
                                                                                                                                            R
                                                                                                                                            (m_XbRLs a_XbRLu)>_R))) <x>_N ; (GHC.Generics.N:K1[0]
                                                                                                                                                                                 <*>_N
                                                                                                                                                                                 <R>_P
                                                                                                                                                                                 <m_XbRLs a_XbRLu>_R
                                                                                                                                                                                 <x>_P ; Sym (Control.Applicative.N:WrappedMonad[0]
                                                                                                                                                                                                  <m_XbRLs>_R) <a_XbRLu>_N)
                 :: (forall x.
                     Rep (WrappedMonad m_XbRLs a_XbRLu) x
                     -> Rep (WrappedMonad m_XbRLs a_XbRLu) x :: *)
                    ~R# (forall x.
                         Rep (WrappedMonad m_XbRLs a_XbRLu) x
                         -> WrappedMonad m_XbRLs a_XbRLu :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 15, joins: 0/0}
unwrapMonad :: forall (m :: * -> *) a. WrappedMonad m a -> m a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Control.Applicative.$fGeneric1WrappedMonad2
               `cast` (forall (m :: <* -> *>_N) (a :: <*>_N).
                       <WrappedMonad m a>_R
                       ->_R Control.Applicative.N:WrappedMonad[0] <m>_R <a>_N
                       :: (forall (m :: * -> *) a.
                           WrappedMonad m a -> WrappedMonad m a :: *)
                          ~R# (forall (m :: * -> *) a. WrappedMonad m a -> m a :: *))}]
unwrapMonad
  = Control.Applicative.$fGeneric1WrappedMonad2
    `cast` (forall (m :: <* -> *>_N) (a :: <*>_N).
            <WrappedMonad m a>_R
            ->_R Control.Applicative.N:WrappedMonad[0] <m>_R <a>_N
            :: (forall (m :: * -> *) a.
                WrappedMonad m a -> WrappedMonad m a :: *)
               ~R# (forall (m :: * -> *) a. WrappedMonad m a -> m a :: *))

-- RHS size: {terms: 1, types: 0, coercions: 22, joins: 0/0}
unwrapArrow
  :: forall (a :: * -> * -> *) b c. WrappedArrow a b c -> a b c
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Control.Applicative.$fGeneric1WrappedArrow2
               `cast` (forall (a :: <* -> * -> *>_N) (b :: <*>_N) (c :: <*>_N).
                       <WrappedArrow a b c>_R
                       ->_R Control.Applicative.N:WrappedArrow[0] <a>_R <b>_N <c>_N
                       :: (forall (a :: * -> * -> *) b c.
                           WrappedArrow a b c -> WrappedArrow a b c :: *)
                          ~R# (forall (a :: * -> * -> *) b c.
                               WrappedArrow a b c -> a b c :: *))}]
unwrapArrow
  = Control.Applicative.$fGeneric1WrappedArrow2
    `cast` (forall (a :: <* -> * -> *>_N) (b :: <*>_N) (c :: <*>_N).
            <WrappedArrow a b c>_R
            ->_R Control.Applicative.N:WrappedArrow[0] <a>_R <b>_N <c>_N
            :: (forall (a :: * -> * -> *) b c.
                WrappedArrow a b c -> WrappedArrow a b c :: *)
               ~R# (forall (a :: * -> * -> *) b c.
                    WrappedArrow a b c -> a b c :: *))

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
getZipList :: forall a. ZipList a -> [a]
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Control.Applicative.$fGeneric1ZipList2
               `cast` (forall (a :: <*>_N).
                       <ZipList a>_R ->_R Control.Applicative.N:ZipList[0] <a>_N
                       :: (forall a. ZipList a -> ZipList a :: *)
                          ~R# (forall a. ZipList a -> [a] :: *))}]
getZipList
  = Control.Applicative.$fGeneric1ZipList2
    `cast` (forall (a :: <*>_N).
            <ZipList a>_R ->_R Control.Applicative.N:ZipList[0] <a>_N
            :: (forall a. ZipList a -> ZipList a :: *)
               ~R# (forall a. ZipList a -> [a] :: *))

-- RHS size: {terms: 17, types: 26, coercions: 0, joins: 0/1}
optional
  :: forall (f :: * -> *) a. Alternative f => f a -> f (Maybe a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LL),U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,1*C1(C1(U)),A,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 160 0}]
optional
  = \ (@ (f_abRFg :: * -> *))
      (@ a_abRFh)
      ($dAlternative_abRFj :: Alternative f_abRFg)
      (eta_X4n :: f_abRFg a_abRFh) ->
      let {
        $dApplicative_sbSld [Dmd=<L,U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)>]
          :: Applicative f_abRFg
        [LclId]
        $dApplicative_sbSld
          = GHC.Base.$p1Alternative @ f_abRFg $dAlternative_abRFj } in
      <|>
        @ f_abRFg
        $dAlternative_abRFj
        @ (Maybe a_abRFh)
        (fmap
           @ f_abRFg
           (GHC.Base.$p1Applicative @ f_abRFg $dApplicative_sbSld)
           @ a_abRFh
           @ (Maybe a_abRFh)
           (GHC.Base.Just @ a_abRFh)
           eta_X4n)
        (pure
           @ f_abRFg
           $dApplicative_sbSld
           @ (Maybe a_abRFh)
           (GHC.Base.Nothing @ a_abRFh))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Control.Applicative.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Applicative.$trModule3
  = GHC.Types.TrNameS Control.Applicative.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
Control.Applicative.$trModule2 = "Control.Applicative"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Applicative.$trModule1
  = GHC.Types.TrNameS Control.Applicative.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Control.Applicative.$trModule
  = GHC.Types.Module
      Control.Applicative.$trModule3 Control.Applicative.$trModule1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tcWrappedMonad1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Control.Applicative.$tcWrappedMonad1
  = GHC.Types.KindRepFun GHC.Types.krep$*Arr* GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tcWrappedArrow1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Control.Applicative.$tcWrappedArrow1
  = GHC.Types.KindRepFun
      GHC.Types.krep$*->*->* GHC.Types.krep$*->*->*

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep_rbSvt :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep_rbSvt = GHC.Types.KindRepVar 2#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep1_rbSvu :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep1_rbSvu = GHC.Types.KindRepVar 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep2_rbSvv :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep2_rbSvv = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep3_rbSvw :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep3_rbSvw
  = GHC.Types.: @ KindRep $krep2_rbSvv (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4_rbSvx :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep4_rbSvx
  = GHC.Types.KindRepTyConApp GHC.Types.$tc[] $krep3_rbSvw

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5_rbSvy :: KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []]
$krep5_rbSvy = GHC.Types.KindRepApp $krep2_rbSvv $krep1_rbSvu

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep6_rbSvz :: KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []]
$krep6_rbSvz = GHC.Types.KindRepApp $krep5_rbSvy $krep_rbSvt

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tcWrappedMonad3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Applicative.$tcWrappedMonad3 = "WrappedMonad"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tcWrappedMonad2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Applicative.$tcWrappedMonad2
  = GHC.Types.TrNameS Control.Applicative.$tcWrappedMonad3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tcWrappedMonad :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Applicative.$tcWrappedMonad
  = GHC.Types.TyCon
      12971590878300233698##
      12447260690856494251##
      Control.Applicative.$trModule
      Control.Applicative.$tcWrappedMonad2
      0#
      Control.Applicative.$tcWrappedMonad1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep7_rbSvA :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep7_rbSvA
  = GHC.Types.: @ KindRep $krep1_rbSvu (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep8_rbSvB :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep8_rbSvB = GHC.Types.: @ KindRep $krep2_rbSvv $krep7_rbSvA

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep9_rbSvC :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep9_rbSvC
  = GHC.Types.KindRepTyConApp
      Control.Applicative.$tcWrappedMonad $krep8_rbSvB

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tc'WrapMonad1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Control.Applicative.$tc'WrapMonad1
  = GHC.Types.KindRepFun $krep5_rbSvy $krep9_rbSvC

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tc'WrapMonad3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Applicative.$tc'WrapMonad3 = "'WrapMonad"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tc'WrapMonad2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Applicative.$tc'WrapMonad2
  = GHC.Types.TrNameS Control.Applicative.$tc'WrapMonad3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tc'WrapMonad :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Applicative.$tc'WrapMonad
  = GHC.Types.TyCon
      10363415327661881286##
      6845751270384138997##
      Control.Applicative.$trModule
      Control.Applicative.$tc'WrapMonad2
      2#
      Control.Applicative.$tc'WrapMonad1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tcWrappedArrow3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Applicative.$tcWrappedArrow3 = "WrappedArrow"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tcWrappedArrow2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Applicative.$tcWrappedArrow2
  = GHC.Types.TrNameS Control.Applicative.$tcWrappedArrow3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tcWrappedArrow :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Applicative.$tcWrappedArrow
  = GHC.Types.TyCon
      17995829375472255965##
      6668242383287740398##
      Control.Applicative.$trModule
      Control.Applicative.$tcWrappedArrow2
      0#
      Control.Applicative.$tcWrappedArrow1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep10_rbSvD :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep10_rbSvD
  = GHC.Types.: @ KindRep $krep_rbSvt (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep11_rbSvE :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep11_rbSvE = GHC.Types.: @ KindRep $krep1_rbSvu $krep10_rbSvD

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep12_rbSvF :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep12_rbSvF = GHC.Types.: @ KindRep $krep2_rbSvv $krep11_rbSvE

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep13_rbSvG :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep13_rbSvG
  = GHC.Types.KindRepTyConApp
      Control.Applicative.$tcWrappedArrow $krep12_rbSvF

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tc'WrapArrow1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Control.Applicative.$tc'WrapArrow1
  = GHC.Types.KindRepFun $krep6_rbSvz $krep13_rbSvG

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tc'WrapArrow3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Applicative.$tc'WrapArrow3 = "'WrapArrow"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tc'WrapArrow2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Applicative.$tc'WrapArrow2
  = GHC.Types.TrNameS Control.Applicative.$tc'WrapArrow3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tc'WrapArrow :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Applicative.$tc'WrapArrow
  = GHC.Types.TyCon
      4796259816778499037##
      13482613273239263357##
      Control.Applicative.$trModule
      Control.Applicative.$tc'WrapArrow2
      3#
      Control.Applicative.$tc'WrapArrow1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tcZipList1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Applicative.$tcZipList1
  = GHC.Types.TrNameS Control.Applicative.$fReadZipList11

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tcZipList :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Applicative.$tcZipList
  = GHC.Types.TyCon
      11311650752326360483##
      5534599578149162946##
      Control.Applicative.$trModule
      Control.Applicative.$tcZipList1
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep14_rbSvH :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep14_rbSvH
  = GHC.Types.KindRepTyConApp
      Control.Applicative.$tcZipList $krep3_rbSvw

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tc'ZipList1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Control.Applicative.$tc'ZipList1
  = GHC.Types.KindRepFun $krep4_rbSvx $krep14_rbSvH

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tc'ZipList3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Control.Applicative.$tc'ZipList3 = "'ZipList"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tc'ZipList2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Applicative.$tc'ZipList2
  = GHC.Types.TrNameS Control.Applicative.$tc'ZipList3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Applicative.$tc'ZipList :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Applicative.$tc'ZipList
  = GHC.Types.TyCon
      15353069281551614305##
      7665927634319452478##
      Control.Applicative.$trModule
      Control.Applicative.$tc'ZipList2
      1#
      Control.Applicative.$tc'ZipList1


