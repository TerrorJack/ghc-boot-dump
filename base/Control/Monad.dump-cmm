
==================== Output Cmm ====================
2018-03-16 16:07:00.638467748 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:00.639569994 UTC

[section ""data" . Control.Monad.guard_closure" {
     Control.Monad.guard_closure:
         const Control.Monad.guard_info;
 },
 Control.Monad.guard_entry() //  [R2, R3]
         { info_tbl: [(cc6UH,
                       label: Control.Monad.guard_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6UH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc6UI; else goto cc6UJ;
       cc6UI: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.guard_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc6UJ: // global
           I64[Sp - 16] = block_cc6UA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc6UV; else goto cc6UB;
       uc6UV: // global
           call _cc6UA(R1) args: 0, res: 0, upd: 0;
       cc6UB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc6UA() //  [R1]
         { info_tbl: [(cc6UA,
                       label: block_cc6UA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6UA: // global
           _sc6QB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc6UE; else goto cc6UF;
       cc6UE: // global
           R2 = _sc6QB::P64;
           Sp = Sp + 16;
           call GHC.Base.empty_entry(R2) args: 8, res: 0, upd: 8;
       cc6UF: // global
           I64[Sp + 8] = block_cc6UP_info;
           R2 = _sc6QB::P64;
           Sp = Sp + 8;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc6UP() //  [R1]
         { info_tbl: [(cc6UP,
                       label: block_cc6UP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6UP: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Tuple.()_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.642052692 UTC

[section ""data" . Control.Monad.filterM_closure" {
     Control.Monad.filterM_closure:
         const Control.Monad.filterM_info;
 },
 z_sc6QH_entry() //  [R1]
         { info_tbl: [(cc6V4,
                       label: z_sc6QH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6V4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc6V5; else goto cc6V6;
       cc6V5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc6V6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc6QQ_entry() //  [R1, R2, R3]
         { info_tbl: [(cc6Vw,
                       label: sat_sc6QQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6Vw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc6Vx; else goto cc6Vy;
       cc6Vx: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc6Vy: // global
           I64[Sp - 24] = block_cc6Vp_info;
           _sc6QL::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sc6QL::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc6VI; else goto cc6Vq;
       uc6VI: // global
           call _cc6Vp(R1) args: 0, res: 0, upd: 0;
       cc6Vq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc6Vp() //  [R1]
         { info_tbl: [(cc6Vp,
                       label: block_cc6Vp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6Vp: // global
           _sc6QO::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cc6Vt; else goto cc6Vu;
       cc6Vt: // global
           R1 = _sc6QO::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc6Vu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc6VH; else goto cc6VG;
       cc6VH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc6VG: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sc6QO::P64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sc6QI_entry() //  [R1, R2]
         { info_tbl: [(cc6VN,
                       label: go_sc6QI_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6VN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc6VO; else goto cc6VP;
       cc6VO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc6VP: // global
           I64[Sp - 40] = block_cc6Vc_info;
           _sc6QI::P64 = R1;
           _sc6QF::P64 = P64[R1 + 7];
           _sc6QG::P64 = P64[R1 + 15];
           _sc6QH::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sc6QF::P64;
           P64[Sp - 24] = _sc6QG::P64;
           P64[Sp - 16] = _sc6QH::P64;
           P64[Sp - 8] = _sc6QI::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc6VV; else goto cc6Vd;
       uc6VV: // global
           call _cc6Vc(R1) args: 0, res: 0, upd: 0;
       cc6Vd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc6Vc() //  [R1]
         { info_tbl: [(cc6Vc,
                       label: block_cc6Vc_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6Vc: // global
           if (R1 & 7 == 1) goto cc6VK; else goto cc6VL;
       cc6VK: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc6VL: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc6VU; else goto cc6VT;
       cc6VU: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc6VT: // global
           _sc6QL::P64 = P64[R1 + 6];
           _sc6QM::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 32];
           P64[Hp - 48] = _sc6QM::P64;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sc6QL::P64;
           I64[Hp - 8] = sat_sc6QQ_info;
           P64[Hp] = _sc6QL::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = Hp - 6;
           P64[Sp + 24] = Hp - 40;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Control.Monad.filterM_entry() //  [R2, R3]
         { info_tbl: [(cc6VW,
                       label: Control.Monad.filterM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6VW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc6W0; else goto cc6VZ;
       cc6W0: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.filterM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc6VZ: // global
           I64[Hp - 48] = z_sc6QH_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go_sc6QI_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.644933627 UTC

[section ""data" . Control.Monad.>=>_closure" {
     Control.Monad.>=>_closure:
         const Control.Monad.>=>_info;
 },
 Control.Monad.>=>_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc6W6,
                       label: Control.Monad.>=>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6W6: // global
           _sc6QW::P64 = R5;
           _sc6QV::P64 = R4;
           _sc6QU::P64 = R3;
           _sc6QT::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc6W7; else goto cc6W8;
       cc6W8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc6Wa; else goto cc6W9;
       cc6Wa: // global
           HpAlloc = 32;
           goto cc6W7;
       cc6W7: // global
           R5 = _sc6QW::P64;
           R4 = _sc6QV::P64;
           R3 = _sc6QU::P64;
           R2 = _sc6QT::P64;
           R1 = Control.Monad.>=>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc6W9: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sc6QU::P64;
           P64[Hp] = _sc6QW::P64;
           R2 = _sc6QT::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sc6QV::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.646148873 UTC

[section ""data" . Control.Monad.<=<_closure" {
     Control.Monad.<=<_closure:
         const Control.Monad.<=<_info;
 },
 Control.Monad.<=<_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc6Wf,
                       label: Control.Monad.<=<_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6Wf: // global
           R5 = R5;
           _sc6R0::P64 = R4;
           R4 = R3;
           R3 = _sc6R0::P64;
           R2 = R2;
           call Control.Monad.>=>_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.647279669 UTC

[section ""data" . Control.Monad.forever_closure" {
     Control.Monad.forever_closure:
         const Control.Monad.forever_info;
 },
 a'_sc6R4_entry() //  [R1]
         { info_tbl: [(cc6Wq,
                       label: a'_sc6R4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6Wq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc6Wr; else goto cc6Ws;
       cc6Wr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc6Ws: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = R1;
           Sp = Sp - 40;
           call GHC.Base.*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.forever_entry() //  [R2, R3]
         { info_tbl: [(cc6Wt,
                       label: Control.Monad.forever_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6Wt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc6Wx; else goto cc6Ww;
       cc6Wx: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.forever_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc6Ww: // global
           I64[Hp - 24] = a'_sc6R4_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.649465871 UTC

[section ""data" . Control.Monad.mapAndUnzipM_closure" {
     Control.Monad.mapAndUnzipM_closure:
         const Control.Monad.mapAndUnzipM_info;
 },
 z_sc6R9_entry() //  [R1]
         { info_tbl: [(cc6WK,
                       label: z_sc6R9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6WK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc6WL; else goto cc6WM;
       cc6WL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc6WM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sc6Ra_entry() //  [R1, R2]
         { info_tbl: [(cc6WZ,
                       label: go_sc6Ra_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6WZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc6X0; else goto cc6X1;
       cc6X0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc6X1: // global
           I64[Sp - 40] = block_cc6WS_info;
           _sc6Ra::P64 = R1;
           _sc6R5::P64 = P64[R1 + 7];
           _sc6R6::P64 = P64[R1 + 15];
           _sc6R9::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sc6R5::P64;
           P64[Sp - 24] = _sc6R6::P64;
           P64[Sp - 16] = _sc6R9::P64;
           P64[Sp - 8] = _sc6Ra::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc6Xc; else goto cc6WT;
       uc6Xc: // global
           call _cc6WS(R1) args: 0, res: 0, upd: 0;
       cc6WT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc6WS() //  [R1]
         { info_tbl: [(cc6WS,
                       label: block_cc6WS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6WS: // global
           if (R1 & 7 == 1) goto cc6WW; else goto cc6WX;
       cc6WW: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc6WX: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc6X9; else goto cc6X8;
       cc6X9: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc6X8: // global
           _sc6Rd::P64 = P64[R1 + 6];
           _sc6Re::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sc6Re::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sc6Rd::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sc6Rh_entry() //  [R1]
         { info_tbl: [(cc6Xd,
                       label: sat_sc6Rh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6Xd: // global
           _sc6Rh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc6Xe; else goto cc6Xf;
       cc6Xf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc6Xh; else goto cc6Xg;
       cc6Xh: // global
           HpAlloc = 56;
           goto cc6Xe;
       cc6Xe: // global
           R1 = _sc6Rh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc6Xg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc6Rh::P64;
           _sc6R5::P64 = P64[_sc6Rh::P64 + 16];
           _sc6R6::P64 = P64[_sc6Rh::P64 + 24];
           _sc6R7::P64 = P64[_sc6Rh::P64 + 32];
           I64[Hp - 48] = z_sc6R9_info;
           P64[Hp - 32] = _sc6R5::P64;
           I64[Hp - 24] = go_sc6Ra_info;
           P64[Hp - 16] = _sc6R5::P64;
           P64[Hp - 8] = _sc6R6::P64;
           P64[Hp] = Hp - 48;
           R2 = _sc6R7::P64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call go_sc6Ra_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.mapAndUnzipM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc6Xk,
                       label: Control.Monad.mapAndUnzipM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6Xk: // global
           _sc6R7::P64 = R4;
           _sc6R6::P64 = R3;
           _sc6R5::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc6Xl; else goto cc6Xm;
       cc6Xm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc6Xo; else goto cc6Xn;
       cc6Xo: // global
           HpAlloc = 40;
           goto cc6Xl;
       cc6Xl: // global
           R4 = _sc6R7::P64;
           R3 = _sc6R6::P64;
           R2 = _sc6R5::P64;
           R1 = Control.Monad.mapAndUnzipM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc6Xn: // global
           I64[Hp - 32] = sat_sc6Rh_info;
           P64[Hp - 16] = _sc6R5::P64;
           P64[Hp - 8] = _sc6R6::P64;
           P64[Hp] = _sc6R7::P64;
           I64[Sp - 16] = block_cc6Xi_info;
           R2 = _sc6R5::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc6Xi() //  [R1]
         { info_tbl: [(cc6Xi,
                       label: block_cc6Xi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6Xi: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.List.unzip_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.654044068 UTC

[section ""data" . Control.Monad.zipWithM_closure" {
     Control.Monad.zipWithM_closure:
         const Control.Monad.zipWithM_info;
 },
 z_sc6Rm_entry() //  [R1]
         { info_tbl: [(cc6XA,
                       label: z_sc6Rm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6XA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc6XB; else goto cc6XC;
       cc6XB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc6XC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go2_sc6Rn_entry() //  [R1, R2, R3]
         { info_tbl: [(cc6XP,
                       label: go2_sc6Rn_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6XP: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cc6XQ; else goto cc6XR;
       cc6XQ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc6XR: // global
           I64[Sp - 48] = block_cc6XI_info;
           _sc6Rn::P64 = R1;
           _sc6Ri::P64 = P64[R1 + 6];
           _sc6Rj::P64 = P64[R1 + 14];
           _sc6Rm::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _sc6Ri::P64;
           P64[Sp - 32] = _sc6Rj::P64;
           P64[Sp - 24] = _sc6Rm::P64;
           P64[Sp - 16] = _sc6Rn::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uc6Yj; else goto cc6XJ;
       uc6Yj: // global
           call _cc6XI(R1) args: 0, res: 0, upd: 0;
       cc6XJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc6XI() //  [R1]
         { info_tbl: [(cc6XI,
                       label: block_cc6XI_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6XI: // global
           if (R1 & 7 == 1) goto uc6Yf; else goto cc6XN;
       uc6Yf: // global
           Sp = Sp + 24;
           call _cc6Y5() args: 0, res: 0, upd: 0;
       cc6XN: // global
           I64[Sp - 8] = block_cc6XX_info;
           _sc6Rr::P64 = P64[R1 + 6];
           _sc6Rs::P64 = P64[R1 + 14];
           R1 = P64[Sp + 40];
           P64[Sp] = _sc6Rs::P64;
           P64[Sp + 40] = _sc6Rr::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc6Yh; else goto cc6XZ;
       uc6Yh: // global
           call _cc6XX(R1) args: 0, res: 0, upd: 0;
       cc6XZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc6XX() //  [R1]
         { info_tbl: [(cc6XX,
                       label: block_cc6XX_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6XX: // global
           if (R1 & 7 == 1) goto uc6Yg; else goto cc6Y6;
       uc6Yg: // global
           Sp = Sp + 32;
           call _cc6Y5() args: 0, res: 0, upd: 0;
       cc6Y6: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc6Yb; else goto cc6Ya;
       cc6Yb: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc6Ya: // global
           _sc6Ru::P64 = P64[R1 + 6];
           _sc6Rv::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _sc6Rv::P64;
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = _sc6Ru::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_ppp_info;
           P64[Sp + 32] = GHC.Types.:_closure+2;
           P64[Sp + 40] = Hp - 32;
           P64[Sp + 48] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cc6Y5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6Y5: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.zipWithM_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc6Yl,
                       label: Control.Monad.zipWithM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6Yl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc6Yp; else goto cc6Yo;
       cc6Yp: // global
           HpAlloc = 56;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.zipWithM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc6Yo: // global
           I64[Hp - 48] = z_sc6Rm_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go2_sc6Rn_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R3 = R5;
           R2 = R4;
           R1 = Hp - 22;
           call go2_sc6Rn_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.657351857 UTC

[section ""data" . Control.Monad.zipWithM__closure" {
     Control.Monad.zipWithM__closure:
         const Control.Monad.zipWithM__info;
 },
 z_sc6RC_entry() //  [R1]
         { info_tbl: [(cc6Yy,
                       label: z_sc6RC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6Yy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc6Yz; else goto cc6YA;
       cc6Yz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc6YA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go2_sc6RD_entry() //  [R1, R2, R3]
         { info_tbl: [(cc6YN,
                       label: go2_sc6RD_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6YN: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cc6YO; else goto cc6YP;
       cc6YO: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc6YP: // global
           I64[Sp - 48] = block_cc6YG_info;
           _sc6RD::P64 = R1;
           _sc6Ry::P64 = P64[R1 + 6];
           _sc6Rz::P64 = P64[R1 + 14];
           _sc6RC::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _sc6Ry::P64;
           P64[Sp - 32] = _sc6Rz::P64;
           P64[Sp - 24] = _sc6RC::P64;
           P64[Sp - 16] = _sc6RD::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uc6Zh; else goto cc6YH;
       uc6Zh: // global
           call _cc6YG(R1) args: 0, res: 0, upd: 0;
       cc6YH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc6YG() //  [R1]
         { info_tbl: [(cc6YG,
                       label: block_cc6YG_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6YG: // global
           if (R1 & 7 == 1) goto uc6Zd; else goto cc6YL;
       uc6Zd: // global
           Sp = Sp + 24;
           call _cc6Z3() args: 0, res: 0, upd: 0;
       cc6YL: // global
           I64[Sp - 8] = block_cc6YV_info;
           _sc6RH::P64 = P64[R1 + 6];
           _sc6RI::P64 = P64[R1 + 14];
           R1 = P64[Sp + 40];
           P64[Sp] = _sc6RI::P64;
           P64[Sp + 40] = _sc6RH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc6Zf; else goto cc6YX;
       uc6Zf: // global
           call _cc6YV(R1) args: 0, res: 0, upd: 0;
       cc6YX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc6YV() //  [R1]
         { info_tbl: [(cc6YV,
                       label: block_cc6YV_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6YV: // global
           if (R1 & 7 == 1) goto uc6Ze; else goto cc6Z4;
       uc6Ze: // global
           Sp = Sp + 32;
           call _cc6Z3() args: 0, res: 0, upd: 0;
       cc6Z4: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc6Z9; else goto cc6Z8;
       cc6Z9: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc6Z8: // global
           _sc6RK::P64 = P64[R1 + 6];
           _sc6RL::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _sc6RL::P64;
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = _sc6RK::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 32;
           P64[Sp + 48] = Hp - 72;
           Sp = Sp + 32;
           call GHC.Base.*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cc6Z3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6Z3: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.zipWithM__entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc6Zj,
                       label: Control.Monad.zipWithM__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6Zj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc6Zn; else goto cc6Zm;
       cc6Zn: // global
           HpAlloc = 56;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.zipWithM__closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc6Zm: // global
           I64[Hp - 48] = z_sc6RC_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go2_sc6RD_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R3 = R5;
           R2 = R4;
           R1 = Hp - 22;
           call go2_sc6RD_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.66027311 UTC

[section ""data" . Control.Monad.foldM_$sfoldM_closure" {
     Control.Monad.foldM_$sfoldM_closure:
         const Control.Monad.foldM_$sfoldM_info;
 },
 Control.Monad.foldM_$sfoldM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc6Zu,
                       label: Control.Monad.foldM_$sfoldM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6Zu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc6Zv; else goto cc6Zw;
       cc6Zv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM_$sfoldM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc6Zw: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc6Zy() args: 0, res: 0, upd: 0;
     }
 },
 _cc6Zy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6Zy: // global
           I64[Sp - 8] = block_cc6ZA_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc706; else goto cc6ZC;
       uc706: // global
           call _cc6ZA(R1) args: 0, res: 0, upd: 0;
       cc6ZC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc6ZA() //  [R1]
         { info_tbl: [(cc6ZA,
                       label: block_cc6ZA_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6ZA: // global
           _sc6RT::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cc6ZI; else goto cc6ZQ;
       cc6ZI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc6ZL; else goto cc6ZK;
       cc6ZL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc6ZK: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sc6RT::P64;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc6ZQ: // global
           I64[Sp] = block_cc6ZO_info;
           R3 = P64[R1 + 6];
           R2 = _sc6RT::P64;
           _sc6RW::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc6RW::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc6ZO() //  [R1]
         { info_tbl: [(cc6ZO,
                       label: block_cc6ZO_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6ZO: // global
           if (R1 & 7 == 1) goto cc6ZW; else goto cc700;
       cc6ZW: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc700: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           Sp = Sp + 8;
           call _cc6Zy() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.6624368 UTC

[section ""data" . Control.Monad.foldM1_closure" {
     Control.Monad.foldM1_closure:
         const Control.Monad.foldM1_info;
 },
 Control.Monad.foldM1_entry() //  [R2, R3, R4]
         { info_tbl: [(cc70e,
                       label: Control.Monad.foldM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc70e: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc70f; else goto cc70g;
       cc70f: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc70g: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc70i() args: 0, res: 0, upd: 0;
     }
 },
 _cc70i() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc70i: // global
           I64[Sp - 8] = block_cc70k_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc70E; else goto cc70m;
       uc70E: // global
           call _cc70k(R1) args: 0, res: 0, upd: 0;
       cc70m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc70k() //  [R1]
         { info_tbl: [(cc70k,
                       label: block_cc70k_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc70k: // global
           _sc6S5::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cc70s; else goto cc70x;
       cc70s: // global
           R1 = _sc6S5::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc70x: // global
           I64[Sp] = block_cc70v_info;
           R3 = P64[R1 + 6];
           R2 = _sc6S5::P64;
           _sc6S9::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc6S9::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc70v() //  [R1]
         { info_tbl: [(cc70v,
                       label: block_cc70v_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc70v: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cc70i() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.663877537 UTC

[section ""data" . Control.Monad.foldM_$sfoldM1_closure" {
     Control.Monad.foldM_$sfoldM1_closure:
         const Control.Monad.foldM_$sfoldM1_info;
 },
 Control.Monad.foldM_$sfoldM1_entry() //  [R2, R3, R4]
         { info_tbl: [(cc70K,
                       label: Control.Monad.foldM_$sfoldM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc70K: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Control.Monad.foldM1_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.664773843 UTC

[section ""data" . Control.Monad.foldM_closure" {
     Control.Monad.foldM_closure:
         const Control.Monad.foldM_info;
 },
 Control.Monad.foldM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cc70R,
                       label: Control.Monad.foldM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc70R: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Foldable.foldlM_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.665531081 UTC

[section ""data" . Control.Monad.foldM_1_closure" {
     Control.Monad.foldM_1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Tuple.()_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.666636404 UTC

[section ""data" . Control.Monad.foldM__$sfoldM__closure" {
     Control.Monad.foldM__$sfoldM__closure:
         const Control.Monad.foldM__$sfoldM__info;
 },
 Control.Monad.foldM__$sfoldM__entry() //  [R2, R3, R4]
         { info_tbl: [(cc710,
                       label: Control.Monad.foldM__$sfoldM__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc710: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc711; else goto cc712;
       cc711: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM__$sfoldM__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc712: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc714() args: 0, res: 0, upd: 0;
     }
 },
 _cc714() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc714: // global
           I64[Sp - 8] = block_cc716_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc71z; else goto cc718;
       uc71z: // global
           call _cc716(R1) args: 0, res: 0, upd: 0;
       cc718: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc716() //  [R1]
         { info_tbl: [(cc716,
                       label: block_cc716_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc716: // global
           if (R1 & 7 == 1) goto cc71e; else goto cc71j;
       cc71e: // global
           R1 = Control.Monad.foldM_1_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc71j: // global
           I64[Sp] = block_cc71h_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sc6Sl::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc6Sl::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc71h() //  [R1]
         { info_tbl: [(cc71h,
                       label: block_cc71h_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc71h: // global
           if (R1 & 7 == 1) goto cc71p; else goto cc71t;
       cc71p: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc71t: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           Sp = Sp + 8;
           call _cc714() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.668467046 UTC

[section ""data" . Control.Monad.foldM_2_closure" {
     Control.Monad.foldM_2_closure:
         const Control.Monad.foldM_2_info;
 },
 Control.Monad.foldM_2_entry() //  [R2, R3, R4]
         { info_tbl: [(cc71H,
                       label: Control.Monad.foldM_2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc71H: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc71I; else goto cc71J;
       cc71I: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM_2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc71J: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc71L() args: 0, res: 0, upd: 0;
     }
 },
 _cc71L() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc71L: // global
           I64[Sp - 8] = block_cc71N_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc727; else goto cc71P;
       uc727: // global
           call _cc71N(R1) args: 0, res: 0, upd: 0;
       cc71P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc71N() //  [R1]
         { info_tbl: [(cc71N,
                       label: block_cc71N_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc71N: // global
           if (R1 & 7 == 1) goto cc71V; else goto cc720;
       cc71V: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc720: // global
           I64[Sp] = block_cc71Y_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sc6Sy::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc6Sy::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc71Y() //  [R1]
         { info_tbl: [(cc71Y,
                       label: block_cc71Y_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc71Y: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cc71L() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.670000344 UTC

[section ""data" . Control.Monad.foldM__$sfoldM_1_closure" {
     Control.Monad.foldM__$sfoldM_1_closure:
         const Control.Monad.foldM__$sfoldM_1_info;
 },
 Control.Monad.foldM__$sfoldM_1_entry() //  [R2, R3, R4]
         { info_tbl: [(cc72d,
                       label: Control.Monad.foldM__$sfoldM_1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc72d: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Control.Monad.foldM_2_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.671185257 UTC

[section ""data" . Control.Monad.foldM__closure" {
     Control.Monad.foldM__closure:
         const Control.Monad.foldM__info;
 },
 sat_sc6SI_entry() //  [R1]
         { info_tbl: [(cc72o,
                       label: sat_sc6SI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc72o: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc72p; else goto cc72q;
       cc72p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc72q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc6SH_entry() //  [R1]
         { info_tbl: [(cc72v,
                       label: sat_sc6SH_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc72v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc72w; else goto cc72x;
       cc72w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc72x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Foldable.foldlM_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.foldM__entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cc72y,
                       label: Control.Monad.foldM__info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc72y: // global
           _sc6SG::P64 = R6;
           _sc6SF::P64 = R5;
           _sc6SE::P64 = R4;
           _sc6SD::P64 = R3;
           _sc6SC::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc72z; else goto cc72A;
       cc72A: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc72C; else goto cc72B;
       cc72C: // global
           HpAlloc = 80;
           goto cc72z;
       cc72z: // global
           R6 = _sc6SG::P64;
           R5 = _sc6SF::P64;
           R4 = _sc6SE::P64;
           R3 = _sc6SD::P64;
           R2 = _sc6SC::P64;
           R1 = Control.Monad.foldM__closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc72B: // global
           I64[Hp - 72] = sat_sc6SI_info;
           P64[Hp - 56] = _sc6SD::P64;
           I64[Hp - 48] = sat_sc6SH_info;
           P64[Hp - 32] = _sc6SC::P64;
           P64[Hp - 24] = _sc6SD::P64;
           P64[Hp - 16] = _sc6SE::P64;
           P64[Hp - 8] = _sc6SF::P64;
           P64[Hp] = _sc6SG::P64;
           R2 = _sc6SD::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 48;
           P64[Sp - 8] = Hp - 72;
           Sp = Sp - 24;
           call GHC.Base.>>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.673150764 UTC

[section ""data" . Control.Monad.<$!>_closure" {
     Control.Monad.<$!>_closure:
         const Control.Monad.<$!>_info;
 },
 sat_sc6SO_entry() //  [R1, R2]
         { info_tbl: [(cc72O,
                       label: sat_sc6SO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc72O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc72P; else goto cc72Q;
       cc72P: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc72Q: // global
           I64[Sp - 16] = block_cc72M_info;
           R2 = R2;
           _sc6SJ::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _sc6SJ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc72M() //  [R1]
         { info_tbl: [(cc72M,
                       label: block_cc72M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc72M: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Monad.<$!>_entry() //  [R2, R3, R4]
         { info_tbl: [(cc72S,
                       label: Control.Monad.<$!>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc72S: // global
           _sc6SL::P64 = R4;
           _sc6SK::P64 = R3;
           _sc6SJ::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc72T; else goto cc72U;
       cc72U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc72W; else goto cc72V;
       cc72W: // global
           HpAlloc = 24;
           goto cc72T;
       cc72T: // global
           R4 = _sc6SL::P64;
           R3 = _sc6SK::P64;
           R2 = _sc6SJ::P64;
           R1 = Control.Monad.<$!>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc72V: // global
           I64[Hp - 16] = sat_sc6SO_info;
           P64[Hp - 8] = _sc6SJ::P64;
           P64[Hp] = _sc6SK::P64;
           R2 = _sc6SJ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sc6SL::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.675272249 UTC

[section ""data" . Control.Monad.mfilter_closure" {
     Control.Monad.mfilter_closure:
         const Control.Monad.mfilter_info;
 },
 lvl_sc6SS_entry() //  [R1]
         { info_tbl: [(cc735,
                       label: lvl_sc6SS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc735: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc736; else goto cc737;
       cc736: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc737: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc6SW_entry() //  [R1, R2]
         { info_tbl: [(cc73n,
                       label: sat_sc6SW_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc73n: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc73o; else goto cc73p;
       cc73o: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc73p: // global
           I64[Sp - 32] = block_cc73h_info;
           _sc6SU::P64 = R2;
           R2 = R2;
           _sc6SS::P64 = P64[R1 + 15];
           _sc6ST::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 24] = _sc6SS::P64;
           P64[Sp - 16] = _sc6ST::P64;
           P64[Sp - 8] = _sc6SU::P64;
           Sp = Sp - 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc73h() //  [R1]
         { info_tbl: [(cc73h,
                       label: block_cc73h_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc73h: // global
           if (R1 & 7 == 1) goto cc73k; else goto cc73l;
       cc73k: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc73l: // global
           R2 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_p_info;
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Monad.mfilter_entry() //  [R2, R3, R4]
         { info_tbl: [(cc73w,
                       label: Control.Monad.mfilter_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc73w: // global
           _sc6SR::P64 = R4;
           _sc6SQ::P64 = R3;
           _sc6SP::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cc73x; else goto cc73y;
       cc73y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc73A; else goto cc73z;
       cc73A: // global
           HpAlloc = 24;
           goto cc73x;
       cc73x: // global
           R4 = _sc6SR::P64;
           R3 = _sc6SQ::P64;
           R2 = _sc6SP::P64;
           R1 = Control.Monad.mfilter_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc73z: // global
           I64[Hp - 16] = lvl_sc6SS_info;
           P64[Hp] = _sc6SP::P64;
           I64[Sp - 32] = block_cc738_info;
           R2 = _sc6SP::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sc6SQ::P64;
           P64[Sp - 8] = _sc6SR::P64;
           Sp = Sp - 32;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc738() //  [R1]
         { info_tbl: [(cc738,
                       label: block_cc738_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc738: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc73D; else goto cc73C;
       cc73D: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc73C: // global
           I64[Hp - 24] = sat_sc6SW_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = Hp - 23;
           Sp = Sp + 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.677299813 UTC

[section ""cstring" . Control.Monad.$trModule4_bytes" {
     Control.Monad.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.677913651 UTC

[section ""data" . Control.Monad.$trModule3_closure" {
     Control.Monad.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.67846212 UTC

[section ""cstring" . Control.Monad.$trModule2_bytes" {
     Control.Monad.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.679021712 UTC

[section ""data" . Control.Monad.$trModule1_closure" {
     Control.Monad.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.679582087 UTC

[section ""data" . Control.Monad.$trModule_closure" {
     Control.Monad.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.$trModule3_closure+1;
         const Control.Monad.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.680491662 UTC

[section ""data" . Control.Monad.unless_$sunless_closure" {
     Control.Monad.unless_$sunless_closure:
         const Control.Monad.unless_$sunless_info;
 },
 Control.Monad.unless_$sunless_entry() //  [R2, R3]
         { info_tbl: [(cc73P,
                       label: Control.Monad.unless_$sunless_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc73P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc73Q; else goto cc73R;
       cc73Q: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.unless_$sunless_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc73R: // global
           I64[Sp - 16] = block_cc73I_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc73Y; else goto cc73J;
       uc73Y: // global
           call _cc73I(R1) args: 0, res: 0, upd: 0;
       cc73J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc73I() //  [R1]
         { info_tbl: [(cc73I,
                       label: block_cc73I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc73I: // global
           if (R1 & 7 == 1) goto cc73M; else goto cc73N;
       cc73M: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc73N: // global
           R1 = Control.Monad.foldM_1_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.682100075 UTC

[section ""data" . Control.Monad.replicateM__$sreplicateM__closure" {
     Control.Monad.replicateM__$sreplicateM__closure:
         const Control.Monad.replicateM__$sreplicateM__info;
 },
 Control.Monad.replicateM__$sreplicateM__entry() //  [R2, R3]
         { info_tbl: [(cc746,
                       label: Control.Monad.replicateM__$sreplicateM__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc746: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc747; else goto cc748;
       cc747: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM__$sreplicateM__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc748: // global
           I64[Sp - 16] = block_cc743_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc74F; else goto cc744;
       uc74F: // global
           call _cc743(R1) args: 0, res: 0, upd: 0;
       cc744: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc743() //  [R1]
         { info_tbl: [(cc743,
                       label: block_cc743_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc743: // global
           I64[Sp] = I64[R1 + 7];
           call _cc74f() args: 0, res: 0, upd: 0;
     }
 },
 _cc74f() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc74f: // global
           if (%MO_S_Gt_W64(I64[Sp], 0)) goto cc74n; else goto cc74z;
       cc74n: // global
           I64[Sp - 8] = block_cc74l_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc74G; else goto cc74o;
       uc74G: // global
           call _cc74l(R1) args: 0, res: 0, upd: 0;
       cc74o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cc74z: // global
           R1 = Control.Monad.foldM_1_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc74l() //  [R1]
         { info_tbl: [(cc74l,
                       label: block_cc74l_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc74l: // global
           if (R1 & 7 == 1) goto cc74u; else goto cc74y;
       cc74u: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc74y: // global
           I64[Sp + 8] = I64[Sp + 8] - 1;
           Sp = Sp + 8;
           call _cc74f() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.683485968 UTC

[section ""data" . Control.Monad.replicateM1_closure" {
     Control.Monad.replicateM1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.684862362 UTC

[section ""data" . Control.Monad.$w$sreplicateM_closure" {
     Control.Monad.$w$sreplicateM_closure:
         const Control.Monad.$w$sreplicateM_info;
 },
 $wloop_sc6Tc_entry() //  [R1, R2]
         { info_tbl: [(cc74W,
                       label: $wloop_sc6Tc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc74W: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc74X; else goto cc74Y;
       cc74X: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc74Y: // global
           if (%MO_S_Gt_W64(R2, 0)) goto cc74U; else goto cc74V;
       cc74U: // global
           I64[Sp - 24] = block_cc750_info;
           _sc6Tc::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sc6Tc::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc75y; else goto cc751;
       uc75y: // global
           call _cc750(R1) args: 0, res: 0, upd: 0;
       cc751: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cc74V: // global
           R1 = Control.Monad.replicateM1_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc750() //  [R1]
         { info_tbl: [(cc750,
                       label: block_cc750_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc750: // global
           if (R1 & 7 == 1) goto uc75w; else goto cc75f;
       uc75w: // global
           Sp = Sp + 24;
           call _cc75l() args: 0, res: 0, upd: 0;
       cc75f: // global
           _sc6Tc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc75e_info;
           R2 = I64[Sp + 16] - 1;
           _sc6Tg::P64 = P64[R1 + 6];
           R1 = _sc6Tc::P64;
           P64[Sp + 16] = _sc6Tg::P64;
           Sp = Sp + 8;
           call $wloop_sc6Tc_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc75e() //  [R1]
         { info_tbl: [(cc75e,
                       label: block_cc75e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc75e: // global
           if (R1 & 7 == 1) goto uc75x; else goto cc75q;
       uc75x: // global
           Sp = Sp + 16;
           call _cc75l() args: 0, res: 0, upd: 0;
       cc75q: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc75t; else goto cc75s;
       cc75t: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc75s: // global
           _sc6Tj::P64 = P64[R1 + 6];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sc6Tj::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc75l() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc75l: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.$w$sreplicateM_entry() //  [R2, R3]
         { info_tbl: [(cc75B,
                       label: Control.Monad.$w$sreplicateM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc75B: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc75F; else goto cc75E;
       cc75F: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$w$sreplicateM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc75E: // global
           I64[Hp - 8] = $wloop_sc6Tc_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call $wloop_sc6Tc_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.687286549 UTC

[section ""data" . Control.Monad.replicateM_$sreplicateM_closure" {
     Control.Monad.replicateM_$sreplicateM_closure:
         const Control.Monad.replicateM_$sreplicateM_info;
 },
 Control.Monad.replicateM_$sreplicateM_entry() //  [R2, R3]
         { info_tbl: [(cc75N,
                       label: Control.Monad.replicateM_$sreplicateM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc75N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc75O; else goto cc75P;
       cc75O: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM_$sreplicateM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc75P: // global
           I64[Sp - 16] = block_cc75K_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc75T; else goto cc75L;
       uc75T: // global
           call _cc75K(R1) args: 0, res: 0, upd: 0;
       cc75L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc75K() //  [R1]
         { info_tbl: [(cc75K,
                       label: block_cc75K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc75K: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Control.Monad.$w$sreplicateM_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.688641613 UTC

[section ""data" . Control.Monad.unless1_closure" {
     Control.Monad.unless1_closure:
         const Control.Monad.unless1_info;
 },
 Control.Monad.unless1_entry() //  [R2, R3]
         { info_tbl: [(cc765,
                       label: Control.Monad.unless1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc765: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc766; else goto cc767;
       cc766: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.unless1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc767: // global
           I64[Sp - 16] = block_cc75Y_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc76e; else goto cc75Z;
       uc76e: // global
           call _cc75Y(R1) args: 0, res: 0, upd: 0;
       cc75Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc75Y() //  [R1]
         { info_tbl: [(cc75Y,
                       label: block_cc75Y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc75Y: // global
           if (R1 & 7 == 1) goto cc762; else goto cc763;
       cc762: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       cc763: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.689908775 UTC

[section ""data" . Control.Monad.unless_$sunless1_closure" {
     Control.Monad.unless_$sunless1_closure:
         const Control.Monad.unless_$sunless1_info;
 },
 Control.Monad.unless_$sunless1_entry() //  [R2, R3]
         { info_tbl: [(cc76j,
                       label: Control.Monad.unless_$sunless1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc76j: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.unless1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.692212914 UTC

[section ""data" . Control.Monad.unless_closure" {
     Control.Monad.unless_closure:
         const Control.Monad.unless_info;
 },
 Control.Monad.unless_entry() //  [R2, R3, R4]
         { info_tbl: [(cc76x,
                       label: Control.Monad.unless_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc76x: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc76y; else goto cc76z;
       cc76y: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.unless_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc76z: // global
           I64[Sp - 24] = block_cc76q_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc76G; else goto cc76r;
       uc76G: // global
           call _cc76q(R1) args: 0, res: 0, upd: 0;
       cc76r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc76q() //  [R1]
         { info_tbl: [(cc76q,
                       label: block_cc76q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc76q: // global
           if (R1 & 7 == 1) goto cc76u; else goto cc76v;
       cc76u: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc76v: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.693722567 UTC

[section ""data" . Control.Monad.replicateM_1_closure" {
     Control.Monad.replicateM_1_closure:
         const Control.Monad.replicateM_1_info;
 },
 Control.Monad.replicateM_1_entry() //  [R2, R3]
         { info_tbl: [(cc76O,
                       label: Control.Monad.replicateM_1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc76O: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc76P; else goto cc76Q;
       cc76P: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM_1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc76Q: // global
           I64[Sp - 16] = block_cc76L_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc77d; else goto cc76M;
       uc77d: // global
           call _cc76L(R1) args: 0, res: 0, upd: 0;
       cc76M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc76L() //  [R1]
         { info_tbl: [(cc76L,
                       label: block_cc76L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc76L: // global
           I64[Sp] = I64[R1 + 7];
           call _cc76X() args: 0, res: 0, upd: 0;
     }
 },
 _cc76X() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc76X: // global
           if (%MO_S_Gt_W64(I64[Sp], 0)) goto cc775; else goto cc778;
       cc775: // global
           I64[Sp - 8] = block_cc773_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cc778: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc773() //  []
         { info_tbl: [(cc773,
                       label: block_cc773_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc773: // global
           I64[Sp + 8] = I64[Sp + 8] - 1;
           Sp = Sp + 8;
           call _cc76X() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.695142012 UTC

[section ""data" . Control.Monad.replicateM__$sreplicateM_1_closure" {
     Control.Monad.replicateM__$sreplicateM_1_closure:
         const Control.Monad.replicateM__$sreplicateM_1_info;
 },
 Control.Monad.replicateM__$sreplicateM_1_entry() //  [R2, R3]
         { info_tbl: [(cc77j,
                       label: Control.Monad.replicateM__$sreplicateM_1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc77j: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.replicateM_1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.696573128 UTC

[section ""data" . Control.Monad.$wreplicateM__closure" {
     Control.Monad.$wreplicateM__closure:
         const Control.Monad.$wreplicateM__info;
 },
 lvl_sc6TN_entry() //  [R1]
         { info_tbl: [(cc77u,
                       label: lvl_sc6TN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc77u: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc77v; else goto cc77w;
       cc77v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc77w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc6TS_entry() //  [R1]
         { info_tbl: [(cc77L,
                       label: sat_sc6TS_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc77L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc77M; else goto cc77N;
       cc77M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc77N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wloop_sc6TO_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wloop_sc6TO_entry() //  [R1, R2]
         { info_tbl: [(cc77R,
                       label: $wloop_sc6TO_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc77R: // global
           _sc6TP::I64 = R2;
           _sc6TO::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cc77S; else goto cc77T;
       cc77T: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc77V; else goto cc77U;
       cc77V: // global
           HpAlloc = 32;
           goto cc77S;
       cc77S: // global
           R2 = _sc6TP::I64;
           R1 = _sc6TO::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc77U: // global
           if (%MO_S_Gt_W64(_sc6TP::I64, 0)) goto cc77P; else goto cc77Q;
       cc77P: // global
           _sc6TK::P64 = P64[_sc6TO::P64 + 7];
           _sc6TM::P64 = P64[_sc6TO::P64 + 15];
           I64[Hp - 24] = sat_sc6TS_info;
           P64[Hp - 8] = _sc6TO::P64;
           I64[Hp] = _sc6TP::I64;
           R2 = _sc6TK::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sc6TM::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Base.*>_entry(R2) args: 32, res: 0, upd: 8;
       cc77Q: // global
           _sc6TN::P64 = P64[_sc6TO::P64 + 23];
           Hp = Hp - 32;
           R1 = _sc6TN::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.$wreplicateM__entry() //  [R2, R3, R4]
         { info_tbl: [(cc77W,
                       label: Control.Monad.$wreplicateM__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc77W: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc780; else goto cc77Z;
       cc780: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$wreplicateM__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc77Z: // global
           I64[Hp - 48] = lvl_sc6TN_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = $wloop_sc6TO_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 48;
           R2 = R3;
           R1 = Hp - 23;
           call $wloop_sc6TO_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.698667094 UTC

[section ""data" . Control.Monad.replicateM__closure" {
     Control.Monad.replicateM__closure:
         const Control.Monad.replicateM__info;
 },
 Control.Monad.replicateM__entry() //  [R2, R3, R4]
         { info_tbl: [(cc788,
                       label: Control.Monad.replicateM__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc788: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc789; else goto cc78a;
       cc789: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc78a: // global
           I64[Sp - 24] = block_cc785_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc78e; else goto cc786;
       uc78e: // global
           call _cc785(R1) args: 0, res: 0, upd: 0;
       cc786: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc785() //  [R1]
         { info_tbl: [(cc785,
                       label: block_cc785_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc785: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Control.Monad.$wreplicateM__entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.700293569 UTC

[section ""data" . Control.Monad.$w$sreplicateM1_closure" {
     Control.Monad.$w$sreplicateM1_closure:
         const Control.Monad.$w$sreplicateM1_info;
 },
 $wloop_sc6U1_entry() //  [R1, R2]
         { info_tbl: [(cc78t,
                       label: $wloop_sc6U1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc78t: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc78u; else goto cc78v;
       cc78u: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc78v: // global
           if (%MO_S_Gt_W64(R2, 0)) goto cc78r; else goto cc78s;
       cc78r: // global
           I64[Sp - 24] = block_cc78x_info;
           _sc6U1::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp - 16] = _sc6U1::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cc78s: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc78x() //  [R1]
         { info_tbl: [(cc78x,
                       label: block_cc78x_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc78x: // global
           _sc6U1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc78C_info;
           R2 = I64[Sp + 16] - 1;
           _sc6U7::P64 = R1;
           R1 = _sc6U1::P64;
           P64[Sp + 16] = _sc6U7::P64;
           Sp = Sp + 8;
           call $wloop_sc6U1_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc78C() //  [R1]
         { info_tbl: [(cc78C,
                       label: block_cc78C_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc78C: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc78I; else goto cc78H;
       cc78I: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc78H: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.$w$sreplicateM1_entry() //  [R2, R3]
         { info_tbl: [(cc78J,
                       label: Control.Monad.$w$sreplicateM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc78J: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc78N; else goto cc78M;
       cc78N: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$w$sreplicateM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc78M: // global
           I64[Hp - 8] = $wloop_sc6U1_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 6;
           call $wloop_sc6U1_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.702304177 UTC

[section ""data" . Control.Monad.replicateM2_closure" {
     Control.Monad.replicateM2_closure:
         const Control.Monad.replicateM2_info;
 },
 Control.Monad.replicateM2_entry() //  [R2, R3]
         { info_tbl: [(cc78V,
                       label: Control.Monad.replicateM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc78V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc78W; else goto cc78X;
       cc78W: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc78X: // global
           I64[Sp - 16] = block_cc78S_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc791; else goto cc78T;
       uc791: // global
           call _cc78S(R1) args: 0, res: 0, upd: 0;
       cc78T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc78S() //  [R1]
         { info_tbl: [(cc78S,
                       label: block_cc78S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc78S: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Control.Monad.$w$sreplicateM1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.703415466 UTC

[section ""data" . Control.Monad.replicateM_$sreplicateM1_closure" {
     Control.Monad.replicateM_$sreplicateM1_closure:
         const Control.Monad.replicateM_$sreplicateM1_info;
 },
 Control.Monad.replicateM_$sreplicateM1_entry() //  [R2, R3]
         { info_tbl: [(cc796,
                       label: Control.Monad.replicateM_$sreplicateM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc796: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.replicateM2_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.704828406 UTC

[section ""data" . Control.Monad.$wreplicateM_closure" {
     Control.Monad.$wreplicateM_closure:
         const Control.Monad.$wreplicateM_info;
 },
 lvl_sc6Ul_entry() //  [R1]
         { info_tbl: [(cc79h,
                       label: lvl_sc6Ul_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc79h: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc79i; else goto cc79j;
       cc79i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc79j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc6Uq_entry() //  [R1]
         { info_tbl: [(cc79y,
                       label: sat_sc6Uq_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc79y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc79z; else goto cc79A;
       cc79z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc79A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wloop_sc6Um_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wloop_sc6Um_entry() //  [R1, R2]
         { info_tbl: [(cc79E,
                       label: $wloop_sc6Um_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc79E: // global
           _sc6Un::I64 = R2;
           _sc6Um::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc79F; else goto cc79G;
       cc79G: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc79I; else goto cc79H;
       cc79I: // global
           HpAlloc = 32;
           goto cc79F;
       cc79F: // global
           R2 = _sc6Un::I64;
           R1 = _sc6Um::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc79H: // global
           if (%MO_S_Gt_W64(_sc6Un::I64, 0)) goto cc79C; else goto cc79D;
       cc79C: // global
           _sc6Ui::P64 = P64[_sc6Um::P64 + 7];
           _sc6Uk::P64 = P64[_sc6Um::P64 + 15];
           I64[Hp - 24] = sat_sc6Uq_info;
           P64[Hp - 8] = _sc6Um::P64;
           I64[Hp] = _sc6Un::I64;
           R2 = _sc6Ui::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           P64[Sp - 16] = _sc6Uk::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
       cc79D: // global
           _sc6Ul::P64 = P64[_sc6Um::P64 + 23];
           Hp = Hp - 32;
           R1 = _sc6Ul::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.$wreplicateM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc79J,
                       label: Control.Monad.$wreplicateM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc79J: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc79N; else goto cc79M;
       cc79N: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$wreplicateM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc79M: // global
           I64[Hp - 48] = lvl_sc6Ul_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = $wloop_sc6Um_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 48;
           R2 = R3;
           R1 = Hp - 23;
           call $wloop_sc6Um_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.706913803 UTC

[section ""data" . Control.Monad.replicateM_closure" {
     Control.Monad.replicateM_closure:
         const Control.Monad.replicateM_info;
 },
 Control.Monad.replicateM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc79V,
                       label: Control.Monad.replicateM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc79V: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc79W; else goto cc79X;
       cc79W: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc79X: // global
           I64[Sp - 24] = block_cc79S_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc7a1; else goto cc79T;
       uc7a1: // global
           call _cc79S(R1) args: 0, res: 0, upd: 0;
       cc79T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc79S() //  [R1]
         { info_tbl: [(cc79S,
                       label: block_cc79S_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc79S: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Control.Monad.$wreplicateM_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.70796688 UTC

[section ""relreadonly" . Sc7a2_srt" { Sc7a2_srt:
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.708485085 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:00.709365141 UTC

[section ""data" . Control.Monad.guard_closure" {
     Control.Monad.guard_closure:
         const Control.Monad.guard_info;
 },
 Control.Monad.guard_entry() //  [R2, R3]
         { info_tbl: [(cc7ae,
                       label: Control.Monad.guard_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7ae: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7af; else goto cc7ag;
       cc7af: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.guard_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7ag: // global
           I64[Sp - 16] = block_cc7a7_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7as; else goto cc7a8;
       uc7as: // global
           call _cc7a7(R1) args: 0, res: 0, upd: 0;
       cc7a8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7a7() //  [R1]
         { info_tbl: [(cc7a7,
                       label: block_cc7a7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7a7: // global
           _sc6QB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc7ab; else goto cc7ac;
       cc7ab: // global
           R2 = _sc6QB::P64;
           Sp = Sp + 16;
           call GHC.Base.empty_entry(R2) args: 8, res: 0, upd: 8;
       cc7ac: // global
           I64[Sp + 8] = block_cc7am_info;
           R2 = _sc6QB::P64;
           Sp = Sp + 8;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc7am() //  [R1]
         { info_tbl: [(cc7am,
                       label: block_cc7am_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7am: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Tuple.()_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.711670568 UTC

[section ""data" . Control.Monad.filterM_closure" {
     Control.Monad.filterM_closure:
         const Control.Monad.filterM_info;
 },
 z_sc6QH_entry() //  [R1]
         { info_tbl: [(cc7aB,
                       label: z_sc6QH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7aB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7aC; else goto cc7aD;
       cc7aC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7aD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc6QQ_entry() //  [R1, R2, R3]
         { info_tbl: [(cc7b3,
                       label: sat_sc6QQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7b3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7b4; else goto cc7b5;
       cc7b4: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7b5: // global
           I64[Sp - 24] = block_cc7aW_info;
           _sc6QL::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sc6QL::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc7bf; else goto cc7aX;
       uc7bf: // global
           call _cc7aW(R1) args: 0, res: 0, upd: 0;
       cc7aX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7aW() //  [R1]
         { info_tbl: [(cc7aW,
                       label: block_cc7aW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7aW: // global
           _sc6QO::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cc7b0; else goto cc7b1;
       cc7b0: // global
           R1 = _sc6QO::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc7b1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc7be; else goto cc7bd;
       cc7be: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7bd: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sc6QO::P64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sc6QI_entry() //  [R1, R2]
         { info_tbl: [(cc7bk,
                       label: go_sc6QI_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7bk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc7bl; else goto cc7bm;
       cc7bl: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7bm: // global
           I64[Sp - 40] = block_cc7aJ_info;
           _sc6QI::P64 = R1;
           _sc6QF::P64 = P64[R1 + 7];
           _sc6QG::P64 = P64[R1 + 15];
           _sc6QH::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sc6QF::P64;
           P64[Sp - 24] = _sc6QG::P64;
           P64[Sp - 16] = _sc6QH::P64;
           P64[Sp - 8] = _sc6QI::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc7bs; else goto cc7aK;
       uc7bs: // global
           call _cc7aJ(R1) args: 0, res: 0, upd: 0;
       cc7aK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7aJ() //  [R1]
         { info_tbl: [(cc7aJ,
                       label: block_cc7aJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7aJ: // global
           if (R1 & 7 == 1) goto cc7bh; else goto cc7bi;
       cc7bh: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc7bi: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc7br; else goto cc7bq;
       cc7br: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7bq: // global
           _sc6QL::P64 = P64[R1 + 6];
           _sc6QM::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 32];
           P64[Hp - 48] = _sc6QM::P64;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sc6QL::P64;
           I64[Hp - 8] = sat_sc6QQ_info;
           P64[Hp] = _sc6QL::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = Hp - 6;
           P64[Sp + 24] = Hp - 40;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Control.Monad.filterM_entry() //  [R2, R3]
         { info_tbl: [(cc7bt,
                       label: Control.Monad.filterM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7bt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7bx; else goto cc7bw;
       cc7bx: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.filterM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7bw: // global
           I64[Hp - 48] = z_sc6QH_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go_sc6QI_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.714465069 UTC

[section ""data" . Control.Monad.>=>_closure" {
     Control.Monad.>=>_closure:
         const Control.Monad.>=>_info;
 },
 Control.Monad.>=>_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc7bD,
                       label: Control.Monad.>=>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7bD: // global
           _sc6QW::P64 = R5;
           _sc6QV::P64 = R4;
           _sc6QU::P64 = R3;
           _sc6QT::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc7bE; else goto cc7bF;
       cc7bF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc7bH; else goto cc7bG;
       cc7bH: // global
           HpAlloc = 32;
           goto cc7bE;
       cc7bE: // global
           R5 = _sc6QW::P64;
           R4 = _sc6QV::P64;
           R3 = _sc6QU::P64;
           R2 = _sc6QT::P64;
           R1 = Control.Monad.>=>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7bG: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sc6QU::P64;
           P64[Hp] = _sc6QW::P64;
           R2 = _sc6QT::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sc6QV::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.715592627 UTC

[section ""data" . Control.Monad.<=<_closure" {
     Control.Monad.<=<_closure:
         const Control.Monad.<=<_info;
 },
 Control.Monad.<=<_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc7bM,
                       label: Control.Monad.<=<_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7bM: // global
           R5 = R5;
           _sc6R0::P64 = R4;
           R4 = R3;
           R3 = _sc6R0::P64;
           R2 = R2;
           call Control.Monad.>=>_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.716687301 UTC

[section ""data" . Control.Monad.forever_closure" {
     Control.Monad.forever_closure:
         const Control.Monad.forever_info;
 },
 a'_sc6R4_entry() //  [R1]
         { info_tbl: [(cc7bX,
                       label: a'_sc6R4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7bX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc7bY; else goto cc7bZ;
       cc7bY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7bZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = R1;
           Sp = Sp - 40;
           call GHC.Base.*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.forever_entry() //  [R2, R3]
         { info_tbl: [(cc7c0,
                       label: Control.Monad.forever_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7c0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc7c4; else goto cc7c3;
       cc7c4: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.forever_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7c3: // global
           I64[Hp - 24] = a'_sc6R4_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.718985081 UTC

[section ""data" . Control.Monad.mapAndUnzipM_closure" {
     Control.Monad.mapAndUnzipM_closure:
         const Control.Monad.mapAndUnzipM_info;
 },
 z_sc6R9_entry() //  [R1]
         { info_tbl: [(cc7ch,
                       label: z_sc6R9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7ch: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7ci; else goto cc7cj;
       cc7ci: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7cj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sc6Ra_entry() //  [R1, R2]
         { info_tbl: [(cc7cw,
                       label: go_sc6Ra_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7cw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc7cx; else goto cc7cy;
       cc7cx: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7cy: // global
           I64[Sp - 40] = block_cc7cp_info;
           _sc6Ra::P64 = R1;
           _sc6R5::P64 = P64[R1 + 7];
           _sc6R6::P64 = P64[R1 + 15];
           _sc6R9::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sc6R5::P64;
           P64[Sp - 24] = _sc6R6::P64;
           P64[Sp - 16] = _sc6R9::P64;
           P64[Sp - 8] = _sc6Ra::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc7cJ; else goto cc7cq;
       uc7cJ: // global
           call _cc7cp(R1) args: 0, res: 0, upd: 0;
       cc7cq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7cp() //  [R1]
         { info_tbl: [(cc7cp,
                       label: block_cc7cp_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7cp: // global
           if (R1 & 7 == 1) goto cc7ct; else goto cc7cu;
       cc7ct: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc7cu: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc7cG; else goto cc7cF;
       cc7cG: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7cF: // global
           _sc6Rd::P64 = P64[R1 + 6];
           _sc6Re::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sc6Re::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sc6Rd::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sc6Rh_entry() //  [R1]
         { info_tbl: [(cc7cK,
                       label: sat_sc6Rh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7cK: // global
           _sc6Rh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc7cL; else goto cc7cM;
       cc7cM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7cO; else goto cc7cN;
       cc7cO: // global
           HpAlloc = 56;
           goto cc7cL;
       cc7cL: // global
           R1 = _sc6Rh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7cN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc6Rh::P64;
           _sc6R5::P64 = P64[_sc6Rh::P64 + 16];
           _sc6R6::P64 = P64[_sc6Rh::P64 + 24];
           _sc6R7::P64 = P64[_sc6Rh::P64 + 32];
           I64[Hp - 48] = z_sc6R9_info;
           P64[Hp - 32] = _sc6R5::P64;
           I64[Hp - 24] = go_sc6Ra_info;
           P64[Hp - 16] = _sc6R5::P64;
           P64[Hp - 8] = _sc6R6::P64;
           P64[Hp] = Hp - 48;
           R2 = _sc6R7::P64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call go_sc6Ra_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.mapAndUnzipM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7cR,
                       label: Control.Monad.mapAndUnzipM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7cR: // global
           _sc6R7::P64 = R4;
           _sc6R6::P64 = R3;
           _sc6R5::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc7cS; else goto cc7cT;
       cc7cT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc7cV; else goto cc7cU;
       cc7cV: // global
           HpAlloc = 40;
           goto cc7cS;
       cc7cS: // global
           R4 = _sc6R7::P64;
           R3 = _sc6R6::P64;
           R2 = _sc6R5::P64;
           R1 = Control.Monad.mapAndUnzipM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7cU: // global
           I64[Hp - 32] = sat_sc6Rh_info;
           P64[Hp - 16] = _sc6R5::P64;
           P64[Hp - 8] = _sc6R6::P64;
           P64[Hp] = _sc6R7::P64;
           I64[Sp - 16] = block_cc7cP_info;
           R2 = _sc6R5::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc7cP() //  [R1]
         { info_tbl: [(cc7cP,
                       label: block_cc7cP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7cP: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.List.unzip_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.722522722 UTC

[section ""data" . Control.Monad.zipWithM_closure" {
     Control.Monad.zipWithM_closure:
         const Control.Monad.zipWithM_info;
 },
 z_sc6Rm_entry() //  [R1]
         { info_tbl: [(cc7d7,
                       label: z_sc6Rm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7d7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7d8; else goto cc7d9;
       cc7d8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7d9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go2_sc6Rn_entry() //  [R1, R2, R3]
         { info_tbl: [(cc7dm,
                       label: go2_sc6Rn_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7dm: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cc7dn; else goto cc7do;
       cc7dn: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7do: // global
           I64[Sp - 48] = block_cc7df_info;
           _sc6Rn::P64 = R1;
           _sc6Ri::P64 = P64[R1 + 6];
           _sc6Rj::P64 = P64[R1 + 14];
           _sc6Rm::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _sc6Ri::P64;
           P64[Sp - 32] = _sc6Rj::P64;
           P64[Sp - 24] = _sc6Rm::P64;
           P64[Sp - 16] = _sc6Rn::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uc7dQ; else goto cc7dg;
       uc7dQ: // global
           call _cc7df(R1) args: 0, res: 0, upd: 0;
       cc7dg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7df() //  [R1]
         { info_tbl: [(cc7df,
                       label: block_cc7df_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7df: // global
           if (R1 & 7 == 1) goto uc7dM; else goto cc7dk;
       uc7dM: // global
           Sp = Sp + 24;
           call _cc7dC() args: 0, res: 0, upd: 0;
       cc7dk: // global
           I64[Sp - 8] = block_cc7du_info;
           _sc6Rr::P64 = P64[R1 + 6];
           _sc6Rs::P64 = P64[R1 + 14];
           R1 = P64[Sp + 40];
           P64[Sp] = _sc6Rs::P64;
           P64[Sp + 40] = _sc6Rr::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7dO; else goto cc7dw;
       uc7dO: // global
           call _cc7du(R1) args: 0, res: 0, upd: 0;
       cc7dw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7du() //  [R1]
         { info_tbl: [(cc7du,
                       label: block_cc7du_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7du: // global
           if (R1 & 7 == 1) goto uc7dN; else goto cc7dD;
       uc7dN: // global
           Sp = Sp + 32;
           call _cc7dC() args: 0, res: 0, upd: 0;
       cc7dD: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc7dI; else goto cc7dH;
       cc7dI: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7dH: // global
           _sc6Ru::P64 = P64[R1 + 6];
           _sc6Rv::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _sc6Rv::P64;
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = _sc6Ru::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_ppp_info;
           P64[Sp + 32] = GHC.Types.:_closure+2;
           P64[Sp + 40] = Hp - 32;
           P64[Sp + 48] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cc7dC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7dC: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.zipWithM_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc7dS,
                       label: Control.Monad.zipWithM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7dS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7dW; else goto cc7dV;
       cc7dW: // global
           HpAlloc = 56;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.zipWithM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7dV: // global
           I64[Hp - 48] = z_sc6Rm_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go2_sc6Rn_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R3 = R5;
           R2 = R4;
           R1 = Hp - 22;
           call go2_sc6Rn_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.725914426 UTC

[section ""data" . Control.Monad.zipWithM__closure" {
     Control.Monad.zipWithM__closure:
         const Control.Monad.zipWithM__info;
 },
 z_sc6RC_entry() //  [R1]
         { info_tbl: [(cc7e5,
                       label: z_sc6RC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7e5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7e6; else goto cc7e7;
       cc7e6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7e7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go2_sc6RD_entry() //  [R1, R2, R3]
         { info_tbl: [(cc7ek,
                       label: go2_sc6RD_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7ek: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cc7el; else goto cc7em;
       cc7el: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7em: // global
           I64[Sp - 48] = block_cc7ed_info;
           _sc6RD::P64 = R1;
           _sc6Ry::P64 = P64[R1 + 6];
           _sc6Rz::P64 = P64[R1 + 14];
           _sc6RC::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _sc6Ry::P64;
           P64[Sp - 32] = _sc6Rz::P64;
           P64[Sp - 24] = _sc6RC::P64;
           P64[Sp - 16] = _sc6RD::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uc7eO; else goto cc7ee;
       uc7eO: // global
           call _cc7ed(R1) args: 0, res: 0, upd: 0;
       cc7ee: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7ed() //  [R1]
         { info_tbl: [(cc7ed,
                       label: block_cc7ed_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7ed: // global
           if (R1 & 7 == 1) goto uc7eK; else goto cc7ei;
       uc7eK: // global
           Sp = Sp + 24;
           call _cc7eA() args: 0, res: 0, upd: 0;
       cc7ei: // global
           I64[Sp - 8] = block_cc7es_info;
           _sc6RH::P64 = P64[R1 + 6];
           _sc6RI::P64 = P64[R1 + 14];
           R1 = P64[Sp + 40];
           P64[Sp] = _sc6RI::P64;
           P64[Sp + 40] = _sc6RH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7eM; else goto cc7eu;
       uc7eM: // global
           call _cc7es(R1) args: 0, res: 0, upd: 0;
       cc7eu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7es() //  [R1]
         { info_tbl: [(cc7es,
                       label: block_cc7es_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7es: // global
           if (R1 & 7 == 1) goto uc7eL; else goto cc7eB;
       uc7eL: // global
           Sp = Sp + 32;
           call _cc7eA() args: 0, res: 0, upd: 0;
       cc7eB: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc7eG; else goto cc7eF;
       cc7eG: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7eF: // global
           _sc6RK::P64 = P64[R1 + 6];
           _sc6RL::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _sc6RL::P64;
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = _sc6RK::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 32;
           P64[Sp + 48] = Hp - 72;
           Sp = Sp + 32;
           call GHC.Base.*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cc7eA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7eA: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.zipWithM__entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc7eQ,
                       label: Control.Monad.zipWithM__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7eQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7eU; else goto cc7eT;
       cc7eU: // global
           HpAlloc = 56;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.zipWithM__closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7eT: // global
           I64[Hp - 48] = z_sc6RC_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go2_sc6RD_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R3 = R5;
           R2 = R4;
           R1 = Hp - 22;
           call go2_sc6RD_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.729029246 UTC

[section ""data" . Control.Monad.foldM_$sfoldM_closure" {
     Control.Monad.foldM_$sfoldM_closure:
         const Control.Monad.foldM_$sfoldM_info;
 },
 Control.Monad.foldM_$sfoldM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7f1,
                       label: Control.Monad.foldM_$sfoldM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7f1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7f2; else goto cc7f3;
       cc7f2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM_$sfoldM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7f3: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc7f5() args: 0, res: 0, upd: 0;
     }
 },
 _cc7f5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7f5: // global
           I64[Sp - 8] = block_cc7f7_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7fD; else goto cc7f9;
       uc7fD: // global
           call _cc7f7(R1) args: 0, res: 0, upd: 0;
       cc7f9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7f7() //  [R1]
         { info_tbl: [(cc7f7,
                       label: block_cc7f7_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7f7: // global
           _sc6RT::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cc7ff; else goto cc7fn;
       cc7ff: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc7fi; else goto cc7fh;
       cc7fi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7fh: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sc6RT::P64;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7fn: // global
           I64[Sp] = block_cc7fl_info;
           R3 = P64[R1 + 6];
           R2 = _sc6RT::P64;
           _sc6RW::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc6RW::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7fl() //  [R1]
         { info_tbl: [(cc7fl,
                       label: block_cc7fl_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7fl: // global
           if (R1 & 7 == 1) goto cc7ft; else goto cc7fx;
       cc7ft: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7fx: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           Sp = Sp + 8;
           call _cc7f5() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.731185566 UTC

[section ""data" . Control.Monad.foldM1_closure" {
     Control.Monad.foldM1_closure:
         const Control.Monad.foldM1_info;
 },
 Control.Monad.foldM1_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7fL,
                       label: Control.Monad.foldM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7fL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7fM; else goto cc7fN;
       cc7fM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7fN: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc7fP() args: 0, res: 0, upd: 0;
     }
 },
 _cc7fP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7fP: // global
           I64[Sp - 8] = block_cc7fR_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7gb; else goto cc7fT;
       uc7gb: // global
           call _cc7fR(R1) args: 0, res: 0, upd: 0;
       cc7fT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7fR() //  [R1]
         { info_tbl: [(cc7fR,
                       label: block_cc7fR_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7fR: // global
           _sc6S5::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cc7fZ; else goto cc7g4;
       cc7fZ: // global
           R1 = _sc6S5::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7g4: // global
           I64[Sp] = block_cc7g2_info;
           R3 = P64[R1 + 6];
           R2 = _sc6S5::P64;
           _sc6S9::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc6S9::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7g2() //  [R1]
         { info_tbl: [(cc7g2,
                       label: block_cc7g2_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7g2: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cc7fP() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.734098946 UTC

[section ""data" . Control.Monad.foldM_$sfoldM1_closure" {
     Control.Monad.foldM_$sfoldM1_closure:
         const Control.Monad.foldM_$sfoldM1_info;
 },
 Control.Monad.foldM_$sfoldM1_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7gh,
                       label: Control.Monad.foldM_$sfoldM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7gh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Control.Monad.foldM1_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.734956041 UTC

[section ""data" . Control.Monad.foldM_closure" {
     Control.Monad.foldM_closure:
         const Control.Monad.foldM_info;
 },
 Control.Monad.foldM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cc7go,
                       label: Control.Monad.foldM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7go: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Foldable.foldlM_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.735721416 UTC

[section ""data" . Control.Monad.foldM_1_closure" {
     Control.Monad.foldM_1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Tuple.()_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.736808189 UTC

[section ""data" . Control.Monad.foldM__$sfoldM__closure" {
     Control.Monad.foldM__$sfoldM__closure:
         const Control.Monad.foldM__$sfoldM__info;
 },
 Control.Monad.foldM__$sfoldM__entry() //  [R2, R3, R4]
         { info_tbl: [(cc7gx,
                       label: Control.Monad.foldM__$sfoldM__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7gx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7gy; else goto cc7gz;
       cc7gy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM__$sfoldM__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7gz: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc7gB() args: 0, res: 0, upd: 0;
     }
 },
 _cc7gB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7gB: // global
           I64[Sp - 8] = block_cc7gD_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7h6; else goto cc7gF;
       uc7h6: // global
           call _cc7gD(R1) args: 0, res: 0, upd: 0;
       cc7gF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7gD() //  [R1]
         { info_tbl: [(cc7gD,
                       label: block_cc7gD_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7gD: // global
           if (R1 & 7 == 1) goto cc7gL; else goto cc7gQ;
       cc7gL: // global
           R1 = Control.Monad.foldM_1_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7gQ: // global
           I64[Sp] = block_cc7gO_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sc6Sl::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc6Sl::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7gO() //  [R1]
         { info_tbl: [(cc7gO,
                       label: block_cc7gO_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7gO: // global
           if (R1 & 7 == 1) goto cc7gW; else goto cc7h0;
       cc7gW: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7h0: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           Sp = Sp + 8;
           call _cc7gB() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.738945084 UTC

[section ""data" . Control.Monad.foldM_2_closure" {
     Control.Monad.foldM_2_closure:
         const Control.Monad.foldM_2_info;
 },
 Control.Monad.foldM_2_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7he,
                       label: Control.Monad.foldM_2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7he: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7hf; else goto cc7hg;
       cc7hf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM_2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7hg: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc7hi() args: 0, res: 0, upd: 0;
     }
 },
 _cc7hi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7hi: // global
           I64[Sp - 8] = block_cc7hk_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7hE; else goto cc7hm;
       uc7hE: // global
           call _cc7hk(R1) args: 0, res: 0, upd: 0;
       cc7hm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7hk() //  [R1]
         { info_tbl: [(cc7hk,
                       label: block_cc7hk_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7hk: // global
           if (R1 & 7 == 1) goto cc7hs; else goto cc7hx;
       cc7hs: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7hx: // global
           I64[Sp] = block_cc7hv_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sc6Sy::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc6Sy::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7hv() //  [R1]
         { info_tbl: [(cc7hv,
                       label: block_cc7hv_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7hv: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cc7hi() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.740402202 UTC

[section ""data" . Control.Monad.foldM__$sfoldM_1_closure" {
     Control.Monad.foldM__$sfoldM_1_closure:
         const Control.Monad.foldM__$sfoldM_1_info;
 },
 Control.Monad.foldM__$sfoldM_1_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7hK,
                       label: Control.Monad.foldM__$sfoldM_1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7hK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Control.Monad.foldM_2_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.741543067 UTC

[section ""data" . Control.Monad.foldM__closure" {
     Control.Monad.foldM__closure:
         const Control.Monad.foldM__info;
 },
 sat_sc6SI_entry() //  [R1]
         { info_tbl: [(cc7hV,
                       label: sat_sc6SI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7hV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7hW; else goto cc7hX;
       cc7hW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7hX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc6SH_entry() //  [R1]
         { info_tbl: [(cc7i2,
                       label: sat_sc6SH_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7i2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7i3; else goto cc7i4;
       cc7i3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7i4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Foldable.foldlM_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.foldM__entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cc7i5,
                       label: Control.Monad.foldM__info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7i5: // global
           _sc6SG::P64 = R6;
           _sc6SF::P64 = R5;
           _sc6SE::P64 = R4;
           _sc6SD::P64 = R3;
           _sc6SC::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc7i6; else goto cc7i7;
       cc7i7: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc7i9; else goto cc7i8;
       cc7i9: // global
           HpAlloc = 80;
           goto cc7i6;
       cc7i6: // global
           R6 = _sc6SG::P64;
           R5 = _sc6SF::P64;
           R4 = _sc6SE::P64;
           R3 = _sc6SD::P64;
           R2 = _sc6SC::P64;
           R1 = Control.Monad.foldM__closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7i8: // global
           I64[Hp - 72] = sat_sc6SI_info;
           P64[Hp - 56] = _sc6SD::P64;
           I64[Hp - 48] = sat_sc6SH_info;
           P64[Hp - 32] = _sc6SC::P64;
           P64[Hp - 24] = _sc6SD::P64;
           P64[Hp - 16] = _sc6SE::P64;
           P64[Hp - 8] = _sc6SF::P64;
           P64[Hp] = _sc6SG::P64;
           R2 = _sc6SD::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 48;
           P64[Sp - 8] = Hp - 72;
           Sp = Sp - 24;
           call GHC.Base.>>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.743506367 UTC

[section ""data" . Control.Monad.<$!>_closure" {
     Control.Monad.<$!>_closure:
         const Control.Monad.<$!>_info;
 },
 sat_sc6SO_entry() //  [R1, R2]
         { info_tbl: [(cc7il,
                       label: sat_sc6SO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7il: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7im; else goto cc7in;
       cc7im: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7in: // global
           I64[Sp - 16] = block_cc7ij_info;
           R2 = R2;
           _sc6SJ::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _sc6SJ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7ij() //  [R1]
         { info_tbl: [(cc7ij,
                       label: block_cc7ij_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7ij: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Monad.<$!>_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7ip,
                       label: Control.Monad.<$!>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7ip: // global
           _sc6SL::P64 = R4;
           _sc6SK::P64 = R3;
           _sc6SJ::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc7iq; else goto cc7ir;
       cc7ir: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc7it; else goto cc7is;
       cc7it: // global
           HpAlloc = 24;
           goto cc7iq;
       cc7iq: // global
           R4 = _sc6SL::P64;
           R3 = _sc6SK::P64;
           R2 = _sc6SJ::P64;
           R1 = Control.Monad.<$!>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7is: // global
           I64[Hp - 16] = sat_sc6SO_info;
           P64[Hp - 8] = _sc6SJ::P64;
           P64[Hp] = _sc6SK::P64;
           R2 = _sc6SJ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sc6SL::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.74557689 UTC

[section ""data" . Control.Monad.mfilter_closure" {
     Control.Monad.mfilter_closure:
         const Control.Monad.mfilter_info;
 },
 lvl_sc6SS_entry() //  [R1]
         { info_tbl: [(cc7iC,
                       label: lvl_sc6SS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7iC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7iD; else goto cc7iE;
       cc7iD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7iE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc6SW_entry() //  [R1, R2]
         { info_tbl: [(cc7iU,
                       label: sat_sc6SW_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7iU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7iV; else goto cc7iW;
       cc7iV: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7iW: // global
           I64[Sp - 32] = block_cc7iO_info;
           _sc6SU::P64 = R2;
           R2 = R2;
           _sc6SS::P64 = P64[R1 + 15];
           _sc6ST::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 24] = _sc6SS::P64;
           P64[Sp - 16] = _sc6ST::P64;
           P64[Sp - 8] = _sc6SU::P64;
           Sp = Sp - 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7iO() //  [R1]
         { info_tbl: [(cc7iO,
                       label: block_cc7iO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7iO: // global
           if (R1 & 7 == 1) goto cc7iR; else goto cc7iS;
       cc7iR: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc7iS: // global
           R2 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_p_info;
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Monad.mfilter_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7j3,
                       label: Control.Monad.mfilter_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7j3: // global
           _sc6SR::P64 = R4;
           _sc6SQ::P64 = R3;
           _sc6SP::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cc7j4; else goto cc7j5;
       cc7j5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc7j7; else goto cc7j6;
       cc7j7: // global
           HpAlloc = 24;
           goto cc7j4;
       cc7j4: // global
           R4 = _sc6SR::P64;
           R3 = _sc6SQ::P64;
           R2 = _sc6SP::P64;
           R1 = Control.Monad.mfilter_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7j6: // global
           I64[Hp - 16] = lvl_sc6SS_info;
           P64[Hp] = _sc6SP::P64;
           I64[Sp - 32] = block_cc7iF_info;
           R2 = _sc6SP::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sc6SQ::P64;
           P64[Sp - 8] = _sc6SR::P64;
           Sp = Sp - 32;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc7iF() //  [R1]
         { info_tbl: [(cc7iF,
                       label: block_cc7iF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7iF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc7ja; else goto cc7j9;
       cc7ja: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7j9: // global
           I64[Hp - 24] = sat_sc6SW_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = Hp - 23;
           Sp = Sp + 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.747481301 UTC

[section ""cstring" . Control.Monad.$trModule4_bytes" {
     Control.Monad.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.748025191 UTC

[section ""data" . Control.Monad.$trModule3_closure" {
     Control.Monad.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.748586546 UTC

[section ""cstring" . Control.Monad.$trModule2_bytes" {
     Control.Monad.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.749160392 UTC

[section ""data" . Control.Monad.$trModule1_closure" {
     Control.Monad.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.749743419 UTC

[section ""data" . Control.Monad.$trModule_closure" {
     Control.Monad.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.$trModule3_closure+1;
         const Control.Monad.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.750583409 UTC

[section ""data" . Control.Monad.unless_$sunless_closure" {
     Control.Monad.unless_$sunless_closure:
         const Control.Monad.unless_$sunless_info;
 },
 Control.Monad.unless_$sunless_entry() //  [R2, R3]
         { info_tbl: [(cc7jm,
                       label: Control.Monad.unless_$sunless_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7jm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7jn; else goto cc7jo;
       cc7jn: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.unless_$sunless_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7jo: // global
           I64[Sp - 16] = block_cc7jf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7jv; else goto cc7jg;
       uc7jv: // global
           call _cc7jf(R1) args: 0, res: 0, upd: 0;
       cc7jg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7jf() //  [R1]
         { info_tbl: [(cc7jf,
                       label: block_cc7jf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7jf: // global
           if (R1 & 7 == 1) goto cc7jj; else goto cc7jk;
       cc7jj: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc7jk: // global
           R1 = Control.Monad.foldM_1_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.752185086 UTC

[section ""data" . Control.Monad.replicateM__$sreplicateM__closure" {
     Control.Monad.replicateM__$sreplicateM__closure:
         const Control.Monad.replicateM__$sreplicateM__info;
 },
 Control.Monad.replicateM__$sreplicateM__entry() //  [R2, R3]
         { info_tbl: [(cc7jD,
                       label: Control.Monad.replicateM__$sreplicateM__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7jD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7jE; else goto cc7jF;
       cc7jE: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM__$sreplicateM__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7jF: // global
           I64[Sp - 16] = block_cc7jA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7kc; else goto cc7jB;
       uc7kc: // global
           call _cc7jA(R1) args: 0, res: 0, upd: 0;
       cc7jB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7jA() //  [R1]
         { info_tbl: [(cc7jA,
                       label: block_cc7jA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7jA: // global
           I64[Sp] = I64[R1 + 7];
           call _cc7jM() args: 0, res: 0, upd: 0;
     }
 },
 _cc7jM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7jM: // global
           if (%MO_S_Gt_W64(I64[Sp], 0)) goto cc7jU; else goto cc7k6;
       cc7jU: // global
           I64[Sp - 8] = block_cc7jS_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7kd; else goto cc7jV;
       uc7kd: // global
           call _cc7jS(R1) args: 0, res: 0, upd: 0;
       cc7jV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cc7k6: // global
           R1 = Control.Monad.foldM_1_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc7jS() //  [R1]
         { info_tbl: [(cc7jS,
                       label: block_cc7jS_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7jS: // global
           if (R1 & 7 == 1) goto cc7k1; else goto cc7k5;
       cc7k1: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7k5: // global
           I64[Sp + 8] = I64[Sp + 8] - 1;
           Sp = Sp + 8;
           call _cc7jM() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.753849027 UTC

[section ""data" . Control.Monad.replicateM1_closure" {
     Control.Monad.replicateM1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.755214817 UTC

[section ""data" . Control.Monad.$w$sreplicateM_closure" {
     Control.Monad.$w$sreplicateM_closure:
         const Control.Monad.$w$sreplicateM_info;
 },
 $wloop_sc6Tc_entry() //  [R1, R2]
         { info_tbl: [(cc7kt,
                       label: $wloop_sc6Tc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7kt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7ku; else goto cc7kv;
       cc7ku: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7kv: // global
           if (%MO_S_Gt_W64(R2, 0)) goto cc7kr; else goto cc7ks;
       cc7kr: // global
           I64[Sp - 24] = block_cc7kx_info;
           _sc6Tc::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sc6Tc::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc7l5; else goto cc7ky;
       uc7l5: // global
           call _cc7kx(R1) args: 0, res: 0, upd: 0;
       cc7ky: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cc7ks: // global
           R1 = Control.Monad.replicateM1_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc7kx() //  [R1]
         { info_tbl: [(cc7kx,
                       label: block_cc7kx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7kx: // global
           if (R1 & 7 == 1) goto uc7l3; else goto cc7kM;
       uc7l3: // global
           Sp = Sp + 24;
           call _cc7kS() args: 0, res: 0, upd: 0;
       cc7kM: // global
           _sc6Tc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc7kL_info;
           R2 = I64[Sp + 16] - 1;
           _sc6Tg::P64 = P64[R1 + 6];
           R1 = _sc6Tc::P64;
           P64[Sp + 16] = _sc6Tg::P64;
           Sp = Sp + 8;
           call $wloop_sc6Tc_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7kL() //  [R1]
         { info_tbl: [(cc7kL,
                       label: block_cc7kL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7kL: // global
           if (R1 & 7 == 1) goto uc7l4; else goto cc7kX;
       uc7l4: // global
           Sp = Sp + 16;
           call _cc7kS() args: 0, res: 0, upd: 0;
       cc7kX: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc7l0; else goto cc7kZ;
       cc7l0: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7kZ: // global
           _sc6Tj::P64 = P64[R1 + 6];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sc6Tj::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc7kS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7kS: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.$w$sreplicateM_entry() //  [R2, R3]
         { info_tbl: [(cc7l8,
                       label: Control.Monad.$w$sreplicateM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7l8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc7lc; else goto cc7lb;
       cc7lc: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$w$sreplicateM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7lb: // global
           I64[Hp - 8] = $wloop_sc6Tc_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call $wloop_sc6Tc_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.757405165 UTC

[section ""data" . Control.Monad.replicateM_$sreplicateM_closure" {
     Control.Monad.replicateM_$sreplicateM_closure:
         const Control.Monad.replicateM_$sreplicateM_info;
 },
 Control.Monad.replicateM_$sreplicateM_entry() //  [R2, R3]
         { info_tbl: [(cc7lk,
                       label: Control.Monad.replicateM_$sreplicateM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7lk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7ll; else goto cc7lm;
       cc7ll: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM_$sreplicateM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7lm: // global
           I64[Sp - 16] = block_cc7lh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7lq; else goto cc7li;
       uc7lq: // global
           call _cc7lh(R1) args: 0, res: 0, upd: 0;
       cc7li: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7lh() //  [R1]
         { info_tbl: [(cc7lh,
                       label: block_cc7lh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7lh: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Control.Monad.$w$sreplicateM_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.758733217 UTC

[section ""data" . Control.Monad.unless1_closure" {
     Control.Monad.unless1_closure:
         const Control.Monad.unless1_info;
 },
 Control.Monad.unless1_entry() //  [R2, R3]
         { info_tbl: [(cc7lC,
                       label: Control.Monad.unless1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7lC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7lD; else goto cc7lE;
       cc7lD: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.unless1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7lE: // global
           I64[Sp - 16] = block_cc7lv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7lL; else goto cc7lw;
       uc7lL: // global
           call _cc7lv(R1) args: 0, res: 0, upd: 0;
       cc7lw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7lv() //  [R1]
         { info_tbl: [(cc7lv,
                       label: block_cc7lv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7lv: // global
           if (R1 & 7 == 1) goto cc7lz; else goto cc7lA;
       cc7lz: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       cc7lA: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.759925197 UTC

[section ""data" . Control.Monad.unless_$sunless1_closure" {
     Control.Monad.unless_$sunless1_closure:
         const Control.Monad.unless_$sunless1_info;
 },
 Control.Monad.unless_$sunless1_entry() //  [R2, R3]
         { info_tbl: [(cc7lQ,
                       label: Control.Monad.unless_$sunless1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7lQ: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.unless1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.760932997 UTC

[section ""data" . Control.Monad.unless_closure" {
     Control.Monad.unless_closure:
         const Control.Monad.unless_info;
 },
 Control.Monad.unless_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7m4,
                       label: Control.Monad.unless_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7m4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7m5; else goto cc7m6;
       cc7m5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.unless_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7m6: // global
           I64[Sp - 24] = block_cc7lX_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc7md; else goto cc7lY;
       uc7md: // global
           call _cc7lX(R1) args: 0, res: 0, upd: 0;
       cc7lY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7lX() //  [R1]
         { info_tbl: [(cc7lX,
                       label: block_cc7lX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7lX: // global
           if (R1 & 7 == 1) goto cc7m1; else goto cc7m2;
       cc7m1: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc7m2: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.762490529 UTC

[section ""data" . Control.Monad.replicateM_1_closure" {
     Control.Monad.replicateM_1_closure:
         const Control.Monad.replicateM_1_info;
 },
 Control.Monad.replicateM_1_entry() //  [R2, R3]
         { info_tbl: [(cc7ml,
                       label: Control.Monad.replicateM_1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7ml: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7mm; else goto cc7mn;
       cc7mm: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM_1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7mn: // global
           I64[Sp - 16] = block_cc7mi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7mK; else goto cc7mj;
       uc7mK: // global
           call _cc7mi(R1) args: 0, res: 0, upd: 0;
       cc7mj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7mi() //  [R1]
         { info_tbl: [(cc7mi,
                       label: block_cc7mi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7mi: // global
           I64[Sp] = I64[R1 + 7];
           call _cc7mu() args: 0, res: 0, upd: 0;
     }
 },
 _cc7mu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7mu: // global
           if (%MO_S_Gt_W64(I64[Sp], 0)) goto cc7mC; else goto cc7mF;
       cc7mC: // global
           I64[Sp - 8] = block_cc7mA_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cc7mF: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc7mA() //  []
         { info_tbl: [(cc7mA,
                       label: block_cc7mA_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7mA: // global
           I64[Sp + 8] = I64[Sp + 8] - 1;
           Sp = Sp + 8;
           call _cc7mu() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.763900565 UTC

[section ""data" . Control.Monad.replicateM__$sreplicateM_1_closure" {
     Control.Monad.replicateM__$sreplicateM_1_closure:
         const Control.Monad.replicateM__$sreplicateM_1_info;
 },
 Control.Monad.replicateM__$sreplicateM_1_entry() //  [R2, R3]
         { info_tbl: [(cc7mQ,
                       label: Control.Monad.replicateM__$sreplicateM_1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7mQ: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.replicateM_1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.765376129 UTC

[section ""data" . Control.Monad.$wreplicateM__closure" {
     Control.Monad.$wreplicateM__closure:
         const Control.Monad.$wreplicateM__info;
 },
 lvl_sc6TN_entry() //  [R1]
         { info_tbl: [(cc7n1,
                       label: lvl_sc6TN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7n1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7n2; else goto cc7n3;
       cc7n2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7n3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc6TS_entry() //  [R1]
         { info_tbl: [(cc7ni,
                       label: sat_sc6TS_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7ni: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7nj; else goto cc7nk;
       cc7nj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7nk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wloop_sc6TO_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wloop_sc6TO_entry() //  [R1, R2]
         { info_tbl: [(cc7no,
                       label: $wloop_sc6TO_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7no: // global
           _sc6TP::I64 = R2;
           _sc6TO::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cc7np; else goto cc7nq;
       cc7nq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc7ns; else goto cc7nr;
       cc7ns: // global
           HpAlloc = 32;
           goto cc7np;
       cc7np: // global
           R2 = _sc6TP::I64;
           R1 = _sc6TO::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7nr: // global
           if (%MO_S_Gt_W64(_sc6TP::I64, 0)) goto cc7nm; else goto cc7nn;
       cc7nm: // global
           _sc6TK::P64 = P64[_sc6TO::P64 + 7];
           _sc6TM::P64 = P64[_sc6TO::P64 + 15];
           I64[Hp - 24] = sat_sc6TS_info;
           P64[Hp - 8] = _sc6TO::P64;
           I64[Hp] = _sc6TP::I64;
           R2 = _sc6TK::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sc6TM::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Base.*>_entry(R2) args: 32, res: 0, upd: 8;
       cc7nn: // global
           _sc6TN::P64 = P64[_sc6TO::P64 + 23];
           Hp = Hp - 32;
           R1 = _sc6TN::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.$wreplicateM__entry() //  [R2, R3, R4]
         { info_tbl: [(cc7nt,
                       label: Control.Monad.$wreplicateM__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7nt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7nx; else goto cc7nw;
       cc7nx: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$wreplicateM__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7nw: // global
           I64[Hp - 48] = lvl_sc6TN_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = $wloop_sc6TO_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 48;
           R2 = R3;
           R1 = Hp - 23;
           call $wloop_sc6TO_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.767550399 UTC

[section ""data" . Control.Monad.replicateM__closure" {
     Control.Monad.replicateM__closure:
         const Control.Monad.replicateM__info;
 },
 Control.Monad.replicateM__entry() //  [R2, R3, R4]
         { info_tbl: [(cc7nF,
                       label: Control.Monad.replicateM__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7nF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7nG; else goto cc7nH;
       cc7nG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7nH: // global
           I64[Sp - 24] = block_cc7nC_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc7nL; else goto cc7nD;
       uc7nL: // global
           call _cc7nC(R1) args: 0, res: 0, upd: 0;
       cc7nD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7nC() //  [R1]
         { info_tbl: [(cc7nC,
                       label: block_cc7nC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7nC: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Control.Monad.$wreplicateM__entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.769520236 UTC

[section ""data" . Control.Monad.$w$sreplicateM1_closure" {
     Control.Monad.$w$sreplicateM1_closure:
         const Control.Monad.$w$sreplicateM1_info;
 },
 $wloop_sc6U1_entry() //  [R1, R2]
         { info_tbl: [(cc7o0,
                       label: $wloop_sc6U1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7o0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7o1; else goto cc7o2;
       cc7o1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7o2: // global
           if (%MO_S_Gt_W64(R2, 0)) goto cc7nY; else goto cc7nZ;
       cc7nY: // global
           I64[Sp - 24] = block_cc7o4_info;
           _sc6U1::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp - 16] = _sc6U1::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cc7nZ: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc7o4() //  [R1]
         { info_tbl: [(cc7o4,
                       label: block_cc7o4_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7o4: // global
           _sc6U1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc7o9_info;
           R2 = I64[Sp + 16] - 1;
           _sc6U7::P64 = R1;
           R1 = _sc6U1::P64;
           P64[Sp + 16] = _sc6U7::P64;
           Sp = Sp + 8;
           call $wloop_sc6U1_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7o9() //  [R1]
         { info_tbl: [(cc7o9,
                       label: block_cc7o9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7o9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc7of; else goto cc7oe;
       cc7of: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7oe: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.$w$sreplicateM1_entry() //  [R2, R3]
         { info_tbl: [(cc7og,
                       label: Control.Monad.$w$sreplicateM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7og: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc7ok; else goto cc7oj;
       cc7ok: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$w$sreplicateM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7oj: // global
           I64[Hp - 8] = $wloop_sc6U1_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 6;
           call $wloop_sc6U1_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.771388481 UTC

[section ""data" . Control.Monad.replicateM2_closure" {
     Control.Monad.replicateM2_closure:
         const Control.Monad.replicateM2_info;
 },
 Control.Monad.replicateM2_entry() //  [R2, R3]
         { info_tbl: [(cc7os,
                       label: Control.Monad.replicateM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7os: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7ot; else goto cc7ou;
       cc7ot: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7ou: // global
           I64[Sp - 16] = block_cc7op_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7oy; else goto cc7oq;
       uc7oy: // global
           call _cc7op(R1) args: 0, res: 0, upd: 0;
       cc7oq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7op() //  [R1]
         { info_tbl: [(cc7op,
                       label: block_cc7op_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7op: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Control.Monad.$w$sreplicateM1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.772599039 UTC

[section ""data" . Control.Monad.replicateM_$sreplicateM1_closure" {
     Control.Monad.replicateM_$sreplicateM1_closure:
         const Control.Monad.replicateM_$sreplicateM1_info;
 },
 Control.Monad.replicateM_$sreplicateM1_entry() //  [R2, R3]
         { info_tbl: [(cc7oD,
                       label: Control.Monad.replicateM_$sreplicateM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7oD: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.replicateM2_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.775451618 UTC

[section ""data" . Control.Monad.$wreplicateM_closure" {
     Control.Monad.$wreplicateM_closure:
         const Control.Monad.$wreplicateM_info;
 },
 lvl_sc6Ul_entry() //  [R1]
         { info_tbl: [(cc7oO,
                       label: lvl_sc6Ul_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7oO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7oP; else goto cc7oQ;
       cc7oP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7oQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc6Uq_entry() //  [R1]
         { info_tbl: [(cc7p5,
                       label: sat_sc6Uq_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7p5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7p6; else goto cc7p7;
       cc7p6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7p7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wloop_sc6Um_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wloop_sc6Um_entry() //  [R1, R2]
         { info_tbl: [(cc7pb,
                       label: $wloop_sc6Um_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7pb: // global
           _sc6Un::I64 = R2;
           _sc6Um::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc7pc; else goto cc7pd;
       cc7pd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc7pf; else goto cc7pe;
       cc7pf: // global
           HpAlloc = 32;
           goto cc7pc;
       cc7pc: // global
           R2 = _sc6Un::I64;
           R1 = _sc6Um::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7pe: // global
           if (%MO_S_Gt_W64(_sc6Un::I64, 0)) goto cc7p9; else goto cc7pa;
       cc7p9: // global
           _sc6Ui::P64 = P64[_sc6Um::P64 + 7];
           _sc6Uk::P64 = P64[_sc6Um::P64 + 15];
           I64[Hp - 24] = sat_sc6Uq_info;
           P64[Hp - 8] = _sc6Um::P64;
           I64[Hp] = _sc6Un::I64;
           R2 = _sc6Ui::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           P64[Sp - 16] = _sc6Uk::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
       cc7pa: // global
           _sc6Ul::P64 = P64[_sc6Um::P64 + 23];
           Hp = Hp - 32;
           R1 = _sc6Ul::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.$wreplicateM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7pg,
                       label: Control.Monad.$wreplicateM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7pg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7pk; else goto cc7pj;
       cc7pk: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$wreplicateM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7pj: // global
           I64[Hp - 48] = lvl_sc6Ul_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = $wloop_sc6Um_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 48;
           R2 = R3;
           R1 = Hp - 23;
           call $wloop_sc6Um_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.777535369 UTC

[section ""data" . Control.Monad.replicateM_closure" {
     Control.Monad.replicateM_closure:
         const Control.Monad.replicateM_info;
 },
 Control.Monad.replicateM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7ps,
                       label: Control.Monad.replicateM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7ps: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7pt; else goto cc7pu;
       cc7pt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7pu: // global
           I64[Sp - 24] = block_cc7pp_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc7py; else goto cc7pq;
       uc7py: // global
           call _cc7pp(R1) args: 0, res: 0, upd: 0;
       cc7pq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7pp() //  [R1]
         { info_tbl: [(cc7pp,
                       label: block_cc7pp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7pp: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Control.Monad.$wreplicateM_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.778533163 UTC

[section ""relreadonly" . Sc7a2_srt" { Sc7a2_srt:
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.779340258 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:00.780769346 UTC

[section ""data" . Control.Monad.guard_closure" {
     Control.Monad.guard_closure:
         const Control.Monad.guard_info;
 },
 Control.Monad.guard_entry() //  [R2, R3]
         { info_tbl: [(cc7pK,
                       label: Control.Monad.guard_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7pK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7pL; else goto cc7pM;
       cc7pL: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.guard_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7pM: // global
           I64[Sp - 16] = block_cc7pD_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7pY; else goto cc7pE;
       uc7pY: // global
           call _cc7pD(R1) args: 0, res: 0, upd: 0;
       cc7pE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7pD() //  [R1]
         { info_tbl: [(cc7pD,
                       label: block_cc7pD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7pD: // global
           _sc6QB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc7pH; else goto cc7pI;
       cc7pH: // global
           R2 = _sc6QB::P64;
           Sp = Sp + 16;
           call GHC.Base.empty_entry(R2) args: 8, res: 0, upd: 8;
       cc7pI: // global
           I64[Sp + 8] = block_cc7pS_info;
           R2 = _sc6QB::P64;
           Sp = Sp + 8;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc7pS() //  [R1]
         { info_tbl: [(cc7pS,
                       label: block_cc7pS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7pS: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Tuple.()_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.789434697 UTC

[section ""data" . Control.Monad.filterM_closure" {
     Control.Monad.filterM_closure:
         const Control.Monad.filterM_info;
 },
 z_sc6QH_entry() //  [R1]
         { info_tbl: [(cc7ql,
                       label: z_sc6QH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7ql: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7qm; else goto cc7qn;
       cc7qm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7qn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc6QQ_entry() //  [R1, R2, R3]
         { info_tbl: [(cc7qN,
                       label: sat_sc6QQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7qN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7qO; else goto cc7qP;
       cc7qO: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7qP: // global
           I64[Sp - 24] = block_cc7qG_info;
           _sc6QL::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sc6QL::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc7qZ; else goto cc7qH;
       uc7qZ: // global
           call _cc7qG(R1) args: 0, res: 0, upd: 0;
       cc7qH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7qG() //  [R1]
         { info_tbl: [(cc7qG,
                       label: block_cc7qG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7qG: // global
           _sc6QO::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cc7qK; else goto cc7qL;
       cc7qK: // global
           R1 = _sc6QO::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc7qL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc7qY; else goto cc7qX;
       cc7qY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7qX: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sc6QO::P64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sc6QI_entry() //  [R1, R2]
         { info_tbl: [(cc7r4,
                       label: go_sc6QI_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7r4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc7r5; else goto cc7r6;
       cc7r5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7r6: // global
           I64[Sp - 40] = block_cc7qt_info;
           _sc6QI::P64 = R1;
           _sc6QF::P64 = P64[R1 + 7];
           _sc6QG::P64 = P64[R1 + 15];
           _sc6QH::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sc6QF::P64;
           P64[Sp - 24] = _sc6QG::P64;
           P64[Sp - 16] = _sc6QH::P64;
           P64[Sp - 8] = _sc6QI::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc7rc; else goto cc7qu;
       uc7rc: // global
           call _cc7qt(R1) args: 0, res: 0, upd: 0;
       cc7qu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7qt() //  [R1]
         { info_tbl: [(cc7qt,
                       label: block_cc7qt_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7qt: // global
           if (R1 & 7 == 1) goto cc7r1; else goto cc7r2;
       cc7r1: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc7r2: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc7rb; else goto cc7ra;
       cc7rb: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7ra: // global
           _sc6QL::P64 = P64[R1 + 6];
           _sc6QM::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 32];
           P64[Hp - 48] = _sc6QM::P64;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sc6QL::P64;
           I64[Hp - 8] = sat_sc6QQ_info;
           P64[Hp] = _sc6QL::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = Hp - 6;
           P64[Sp + 24] = Hp - 40;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Control.Monad.filterM_entry() //  [R2, R3]
         { info_tbl: [(cc7rd,
                       label: Control.Monad.filterM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7rd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7rh; else goto cc7rg;
       cc7rh: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.filterM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7rg: // global
           I64[Hp - 48] = z_sc6QH_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go_sc6QI_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.804207391 UTC

[section ""data" . Control.Monad.>=>_closure" {
     Control.Monad.>=>_closure:
         const Control.Monad.>=>_info;
 },
 Control.Monad.>=>_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc7s0,
                       label: Control.Monad.>=>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7s0: // global
           _sc6QW::P64 = R5;
           _sc6QV::P64 = R4;
           _sc6QU::P64 = R3;
           _sc6QT::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc7s1; else goto cc7s2;
       cc7s2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc7s4; else goto cc7s3;
       cc7s4: // global
           HpAlloc = 32;
           goto cc7s1;
       cc7s1: // global
           R5 = _sc6QW::P64;
           R4 = _sc6QV::P64;
           R3 = _sc6QU::P64;
           R2 = _sc6QT::P64;
           R1 = Control.Monad.>=>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7s3: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sc6QU::P64;
           P64[Hp] = _sc6QW::P64;
           R2 = _sc6QT::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sc6QV::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.808597932 UTC

[section ""data" . Control.Monad.<=<_closure" {
     Control.Monad.<=<_closure:
         const Control.Monad.<=<_info;
 },
 Control.Monad.<=<_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc7sf,
                       label: Control.Monad.<=<_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7sf: // global
           R5 = R5;
           _sc6R0::P64 = R4;
           R4 = R3;
           R3 = _sc6R0::P64;
           R2 = R2;
           call Control.Monad.>=>_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.813272632 UTC

[section ""data" . Control.Monad.forever_closure" {
     Control.Monad.forever_closure:
         const Control.Monad.forever_info;
 },
 a'_sc6R4_entry() //  [R1]
         { info_tbl: [(cc7su,
                       label: a'_sc6R4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7su: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc7sv; else goto cc7sw;
       cc7sv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7sw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = R1;
           Sp = Sp - 40;
           call GHC.Base.*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.forever_entry() //  [R2, R3]
         { info_tbl: [(cc7sx,
                       label: Control.Monad.forever_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7sx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc7sB; else goto cc7sA;
       cc7sB: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.forever_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7sA: // global
           I64[Hp - 24] = a'_sc6R4_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.820187945 UTC

[section ""data" . Control.Monad.mapAndUnzipM_closure" {
     Control.Monad.mapAndUnzipM_closure:
         const Control.Monad.mapAndUnzipM_info;
 },
 z_sc6R9_entry() //  [R1]
         { info_tbl: [(cc7sX,
                       label: z_sc6R9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7sX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7sY; else goto cc7sZ;
       cc7sY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7sZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sc6Ra_entry() //  [R1, R2]
         { info_tbl: [(cc7tc,
                       label: go_sc6Ra_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7tc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc7td; else goto cc7te;
       cc7td: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7te: // global
           I64[Sp - 40] = block_cc7t5_info;
           _sc6Ra::P64 = R1;
           _sc6R5::P64 = P64[R1 + 7];
           _sc6R6::P64 = P64[R1 + 15];
           _sc6R9::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sc6R5::P64;
           P64[Sp - 24] = _sc6R6::P64;
           P64[Sp - 16] = _sc6R9::P64;
           P64[Sp - 8] = _sc6Ra::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc7tp; else goto cc7t6;
       uc7tp: // global
           call _cc7t5(R1) args: 0, res: 0, upd: 0;
       cc7t6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7t5() //  [R1]
         { info_tbl: [(cc7t5,
                       label: block_cc7t5_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7t5: // global
           if (R1 & 7 == 1) goto cc7t9; else goto cc7ta;
       cc7t9: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc7ta: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc7tm; else goto cc7tl;
       cc7tm: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7tl: // global
           _sc6Rd::P64 = P64[R1 + 6];
           _sc6Re::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sc6Re::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sc6Rd::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sc6Rh_entry() //  [R1]
         { info_tbl: [(cc7tq,
                       label: sat_sc6Rh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7tq: // global
           _sc6Rh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc7tr; else goto cc7ts;
       cc7ts: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7tu; else goto cc7tt;
       cc7tu: // global
           HpAlloc = 56;
           goto cc7tr;
       cc7tr: // global
           R1 = _sc6Rh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7tt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc6Rh::P64;
           _sc6R5::P64 = P64[_sc6Rh::P64 + 16];
           _sc6R6::P64 = P64[_sc6Rh::P64 + 24];
           _sc6R7::P64 = P64[_sc6Rh::P64 + 32];
           I64[Hp - 48] = z_sc6R9_info;
           P64[Hp - 32] = _sc6R5::P64;
           I64[Hp - 24] = go_sc6Ra_info;
           P64[Hp - 16] = _sc6R5::P64;
           P64[Hp - 8] = _sc6R6::P64;
           P64[Hp] = Hp - 48;
           R2 = _sc6R7::P64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call go_sc6Ra_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.mapAndUnzipM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7tx,
                       label: Control.Monad.mapAndUnzipM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7tx: // global
           _sc6R7::P64 = R4;
           _sc6R6::P64 = R3;
           _sc6R5::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc7ty; else goto cc7tz;
       cc7tz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc7tB; else goto cc7tA;
       cc7tB: // global
           HpAlloc = 40;
           goto cc7ty;
       cc7ty: // global
           R4 = _sc6R7::P64;
           R3 = _sc6R6::P64;
           R2 = _sc6R5::P64;
           R1 = Control.Monad.mapAndUnzipM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7tA: // global
           I64[Hp - 32] = sat_sc6Rh_info;
           P64[Hp - 16] = _sc6R5::P64;
           P64[Hp - 8] = _sc6R6::P64;
           P64[Hp] = _sc6R7::P64;
           I64[Sp - 16] = block_cc7tv_info;
           R2 = _sc6R5::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc7tv() //  [R1]
         { info_tbl: [(cc7tv,
                       label: block_cc7tv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7tv: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.List.unzip_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.835792389 UTC

[section ""data" . Control.Monad.zipWithM_closure" {
     Control.Monad.zipWithM_closure:
         const Control.Monad.zipWithM_info;
 },
 z_sc6Rm_entry() //  [R1]
         { info_tbl: [(cc7uj,
                       label: z_sc6Rm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7uj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7uk; else goto cc7ul;
       cc7uk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7ul: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go2_sc6Rn_entry() //  [R1, R2, R3]
         { info_tbl: [(cc7uy,
                       label: go2_sc6Rn_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7uy: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cc7uz; else goto cc7uA;
       cc7uz: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7uA: // global
           I64[Sp - 48] = block_cc7ur_info;
           _sc6Rn::P64 = R1;
           _sc6Ri::P64 = P64[R1 + 6];
           _sc6Rj::P64 = P64[R1 + 14];
           _sc6Rm::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _sc6Ri::P64;
           P64[Sp - 32] = _sc6Rj::P64;
           P64[Sp - 24] = _sc6Rm::P64;
           P64[Sp - 16] = _sc6Rn::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uc7v2; else goto cc7us;
       uc7v2: // global
           call _cc7ur(R1) args: 0, res: 0, upd: 0;
       cc7us: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7ur() //  [R1]
         { info_tbl: [(cc7ur,
                       label: block_cc7ur_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7ur: // global
           if (R1 & 7 == 1) goto uc7uY; else goto cc7uw;
       uc7uY: // global
           Sp = Sp + 24;
           call _cc7uO() args: 0, res: 0, upd: 0;
       cc7uw: // global
           I64[Sp - 8] = block_cc7uG_info;
           _sc6Rr::P64 = P64[R1 + 6];
           _sc6Rs::P64 = P64[R1 + 14];
           R1 = P64[Sp + 40];
           P64[Sp] = _sc6Rs::P64;
           P64[Sp + 40] = _sc6Rr::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7v0; else goto cc7uI;
       uc7v0: // global
           call _cc7uG(R1) args: 0, res: 0, upd: 0;
       cc7uI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7uG() //  [R1]
         { info_tbl: [(cc7uG,
                       label: block_cc7uG_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7uG: // global
           if (R1 & 7 == 1) goto uc7uZ; else goto cc7uP;
       uc7uZ: // global
           Sp = Sp + 32;
           call _cc7uO() args: 0, res: 0, upd: 0;
       cc7uP: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc7uU; else goto cc7uT;
       cc7uU: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7uT: // global
           _sc6Ru::P64 = P64[R1 + 6];
           _sc6Rv::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _sc6Rv::P64;
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = _sc6Ru::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_ppp_info;
           P64[Sp + 32] = GHC.Types.:_closure+2;
           P64[Sp + 40] = Hp - 32;
           P64[Sp + 48] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cc7uO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7uO: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.zipWithM_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc7v4,
                       label: Control.Monad.zipWithM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7v4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7v8; else goto cc7v7;
       cc7v8: // global
           HpAlloc = 56;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.zipWithM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7v7: // global
           I64[Hp - 48] = z_sc6Rm_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go2_sc6Rn_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R3 = R5;
           R2 = R4;
           R1 = Hp - 22;
           call go2_sc6Rn_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.851394923 UTC

[section ""data" . Control.Monad.zipWithM__closure" {
     Control.Monad.zipWithM__closure:
         const Control.Monad.zipWithM__info;
 },
 z_sc6RC_entry() //  [R1]
         { info_tbl: [(cc7vO,
                       label: z_sc6RC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7vO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7vP; else goto cc7vQ;
       cc7vP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7vQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go2_sc6RD_entry() //  [R1, R2, R3]
         { info_tbl: [(cc7w3,
                       label: go2_sc6RD_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7w3: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cc7w4; else goto cc7w5;
       cc7w4: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7w5: // global
           I64[Sp - 48] = block_cc7vW_info;
           _sc6RD::P64 = R1;
           _sc6Ry::P64 = P64[R1 + 6];
           _sc6Rz::P64 = P64[R1 + 14];
           _sc6RC::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _sc6Ry::P64;
           P64[Sp - 32] = _sc6Rz::P64;
           P64[Sp - 24] = _sc6RC::P64;
           P64[Sp - 16] = _sc6RD::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uc7wx; else goto cc7vX;
       uc7wx: // global
           call _cc7vW(R1) args: 0, res: 0, upd: 0;
       cc7vX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7vW() //  [R1]
         { info_tbl: [(cc7vW,
                       label: block_cc7vW_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7vW: // global
           if (R1 & 7 == 1) goto uc7wt; else goto cc7w1;
       uc7wt: // global
           Sp = Sp + 24;
           call _cc7wj() args: 0, res: 0, upd: 0;
       cc7w1: // global
           I64[Sp - 8] = block_cc7wb_info;
           _sc6RH::P64 = P64[R1 + 6];
           _sc6RI::P64 = P64[R1 + 14];
           R1 = P64[Sp + 40];
           P64[Sp] = _sc6RI::P64;
           P64[Sp + 40] = _sc6RH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7wv; else goto cc7wd;
       uc7wv: // global
           call _cc7wb(R1) args: 0, res: 0, upd: 0;
       cc7wd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7wb() //  [R1]
         { info_tbl: [(cc7wb,
                       label: block_cc7wb_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7wb: // global
           if (R1 & 7 == 1) goto uc7wu; else goto cc7wk;
       uc7wu: // global
           Sp = Sp + 32;
           call _cc7wj() args: 0, res: 0, upd: 0;
       cc7wk: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc7wp; else goto cc7wo;
       cc7wp: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7wo: // global
           _sc6RK::P64 = P64[R1 + 6];
           _sc6RL::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _sc6RL::P64;
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = _sc6RK::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 32;
           P64[Sp + 48] = Hp - 72;
           Sp = Sp + 32;
           call GHC.Base.*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cc7wj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7wj: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.zipWithM__entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc7wz,
                       label: Control.Monad.zipWithM__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7wz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7wD; else goto cc7wC;
       cc7wD: // global
           HpAlloc = 56;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.zipWithM__closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7wC: // global
           I64[Hp - 48] = z_sc6RC_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go2_sc6RD_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R3 = R5;
           R2 = R4;
           R1 = Hp - 22;
           call go2_sc6RD_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.864887845 UTC

[section ""data" . Control.Monad.foldM_$sfoldM_closure" {
     Control.Monad.foldM_$sfoldM_closure:
         const Control.Monad.foldM_$sfoldM_info;
 },
 Control.Monad.foldM_$sfoldM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7xh,
                       label: Control.Monad.foldM_$sfoldM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7xh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7xi; else goto cc7xj;
       cc7xi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM_$sfoldM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7xj: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc7xl() args: 0, res: 0, upd: 0;
     }
 },
 _cc7xl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7xl: // global
           I64[Sp - 8] = block_cc7xn_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7xT; else goto cc7xp;
       uc7xT: // global
           call _cc7xn(R1) args: 0, res: 0, upd: 0;
       cc7xp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7xn() //  [R1]
         { info_tbl: [(cc7xn,
                       label: block_cc7xn_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7xn: // global
           _sc6RT::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cc7xv; else goto cc7xD;
       cc7xv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc7xy; else goto cc7xx;
       cc7xy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7xx: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sc6RT::P64;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7xD: // global
           I64[Sp] = block_cc7xB_info;
           R3 = P64[R1 + 6];
           R2 = _sc6RT::P64;
           _sc6RW::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc6RW::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7xB() //  [R1]
         { info_tbl: [(cc7xB,
                       label: block_cc7xB_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7xB: // global
           if (R1 & 7 == 1) goto cc7xJ; else goto cc7xN;
       cc7xJ: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7xN: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           Sp = Sp + 8;
           call _cc7xl() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.874545094 UTC

[section ""data" . Control.Monad.foldM1_closure" {
     Control.Monad.foldM1_closure:
         const Control.Monad.foldM1_info;
 },
 Control.Monad.foldM1_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7yn,
                       label: Control.Monad.foldM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7yn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7yo; else goto cc7yp;
       cc7yo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7yp: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc7yr() args: 0, res: 0, upd: 0;
     }
 },
 _cc7yr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7yr: // global
           I64[Sp - 8] = block_cc7yt_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7yN; else goto cc7yv;
       uc7yN: // global
           call _cc7yt(R1) args: 0, res: 0, upd: 0;
       cc7yv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7yt() //  [R1]
         { info_tbl: [(cc7yt,
                       label: block_cc7yt_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7yt: // global
           _sc6S5::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cc7yB; else goto cc7yG;
       cc7yB: // global
           R1 = _sc6S5::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7yG: // global
           I64[Sp] = block_cc7yE_info;
           R3 = P64[R1 + 6];
           R2 = _sc6S5::P64;
           _sc6S9::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc6S9::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7yE() //  [R1]
         { info_tbl: [(cc7yE,
                       label: block_cc7yE_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7yE: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cc7yr() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.883195329 UTC

[section ""data" . Control.Monad.foldM_$sfoldM1_closure" {
     Control.Monad.foldM_$sfoldM1_closure:
         const Control.Monad.foldM_$sfoldM1_info;
 },
 Control.Monad.foldM_$sfoldM1_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7zb,
                       label: Control.Monad.foldM_$sfoldM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7zb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Control.Monad.foldM1_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.887279424 UTC

[section ""data" . Control.Monad.foldM_closure" {
     Control.Monad.foldM_closure:
         const Control.Monad.foldM_info;
 },
 Control.Monad.foldM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cc7zm,
                       label: Control.Monad.foldM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7zm: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Foldable.foldlM_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.890577411 UTC

[section ""data" . Control.Monad.foldM_1_closure" {
     Control.Monad.foldM_1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Tuple.()_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.89284657 UTC

[section ""data" . Control.Monad.foldM__$sfoldM__closure" {
     Control.Monad.foldM__$sfoldM__closure:
         const Control.Monad.foldM__$sfoldM__info;
 },
 Control.Monad.foldM__$sfoldM__entry() //  [R2, R3, R4]
         { info_tbl: [(cc7zA,
                       label: Control.Monad.foldM__$sfoldM__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7zA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7zB; else goto cc7zC;
       cc7zB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM__$sfoldM__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7zC: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc7zE() args: 0, res: 0, upd: 0;
     }
 },
 _cc7zE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7zE: // global
           I64[Sp - 8] = block_cc7zG_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7A9; else goto cc7zI;
       uc7A9: // global
           call _cc7zG(R1) args: 0, res: 0, upd: 0;
       cc7zI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7zG() //  [R1]
         { info_tbl: [(cc7zG,
                       label: block_cc7zG_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7zG: // global
           if (R1 & 7 == 1) goto cc7zO; else goto cc7zT;
       cc7zO: // global
           R1 = Control.Monad.foldM_1_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7zT: // global
           I64[Sp] = block_cc7zR_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sc6Sl::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc6Sl::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7zR() //  [R1]
         { info_tbl: [(cc7zR,
                       label: block_cc7zR_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7zR: // global
           if (R1 & 7 == 1) goto cc7zZ; else goto cc7A3;
       cc7zZ: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7A3: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           Sp = Sp + 8;
           call _cc7zE() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.90181155 UTC

[section ""data" . Control.Monad.foldM_2_closure" {
     Control.Monad.foldM_2_closure:
         const Control.Monad.foldM_2_info;
 },
 Control.Monad.foldM_2_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7AD,
                       label: Control.Monad.foldM_2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7AD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7AE; else goto cc7AF;
       cc7AE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM_2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7AF: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc7AH() args: 0, res: 0, upd: 0;
     }
 },
 _cc7AH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7AH: // global
           I64[Sp - 8] = block_cc7AJ_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7B3; else goto cc7AL;
       uc7B3: // global
           call _cc7AJ(R1) args: 0, res: 0, upd: 0;
       cc7AL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7AJ() //  [R1]
         { info_tbl: [(cc7AJ,
                       label: block_cc7AJ_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7AJ: // global
           if (R1 & 7 == 1) goto cc7AR; else goto cc7AW;
       cc7AR: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7AW: // global
           I64[Sp] = block_cc7AU_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sc6Sy::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc6Sy::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7AU() //  [R1]
         { info_tbl: [(cc7AU,
                       label: block_cc7AU_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7AU: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cc7AH() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.910277687 UTC

[section ""data" . Control.Monad.foldM__$sfoldM_1_closure" {
     Control.Monad.foldM__$sfoldM_1_closure:
         const Control.Monad.foldM__$sfoldM_1_info;
 },
 Control.Monad.foldM__$sfoldM_1_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7Br,
                       label: Control.Monad.foldM__$sfoldM_1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Br: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Control.Monad.foldM_2_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.915015255 UTC

[section ""data" . Control.Monad.foldM__closure" {
     Control.Monad.foldM__closure:
         const Control.Monad.foldM__info;
 },
 sat_sc6SI_entry() //  [R1]
         { info_tbl: [(cc7BG,
                       label: sat_sc6SI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7BG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7BH; else goto cc7BI;
       cc7BH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7BI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc6SH_entry() //  [R1]
         { info_tbl: [(cc7BN,
                       label: sat_sc6SH_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7BN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7BO; else goto cc7BP;
       cc7BO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7BP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Foldable.foldlM_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.foldM__entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cc7BQ,
                       label: Control.Monad.foldM__info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7BQ: // global
           _sc6SG::P64 = R6;
           _sc6SF::P64 = R5;
           _sc6SE::P64 = R4;
           _sc6SD::P64 = R3;
           _sc6SC::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc7BR; else goto cc7BS;
       cc7BS: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc7BU; else goto cc7BT;
       cc7BU: // global
           HpAlloc = 80;
           goto cc7BR;
       cc7BR: // global
           R6 = _sc6SG::P64;
           R5 = _sc6SF::P64;
           R4 = _sc6SE::P64;
           R3 = _sc6SD::P64;
           R2 = _sc6SC::P64;
           R1 = Control.Monad.foldM__closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7BT: // global
           I64[Hp - 72] = sat_sc6SI_info;
           P64[Hp - 56] = _sc6SD::P64;
           I64[Hp - 48] = sat_sc6SH_info;
           P64[Hp - 32] = _sc6SC::P64;
           P64[Hp - 24] = _sc6SD::P64;
           P64[Hp - 16] = _sc6SE::P64;
           P64[Hp - 8] = _sc6SF::P64;
           P64[Hp] = _sc6SG::P64;
           R2 = _sc6SD::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 48;
           P64[Sp - 8] = Hp - 72;
           Sp = Sp - 24;
           call GHC.Base.>>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.925148459 UTC

[section ""data" . Control.Monad.<$!>_closure" {
     Control.Monad.<$!>_closure:
         const Control.Monad.<$!>_info;
 },
 sat_sc6SO_entry() //  [R1, R2]
         { info_tbl: [(cc7Cl,
                       label: sat_sc6SO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Cl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7Cm; else goto cc7Cn;
       cc7Cm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7Cn: // global
           I64[Sp - 16] = block_cc7Cj_info;
           R2 = R2;
           _sc6SJ::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _sc6SJ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7Cj() //  [R1]
         { info_tbl: [(cc7Cj,
                       label: block_cc7Cj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Cj: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Monad.<$!>_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7Cp,
                       label: Control.Monad.<$!>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Cp: // global
           _sc6SL::P64 = R4;
           _sc6SK::P64 = R3;
           _sc6SJ::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc7Cq; else goto cc7Cr;
       cc7Cr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc7Ct; else goto cc7Cs;
       cc7Ct: // global
           HpAlloc = 24;
           goto cc7Cq;
       cc7Cq: // global
           R4 = _sc6SL::P64;
           R3 = _sc6SK::P64;
           R2 = _sc6SJ::P64;
           R1 = Control.Monad.<$!>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Cs: // global
           I64[Hp - 16] = sat_sc6SO_info;
           P64[Hp - 8] = _sc6SJ::P64;
           P64[Hp] = _sc6SK::P64;
           R2 = _sc6SJ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sc6SL::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.934516565 UTC

[section ""data" . Control.Monad.mfilter_closure" {
     Control.Monad.mfilter_closure:
         const Control.Monad.mfilter_info;
 },
 lvl_sc6SS_entry() //  [R1]
         { info_tbl: [(cc7CP,
                       label: lvl_sc6SS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7CP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7CQ; else goto cc7CR;
       cc7CQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7CR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc6SW_entry() //  [R1, R2]
         { info_tbl: [(cc7D7,
                       label: sat_sc6SW_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7D7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7D8; else goto cc7D9;
       cc7D8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7D9: // global
           I64[Sp - 32] = block_cc7D1_info;
           _sc6SU::P64 = R2;
           R2 = R2;
           _sc6SS::P64 = P64[R1 + 15];
           _sc6ST::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 24] = _sc6SS::P64;
           P64[Sp - 16] = _sc6ST::P64;
           P64[Sp - 8] = _sc6SU::P64;
           Sp = Sp - 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7D1() //  [R1]
         { info_tbl: [(cc7D1,
                       label: block_cc7D1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7D1: // global
           if (R1 & 7 == 1) goto cc7D4; else goto cc7D5;
       cc7D4: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc7D5: // global
           R2 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_p_info;
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Monad.mfilter_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7Dg,
                       label: Control.Monad.mfilter_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Dg: // global
           _sc6SR::P64 = R4;
           _sc6SQ::P64 = R3;
           _sc6SP::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cc7Dh; else goto cc7Di;
       cc7Di: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc7Dk; else goto cc7Dj;
       cc7Dk: // global
           HpAlloc = 24;
           goto cc7Dh;
       cc7Dh: // global
           R4 = _sc6SR::P64;
           R3 = _sc6SQ::P64;
           R2 = _sc6SP::P64;
           R1 = Control.Monad.mfilter_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Dj: // global
           I64[Hp - 16] = lvl_sc6SS_info;
           P64[Hp] = _sc6SP::P64;
           I64[Sp - 32] = block_cc7CS_info;
           R2 = _sc6SP::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sc6SQ::P64;
           P64[Sp - 8] = _sc6SR::P64;
           Sp = Sp - 32;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc7CS() //  [R1]
         { info_tbl: [(cc7CS,
                       label: block_cc7CS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7CS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc7Dn; else goto cc7Dm;
       cc7Dn: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7Dm: // global
           I64[Hp - 24] = sat_sc6SW_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = Hp - 23;
           Sp = Sp + 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.947603761 UTC

[section ""cstring" . Control.Monad.$trModule4_bytes" {
     Control.Monad.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.949462578 UTC

[section ""data" . Control.Monad.$trModule3_closure" {
     Control.Monad.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.951341486 UTC

[section ""cstring" . Control.Monad.$trModule2_bytes" {
     Control.Monad.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.953102258 UTC

[section ""data" . Control.Monad.$trModule1_closure" {
     Control.Monad.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.954918837 UTC

[section ""data" . Control.Monad.$trModule_closure" {
     Control.Monad.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.$trModule3_closure+1;
         const Control.Monad.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.9571291 UTC

[section ""data" . Control.Monad.unless_$sunless_closure" {
     Control.Monad.unless_$sunless_closure:
         const Control.Monad.unless_$sunless_info;
 },
 Control.Monad.unless_$sunless_entry() //  [R2, R3]
         { info_tbl: [(cc7E4,
                       label: Control.Monad.unless_$sunless_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7E4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7E5; else goto cc7E6;
       cc7E5: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.unless_$sunless_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7E6: // global
           I64[Sp - 16] = block_cc7DX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7Ed; else goto cc7DY;
       uc7Ed: // global
           call _cc7DX(R1) args: 0, res: 0, upd: 0;
       cc7DY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7DX() //  [R1]
         { info_tbl: [(cc7DX,
                       label: block_cc7DX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7DX: // global
           if (R1 & 7 == 1) goto cc7E1; else goto cc7E2;
       cc7E1: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc7E2: // global
           R1 = Control.Monad.foldM_1_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.964323753 UTC

[section ""data" . Control.Monad.replicateM__$sreplicateM__closure" {
     Control.Monad.replicateM__$sreplicateM__closure:
         const Control.Monad.replicateM__$sreplicateM__info;
 },
 Control.Monad.replicateM__$sreplicateM__entry() //  [R2, R3]
         { info_tbl: [(cc7Ez,
                       label: Control.Monad.replicateM__$sreplicateM__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Ez: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7EA; else goto cc7EB;
       cc7EA: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM__$sreplicateM__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7EB: // global
           I64[Sp - 16] = block_cc7Ew_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7F8; else goto cc7Ex;
       uc7F8: // global
           call _cc7Ew(R1) args: 0, res: 0, upd: 0;
       cc7Ex: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7Ew() //  [R1]
         { info_tbl: [(cc7Ew,
                       label: block_cc7Ew_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Ew: // global
           I64[Sp] = I64[R1 + 7];
           call _cc7EI() args: 0, res: 0, upd: 0;
     }
 },
 _cc7EI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7EI: // global
           if (%MO_S_Gt_W64(I64[Sp], 0)) goto cc7EQ; else goto cc7F2;
       cc7EQ: // global
           I64[Sp - 8] = block_cc7EO_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7F9; else goto cc7ER;
       uc7F9: // global
           call _cc7EO(R1) args: 0, res: 0, upd: 0;
       cc7ER: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cc7F2: // global
           R1 = Control.Monad.foldM_1_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc7EO() //  [R1]
         { info_tbl: [(cc7EO,
                       label: block_cc7EO_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7EO: // global
           if (R1 & 7 == 1) goto cc7EX; else goto cc7F1;
       cc7EX: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc7F1: // global
           I64[Sp + 8] = I64[Sp + 8] - 1;
           Sp = Sp + 8;
           call _cc7EI() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.972342226 UTC

[section ""data" . Control.Monad.replicateM1_closure" {
     Control.Monad.replicateM1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.975310018 UTC

[section ""data" . Control.Monad.$w$sreplicateM_closure" {
     Control.Monad.$w$sreplicateM_closure:
         const Control.Monad.$w$sreplicateM_info;
 },
 $wloop_sc6Tc_entry() //  [R1, R2]
         { info_tbl: [(cc7FK,
                       label: $wloop_sc6Tc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7FK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7FL; else goto cc7FM;
       cc7FL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7FM: // global
           if (%MO_S_Gt_W64(R2, 0)) goto cc7FI; else goto cc7FJ;
       cc7FI: // global
           I64[Sp - 24] = block_cc7FO_info;
           _sc6Tc::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sc6Tc::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc7Gm; else goto cc7FP;
       uc7Gm: // global
           call _cc7FO(R1) args: 0, res: 0, upd: 0;
       cc7FP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cc7FJ: // global
           R1 = Control.Monad.replicateM1_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc7FO() //  [R1]
         { info_tbl: [(cc7FO,
                       label: block_cc7FO_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7FO: // global
           if (R1 & 7 == 1) goto uc7Gk; else goto cc7G3;
       uc7Gk: // global
           Sp = Sp + 24;
           call _cc7G9() args: 0, res: 0, upd: 0;
       cc7G3: // global
           _sc6Tc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc7G2_info;
           R2 = I64[Sp + 16] - 1;
           _sc6Tg::P64 = P64[R1 + 6];
           R1 = _sc6Tc::P64;
           P64[Sp + 16] = _sc6Tg::P64;
           Sp = Sp + 8;
           call $wloop_sc6Tc_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7G2() //  [R1]
         { info_tbl: [(cc7G2,
                       label: block_cc7G2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7G2: // global
           if (R1 & 7 == 1) goto uc7Gl; else goto cc7Ge;
       uc7Gl: // global
           Sp = Sp + 16;
           call _cc7G9() args: 0, res: 0, upd: 0;
       cc7Ge: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc7Gh; else goto cc7Gg;
       cc7Gh: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7Gg: // global
           _sc6Tj::P64 = P64[R1 + 6];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sc6Tj::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc7G9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7G9: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.$w$sreplicateM_entry() //  [R2, R3]
         { info_tbl: [(cc7Gp,
                       label: Control.Monad.$w$sreplicateM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Gp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc7Gt; else goto cc7Gs;
       cc7Gt: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$w$sreplicateM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Gs: // global
           I64[Hp - 8] = $wloop_sc6Tc_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call $wloop_sc6Tc_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.986098019 UTC

[section ""data" . Control.Monad.replicateM_$sreplicateM_closure" {
     Control.Monad.replicateM_$sreplicateM_closure:
         const Control.Monad.replicateM_$sreplicateM_info;
 },
 Control.Monad.replicateM_$sreplicateM_entry() //  [R2, R3]
         { info_tbl: [(cc7H2,
                       label: Control.Monad.replicateM_$sreplicateM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7H2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7H3; else goto cc7H4;
       cc7H3: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM_$sreplicateM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7H4: // global
           I64[Sp - 16] = block_cc7GZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7H8; else goto cc7H0;
       uc7H8: // global
           call _cc7GZ(R1) args: 0, res: 0, upd: 0;
       cc7H0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7GZ() //  [R1]
         { info_tbl: [(cc7GZ,
                       label: block_cc7GZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7GZ: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Control.Monad.$w$sreplicateM_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.99203819 UTC

[section ""data" . Control.Monad.unless1_closure" {
     Control.Monad.unless1_closure:
         const Control.Monad.unless1_info;
 },
 Control.Monad.unless1_entry() //  [R2, R3]
         { info_tbl: [(cc7Ht,
                       label: Control.Monad.unless1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Ht: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7Hu; else goto cc7Hv;
       cc7Hu: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.unless1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Hv: // global
           I64[Sp - 16] = block_cc7Hm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7HC; else goto cc7Hn;
       uc7HC: // global
           call _cc7Hm(R1) args: 0, res: 0, upd: 0;
       cc7Hn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7Hm() //  [R1]
         { info_tbl: [(cc7Hm,
                       label: block_cc7Hm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Hm: // global
           if (R1 & 7 == 1) goto cc7Hq; else goto cc7Hr;
       cc7Hq: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       cc7Hr: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.997786714 UTC

[section ""data" . Control.Monad.unless_$sunless1_closure" {
     Control.Monad.unless_$sunless1_closure:
         const Control.Monad.unless_$sunless1_info;
 },
 Control.Monad.unless_$sunless1_entry() //  [R2, R3]
         { info_tbl: [(cc7HT,
                       label: Control.Monad.unless_$sunless1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7HT: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.unless1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:01.001780546 UTC

[section ""data" . Control.Monad.unless_closure" {
     Control.Monad.unless_closure:
         const Control.Monad.unless_info;
 },
 Control.Monad.unless_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7Ib,
                       label: Control.Monad.unless_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Ib: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7Ic; else goto cc7Id;
       cc7Ic: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.unless_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Id: // global
           I64[Sp - 24] = block_cc7I4_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc7Ik; else goto cc7I5;
       uc7Ik: // global
           call _cc7I4(R1) args: 0, res: 0, upd: 0;
       cc7I5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7I4() //  [R1]
         { info_tbl: [(cc7I4,
                       label: block_cc7I4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7I4: // global
           if (R1 & 7 == 1) goto cc7I8; else goto cc7I9;
       cc7I8: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc7I9: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:01.007636581 UTC

[section ""data" . Control.Monad.replicateM_1_closure" {
     Control.Monad.replicateM_1_closure:
         const Control.Monad.replicateM_1_info;
 },
 Control.Monad.replicateM_1_entry() //  [R2, R3]
         { info_tbl: [(cc7ID,
                       label: Control.Monad.replicateM_1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7ID: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7IE; else goto cc7IF;
       cc7IE: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM_1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7IF: // global
           I64[Sp - 16] = block_cc7IA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7J2; else goto cc7IB;
       uc7J2: // global
           call _cc7IA(R1) args: 0, res: 0, upd: 0;
       cc7IB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7IA() //  [R1]
         { info_tbl: [(cc7IA,
                       label: block_cc7IA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7IA: // global
           I64[Sp] = I64[R1 + 7];
           call _cc7IM() args: 0, res: 0, upd: 0;
     }
 },
 _cc7IM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7IM: // global
           if (%MO_S_Gt_W64(I64[Sp], 0)) goto cc7IU; else goto cc7IX;
       cc7IU: // global
           I64[Sp - 8] = block_cc7IS_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cc7IX: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc7IS() //  []
         { info_tbl: [(cc7IS,
                       label: block_cc7IS_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7IS: // global
           I64[Sp + 8] = I64[Sp + 8] - 1;
           Sp = Sp + 8;
           call _cc7IM() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:01.015503123 UTC

[section ""data" . Control.Monad.replicateM__$sreplicateM_1_closure" {
     Control.Monad.replicateM__$sreplicateM_1_closure:
         const Control.Monad.replicateM__$sreplicateM_1_info;
 },
 Control.Monad.replicateM__$sreplicateM_1_entry() //  [R2, R3]
         { info_tbl: [(cc7Jo,
                       label: Control.Monad.replicateM__$sreplicateM_1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Jo: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.replicateM_1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:01.019434908 UTC

[section ""data" . Control.Monad.$wreplicateM__closure" {
     Control.Monad.$wreplicateM__closure:
         const Control.Monad.$wreplicateM__info;
 },
 lvl_sc6TN_entry() //  [R1]
         { info_tbl: [(cc7JD,
                       label: lvl_sc6TN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7JD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7JE; else goto cc7JF;
       cc7JE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7JF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc6TS_entry() //  [R1]
         { info_tbl: [(cc7JU,
                       label: sat_sc6TS_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7JU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7JV; else goto cc7JW;
       cc7JV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7JW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wloop_sc6TO_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wloop_sc6TO_entry() //  [R1, R2]
         { info_tbl: [(cc7K0,
                       label: $wloop_sc6TO_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7K0: // global
           _sc6TP::I64 = R2;
           _sc6TO::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cc7K1; else goto cc7K2;
       cc7K2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc7K4; else goto cc7K3;
       cc7K4: // global
           HpAlloc = 32;
           goto cc7K1;
       cc7K1: // global
           R2 = _sc6TP::I64;
           R1 = _sc6TO::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7K3: // global
           if (%MO_S_Gt_W64(_sc6TP::I64, 0)) goto cc7JY; else goto cc7JZ;
       cc7JY: // global
           _sc6TK::P64 = P64[_sc6TO::P64 + 7];
           _sc6TM::P64 = P64[_sc6TO::P64 + 15];
           I64[Hp - 24] = sat_sc6TS_info;
           P64[Hp - 8] = _sc6TO::P64;
           I64[Hp] = _sc6TP::I64;
           R2 = _sc6TK::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sc6TM::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Base.*>_entry(R2) args: 32, res: 0, upd: 8;
       cc7JZ: // global
           _sc6TN::P64 = P64[_sc6TO::P64 + 23];
           Hp = Hp - 32;
           R1 = _sc6TN::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.$wreplicateM__entry() //  [R2, R3, R4]
         { info_tbl: [(cc7K5,
                       label: Control.Monad.$wreplicateM__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7K5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7K9; else goto cc7K8;
       cc7K9: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$wreplicateM__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7K8: // global
           I64[Hp - 48] = lvl_sc6TN_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = $wloop_sc6TO_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 48;
           R2 = R3;
           R1 = Hp - 23;
           call $wloop_sc6TO_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:01.030062705 UTC

[section ""data" . Control.Monad.replicateM__closure" {
     Control.Monad.replicateM__closure:
         const Control.Monad.replicateM__info;
 },
 Control.Monad.replicateM__entry() //  [R2, R3, R4]
         { info_tbl: [(cc7KA,
                       label: Control.Monad.replicateM__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7KA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7KB; else goto cc7KC;
       cc7KB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7KC: // global
           I64[Sp - 24] = block_cc7Kx_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc7KG; else goto cc7Ky;
       uc7KG: // global
           call _cc7Kx(R1) args: 0, res: 0, upd: 0;
       cc7Ky: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7Kx() //  [R1]
         { info_tbl: [(cc7Kx,
                       label: block_cc7Kx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Kx: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Control.Monad.$wreplicateM__entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:01.036567341 UTC

[section ""data" . Control.Monad.$w$sreplicateM1_closure" {
     Control.Monad.$w$sreplicateM1_closure:
         const Control.Monad.$w$sreplicateM1_info;
 },
 $wloop_sc6U1_entry() //  [R1, R2]
         { info_tbl: [(cc7L4,
                       label: $wloop_sc6U1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7L4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7L5; else goto cc7L6;
       cc7L5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7L6: // global
           if (%MO_S_Gt_W64(R2, 0)) goto cc7L2; else goto cc7L3;
       cc7L2: // global
           I64[Sp - 24] = block_cc7L8_info;
           _sc6U1::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp - 16] = _sc6U1::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cc7L3: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc7L8() //  [R1]
         { info_tbl: [(cc7L8,
                       label: block_cc7L8_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7L8: // global
           _sc6U1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc7Ld_info;
           R2 = I64[Sp + 16] - 1;
           _sc6U7::P64 = R1;
           R1 = _sc6U1::P64;
           P64[Sp + 16] = _sc6U7::P64;
           Sp = Sp + 8;
           call $wloop_sc6U1_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7Ld() //  [R1]
         { info_tbl: [(cc7Ld,
                       label: block_cc7Ld_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Ld: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc7Lj; else goto cc7Li;
       cc7Lj: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7Li: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.$w$sreplicateM1_entry() //  [R2, R3]
         { info_tbl: [(cc7Lk,
                       label: Control.Monad.$w$sreplicateM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Lk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc7Lo; else goto cc7Ln;
       cc7Lo: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$w$sreplicateM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Ln: // global
           I64[Hp - 8] = $wloop_sc6U1_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 6;
           call $wloop_sc6U1_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:01.046146387 UTC

[section ""data" . Control.Monad.replicateM2_closure" {
     Control.Monad.replicateM2_closure:
         const Control.Monad.replicateM2_info;
 },
 Control.Monad.replicateM2_entry() //  [R2, R3]
         { info_tbl: [(cc7LO,
                       label: Control.Monad.replicateM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7LO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7LP; else goto cc7LQ;
       cc7LP: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7LQ: // global
           I64[Sp - 16] = block_cc7LL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7LU; else goto cc7LM;
       uc7LU: // global
           call _cc7LL(R1) args: 0, res: 0, upd: 0;
       cc7LM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7LL() //  [R1]
         { info_tbl: [(cc7LL,
                       label: block_cc7LL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7LL: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Control.Monad.$w$sreplicateM1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:01.051366381 UTC

[section ""data" . Control.Monad.replicateM_$sreplicateM1_closure" {
     Control.Monad.replicateM_$sreplicateM1_closure:
         const Control.Monad.replicateM_$sreplicateM1_info;
 },
 Control.Monad.replicateM_$sreplicateM1_entry() //  [R2, R3]
         { info_tbl: [(cc7M8,
                       label: Control.Monad.replicateM_$sreplicateM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7M8: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.replicateM2_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:01.055345727 UTC

[section ""data" . Control.Monad.$wreplicateM_closure" {
     Control.Monad.$wreplicateM_closure:
         const Control.Monad.$wreplicateM_info;
 },
 lvl_sc6Ul_entry() //  [R1]
         { info_tbl: [(cc7Mn,
                       label: lvl_sc6Ul_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Mn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7Mo; else goto cc7Mp;
       cc7Mo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7Mp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc6Uq_entry() //  [R1]
         { info_tbl: [(cc7ME,
                       label: sat_sc6Uq_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7ME: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7MF; else goto cc7MG;
       cc7MF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7MG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wloop_sc6Um_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wloop_sc6Um_entry() //  [R1, R2]
         { info_tbl: [(cc7MK,
                       label: $wloop_sc6Um_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7MK: // global
           _sc6Un::I64 = R2;
           _sc6Um::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc7ML; else goto cc7MM;
       cc7MM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc7MO; else goto cc7MN;
       cc7MO: // global
           HpAlloc = 32;
           goto cc7ML;
       cc7ML: // global
           R2 = _sc6Un::I64;
           R1 = _sc6Um::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7MN: // global
           if (%MO_S_Gt_W64(_sc6Un::I64, 0)) goto cc7MI; else goto cc7MJ;
       cc7MI: // global
           _sc6Ui::P64 = P64[_sc6Um::P64 + 7];
           _sc6Uk::P64 = P64[_sc6Um::P64 + 15];
           I64[Hp - 24] = sat_sc6Uq_info;
           P64[Hp - 8] = _sc6Um::P64;
           I64[Hp] = _sc6Un::I64;
           R2 = _sc6Ui::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           P64[Sp - 16] = _sc6Uk::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
       cc7MJ: // global
           _sc6Ul::P64 = P64[_sc6Um::P64 + 23];
           Hp = Hp - 32;
           R1 = _sc6Ul::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.$wreplicateM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7MP,
                       label: Control.Monad.$wreplicateM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7MP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7MT; else goto cc7MS;
       cc7MT: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$wreplicateM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7MS: // global
           I64[Hp - 48] = lvl_sc6Ul_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = $wloop_sc6Um_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 48;
           R2 = R3;
           R1 = Hp - 23;
           call $wloop_sc6Um_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:01.06606509 UTC

[section ""data" . Control.Monad.replicateM_closure" {
     Control.Monad.replicateM_closure:
         const Control.Monad.replicateM_info;
 },
 Control.Monad.replicateM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7Nk,
                       label: Control.Monad.replicateM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Nk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7Nl; else goto cc7Nm;
       cc7Nl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Nm: // global
           I64[Sp - 24] = block_cc7Nh_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc7Nq; else goto cc7Ni;
       uc7Nq: // global
           call _cc7Nh(R1) args: 0, res: 0, upd: 0;
       cc7Ni: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7Nh() //  [R1]
         { info_tbl: [(cc7Nh,
                       label: block_cc7Nh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Nh: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Control.Monad.$wreplicateM_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:01.071569535 UTC

[section ""relreadonly" . Sc7a2_srt" { Sc7a2_srt:
 }]


==================== Output Cmm ====================
2018-03-16 16:07:01.995556167 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:01.997214953 UTC

[section ""data" . Control.Monad.guard_closure" {
     Control.Monad.guard_closure:
         const Control.Monad.guard_info;
 },
 Control.Monad.guard_entry() //  [R2, R3]
         { info_tbl: [(cc7RH,
                       label: Control.Monad.guard_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7RH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc7RI; else goto cc7RJ;
       cc7RI: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.guard_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7RJ: // global
           I64[Sp - 16] = block_cc7RA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc7RV; else goto cc7RB;
       uc7RV: // global
           call _cc7RA(R1) args: 0, res: 0, upd: 0;
       cc7RB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7RA() //  [R1]
         { info_tbl: [(cc7RA,
                       label: block_cc7RA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7RA: // global
           _sc7NB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc7RE; else goto cc7RF;
       cc7RE: // global
           R2 = _sc7NB::P64;
           Sp = Sp + 16;
           call GHC.Base.empty_entry(R2) args: 8, res: 0, upd: 8;
       cc7RF: // global
           I64[Sp + 8] = block_cc7RP_info;
           R2 = _sc7NB::P64;
           Sp = Sp + 8;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc7RP() //  [R1]
         { info_tbl: [(cc7RP,
                       label: block_cc7RP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7RP: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Tuple.()_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.079512912 UTC

[section ""data" . Control.Monad.filterM_closure" {
     Control.Monad.filterM_closure:
         const Control.Monad.filterM_info;
 },
 z_sc7NH_entry() //  [R1]
         { info_tbl: [(cc7Sn,
                       label: z_sc7NH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Sn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7So; else goto cc7Sp;
       cc7So: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7Sp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc7NQ_entry() //  [R1, R2, R3]
         { info_tbl: [(cc7SP,
                       label: sat_sc7NQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7SP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc7SQ; else goto cc7SR;
       cc7SQ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7SR: // global
           I64[Sp - 24] = block_cc7SI_info;
           _sc7NL::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sc7NL::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc7T1; else goto cc7SJ;
       uc7T1: // global
           call _cc7SI(R1) args: 0, res: 0, upd: 0;
       cc7SJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7SI() //  [R1]
         { info_tbl: [(cc7SI,
                       label: block_cc7SI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7SI: // global
           _sc7NO::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cc7SM; else goto cc7SN;
       cc7SM: // global
           R1 = _sc7NO::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc7SN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc7T0; else goto cc7SZ;
       cc7T0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7SZ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sc7NO::P64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sc7NI_entry() //  [R1, R2]
         { info_tbl: [(cc7T6,
                       label: go_sc7NI_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7T6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc7T7; else goto cc7T8;
       cc7T7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7T8: // global
           I64[Sp - 40] = block_cc7Sv_info;
           _sc7NI::P64 = R1;
           _sc7NF::P64 = P64[R1 + 7];
           _sc7NG::P64 = P64[R1 + 15];
           _sc7NH::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sc7NF::P64;
           P64[Sp - 24] = _sc7NG::P64;
           P64[Sp - 16] = _sc7NH::P64;
           P64[Sp - 8] = _sc7NI::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc7Te; else goto cc7Sw;
       uc7Te: // global
           call _cc7Sv(R1) args: 0, res: 0, upd: 0;
       cc7Sw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7Sv() //  [R1]
         { info_tbl: [(cc7Sv,
                       label: block_cc7Sv_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Sv: // global
           if (R1 & 7 == 1) goto cc7T3; else goto cc7T4;
       cc7T3: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc7T4: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc7Td; else goto cc7Tc;
       cc7Td: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7Tc: // global
           _sc7NL::P64 = P64[R1 + 6];
           _sc7NM::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 32];
           P64[Hp - 48] = _sc7NM::P64;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sc7NL::P64;
           I64[Hp - 8] = sat_sc7NQ_info;
           P64[Hp] = _sc7NL::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = Hp - 6;
           P64[Sp + 24] = Hp - 40;
           P64[Sp + 32] = Hp - 72;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Control.Monad.filterM_entry() //  [R2, R3]
         { info_tbl: [(cc7Tf,
                       label: Control.Monad.filterM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Tf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7Tj; else goto cc7Ti;
       cc7Tj: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.filterM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Ti: // global
           I64[Hp - 48] = z_sc7NH_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go_sc7NI_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.094451277 UTC

[section ""data" . Control.Monad.>=>_closure" {
     Control.Monad.>=>_closure:
         const Control.Monad.>=>_info;
 },
 Control.Monad.>=>_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc7Uf,
                       label: Control.Monad.>=>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Uf: // global
           _sc7NW::P64 = R5;
           _sc7NV::P64 = R4;
           _sc7NU::P64 = R3;
           _sc7NT::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc7Ug; else goto cc7Uh;
       cc7Uh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc7Uj; else goto cc7Ui;
       cc7Uj: // global
           HpAlloc = 32;
           goto cc7Ug;
       cc7Ug: // global
           R5 = _sc7NW::P64;
           R4 = _sc7NV::P64;
           R3 = _sc7NU::P64;
           R2 = _sc7NT::P64;
           R1 = Control.Monad.>=>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Ui: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sc7NU::P64;
           P64[Hp] = _sc7NW::P64;
           R2 = _sc7NT::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sc7NV::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.098848332 UTC

[section ""data" . Control.Monad.<=<_closure" {
     Control.Monad.<=<_closure:
         const Control.Monad.<=<_info;
 },
 Control.Monad.<=<_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc7Uw,
                       label: Control.Monad.<=<_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Uw: // global
           R5 = R5;
           _sc7O0::P64 = R4;
           R4 = R3;
           R3 = _sc7O0::P64;
           R2 = R2;
           call Control.Monad.>=>_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.102836203 UTC

[section ""data" . Control.Monad.forever_closure" {
     Control.Monad.forever_closure:
         const Control.Monad.forever_info;
 },
 a'_sc7O4_entry() //  [R1]
         { info_tbl: [(cc7UL,
                       label: a'_sc7O4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7UL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc7UM; else goto cc7UN;
       cc7UM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7UN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = R1;
           Sp = Sp - 40;
           call GHC.Base.*>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Monad.forever_entry() //  [R2, R3]
         { info_tbl: [(cc7UO,
                       label: Control.Monad.forever_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7UO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc7US; else goto cc7UR;
       cc7US: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.forever_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7UR: // global
           I64[Hp - 24] = a'_sc7O4_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.109417946 UTC

[section ""data" . Control.Monad.mapAndUnzipM_closure" {
     Control.Monad.mapAndUnzipM_closure:
         const Control.Monad.mapAndUnzipM_info;
 },
 z_sc7O9_entry() //  [R1]
         { info_tbl: [(cc7Vh,
                       label: z_sc7O9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Vh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7Vi; else goto cc7Vj;
       cc7Vi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7Vj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sc7Oa_entry() //  [R1, R2]
         { info_tbl: [(cc7Vw,
                       label: go_sc7Oa_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Vw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc7Vx; else goto cc7Vy;
       cc7Vx: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc7Vy: // global
           I64[Sp - 40] = block_cc7Vp_info;
           _sc7Oa::P64 = R1;
           _sc7O5::P64 = P64[R1 + 7];
           _sc7O6::P64 = P64[R1 + 15];
           _sc7O9::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sc7O5::P64;
           P64[Sp - 24] = _sc7O6::P64;
           P64[Sp - 16] = _sc7O9::P64;
           P64[Sp - 8] = _sc7Oa::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc7VJ; else goto cc7Vq;
       uc7VJ: // global
           call _cc7Vp(R1) args: 0, res: 0, upd: 0;
       cc7Vq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7Vp() //  [R1]
         { info_tbl: [(cc7Vp,
                       label: block_cc7Vp_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Vp: // global
           if (R1 & 7 == 1) goto cc7Vt; else goto cc7Vu;
       cc7Vt: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc7Vu: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc7VG; else goto cc7VF;
       cc7VG: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7VF: // global
           _sc7Od::P64 = P64[R1 + 6];
           _sc7Oe::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sc7Oe::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sc7Od::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sc7Oh_entry() //  [R1]
         { info_tbl: [(cc7VK,
                       label: sat_sc7Oh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7VK: // global
           _sc7Oh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc7VL; else goto cc7VM;
       cc7VM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7VO; else goto cc7VN;
       cc7VO: // global
           HpAlloc = 56;
           goto cc7VL;
       cc7VL: // global
           R1 = _sc7Oh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7VN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc7Oh::P64;
           _sc7O5::P64 = P64[_sc7Oh::P64 + 16];
           _sc7O6::P64 = P64[_sc7Oh::P64 + 24];
           _sc7O7::P64 = P64[_sc7Oh::P64 + 32];
           I64[Hp - 48] = z_sc7O9_info;
           P64[Hp - 32] = _sc7O5::P64;
           I64[Hp - 24] = go_sc7Oa_info;
           P64[Hp - 16] = _sc7O5::P64;
           P64[Hp - 8] = _sc7O6::P64;
           P64[Hp] = Hp - 48;
           R2 = _sc7O7::P64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call go_sc7Oa_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.mapAndUnzipM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc7VR,
                       label: Control.Monad.mapAndUnzipM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7VR: // global
           _sc7O7::P64 = R4;
           _sc7O6::P64 = R3;
           _sc7O5::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc7VS; else goto cc7VT;
       cc7VT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc7VV; else goto cc7VU;
       cc7VV: // global
           HpAlloc = 40;
           goto cc7VS;
       cc7VS: // global
           R4 = _sc7O7::P64;
           R3 = _sc7O6::P64;
           R2 = _sc7O5::P64;
           R1 = Control.Monad.mapAndUnzipM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7VU: // global
           I64[Hp - 32] = sat_sc7Oh_info;
           P64[Hp - 16] = _sc7O5::P64;
           P64[Hp - 8] = _sc7O6::P64;
           P64[Hp] = _sc7O7::P64;
           I64[Sp - 16] = block_cc7VP_info;
           R2 = _sc7O5::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc7VP() //  [R1]
         { info_tbl: [(cc7VP,
                       label: block_cc7VP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7VP: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.List.unzip_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.12734635 UTC

[section ""data" . Control.Monad.zipWithM_closure" {
     Control.Monad.zipWithM_closure:
         const Control.Monad.zipWithM_info;
 },
 z_sc7Om_entry() //  [R1]
         { info_tbl: [(cc7WV,
                       label: z_sc7Om_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7WV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7WW; else goto cc7WX;
       cc7WW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7WX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go2_sc7On_entry() //  [R1, R2, R3]
         { info_tbl: [(cc7Xa,
                       label: go2_sc7On_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Xa: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cc7Xb; else goto cc7Xc;
       cc7Xb: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Xc: // global
           I64[Sp - 48] = block_cc7X3_info;
           _sc7On::P64 = R1;
           _sc7Oi::P64 = P64[R1 + 6];
           _sc7Oj::P64 = P64[R1 + 14];
           _sc7Om::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _sc7Oi::P64;
           P64[Sp - 32] = _sc7Oj::P64;
           P64[Sp - 24] = _sc7Om::P64;
           P64[Sp - 16] = _sc7On::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uc7XE; else goto cc7X4;
       uc7XE: // global
           call _cc7X3(R1) args: 0, res: 0, upd: 0;
       cc7X4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7X3() //  [R1]
         { info_tbl: [(cc7X3,
                       label: block_cc7X3_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7X3: // global
           if (R1 & 7 == 1) goto uc7XA; else goto cc7X8;
       uc7XA: // global
           Sp = Sp + 24;
           call _cc7Xq() args: 0, res: 0, upd: 0;
       cc7X8: // global
           I64[Sp - 8] = block_cc7Xi_info;
           _sc7Or::P64 = P64[R1 + 6];
           _sc7Os::P64 = P64[R1 + 14];
           R1 = P64[Sp + 40];
           P64[Sp] = _sc7Os::P64;
           P64[Sp + 40] = _sc7Or::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7XC; else goto cc7Xk;
       uc7XC: // global
           call _cc7Xi(R1) args: 0, res: 0, upd: 0;
       cc7Xk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7Xi() //  [R1]
         { info_tbl: [(cc7Xi,
                       label: block_cc7Xi_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Xi: // global
           if (R1 & 7 == 1) goto uc7XB; else goto cc7Xr;
       uc7XB: // global
           Sp = Sp + 32;
           call _cc7Xq() args: 0, res: 0, upd: 0;
       cc7Xr: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc7Xw; else goto cc7Xv;
       cc7Xw: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7Xv: // global
           _sc7Ou::P64 = P64[R1 + 6];
           _sc7Ov::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _sc7Ov::P64;
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = _sc7Ou::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 24] = stg_ap_ppp_info;
           P64[Sp + 32] = GHC.Types.:_closure+2;
           P64[Sp + 40] = Hp - 32;
           P64[Sp + 48] = Hp - 72;
           Sp = Sp + 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cc7Xq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Xq: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.zipWithM_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc7XG,
                       label: Control.Monad.zipWithM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7XG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7XK; else goto cc7XJ;
       cc7XK: // global
           HpAlloc = 56;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.zipWithM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7XJ: // global
           I64[Hp - 48] = z_sc7Om_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go2_sc7On_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R3 = R5;
           R2 = R4;
           R1 = Hp - 22;
           call go2_sc7On_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.14190223 UTC

[section ""data" . Control.Monad.zipWithM__closure" {
     Control.Monad.zipWithM__closure:
         const Control.Monad.zipWithM__info;
 },
 z_sc7OC_entry() //  [R1]
         { info_tbl: [(cc7YD,
                       label: z_sc7OC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7YD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc7YE; else goto cc7YF;
       cc7YE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc7YF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go2_sc7OD_entry() //  [R1, R2, R3]
         { info_tbl: [(cc7YS,
                       label: go2_sc7OD_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7YS: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cc7YT; else goto cc7YU;
       cc7YT: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7YU: // global
           I64[Sp - 48] = block_cc7YL_info;
           _sc7OD::P64 = R1;
           _sc7Oy::P64 = P64[R1 + 6];
           _sc7Oz::P64 = P64[R1 + 14];
           _sc7OC::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _sc7Oy::P64;
           P64[Sp - 32] = _sc7Oz::P64;
           P64[Sp - 24] = _sc7OC::P64;
           P64[Sp - 16] = _sc7OD::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uc7Zm; else goto cc7YM;
       uc7Zm: // global
           call _cc7YL(R1) args: 0, res: 0, upd: 0;
       cc7YM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7YL() //  [R1]
         { info_tbl: [(cc7YL,
                       label: block_cc7YL_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7YL: // global
           if (R1 & 7 == 1) goto uc7Zi; else goto cc7YQ;
       uc7Zi: // global
           Sp = Sp + 24;
           call _cc7Z8() args: 0, res: 0, upd: 0;
       cc7YQ: // global
           I64[Sp - 8] = block_cc7Z0_info;
           _sc7OH::P64 = P64[R1 + 6];
           _sc7OI::P64 = P64[R1 + 14];
           R1 = P64[Sp + 40];
           P64[Sp] = _sc7OI::P64;
           P64[Sp + 40] = _sc7OH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc7Zk; else goto cc7Z2;
       uc7Zk: // global
           call _cc7Z0(R1) args: 0, res: 0, upd: 0;
       cc7Z2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc7Z0() //  [R1]
         { info_tbl: [(cc7Z0,
                       label: block_cc7Z0_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Z0: // global
           if (R1 & 7 == 1) goto uc7Zj; else goto cc7Z9;
       uc7Zj: // global
           Sp = Sp + 32;
           call _cc7Z8() args: 0, res: 0, upd: 0;
       cc7Z9: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc7Ze; else goto cc7Zd;
       cc7Ze: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc7Zd: // global
           _sc7OK::P64 = P64[R1 + 6];
           _sc7OL::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_3_upd_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _sc7OL::P64;
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = _sc7OK::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 32] = stg_ap_pp_info;
           P64[Sp + 40] = Hp - 32;
           P64[Sp + 48] = Hp - 72;
           Sp = Sp + 32;
           call GHC.Base.*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cc7Z8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Z8: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.zipWithM__entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc7Zo,
                       label: Control.Monad.zipWithM__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Zo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc7Zs; else goto cc7Zr;
       cc7Zs: // global
           HpAlloc = 56;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.zipWithM__closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc7Zr: // global
           I64[Hp - 48] = z_sc7OC_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go2_sc7OD_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R3 = R5;
           R2 = R4;
           R1 = Hp - 22;
           call go2_sc7OD_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.156360412 UTC

[section ""data" . Control.Monad.foldM_$sfoldM_closure" {
     Control.Monad.foldM_$sfoldM_closure:
         const Control.Monad.foldM_$sfoldM_info;
 },
 Control.Monad.foldM_$sfoldM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc80h,
                       label: Control.Monad.foldM_$sfoldM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc80h: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc80i; else goto cc80j;
       cc80i: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM_$sfoldM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc80j: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc80l() args: 0, res: 0, upd: 0;
     }
 },
 _cc80l() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc80l: // global
           I64[Sp - 8] = block_cc80n_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc80T; else goto cc80p;
       uc80T: // global
           call _cc80n(R1) args: 0, res: 0, upd: 0;
       cc80p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc80n() //  [R1]
         { info_tbl: [(cc80n,
                       label: block_cc80n_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc80n: // global
           _sc7OT::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cc80v; else goto cc80D;
       cc80v: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc80y; else goto cc80x;
       cc80y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc80x: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sc7OT::P64;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc80D: // global
           I64[Sp] = block_cc80B_info;
           R3 = P64[R1 + 6];
           R2 = _sc7OT::P64;
           _sc7OW::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc7OW::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc80B() //  [R1]
         { info_tbl: [(cc80B,
                       label: block_cc80B_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc80B: // global
           if (R1 & 7 == 1) goto cc80J; else goto cc80N;
       cc80J: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc80N: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           Sp = Sp + 8;
           call _cc80l() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.167652866 UTC

[section ""data" . Control.Monad.foldM1_closure" {
     Control.Monad.foldM1_closure:
         const Control.Monad.foldM1_info;
 },
 Control.Monad.foldM1_entry() //  [R2, R3, R4]
         { info_tbl: [(cc81r,
                       label: Control.Monad.foldM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc81r: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc81s; else goto cc81t;
       cc81s: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc81t: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc81v() args: 0, res: 0, upd: 0;
     }
 },
 _cc81v() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc81v: // global
           I64[Sp - 8] = block_cc81x_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc81R; else goto cc81z;
       uc81R: // global
           call _cc81x(R1) args: 0, res: 0, upd: 0;
       cc81z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc81x() //  [R1]
         { info_tbl: [(cc81x,
                       label: block_cc81x_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc81x: // global
           _sc7P5::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cc81F; else goto cc81K;
       cc81F: // global
           R1 = _sc7P5::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc81K: // global
           I64[Sp] = block_cc81I_info;
           R3 = P64[R1 + 6];
           R2 = _sc7P5::P64;
           _sc7P9::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc7P9::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc81I() //  [R1]
         { info_tbl: [(cc81I,
                       label: block_cc81I_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc81I: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cc81v() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.176058181 UTC

[section ""data" . Control.Monad.foldM_$sfoldM1_closure" {
     Control.Monad.foldM_$sfoldM1_closure:
         const Control.Monad.foldM_$sfoldM1_info;
 },
 Control.Monad.foldM_$sfoldM1_entry() //  [R2, R3, R4]
         { info_tbl: [(cc82h,
                       label: Control.Monad.foldM_$sfoldM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc82h: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Control.Monad.foldM1_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.179573279 UTC

[section ""data" . Control.Monad.foldM_closure" {
     Control.Monad.foldM_closure:
         const Control.Monad.foldM_info;
 },
 Control.Monad.foldM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cc82s,
                       label: Control.Monad.foldM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc82s: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Foldable.foldlM_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.183237111 UTC

[section ""data" . Control.Monad.foldM_1_closure" {
     Control.Monad.foldM_1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Tuple.()_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.185680449 UTC

[section ""data" . Control.Monad.foldM__$sfoldM__closure" {
     Control.Monad.foldM__$sfoldM__closure:
         const Control.Monad.foldM__$sfoldM__info;
 },
 Control.Monad.foldM__$sfoldM__entry() //  [R2, R3, R4]
         { info_tbl: [(cc82G,
                       label: Control.Monad.foldM__$sfoldM__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc82G: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc82H; else goto cc82I;
       cc82H: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM__$sfoldM__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc82I: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc82K() args: 0, res: 0, upd: 0;
     }
 },
 _cc82K() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc82K: // global
           I64[Sp - 8] = block_cc82M_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc83f; else goto cc82O;
       uc83f: // global
           call _cc82M(R1) args: 0, res: 0, upd: 0;
       cc82O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc82M() //  [R1]
         { info_tbl: [(cc82M,
                       label: block_cc82M_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc82M: // global
           if (R1 & 7 == 1) goto cc82U; else goto cc82Z;
       cc82U: // global
           R1 = Control.Monad.foldM_1_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc82Z: // global
           I64[Sp] = block_cc82X_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sc7Pl::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc7Pl::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc82X() //  [R1]
         { info_tbl: [(cc82X,
                       label: block_cc82X_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc82X: // global
           if (R1 & 7 == 1) goto cc835; else goto cc839;
       cc835: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc839: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = P64[R1 + 6];
           Sp = Sp + 8;
           call _cc82K() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.194836241 UTC

[section ""data" . Control.Monad.foldM_2_closure" {
     Control.Monad.foldM_2_closure:
         const Control.Monad.foldM_2_info;
 },
 Control.Monad.foldM_2_entry() //  [R2, R3, R4]
         { info_tbl: [(cc83M,
                       label: Control.Monad.foldM_2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc83M: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc83N; else goto cc83O;
       cc83N: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.foldM_2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc83O: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cc83Q() args: 0, res: 0, upd: 0;
     }
 },
 _cc83Q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc83Q: // global
           I64[Sp - 8] = block_cc83S_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc84c; else goto cc83U;
       uc84c: // global
           call _cc83S(R1) args: 0, res: 0, upd: 0;
       cc83U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc83S() //  [R1]
         { info_tbl: [(cc83S,
                       label: block_cc83S_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc83S: // global
           if (R1 & 7 == 1) goto cc840; else goto cc845;
       cc840: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc845: // global
           I64[Sp] = block_cc843_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 24];
           _sc7Py::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _sc7Py::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc843() //  [R1]
         { info_tbl: [(cc843,
                       label: block_cc843_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc843: // global
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cc83Q() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.20402925 UTC

[section ""data" . Control.Monad.foldM__$sfoldM_1_closure" {
     Control.Monad.foldM__$sfoldM_1_closure:
         const Control.Monad.foldM__$sfoldM_1_info;
 },
 Control.Monad.foldM__$sfoldM_1_entry() //  [R2, R3, R4]
         { info_tbl: [(cc84D,
                       label: Control.Monad.foldM__$sfoldM_1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc84D: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Control.Monad.foldM_2_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.207806773 UTC

[section ""data" . Control.Monad.foldM__closure" {
     Control.Monad.foldM__closure:
         const Control.Monad.foldM__info;
 },
 sat_sc7PI_entry() //  [R1]
         { info_tbl: [(cc84S,
                       label: sat_sc7PI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc84S: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc84T; else goto cc84U;
       cc84T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc84U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc7PH_entry() //  [R1]
         { info_tbl: [(cc84Z,
                       label: sat_sc7PH_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc84Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc850; else goto cc851;
       cc850: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc851: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Foldable.foldlM_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Monad.foldM__entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cc852,
                       label: Control.Monad.foldM__info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc852: // global
           _sc7PG::P64 = R6;
           _sc7PF::P64 = R5;
           _sc7PE::P64 = R4;
           _sc7PD::P64 = R3;
           _sc7PC::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc853; else goto cc854;
       cc854: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc856; else goto cc855;
       cc856: // global
           HpAlloc = 80;
           goto cc853;
       cc853: // global
           R6 = _sc7PG::P64;
           R5 = _sc7PF::P64;
           R4 = _sc7PE::P64;
           R3 = _sc7PD::P64;
           R2 = _sc7PC::P64;
           R1 = Control.Monad.foldM__closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc855: // global
           I64[Hp - 72] = sat_sc7PI_info;
           P64[Hp - 56] = _sc7PD::P64;
           I64[Hp - 48] = sat_sc7PH_info;
           P64[Hp - 32] = _sc7PC::P64;
           P64[Hp - 24] = _sc7PD::P64;
           P64[Hp - 16] = _sc7PE::P64;
           P64[Hp - 8] = _sc7PF::P64;
           P64[Hp] = _sc7PG::P64;
           R2 = _sc7PD::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 48;
           P64[Sp - 8] = Hp - 72;
           Sp = Sp - 24;
           call GHC.Base.>>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.21662928 UTC

[section ""data" . Control.Monad.<$!>_closure" {
     Control.Monad.<$!>_closure:
         const Control.Monad.<$!>_info;
 },
 sat_sc7PO_entry() //  [R1, R2]
         { info_tbl: [(cc85F,
                       label: sat_sc7PO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc85F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc85G; else goto cc85H;
       cc85G: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc85H: // global
           I64[Sp - 16] = block_cc85D_info;
           R2 = R2;
           _sc7PJ::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _sc7PJ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc85D() //  [R1]
         { info_tbl: [(cc85D,
                       label: block_cc85D_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc85D: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Monad.<$!>_entry() //  [R2, R3, R4]
         { info_tbl: [(cc85J,
                       label: Control.Monad.<$!>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc85J: // global
           _sc7PL::P64 = R4;
           _sc7PK::P64 = R3;
           _sc7PJ::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc85K; else goto cc85L;
       cc85L: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc85N; else goto cc85M;
       cc85N: // global
           HpAlloc = 24;
           goto cc85K;
       cc85K: // global
           R4 = _sc7PL::P64;
           R3 = _sc7PK::P64;
           R2 = _sc7PJ::P64;
           R1 = Control.Monad.<$!>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc85M: // global
           I64[Hp - 16] = sat_sc7PO_info;
           P64[Hp - 8] = _sc7PJ::P64;
           P64[Hp] = _sc7PK::P64;
           R2 = _sc7PJ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sc7PL::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.225063799 UTC

[section ""data" . Control.Monad.mfilter_closure" {
     Control.Monad.mfilter_closure:
         const Control.Monad.mfilter_info;
 },
 lvl_sc7PS_entry() //  [R1]
         { info_tbl: [(cc86d,
                       label: lvl_sc7PS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc86d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc86e; else goto cc86f;
       cc86e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc86f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc7PW_entry() //  [R1, R2]
         { info_tbl: [(cc86v,
                       label: sat_sc7PW_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc86v: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc86w; else goto cc86x;
       cc86w: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc86x: // global
           I64[Sp - 32] = block_cc86p_info;
           _sc7PU::P64 = R2;
           R2 = R2;
           _sc7PS::P64 = P64[R1 + 15];
           _sc7PT::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 24] = _sc7PS::P64;
           P64[Sp - 16] = _sc7PT::P64;
           P64[Sp - 8] = _sc7PU::P64;
           Sp = Sp - 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc86p() //  [R1]
         { info_tbl: [(cc86p,
                       label: block_cc86p_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc86p: // global
           if (R1 & 7 == 1) goto cc86s; else goto cc86t;
       cc86s: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc86t: // global
           R2 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_p_info;
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Control.Monad.mfilter_entry() //  [R2, R3, R4]
         { info_tbl: [(cc86E,
                       label: Control.Monad.mfilter_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc86E: // global
           _sc7PR::P64 = R4;
           _sc7PQ::P64 = R3;
           _sc7PP::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cc86F; else goto cc86G;
       cc86G: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc86I; else goto cc86H;
       cc86I: // global
           HpAlloc = 24;
           goto cc86F;
       cc86F: // global
           R4 = _sc7PR::P64;
           R3 = _sc7PQ::P64;
           R2 = _sc7PP::P64;
           R1 = Control.Monad.mfilter_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc86H: // global
           I64[Hp - 16] = lvl_sc7PS_info;
           P64[Hp] = _sc7PP::P64;
           I64[Sp - 32] = block_cc86g_info;
           R2 = _sc7PP::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = _sc7PQ::P64;
           P64[Sp - 8] = _sc7PR::P64;
           Sp = Sp - 32;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc86g() //  [R1]
         { info_tbl: [(cc86g,
                       label: block_cc86g_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc86g: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc86L; else goto cc86K;
       cc86L: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc86K: // global
           I64[Hp - 24] = sat_sc7PW_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = P64[Sp + 24];
           P64[Sp + 24] = Hp - 23;
           Sp = Sp + 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.237090419 UTC

[section ""cstring" . Control.Monad.$trModule4_bytes" {
     Control.Monad.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.238862902 UTC

[section ""data" . Control.Monad.$trModule3_closure" {
     Control.Monad.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.240489638 UTC

[section ""cstring" . Control.Monad.$trModule2_bytes" {
     Control.Monad.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.242332654 UTC

[section ""data" . Control.Monad.$trModule1_closure" {
     Control.Monad.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Monad.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.24405943 UTC

[section ""data" . Control.Monad.$trModule_closure" {
     Control.Monad.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Monad.$trModule3_closure+1;
         const Control.Monad.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.24623911 UTC

[section ""data" . Control.Monad.unless_$sunless_closure" {
     Control.Monad.unless_$sunless_closure:
         const Control.Monad.unless_$sunless_info;
 },
 Control.Monad.unless_$sunless_entry() //  [R2, R3]
         { info_tbl: [(cc87z,
                       label: Control.Monad.unless_$sunless_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc87z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc87A; else goto cc87B;
       cc87A: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.unless_$sunless_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc87B: // global
           I64[Sp - 16] = block_cc87s_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc87I; else goto cc87t;
       uc87I: // global
           call _cc87s(R1) args: 0, res: 0, upd: 0;
       cc87t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc87s() //  [R1]
         { info_tbl: [(cc87s,
                       label: block_cc87s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc87s: // global
           if (R1 & 7 == 1) goto cc87w; else goto cc87x;
       cc87w: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc87x: // global
           R1 = Control.Monad.foldM_1_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.252256286 UTC

[section ""data" . Control.Monad.replicateM__$sreplicateM__closure" {
     Control.Monad.replicateM__$sreplicateM__closure:
         const Control.Monad.replicateM__$sreplicateM__info;
 },
 Control.Monad.replicateM__$sreplicateM__entry() //  [R2, R3]
         { info_tbl: [(cc885,
                       label: Control.Monad.replicateM__$sreplicateM__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc885: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc886; else goto cc887;
       cc886: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM__$sreplicateM__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc887: // global
           I64[Sp - 16] = block_cc882_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc88E; else goto cc883;
       uc88E: // global
           call _cc882(R1) args: 0, res: 0, upd: 0;
       cc883: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc882() //  [R1]
         { info_tbl: [(cc882,
                       label: block_cc882_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc882: // global
           I64[Sp] = I64[R1 + 7];
           call _cc88e() args: 0, res: 0, upd: 0;
     }
 },
 _cc88e() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc88e: // global
           if (%MO_S_Gt_W64(I64[Sp], 0)) goto cc88m; else goto cc88y;
       cc88m: // global
           I64[Sp - 8] = block_cc88k_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc88F; else goto cc88n;
       uc88F: // global
           call _cc88k(R1) args: 0, res: 0, upd: 0;
       cc88n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cc88y: // global
           R1 = Control.Monad.foldM_1_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc88k() //  [R1]
         { info_tbl: [(cc88k,
                       label: block_cc88k_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc88k: // global
           if (R1 & 7 == 1) goto cc88t; else goto cc88x;
       cc88t: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc88x: // global
           I64[Sp + 8] = I64[Sp + 8] - 1;
           Sp = Sp + 8;
           call _cc88e() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.260615844 UTC

[section ""data" . Control.Monad.replicateM1_closure" {
     Control.Monad.replicateM1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.263306711 UTC

[section ""data" . Control.Monad.$w$sreplicateM_closure" {
     Control.Monad.$w$sreplicateM_closure:
         const Control.Monad.$w$sreplicateM_info;
 },
 $wloop_sc7Qc_entry() //  [R1, R2]
         { info_tbl: [(cc89j,
                       label: $wloop_sc7Qc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc89j: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc89k; else goto cc89l;
       cc89k: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc89l: // global
           if (%MO_S_Gt_W64(R2, 0)) goto cc89h; else goto cc89i;
       cc89h: // global
           I64[Sp - 24] = block_cc89n_info;
           _sc7Qc::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _sc7Qc::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc89V; else goto cc89o;
       uc89V: // global
           call _cc89n(R1) args: 0, res: 0, upd: 0;
       cc89o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cc89i: // global
           R1 = Control.Monad.replicateM1_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc89n() //  [R1]
         { info_tbl: [(cc89n,
                       label: block_cc89n_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc89n: // global
           if (R1 & 7 == 1) goto uc89T; else goto cc89C;
       uc89T: // global
           Sp = Sp + 24;
           call _cc89I() args: 0, res: 0, upd: 0;
       cc89C: // global
           _sc7Qc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc89B_info;
           R2 = I64[Sp + 16] - 1;
           _sc7Qg::P64 = P64[R1 + 6];
           R1 = _sc7Qc::P64;
           P64[Sp + 16] = _sc7Qg::P64;
           Sp = Sp + 8;
           call $wloop_sc7Qc_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc89B() //  [R1]
         { info_tbl: [(cc89B,
                       label: block_cc89B_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc89B: // global
           if (R1 & 7 == 1) goto uc89U; else goto cc89N;
       uc89U: // global
           Sp = Sp + 16;
           call _cc89I() args: 0, res: 0, upd: 0;
       cc89N: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc89Q; else goto cc89P;
       cc89Q: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc89P: // global
           _sc7Qj::P64 = P64[R1 + 6];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sc7Qj::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc89I() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc89I: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.$w$sreplicateM_entry() //  [R2, R3]
         { info_tbl: [(cc89Y,
                       label: Control.Monad.$w$sreplicateM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc89Y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc8a2; else goto cc8a1;
       cc8a2: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$w$sreplicateM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8a1: // global
           I64[Hp - 8] = $wloop_sc7Qc_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call $wloop_sc7Qc_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.275508503 UTC

[section ""data" . Control.Monad.replicateM_$sreplicateM_closure" {
     Control.Monad.replicateM_$sreplicateM_closure:
         const Control.Monad.replicateM_$sreplicateM_info;
 },
 Control.Monad.replicateM_$sreplicateM_entry() //  [R2, R3]
         { info_tbl: [(cc8aH,
                       label: Control.Monad.replicateM_$sreplicateM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8aH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc8aI; else goto cc8aJ;
       cc8aI: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM_$sreplicateM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8aJ: // global
           I64[Sp - 16] = block_cc8aE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc8aN; else goto cc8aF;
       uc8aN: // global
           call _cc8aE(R1) args: 0, res: 0, upd: 0;
       cc8aF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc8aE() //  [R1]
         { info_tbl: [(cc8aE,
                       label: block_cc8aE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8aE: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Control.Monad.$w$sreplicateM_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.280938907 UTC

[section ""data" . Control.Monad.unless1_closure" {
     Control.Monad.unless1_closure:
         const Control.Monad.unless1_info;
 },
 Control.Monad.unless1_entry() //  [R2, R3]
         { info_tbl: [(cc8b9,
                       label: Control.Monad.unless1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8b9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc8ba; else goto cc8bb;
       cc8ba: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.unless1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8bb: // global
           I64[Sp - 16] = block_cc8b2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc8bi; else goto cc8b3;
       uc8bi: // global
           call _cc8b2(R1) args: 0, res: 0, upd: 0;
       cc8b3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc8b2() //  [R1]
         { info_tbl: [(cc8b2,
                       label: block_cc8b2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8b2: // global
           if (R1 & 7 == 1) goto cc8b6; else goto cc8b7;
       cc8b6: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       cc8b7: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.286724632 UTC

[section ""data" . Control.Monad.unless_$sunless1_closure" {
     Control.Monad.unless_$sunless1_closure:
         const Control.Monad.unless_$sunless1_info;
 },
 Control.Monad.unless_$sunless1_entry() //  [R2, R3]
         { info_tbl: [(cc8bB,
                       label: Control.Monad.unless_$sunless1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8bB: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.unless1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.29015145 UTC

[section ""data" . Control.Monad.unless_closure" {
     Control.Monad.unless_closure:
         const Control.Monad.unless_info;
 },
 Control.Monad.unless_entry() //  [R2, R3, R4]
         { info_tbl: [(cc8bT,
                       label: Control.Monad.unless_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8bT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc8bU; else goto cc8bV;
       cc8bU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.unless_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8bV: // global
           I64[Sp - 24] = block_cc8bM_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc8c2; else goto cc8bN;
       uc8c2: // global
           call _cc8bM(R1) args: 0, res: 0, upd: 0;
       cc8bN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc8bM() //  [R1]
         { info_tbl: [(cc8bM,
                       label: block_cc8bM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8bM: // global
           if (R1 & 7 == 1) goto cc8bQ; else goto cc8bR;
       cc8bQ: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc8bR: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.296442305 UTC

[section ""data" . Control.Monad.replicateM_1_closure" {
     Control.Monad.replicateM_1_closure:
         const Control.Monad.replicateM_1_info;
 },
 Control.Monad.replicateM_1_entry() //  [R2, R3]
         { info_tbl: [(cc8cp,
                       label: Control.Monad.replicateM_1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8cp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc8cq; else goto cc8cr;
       cc8cq: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM_1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8cr: // global
           I64[Sp - 16] = block_cc8cm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc8cO; else goto cc8cn;
       uc8cO: // global
           call _cc8cm(R1) args: 0, res: 0, upd: 0;
       cc8cn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc8cm() //  [R1]
         { info_tbl: [(cc8cm,
                       label: block_cc8cm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8cm: // global
           I64[Sp] = I64[R1 + 7];
           call _cc8cy() args: 0, res: 0, upd: 0;
     }
 },
 _cc8cy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8cy: // global
           if (%MO_S_Gt_W64(I64[Sp], 0)) goto cc8cG; else goto cc8cJ;
       cc8cG: // global
           I64[Sp - 8] = block_cc8cE_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cc8cJ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc8cE() //  []
         { info_tbl: [(cc8cE,
                       label: block_cc8cE_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8cE: // global
           I64[Sp + 8] = I64[Sp + 8] - 1;
           Sp = Sp + 8;
           call _cc8cy() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.304165972 UTC

[section ""data" . Control.Monad.replicateM__$sreplicateM_1_closure" {
     Control.Monad.replicateM__$sreplicateM_1_closure:
         const Control.Monad.replicateM__$sreplicateM_1_info;
 },
 Control.Monad.replicateM__$sreplicateM_1_entry() //  [R2, R3]
         { info_tbl: [(cc8dd,
                       label: Control.Monad.replicateM__$sreplicateM_1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8dd: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.replicateM_1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.308981401 UTC

[section ""data" . Control.Monad.$wreplicateM__closure" {
     Control.Monad.$wreplicateM__closure:
         const Control.Monad.$wreplicateM__info;
 },
 lvl_sc7QN_entry() //  [R1]
         { info_tbl: [(cc8ds,
                       label: lvl_sc7QN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8ds: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc8dt; else goto cc8du;
       cc8dt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc8du: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc7QS_entry() //  [R1]
         { info_tbl: [(cc8dJ,
                       label: sat_sc7QS_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8dJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc8dK; else goto cc8dL;
       cc8dK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc8dL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wloop_sc7QO_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wloop_sc7QO_entry() //  [R1, R2]
         { info_tbl: [(cc8dP,
                       label: $wloop_sc7QO_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8dP: // global
           _sc7QP::I64 = R2;
           _sc7QO::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cc8dQ; else goto cc8dR;
       cc8dR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc8dT; else goto cc8dS;
       cc8dT: // global
           HpAlloc = 32;
           goto cc8dQ;
       cc8dQ: // global
           R2 = _sc7QP::I64;
           R1 = _sc7QO::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc8dS: // global
           if (%MO_S_Gt_W64(_sc7QP::I64, 0)) goto cc8dN; else goto cc8dO;
       cc8dN: // global
           _sc7QK::P64 = P64[_sc7QO::P64 + 7];
           _sc7QM::P64 = P64[_sc7QO::P64 + 15];
           I64[Hp - 24] = sat_sc7QS_info;
           P64[Hp - 8] = _sc7QO::P64;
           I64[Hp] = _sc7QP::I64;
           R2 = _sc7QK::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sc7QM::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Base.*>_entry(R2) args: 32, res: 0, upd: 8;
       cc8dO: // global
           _sc7QN::P64 = P64[_sc7QO::P64 + 23];
           Hp = Hp - 32;
           R1 = _sc7QN::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.$wreplicateM__entry() //  [R2, R3, R4]
         { info_tbl: [(cc8dU,
                       label: Control.Monad.$wreplicateM__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8dU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc8dY; else goto cc8dX;
       cc8dY: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$wreplicateM__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8dX: // global
           I64[Hp - 48] = lvl_sc7QN_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = $wloop_sc7QO_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 48;
           R2 = R3;
           R1 = Hp - 23;
           call $wloop_sc7QO_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.319458662 UTC

[section ""data" . Control.Monad.replicateM__closure" {
     Control.Monad.replicateM__closure:
         const Control.Monad.replicateM__info;
 },
 Control.Monad.replicateM__entry() //  [R2, R3, R4]
         { info_tbl: [(cc8ey,
                       label: Control.Monad.replicateM__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8ey: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc8ez; else goto cc8eA;
       cc8ez: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM__closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8eA: // global
           I64[Sp - 24] = block_cc8ev_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc8eE; else goto cc8ew;
       uc8eE: // global
           call _cc8ev(R1) args: 0, res: 0, upd: 0;
       cc8ew: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc8ev() //  [R1]
         { info_tbl: [(cc8ev,
                       label: block_cc8ev_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8ev: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Control.Monad.$wreplicateM__entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.325675406 UTC

[section ""data" . Control.Monad.$w$sreplicateM1_closure" {
     Control.Monad.$w$sreplicateM1_closure:
         const Control.Monad.$w$sreplicateM1_info;
 },
 $wloop_sc7R1_entry() //  [R1, R2]
         { info_tbl: [(cc8f3,
                       label: $wloop_sc7R1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8f3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc8f4; else goto cc8f5;
       cc8f4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc8f5: // global
           if (%MO_S_Gt_W64(R2, 0)) goto cc8f1; else goto cc8f2;
       cc8f1: // global
           I64[Sp - 24] = block_cc8f7_info;
           _sc7R1::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp - 16] = _sc7R1::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cc8f2: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc8f7() //  [R1]
         { info_tbl: [(cc8f7,
                       label: block_cc8f7_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8f7: // global
           _sc7R1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc8fc_info;
           R2 = I64[Sp + 16] - 1;
           _sc7R7::P64 = R1;
           R1 = _sc7R1::P64;
           P64[Sp + 16] = _sc7R7::P64;
           Sp = Sp + 8;
           call $wloop_sc7R1_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc8fc() //  [R1]
         { info_tbl: [(cc8fc,
                       label: block_cc8fc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8fc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc8fi; else goto cc8fh;
       cc8fi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc8fh: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.$w$sreplicateM1_entry() //  [R2, R3]
         { info_tbl: [(cc8fj,
                       label: Control.Monad.$w$sreplicateM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8fj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc8fn; else goto cc8fm;
       cc8fn: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$w$sreplicateM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8fm: // global
           I64[Hp - 8] = $wloop_sc7R1_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 6;
           call $wloop_sc7R1_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.334935227 UTC

[section ""data" . Control.Monad.replicateM2_closure" {
     Control.Monad.replicateM2_closure:
         const Control.Monad.replicateM2_info;
 },
 Control.Monad.replicateM2_entry() //  [R2, R3]
         { info_tbl: [(cc8fS,
                       label: Control.Monad.replicateM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8fS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc8fT; else goto cc8fU;
       cc8fT: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8fU: // global
           I64[Sp - 16] = block_cc8fP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc8fY; else goto cc8fQ;
       uc8fY: // global
           call _cc8fP(R1) args: 0, res: 0, upd: 0;
       cc8fQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc8fP() //  [R1]
         { info_tbl: [(cc8fP,
                       label: block_cc8fP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8fP: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Control.Monad.$w$sreplicateM1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.340403104 UTC

[section ""data" . Control.Monad.replicateM_$sreplicateM1_closure" {
     Control.Monad.replicateM_$sreplicateM1_closure:
         const Control.Monad.replicateM_$sreplicateM1_info;
 },
 Control.Monad.replicateM_$sreplicateM1_entry() //  [R2, R3]
         { info_tbl: [(cc8gd,
                       label: Control.Monad.replicateM_$sreplicateM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8gd: // global
           R3 = R3;
           R2 = R2;
           call Control.Monad.replicateM2_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.344959052 UTC

[section ""data" . Control.Monad.$wreplicateM_closure" {
     Control.Monad.$wreplicateM_closure:
         const Control.Monad.$wreplicateM_info;
 },
 lvl_sc7Rl_entry() //  [R1]
         { info_tbl: [(cc8gs,
                       label: lvl_sc7Rl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8gs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc8gt; else goto cc8gu;
       cc8gt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc8gu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc7Rq_entry() //  [R1]
         { info_tbl: [(cc8gJ,
                       label: sat_sc7Rq_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8gJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc8gK; else goto cc8gL;
       cc8gK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc8gL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wloop_sc7Rm_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wloop_sc7Rm_entry() //  [R1, R2]
         { info_tbl: [(cc8gP,
                       label: $wloop_sc7Rm_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8gP: // global
           _sc7Rn::I64 = R2;
           _sc7Rm::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc8gQ; else goto cc8gR;
       cc8gR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc8gT; else goto cc8gS;
       cc8gT: // global
           HpAlloc = 32;
           goto cc8gQ;
       cc8gQ: // global
           R2 = _sc7Rn::I64;
           R1 = _sc7Rm::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc8gS: // global
           if (%MO_S_Gt_W64(_sc7Rn::I64, 0)) goto cc8gN; else goto cc8gO;
       cc8gN: // global
           _sc7Ri::P64 = P64[_sc7Rm::P64 + 7];
           _sc7Rk::P64 = P64[_sc7Rm::P64 + 15];
           I64[Hp - 24] = sat_sc7Rq_info;
           P64[Hp - 8] = _sc7Rm::P64;
           I64[Hp] = _sc7Rn::I64;
           R2 = _sc7Ri::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           P64[Sp - 16] = _sc7Rk::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
       cc8gO: // global
           _sc7Rl::P64 = P64[_sc7Rm::P64 + 23];
           Hp = Hp - 32;
           R1 = _sc7Rl::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Monad.$wreplicateM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc8gU,
                       label: Control.Monad.$wreplicateM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8gU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc8gY; else goto cc8gX;
       cc8gY: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.$wreplicateM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8gX: // global
           I64[Hp - 48] = lvl_sc7Rl_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = $wloop_sc7Rm_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 48;
           R2 = R3;
           R1 = Hp - 23;
           call $wloop_sc7Rm_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.35532249 UTC

[section ""data" . Control.Monad.replicateM_closure" {
     Control.Monad.replicateM_closure:
         const Control.Monad.replicateM_info;
 },
 Control.Monad.replicateM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc8hA,
                       label: Control.Monad.replicateM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8hA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc8hB; else goto cc8hC;
       cc8hB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Monad.replicateM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8hC: // global
           I64[Sp - 24] = block_cc8hx_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc8hG; else goto cc8hy;
       uc8hG: // global
           call _cc8hx(R1) args: 0, res: 0, upd: 0;
       cc8hy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc8hx() //  [R1]
         { info_tbl: [(cc8hx,
                       label: block_cc8hx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8hx: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Control.Monad.$wreplicateM_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:02.361050452 UTC

[section ""relreadonly" . Sc8hR_srt" { Sc8hR_srt:
 }]

