
==================== Tidy Core ====================
2018-03-16 16:04:54.499275271 UTC

Result size of Tidy Core
  = {terms: 1,420, types: 2,080, coercions: 487, joins: 0/0}

-- RHS size: {terms: 4, types: 3, coercions: 1, joins: 0/0}
Control.Exception.Base.$fShowPatternMatchFail_$cshowsPrec
  :: Int -> PatternMatchFail -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (ds1_d9Ph8 [Occ=Once] :: PatternMatchFail) ->
                 ++
                   @ Char
                   (ds1_d9Ph8
                    `cast` (Control.Exception.Base.N:PatternMatchFail[0]
                            :: (PatternMatchFail :: *) ~R# (String :: *)))}]
Control.Exception.Base.$fShowPatternMatchFail_$cshowsPrec
  = \ _ [Occ=Dead] (ds1_d9Ph8 :: PatternMatchFail) ->
      ++
        @ Char
        (ds1_d9Ph8
         `cast` (Control.Exception.Base.N:PatternMatchFail[0]
                 :: (PatternMatchFail :: *) ~R# (String :: *)))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionPatternMatchFail1
  :: PatternMatchFail -> PatternMatchFail
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (x_i7Jay [Occ=Once] :: PatternMatchFail) -> x_i7Jay}]
Control.Exception.Base.$fExceptionPatternMatchFail1
  = \ (x_i7Jay :: PatternMatchFail) -> x_i7Jay

-- RHS size: {terms: 6, types: 5, coercions: 7, joins: 0/0}
Control.Exception.Base.$fShowPatternMatchFail_$cshowList
  :: [PatternMatchFail] -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [PatternMatchFail])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ PatternMatchFail
                   ((++ @ Char)
                    `cast` (Sym (Control.Exception.Base.N:PatternMatchFail[0])
                            ->_R <[Char] -> [Char]>_R
                            :: (String -> [Char] -> [Char] :: *)
                               ~R# (PatternMatchFail -> [Char] -> [Char] :: *)))
                   ls_i7JaB
                   s_i7JaC}]
Control.Exception.Base.$fShowPatternMatchFail_$cshowList
  = \ (ls_i7JaB :: [PatternMatchFail]) (s_i7JaC :: String) ->
      showList__
        @ PatternMatchFail
        ((++ @ Char)
         `cast` (Sym (Control.Exception.Base.N:PatternMatchFail[0])
                 ->_R <[Char] -> [Char]>_R
                 :: (String -> [Char] -> [Char] :: *)
                    ~R# (PatternMatchFail -> [Char] -> [Char] :: *)))
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 3, joins: 0/0}
Control.Exception.Base.$fShowPatternMatchFail [InlPrag=NOUSERINLINE CONLIKE]
  :: Show PatternMatchFail
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: PatternMatchFail
                       Control.Exception.Base.$fShowPatternMatchFail_$cshowsPrec
                       Control.Exception.Base.$fExceptionPatternMatchFail1
                       `cast` (<PatternMatchFail>_R
                               ->_R Control.Exception.Base.N:PatternMatchFail[0]
                               :: (PatternMatchFail -> PatternMatchFail :: *)
                                  ~R# (PatternMatchFail -> String :: *))
                       Control.Exception.Base.$fShowPatternMatchFail_$cshowList]
Control.Exception.Base.$fShowPatternMatchFail
  = GHC.Show.C:Show
      @ PatternMatchFail
      Control.Exception.Base.$fShowPatternMatchFail_$cshowsPrec
      (Control.Exception.Base.$fExceptionPatternMatchFail1
       `cast` (<PatternMatchFail>_R
               ->_R Control.Exception.Base.N:PatternMatchFail[0]
               :: (PatternMatchFail -> PatternMatchFail :: *)
                  ~R# (PatternMatchFail -> String :: *)))
      Control.Exception.Base.$fShowPatternMatchFail_$cshowList

-- RHS size: {terms: 4, types: 3, coercions: 1, joins: 0/0}
Control.Exception.Base.$fShowRecSelError_$cshowsPrec
  :: Int -> RecSelError -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (ds1_d9Ph2 [Occ=Once] :: RecSelError) ->
                 ++
                   @ Char
                   (ds1_d9Ph2
                    `cast` (Control.Exception.Base.N:RecSelError[0]
                            :: (RecSelError :: *) ~R# (String :: *)))}]
Control.Exception.Base.$fShowRecSelError_$cshowsPrec
  = \ _ [Occ=Dead] (ds1_d9Ph2 :: RecSelError) ->
      ++
        @ Char
        (ds1_d9Ph2
         `cast` (Control.Exception.Base.N:RecSelError[0]
                 :: (RecSelError :: *) ~R# (String :: *)))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionRecSelError1
  :: RecSelError -> RecSelError
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (x_X7Jdz [Occ=Once] :: RecSelError) -> x_X7Jdz}]
Control.Exception.Base.$fExceptionRecSelError1
  = \ (x_X7Jdz :: RecSelError) -> x_X7Jdz

-- RHS size: {terms: 6, types: 5, coercions: 7, joins: 0/0}
Control.Exception.Base.$fShowRecSelError_$cshowList
  :: [RecSelError] -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [RecSelError])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ RecSelError
                   ((++ @ Char)
                    `cast` (Sym (Control.Exception.Base.N:RecSelError[0])
                            ->_R <[Char] -> [Char]>_R
                            :: (String -> [Char] -> [Char] :: *)
                               ~R# (RecSelError -> [Char] -> [Char] :: *)))
                   ls_i7JaB
                   s_i7JaC}]
Control.Exception.Base.$fShowRecSelError_$cshowList
  = \ (ls_i7JaB :: [RecSelError]) (s_i7JaC :: String) ->
      showList__
        @ RecSelError
        ((++ @ Char)
         `cast` (Sym (Control.Exception.Base.N:RecSelError[0])
                 ->_R <[Char] -> [Char]>_R
                 :: (String -> [Char] -> [Char] :: *)
                    ~R# (RecSelError -> [Char] -> [Char] :: *)))
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 3, joins: 0/0}
Control.Exception.Base.$fShowRecSelError [InlPrag=NOUSERINLINE CONLIKE]
  :: Show RecSelError
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: RecSelError
                       Control.Exception.Base.$fShowRecSelError_$cshowsPrec
                       Control.Exception.Base.$fExceptionRecSelError1
                       `cast` (<RecSelError>_R
                               ->_R Control.Exception.Base.N:RecSelError[0]
                               :: (RecSelError -> RecSelError :: *)
                                  ~R# (RecSelError -> String :: *))
                       Control.Exception.Base.$fShowRecSelError_$cshowList]
Control.Exception.Base.$fShowRecSelError
  = GHC.Show.C:Show
      @ RecSelError
      Control.Exception.Base.$fShowRecSelError_$cshowsPrec
      (Control.Exception.Base.$fExceptionRecSelError1
       `cast` (<RecSelError>_R
               ->_R Control.Exception.Base.N:RecSelError[0]
               :: (RecSelError -> RecSelError :: *)
                  ~R# (RecSelError -> String :: *)))
      Control.Exception.Base.$fShowRecSelError_$cshowList

-- RHS size: {terms: 4, types: 3, coercions: 1, joins: 0/0}
Control.Exception.Base.$fShowRecConError_$cshowsPrec
  :: Int -> RecConError -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (ds1_d9PgW [Occ=Once] :: RecConError) ->
                 ++
                   @ Char
                   (ds1_d9PgW
                    `cast` (Control.Exception.Base.N:RecConError[0]
                            :: (RecConError :: *) ~R# (String :: *)))}]
Control.Exception.Base.$fShowRecConError_$cshowsPrec
  = \ _ [Occ=Dead] (ds1_d9PgW :: RecConError) ->
      ++
        @ Char
        (ds1_d9PgW
         `cast` (Control.Exception.Base.N:RecConError[0]
                 :: (RecConError :: *) ~R# (String :: *)))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionRecConError1
  :: RecConError -> RecConError
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (x_X7JdF [Occ=Once] :: RecConError) -> x_X7JdF}]
Control.Exception.Base.$fExceptionRecConError1
  = \ (x_X7JdF :: RecConError) -> x_X7JdF

-- RHS size: {terms: 6, types: 5, coercions: 7, joins: 0/0}
Control.Exception.Base.$fShowRecConError_$cshowList
  :: [RecConError] -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [RecConError])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ RecConError
                   ((++ @ Char)
                    `cast` (Sym (Control.Exception.Base.N:RecConError[0])
                            ->_R <[Char] -> [Char]>_R
                            :: (String -> [Char] -> [Char] :: *)
                               ~R# (RecConError -> [Char] -> [Char] :: *)))
                   ls_i7JaB
                   s_i7JaC}]
Control.Exception.Base.$fShowRecConError_$cshowList
  = \ (ls_i7JaB :: [RecConError]) (s_i7JaC :: String) ->
      showList__
        @ RecConError
        ((++ @ Char)
         `cast` (Sym (Control.Exception.Base.N:RecConError[0])
                 ->_R <[Char] -> [Char]>_R
                 :: (String -> [Char] -> [Char] :: *)
                    ~R# (RecConError -> [Char] -> [Char] :: *)))
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 3, joins: 0/0}
Control.Exception.Base.$fShowRecConError [InlPrag=NOUSERINLINE CONLIKE]
  :: Show RecConError
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: RecConError
                       Control.Exception.Base.$fShowRecConError_$cshowsPrec
                       Control.Exception.Base.$fExceptionRecConError1
                       `cast` (<RecConError>_R
                               ->_R Control.Exception.Base.N:RecConError[0]
                               :: (RecConError -> RecConError :: *)
                                  ~R# (RecConError -> String :: *))
                       Control.Exception.Base.$fShowRecConError_$cshowList]
Control.Exception.Base.$fShowRecConError
  = GHC.Show.C:Show
      @ RecConError
      Control.Exception.Base.$fShowRecConError_$cshowsPrec
      (Control.Exception.Base.$fExceptionRecConError1
       `cast` (<RecConError>_R
               ->_R Control.Exception.Base.N:RecConError[0]
               :: (RecConError -> RecConError :: *)
                  ~R# (RecConError -> String :: *)))
      Control.Exception.Base.$fShowRecConError_$cshowList

-- RHS size: {terms: 4, types: 3, coercions: 1, joins: 0/0}
Control.Exception.Base.$fShowRecUpdError_$cshowsPrec
  :: Int -> RecUpdError -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (ds1_d9PgQ [Occ=Once] :: RecUpdError) ->
                 ++
                   @ Char
                   (ds1_d9PgQ
                    `cast` (Control.Exception.Base.N:RecUpdError[0]
                            :: (RecUpdError :: *) ~R# (String :: *)))}]
Control.Exception.Base.$fShowRecUpdError_$cshowsPrec
  = \ _ [Occ=Dead] (ds1_d9PgQ :: RecUpdError) ->
      ++
        @ Char
        (ds1_d9PgQ
         `cast` (Control.Exception.Base.N:RecUpdError[0]
                 :: (RecUpdError :: *) ~R# (String :: *)))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionRecUpdError1
  :: RecUpdError -> RecUpdError
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (x_X7JdL [Occ=Once] :: RecUpdError) -> x_X7JdL}]
Control.Exception.Base.$fExceptionRecUpdError1
  = \ (x_X7JdL :: RecUpdError) -> x_X7JdL

-- RHS size: {terms: 6, types: 5, coercions: 7, joins: 0/0}
Control.Exception.Base.$fShowRecUpdError_$cshowList
  :: [RecUpdError] -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [RecUpdError])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ RecUpdError
                   ((++ @ Char)
                    `cast` (Sym (Control.Exception.Base.N:RecUpdError[0])
                            ->_R <[Char] -> [Char]>_R
                            :: (String -> [Char] -> [Char] :: *)
                               ~R# (RecUpdError -> [Char] -> [Char] :: *)))
                   ls_i7JaB
                   s_i7JaC}]
Control.Exception.Base.$fShowRecUpdError_$cshowList
  = \ (ls_i7JaB :: [RecUpdError]) (s_i7JaC :: String) ->
      showList__
        @ RecUpdError
        ((++ @ Char)
         `cast` (Sym (Control.Exception.Base.N:RecUpdError[0])
                 ->_R <[Char] -> [Char]>_R
                 :: (String -> [Char] -> [Char] :: *)
                    ~R# (RecUpdError -> [Char] -> [Char] :: *)))
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 3, joins: 0/0}
Control.Exception.Base.$fShowRecUpdError [InlPrag=NOUSERINLINE CONLIKE]
  :: Show RecUpdError
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: RecUpdError
                       Control.Exception.Base.$fShowRecUpdError_$cshowsPrec
                       Control.Exception.Base.$fExceptionRecUpdError1
                       `cast` (<RecUpdError>_R
                               ->_R Control.Exception.Base.N:RecUpdError[0]
                               :: (RecUpdError -> RecUpdError :: *)
                                  ~R# (RecUpdError -> String :: *))
                       Control.Exception.Base.$fShowRecUpdError_$cshowList]
Control.Exception.Base.$fShowRecUpdError
  = GHC.Show.C:Show
      @ RecUpdError
      Control.Exception.Base.$fShowRecUpdError_$cshowsPrec
      (Control.Exception.Base.$fExceptionRecUpdError1
       `cast` (<RecUpdError>_R
               ->_R Control.Exception.Base.N:RecUpdError[0]
               :: (RecUpdError -> RecUpdError :: *)
                  ~R# (RecUpdError -> String :: *)))
      Control.Exception.Base.$fShowRecUpdError_$cshowList

-- RHS size: {terms: 4, types: 3, coercions: 1, joins: 0/0}
Control.Exception.Base.$fShowNoMethodError_$cshowsPrec
  :: Int -> NoMethodError -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (ds1_d9PgK [Occ=Once] :: NoMethodError) ->
                 ++
                   @ Char
                   (ds1_d9PgK
                    `cast` (Control.Exception.Base.N:NoMethodError[0]
                            :: (NoMethodError :: *) ~R# (String :: *)))}]
Control.Exception.Base.$fShowNoMethodError_$cshowsPrec
  = \ _ [Occ=Dead] (ds1_d9PgK :: NoMethodError) ->
      ++
        @ Char
        (ds1_d9PgK
         `cast` (Control.Exception.Base.N:NoMethodError[0]
                 :: (NoMethodError :: *) ~R# (String :: *)))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionNoMethodError1
  :: NoMethodError -> NoMethodError
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (x_X7JdR [Occ=Once] :: NoMethodError) -> x_X7JdR}]
Control.Exception.Base.$fExceptionNoMethodError1
  = \ (x_X7JdR :: NoMethodError) -> x_X7JdR

-- RHS size: {terms: 6, types: 5, coercions: 7, joins: 0/0}
Control.Exception.Base.$fShowNoMethodError_$cshowList
  :: [NoMethodError] -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [NoMethodError])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ NoMethodError
                   ((++ @ Char)
                    `cast` (Sym (Control.Exception.Base.N:NoMethodError[0])
                            ->_R <[Char] -> [Char]>_R
                            :: (String -> [Char] -> [Char] :: *)
                               ~R# (NoMethodError -> [Char] -> [Char] :: *)))
                   ls_i7JaB
                   s_i7JaC}]
Control.Exception.Base.$fShowNoMethodError_$cshowList
  = \ (ls_i7JaB :: [NoMethodError]) (s_i7JaC :: String) ->
      showList__
        @ NoMethodError
        ((++ @ Char)
         `cast` (Sym (Control.Exception.Base.N:NoMethodError[0])
                 ->_R <[Char] -> [Char]>_R
                 :: (String -> [Char] -> [Char] :: *)
                    ~R# (NoMethodError -> [Char] -> [Char] :: *)))
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 3, joins: 0/0}
Control.Exception.Base.$fShowNoMethodError [InlPrag=NOUSERINLINE CONLIKE]
  :: Show NoMethodError
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: NoMethodError
                       Control.Exception.Base.$fShowNoMethodError_$cshowsPrec
                       Control.Exception.Base.$fExceptionNoMethodError1
                       `cast` (<NoMethodError>_R
                               ->_R Control.Exception.Base.N:NoMethodError[0]
                               :: (NoMethodError -> NoMethodError :: *)
                                  ~R# (NoMethodError -> String :: *))
                       Control.Exception.Base.$fShowNoMethodError_$cshowList]
Control.Exception.Base.$fShowNoMethodError
  = GHC.Show.C:Show
      @ NoMethodError
      Control.Exception.Base.$fShowNoMethodError_$cshowsPrec
      (Control.Exception.Base.$fExceptionNoMethodError1
       `cast` (<NoMethodError>_R
               ->_R Control.Exception.Base.N:NoMethodError[0]
               :: (NoMethodError -> NoMethodError :: *)
                  ~R# (NoMethodError -> String :: *)))
      Control.Exception.Base.$fShowNoMethodError_$cshowList

-- RHS size: {terms: 4, types: 3, coercions: 1, joins: 0/0}
Control.Exception.Base.$fShowTypeError_$cshowsPrec
  :: Int -> TypeError -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (ds1_d9PgE [Occ=Once] :: TypeError) ->
                 ++
                   @ Char
                   (ds1_d9PgE
                    `cast` (Control.Exception.Base.N:TypeError[0]
                            :: (TypeError :: *) ~R# (String :: *)))}]
Control.Exception.Base.$fShowTypeError_$cshowsPrec
  = \ _ [Occ=Dead] (ds1_d9PgE :: TypeError) ->
      ++
        @ Char
        (ds1_d9PgE
         `cast` (Control.Exception.Base.N:TypeError[0]
                 :: (TypeError :: *) ~R# (String :: *)))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionTypeError1
  :: TypeError -> TypeError
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (x_X7JdX [Occ=Once] :: TypeError) -> x_X7JdX}]
Control.Exception.Base.$fExceptionTypeError1
  = \ (x_X7JdX :: TypeError) -> x_X7JdX

-- RHS size: {terms: 6, types: 5, coercions: 7, joins: 0/0}
Control.Exception.Base.$fShowTypeError_$cshowList
  :: [TypeError] -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [TypeError])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ TypeError
                   ((++ @ Char)
                    `cast` (Sym (Control.Exception.Base.N:TypeError[0])
                            ->_R <[Char] -> [Char]>_R
                            :: (String -> [Char] -> [Char] :: *)
                               ~R# (TypeError -> [Char] -> [Char] :: *)))
                   ls_i7JaB
                   s_i7JaC}]
Control.Exception.Base.$fShowTypeError_$cshowList
  = \ (ls_i7JaB :: [TypeError]) (s_i7JaC :: String) ->
      showList__
        @ TypeError
        ((++ @ Char)
         `cast` (Sym (Control.Exception.Base.N:TypeError[0])
                 ->_R <[Char] -> [Char]>_R
                 :: (String -> [Char] -> [Char] :: *)
                    ~R# (TypeError -> [Char] -> [Char] :: *)))
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 3, joins: 0/0}
Control.Exception.Base.$fShowTypeError [InlPrag=NOUSERINLINE CONLIKE]
  :: Show TypeError
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: TypeError
                       Control.Exception.Base.$fShowTypeError_$cshowsPrec
                       Control.Exception.Base.$fExceptionTypeError1
                       `cast` (<TypeError>_R ->_R Control.Exception.Base.N:TypeError[0]
                               :: (TypeError -> TypeError :: *) ~R# (TypeError -> String :: *))
                       Control.Exception.Base.$fShowTypeError_$cshowList]
Control.Exception.Base.$fShowTypeError
  = GHC.Show.C:Show
      @ TypeError
      Control.Exception.Base.$fShowTypeError_$cshowsPrec
      (Control.Exception.Base.$fExceptionTypeError1
       `cast` (<TypeError>_R ->_R Control.Exception.Base.N:TypeError[0]
               :: (TypeError -> TypeError :: *) ~R# (TypeError -> String :: *)))
      Control.Exception.Base.$fShowTypeError_$cshowList

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionNonTermination2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Control.Exception.Base.$fExceptionNonTermination2 = "<<loop>>"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionNonTermination1 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Control.Exception.Base.$fExceptionNonTermination1
  = unpackCString# Control.Exception.Base.$fExceptionNonTermination2

-- RHS size: {terms: 9, types: 5, coercions: 0, joins: 0/0}
Control.Exception.Base.$fShowNonTermination_$cshowsPrec
  :: Int -> NonTermination -> ShowS
[GblId,
 Arity=3,
 Str=<L,A><S,1*H><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead]
                 (ds1_d9Pgz [Occ=Once!] :: NonTermination)
                 (eta_B1 [Occ=Once] :: String) ->
                 case ds1_d9Pgz of { NonTermination ->
                 augment
                   @ Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      foldr
                        @ Char
                        @ b_i7JbU
                        c_i7JbV
                        n_i7JbW
                        Control.Exception.Base.$fExceptionNonTermination1)
                   eta_B1
                 }}]
Control.Exception.Base.$fShowNonTermination_$cshowsPrec
  = \ _ [Occ=Dead]
      (ds1_d9Pgz :: NonTermination)
      (eta_B1 :: String) ->
      case ds1_d9Pgz of { NonTermination ->
      ++ @ Char Control.Exception.Base.$fExceptionNonTermination1 eta_B1
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionNonTermination_$cshow
  :: NonTermination -> String
[GblId,
 Arity=1,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_X7Je7 [Occ=Once!] :: NonTermination) ->
                 case x_X7Je7 of { NonTermination ->
                 Control.Exception.Base.$fExceptionNonTermination1
                 }}]
Control.Exception.Base.$fExceptionNonTermination_$cshow
  = \ (x_X7Je7 :: NonTermination) ->
      case x_X7Je7 of { NonTermination ->
      Control.Exception.Base.$fExceptionNonTermination1
      }

-- RHS size: {terms: 8, types: 4, coercions: 0, joins: 0/0}
Control.Exception.Base.$fShowNonTermination1
  :: NonTermination -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*H><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d9Pgz [Occ=Once!] :: NonTermination)
                 (eta_B1 [Occ=Once] :: String) ->
                 case ds_d9Pgz of { NonTermination ->
                 augment
                   @ Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      foldr
                        @ Char
                        @ b_i7JbU
                        c_i7JbV
                        n_i7JbW
                        Control.Exception.Base.$fExceptionNonTermination1)
                   eta_B1
                 }}]
Control.Exception.Base.$fShowNonTermination1
  = \ (ds_d9Pgz :: NonTermination) (eta_B1 :: String) ->
      case ds_d9Pgz of { NonTermination ->
      ++ @ Char Control.Exception.Base.$fExceptionNonTermination1 eta_B1
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
Control.Exception.Base.$fShowNonTermination_$cshowList
  :: [NonTermination] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [NonTermination])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ NonTermination
                   Control.Exception.Base.$fShowNonTermination1
                   ls_i7JaB
                   s_i7JaC}]
Control.Exception.Base.$fShowNonTermination_$cshowList
  = \ (ls_i7JaB :: [NonTermination]) (s_i7JaC :: String) ->
      showList__
        @ NonTermination
        Control.Exception.Base.$fShowNonTermination1
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
Control.Exception.Base.$fShowNonTermination [InlPrag=NOUSERINLINE CONLIKE]
  :: Show NonTermination
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: NonTermination
                       Control.Exception.Base.$fShowNonTermination_$cshowsPrec
                       Control.Exception.Base.$fExceptionNonTermination_$cshow
                       Control.Exception.Base.$fShowNonTermination_$cshowList]
Control.Exception.Base.$fShowNonTermination
  = GHC.Show.C:Show
      @ NonTermination
      Control.Exception.Base.$fShowNonTermination_$cshowsPrec
      Control.Exception.Base.$fExceptionNonTermination_$cshow
      Control.Exception.Base.$fShowNonTermination_$cshowList

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionNestedAtomically2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 120 0}]
Control.Exception.Base.$fExceptionNestedAtomically2
  = "Control.Concurrent.STM.atomically was nested"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionNestedAtomically1 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Control.Exception.Base.$fExceptionNestedAtomically1
  = unpackCString#
      Control.Exception.Base.$fExceptionNestedAtomically2

-- RHS size: {terms: 9, types: 5, coercions: 0, joins: 0/0}
Control.Exception.Base.$fShowNestedAtomically_$cshowsPrec
  :: Int -> NestedAtomically -> ShowS
[GblId,
 Arity=3,
 Str=<L,A><S,1*H><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead]
                 (ds1_d9Pgu [Occ=Once!] :: NestedAtomically)
                 (eta_B1 [Occ=Once] :: String) ->
                 case ds1_d9Pgu of { NestedAtomically ->
                 augment
                   @ Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      foldr
                        @ Char
                        @ b_i7JbU
                        c_i7JbV
                        n_i7JbW
                        Control.Exception.Base.$fExceptionNestedAtomically1)
                   eta_B1
                 }}]
Control.Exception.Base.$fShowNestedAtomically_$cshowsPrec
  = \ _ [Occ=Dead]
      (ds1_d9Pgu :: NestedAtomically)
      (eta_B1 :: String) ->
      case ds1_d9Pgu of { NestedAtomically ->
      ++
        @ Char Control.Exception.Base.$fExceptionNestedAtomically1 eta_B1
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionNestedAtomically_$cshow
  :: NestedAtomically -> String
[GblId,
 Arity=1,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_X7Jei [Occ=Once!] :: NestedAtomically) ->
                 case x_X7Jei of { NestedAtomically ->
                 Control.Exception.Base.$fExceptionNestedAtomically1
                 }}]
Control.Exception.Base.$fExceptionNestedAtomically_$cshow
  = \ (x_X7Jei :: NestedAtomically) ->
      case x_X7Jei of { NestedAtomically ->
      Control.Exception.Base.$fExceptionNestedAtomically1
      }

-- RHS size: {terms: 8, types: 4, coercions: 0, joins: 0/0}
Control.Exception.Base.$fShowNestedAtomically1
  :: NestedAtomically -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*H><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d9Pgu [Occ=Once!] :: NestedAtomically)
                 (eta_B1 [Occ=Once] :: String) ->
                 case ds_d9Pgu of { NestedAtomically ->
                 augment
                   @ Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      foldr
                        @ Char
                        @ b_i7JbU
                        c_i7JbV
                        n_i7JbW
                        Control.Exception.Base.$fExceptionNestedAtomically1)
                   eta_B1
                 }}]
Control.Exception.Base.$fShowNestedAtomically1
  = \ (ds_d9Pgu :: NestedAtomically) (eta_B1 :: String) ->
      case ds_d9Pgu of { NestedAtomically ->
      ++
        @ Char Control.Exception.Base.$fExceptionNestedAtomically1 eta_B1
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
Control.Exception.Base.$fShowNestedAtomically_$cshowList
  :: [NestedAtomically] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [NestedAtomically])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ NestedAtomically
                   Control.Exception.Base.$fShowNestedAtomically1
                   ls_i7JaB
                   s_i7JaC}]
Control.Exception.Base.$fShowNestedAtomically_$cshowList
  = \ (ls_i7JaB :: [NestedAtomically]) (s_i7JaC :: String) ->
      showList__
        @ NestedAtomically
        Control.Exception.Base.$fShowNestedAtomically1
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
Control.Exception.Base.$fShowNestedAtomically [InlPrag=NOUSERINLINE CONLIKE]
  :: Show NestedAtomically
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: NestedAtomically
                       Control.Exception.Base.$fShowNestedAtomically_$cshowsPrec
                       Control.Exception.Base.$fExceptionNestedAtomically_$cshow
                       Control.Exception.Base.$fShowNestedAtomically_$cshowList]
Control.Exception.Base.$fShowNestedAtomically
  = GHC.Show.C:Show
      @ NestedAtomically
      Control.Exception.Base.$fShowNestedAtomically_$cshowsPrec
      Control.Exception.Base.$fExceptionNestedAtomically_$cshow
      Control.Exception.Base.$fShowNestedAtomically_$cshowList

-- RHS size: {terms: 30, types: 32, coercions: 4, joins: 0/0}
Control.Exception.Base.catchJust1
  :: forall e b a.
     Exception e =>
     (e -> Maybe b)
     -> IO a
     -> (b -> IO a)
     -> State# RealWorld
     -> (# State# RealWorld, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(A,A,1*C1(U),1*C1(U),A)><L,1*C1(U)><L,1*C1(U)><L,1*C1(C1(U))><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 0 60 0] 156 0}]
Control.Exception.Base.catchJust1
  = \ (@ e_a9P80)
      (@ b_a9P81)
      (@ a_a9P82)
      ($dException_a9P84 :: Exception e_a9P80)
      (p_a9OUv :: e_a9P80 -> Maybe b_a9P81)
      (a1_a9OUw :: IO a_a9P82)
      (handler_a9OUx :: b_a9P81 -> IO a_a9P82)
      (eta_i8SfW :: State# RealWorld) ->
      catch#
        @ a_a9P82
        @ SomeException
        (a1_a9OUw
         `cast` (GHC.Types.N:IO[0] <a_a9P82>_R
                 :: (IO a_a9P82 :: *)
                    ~R# (State# RealWorld -> (# State# RealWorld, a_a9P82 #) :: *)))
        (\ (e1_i8SfX [OS=OneShot] :: SomeException) ->
           case fromException @ e_a9P80 $dException_a9P84 e1_i8SfX of {
             Nothing -> raiseIO# @ SomeException @ a_a9P82 e1_i8SfX;
             Just e'_i8Sg2 ->
               case p_a9OUv e'_i8Sg2 of {
                 Nothing ->
                   GHC.IO.throwIO1 @ e_a9P80 @ a_a9P82 $dException_a9P84 e'_i8Sg2;
                 Just b1_a9OUA ->
                   (handler_a9OUx b1_a9OUA)
                   `cast` (GHC.Types.N:IO[0] <a_a9P82>_R
                           :: (IO a_a9P82 :: *)
                              ~R# (State# RealWorld -> (# State# RealWorld, a_a9P82 #) :: *))
               }
           })
        eta_i8SfW

-- RHS size: {terms: 1, types: 0, coercions: 26, joins: 0/0}
catchJust
  :: forall e b a.
     Exception e =>
     (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(A,A,1*C1(U),1*C1(U),A)><L,1*C1(U)><L,1*C1(U)><L,1*C1(C1(U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Control.Exception.Base.catchJust1
               `cast` (forall (e :: <*>_N) (b :: <*>_N) (a :: <*>_N).
                       <Exception e>_R
                       ->_R <e -> Maybe b>_R
                       ->_R <IO a>_R
                       ->_R <b -> IO a>_R
                       ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall e b a.
                           Exception e =>
                           (e -> Maybe b)
                           -> IO a
                           -> (b -> IO a)
                           -> State# RealWorld
                           -> (# State# RealWorld, a #) :: *)
                          ~R# (forall e b a.
                               Exception e =>
                               (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a :: *))}]
catchJust
  = Control.Exception.Base.catchJust1
    `cast` (forall (e :: <*>_N) (b :: <*>_N) (a :: <*>_N).
            <Exception e>_R
            ->_R <e -> Maybe b>_R
            ->_R <IO a>_R
            ->_R <b -> IO a>_R
            ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall e b a.
                Exception e =>
                (e -> Maybe b)
                -> IO a
                -> (b -> IO a)
                -> State# RealWorld
                -> (# State# RealWorld, a #) :: *)
               ~R# (forall e b a.
                    Exception e =>
                    (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a :: *))

-- RHS size: {terms: 14, types: 21, coercions: 0, joins: 0/0}
Control.Exception.Base.handleJust1
  :: forall e b a.
     Exception e =>
     (e -> Maybe b)
     -> (b -> IO a)
     -> IO a
     -> State# RealWorld
     -> (# State# RealWorld, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(U),C(U),A)><L,1*C1(U)><L,1*C1(C1(U))><L,1*C1(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ e_a9P8q)
                 (@ b_a9P8r)
                 (@ a_a9P8s)
                 ($dException_a9P8u [Occ=Once] :: Exception e_a9P8q)
                 (p_a9OUB [Occ=Once] :: e_a9P8q -> Maybe b_a9P8r)
                 (eta_B3 [Occ=Once] :: b_a9P8r -> IO a_a9P8s)
                 (eta1_B2 [Occ=Once] :: IO a_a9P8s)
                 (eta2_B1 [Occ=Once] :: State# RealWorld) ->
                 Control.Exception.Base.catchJust1
                   @ e_a9P8q
                   @ b_a9P8r
                   @ a_a9P8s
                   $dException_a9P8u
                   p_a9OUB
                   eta1_B2
                   eta_B3
                   eta2_B1}]
Control.Exception.Base.handleJust1
  = \ (@ e_a9P8q)
      (@ b_a9P8r)
      (@ a_a9P8s)
      ($dException_a9P8u :: Exception e_a9P8q)
      (p_a9OUB :: e_a9P8q -> Maybe b_a9P8r)
      (eta_B3 :: b_a9P8r -> IO a_a9P8s)
      (eta1_B2 :: IO a_a9P8s)
      (eta2_B1 :: State# RealWorld) ->
      Control.Exception.Base.catchJust1
        @ e_a9P8q
        @ b_a9P8r
        @ a_a9P8s
        $dException_a9P8u
        p_a9OUB
        eta1_B2
        eta_B3
        eta2_B1

-- RHS size: {terms: 1, types: 0, coercions: 26, joins: 0/0}
handleJust
  :: forall e b a.
     Exception e =>
     (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(U),C(U),A)><L,1*C1(U)><L,1*C1(C1(U))><L,1*C1(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Control.Exception.Base.handleJust1
               `cast` (forall (e :: <*>_N) (b :: <*>_N) (a :: <*>_N).
                       <Exception e>_R
                       ->_R <e -> Maybe b>_R
                       ->_R <b -> IO a>_R
                       ->_R <IO a>_R
                       ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall e b a.
                           Exception e =>
                           (e -> Maybe b)
                           -> (b -> IO a)
                           -> IO a
                           -> State# RealWorld
                           -> (# State# RealWorld, a #) :: *)
                          ~R# (forall e b a.
                               Exception e =>
                               (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a :: *))}]
handleJust
  = Control.Exception.Base.handleJust1
    `cast` (forall (e :: <*>_N) (b :: <*>_N) (a :: <*>_N).
            <Exception e>_R
            ->_R <e -> Maybe b>_R
            ->_R <b -> IO a>_R
            ->_R <IO a>_R
            ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall e b a.
                Exception e =>
                (e -> Maybe b)
                -> (b -> IO a)
                -> IO a
                -> State# RealWorld
                -> (# State# RealWorld, a #) :: *)
               ~R# (forall e b a.
                    Exception e =>
                    (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a :: *))

-- RHS size: {terms: 11, types: 15, coercions: 0, joins: 0/0}
Control.Exception.Base.handle1
  :: forall e a.
     Exception e =>
     (e -> IO a)
     -> IO a -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(U),A)><L,1*C1(C1(U))><L,1*C1(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ e_a9P7P)
                 (@ a_a9P7Q)
                 ($dException_a9P7S [Occ=Once] :: Exception e_a9P7P)
                 (eta_X3v [Occ=Once] :: e_a9P7P -> IO a_a9P7Q)
                 (eta1_X6Y [Occ=Once] :: IO a_a9P7Q)
                 (eta2_B1 [Occ=Once] :: State# RealWorld) ->
                 GHC.IO.catch1
                   @ e_a9P7P @ a_a9P7Q $dException_a9P7S eta1_X6Y eta_X3v eta2_B1}]
Control.Exception.Base.handle1
  = \ (@ e_a9P7P)
      (@ a_a9P7Q)
      ($dException_a9P7S :: Exception e_a9P7P)
      (eta_X3v :: e_a9P7P -> IO a_a9P7Q)
      (eta1_X6Y :: IO a_a9P7Q)
      (eta2_B1 :: State# RealWorld) ->
      GHC.IO.catch1
        @ e_a9P7P @ a_a9P7Q $dException_a9P7S eta1_X6Y eta_X3v eta2_B1

-- RHS size: {terms: 1, types: 0, coercions: 19, joins: 0/0}
handle :: forall e a. Exception e => (e -> IO a) -> IO a -> IO a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(U),A)><L,1*C1(C1(U))><L,1*C1(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Control.Exception.Base.handle1
               `cast` (forall (e :: <*>_N) (a :: <*>_N).
                       <Exception e>_R
                       ->_R <e -> IO a>_R
                       ->_R <IO a>_R
                       ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall e a.
                           Exception e =>
                           (e -> IO a)
                           -> IO a -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                          ~R# (forall e a.
                               Exception e =>
                               (e -> IO a) -> IO a -> IO a :: *))}]
handle
  = Control.Exception.Base.handle1
    `cast` (forall (e :: <*>_N) (a :: <*>_N).
            <Exception e>_R
            ->_R <e -> IO a>_R
            ->_R <IO a>_R
            ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall e a.
                Exception e =>
                (e -> IO a)
                -> IO a -> State# RealWorld -> (# State# RealWorld, a #) :: *)
               ~R# (forall e a. Exception e => (e -> IO a) -> IO a -> IO a :: *))

-- RHS size: {terms: 13, types: 16, coercions: 0, joins: 0/0}
Control.Exception.Base.mapException1
  :: forall e1 e2 a.
     (e1 -> e2)
     -> e1
     -> Exception e2 => State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<B,1*C1(U)><B,U><B,1*U(A,A,1*C1(U),A,A)><B,U>x,
 Unf=OtherCon []]
Control.Exception.Base.mapException1
  = \ (@ e1_a9P7y)
      (@ e2_a9P7z)
      (@ a_a9P7A)
      (f_a9OUC :: e1_a9P7y -> e2_a9P7z)
      (e'_i8Sg2 :: e1_a9P7y)
      ($dException_a9P7D :: Exception e2_a9P7z)
      (eta_i9Phq :: State# RealWorld) ->
      raiseIO#
        @ SomeException
        @ a_a9P7A
        (toException @ e2_a9P7z $dException_a9P7D (f_a9OUC e'_i8Sg2))
        eta_i9Phq

-- RHS size: {terms: 37, types: 66, coercions: 0, joins: 0/0}
mapException
  :: forall e1 e2 a.
     (Exception e1, Exception e2) =>
     (e1 -> e2) -> a -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(U),A)><L,1*U(A,A,1*C1(U),A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0 0] 149 0}]
mapException
  = \ (@ e1_a9P7y)
      (@ e2_a9P7z)
      (@ a_a9P7A)
      ($dException_a9P7C :: Exception e1_a9P7y)
      ($dException1_a9P7D :: Exception e2_a9P7z)
      (f_a9OUC :: e1_a9P7y -> e2_a9P7z)
      (v_a9OUD :: a_a9P7A) ->
      case runRW#
             @ ('TupleRep '['TupleRep '[], 'LiftedRep])
             @ (# State# RealWorld, a_a9P7A #)
             (\ (s_i91ZD [OS=OneShot] :: State# RealWorld) ->
                case noDuplicate# @ RealWorld s_i91ZD of s'_i91ZE { __DEFAULT ->
                catch#
                  @ a_a9P7A
                  @ SomeException
                  (\ (s1_i9Phx [OS=OneShot] :: State# RealWorld) ->
                     seq# @ a_a9P7A @ RealWorld v_a9OUD s1_i9Phx)
                  (\ (e4_i8SfX [OS=OneShot] :: SomeException) ->
                     case fromException @ e1_a9P7y $dException_a9P7C e4_i8SfX of {
                       Nothing -> raiseIO# @ SomeException @ a_a9P7A e4_i8SfX;
                       Just e'_i8Sg2 ->
                         \ (eta_i9Phq [OS=OneShot] :: State# RealWorld) ->
                           Control.Exception.Base.mapException1
                             @ e1_a9P7y
                             @ e2_a9P7z
                             @ a_a9P7A
                             f_a9OUC
                             e'_i8Sg2
                             $dException1_a9P7D
                             eta_i9Phq
                     })
                  s'_i91ZE
                })
      of
      { (# ipv_i91ZH, ipv1_i91ZI #) ->
      ipv1_i91ZI
      }

-- RHS size: {terms: 31, types: 60, coercions: 2, joins: 0/0}
Control.Exception.Base.try1
  :: forall e a.
     Exception e =>
     IO a -> State# RealWorld -> (# State# RealWorld, Either e a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(U),A)><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 60 0] 107 0}]
Control.Exception.Base.try1
  = \ (@ e_a9P6G)
      (@ a_a9P6H)
      ($dException_a9P6J :: Exception e_a9P6G)
      (a1_a9OUF :: IO a_a9P6H)
      (eta_i8SfW :: State# RealWorld) ->
      catch#
        @ (Either e_a9P6G a_a9P6H)
        @ SomeException
        (\ (s_i7IAv [OS=OneShot] :: State# RealWorld) ->
           case (a1_a9OUF
                 `cast` (GHC.Types.N:IO[0] <a_a9P6H>_R
                         :: (IO a_a9P6H :: *)
                            ~R# (State# RealWorld -> (# State# RealWorld, a_a9P6H #) :: *)))
                  s_i7IAv
           of
           { (# ipv_i7IAy, ipv1_i7IAz #) ->
           (# ipv_i7IAy, Data.Either.Right @ e_a9P6G @ a_a9P6H ipv1_i7IAz #)
           })
        (\ (e1_i8SfX [OS=OneShot] :: SomeException)
           (eta1_B1 [OS=OneShot] :: State# RealWorld) ->
           case fromException @ e_a9P6G $dException_a9P6J e1_i8SfX of {
             Nothing ->
               raiseIO#
                 @ SomeException @ (Either e_a9P6G a_a9P6H) e1_i8SfX eta1_B1;
             Just e'_i8Sg2 ->
               (# eta1_B1, Data.Either.Left @ e_a9P6G @ a_a9P6H e'_i8Sg2 #)
           })
        eta_i8SfW

-- RHS size: {terms: 1, types: 0, coercions: 17, joins: 0/0}
try :: forall e a. Exception e => IO a -> IO (Either e a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(U),A)><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Control.Exception.Base.try1
               `cast` (forall (e :: <*>_N) (a :: <*>_N).
                       <Exception e>_R
                       ->_R <IO a>_R
                       ->_R Sym (GHC.Types.N:IO[0] <Either e a>_R)
                       :: (forall e a.
                           Exception e =>
                           IO a
                           -> State# RealWorld -> (# State# RealWorld, Either e a #) :: *)
                          ~R# (forall e a. Exception e => IO a -> IO (Either e a) :: *))}]
try
  = Control.Exception.Base.try1
    `cast` (forall (e :: <*>_N) (a :: <*>_N).
            <Exception e>_R
            ->_R <IO a>_R
            ->_R Sym (GHC.Types.N:IO[0] <Either e a>_R)
            :: (forall e a.
                Exception e =>
                IO a
                -> State# RealWorld -> (# State# RealWorld, Either e a #) :: *)
               ~R# (forall e a. Exception e => IO a -> IO (Either e a) :: *))

-- RHS size: {terms: 34, types: 66, coercions: 0, joins: 0/0}
Control.Exception.Base.tryJust1
  :: forall e b a.
     Exception e =>
     (e -> Maybe b)
     -> IO a -> State# RealWorld -> (# State# RealWorld, Either b a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,1*C1(U),1*C1(U),A)><L,1*C1(U)><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 60 0 0] 150 60}]
Control.Exception.Base.tryJust1
  = \ (@ e_a9P74)
      (@ b_a9P75)
      (@ a_a9P76)
      ($dException_a9P78 :: Exception e_a9P74)
      (p_a9OUI :: e_a9P74 -> Maybe b_a9P75)
      (a1_a9OUJ :: IO a_a9P76)
      (s_i7IAv :: State# RealWorld) ->
      case Control.Exception.Base.try1
             @ e_a9P74 @ a_a9P76 $dException_a9P78 a1_a9OUJ s_i7IAv
      of
      { (# ipv_i7IAy, ipv1_i7IAz #) ->
      case ipv1_i7IAz of {
        Left e1_a9OUM ->
          case p_a9OUI e1_a9OUM of {
            Nothing ->
              GHC.IO.throwIO1
                @ e_a9P74
                @ (Either b_a9P75 a_a9P76)
                $dException_a9P78
                e1_a9OUM
                ipv_i7IAy;
            Just b1_a9OUN ->
              (# ipv_i7IAy, Data.Either.Left @ b_a9P75 @ a_a9P76 b1_a9OUN #)
          };
        Right v_a9OUL ->
          (# ipv_i7IAy, Data.Either.Right @ b_a9P75 @ a_a9P76 v_a9OUL #)
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 24, joins: 0/0}
tryJust
  :: forall e b a.
     Exception e =>
     (e -> Maybe b) -> IO a -> IO (Either b a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,1*C1(U),1*C1(U),A)><L,1*C1(U)><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Control.Exception.Base.tryJust1
               `cast` (forall (e :: <*>_N) (b :: <*>_N) (a :: <*>_N).
                       <Exception e>_R
                       ->_R <e -> Maybe b>_R
                       ->_R <IO a>_R
                       ->_R Sym (GHC.Types.N:IO[0] <Either b a>_R)
                       :: (forall e b a.
                           Exception e =>
                           (e -> Maybe b)
                           -> IO a
                           -> State# RealWorld
                           -> (# State# RealWorld, Either b a #) :: *)
                          ~R# (forall e b a.
                               Exception e =>
                               (e -> Maybe b) -> IO a -> IO (Either b a) :: *))}]
tryJust
  = Control.Exception.Base.tryJust1
    `cast` (forall (e :: <*>_N) (b :: <*>_N) (a :: <*>_N).
            <Exception e>_R
            ->_R <e -> Maybe b>_R
            ->_R <IO a>_R
            ->_R Sym (GHC.Types.N:IO[0] <Either b a>_R)
            :: (forall e b a.
                Exception e =>
                (e -> Maybe b)
                -> IO a
                -> State# RealWorld
                -> (# State# RealWorld, Either b a #) :: *)
               ~R# (forall e b a.
                    Exception e =>
                    (e -> Maybe b) -> IO a -> IO (Either b a) :: *))

-- RHS size: {terms: 17, types: 28, coercions: 4, joins: 0/0}
Control.Exception.Base.onException1
  :: forall a b.
     IO a -> IO b -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U(U,A))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a9P59)
                 (@ b_a9P5a)
                 (io_a9OUO [Occ=Once] :: IO a_a9P59)
                 (what_a9OUP [Occ=Once] :: IO b_a9P5a)
                 (eta_i8SfW [Occ=Once] :: State# RealWorld) ->
                 catch#
                   @ a_a9P59
                   @ SomeException
                   (io_a9OUO
                    `cast` (GHC.Types.N:IO[0] <a_a9P59>_R
                            :: (IO a_a9P59 :: *)
                               ~R# (State# RealWorld -> (# State# RealWorld, a_a9P59 #) :: *)))
                   (\ (e1_i8SfX [Occ=Once, OS=OneShot] :: SomeException)
                      (s_i7IAv [Occ=Once, OS=OneShot] :: State# RealWorld) ->
                      case (what_a9OUP
                            `cast` (GHC.Types.N:IO[0] <b_a9P5a>_R
                                    :: (IO b_a9P5a :: *)
                                       ~R# (State# RealWorld
                                            -> (# State# RealWorld, b_a9P5a #) :: *)))
                             s_i7IAv
                      of
                      { (# ipv_i7IAy [Occ=Once], _ [Occ=Dead] #) ->
                      raiseIO# @ SomeException @ a_a9P59 e1_i8SfX ipv_i7IAy
                      })
                   eta_i8SfW}]
Control.Exception.Base.onException1
  = \ (@ a_a9P59)
      (@ b_a9P5a)
      (io_a9OUO :: IO a_a9P59)
      (what_a9OUP :: IO b_a9P5a)
      (eta_i8SfW :: State# RealWorld) ->
      catch#
        @ a_a9P59
        @ SomeException
        (io_a9OUO
         `cast` (GHC.Types.N:IO[0] <a_a9P59>_R
                 :: (IO a_a9P59 :: *)
                    ~R# (State# RealWorld -> (# State# RealWorld, a_a9P59 #) :: *)))
        (\ (e1_i8SfX [OS=OneShot] :: SomeException)
           (s_i7IAv [OS=OneShot] :: State# RealWorld) ->
           case (what_a9OUP
                 `cast` (GHC.Types.N:IO[0] <b_a9P5a>_R
                         :: (IO b_a9P5a :: *)
                            ~R# (State# RealWorld -> (# State# RealWorld, b_a9P5a #) :: *)))
                  s_i7IAv
           of
           { (# ipv_i7IAy, ipv1_i7IAz #) ->
           raiseIO# @ SomeException @ a_a9P59 e1_i8SfX ipv_i7IAy
           })
        eta_i8SfW

-- RHS size: {terms: 1, types: 0, coercions: 15, joins: 0/0}
onException :: forall a b. IO a -> IO b -> IO a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U(U,A))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Control.Exception.Base.onException1
               `cast` (forall (a :: <*>_N) (b :: <*>_N).
                       <IO a>_R ->_R <IO b>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall a b.
                           IO a -> IO b -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                          ~R# (forall a b. IO a -> IO b -> IO a :: *))}]
onException
  = Control.Exception.Base.onException1
    `cast` (forall (a :: <*>_N) (b :: <*>_N).
            <IO a>_R ->_R <IO b>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall a b.
                IO a -> IO b -> State# RealWorld -> (# State# RealWorld, a #) :: *)
               ~R# (forall a b. IO a -> IO b -> IO a :: *))

-- RHS size: {terms: 106, types: 208, coercions: 24, joins: 0/0}
Control.Exception.Base.bracket1
  :: forall a b c.
     IO a
     -> (a -> IO b)
     -> (a -> IO c)
     -> State# RealWorld
     -> (# State# RealWorld, c #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,C(C1(U(U,A)))><L,1*C1(C1(U))><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [180 60 60 0] 432 60}]
Control.Exception.Base.bracket1
  = \ (@ a_a9P5v)
      (@ b_a9P5w)
      (@ c_a9P5x)
      (before_a9OUR :: IO a_a9P5v)
      (after_a9OUS :: a_a9P5v -> IO b_a9P5w)
      (thing_a9OUT :: a_a9P5v -> IO c_a9P5x)
      (eta_B1 :: State# RealWorld) ->
      case getMaskingState# eta_B1 of { (# ipv_i94TO, ipv1_i94TP #) ->
      case ipv1_i94TP of {
        __DEFAULT ->
          case (before_a9OUR
                `cast` (GHC.Types.N:IO[0] <a_a9P5v>_R
                        :: (IO a_a9P5v :: *)
                           ~R# (State# RealWorld -> (# State# RealWorld, a_a9P5v #) :: *)))
                 ipv_i94TO
          of
          { (# ipv2_i7IAy, ipv3_i7IAz #) ->
          case catch#
                 @ c_a9P5x
                 @ SomeException
                 (maskAsyncExceptions#
                    @ c_a9P5x
                    ((thing_a9OUT ipv3_i7IAz)
                     `cast` (GHC.Types.N:IO[0] <c_a9P5x>_R
                             :: (IO c_a9P5x :: *)
                                ~R# (State# RealWorld -> (# State# RealWorld, c_a9P5x #) :: *))))
                 (\ (e1_i8SfX [OS=OneShot] :: SomeException)
                    (s_X7IDQ [OS=OneShot] :: State# RealWorld) ->
                    case ((after_a9OUS ipv3_i7IAz)
                          `cast` (GHC.Types.N:IO[0] <b_a9P5w>_R
                                  :: (IO b_a9P5w :: *)
                                     ~R# (State# RealWorld
                                          -> (# State# RealWorld, b_a9P5w #) :: *)))
                           s_X7IDQ
                    of
                    { (# ipv4_X7IDW, ipv5_X7IDY #) ->
                    raiseIO# @ SomeException @ c_a9P5x e1_i8SfX ipv4_X7IDW
                    })
                 ipv2_i7IAy
          of
          { (# ipv4_X7IDU, ipv5_X7IDW #) ->
          case ((after_a9OUS ipv3_i7IAz)
                `cast` (GHC.Types.N:IO[0] <b_a9P5w>_R
                        :: (IO b_a9P5w :: *)
                           ~R# (State# RealWorld -> (# State# RealWorld, b_a9P5w #) :: *)))
                 ipv4_X7IDU
          of
          { (# ipv6_X7IE0, ipv7_X7IE2 #) ->
          (# ipv6_X7IE0, ipv5_X7IDW #)
          }
          }
          };
        0# ->
          maskAsyncExceptions#
            @ c_a9P5x
            (\ (s_i7IAv [OS=OneShot] :: State# RealWorld) ->
               case (before_a9OUR
                     `cast` (GHC.Types.N:IO[0] <a_a9P5v>_R
                             :: (IO a_a9P5v :: *)
                                ~R# (State# RealWorld -> (# State# RealWorld, a_a9P5v #) :: *)))
                      s_i7IAv
               of
               { (# ipv2_i7IAy, ipv3_i7IAz #) ->
               case catch#
                      @ c_a9P5x
                      @ SomeException
                      (unmaskAsyncExceptions#
                         @ c_a9P5x
                         ((thing_a9OUT ipv3_i7IAz)
                          `cast` (GHC.Types.N:IO[0] <c_a9P5x>_R
                                  :: (IO c_a9P5x :: *)
                                     ~R# (State# RealWorld
                                          -> (# State# RealWorld, c_a9P5x #) :: *))))
                      (\ (e1_i8SfX [OS=OneShot] :: SomeException)
                         (s1_X7IDQ [OS=OneShot] :: State# RealWorld) ->
                         case ((after_a9OUS ipv3_i7IAz)
                               `cast` (GHC.Types.N:IO[0] <b_a9P5w>_R
                                       :: (IO b_a9P5w :: *)
                                          ~R# (State# RealWorld
                                               -> (# State# RealWorld, b_a9P5w #) :: *)))
                                s1_X7IDQ
                         of
                         { (# ipv4_X7IDW, ipv5_X7IDY #) ->
                         raiseIO# @ SomeException @ c_a9P5x e1_i8SfX ipv4_X7IDW
                         })
                      ipv2_i7IAy
               of
               { (# ipv4_X7IDU, ipv5_X7IDW #) ->
               case ((after_a9OUS ipv3_i7IAz)
                     `cast` (GHC.Types.N:IO[0] <b_a9P5w>_R
                             :: (IO b_a9P5w :: *)
                                ~R# (State# RealWorld -> (# State# RealWorld, b_a9P5w #) :: *)))
                      ipv4_X7IDU
               of
               { (# ipv6_X7IE0, ipv7_X7IE2 #) ->
               (# ipv6_X7IE0, ipv5_X7IDW #)
               }
               }
               })
            ipv_i94TO;
        1# ->
          case (before_a9OUR
                `cast` (GHC.Types.N:IO[0] <a_a9P5v>_R
                        :: (IO a_a9P5v :: *)
                           ~R# (State# RealWorld -> (# State# RealWorld, a_a9P5v #) :: *)))
                 ipv_i94TO
          of
          { (# ipv2_i7IAy, ipv3_i7IAz #) ->
          case catch#
                 @ c_a9P5x
                 @ SomeException
                 (maskUninterruptible#
                    @ c_a9P5x
                    ((thing_a9OUT ipv3_i7IAz)
                     `cast` (GHC.Types.N:IO[0] <c_a9P5x>_R
                             :: (IO c_a9P5x :: *)
                                ~R# (State# RealWorld -> (# State# RealWorld, c_a9P5x #) :: *))))
                 (\ (e1_i8SfX [OS=OneShot] :: SomeException)
                    (s_X7IDQ [OS=OneShot] :: State# RealWorld) ->
                    case ((after_a9OUS ipv3_i7IAz)
                          `cast` (GHC.Types.N:IO[0] <b_a9P5w>_R
                                  :: (IO b_a9P5w :: *)
                                     ~R# (State# RealWorld
                                          -> (# State# RealWorld, b_a9P5w #) :: *)))
                           s_X7IDQ
                    of
                    { (# ipv4_X7IDW, ipv5_X7IDY #) ->
                    raiseIO# @ SomeException @ c_a9P5x e1_i8SfX ipv4_X7IDW
                    })
                 ipv2_i7IAy
          of
          { (# ipv4_X7IDU, ipv5_X7IDW #) ->
          case ((after_a9OUS ipv3_i7IAz)
                `cast` (GHC.Types.N:IO[0] <b_a9P5w>_R
                        :: (IO b_a9P5w :: *)
                           ~R# (State# RealWorld -> (# State# RealWorld, b_a9P5w #) :: *)))
                 ipv4_X7IDU
          of
          { (# ipv6_X7IE0, ipv7_X7IE2 #) ->
          (# ipv6_X7IE0, ipv5_X7IDW #)
          }
          }
          }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 23, joins: 0/0}
bracket :: forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,C(C1(U(U,A)))><L,1*C1(C1(U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Control.Exception.Base.bracket1
               `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                       <IO a>_R
                       ->_R <a -> IO b>_R
                       ->_R <a -> IO c>_R
                       ->_R Sym (GHC.Types.N:IO[0] <c>_R)
                       :: (forall a b c.
                           IO a
                           -> (a -> IO b)
                           -> (a -> IO c)
                           -> State# RealWorld
                           -> (# State# RealWorld, c #) :: *)
                          ~R# (forall a b c.
                               IO a -> (a -> IO b) -> (a -> IO c) -> IO c :: *))}]
bracket
  = Control.Exception.Base.bracket1
    `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
            <IO a>_R
            ->_R <a -> IO b>_R
            ->_R <a -> IO c>_R
            ->_R Sym (GHC.Types.N:IO[0] <c>_R)
            :: (forall a b c.
                IO a
                -> (a -> IO b)
                -> (a -> IO c)
                -> State# RealWorld
                -> (# State# RealWorld, c #) :: *)
               ~R# (forall a b c.
                    IO a -> (a -> IO b) -> (a -> IO c) -> IO c :: *))

-- RHS size: {terms: 14, types: 19, coercions: 0, joins: 0/0}
Control.Exception.Base.bracket_1
  :: forall a b c.
     IO a
     -> IO b -> IO c -> State# RealWorld -> (# State# RealWorld, c #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,C(U(U,A))><L,1*C1(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a9P5V)
                 (@ b_a9P5W)
                 (@ c_a9P5X)
                 (before_a9OV1 [Occ=Once] :: IO a_a9P5V)
                 (after_a9OV2 [Occ=OnceL] :: IO b_a9P5W)
                 (thing_a9OV3 [Occ=Once] :: IO c_a9P5X)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 Control.Exception.Base.bracket1
                   @ a_a9P5V
                   @ b_a9P5W
                   @ c_a9P5X
                   before_a9OV1
                   (\ _ [Occ=Dead] -> after_a9OV2)
                   (\ _ [Occ=Dead, OS=OneShot] -> thing_a9OV3)
                   eta_B1}]
Control.Exception.Base.bracket_1
  = \ (@ a_a9P5V)
      (@ b_a9P5W)
      (@ c_a9P5X)
      (before_a9OV1 :: IO a_a9P5V)
      (after_a9OV2 :: IO b_a9P5W)
      (thing_a9OV3 :: IO c_a9P5X)
      (eta_B1 :: State# RealWorld) ->
      Control.Exception.Base.bracket1
        @ a_a9P5V
        @ b_a9P5W
        @ c_a9P5X
        before_a9OV1
        (\ _ [Occ=Dead] -> after_a9OV2)
        (\ _ [Occ=Dead, OS=OneShot] -> thing_a9OV3)
        eta_B1

-- RHS size: {terms: 1, types: 0, coercions: 21, joins: 0/0}
bracket_ :: forall a b c. IO a -> IO b -> IO c -> IO c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,C(U(U,A))><L,1*C1(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Control.Exception.Base.bracket_1
               `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                       <IO a>_R
                       ->_R <IO b>_R
                       ->_R <IO c>_R
                       ->_R Sym (GHC.Types.N:IO[0] <c>_R)
                       :: (forall a b c.
                           IO a
                           -> IO b
                           -> IO c
                           -> State# RealWorld
                           -> (# State# RealWorld, c #) :: *)
                          ~R# (forall a b c. IO a -> IO b -> IO c -> IO c :: *))}]
bracket_
  = Control.Exception.Base.bracket_1
    `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
            <IO a>_R
            ->_R <IO b>_R
            ->_R <IO c>_R
            ->_R Sym (GHC.Types.N:IO[0] <c>_R)
            :: (forall a b c.
                IO a
                -> IO b
                -> IO c
                -> State# RealWorld
                -> (# State# RealWorld, c #) :: *)
               ~R# (forall a b c. IO a -> IO b -> IO c -> IO c :: *))

-- RHS size: {terms: 83, types: 169, coercions: 18, joins: 0/0}
Control.Exception.Base.finally1
  :: forall a b.
     IO a -> IO b -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><C(S(SL)),C(U(U,A))><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 360 0] 252 60}]
Control.Exception.Base.finally1
  = \ (@ a_a9P66)
      (@ b_a9P67)
      (a1_a9OUX :: IO a_a9P66)
      (sequel_a9OUY :: IO b_a9P67)
      (eta_B1 :: State# RealWorld) ->
      case getMaskingState# eta_B1 of { (# ipv_i94TO, ipv1_i94TP #) ->
      case ipv1_i94TP of {
        __DEFAULT ->
          case catch#
                 @ a_a9P66
                 @ SomeException
                 (maskAsyncExceptions#
                    @ a_a9P66
                    (a1_a9OUX
                     `cast` (GHC.Types.N:IO[0] <a_a9P66>_R
                             :: (IO a_a9P66 :: *)
                                ~R# (State# RealWorld -> (# State# RealWorld, a_a9P66 #) :: *))))
                 (\ (e1_i8SfX [OS=OneShot] :: SomeException)
                    (s_X7IDK [OS=OneShot] :: State# RealWorld) ->
                    case (sequel_a9OUY
                          `cast` (GHC.Types.N:IO[0] <b_a9P67>_R
                                  :: (IO b_a9P67 :: *)
                                     ~R# (State# RealWorld
                                          -> (# State# RealWorld, b_a9P67 #) :: *)))
                           s_X7IDK
                    of
                    { (# ipv2_i7IAy, ipv3_i7IAz #) ->
                    raiseIO# @ SomeException @ a_a9P66 e1_i8SfX ipv2_i7IAy
                    })
                 ipv_i94TO
          of
          { (# ipv2_i7IAy, ipv3_i7IAz #) ->
          case (sequel_a9OUY
                `cast` (GHC.Types.N:IO[0] <b_a9P67>_R
                        :: (IO b_a9P67 :: *)
                           ~R# (State# RealWorld -> (# State# RealWorld, b_a9P67 #) :: *)))
                 ipv2_i7IAy
          of
          { (# ipv4_X7IDU, ipv5_X7IDW #) ->
          (# ipv4_X7IDU, ipv3_i7IAz #)
          }
          };
        0# ->
          maskAsyncExceptions#
            @ a_a9P66
            (\ (s_i7IAv [OS=OneShot] :: State# RealWorld) ->
               case catch#
                      @ a_a9P66
                      @ SomeException
                      (unmaskAsyncExceptions#
                         @ a_a9P66
                         (a1_a9OUX
                          `cast` (GHC.Types.N:IO[0] <a_a9P66>_R
                                  :: (IO a_a9P66 :: *)
                                     ~R# (State# RealWorld
                                          -> (# State# RealWorld, a_a9P66 #) :: *))))
                      (\ (e1_i8SfX [OS=OneShot] :: SomeException)
                         (s1_X7IDK [OS=OneShot] :: State# RealWorld) ->
                         case (sequel_a9OUY
                               `cast` (GHC.Types.N:IO[0] <b_a9P67>_R
                                       :: (IO b_a9P67 :: *)
                                          ~R# (State# RealWorld
                                               -> (# State# RealWorld, b_a9P67 #) :: *)))
                                s1_X7IDK
                         of
                         { (# ipv2_i7IAy, ipv3_i7IAz #) ->
                         raiseIO# @ SomeException @ a_a9P66 e1_i8SfX ipv2_i7IAy
                         })
                      s_i7IAv
               of
               { (# ipv2_i7IAy, ipv3_i7IAz #) ->
               case (sequel_a9OUY
                     `cast` (GHC.Types.N:IO[0] <b_a9P67>_R
                             :: (IO b_a9P67 :: *)
                                ~R# (State# RealWorld -> (# State# RealWorld, b_a9P67 #) :: *)))
                      ipv2_i7IAy
               of
               { (# ipv4_X7IDU, ipv5_X7IDW #) ->
               (# ipv4_X7IDU, ipv3_i7IAz #)
               }
               })
            ipv_i94TO;
        1# ->
          case catch#
                 @ a_a9P66
                 @ SomeException
                 (maskUninterruptible#
                    @ a_a9P66
                    (a1_a9OUX
                     `cast` (GHC.Types.N:IO[0] <a_a9P66>_R
                             :: (IO a_a9P66 :: *)
                                ~R# (State# RealWorld -> (# State# RealWorld, a_a9P66 #) :: *))))
                 (\ (e1_i8SfX [OS=OneShot] :: SomeException)
                    (s_X7IDK [OS=OneShot] :: State# RealWorld) ->
                    case (sequel_a9OUY
                          `cast` (GHC.Types.N:IO[0] <b_a9P67>_R
                                  :: (IO b_a9P67 :: *)
                                     ~R# (State# RealWorld
                                          -> (# State# RealWorld, b_a9P67 #) :: *)))
                           s_X7IDK
                    of
                    { (# ipv2_i7IAy, ipv3_i7IAz #) ->
                    raiseIO# @ SomeException @ a_a9P66 e1_i8SfX ipv2_i7IAy
                    })
                 ipv_i94TO
          of
          { (# ipv2_i7IAy, ipv3_i7IAz #) ->
          case (sequel_a9OUY
                `cast` (GHC.Types.N:IO[0] <b_a9P67>_R
                        :: (IO b_a9P67 :: *)
                           ~R# (State# RealWorld -> (# State# RealWorld, b_a9P67 #) :: *)))
                 ipv2_i7IAy
          of
          { (# ipv4_X7IDU, ipv5_X7IDW #) ->
          (# ipv4_X7IDU, ipv3_i7IAz #)
          }
          }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 15, joins: 0/0}
finally :: forall a b. IO a -> IO b -> IO a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><C(S(SL)),C(U(U,A))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Control.Exception.Base.finally1
               `cast` (forall (a :: <*>_N) (b :: <*>_N).
                       <IO a>_R ->_R <IO b>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall a b.
                           IO a -> IO b -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                          ~R# (forall a b. IO a -> IO b -> IO a :: *))}]
finally
  = Control.Exception.Base.finally1
    `cast` (forall (a :: <*>_N) (b :: <*>_N).
            <IO a>_R ->_R <IO b>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall a b.
                IO a -> IO b -> State# RealWorld -> (# State# RealWorld, a #) :: *)
               ~R# (forall a b. IO a -> IO b -> IO a :: *))

-- RHS size: {terms: 76, types: 121, coercions: 18, joins: 0/0}
Control.Exception.Base.bracketOnError1
  :: forall a b c.
     IO a
     -> (a -> IO b)
     -> (a -> IO c)
     -> State# RealWorld
     -> (# State# RealWorld, c #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(C1(U(U,A)))><L,1*C1(C1(U))><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [180 60 60 0] 312 0}]
Control.Exception.Base.bracketOnError1
  = \ (@ a_a9P6r)
      (@ b_a9P6s)
      (@ c_a9P6t)
      (before_a9OV4 :: IO a_a9P6r)
      (after_a9OV5 :: a_a9P6r -> IO b_a9P6s)
      (thing_a9OV6 :: a_a9P6r -> IO c_a9P6t)
      (eta_B1 :: State# RealWorld) ->
      case getMaskingState# eta_B1 of { (# ipv_i94TO, ipv1_i94TP #) ->
      case ipv1_i94TP of {
        __DEFAULT ->
          case (before_a9OV4
                `cast` (GHC.Types.N:IO[0] <a_a9P6r>_R
                        :: (IO a_a9P6r :: *)
                           ~R# (State# RealWorld -> (# State# RealWorld, a_a9P6r #) :: *)))
                 ipv_i94TO
          of
          { (# ipv2_i7IAy, ipv3_i7IAz #) ->
          catch#
            @ c_a9P6t
            @ SomeException
            (maskAsyncExceptions#
               @ c_a9P6t
               ((thing_a9OV6 ipv3_i7IAz)
                `cast` (GHC.Types.N:IO[0] <c_a9P6t>_R
                        :: (IO c_a9P6t :: *)
                           ~R# (State# RealWorld -> (# State# RealWorld, c_a9P6t #) :: *))))
            (\ (e1_i8SfX [OS=OneShot] :: SomeException)
               (s_X7IDT [OS=OneShot] :: State# RealWorld) ->
               case ((after_a9OV5 ipv3_i7IAz)
                     `cast` (GHC.Types.N:IO[0] <b_a9P6s>_R
                             :: (IO b_a9P6s :: *)
                                ~R# (State# RealWorld -> (# State# RealWorld, b_a9P6s #) :: *)))
                      s_X7IDT
               of
               { (# ipv4_X7IDZ, ipv5_X7IE1 #) ->
               raiseIO# @ SomeException @ c_a9P6t e1_i8SfX ipv4_X7IDZ
               })
            ipv2_i7IAy
          };
        0# ->
          maskAsyncExceptions#
            @ c_a9P6t
            (\ (s_i7IAv [OS=OneShot] :: State# RealWorld) ->
               case (before_a9OV4
                     `cast` (GHC.Types.N:IO[0] <a_a9P6r>_R
                             :: (IO a_a9P6r :: *)
                                ~R# (State# RealWorld -> (# State# RealWorld, a_a9P6r #) :: *)))
                      s_i7IAv
               of
               { (# ipv2_i7IAy, ipv3_i7IAz #) ->
               catch#
                 @ c_a9P6t
                 @ SomeException
                 (unmaskAsyncExceptions#
                    @ c_a9P6t
                    ((thing_a9OV6 ipv3_i7IAz)
                     `cast` (GHC.Types.N:IO[0] <c_a9P6t>_R
                             :: (IO c_a9P6t :: *)
                                ~R# (State# RealWorld -> (# State# RealWorld, c_a9P6t #) :: *))))
                 (\ (e1_i8SfX [OS=OneShot] :: SomeException)
                    (s1_X7IDT [OS=OneShot] :: State# RealWorld) ->
                    case ((after_a9OV5 ipv3_i7IAz)
                          `cast` (GHC.Types.N:IO[0] <b_a9P6s>_R
                                  :: (IO b_a9P6s :: *)
                                     ~R# (State# RealWorld
                                          -> (# State# RealWorld, b_a9P6s #) :: *)))
                           s1_X7IDT
                    of
                    { (# ipv4_X7IDZ, ipv5_X7IE1 #) ->
                    raiseIO# @ SomeException @ c_a9P6t e1_i8SfX ipv4_X7IDZ
                    })
                 ipv2_i7IAy
               })
            ipv_i94TO;
        1# ->
          case (before_a9OV4
                `cast` (GHC.Types.N:IO[0] <a_a9P6r>_R
                        :: (IO a_a9P6r :: *)
                           ~R# (State# RealWorld -> (# State# RealWorld, a_a9P6r #) :: *)))
                 ipv_i94TO
          of
          { (# ipv2_i7IAy, ipv3_i7IAz #) ->
          catch#
            @ c_a9P6t
            @ SomeException
            (maskUninterruptible#
               @ c_a9P6t
               ((thing_a9OV6 ipv3_i7IAz)
                `cast` (GHC.Types.N:IO[0] <c_a9P6t>_R
                        :: (IO c_a9P6t :: *)
                           ~R# (State# RealWorld -> (# State# RealWorld, c_a9P6t #) :: *))))
            (\ (e1_i8SfX [OS=OneShot] :: SomeException)
               (s_X7IDT [OS=OneShot] :: State# RealWorld) ->
               case ((after_a9OV5 ipv3_i7IAz)
                     `cast` (GHC.Types.N:IO[0] <b_a9P6s>_R
                             :: (IO b_a9P6s :: *)
                                ~R# (State# RealWorld -> (# State# RealWorld, b_a9P6s #) :: *)))
                      s_X7IDT
               of
               { (# ipv4_X7IDZ, ipv5_X7IE1 #) ->
               raiseIO# @ SomeException @ c_a9P6t e1_i8SfX ipv4_X7IDZ
               })
            ipv2_i7IAy
          }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 23, joins: 0/0}
bracketOnError
  :: forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(C1(U(U,A)))><L,1*C1(C1(U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Control.Exception.Base.bracketOnError1
               `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                       <IO a>_R
                       ->_R <a -> IO b>_R
                       ->_R <a -> IO c>_R
                       ->_R Sym (GHC.Types.N:IO[0] <c>_R)
                       :: (forall a b c.
                           IO a
                           -> (a -> IO b)
                           -> (a -> IO c)
                           -> State# RealWorld
                           -> (# State# RealWorld, c #) :: *)
                          ~R# (forall a b c.
                               IO a -> (a -> IO b) -> (a -> IO c) -> IO c :: *))}]
bracketOnError
  = Control.Exception.Base.bracketOnError1
    `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
            <IO a>_R
            ->_R <a -> IO b>_R
            ->_R <a -> IO c>_R
            ->_R Sym (GHC.Types.N:IO[0] <c>_R)
            :: (forall a b c.
                IO a
                -> (a -> IO b)
                -> (a -> IO c)
                -> State# RealWorld
                -> (# State# RealWorld, c #) :: *)
               ~R# (forall a b c.
                    IO a -> (a -> IO b) -> (a -> IO c) -> IO c :: *))

-- RHS size: {terms: 5, types: 5, coercions: 0, joins: 0/0}
runtimeError :: forall a. Addr# -> a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
runtimeError
  = \ (@ a_a9P4Y) (s_a9OVa :: Addr#) ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a9P4Y (unpackCStringUtf8# s_a9OVa)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_r9PFt :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl_r9PFt = "Oops!  Entered absent arg "#

-- RHS size: {terms: 7, types: 5, coercions: 0, joins: 0/0}
absentError :: forall a. Addr# -> a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
absentError
  = \ (@ a_a9P4T) (s_a9OVb :: Addr#) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ a_a9P4T
        (unpackAppendCString# lvl_r9PFt (unpackCStringUtf8# s_a9OVb))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Control.Exception.Base.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Exception.Base.$trModule3
  = GHC.Types.TrNameS Control.Exception.Base.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
Control.Exception.Base.$trModule2 = "Control.Exception.Base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Exception.Base.$trModule1
  = GHC.Types.TrNameS Control.Exception.Base.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Control.Exception.Base.$trModule
  = GHC.Types.Module
      Control.Exception.Base.$trModule3 Control.Exception.Base.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_r9PFu :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_r9PFu
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcChar (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep1_r9PFv :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep1_r9PFv
  = GHC.Types.: @ KindRep $krep_r9PFu (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep2_r9PFw :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep2_r9PFw
  = GHC.Types.KindRepTyConApp GHC.Types.$tc[] $krep1_r9PFv

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionPatternMatchFail4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Control.Exception.Base.$fExceptionPatternMatchFail4
  = "PatternMatchFail"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionPatternMatchFail3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Exception.Base.$fExceptionPatternMatchFail3
  = GHC.Types.TrNameS
      Control.Exception.Base.$fExceptionPatternMatchFail4

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tcPatternMatchFail :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Exception.Base.$tcPatternMatchFail
  = GHC.Types.TyCon
      15470147969565509342##
      8416277433045206230##
      Control.Exception.Base.$trModule
      Control.Exception.Base.$fExceptionPatternMatchFail3
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep3_r9PFx :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep3_r9PFx
  = GHC.Types.KindRepTyConApp
      Control.Exception.Base.$tcPatternMatchFail (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'PatternMatchFail1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Control.Exception.Base.$tc'PatternMatchFail1
  = GHC.Types.KindRepFun $krep2_r9PFw $krep3_r9PFx

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'PatternMatchFail3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
Control.Exception.Base.$tc'PatternMatchFail3 = "'PatternMatchFail"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'PatternMatchFail2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Exception.Base.$tc'PatternMatchFail2
  = GHC.Types.TrNameS Control.Exception.Base.$tc'PatternMatchFail3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'PatternMatchFail :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Exception.Base.$tc'PatternMatchFail
  = GHC.Types.TyCon
      5659337934556330582##
      79463786797963870##
      Control.Exception.Base.$trModule
      Control.Exception.Base.$tc'PatternMatchFail2
      0#
      Control.Exception.Base.$tc'PatternMatchFail1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionPatternMatchFail2
  :: Data.Typeable.Internal.TypeRep PatternMatchFail
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Control.Exception.Base.$fExceptionPatternMatchFail2
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ PatternMatchFail
           15470147969565509342##
           8416277433045206230##
           Control.Exception.Base.$trModule
           Control.Exception.Base.$fExceptionPatternMatchFail3
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ PatternMatchFail
      ww8_i8htw
      ww9_i8htx
      ww10_i8hty
      ww11_i8htz
      ww12_i8htA
    }

-- RHS size: {terms: 14, types: 17, coercions: 9, joins: 0/0}
Control.Exception.Base.$fExceptionPatternMatchFail_$cfromException
  :: SomeException -> Maybe PatternMatchFail
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 90 30}]
Control.Exception.Base.$fExceptionPatternMatchFail_$cfromException
  = \ (ds_i8hqT :: SomeException) ->
      case ds_i8hqT of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ PatternMatchFail
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             Control.Exception.Base.$fExceptionPatternMatchFail2
      of {
        False -> GHC.Base.Nothing @ PatternMatchFail;
        True ->
          (GHC.Base.Just @ e1_i8hqW e2_i8hqY)
          `cast` ((Maybe
                     (UnsafeCo representational e1_i8hqW PatternMatchFail))_R
                  :: (Maybe e1_i8hqW :: *) ~R# (Maybe PatternMatchFail :: *))
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 8, joins: 0/0}
Control.Exception.Base.$fExceptionPatternMatchFail [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception PatternMatchFail
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: PatternMatchFail
                                 Control.Exception.Base.$fExceptionPatternMatchFail2
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <PatternMatchFail>_N
                                         :: (Data.Typeable.Internal.TypeRep PatternMatchFail :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   PatternMatchFail :: Constraint))
                                 Control.Exception.Base.$fShowPatternMatchFail
                                 Control.Exception.Base.$fExceptionPatternMatchFail_$ctoException
                                 Control.Exception.Base.$fExceptionPatternMatchFail_$cfromException
                                 Control.Exception.Base.$fExceptionPatternMatchFail1
                                 `cast` (<PatternMatchFail>_R
                                         ->_R Control.Exception.Base.N:PatternMatchFail[0]
                                         :: (PatternMatchFail -> PatternMatchFail :: *)
                                            ~R# (PatternMatchFail -> String :: *))]
Control.Exception.Base.$fExceptionPatternMatchFail
  = GHC.Exception.C:Exception
      @ PatternMatchFail
      (Control.Exception.Base.$fExceptionPatternMatchFail2
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <PatternMatchFail>_N
               :: (Data.Typeable.Internal.TypeRep PatternMatchFail :: *)
                  ~R# (Data.Typeable.Internal.Typeable
                         PatternMatchFail :: Constraint)))
      Control.Exception.Base.$fShowPatternMatchFail
      Control.Exception.Base.$fExceptionPatternMatchFail_$ctoException
      Control.Exception.Base.$fExceptionPatternMatchFail_$cfromException
      (Control.Exception.Base.$fExceptionPatternMatchFail1
       `cast` (<PatternMatchFail>_R
               ->_R Control.Exception.Base.N:PatternMatchFail[0]
               :: (PatternMatchFail -> PatternMatchFail :: *)
                  ~R# (PatternMatchFail -> String :: *)))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionPatternMatchFail_$ctoException [Occ=LoopBreaker]
  :: PatternMatchFail -> SomeException
[GblId, Arity=1, Unf=OtherCon []]
Control.Exception.Base.$fExceptionPatternMatchFail_$ctoException
  = GHC.Exception.SomeException
      @ PatternMatchFail
      Control.Exception.Base.$fExceptionPatternMatchFail
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl1_r9PFy :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl1_r9PFy = "Non-exhaustive patterns in"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl2_r9PFz :: [Char]
[GblId]
lvl2_r9PFz = unpackCString# lvl1_r9PFy

-- RHS size: {terms: 7, types: 5, coercions: 2, joins: 0/0}
patError :: forall a. Addr# -> a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
patError
  = \ (@ a_a9P4u) (s_a9OVf :: Addr#) ->
      throw
        @ PatternMatchFail
        @ a_a9P4u
        Control.Exception.Base.$fExceptionPatternMatchFail
        ((untangle s_a9OVf lvl2_r9PFz)
         `cast` (Sym (Control.Exception.Base.N:PatternMatchFail[0])
                 :: (String :: *) ~R# (PatternMatchFail :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl3_r9PFA :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl3_r9PFA = "Non-exhaustive guards in"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl4_r9PFB :: [Char]
[GblId]
lvl4_r9PFB = unpackCString# lvl3_r9PFA

-- RHS size: {terms: 7, types: 5, coercions: 2, joins: 0/0}
nonExhaustiveGuardsError :: forall a. Addr# -> a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
nonExhaustiveGuardsError
  = \ (@ a_a9P4N) (s_a9OVc :: Addr#) ->
      throw
        @ PatternMatchFail
        @ a_a9P4N
        Control.Exception.Base.$fExceptionPatternMatchFail
        ((untangle s_a9OVc lvl4_r9PFB)
         `cast` (Sym (Control.Exception.Base.N:PatternMatchFail[0])
                 :: (String :: *) ~R# (PatternMatchFail :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionRecSelError4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Exception.Base.$fExceptionRecSelError4 = "RecSelError"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionRecSelError3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Exception.Base.$fExceptionRecSelError3
  = GHC.Types.TrNameS Control.Exception.Base.$fExceptionRecSelError4

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tcRecSelError :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Exception.Base.$tcRecSelError
  = GHC.Types.TyCon
      10415770337441550020##
      15768375346093691416##
      Control.Exception.Base.$trModule
      Control.Exception.Base.$fExceptionRecSelError3
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep4_r9PFC :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep4_r9PFC
  = GHC.Types.KindRepTyConApp
      Control.Exception.Base.$tcRecSelError (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'RecSelError1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Control.Exception.Base.$tc'RecSelError1
  = GHC.Types.KindRepFun $krep2_r9PFw $krep4_r9PFC

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'RecSelError3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Exception.Base.$tc'RecSelError3 = "'RecSelError"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'RecSelError2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Exception.Base.$tc'RecSelError2
  = GHC.Types.TrNameS Control.Exception.Base.$tc'RecSelError3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'RecSelError :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Exception.Base.$tc'RecSelError
  = GHC.Types.TyCon
      5471381485413442404##
      14158408912397908002##
      Control.Exception.Base.$trModule
      Control.Exception.Base.$tc'RecSelError2
      0#
      Control.Exception.Base.$tc'RecSelError1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionRecSelError2
  :: Data.Typeable.Internal.TypeRep RecSelError
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Control.Exception.Base.$fExceptionRecSelError2
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ RecSelError
           10415770337441550020##
           15768375346093691416##
           Control.Exception.Base.$trModule
           Control.Exception.Base.$fExceptionRecSelError3
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ RecSelError
      ww8_i8htw
      ww9_i8htx
      ww10_i8hty
      ww11_i8htz
      ww12_i8htA
    }

-- RHS size: {terms: 14, types: 17, coercions: 9, joins: 0/0}
Control.Exception.Base.$fExceptionRecSelError_$cfromException
  :: SomeException -> Maybe RecSelError
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 90 30}]
Control.Exception.Base.$fExceptionRecSelError_$cfromException
  = \ (ds_i8hqT :: SomeException) ->
      case ds_i8hqT of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ RecSelError
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             Control.Exception.Base.$fExceptionRecSelError2
      of {
        False -> GHC.Base.Nothing @ RecSelError;
        True ->
          (GHC.Base.Just @ e1_i8hqW e2_i8hqY)
          `cast` ((Maybe (UnsafeCo representational e1_i8hqW RecSelError))_R
                  :: (Maybe e1_i8hqW :: *) ~R# (Maybe RecSelError :: *))
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 8, joins: 0/0}
Control.Exception.Base.$fExceptionRecSelError [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception RecSelError
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: RecSelError
                                 Control.Exception.Base.$fExceptionRecSelError2
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <RecSelError>_N
                                         :: (Data.Typeable.Internal.TypeRep RecSelError :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   RecSelError :: Constraint))
                                 Control.Exception.Base.$fShowRecSelError
                                 Control.Exception.Base.$fExceptionRecSelError_$ctoException
                                 Control.Exception.Base.$fExceptionRecSelError_$cfromException
                                 Control.Exception.Base.$fExceptionRecSelError1
                                 `cast` (<RecSelError>_R
                                         ->_R Control.Exception.Base.N:RecSelError[0]
                                         :: (RecSelError -> RecSelError :: *)
                                            ~R# (RecSelError -> String :: *))]
Control.Exception.Base.$fExceptionRecSelError
  = GHC.Exception.C:Exception
      @ RecSelError
      (Control.Exception.Base.$fExceptionRecSelError2
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <RecSelError>_N
               :: (Data.Typeable.Internal.TypeRep RecSelError :: *)
                  ~R# (Data.Typeable.Internal.Typeable RecSelError :: Constraint)))
      Control.Exception.Base.$fShowRecSelError
      Control.Exception.Base.$fExceptionRecSelError_$ctoException
      Control.Exception.Base.$fExceptionRecSelError_$cfromException
      (Control.Exception.Base.$fExceptionRecSelError1
       `cast` (<RecSelError>_R
               ->_R Control.Exception.Base.N:RecSelError[0]
               :: (RecSelError -> RecSelError :: *)
                  ~R# (RecSelError -> String :: *)))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionRecSelError_$ctoException [Occ=LoopBreaker]
  :: RecSelError -> SomeException
[GblId, Arity=1, Unf=OtherCon []]
Control.Exception.Base.$fExceptionRecSelError_$ctoException
  = GHC.Exception.SomeException
      @ RecSelError Control.Exception.Base.$fExceptionRecSelError
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl5_r9PFD :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl5_r9PFD = "No match in record selector "#

-- RHS size: {terms: 8, types: 5, coercions: 2, joins: 0/0}
recSelError :: forall a. Addr# -> a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
recSelError
  = \ (@ a_a9P52) (s_a9OV9 :: Addr#) ->
      throw
        @ RecSelError
        @ a_a9P52
        Control.Exception.Base.$fExceptionRecSelError
        ((unpackAppendCString# lvl5_r9PFD (unpackCStringUtf8# s_a9OV9))
         `cast` (Sym (Control.Exception.Base.N:RecSelError[0])
                 :: (String :: *) ~R# (RecSelError :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionRecConError4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Exception.Base.$fExceptionRecConError4 = "RecConError"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionRecConError3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Exception.Base.$fExceptionRecConError3
  = GHC.Types.TrNameS Control.Exception.Base.$fExceptionRecConError4

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tcRecConError :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Exception.Base.$tcRecConError
  = GHC.Types.TyCon
      12352028005606494596##
      6364281046760374976##
      Control.Exception.Base.$trModule
      Control.Exception.Base.$fExceptionRecConError3
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep5_r9PFE :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep5_r9PFE
  = GHC.Types.KindRepTyConApp
      Control.Exception.Base.$tcRecConError (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'RecConError1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Control.Exception.Base.$tc'RecConError1
  = GHC.Types.KindRepFun $krep2_r9PFw $krep5_r9PFE

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'RecConError3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Exception.Base.$tc'RecConError3 = "'RecConError"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'RecConError2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Exception.Base.$tc'RecConError2
  = GHC.Types.TrNameS Control.Exception.Base.$tc'RecConError3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'RecConError :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Exception.Base.$tc'RecConError
  = GHC.Types.TyCon
      9626440070376619587##
      11467734131060317064##
      Control.Exception.Base.$trModule
      Control.Exception.Base.$tc'RecConError2
      0#
      Control.Exception.Base.$tc'RecConError1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionRecConError2
  :: Data.Typeable.Internal.TypeRep RecConError
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Control.Exception.Base.$fExceptionRecConError2
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ RecConError
           12352028005606494596##
           6364281046760374976##
           Control.Exception.Base.$trModule
           Control.Exception.Base.$fExceptionRecConError3
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ RecConError
      ww8_i8htw
      ww9_i8htx
      ww10_i8hty
      ww11_i8htz
      ww12_i8htA
    }

-- RHS size: {terms: 14, types: 17, coercions: 9, joins: 0/0}
Control.Exception.Base.$fExceptionRecConError_$cfromException
  :: SomeException -> Maybe RecConError
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 90 30}]
Control.Exception.Base.$fExceptionRecConError_$cfromException
  = \ (ds_i8hqT :: SomeException) ->
      case ds_i8hqT of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ RecConError
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             Control.Exception.Base.$fExceptionRecConError2
      of {
        False -> GHC.Base.Nothing @ RecConError;
        True ->
          (GHC.Base.Just @ e1_i8hqW e2_i8hqY)
          `cast` ((Maybe (UnsafeCo representational e1_i8hqW RecConError))_R
                  :: (Maybe e1_i8hqW :: *) ~R# (Maybe RecConError :: *))
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 8, joins: 0/0}
Control.Exception.Base.$fExceptionRecConError [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception RecConError
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: RecConError
                                 Control.Exception.Base.$fExceptionRecConError2
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <RecConError>_N
                                         :: (Data.Typeable.Internal.TypeRep RecConError :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   RecConError :: Constraint))
                                 Control.Exception.Base.$fShowRecConError
                                 Control.Exception.Base.$fExceptionRecConError_$ctoException
                                 Control.Exception.Base.$fExceptionRecConError_$cfromException
                                 Control.Exception.Base.$fExceptionRecConError1
                                 `cast` (<RecConError>_R
                                         ->_R Control.Exception.Base.N:RecConError[0]
                                         :: (RecConError -> RecConError :: *)
                                            ~R# (RecConError -> String :: *))]
Control.Exception.Base.$fExceptionRecConError
  = GHC.Exception.C:Exception
      @ RecConError
      (Control.Exception.Base.$fExceptionRecConError2
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <RecConError>_N
               :: (Data.Typeable.Internal.TypeRep RecConError :: *)
                  ~R# (Data.Typeable.Internal.Typeable RecConError :: Constraint)))
      Control.Exception.Base.$fShowRecConError
      Control.Exception.Base.$fExceptionRecConError_$ctoException
      Control.Exception.Base.$fExceptionRecConError_$cfromException
      (Control.Exception.Base.$fExceptionRecConError1
       `cast` (<RecConError>_R
               ->_R Control.Exception.Base.N:RecConError[0]
               :: (RecConError -> RecConError :: *)
                  ~R# (RecConError -> String :: *)))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionRecConError_$ctoException [Occ=LoopBreaker]
  :: RecConError -> SomeException
[GblId, Arity=1, Unf=OtherCon []]
Control.Exception.Base.$fExceptionRecConError_$ctoException
  = GHC.Exception.SomeException
      @ RecConError Control.Exception.Base.$fExceptionRecConError
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl6_r9PFF :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl6_r9PFF = "Missing field in record construction"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl7_r9PFG :: [Char]
[GblId]
lvl7_r9PFG = unpackCString# lvl6_r9PFF

-- RHS size: {terms: 7, types: 5, coercions: 2, joins: 0/0}
recConError :: forall a. Addr# -> a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
recConError
  = \ (@ a_a9P4H) (s_a9OVd :: Addr#) ->
      throw
        @ RecConError
        @ a_a9P4H
        Control.Exception.Base.$fExceptionRecConError
        ((untangle s_a9OVd lvl7_r9PFG)
         `cast` (Sym (Control.Exception.Base.N:RecConError[0])
                 :: (String :: *) ~R# (RecConError :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionRecUpdError4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Exception.Base.$fExceptionRecUpdError4 = "RecUpdError"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionRecUpdError3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Exception.Base.$fExceptionRecUpdError3
  = GHC.Types.TrNameS Control.Exception.Base.$fExceptionRecUpdError4

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tcRecUpdError :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Exception.Base.$tcRecUpdError
  = GHC.Types.TyCon
      15702205725616076489##
      17185013925011980063##
      Control.Exception.Base.$trModule
      Control.Exception.Base.$fExceptionRecUpdError3
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep6_r9PFH :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep6_r9PFH
  = GHC.Types.KindRepTyConApp
      Control.Exception.Base.$tcRecUpdError (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'RecUpdError1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Control.Exception.Base.$tc'RecUpdError1
  = GHC.Types.KindRepFun $krep2_r9PFw $krep6_r9PFH

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'RecUpdError3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Exception.Base.$tc'RecUpdError3 = "'RecUpdError"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'RecUpdError2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Exception.Base.$tc'RecUpdError2
  = GHC.Types.TrNameS Control.Exception.Base.$tc'RecUpdError3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'RecUpdError :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Exception.Base.$tc'RecUpdError
  = GHC.Types.TyCon
      16559845159098082290##
      2874382059338705699##
      Control.Exception.Base.$trModule
      Control.Exception.Base.$tc'RecUpdError2
      0#
      Control.Exception.Base.$tc'RecUpdError1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionRecUpdError2
  :: Data.Typeable.Internal.TypeRep RecUpdError
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Control.Exception.Base.$fExceptionRecUpdError2
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ RecUpdError
           15702205725616076489##
           17185013925011980063##
           Control.Exception.Base.$trModule
           Control.Exception.Base.$fExceptionRecUpdError3
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ RecUpdError
      ww8_i8htw
      ww9_i8htx
      ww10_i8hty
      ww11_i8htz
      ww12_i8htA
    }

-- RHS size: {terms: 14, types: 17, coercions: 9, joins: 0/0}
Control.Exception.Base.$fExceptionRecUpdError_$cfromException
  :: SomeException -> Maybe RecUpdError
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 90 30}]
Control.Exception.Base.$fExceptionRecUpdError_$cfromException
  = \ (ds_i8hqT :: SomeException) ->
      case ds_i8hqT of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ RecUpdError
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             Control.Exception.Base.$fExceptionRecUpdError2
      of {
        False -> GHC.Base.Nothing @ RecUpdError;
        True ->
          (GHC.Base.Just @ e1_i8hqW e2_i8hqY)
          `cast` ((Maybe (UnsafeCo representational e1_i8hqW RecUpdError))_R
                  :: (Maybe e1_i8hqW :: *) ~R# (Maybe RecUpdError :: *))
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 8, joins: 0/0}
Control.Exception.Base.$fExceptionRecUpdError [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception RecUpdError
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: RecUpdError
                                 Control.Exception.Base.$fExceptionRecUpdError2
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <RecUpdError>_N
                                         :: (Data.Typeable.Internal.TypeRep RecUpdError :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   RecUpdError :: Constraint))
                                 Control.Exception.Base.$fShowRecUpdError
                                 Control.Exception.Base.$fExceptionRecUpdError_$ctoException
                                 Control.Exception.Base.$fExceptionRecUpdError_$cfromException
                                 Control.Exception.Base.$fExceptionRecUpdError1
                                 `cast` (<RecUpdError>_R
                                         ->_R Control.Exception.Base.N:RecUpdError[0]
                                         :: (RecUpdError -> RecUpdError :: *)
                                            ~R# (RecUpdError -> String :: *))]
Control.Exception.Base.$fExceptionRecUpdError
  = GHC.Exception.C:Exception
      @ RecUpdError
      (Control.Exception.Base.$fExceptionRecUpdError2
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <RecUpdError>_N
               :: (Data.Typeable.Internal.TypeRep RecUpdError :: *)
                  ~R# (Data.Typeable.Internal.Typeable RecUpdError :: Constraint)))
      Control.Exception.Base.$fShowRecUpdError
      Control.Exception.Base.$fExceptionRecUpdError_$ctoException
      Control.Exception.Base.$fExceptionRecUpdError_$cfromException
      (Control.Exception.Base.$fExceptionRecUpdError1
       `cast` (<RecUpdError>_R
               ->_R Control.Exception.Base.N:RecUpdError[0]
               :: (RecUpdError -> RecUpdError :: *)
                  ~R# (RecUpdError -> String :: *)))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionRecUpdError_$ctoException [Occ=LoopBreaker]
  :: RecUpdError -> SomeException
[GblId, Arity=1, Unf=OtherCon []]
Control.Exception.Base.$fExceptionRecUpdError_$ctoException
  = GHC.Exception.SomeException
      @ RecUpdError Control.Exception.Base.$fExceptionRecUpdError
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionNoMethodError4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Control.Exception.Base.$fExceptionNoMethodError4 = "NoMethodError"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionNoMethodError3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Exception.Base.$fExceptionNoMethodError3
  = GHC.Types.TrNameS
      Control.Exception.Base.$fExceptionNoMethodError4

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tcNoMethodError :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Exception.Base.$tcNoMethodError
  = GHC.Types.TyCon
      11351432124310594529##
      14675551822527927261##
      Control.Exception.Base.$trModule
      Control.Exception.Base.$fExceptionNoMethodError3
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep7_r9PFI :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep7_r9PFI
  = GHC.Types.KindRepTyConApp
      Control.Exception.Base.$tcNoMethodError (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'NoMethodError1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Control.Exception.Base.$tc'NoMethodError1
  = GHC.Types.KindRepFun $krep2_r9PFw $krep7_r9PFI

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'NoMethodError3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Control.Exception.Base.$tc'NoMethodError3 = "'NoMethodError"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'NoMethodError2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Exception.Base.$tc'NoMethodError2
  = GHC.Types.TrNameS Control.Exception.Base.$tc'NoMethodError3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'NoMethodError :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Exception.Base.$tc'NoMethodError
  = GHC.Types.TyCon
      17186686744263410642##
      16452408278578849625##
      Control.Exception.Base.$trModule
      Control.Exception.Base.$tc'NoMethodError2
      0#
      Control.Exception.Base.$tc'NoMethodError1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionNoMethodError2
  :: Data.Typeable.Internal.TypeRep NoMethodError
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Control.Exception.Base.$fExceptionNoMethodError2
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ NoMethodError
           11351432124310594529##
           14675551822527927261##
           Control.Exception.Base.$trModule
           Control.Exception.Base.$fExceptionNoMethodError3
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ NoMethodError
      ww8_i8htw
      ww9_i8htx
      ww10_i8hty
      ww11_i8htz
      ww12_i8htA
    }

-- RHS size: {terms: 14, types: 17, coercions: 9, joins: 0/0}
Control.Exception.Base.$fExceptionNoMethodError_$cfromException
  :: SomeException -> Maybe NoMethodError
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 90 30}]
Control.Exception.Base.$fExceptionNoMethodError_$cfromException
  = \ (ds_i8hqT :: SomeException) ->
      case ds_i8hqT of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ NoMethodError
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             Control.Exception.Base.$fExceptionNoMethodError2
      of {
        False -> GHC.Base.Nothing @ NoMethodError;
        True ->
          (GHC.Base.Just @ e1_i8hqW e2_i8hqY)
          `cast` ((Maybe
                     (UnsafeCo representational e1_i8hqW NoMethodError))_R
                  :: (Maybe e1_i8hqW :: *) ~R# (Maybe NoMethodError :: *))
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 8, joins: 0/0}
Control.Exception.Base.$fExceptionNoMethodError [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception NoMethodError
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: NoMethodError
                                 Control.Exception.Base.$fExceptionNoMethodError2
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <NoMethodError>_N
                                         :: (Data.Typeable.Internal.TypeRep NoMethodError :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   NoMethodError :: Constraint))
                                 Control.Exception.Base.$fShowNoMethodError
                                 Control.Exception.Base.$fExceptionNoMethodError_$ctoException
                                 Control.Exception.Base.$fExceptionNoMethodError_$cfromException
                                 Control.Exception.Base.$fExceptionNoMethodError1
                                 `cast` (<NoMethodError>_R
                                         ->_R Control.Exception.Base.N:NoMethodError[0]
                                         :: (NoMethodError -> NoMethodError :: *)
                                            ~R# (NoMethodError -> String :: *))]
Control.Exception.Base.$fExceptionNoMethodError
  = GHC.Exception.C:Exception
      @ NoMethodError
      (Control.Exception.Base.$fExceptionNoMethodError2
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <NoMethodError>_N
               :: (Data.Typeable.Internal.TypeRep NoMethodError :: *)
                  ~R# (Data.Typeable.Internal.Typeable NoMethodError :: Constraint)))
      Control.Exception.Base.$fShowNoMethodError
      Control.Exception.Base.$fExceptionNoMethodError_$ctoException
      Control.Exception.Base.$fExceptionNoMethodError_$cfromException
      (Control.Exception.Base.$fExceptionNoMethodError1
       `cast` (<NoMethodError>_R
               ->_R Control.Exception.Base.N:NoMethodError[0]
               :: (NoMethodError -> NoMethodError :: *)
                  ~R# (NoMethodError -> String :: *)))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionNoMethodError_$ctoException [Occ=LoopBreaker]
  :: NoMethodError -> SomeException
[GblId, Arity=1, Unf=OtherCon []]
Control.Exception.Base.$fExceptionNoMethodError_$ctoException
  = GHC.Exception.SomeException
      @ NoMethodError Control.Exception.Base.$fExceptionNoMethodError
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl8_r9PFJ :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl8_r9PFJ = "No instance nor default method for class operation"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl9_r9PFK :: [Char]
[GblId]
lvl9_r9PFK = unpackCString# lvl8_r9PFJ

-- RHS size: {terms: 7, types: 5, coercions: 2, joins: 0/0}
noMethodBindingError :: forall a. Addr# -> a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
noMethodBindingError
  = \ (@ a_a9P4B) (s_a9OVe :: Addr#) ->
      throw
        @ NoMethodError
        @ a_a9P4B
        Control.Exception.Base.$fExceptionNoMethodError
        ((untangle s_a9OVe lvl9_r9PFK)
         `cast` (Sym (Control.Exception.Base.N:NoMethodError[0])
                 :: (String :: *) ~R# (NoMethodError :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionTypeError4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Exception.Base.$fExceptionTypeError4 = "TypeError"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionTypeError3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Exception.Base.$fExceptionTypeError3
  = GHC.Types.TrNameS Control.Exception.Base.$fExceptionTypeError4

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tcTypeError :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Exception.Base.$tcTypeError
  = GHC.Types.TyCon
      16164392450212773017##
      7054022894506300317##
      Control.Exception.Base.$trModule
      Control.Exception.Base.$fExceptionTypeError3
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep8_r9PFL :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep8_r9PFL
  = GHC.Types.KindRepTyConApp
      Control.Exception.Base.$tcTypeError (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'TypeError1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Control.Exception.Base.$tc'TypeError1
  = GHC.Types.KindRepFun $krep2_r9PFw $krep8_r9PFL

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'TypeError3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Control.Exception.Base.$tc'TypeError3 = "'TypeError"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'TypeError2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Exception.Base.$tc'TypeError2
  = GHC.Types.TrNameS Control.Exception.Base.$tc'TypeError3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'TypeError :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Exception.Base.$tc'TypeError
  = GHC.Types.TyCon
      2042750002965703545##
      3275664116896771855##
      Control.Exception.Base.$trModule
      Control.Exception.Base.$tc'TypeError2
      0#
      Control.Exception.Base.$tc'TypeError1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionTypeError2
  :: Data.Typeable.Internal.TypeRep TypeError
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Control.Exception.Base.$fExceptionTypeError2
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ TypeError
           16164392450212773017##
           7054022894506300317##
           Control.Exception.Base.$trModule
           Control.Exception.Base.$fExceptionTypeError3
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ TypeError
      ww8_i8htw
      ww9_i8htx
      ww10_i8hty
      ww11_i8htz
      ww12_i8htA
    }

-- RHS size: {terms: 14, types: 17, coercions: 9, joins: 0/0}
Control.Exception.Base.$fExceptionTypeError_$cfromException
  :: SomeException -> Maybe TypeError
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 90 30}]
Control.Exception.Base.$fExceptionTypeError_$cfromException
  = \ (ds_i8hqT :: SomeException) ->
      case ds_i8hqT of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ TypeError
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             Control.Exception.Base.$fExceptionTypeError2
      of {
        False -> GHC.Base.Nothing @ TypeError;
        True ->
          (GHC.Base.Just @ e1_i8hqW e2_i8hqY)
          `cast` ((Maybe (UnsafeCo representational e1_i8hqW TypeError))_R
                  :: (Maybe e1_i8hqW :: *) ~R# (Maybe TypeError :: *))
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 8, joins: 0/0}
Control.Exception.Base.$fExceptionTypeError [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception TypeError
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: TypeError
                                 Control.Exception.Base.$fExceptionTypeError2
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <TypeError>_N
                                         :: (Data.Typeable.Internal.TypeRep TypeError :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   TypeError :: Constraint))
                                 Control.Exception.Base.$fShowTypeError
                                 Control.Exception.Base.$fExceptionTypeError_$ctoException
                                 Control.Exception.Base.$fExceptionTypeError_$cfromException
                                 Control.Exception.Base.$fExceptionTypeError1
                                 `cast` (<TypeError>_R ->_R Control.Exception.Base.N:TypeError[0]
                                         :: (TypeError -> TypeError :: *)
                                            ~R# (TypeError -> String :: *))]
Control.Exception.Base.$fExceptionTypeError
  = GHC.Exception.C:Exception
      @ TypeError
      (Control.Exception.Base.$fExceptionTypeError2
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <TypeError>_N
               :: (Data.Typeable.Internal.TypeRep TypeError :: *)
                  ~R# (Data.Typeable.Internal.Typeable TypeError :: Constraint)))
      Control.Exception.Base.$fShowTypeError
      Control.Exception.Base.$fExceptionTypeError_$ctoException
      Control.Exception.Base.$fExceptionTypeError_$cfromException
      (Control.Exception.Base.$fExceptionTypeError1
       `cast` (<TypeError>_R ->_R Control.Exception.Base.N:TypeError[0]
               :: (TypeError -> TypeError :: *) ~R# (TypeError -> String :: *)))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionTypeError_$ctoException [Occ=LoopBreaker]
  :: TypeError -> SomeException
[GblId, Arity=1, Unf=OtherCon []]
Control.Exception.Base.$fExceptionTypeError_$ctoException
  = GHC.Exception.SomeException
      @ TypeError Control.Exception.Base.$fExceptionTypeError
end Rec }

-- RHS size: {terms: 6, types: 5, coercions: 2, joins: 0/0}
typeError :: forall a. Addr# -> a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
typeError
  = \ (@ a_a9P4o) (s_a9OVg :: Addr#) ->
      throw
        @ TypeError
        @ a_a9P4o
        Control.Exception.Base.$fExceptionTypeError
        ((unpackCStringUtf8# s_a9OVg)
         `cast` (Sym (Control.Exception.Base.N:TypeError[0])
                 :: (String :: *) ~R# (TypeError :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionNonTermination5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Control.Exception.Base.$fExceptionNonTermination5
  = "NonTermination"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionNonTermination4 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Exception.Base.$fExceptionNonTermination4
  = GHC.Types.TrNameS
      Control.Exception.Base.$fExceptionNonTermination5

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tcNonTermination :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Exception.Base.$tcNonTermination
  = GHC.Types.TyCon
      3579424895879668618##
      10599900892006414641##
      Control.Exception.Base.$trModule
      Control.Exception.Base.$fExceptionNonTermination4
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'NonTermination1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
Control.Exception.Base.$tc'NonTermination1
  = GHC.Types.KindRepTyConApp
      Control.Exception.Base.$tcNonTermination (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'NonTermination3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Control.Exception.Base.$tc'NonTermination3 = "'NonTermination"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'NonTermination2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Exception.Base.$tc'NonTermination2
  = GHC.Types.TrNameS Control.Exception.Base.$tc'NonTermination3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'NonTermination :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Exception.Base.$tc'NonTermination
  = GHC.Types.TyCon
      12968537629115503750##
      16395462767232503200##
      Control.Exception.Base.$trModule
      Control.Exception.Base.$tc'NonTermination2
      0#
      Control.Exception.Base.$tc'NonTermination1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionNonTermination3
  :: Data.Typeable.Internal.TypeRep NonTermination
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Control.Exception.Base.$fExceptionNonTermination3
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ NonTermination
           3579424895879668618##
           10599900892006414641##
           Control.Exception.Base.$trModule
           Control.Exception.Base.$fExceptionNonTermination4
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ NonTermination
      ww8_i8htw
      ww9_i8htx
      ww10_i8hty
      ww11_i8htz
      ww12_i8htA
    }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionNestedAtomically5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Control.Exception.Base.$fExceptionNestedAtomically5
  = "NestedAtomically"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionNestedAtomically4 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Exception.Base.$fExceptionNestedAtomically4
  = GHC.Types.TrNameS
      Control.Exception.Base.$fExceptionNestedAtomically5

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tcNestedAtomically :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Exception.Base.$tcNestedAtomically
  = GHC.Types.TyCon
      13388460688970090897##
      8422109474180001052##
      Control.Exception.Base.$trModule
      Control.Exception.Base.$fExceptionNestedAtomically4
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'NestedAtomically1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
Control.Exception.Base.$tc'NestedAtomically1
  = GHC.Types.KindRepTyConApp
      Control.Exception.Base.$tcNestedAtomically (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'NestedAtomically3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
Control.Exception.Base.$tc'NestedAtomically3 = "'NestedAtomically"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'NestedAtomically2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Control.Exception.Base.$tc'NestedAtomically2
  = GHC.Types.TrNameS Control.Exception.Base.$tc'NestedAtomically3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Control.Exception.Base.$tc'NestedAtomically :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Control.Exception.Base.$tc'NestedAtomically
  = GHC.Types.TyCon
      4753625237420970988##
      7635940481883810337##
      Control.Exception.Base.$trModule
      Control.Exception.Base.$tc'NestedAtomically2
      0#
      Control.Exception.Base.$tc'NestedAtomically1

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionNestedAtomically3
  :: Data.Typeable.Internal.TypeRep NestedAtomically
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Control.Exception.Base.$fExceptionNestedAtomically3
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ NestedAtomically
           13388460688970090897##
           8422109474180001052##
           Control.Exception.Base.$trModule
           Control.Exception.Base.$fExceptionNestedAtomically4
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_i8htw, ww9_i8htx, ww10_i8hty, ww11_i8htz, ww12_i8htA #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ NestedAtomically
      ww8_i8htw
      ww9_i8htx
      ww10_i8hty
      ww11_i8htz
      ww12_i8htA
    }

-- RHS size: {terms: 14, types: 17, coercions: 9, joins: 0/0}
Control.Exception.Base.$fExceptionNonTermination_$cfromException
  :: SomeException -> Maybe NonTermination
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 90 30}]
Control.Exception.Base.$fExceptionNonTermination_$cfromException
  = \ (ds_i8hqT :: SomeException) ->
      case ds_i8hqT of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ NonTermination
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             Control.Exception.Base.$fExceptionNonTermination3
      of {
        False -> GHC.Base.Nothing @ NonTermination;
        True ->
          (GHC.Base.Just @ e1_i8hqW e2_i8hqY)
          `cast` ((Maybe
                     (UnsafeCo representational e1_i8hqW NonTermination))_R
                  :: (Maybe e1_i8hqW :: *) ~R# (Maybe NonTermination :: *))
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 5, joins: 0/0}
Control.Exception.Base.$fExceptionNonTermination [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception NonTermination
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: NonTermination
                                 Control.Exception.Base.$fExceptionNonTermination3
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <NonTermination>_N
                                         :: (Data.Typeable.Internal.TypeRep NonTermination :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   NonTermination :: Constraint))
                                 Control.Exception.Base.$fShowNonTermination
                                 Control.Exception.Base.$fExceptionNonTermination_$ctoException
                                 Control.Exception.Base.$fExceptionNonTermination_$cfromException
                                 Control.Exception.Base.$fExceptionNonTermination_$cshow]
Control.Exception.Base.$fExceptionNonTermination
  = GHC.Exception.C:Exception
      @ NonTermination
      (Control.Exception.Base.$fExceptionNonTermination3
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <NonTermination>_N
               :: (Data.Typeable.Internal.TypeRep NonTermination :: *)
                  ~R# (Data.Typeable.Internal.Typeable
                         NonTermination :: Constraint)))
      Control.Exception.Base.$fShowNonTermination
      Control.Exception.Base.$fExceptionNonTermination_$ctoException
      Control.Exception.Base.$fExceptionNonTermination_$cfromException
      Control.Exception.Base.$fExceptionNonTermination_$cshow

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionNonTermination_$ctoException [Occ=LoopBreaker]
  :: NonTermination -> SomeException
[GblId, Arity=1, Unf=OtherCon []]
Control.Exception.Base.$fExceptionNonTermination_$ctoException
  = GHC.Exception.SomeException
      @ NonTermination Control.Exception.Base.$fExceptionNonTermination
end Rec }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
nonTermination :: SomeException
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
nonTermination
  = Control.Exception.Base.$fExceptionNonTermination_$ctoException
      Control.Exception.Base.NonTermination

-- RHS size: {terms: 14, types: 17, coercions: 9, joins: 0/0}
Control.Exception.Base.$fExceptionNestedAtomically_$cfromException
  :: SomeException -> Maybe NestedAtomically
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 90 30}]
Control.Exception.Base.$fExceptionNestedAtomically_$cfromException
  = \ (ds_i8hqT :: SomeException) ->
      case ds_i8hqT of
      { SomeException @ e1_i8hqW $dException1_i8hqX e2_i8hqY ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_i8hqW
             @ NestedAtomically
             ((GHC.Exception.$p1Exception @ e1_i8hqW $dException1_i8hqX)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_i8hqW>_N
                      :: (Data.Typeable.Internal.Typeable e1_i8hqW :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_i8hqW :: *)))
             Control.Exception.Base.$fExceptionNestedAtomically3
      of {
        False -> GHC.Base.Nothing @ NestedAtomically;
        True ->
          (GHC.Base.Just @ e1_i8hqW e2_i8hqY)
          `cast` ((Maybe
                     (UnsafeCo representational e1_i8hqW NestedAtomically))_R
                  :: (Maybe e1_i8hqW :: *) ~R# (Maybe NestedAtomically :: *))
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 5, joins: 0/0}
Control.Exception.Base.$fExceptionNestedAtomically [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception NestedAtomically
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: NestedAtomically
                                 Control.Exception.Base.$fExceptionNestedAtomically3
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <NestedAtomically>_N
                                         :: (Data.Typeable.Internal.TypeRep NestedAtomically :: *)
                                            ~R# (Data.Typeable.Internal.Typeable
                                                   NestedAtomically :: Constraint))
                                 Control.Exception.Base.$fShowNestedAtomically
                                 Control.Exception.Base.$fExceptionNestedAtomically_$ctoException
                                 Control.Exception.Base.$fExceptionNestedAtomically_$cfromException
                                 Control.Exception.Base.$fExceptionNestedAtomically_$cshow]
Control.Exception.Base.$fExceptionNestedAtomically
  = GHC.Exception.C:Exception
      @ NestedAtomically
      (Control.Exception.Base.$fExceptionNestedAtomically3
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <NestedAtomically>_N
               :: (Data.Typeable.Internal.TypeRep NestedAtomically :: *)
                  ~R# (Data.Typeable.Internal.Typeable
                         NestedAtomically :: Constraint)))
      Control.Exception.Base.$fShowNestedAtomically
      Control.Exception.Base.$fExceptionNestedAtomically_$ctoException
      Control.Exception.Base.$fExceptionNestedAtomically_$cfromException
      Control.Exception.Base.$fExceptionNestedAtomically_$cshow

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Control.Exception.Base.$fExceptionNestedAtomically_$ctoException [Occ=LoopBreaker]
  :: NestedAtomically -> SomeException
[GblId, Arity=1, Unf=OtherCon []]
Control.Exception.Base.$fExceptionNestedAtomically_$ctoException
  = GHC.Exception.SomeException
      @ NestedAtomically
      Control.Exception.Base.$fExceptionNestedAtomically
end Rec }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
nestedAtomically :: SomeException
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
nestedAtomically
  = Control.Exception.Base.$fExceptionNestedAtomically_$ctoException
      Control.Exception.Base.NestedAtomically


