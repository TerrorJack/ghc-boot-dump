
==================== Output Cmm ====================
2018-03-16 16:06:45.351680674 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:45.352930323 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedMonad1_closure" {
     Control.Applicative.$fFunctorWrappedMonad1_closure:
         const Control.Applicative.$fFunctorWrappedMonad1_info;
 },
 lvl_sbSvM_entry() //  [R1]
         { info_tbl: [(cbSB1,
                       label: lvl_sbSvM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSB1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbSB2; else goto cbSB3;
       cbSB2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSB3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSvO_entry() //  [R1]
         { info_tbl: [(cbSB9,
                       label: sat_sbSvO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSB9: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fFunctorWrappedMonad1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbSBc,
                       label: Control.Applicative.$fFunctorWrappedMonad1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSBc: // global
           _sbSvL::P64 = R4;
           _sbSvK::P64 = R3;
           _sbSvJ::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbSBd; else goto cbSBe;
       cbSBe: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbSBg; else goto cbSBf;
       cbSBg: // global
           HpAlloc = 48;
           goto cbSBd;
       cbSBd: // global
           R4 = _sbSvL::P64;
           R3 = _sbSvK::P64;
           R2 = _sbSvJ::P64;
           R1 = Control.Applicative.$fFunctorWrappedMonad1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSBf: // global
           I64[Hp - 40] = lvl_sbSvM_info;
           P64[Hp - 24] = _sbSvJ::P64;
           P64[Hp - 16] = _sbSvK::P64;
           I64[Hp - 8] = sat_sbSvO_info;
           P64[Hp] = Hp - 40;
           R2 = _sbSvJ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSvL::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.354816556 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedMonad_closure" {
     Control.Applicative.$fFunctorWrappedMonad_closure:
         const Control.Applicative.$fFunctorWrappedMonad_info;
 },
 sat_sbSvT_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSBq,
                       label: sat_sbSvT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSBq: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fFunctorWrappedMonad1_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSvS_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSBy,
                       label: sat_sbSvS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSBy: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.liftM_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fFunctorWrappedMonad_entry() //  [R2]
         { info_tbl: [(cbSBC,
                       label: Control.Applicative.$fFunctorWrappedMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSBC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbSBG; else goto cbSBF;
       cbSBG: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Applicative.$fFunctorWrappedMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSBF: // global
           I64[Hp - 48] = sat_sbSvT_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sbSvS_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.356254038 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedMonad3_closure" {
     Control.Applicative.$fApplicativeWrappedMonad3_closure:
         const Control.Applicative.$fApplicativeWrappedMonad3_info;
 },
 Control.Applicative.$fApplicativeWrappedMonad3_entry() //  [R2, R3]
         { info_tbl: [(cbSBN,
                       label: Control.Applicative.$fApplicativeWrappedMonad3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSBN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSBO; else goto cbSBP;
       cbSBO: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedMonad3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSBP: // global
           I64[Sp - 16] = block_cbSBL_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbSBL() //  [R1]
         { info_tbl: [(cbSBL,
                       label: block_cbSBL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSBL: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.357831569 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedMonad2_closure" {
     Control.Applicative.$fApplicativeWrappedMonad2_closure:
         const Control.Applicative.$fApplicativeWrappedMonad2_info;
 },
 lvl_sbSw0_entry() //  [R1]
         { info_tbl: [(cbSC5,
                       label: lvl_sbSw0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSC5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbSC6; else goto cbSC7;
       cbSC6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSC7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSw2_entry() //  [R1]
         { info_tbl: [(cbSCd,
                       label: sat_sbSw2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSCd: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSw3_entry() //  [R1]
         { info_tbl: [(cbSCg,
                       label: sat_sbSw3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSCg: // global
           _sbSw3::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbSCh; else goto cbSCi;
       cbSCi: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbSCk; else goto cbSCj;
       cbSCk: // global
           HpAlloc = 40;
           goto cbSCh;
       cbSCh: // global
           R1 = _sbSw3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSCj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSw3::P64;
           _sbSvX::P64 = P64[_sbSw3::P64 + 16];
           _sbSvY::P64 = P64[_sbSw3::P64 + 24];
           I64[Hp - 32] = lvl_sbSw0_info;
           P64[Hp - 16] = _sbSvX::P64;
           I64[Hp - 8] = sat_sbSw2_info;
           P64[Hp] = Hp - 32;
           R2 = _sbSvX::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbSvY::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeWrappedMonad2_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbSCl,
                       label: Control.Applicative.$fApplicativeWrappedMonad2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSCl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbSCp; else goto cbSCo;
       cbSCp: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedMonad2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSCo: // global
           I64[Hp - 24] = sat_sbSw3_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R4 = R4;
           R3 = Hp - 24;
           R2 = R2;
           call GHC.Base.ap_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.360094078 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedMonad1_closure" {
     Control.Applicative.$fApplicativeWrappedMonad1_closure:
         const Control.Applicative.$fApplicativeWrappedMonad1_info;
 },
 lvl_sbSw8_entry() //  [R1]
         { info_tbl: [(cbSCD,
                       label: lvl_sbSw8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSCD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbSCE; else goto cbSCF;
       cbSCE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSCF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSwa_entry() //  [R1]
         { info_tbl: [(cbSCL,
                       label: sat_sbSwa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSCL: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwb_entry() //  [R1, R2]
         { info_tbl: [(cbSCO,
                       label: sat_sbSwb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSCO: // global
           _sbSw7::P64 = R2;
           _sbSwb::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbSCP; else goto cbSCQ;
       cbSCQ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbSCS; else goto cbSCR;
       cbSCS: // global
           HpAlloc = 48;
           goto cbSCP;
       cbSCP: // global
           R2 = _sbSw7::P64;
           R1 = _sbSwb::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSCR: // global
           _sbSw4::P64 = P64[_sbSwb::P64 + 7];
           _sbSw6::P64 = P64[_sbSwb::P64 + 15];
           I64[Hp - 40] = lvl_sbSw8_info;
           P64[Hp - 24] = _sbSw4::P64;
           P64[Hp - 16] = _sbSw7::P64;
           I64[Hp - 8] = sat_sbSwa_info;
           P64[Hp] = Hp - 40;
           R2 = _sbSw4::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSw6::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fApplicativeWrappedMonad1_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbSCT,
                       label: Control.Applicative.$fApplicativeWrappedMonad1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSCT: // global
           _sbSw6::P64 = R4;
           _sbSw5::P64 = R3;
           _sbSw4::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbSCU; else goto cbSCV;
       cbSCV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSCX; else goto cbSCW;
       cbSCX: // global
           HpAlloc = 24;
           goto cbSCU;
       cbSCU: // global
           R4 = _sbSw6::P64;
           R3 = _sbSw5::P64;
           R2 = _sbSw4::P64;
           R1 = Control.Applicative.$fApplicativeWrappedMonad1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSCW: // global
           I64[Hp - 16] = sat_sbSwb_info;
           P64[Hp - 8] = _sbSw4::P64;
           P64[Hp] = _sbSw6::P64;
           R2 = _sbSw4::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSw5::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.36275328 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedMonad_closure" {
     Control.Applicative.$fApplicativeWrappedMonad_closure:
         const Control.Applicative.$fApplicativeWrappedMonad_info;
 },
 sat_sbSwn_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSD7,
                       label: sat_sbSwn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSD7: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedMonad1_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwm_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSDf,
                       label: sat_sbSwm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSDf: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedMonad2_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwl_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbSDn,
                       label: sat_sbSwl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSDn: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.liftM2_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwh_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSDv,
                       label: sat_sbSwh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSDv: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.ap_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwe_entry() //  [R1, R2]
         { info_tbl: [(cbSDD,
                       label: sat_sbSwe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSDD: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fApplicativeWrappedMonad3_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwd_entry() //  [R1]
         { info_tbl: [(cbSDK,
                       label: sat_sbSwd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSDK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSDL; else goto cbSDM;
       cbSDL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSDM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fFunctorWrappedMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeWrappedMonad_entry() //  [R2]
         { info_tbl: [(cbSDO,
                       label: Control.Applicative.$fApplicativeWrappedMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSDO: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cbSDS; else goto cbSDR;
       cbSDS: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSDR: // global
           I64[Hp - 152] = sat_sbSwn_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbSwm_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbSwl_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbSwh_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbSwe_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbSwd_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 87;
           P64[Hp - 24] = Hp - 102;
           P64[Hp - 16] = Hp - 117;
           P64[Hp - 8] = Hp - 134;
           P64[Hp] = Hp - 150;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.365037219 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_closure" {
     Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_closure:
         const Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_info;
 },
 sat_sbSwp_entry() //  [R1]
         { info_tbl: [(cbSE1,
                       label: sat_sbSwp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSE1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSE2; else goto cbSE3;
       cbSE2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSE3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_entry() //  [R2]
         { info_tbl: [(cbSE4,
                       label: Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSE4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSE8; else goto cbSE7;
       cbSE8: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSE7: // global
           I64[Hp - 16] = sat_sbSwp_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Applicative.$fApplicativeWrappedMonad_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.367294064 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedMonad_$csome_closure" {
     Control.Applicative.$fAlternativeWrappedMonad_$csome_closure:
         const Control.Applicative.$fAlternativeWrappedMonad_$csome_info;
 },
 sat_sbSww_entry() //  [R1]
         { info_tbl: [(cbSEs,
                       label: sat_sbSww_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSEs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbSEt; else goto cbSEu;
       cbSEt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSEu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbSEq_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbSEq() //  [R1]
         { info_tbl: [(cbSEq,
                       label: block_cbSEq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSEq: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 m2_sbSwt_entry() //  [R1]
         { info_tbl: [(cbSEy,
                       label: m2_sbSwt_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSEy: // global
           _sbSwt::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbSEz; else goto cbSEA;
       cbSEA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSEC; else goto cbSEB;
       cbSEC: // global
           HpAlloc = 24;
           goto cbSEz;
       cbSEz: // global
           R1 = _sbSwt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSEB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSwt::P64;
           _sbSwq::P64 = P64[_sbSwt::P64 + 16];
           _sbSws::P64 = P64[_sbSwt::P64 + 24];
           _sbSwu::P64 = P64[_sbSwt::P64 + 32];
           I64[Hp - 16] = sat_sbSww_info;
           P64[Hp] = _sbSws::P64;
           R2 = _sbSwq::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbSwu::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call GHC.Base.mplus_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbSwA_entry() //  [R1, R2]
         { info_tbl: [(cbSER,
                       label: sat_sbSwA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSER: // global
           _sbSwy::P64 = R2;
           _sbSwA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbSES; else goto cbSET;
       cbSET: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSEV; else goto cbSEU;
       cbSEV: // global
           HpAlloc = 24;
           goto cbSES;
       cbSES: // global
           R2 = _sbSwy::P64;
           R1 = _sbSwA::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSEU: // global
           _sbSws::P64 = P64[_sbSwA::P64 + 7];
           _sbSwx::P64 = P64[_sbSwA::P64 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sbSwx::P64;
           P64[Hp] = _sbSwy::P64;
           R2 = _sbSws::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbSwB_entry() //  [R1, R2]
         { info_tbl: [(cbSEW,
                       label: sat_sbSwB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSEW: // global
           _sbSwx::P64 = R2;
           _sbSwB::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbSEX; else goto cbSEY;
       cbSEY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSF0; else goto cbSEZ;
       cbSF0: // global
           HpAlloc = 24;
           goto cbSEX;
       cbSEX: // global
           R2 = _sbSwx::P64;
           R1 = _sbSwB::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSEZ: // global
           _sbSws::P64 = P64[_sbSwB::P64 + 7];
           _sbSwt::P64 = P64[_sbSwB::P64 + 15];
           I64[Hp - 16] = sat_sbSwA_info;
           P64[Hp - 8] = _sbSws::P64;
           P64[Hp] = _sbSwx::P64;
           R2 = _sbSws::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSwt::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 some_v_sbSwu_entry() //  [R1]
         { info_tbl: [(cbSF1,
                       label: some_v_sbSwu_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSF1: // global
           _sbSwu::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbSF2; else goto cbSF3;
       cbSF3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSF5; else goto cbSF4;
       cbSF5: // global
           HpAlloc = 24;
           goto cbSF2;
       cbSF2: // global
           R1 = _sbSwu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSF4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSwu::P64;
           _sbSwr::P64 = P64[_sbSwu::P64 + 16];
           _sbSws::P64 = P64[_sbSwu::P64 + 24];
           _sbSwt::P64 = P64[_sbSwu::P64 + 32];
           I64[Hp - 16] = sat_sbSwB_info;
           P64[Hp - 8] = _sbSws::P64;
           P64[Hp] = _sbSwt::P64;
           R2 = _sbSws::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbSwr::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedMonad_$csome_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(cbSF6,
                       label: Control.Applicative.$fAlternativeWrappedMonad_$csome_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSF6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbSF7; else goto cbSF8;
       cbSF7: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedMonad_$csome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSF8: // global
           I64[Sp - 24] = block_cbSEd_info;
           _sbSwq::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _sbSwq::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbSEd() //  [R1]
         { info_tbl: [(cbSEd,
                       label: block_cbSEd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSEd: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbSFb; else goto cbSFa;
       cbSFb: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbSFa: // global
           I64[Hp - 72] = m2_sbSwt_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           _cbSEi::P64 = Hp - 32;
           P64[Hp - 40] = _cbSEi::P64;
           I64[Hp - 32] = some_v_sbSwu_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 72;
           R1 = _cbSEi::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.371713717 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedMonad_$cmany_closure" {
     Control.Applicative.$fAlternativeWrappedMonad_$cmany_closure:
         const Control.Applicative.$fAlternativeWrappedMonad_$cmany_info;
 },
 $dApplicative_sbSwF_entry() //  [R1]
         { info_tbl: [(cbSFo,
                       label: $dApplicative_sbSwF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSFo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSFp; else goto cbSFq;
       cbSFp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSFq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSwN_entry() //  [R1]
         { info_tbl: [(cbSFx,
                       label: sat_sbSwN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSFx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbSFy; else goto cbSFz;
       cbSFy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSFz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbSFv_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbSFv() //  [R1]
         { info_tbl: [(cbSFv,
                       label: block_cbSFv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSFv: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSwJ_entry() //  [R1, R2]
         { info_tbl: [(cbSFS,
                       label: sat_sbSwJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSFS: // global
           _sbSwH::P64 = R2;
           _sbSwJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbSFT; else goto cbSFU;
       cbSFU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSFW; else goto cbSFV;
       cbSFW: // global
           HpAlloc = 24;
           goto cbSFT;
       cbSFT: // global
           R2 = _sbSwH::P64;
           R1 = _sbSwJ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSFV: // global
           _sbSwF::P64 = P64[_sbSwJ::P64 + 7];
           _sbSwG::P64 = P64[_sbSwJ::P64 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sbSwG::P64;
           P64[Hp] = _sbSwH::P64;
           R2 = _sbSwF::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbSwK_entry() //  [R1, R2]
         { info_tbl: [(cbSFX,
                       label: sat_sbSwK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSFX: // global
           _sbSwG::P64 = R2;
           _sbSwK::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbSFY; else goto cbSFZ;
       cbSFZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSG1; else goto cbSG0;
       cbSG1: // global
           HpAlloc = 24;
           goto cbSFY;
       cbSFY: // global
           R2 = _sbSwG::P64;
           R1 = _sbSwK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSG0: // global
           _sbSwE::P64 = P64[_sbSwK::P64 + 7];
           _sbSwF::P64 = P64[_sbSwK::P64 + 15];
           I64[Hp - 16] = sat_sbSwJ_info;
           P64[Hp - 8] = _sbSwF::P64;
           P64[Hp] = _sbSwG::P64;
           R2 = _sbSwF::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSwE::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbSwL_entry() //  [R1]
         { info_tbl: [(cbSG2,
                       label: sat_sbSwL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSG2: // global
           _sbSwL::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbSG3; else goto cbSG4;
       cbSG4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSG6; else goto cbSG5;
       cbSG6: // global
           HpAlloc = 24;
           goto cbSG3;
       cbSG3: // global
           R1 = _sbSwL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSG5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSwL::P64;
           _sbSwD::P64 = P64[_sbSwL::P64 + 16];
           _sbSwE::P64 = P64[_sbSwL::P64 + 24];
           _sbSwF::P64 = P64[_sbSwL::P64 + 32];
           I64[Hp - 16] = sat_sbSwK_info;
           P64[Hp - 8] = _sbSwE::P64;
           P64[Hp] = _sbSwF::P64;
           R2 = _sbSwF::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbSwD::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 many_v_sbSwE_entry() //  [R1]
         { info_tbl: [(cbSG7,
                       label: many_v_sbSwE_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSG7: // global
           _sbSwE::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbSG8; else goto cbSG9;
       cbSG9: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbSGb; else goto cbSGa;
       cbSGb: // global
           HpAlloc = 88;
           goto cbSG8;
       cbSG8: // global
           R1 = _sbSwE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSGa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSwE::P64;
           _sbSwC::P64 = P64[_sbSwE::P64 + 16];
           _sbSwD::P64 = P64[_sbSwE::P64 + 24];
           I64[Hp - 80] = $dApplicative_sbSwF_info;
           P64[Hp - 64] = _sbSwC::P64;
           I64[Hp - 56] = sat_sbSwN_info;
           _cbSFk::P64 = Hp - 80;
           P64[Hp - 40] = _cbSFk::P64;
           I64[Hp - 32] = sat_sbSwL_info;
           P64[Hp - 16] = _sbSwD::P64;
           P64[Hp - 8] = _sbSwE::P64;
           P64[Hp] = _cbSFk::P64;
           R2 = _sbSwC::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call GHC.Base.mplus_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedMonad_$cmany_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(cbSGc,
                       label: Control.Applicative.$fAlternativeWrappedMonad_$cmany_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSGc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbSGg; else goto cbSGf;
       cbSGg: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedMonad_$cmany_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSGf: // global
           I64[Hp - 24] = many_v_sbSwE_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.375839391 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedMonad_closure" {
     Control.Applicative.$fAlternativeWrappedMonad_closure:
         const Control.Applicative.$fAlternativeWrappedMonad_info;
 },
 sat_sbSwV_entry() //  [R1, R2]
         { info_tbl: [(cbSGq,
                       label: sat_sbSwV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSGq: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fAlternativeWrappedMonad_$cmany_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwU_entry() //  [R1, R2]
         { info_tbl: [(cbSGy,
                       label: sat_sbSwU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSGy: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fAlternativeWrappedMonad_$csome_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwT_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSGG,
                       label: sat_sbSwT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSGG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbSGH; else goto cbSGI;
       cbSGH: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSGI: // global
           _sbSwR::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSwR::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbSwQ_entry() //  [R1]
         { info_tbl: [(cbSGN,
                       label: sat_sbSwQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSGN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSGO; else goto cbSGP;
       cbSGO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSGP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSwP_entry() //  [R1]
         { info_tbl: [(cbSGU,
                       label: sat_sbSwP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSGU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSGV; else goto cbSGW;
       cbSGV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSGW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedMonad_entry() //  [R2]
         { info_tbl: [(cbSGY,
                       label: Control.Applicative.$fAlternativeWrappedMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSGY: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cbSH2; else goto cbSH1;
       cbSH2: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSH1: // global
           I64[Hp - 136] = sat_sbSwV_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbSwU_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbSwT_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbSwQ_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbSwP_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 102;
           P64[Hp - 8] = Hp - 119;
           P64[Hp] = Hp - 135;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.378475368 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedArrow2_closure" {
     Control.Applicative.$fFunctorWrappedArrow2_closure:
         const Control.Applicative.$fFunctorWrappedArrow2_info;
 },
 sat_sbSx0_entry() //  [R1]
         { info_tbl: [(cbSHb,
                       label: sat_sbSx0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSHb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbSHc; else goto cbSHd;
       cbSHc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSHd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fFunctorWrappedArrow2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbSHg,
                       label: Control.Applicative.$fFunctorWrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSHg: // global
           _sbSwY::P64 = R4;
           _sbSwX::P64 = R3;
           _sbSwW::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbSHh; else goto cbSHi;
       cbSHi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbSHk; else goto cbSHj;
       cbSHk: // global
           HpAlloc = 32;
           goto cbSHh;
       cbSHh: // global
           R4 = _sbSwY::P64;
           R3 = _sbSwX::P64;
           R2 = _sbSwW::P64;
           R1 = Control.Applicative.$fFunctorWrappedArrow2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSHj: // global
           I64[Hp - 24] = sat_sbSx0_info;
           P64[Hp - 8] = _sbSwW::P64;
           P64[Hp] = _sbSwX::P64;
           I64[Sp - 24] = block_cbSHe_info;
           R2 = _sbSwW::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbSwY::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbSHe() //  [R1]
         { info_tbl: [(cbSHe,
                       label: block_cbSHe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSHe: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.382089978 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedArrow1_closure" {
     Control.Applicative.$fFunctorWrappedArrow1_closure:
         const Control.Applicative.$fFunctorWrappedArrow1_info;
 },
 sat_sbSx6_entry() //  [R1]
         { info_tbl: [(cbSHB,
                       label: sat_sbSx6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSHB: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSx7_entry() //  [R1]
         { info_tbl: [(cbSHE,
                       label: sat_sbSx7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSHE: // global
           _sbSx7::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbSHF; else goto cbSHG;
       cbSHG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbSHI; else goto cbSHH;
       cbSHI: // global
           HpAlloc = 16;
           goto cbSHF;
       cbSHF: // global
           R1 = _sbSx7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSHH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSx7::P64;
           _sbSx1::P64 = P64[_sbSx7::P64 + 16];
           _sbSx2::P64 = P64[_sbSx7::P64 + 24];
           I64[Hp - 8] = sat_sbSx6_info;
           P64[Hp] = _sbSx2::P64;
           R2 = _sbSx1::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fFunctorWrappedArrow1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbSHL,
                       label: Control.Applicative.$fFunctorWrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSHL: // global
           _sbSx3::P64 = R4;
           _sbSx2::P64 = R3;
           _sbSx1::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbSHM; else goto cbSHN;
       cbSHN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbSHP; else goto cbSHO;
       cbSHP: // global
           HpAlloc = 32;
           goto cbSHM;
       cbSHM: // global
           R4 = _sbSx3::P64;
           R3 = _sbSx2::P64;
           R2 = _sbSx1::P64;
           R1 = Control.Applicative.$fFunctorWrappedArrow1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSHO: // global
           I64[Hp - 24] = sat_sbSx7_info;
           P64[Hp - 8] = _sbSx1::P64;
           P64[Hp] = _sbSx2::P64;
           I64[Sp - 24] = block_cbSHJ_info;
           R2 = _sbSx1::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbSx3::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbSHJ() //  [R1]
         { info_tbl: [(cbSHJ,
                       label: block_cbSHJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSHJ: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.384045075 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedArrow_closure" {
     Control.Applicative.$fFunctorWrappedArrow_closure:
         const Control.Applicative.$fFunctorWrappedArrow_info;
 },
 sat_sbSxa_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSI2,
                       label: sat_sbSxa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSI2: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fFunctorWrappedArrow1_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSx9_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSIa,
                       label: sat_sbSx9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSIa: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fFunctorWrappedArrow2_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fFunctorWrappedArrow_entry() //  [R2]
         { info_tbl: [(cbSIe,
                       label: Control.Applicative.$fFunctorWrappedArrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSIe: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbSIi; else goto cbSIh;
       cbSIi: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Applicative.$fFunctorWrappedArrow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSIh: // global
           I64[Hp - 48] = sat_sbSxa_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sbSx9_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.385890732 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow2_closure" {
     Control.Applicative.$fAlternativeWrappedArrow2_closure:
         const Control.Applicative.$fAlternativeWrappedArrow2_info;
 },
 sat_sbSxi_entry() //  [R1]
         { info_tbl: [(cbSIr,
                       label: sat_sbSxi_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSIr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbSIs; else goto cbSIt;
       cbSIs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSIt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Arrow.&&&_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbSxg_entry() //  [R1, R2]
         { info_tbl: [(cbSID,
                       label: sat_sbSxg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSID: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Tuple.uncurry_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSxh_entry() //  [R1]
         { info_tbl: [(cbSIG,
                       label: sat_sbSxh_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSIG: // global
           _sbSxh::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbSIH; else goto cbSII;
       cbSII: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbSIK; else goto cbSIJ;
       cbSIK: // global
           HpAlloc = 16;
           goto cbSIH;
       cbSIH: // global
           R1 = _sbSxh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSIJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSxh::P64;
           _sbSxb::P64 = P64[_sbSxh::P64 + 16];
           _sbSxc::P64 = P64[_sbSxh::P64 + 24];
           I64[Hp - 8] = sat_sbSxg_info;
           P64[Hp] = _sbSxc::P64;
           R2 = _sbSxb::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow2_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cbSIN,
                       label: Control.Applicative.$fAlternativeWrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSIN: // global
           _sbSxe::P64 = R5;
           _sbSxd::P64 = R4;
           _sbSxc::P64 = R3;
           _sbSxb::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbSIO; else goto cbSIP;
       cbSIP: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbSIR; else goto cbSIQ;
       cbSIR: // global
           HpAlloc = 72;
           goto cbSIO;
       cbSIO: // global
           R5 = _sbSxe::P64;
           R4 = _sbSxd::P64;
           R3 = _sbSxc::P64;
           R2 = _sbSxb::P64;
           R1 = Control.Applicative.$fAlternativeWrappedArrow2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSIQ: // global
           I64[Hp - 64] = sat_sbSxi_info;
           P64[Hp - 48] = _sbSxb::P64;
           P64[Hp - 40] = _sbSxd::P64;
           P64[Hp - 32] = _sbSxe::P64;
           I64[Hp - 24] = sat_sbSxh_info;
           P64[Hp - 8] = _sbSxb::P64;
           P64[Hp] = _sbSxc::P64;
           I64[Sp - 24] = block_cbSIL_info;
           R2 = _sbSxb::P64;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbSIL() //  [R1]
         { info_tbl: [(cbSIL,
                       label: block_cbSIL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSIL: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbSIn::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbSIn::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.388072295 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow5_closure" {
     Control.Applicative.$fApplicativeWrappedArrow5_closure:
         const Control.Applicative.$fApplicativeWrappedArrow5_info;
 },
 sat_sbSxm_entry() //  [R1]
         { info_tbl: [(cbSJ4,
                       label: sat_sbSxm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSJ4: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fApplicativeWrappedArrow5_entry() //  [R2, R3]
         { info_tbl: [(cbSJ7,
                       label: Control.Applicative.$fApplicativeWrappedArrow5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSJ7: // global
           _sbSxk::P64 = R3;
           _sbSxj::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbSJ8; else goto cbSJ9;
       cbSJ9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbSJb; else goto cbSJa;
       cbSJb: // global
           HpAlloc = 16;
           goto cbSJ8;
       cbSJ8: // global
           R3 = _sbSxk::P64;
           R2 = _sbSxj::P64;
           R1 = Control.Applicative.$fApplicativeWrappedArrow5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSJa: // global
           I64[Hp - 8] = sat_sbSxm_info;
           P64[Hp] = _sbSxk::P64;
           R2 = _sbSxj::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Arrow.arr_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.389297613 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow4_closure" {
     Control.Applicative.$fApplicativeWrappedArrow4_closure:
         const Control.Applicative.$fApplicativeWrappedArrow4_info;
 },
 Control.Applicative.$fApplicativeWrappedArrow4_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbSJg,
                       label: Control.Applicative.$fApplicativeWrappedArrow4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSJg: // global
           R5 = R4;
           R4 = R3;
           R3 = GHC.Base.breakpoint_closure+1;
           R2 = R2;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.390163232 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow3_closure" {
     Control.Applicative.$fApplicativeWrappedArrow3_closure:
         const Control.Applicative.$fApplicativeWrappedArrow3_info;
 },
 Control.Applicative.$fApplicativeWrappedArrow3_entry() //  [R3]
         { info_tbl: [(cbSJn,
                       label: Control.Applicative.$fApplicativeWrappedArrow3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSJn: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.391411781 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow2_closure" {
     Control.Applicative.$fApplicativeWrappedArrow2_closure:
         const Control.Applicative.$fApplicativeWrappedArrow2_info;
 },
 sat_sbSxu_entry() //  [R1]
         { info_tbl: [(cbSJC,
                       label: sat_sbSxu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSJC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbSJD; else goto cbSJE;
       cbSJD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSJE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Applicative.$fApplicativeWrappedArrow3_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSxv_entry() //  [R1]
         { info_tbl: [(cbSJH,
                       label: sat_sbSxv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSJH: // global
           _sbSxv::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbSJI; else goto cbSJJ;
       cbSJJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSJL; else goto cbSJK;
       cbSJL: // global
           HpAlloc = 24;
           goto cbSJI;
       cbSJI: // global
           R1 = _sbSxv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSJK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSxv::P64;
           _sbSxq::P64 = P64[_sbSxv::P64 + 16];
           _sbSxr::P64 = P64[_sbSxv::P64 + 24];
           I64[Hp - 16] = sat_sbSxu_info;
           P64[Hp] = _sbSxq::P64;
           I64[Sp - 40] = block_cbSJF_info;
           R2 = _sbSxq::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbSxr::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbSJF() //  [R1]
         { info_tbl: [(cbSJF,
                       label: block_cbSJF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSJF: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeWrappedArrow2_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbSJP,
                       label: Control.Applicative.$fApplicativeWrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSJP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbSJT; else goto cbSJS;
       cbSJT: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedArrow2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSJS: // global
           I64[Hp - 24] = sat_sbSxv_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R5 = R4;
           R4 = Hp - 24;
           R3 = GHC.Base.breakpoint_closure+1;
           R2 = R2;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.393115737 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow1_closure" {
     Control.Applicative.$fApplicativeWrappedArrow1_closure:
         const Control.Applicative.$fApplicativeWrappedArrow1_info;
 },
 Control.Applicative.$fApplicativeWrappedArrow1_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbSJY,
                       label: Control.Applicative.$fApplicativeWrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSJY: // global
           R5 = R4;
           R4 = R3;
           R3 = GHC.Base.const_closure+2;
           R2 = R2;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.394839191 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow_closure" {
     Control.Applicative.$fApplicativeWrappedArrow_closure:
         const Control.Applicative.$fApplicativeWrappedArrow_info;
 },
 sat_sbSxD_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSKa,
                       label: sat_sbSxD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSKa: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedArrow1_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSxC_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSKi,
                       label: sat_sbSxC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSKi: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedArrow2_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSxB_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbSKq,
                       label: sat_sbSxB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSKq: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSxA_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSKy,
                       label: sat_sbSxA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSKy: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedArrow4_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSxz_entry() //  [R1, R2]
         { info_tbl: [(cbSKG,
                       label: sat_sbSxz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSKG: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fApplicativeWrappedArrow5_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSxy_entry() //  [R1]
         { info_tbl: [(cbSKN,
                       label: sat_sbSxy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSKN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSKO; else goto cbSKP;
       cbSKO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSKP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fFunctorWrappedArrow_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeWrappedArrow_entry() //  [R2]
         { info_tbl: [(cbSKR,
                       label: Control.Applicative.$fApplicativeWrappedArrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSKR: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cbSKV; else goto cbSKU;
       cbSKV: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedArrow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSKU: // global
           I64[Hp - 152] = sat_sbSxD_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbSxC_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbSxB_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbSxA_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbSxz_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbSxy_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 87;
           P64[Hp - 24] = Hp - 102;
           P64[Hp - 16] = Hp - 117;
           P64[Hp - 8] = Hp - 134;
           P64[Hp] = Hp - 150;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.397058679 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_closure" {
     Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_closure:
         const Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_info;
 },
 sat_sbSxG_entry() //  [R1]
         { info_tbl: [(cbSL4,
                       label: sat_sbSxG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSL4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSL5; else goto cbSL6;
       cbSL5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSL6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_entry() //  [R2,
                                                                            R3]
         { info_tbl: [(cbSL7,
                       label: Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSL7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSLb; else goto cbSLa;
       cbSLb: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSLa: // global
           I64[Hp - 16] = sat_sbSxG_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Applicative.$fApplicativeWrappedArrow_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.398172064 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow1_closure" {
     Control.Applicative.$fAlternativeWrappedArrow1_closure:
         const Control.Applicative.$fAlternativeWrappedArrow1_info;
 },
 Control.Applicative.$fAlternativeWrappedArrow1_entry() //  []
         { info_tbl: [(cbSLg,
                       label: Control.Applicative.$fAlternativeWrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSLg: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.399603136 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow_$csome_closure" {
     Control.Applicative.$fAlternativeWrappedArrow_$csome_closure:
         const Control.Applicative.$fAlternativeWrappedArrow_$csome_info;
 },
 sat_sbSxN_entry() //  [R1]
         { info_tbl: [(cbSLD,
                       label: sat_sbSxN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSLD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbSLE; else goto cbSLF;
       cbSLE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSLF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Applicative.$fAlternativeWrappedArrow1_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSxO_entry() //  [R1]
         { info_tbl: [(cbSLG,
                       label: sat_sbSxO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSLG: // global
           _sbSxO::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbSLH; else goto cbSLI;
       cbSLI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSLK; else goto cbSLJ;
       cbSLK: // global
           HpAlloc = 24;
           goto cbSLH;
       cbSLH: // global
           R1 = _sbSxO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSLJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSxO::P64;
           _sbSxJ::P64 = P64[_sbSxO::P64 + 16];
           _sbSxL::P64 = P64[_sbSxO::P64 + 24];
           _sbSxM::P64 = P64[_sbSxO::P64 + 32];
           I64[Hp - 16] = sat_sbSxN_info;
           P64[Hp] = _sbSxM::P64;
           R2 = _sbSxJ::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbSxL::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call Control.Arrow.<+>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 some_v_sbSxL_entry() //  [R1]
         { info_tbl: [(cbSLL,
                       label: some_v_sbSxL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSLL: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbSLM; else goto cbSLN;
       cbSLM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSLN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cbSLr_info;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = R1;
           Sp = Sp - 48;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbSLr() //  [R1]
         { info_tbl: [(cbSLr,
                       label: block_cbSLr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSLr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbSLQ; else goto cbSLP;
       cbSLQ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbSLP: // global
           I64[Hp - 32] = sat_sbSxO_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R5 = Hp - 32;
           R4 = P64[Sp + 16];
           R3 = GHC.Types.:_closure+2;
           R2 = R1;
           Sp = Sp + 32;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow_$csome_entry() //  [R2,
                                                                   R3, R4]
         { info_tbl: [(cbSLR,
                       label: Control.Applicative.$fAlternativeWrappedArrow_$csome_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSLR: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbSLV; else goto cbSLU;
       cbSLV: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedArrow_$csome_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSLU: // global
           I64[Hp - 32] = some_v_sbSxL_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.402285786 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow_$cmany_closure" {
     Control.Applicative.$fAlternativeWrappedArrow_$cmany_closure:
         const Control.Applicative.$fAlternativeWrappedArrow_$cmany_info;
 },
 $dApplicative_sbSxT_entry() //  [R1]
         { info_tbl: [(cbSM8,
                       label: $dApplicative_sbSxT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSM8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSM9; else goto cbSMa;
       cbSM9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSMa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSxV_entry() //  [R1]
         { info_tbl: [(cbSMf,
                       label: sat_sbSxV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSMf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbSMg; else goto cbSMh;
       cbSMg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSMh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Applicative.$fAlternativeWrappedArrow1_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSxU_entry() //  [R1]
         { info_tbl: [(cbSMm,
                       label: sat_sbSxU_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSMm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSMn; else goto cbSMo;
       cbSMn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSMo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 24];
           R4 = P64[R1 + 16];
           R3 = GHC.Types.:_closure+2;
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 many_v_sbSxS_entry() //  [R1]
         { info_tbl: [(cbSMp,
                       label: many_v_sbSxS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSMp: // global
           _sbSxS::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbSMq; else goto cbSMr;
       cbSMr: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbSMt; else goto cbSMs;
       cbSMt: // global
           HpAlloc = 88;
           goto cbSMq;
       cbSMq: // global
           R1 = _sbSxS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSMs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSxS::P64;
           _sbSxP::P64 = P64[_sbSxS::P64 + 16];
           _sbSxQ::P64 = P64[_sbSxS::P64 + 24];
           _sbSxR::P64 = P64[_sbSxS::P64 + 32];
           I64[Hp - 80] = $dApplicative_sbSxT_info;
           P64[Hp - 64] = _sbSxP::P64;
           I64[Hp - 56] = sat_sbSxV_info;
           _cbSM4::P64 = Hp - 80;
           P64[Hp - 40] = _cbSM4::P64;
           I64[Hp - 32] = sat_sbSxU_info;
           P64[Hp - 16] = _sbSxR::P64;
           P64[Hp - 8] = _sbSxS::P64;
           P64[Hp] = _cbSM4::P64;
           R2 = _sbSxQ::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call Control.Arrow.<+>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow_$cmany_entry() //  [R2,
                                                                   R3, R4]
         { info_tbl: [(cbSMu,
                       label: Control.Applicative.$fAlternativeWrappedArrow_$cmany_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSMu: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbSMy; else goto cbSMx;
       cbSMy: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedArrow_$cmany_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSMx: // global
           I64[Hp - 32] = many_v_sbSxS_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.405038954 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow_closure" {
     Control.Applicative.$fAlternativeWrappedArrow_closure:
         const Control.Applicative.$fAlternativeWrappedArrow_info;
 },
 sat_sbSy4_entry() //  [R1, R2]
         { info_tbl: [(cbSMI,
                       label: sat_sbSy4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSMI: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Applicative.$fAlternativeWrappedArrow_$cmany_entry(R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSy3_entry() //  [R1, R2]
         { info_tbl: [(cbSMQ,
                       label: sat_sbSy3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSMQ: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Applicative.$fAlternativeWrappedArrow_$csome_entry(R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSy2_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSMY,
                       label: sat_sbSy2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSMY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbSMZ; else goto cbSN0;
       cbSMZ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSN0: // global
           _sbSy0::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSy0::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Control.Arrow.<+>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbSxZ_entry() //  [R1]
         { info_tbl: [(cbSN5,
                       label: sat_sbSxZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSN5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSN6; else goto cbSN7;
       cbSN6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSN7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.zeroArrow_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSxY_entry() //  [R1]
         { info_tbl: [(cbSNc,
                       label: sat_sbSxY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSNc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSNd; else goto cbSNe;
       cbSNd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSNe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_entry(R3,
                                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow_entry() //  [R2, R3]
         { info_tbl: [(cbSNg,
                       label: Control.Applicative.$fAlternativeWrappedArrow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSNg: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cbSNk; else goto cbSNj;
       cbSNk: // global
           HpAlloc = 168;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedArrow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSNj: // global
           I64[Hp - 160] = sat_sbSy4_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sbSy3_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sbSy2_info;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_sbSxZ_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbSxY_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 96;
           P64[Hp - 16] = Hp - 110;
           P64[Hp - 8] = Hp - 135;
           P64[Hp] = Hp - 159;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.407701595 UTC

[section ""data" . Control.Applicative.$wunsafeDrop_closure" {
     Control.Applicative.$wunsafeDrop_closure:
         const Control.Applicative.$wunsafeDrop_info;
 },
 Control.Applicative.$wunsafeDrop_entry() //  [R2, R3]
         { info_tbl: [(cbSNw,
                       label: Control.Applicative.$wunsafeDrop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSNw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbSNx; else goto ubSNL;
       cbSNx: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$wunsafeDrop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ubSNL: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cbSNm() args: 0, res: 0, upd: 0;
     }
 },
 _cbSNm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSNm: // global
           I64[Sp - 8] = block_cbSNp_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubSNN; else goto cbSNq;
       ubSNN: // global
           call _cbSNp(R1) args: 0, res: 0, upd: 0;
       cbSNq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbSNp() //  [R1]
         { info_tbl: [(cbSNp,
                       label: block_cbSNp_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSNp: // global
           if (R1 & 7 == 1) goto cbSNt; else goto cbSNu;
       cbSNt: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbSNu: // global
           _sbSy9::P64 = P64[R1 + 14];
           _sbSya::I64 = I64[Sp + 8];
           if (_sbSya::I64 != 1) goto cbSNH; else goto cbSNI;
       cbSNH: // global
           I64[Sp + 8] = _sbSya::I64 - 1;
           P64[Sp + 16] = _sbSy9::P64;
           Sp = Sp + 8;
           call _cbSNm() args: 0, res: 0, upd: 0;
       cbSNI: // global
           R1 = _sbSy9::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.409385033 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList2_closure" {
     Control.Applicative.$fAlternativeZipList2_closure:
         const Control.Applicative.$fAlternativeZipList2_info;
 },
 sat_sbSyg_entry() //  [R1]
         { info_tbl: [(cbSO0,
                       label: sat_sbSyg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSO0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSO1; else goto cbSO2;
       cbSO1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSO2: // global
           I64[Sp - 16] = block_cbSNY_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbSNY() //  [R1]
         { info_tbl: [(cbSNY,
                       label: block_cbSNY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSNY: // global
           _sbSyd::P64 = P64[Sp + 8];
           if (%MO_S_Gt_W64(R1, 0)) goto cbSO9; else goto cbSOa;
       cbSO9: // global
           R3 = _sbSyd::P64;
           R2 = R1;
           Sp = Sp + 16;
           call Control.Applicative.$wunsafeDrop_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       cbSOa: // global
           R1 = _sbSyd::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fAlternativeZipList2_entry() //  [R2, R3]
         { info_tbl: [(cbSOb,
                       label: Control.Applicative.$fAlternativeZipList2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSOb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbSOf; else goto cbSOe;
       cbSOf: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeZipList2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSOe: // global
           I64[Hp - 24] = sat_sbSyg_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = R2;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.410783275 UTC

[section ""data" . Control.Applicative.$fGeneric1ZipList1_closure" {
     Control.Applicative.$fGeneric1ZipList1_closure:
         const Control.Applicative.$fGeneric1ZipList1_info;
 },
 Control.Applicative.$fGeneric1ZipList1_entry() //  [R2]
         { info_tbl: [(cbSOk,
                       label: Control.Applicative.$fGeneric1ZipList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSOk: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.41153678 UTC

[section ""data" . Control.Applicative.$fGeneric1ZipList2_closure" {
     Control.Applicative.$fGeneric1ZipList2_closure:
         const Control.Applicative.$fGeneric1ZipList2_info;
 },
 Control.Applicative.$fGeneric1ZipList2_entry() //  [R2]
         { info_tbl: [(cbSOr,
                       label: Control.Applicative.$fGeneric1ZipList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSOr: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.41223983 UTC

[section ""data" . Control.Applicative.$fGeneric1ZipList_closure" {
     Control.Applicative.$fGeneric1ZipList_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Control.Applicative.$fGeneric1ZipList2_closure+1;
         const Control.Applicative.$fGeneric1ZipList1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.412920298 UTC

[section ""data" . Control.Applicative.$fGenericZipList1_closure" {
     Control.Applicative.$fGenericZipList1_closure:
         const Control.Applicative.$fGenericZipList1_info;
 },
 Control.Applicative.$fGenericZipList1_entry() //  [R2]
         { info_tbl: [(cbSOy,
                       label: Control.Applicative.$fGenericZipList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSOy: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.413761982 UTC

[section ""data" . Control.Applicative.$fGenericZipList2_closure" {
     Control.Applicative.$fGenericZipList2_closure:
         const Control.Applicative.$fGenericZipList2_info;
 },
 Control.Applicative.$fGenericZipList2_entry() //  [R2]
         { info_tbl: [(cbSOF,
                       label: Control.Applicative.$fGenericZipList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSOF: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.414469883 UTC

[section ""data" . Control.Applicative.$fGenericZipList_closure" {
     Control.Applicative.$fGenericZipList_closure:
         const GHC.Generics.C:Generic_con_info;
         const Control.Applicative.$fGenericZipList2_closure+1;
         const Control.Applicative.$fGenericZipList1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.415078293 UTC

[section ""data" . Control.Applicative.$fFoldableZipList_closure" {
     Control.Applicative.$fFoldableZipList_closure:
         const Data.Foldable.C:Foldable_con_info;
         const Data.Foldable.$fFoldableNonEmpty_$cfold1_closure+2;
         const Data.Foldable.$fFoldable[]_$cfoldMap_closure+3;
         const GHC.Base.foldr_closure+3;
         const Data.Foldable.$fFoldable[]_$cfoldr'_closure+3;
         const GHC.List.foldl_closure+3;
         const GHC.List.foldl'_closure+3;
         const GHC.List.foldr1_closure+2;
         const GHC.List.foldl1_closure+2;
         const GHC.Base.id_closure+1;
         const GHC.List.null_closure+1;
         const GHC.List.length_closure+1;
         const GHC.List.elem_closure+3;
         const GHC.List.maximum_closure+2;
         const GHC.List.minimum_closure+2;
         const GHC.List.sum_closure+1;
         const GHC.List.product_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.415785413 UTC

[section ""data" . Control.Applicative.$fFunctorZipList_closure" {
     Control.Applicative.$fFunctorZipList_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.map_closure+2;
         const GHC.Base.$fFunctor[]_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.417086585 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList6_closure" {
     Control.Applicative.$fApplicativeZipList6_closure:
         const Control.Applicative.$fApplicativeZipList6_info;
 },
 sat_sbSyu_entry() //  [R1]
         { info_tbl: [(cbSP2,
                       label: sat_sbSyu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSP2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSP3; else goto cbSP4;
       cbSP3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSP4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fApplicativeZipList6_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeZipList6_entry() //  [R2, R3]
         { info_tbl: [(cbSP9,
                       label: Control.Applicative.$fApplicativeZipList6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSP9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbSPa; else goto cbSPb;
       cbSPa: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeZipList6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSPb: // global
           I64[Sp - 16] = block_cbSOM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubSPv; else goto cbSON;
       ubSPv: // global
           call _cbSOM(R1) args: 0, res: 0, upd: 0;
       cbSON: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbSOM() //  [R1]
         { info_tbl: [(cbSOM,
                       label: block_cbSOM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSOM: // global
           if (R1 & 7 == 1) goto ubSPq; else goto cbSP7;
       ubSPq: // global
           Sp = Sp + 16;
           call _cbSPi() args: 0, res: 0, upd: 0;
       cbSP7: // global
           I64[Sp - 8] = block_cbSOS_info;
           _sbSyo::P64 = P64[R1 + 6];
           _sbSyp::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbSyp::P64;
           P64[Sp + 8] = _sbSyo::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubSPs; else goto cbSOT;
       ubSPs: // global
           call _cbSOS(R1) args: 0, res: 0, upd: 0;
       cbSOT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbSOS() //  [R1]
         { info_tbl: [(cbSOS,
                       label: block_cbSOS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSOS: // global
           if (R1 & 7 == 1) goto ubSPr; else goto cbSPl;
       ubSPr: // global
           Sp = Sp + 24;
           call _cbSPi() args: 0, res: 0, upd: 0;
       cbSPl: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbSPo; else goto cbSPn;
       cbSPo: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbSPn: // global
           _sbSyr::P64 = P64[R1 + 6];
           _sbSys::P64 = P64[R1 + 14];
           I64[Hp - 80] = sat_sbSyu_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _sbSys::P64;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sbSyr::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbSPi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSPi: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.419218841 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList5_closure" {
     Control.Applicative.$fApplicativeZipList5_closure:
         const Control.Applicative.$fApplicativeZipList5_info;
 },
 Control.Applicative.$fApplicativeZipList5_entry() //  [R2, R3]
         { info_tbl: [(cbSPA,
                       label: Control.Applicative.$fApplicativeZipList5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSPA: // global
           R3 = R3;
           R2 = R2;
           call Control.Applicative.$fApplicativeZipList6_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.420614893 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList4_closure" {
     Control.Applicative.$fApplicativeZipList4_closure:
         const Control.Applicative.$fApplicativeZipList4_info;
 },
 sat_sbSyF_entry() //  [R1]
         { info_tbl: [(cbSPX,
                       label: sat_sbSyF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSPX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSPY; else goto cbSPZ;
       cbSPY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSPZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fApplicativeZipList4_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeZipList4_entry() //  [R2, R3]
         { info_tbl: [(cbSQ4,
                       label: Control.Applicative.$fApplicativeZipList4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSQ4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSQ5; else goto cbSQ6;
       cbSQ5: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeZipList4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSQ6: // global
           I64[Sp - 16] = block_cbSPH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubSQp; else goto cbSPI;
       ubSQp: // global
           call _cbSPH(R1) args: 0, res: 0, upd: 0;
       cbSPI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbSPH() //  [R1]
         { info_tbl: [(cbSPH,
                       label: block_cbSPH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSPH: // global
           if (R1 & 7 == 1) goto ubSQk; else goto cbSQ2;
       ubSQk: // global
           Sp = Sp + 16;
           call _cbSQd() args: 0, res: 0, upd: 0;
       cbSQ2: // global
           I64[Sp] = block_cbSPN_info;
           _sbSyB::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbSyB::P64;
           if (R1 & 7 != 0) goto ubSQm; else goto cbSPO;
       ubSQm: // global
           call _cbSPN(R1) args: 0, res: 0, upd: 0;
       cbSPO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbSPN() //  [R1]
         { info_tbl: [(cbSPN,
                       label: block_cbSPN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSPN: // global
           if (R1 & 7 == 1) goto ubSQl; else goto cbSQf;
       ubSQl: // global
           Sp = Sp + 16;
           call _cbSQd() args: 0, res: 0, upd: 0;
       cbSQf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbSQi; else goto cbSQh;
       cbSQi: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbSQh: // global
           _sbSyD::P64 = P64[R1 + 6];
           _sbSyE::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_sbSyF_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sbSyE::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sbSyD::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbSQd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSQd: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.422540074 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList3_closure" {
     Control.Applicative.$fApplicativeZipList3_closure:
         const Control.Applicative.$fApplicativeZipList3_info;
 },
 Control.Applicative.$fApplicativeZipList3_entry() //  [R2, R3]
         { info_tbl: [(cbSQu,
                       label: Control.Applicative.$fApplicativeZipList3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSQu: // global
           R3 = R3;
           R2 = R2;
           call Control.Applicative.$fApplicativeZipList4_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.423913101 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList2_closure" {
     Control.Applicative.$fApplicativeZipList2_closure:
         const Control.Applicative.$fApplicativeZipList2_info;
 },
 sat_sbSyQ_entry() //  [R1]
         { info_tbl: [(cbSQR,
                       label: sat_sbSyQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSQR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSQS; else goto cbSQT;
       cbSQS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSQT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fApplicativeZipList2_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeZipList2_entry() //  [R2, R3]
         { info_tbl: [(cbSQY,
                       label: Control.Applicative.$fApplicativeZipList2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSQY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbSQZ; else goto cbSR0;
       cbSQZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeZipList2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSR0: // global
           I64[Sp - 16] = block_cbSQB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubSRj; else goto cbSQC;
       ubSRj: // global
           call _cbSQB(R1) args: 0, res: 0, upd: 0;
       cbSQC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbSQB() //  [R1]
         { info_tbl: [(cbSQB,
                       label: block_cbSQB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSQB: // global
           if (R1 & 7 == 1) goto ubSRe; else goto cbSQW;
       ubSRe: // global
           Sp = Sp + 16;
           call _cbSR7() args: 0, res: 0, upd: 0;
       cbSQW: // global
           I64[Sp - 8] = block_cbSQH_info;
           _sbSyL::P64 = P64[R1 + 6];
           _sbSyM::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbSyM::P64;
           P64[Sp + 8] = _sbSyL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubSRg; else goto cbSQI;
       ubSRg: // global
           call _cbSQH(R1) args: 0, res: 0, upd: 0;
       cbSQI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbSQH() //  [R1]
         { info_tbl: [(cbSQH,
                       label: block_cbSQH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSQH: // global
           if (R1 & 7 == 1) goto ubSRf; else goto cbSR9;
       ubSRf: // global
           Sp = Sp + 24;
           call _cbSR7() args: 0, res: 0, upd: 0;
       cbSR9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbSRc; else goto cbSRb;
       cbSRc: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbSRb: // global
           _sbSyP::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_sbSyQ_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sbSyP::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbSR7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSR7: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.425804905 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList1_closure" {
     Control.Applicative.$fApplicativeZipList1_closure:
         const Control.Applicative.$fApplicativeZipList1_info;
 },
 Control.Applicative.$fApplicativeZipList1_entry() //  [R2, R3]
         { info_tbl: [(cbSRo,
                       label: Control.Applicative.$fApplicativeZipList1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSRo: // global
           R3 = R3;
           R2 = R2;
           call Control.Applicative.$fApplicativeZipList2_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.426527476 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList_closure" {
     Control.Applicative.$fApplicativeZipList_closure:
         const GHC.Base.C:Applicative_con_info;
         const Control.Applicative.$fFunctorZipList_closure+1;
         const GHC.List.repeat_closure+1;
         const Control.Applicative.$fApplicativeZipList5_closure+2;
         const GHC.List.zipWith_closure+3;
         const Control.Applicative.$fApplicativeZipList3_closure+2;
         const Control.Applicative.$fApplicativeZipList1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.427111971 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList_xs_closure" {
     Control.Applicative.$fAlternativeZipList_xs_closure:
         const :_con_info;
         const GHC.Types.[]_closure+1;
         const Control.Applicative.$fAlternativeZipList_xs_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.428395088 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList1_closure" {
     Control.Applicative.$fAlternativeZipList1_closure:
         const Control.Applicative.$fAlternativeZipList1_info;
 },
 sat_sbSz2_entry() //  [R1]
         { info_tbl: [(cbSRL,
                       label: sat_sbSz2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSRL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSRM; else goto cbSRN;
       cbSRM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSRN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeZipList1_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeZipList1_entry() //  [R2, R3]
         { info_tbl: [(cbSRS,
                       label: Control.Applicative.$fAlternativeZipList1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSRS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbSRT; else goto cbSRU;
       cbSRT: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeZipList1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSRU: // global
           I64[Sp - 16] = block_cbSRv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubSSe; else goto cbSRw;
       ubSSe: // global
           call _cbSRv(R1) args: 0, res: 0, upd: 0;
       cbSRw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbSRv() //  [R1]
         { info_tbl: [(cbSRv,
                       label: block_cbSRv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSRv: // global
           if (R1 & 7 == 1) goto ubSS9; else goto cbSRQ;
       ubSS9: // global
           Sp = Sp + 16;
           call _cbSS1() args: 0, res: 0, upd: 0;
       cbSRQ: // global
           I64[Sp - 8] = block_cbSRB_info;
           _sbSyW::P64 = P64[R1 + 6];
           _sbSyX::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbSyX::P64;
           P64[Sp + 8] = _sbSyW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubSSb; else goto cbSRC;
       ubSSb: // global
           call _cbSRB(R1) args: 0, res: 0, upd: 0;
       cbSRC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbSRB() //  [R1]
         { info_tbl: [(cbSRB,
                       label: block_cbSRB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSRB: // global
           if (R1 & 7 == 1) goto ubSSa; else goto cbSS4;
       ubSSa: // global
           Sp = Sp + 24;
           call _cbSS1() args: 0, res: 0, upd: 0;
       cbSS4: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbSS7; else goto cbSS6;
       cbSS7: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbSS6: // global
           _sbSyZ::P64 = P64[R1 + 6];
           _sbSz0::P64 = P64[R1 + 14];
           I64[Hp - 72] = sat_sbSz2_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _sbSz0::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sbSyZ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbSS1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSS1: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.430600185 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList_$csome_closure" {
     Control.Applicative.$fAlternativeZipList_$csome_closure:
         const Control.Applicative.$fAlternativeZipList_$csome_info;
 },
 sat_sbSz5_entry() //  [R1]
         { info_tbl: [(cbSSr,
                       label: sat_sbSz5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSSr: // global
           R3 = Control.Applicative.$fAlternativeZipList_xs_closure+2;
           R2 = P64[R1 + 16];
           call Control.Applicative.$fAlternativeZipList2_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 some_v_sbSz4_entry() //  [R1]
         { info_tbl: [(cbSSu,
                       label: some_v_sbSz4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSSu: // global
           _sbSz4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbSSv; else goto cbSSw;
       cbSSw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSSy; else goto cbSSx;
       cbSSy: // global
           HpAlloc = 24;
           goto cbSSv;
       cbSSv: // global
           R1 = _sbSz4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSSx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSz4::P64;
           _sbSz3::P64 = P64[_sbSz4::P64 + 16];
           I64[Hp - 16] = sat_sbSz5_info;
           P64[Hp] = _sbSz4::P64;
           R3 = Hp - 16;
           R2 = _sbSz3::P64;
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeZipList1_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeZipList_$csome_entry() //  [R2]
         { info_tbl: [(cbSSz,
                       label: Control.Applicative.$fAlternativeZipList_$csome_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSSz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSSD; else goto cbSSC;
       cbSSD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeZipList_$csome_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSSC: // global
           I64[Hp - 16] = some_v_sbSz4_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.432253247 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList_$cmany_closure" {
     Control.Applicative.$fAlternativeZipList_$cmany_closure:
         const Control.Applicative.$fAlternativeZipList_$cmany_info;
 },
 many_v_sbSz7_entry() //  [R1]
         { info_tbl: [(cbSSO,
                       label: many_v_sbSz7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSSO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbSSP; else goto cbSSQ;
       cbSSP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSSQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbSSM_info;
           R3 = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Applicative.$fAlternativeZipList1_entry(R3,
                                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbSSM() //  [R1]
         { info_tbl: [(cbSSM,
                       label: block_cbSSM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSSM: // global
           R3 = Control.Applicative.$fAlternativeZipList_xs_closure+2;
           R2 = R1;
           Sp = Sp + 8;
           call Control.Applicative.$fAlternativeZipList2_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeZipList_$cmany_entry() //  [R2]
         { info_tbl: [(cbSSU,
                       label: Control.Applicative.$fAlternativeZipList_$cmany_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSSU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSSY; else goto cbSSX;
       cbSSY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeZipList_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSSX: // global
           I64[Hp - 16] = many_v_sbSz7_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.433734563 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList_closure" {
     Control.Applicative.$fAlternativeZipList_closure:
         const GHC.Base.C:Alternative_con_info;
         const Control.Applicative.$fApplicativeZipList_closure+1;
         const GHC.Types.[]_closure+1;
         const Control.Applicative.$fAlternativeZipList2_closure+2;
         const Control.Applicative.$fAlternativeZipList_$csome_closure+1;
         const Control.Applicative.$fAlternativeZipList_$cmany_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.434313681 UTC

[section ""cstring" . Control.Applicative.$fReadZipList11_bytes" {
     Control.Applicative.$fReadZipList11_bytes:
         I8[] [90,105,112,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.435056215 UTC

[section ""data" . Control.Applicative.$fReadZipList10_closure" {
     Control.Applicative.$fReadZipList10_closure:
         const Control.Applicative.$fReadZipList10_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Applicative.$fReadZipList10_entry() //  [R1]
         { info_tbl: [(cbST5,
                       label: Control.Applicative.$fReadZipList10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbST5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbST6; else goto cbST7;
       cbST6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbST7: // global
           (_cbST2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbST2::I64 == 0) goto cbST4; else goto cbST3;
       cbST4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbST3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbST2::I64;
           R2 = Control.Applicative.$fReadZipList11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.435973888 UTC

[section ""data" . Control.Applicative.$fReadZipList_lexeme1_closure" {
     Control.Applicative.$fReadZipList_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Control.Applicative.$fReadZipList10_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.43650976 UTC

[section ""cstring" . Control.Applicative.$fReadZipList9_bytes" {
     Control.Applicative.$fReadZipList9_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.437170265 UTC

[section ""data" . Control.Applicative.$fReadZipList8_closure" {
     Control.Applicative.$fReadZipList8_closure:
         const Control.Applicative.$fReadZipList8_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Applicative.$fReadZipList8_entry() //  [R1]
         { info_tbl: [(cbSTe,
                       label: Control.Applicative.$fReadZipList8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSTe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSTf; else goto cbSTg;
       cbSTf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSTg: // global
           (_cbSTb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbSTb::I64 == 0) goto cbSTd; else goto cbSTc;
       cbSTd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbSTc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbSTb::I64;
           R2 = Control.Applicative.$fReadZipList9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.438067649 UTC

[section ""data" . Control.Applicative.$fReadZipList_lexeme_closure" {
     Control.Applicative.$fReadZipList_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const Control.Applicative.$fReadZipList8_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.440711038 UTC

[section ""cstring" . Control.Applicative.$fReadZipList7_bytes" {
     Control.Applicative.$fReadZipList7_bytes:
         I8[] [103,101,116,90,105,112,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.441469337 UTC

[section ""data" . Control.Applicative.$fReadZipList6_closure" {
     Control.Applicative.$fReadZipList6_closure:
         const Control.Applicative.$fReadZipList6_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Applicative.$fReadZipList6_entry() //  [R1]
         { info_tbl: [(cbSTn,
                       label: Control.Applicative.$fReadZipList6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSTn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSTo; else goto cbSTp;
       cbSTo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSTp: // global
           (_cbSTk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbSTk::I64 == 0) goto cbSTm; else goto cbSTl;
       cbSTm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbSTl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbSTk::I64;
           R2 = Control.Applicative.$fReadZipList7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.442371264 UTC

[section ""data" . Control.Applicative.$fReadZipList5_closure" {
     Control.Applicative.$fReadZipList5_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.442908333 UTC

[section ""cstring" . Control.Applicative.$fReadZipList4_bytes" {
     Control.Applicative.$fReadZipList4_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.443645987 UTC

[section ""data" . Control.Applicative.$fReadZipList3_closure" {
     Control.Applicative.$fReadZipList3_closure:
         const Control.Applicative.$fReadZipList3_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Applicative.$fReadZipList3_entry() //  [R1]
         { info_tbl: [(cbSTw,
                       label: Control.Applicative.$fReadZipList3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSTw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSTx; else goto cbSTy;
       cbSTx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSTy: // global
           (_cbSTt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbSTt::I64 == 0) goto cbSTv; else goto cbSTu;
       cbSTv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbSTu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbSTt::I64;
           R2 = Control.Applicative.$fReadZipList4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.444519687 UTC

[section ""data" . Control.Applicative.$fReadZipList2_closure" {
     Control.Applicative.$fReadZipList2_closure:
         const Text.Read.Lex.Punc_con_info;
         const Control.Applicative.$fReadZipList3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.446976509 UTC

[section ""data" . Control.Applicative.$fReadZipList1_closure" {
     Control.Applicative.$fReadZipList1_closure:
         const Control.Applicative.$fReadZipList1_info;
         const 0;
 },
 lvl_sbSza_entry() //  [R1]
         { info_tbl: [(cbSTH,
                       label: lvl_sbSza_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSTH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbSTI; else goto cbSTJ;
       cbSTI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSTJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readListPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_sbSzb_entry() //  [R1]
         { info_tbl: [(cbSTP,
                       label: ds_sbSzb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSTP: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzm_entry() //  [R1]
         { info_tbl: [(cbSUq,
                       label: sat_sbSzm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSUq: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzp_entry() //  [R1, R2]
         { info_tbl: [(cbSUw,
                       label: sat_sbSzp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSUw: // global
           _sbSzk::P64 = R2;
           _sbSzp::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cbSUx; else goto cbSUy;
       cbSUy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSUA; else goto cbSUz;
       cbSUA: // global
           HpAlloc = 24;
           goto cbSUx;
       cbSUx: // global
           R2 = _sbSzk::P64;
           R1 = _sbSzp::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSUz: // global
           _sbSze::P64 = P64[_sbSzp::P64 + 7];
           I64[Hp - 16] = sat_sbSzm_info;
           P64[Hp - 8] = _sbSze::P64;
           P64[Hp] = _sbSzk::P64;
           I64[Sp - 8] = block_cbSUt_info;
           R3 = Hp - 15;
           R2 = Control.Applicative.$fReadZipList2_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbSUt() //  [R1]
         { info_tbl: [(cbSUt,
                       label: block_cbSUt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSUt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbSUD; else goto cbSUC;
       cbSUD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbSUC: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzq_entry() //  [R1, R2]
         { info_tbl: [(cbSUE,
                       label: sat_sbSzq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSUE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbSUI; else goto cbSUH;
       cbSUI: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSUH: // global
           _sbSzb::P64 = P64[R1 + 7];
           _sbSze::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sbSzp_info;
           P64[Hp] = _sbSze::P64;
           R5 = Hp - 7;
           R4 = Control.Applicative.$fReadZipList5_closure+1;
           R3 = _sbSzb::P64;
           R2 = Control.Applicative.$fReadZipList6_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzt_entry() //  [R1, R2]
         { info_tbl: [(cbSUM,
                       label: sat_sbSzt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSUM: // global
           _sbSzi::P64 = R2;
           _sbSzt::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cbSUN; else goto cbSUO;
       cbSUO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSUQ; else goto cbSUP;
       cbSUQ: // global
           HpAlloc = 24;
           goto cbSUN;
       cbSUN: // global
           R2 = _sbSzi::P64;
           R1 = _sbSzt::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSUP: // global
           _sbSzb::P64 = P64[_sbSzt::P64 + 7];
           _sbSze::P64 = P64[_sbSzt::P64 + 15];
           I64[Hp - 16] = sat_sbSzq_info;
           P64[Hp - 8] = _sbSzb::P64;
           P64[Hp] = _sbSze::P64;
           I64[Sp - 8] = block_cbSUJ_info;
           R3 = Hp - 15;
           R2 = Control.Applicative.$fReadZipList_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbSUJ() //  [R1]
         { info_tbl: [(cbSUJ,
                       label: block_cbSUJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSUJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbSUT; else goto cbSUS;
       cbSUT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbSUS: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzw_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSUU,
                       label: sat_sbSzw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSUU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbSUV; else goto cbSUW;
       cbSUV: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSUW: // global
           I64[Sp - 24] = block_cbSTX_info;
           _sbSzb::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sbSzb::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubSV9; else goto cbSTY;
       ubSV9: // global
           call _cbSTX(R1) args: 0, res: 0, upd: 0;
       cbSTY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbSTX() //  [R1]
         { info_tbl: [(cbSTX,
                       label: block_cbSTX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSTX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSUZ; else goto cbSUY;
       cbSUZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbSUY: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto cbSV1; else goto cbSV5;
       cbSV1: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbSV5: // global
           I64[Hp - 16] = sat_sbSzt_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cbSV2_info;
           R3 = Hp - 15;
           R2 = Control.Applicative.$fReadZipList_lexeme1_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbSV2() //  [R1]
         { info_tbl: [(cbSV2,
                       label: block_cbSV2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSV2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbSV8; else goto cbSV7;
       cbSV8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbSV7: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fReadZipList1_entry() //  [R2]
         { info_tbl: [(cbSVa,
                       label: Control.Applicative.$fReadZipList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSVa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbSVe; else goto cbSVd;
       cbSVe: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSVd: // global
           I64[Hp - 48] = lvl_sbSza_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_sbSzb_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sbSzw_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.451335716 UTC

[section ""data" . Control.Applicative.$fReadZipList_$creadsPrec_closure" {
     Control.Applicative.$fReadZipList_$creadsPrec_closure:
         const Control.Applicative.$fReadZipList_$creadsPrec_info;
         const 0;
 },
 ds_sbSzy_entry() //  [R1]
         { info_tbl: [(cbSVo,
                       label: ds_sbSzy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSVo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSVp; else goto cbSVq;
       cbSVp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSVq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSzA_entry() //  [R1]
         { info_tbl: [(cbSVA,
                       label: sat_sbSzA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSVA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSVB; else goto cbSVC;
       cbSVB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSVC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSzB_entry() //  [R1, R2]
         { info_tbl: [(cbSVD,
                       label: sat_sbSzB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSVD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbSVH; else goto cbSVG;
       cbSVH: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSVG: // global
           _sbSzy::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sbSzA_info;
           P64[Hp - 8] = _sbSzy::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fReadZipList_$creadsPrec_entry() //  [R2]
         { info_tbl: [(cbSVI,
                       label: Control.Applicative.$fReadZipList_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSVI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbSVM; else goto cbSVL;
       cbSVM: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSVL: // global
           I64[Hp - 32] = ds_sbSzy_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sbSzB_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.453138069 UTC

[section ""data" . Control.Applicative.$fReadZipList_$creadListPrec_closure" {
     Control.Applicative.$fReadZipList_$creadListPrec_closure:
         const Control.Applicative.$fReadZipList_$creadListPrec_info;
         const 0;
 },
 sat_sbSzD_entry() //  [R1]
         { info_tbl: [(cbSVV,
                       label: sat_sbSzD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSVV: // global
           R2 = P64[R1 + 16];
           call Control.Applicative.$fReadZipList1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fReadZipList_$creadListPrec_entry() //  [R2]
         { info_tbl: [(cbSVY,
                       label: Control.Applicative.$fReadZipList_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSVY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSW2; else goto cbSW1;
       cbSW2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSW1: // global
           I64[Hp - 16] = sat_sbSzD_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.454494295 UTC

[section ""data" . Control.Applicative.$fReadZipList_$creadList_closure" {
     Control.Applicative.$fReadZipList_$creadList_closure:
         const Control.Applicative.$fReadZipList_$creadList_info;
         const 0;
 },
 sat_sbSzF_entry() //  [R1]
         { info_tbl: [(cbSWf,
                       label: sat_sbSzF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSWf: // global
           R2 = P64[R1 + 16];
           call Control.Applicative.$fReadZipList1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzG_entry() //  [R1]
         { info_tbl: [(cbSWi,
                       label: sat_sbSzG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSWi: // global
           _sbSzG::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbSWj; else goto cbSWk;
       cbSWk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSWm; else goto cbSWl;
       cbSWm: // global
           HpAlloc = 24;
           goto cbSWj;
       cbSWj: // global
           R1 = _sbSzG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSWl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSzG::P64;
           _sbSzE::P64 = P64[_sbSzG::P64 + 16];
           I64[Hp - 16] = sat_sbSzF_info;
           P64[Hp] = _sbSzE::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fReadZipList_$creadList_entry() //  [R2]
         { info_tbl: [(cbSWn,
                       label: Control.Applicative.$fReadZipList_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSWn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSWr; else goto cbSWq;
       cbSWr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSWq: // global
           I64[Hp - 16] = sat_sbSzG_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.456377703 UTC

[section ""data" . Control.Applicative.$fReadZipList_closure" {
     Control.Applicative.$fReadZipList_closure:
         const Control.Applicative.$fReadZipList_info;
         const 0;
 },
 sat_sbSzL_entry() //  [R1]
         { info_tbl: [(cbSWA,
                       label: sat_sbSzL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSWA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSWB; else goto cbSWC;
       cbSWB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSWC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSzK_entry() //  [R1]
         { info_tbl: [(cbSWH,
                       label: sat_sbSzK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSWH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSWI; else goto cbSWJ;
       cbSWI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSWJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSzJ_entry() //  [R1]
         { info_tbl: [(cbSWO,
                       label: sat_sbSzJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSWO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSWP; else goto cbSWQ;
       cbSWP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSWQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSzI_entry() //  [R1]
         { info_tbl: [(cbSWV,
                       label: sat_sbSzI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSWV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSWW; else goto cbSWX;
       cbSWW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSWX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fReadZipList_entry() //  [R2]
         { info_tbl: [(cbSWZ,
                       label: Control.Applicative.$fReadZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSWZ: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbSX3; else goto cbSX2;
       cbSX3: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSX2: // global
           I64[Hp - 128] = sat_sbSzL_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbSzK_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbSzJ_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbSzI_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.458566719 UTC

[section ""data" . Control.Applicative.$fEqZipList_closure" {
     Control.Applicative.$fEqZipList_closure:
         const Control.Applicative.$fEqZipList_info;
 },
 sat_sbSzO_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSXd,
                       label: sat_sbSzO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSXd: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fEq[]_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzN_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSXl,
                       label: sat_sbSzN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSXl: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fEq[]_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fEqZipList_entry() //  [R2]
         { info_tbl: [(cbSXp,
                       label: Control.Applicative.$fEqZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSXp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbSXt; else goto cbSXs;
       cbSXt: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Applicative.$fEqZipList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSXs: // global
           I64[Hp - 48] = sat_sbSzO_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sbSzN_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.460035338 UTC

[section ""data" . Control.Applicative.$fOrdZipList_$cp1Ord_closure" {
     Control.Applicative.$fOrdZipList_$cp1Ord_closure:
         const Control.Applicative.$fOrdZipList_$cp1Ord_info;
 },
 sat_sbSzQ_entry() //  [R1]
         { info_tbl: [(cbSXC,
                       label: sat_sbSzQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSXC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSXD; else goto cbSXE;
       cbSXD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSXE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fOrdZipList_$cp1Ord_entry() //  [R2]
         { info_tbl: [(cbSXF,
                       label: Control.Applicative.$fOrdZipList_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSXF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSXJ; else goto cbSXI;
       cbSXJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fOrdZipList_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSXI: // global
           I64[Hp - 16] = sat_sbSzQ_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Applicative.$fEqZipList_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.462380917 UTC

[section ""data" . Control.Applicative.$fOrdZipList_closure" {
     Control.Applicative.$fOrdZipList_closure:
         const Control.Applicative.$fOrdZipList_info;
 },
 sat_sbSzZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSXT,
                       label: sat_sbSzZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSXT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzY_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSY1,
                       label: sat_sbSzY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSY1: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzX_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSY9,
                       label: sat_sbSzX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSY9: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzW_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSYh,
                       label: sat_sbSzW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSYh: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$c>_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzV_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSYp,
                       label: sat_sbSzV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSYp: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzU_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSYx,
                       label: sat_sbSzU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSYx: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzT_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSYF,
                       label: sat_sbSzT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSYF: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzS_entry() //  [R1]
         { info_tbl: [(cbSYM,
                       label: sat_sbSzS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSYM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSYN; else goto cbSYO;
       cbSYN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSYO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fOrdZipList_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fOrdZipList_entry() //  [R2]
         { info_tbl: [(cbSYQ,
                       label: Control.Applicative.$fOrdZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSYQ: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cbSYU; else goto cbSYT;
       cbSYU: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = Control.Applicative.$fOrdZipList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSYT: // global
           I64[Hp - 200] = sat_sbSzZ_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sbSzY_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_sbSzX_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbSzW_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbSzV_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbSzU_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbSzT_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbSzS_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.46470355 UTC

[section ""cstring" . Control.Applicative.$fShowZipList3_bytes" {
     Control.Applicative.$fShowZipList3_bytes:
         I8[] [90,105,112,76,105,115,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.465264216 UTC

[section ""cstring" . Control.Applicative.$fShowZipList2_bytes" {
     Control.Applicative.$fShowZipList2_bytes:
         I8[] [103,101,116,90,105,112,76,105,115,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.467538872 UTC

[section ""data" . Control.Applicative.$w$cshowsPrec_closure" {
     Control.Applicative.$w$cshowsPrec_closure:
         const Control.Applicative.$w$cshowsPrec_info;
 },
 f_sbSA3_entry() //  [R1]
         { info_tbl: [(cbSZ3,
                       label: f_sbSA3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSZ3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbSZ4; else goto cbSZ5;
       cbSZ4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSZ5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.showList_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSA6_entry() //  [R1]
         { info_tbl: [(cbSZq,
                       label: sat_sbSA6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSZq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSZr; else goto cbSZs;
       cbSZr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSZs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Control.Applicative.$fReadZipList4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSA7_entry() //  [R1]
         { info_tbl: [(cbSZt,
                       label: sat_sbSA7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSZt: // global
           _sbSA7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbSZu; else goto cbSZv;
       cbSZv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSZx; else goto cbSZw;
       cbSZx: // global
           HpAlloc = 24;
           goto cbSZu;
       cbSZu: // global
           R1 = _sbSA7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSZw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSA7::P64;
           _sbSA3::P64 = P64[_sbSA7::P64 + 16];
           _sbSA5::P64 = P64[_sbSA7::P64 + 24];
           I64[Hp - 16] = sat_sbSA6_info;
           P64[Hp] = _sbSA5::P64;
           R2 = Hp - 16;
           R1 = _sbSA3::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSA8_entry() //  [R1]
         { info_tbl: [(cbSZy,
                       label: sat_sbSA8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSZy: // global
           _sbSA8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbSZz; else goto cbSZA;
       cbSZA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbSZC; else goto cbSZB;
       cbSZC: // global
           HpAlloc = 32;
           goto cbSZz;
       cbSZz: // global
           R1 = _sbSA8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSZB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSA8::P64;
           _sbSA3::P64 = P64[_sbSA8::P64 + 16];
           _sbSA5::P64 = P64[_sbSA8::P64 + 24];
           I64[Hp - 24] = sat_sbSA7_info;
           P64[Hp - 8] = _sbSA3::P64;
           P64[Hp] = _sbSA5::P64;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSA9_entry() //  [R1, R2]
         { info_tbl: [(cbSZD,
                       label: sat_sbSA9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSZD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbSZH; else goto cbSZG;
       cbSZH: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSZG: // global
           _sbSA3::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sbSA8_info;
           P64[Hp - 8] = _sbSA3::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSAc_entry() //  [R1]
         { info_tbl: [(cbT05,
                       label: sat_sbSAc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT05: // global
           _sbSAc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbT06; else goto cbT07;
       cbT07: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbT09; else goto cbT08;
       cbT09: // global
           HpAlloc = 24;
           goto cbT06;
       cbT06: // global
           R1 = _sbSAc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT08: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSAc::P64;
           _sbSAa::P64 = P64[_sbSAc::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sbSAa::P64;
           R3 = Hp - 14;
           R2 = Control.Applicative.$fReadZipList4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAd_entry() //  [R1]
         { info_tbl: [(cbT0a,
                       label: sat_sbSAd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT0a: // global
           _sbSAd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbT0b; else goto cbT0c;
       cbT0c: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbT0e; else goto cbT0d;
       cbT0e: // global
           HpAlloc = 24;
           goto cbT0b;
       cbT0b: // global
           R1 = _sbSAd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT0d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSAd::P64;
           _sbSA3::P64 = P64[_sbSAd::P64 + 16];
           _sbSAa::P64 = P64[_sbSAd::P64 + 24];
           I64[Hp - 16] = sat_sbSAc_info;
           P64[Hp] = _sbSAa::P64;
           R2 = Hp - 16;
           R1 = _sbSA3::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAe_entry() //  [R1]
         { info_tbl: [(cbT0f,
                       label: sat_sbSAe_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT0f: // global
           _sbSAe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbT0g; else goto cbT0h;
       cbT0h: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbT0j; else goto cbT0i;
       cbT0j: // global
           HpAlloc = 32;
           goto cbT0g;
       cbT0g: // global
           R1 = _sbSAe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT0i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSAe::P64;
           _sbSA3::P64 = P64[_sbSAe::P64 + 16];
           _sbSAa::P64 = P64[_sbSAe::P64 + 24];
           I64[Hp - 24] = sat_sbSAd_info;
           P64[Hp - 8] = _sbSA3::P64;
           P64[Hp] = _sbSAa::P64;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAf_entry() //  [R1]
         { info_tbl: [(cbT0k,
                       label: sat_sbSAf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT0k: // global
           _sbSAf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbT0l; else goto cbT0m;
       cbT0m: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbT0o; else goto cbT0n;
       cbT0o: // global
           HpAlloc = 32;
           goto cbT0l;
       cbT0l: // global
           R1 = _sbSAf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT0n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSAf::P64;
           _sbSA3::P64 = P64[_sbSAf::P64 + 16];
           _sbSAa::P64 = P64[_sbSAf::P64 + 24];
           I64[Hp - 24] = sat_sbSAe_info;
           P64[Hp - 8] = _sbSA3::P64;
           P64[Hp] = _sbSAa::P64;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAg_entry() //  [R1, R2]
         { info_tbl: [(cbT0q,
                       label: sat_sbSAg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT0q: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbT0u; else goto cbT0t;
       cbT0u: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbT0t: // global
           _sbSA3::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_sbSAf_info;
           P64[Hp - 32] = _sbSA3::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cbT0y,
                       label: Control.Applicative.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT0y: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbT0C; else goto cbT0B;
       cbT0C: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbT0B: // global
           I64[Hp - 40] = f_sbSA3_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _cbSYZ::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto cbT0w; else goto cbT0x;
       cbT0w: // global
           I64[Hp - 8] = sat_sbSA9_info;
           P64[Hp] = _cbSYZ::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbT0x: // global
           I64[Hp - 8] = sat_sbSAg_info;
           P64[Hp] = _cbSYZ::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.471773576 UTC

[section ""data" . Control.Applicative.$fShowZipList_$cshowsPrec_closure" {
     Control.Applicative.$fShowZipList_$cshowsPrec_closure:
         const Control.Applicative.$fShowZipList_$cshowsPrec_info;
 },
 Control.Applicative.$fShowZipList_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbT0K,
                       label: Control.Applicative.$fShowZipList_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT0K: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbT0L; else goto cbT0M;
       cbT0L: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fShowZipList_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbT0M: // global
           I64[Sp - 24] = block_cbT0H_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubT0Q; else goto cbT0I;
       ubT0Q: // global
           call _cbT0H(R1) args: 0, res: 0, upd: 0;
       cbT0I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbT0H() //  [R1]
         { info_tbl: [(cbT0H,
                       label: block_cbT0H_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT0H: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Control.Applicative.$w$cshowsPrec_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.473298726 UTC

[section ""data" . Control.Applicative.$fShowZipList_$cshow_closure" {
     Control.Applicative.$fShowZipList_$cshow_closure:
         const Control.Applicative.$fShowZipList_$cshow_info;
         const 0;
 },
 sat_sbSAo_entry() //  [R1]
         { info_tbl: [(cbT13,
                       label: sat_sbSAo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT13: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbT14; else goto cbT15;
       cbT14: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT15: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Control.Applicative.$fReadZipList3_closure;
           Sp = Sp - 40;
           call GHC.Show.showList_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbSAp_entry() //  [R1]
         { info_tbl: [(cbT16,
                       label: sat_sbSAp_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT16: // global
           _sbSAp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbT17; else goto cbT18;
       cbT18: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbT1a; else goto cbT19;
       cbT1a: // global
           HpAlloc = 32;
           goto cbT17;
       cbT17: // global
           R1 = _sbSAp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT19: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSAp::P64;
           _sbSAm::P64 = P64[_sbSAp::P64 + 16];
           _sbSAn::P64 = P64[_sbSAp::P64 + 24];
           I64[Hp - 24] = sat_sbSAo_info;
           P64[Hp - 8] = _sbSAm::P64;
           P64[Hp] = _sbSAn::P64;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fShowZipList_$cshow_entry() //  [R2, R3]
         { info_tbl: [(cbT1b,
                       label: Control.Applicative.$fShowZipList_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT1b: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbT1f; else goto cbT1e;
       cbT1f: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fShowZipList_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbT1e: // global
           I64[Hp - 24] = sat_sbSAp_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.474799072 UTC

[section ""data" . Control.Applicative.$fShowZipList1_closure" {
     Control.Applicative.$fShowZipList1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.475693712 UTC

[section ""data" . Control.Applicative.$fShowZipList_$cshowList_closure" {
     Control.Applicative.$fShowZipList_$cshowList_closure:
         const Control.Applicative.$fShowZipList_$cshowList_info;
 },
 sat_sbSAu_entry() //  [R1, R2]
         { info_tbl: [(cbT1p,
                       label: sat_sbSAu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT1p: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Control.Applicative.$w$cshowsPrec_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fShowZipList_$cshowList_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cbT1s,
                       label: Control.Applicative.$fShowZipList_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT1s: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbT1w; else goto cbT1v;
       cbT1w: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fShowZipList_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbT1v: // global
           I64[Hp - 8] = sat_sbSAu_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.477203141 UTC

[section ""data" . Control.Applicative.$fShowZipList_closure" {
     Control.Applicative.$fShowZipList_closure:
         const Control.Applicative.$fShowZipList_info;
         const 0;
 },
 sat_sbSAy_entry() //  [R1, R2, R3]
         { info_tbl: [(cbT1G,
                       label: sat_sbSAy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT1G: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fShowZipList_$cshowList_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSAx_entry() //  [R1, R2]
         { info_tbl: [(cbT1O,
                       label: sat_sbSAx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT1O: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fShowZipList_$cshow_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSAw_entry() //  [R1, R2, R3]
         { info_tbl: [(cbT1W,
                       label: sat_sbSAw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT1W: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fShowZipList_$cshowsPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fShowZipList_entry() //  [R2]
         { info_tbl: [(cbT20,
                       label: Control.Applicative.$fShowZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT20: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbT24; else goto cbT23;
       cbT24: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Control.Applicative.$fShowZipList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbT23: // global
           I64[Hp - 72] = sat_sbSAy_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbSAx_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbSAw_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.478907927 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedArrow1_closure" {
     Control.Applicative.$fGeneric1WrappedArrow1_closure:
         const Control.Applicative.$fGeneric1WrappedArrow1_info;
 },
 Control.Applicative.$fGeneric1WrappedArrow1_entry() //  [R2]
         { info_tbl: [(cbT29,
                       label: Control.Applicative.$fGeneric1WrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT29: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.479745831 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedArrow2_closure" {
     Control.Applicative.$fGeneric1WrappedArrow2_closure:
         const Control.Applicative.$fGeneric1WrappedArrow2_info;
 },
 Control.Applicative.$fGeneric1WrappedArrow2_entry() //  [R2]
         { info_tbl: [(cbT2g,
                       label: Control.Applicative.$fGeneric1WrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT2g: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.480432644 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedArrow_closure" {
     Control.Applicative.$fGeneric1WrappedArrow_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Control.Applicative.$fGeneric1WrappedArrow2_closure+1;
         const Control.Applicative.$fGeneric1WrappedArrow1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.481080598 UTC

[section ""data" . Control.Applicative.$fGenericWrappedArrow1_closure" {
     Control.Applicative.$fGenericWrappedArrow1_closure:
         const Control.Applicative.$fGenericWrappedArrow1_info;
 },
 Control.Applicative.$fGenericWrappedArrow1_entry() //  [R2]
         { info_tbl: [(cbT2n,
                       label: Control.Applicative.$fGenericWrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT2n: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.481912028 UTC

[section ""data" . Control.Applicative.$fGenericWrappedArrow2_closure" {
     Control.Applicative.$fGenericWrappedArrow2_closure:
         const Control.Applicative.$fGenericWrappedArrow2_info;
 },
 Control.Applicative.$fGenericWrappedArrow2_entry() //  [R2]
         { info_tbl: [(cbT2u,
                       label: Control.Applicative.$fGenericWrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT2u: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.482594654 UTC

[section ""data" . Control.Applicative.$fGenericWrappedArrow_closure" {
     Control.Applicative.$fGenericWrappedArrow_closure:
         const GHC.Generics.C:Generic_con_info;
         const Control.Applicative.$fGenericWrappedArrow2_closure+1;
         const Control.Applicative.$fGenericWrappedArrow1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.483903406 UTC

[section ""data" . Control.Applicative.$fMonadWrappedMonad_closure" {
     Control.Applicative.$fMonadWrappedMonad_closure:
         const Control.Applicative.$fMonadWrappedMonad_info;
 },
 sat_sbSAI_entry() //  [R1]
         { info_tbl: [(cbT2F,
                       label: sat_sbSAI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT2F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbT2G; else goto cbT2H;
       cbT2G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT2H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.fail_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAH_entry() //  [R1]
         { info_tbl: [(cbT2M,
                       label: sat_sbSAH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT2M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbT2N; else goto cbT2O;
       cbT2N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT2O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAG_entry() //  [R1]
         { info_tbl: [(cbT2T,
                       label: sat_sbSAG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT2T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbT2U; else goto cbT2V;
       cbT2U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT2V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.>>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAF_entry() //  [R1]
         { info_tbl: [(cbT30,
                       label: sat_sbSAF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT30: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbT31; else goto cbT32;
       cbT31: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT32: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.>>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAE_entry() //  [R1]
         { info_tbl: [(cbT37,
                       label: sat_sbSAE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT37: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbT38; else goto cbT39;
       cbT38: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT39: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fApplicativeWrappedMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fMonadWrappedMonad_entry() //  [R2]
         { info_tbl: [(cbT3b,
                       label: Control.Applicative.$fMonadWrappedMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT3b: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cbT3f; else goto cbT3e;
       cbT3f: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Control.Applicative.$fMonadWrappedMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbT3e: // global
           I64[Hp - 160] = sat_sbSAI_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbSAH_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbSAG_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbSAF_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbSAE_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.485990974 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedMonad1_closure" {
     Control.Applicative.$fGeneric1WrappedMonad1_closure:
         const Control.Applicative.$fGeneric1WrappedMonad1_info;
 },
 Control.Applicative.$fGeneric1WrappedMonad1_entry() //  [R2]
         { info_tbl: [(cbT3k,
                       label: Control.Applicative.$fGeneric1WrappedMonad1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT3k: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.486780206 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedMonad2_closure" {
     Control.Applicative.$fGeneric1WrappedMonad2_closure:
         const Control.Applicative.$fGeneric1WrappedMonad2_info;
 },
 Control.Applicative.$fGeneric1WrappedMonad2_entry() //  [R2]
         { info_tbl: [(cbT3r,
                       label: Control.Applicative.$fGeneric1WrappedMonad2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT3r: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.487460119 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedMonad_closure" {
     Control.Applicative.$fGeneric1WrappedMonad_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Control.Applicative.$fGeneric1WrappedMonad2_closure+1;
         const Control.Applicative.$fGeneric1WrappedMonad1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.488169731 UTC

[section ""data" . Control.Applicative.$fGenericWrappedMonad1_closure" {
     Control.Applicative.$fGenericWrappedMonad1_closure:
         const Control.Applicative.$fGenericWrappedMonad1_info;
 },
 Control.Applicative.$fGenericWrappedMonad1_entry() //  [R2]
         { info_tbl: [(cbT3y,
                       label: Control.Applicative.$fGenericWrappedMonad1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT3y: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.488991089 UTC

[section ""data" . Control.Applicative.$fGenericWrappedMonad2_closure" {
     Control.Applicative.$fGenericWrappedMonad2_closure:
         const Control.Applicative.$fGenericWrappedMonad2_info;
 },
 Control.Applicative.$fGenericWrappedMonad2_entry() //  [R2]
         { info_tbl: [(cbT3F,
                       label: Control.Applicative.$fGenericWrappedMonad2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT3F: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.48990627 UTC

[section ""data" . Control.Applicative.$fGenericWrappedMonad_closure" {
     Control.Applicative.$fGenericWrappedMonad_closure:
         const GHC.Generics.C:Generic_con_info;
         const Control.Applicative.$fGenericWrappedMonad2_closure+1;
         const Control.Applicative.$fGenericWrappedMonad1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.49055502 UTC

[section ""data" . Control.Applicative.unwrapMonad_closure" {
     Control.Applicative.unwrapMonad_closure:
         const Control.Applicative.unwrapMonad_info;
 },
 Control.Applicative.unwrapMonad_entry() //  [R2]
         { info_tbl: [(cbT3M,
                       label: Control.Applicative.unwrapMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT3M: // global
           R2 = R2;
           call Control.Applicative.$fGeneric1WrappedMonad2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.491347859 UTC

[section ""data" . Control.Applicative.unwrapArrow_closure" {
     Control.Applicative.unwrapArrow_closure:
         const Control.Applicative.unwrapArrow_info;
 },
 Control.Applicative.unwrapArrow_entry() //  [R2]
         { info_tbl: [(cbT3T,
                       label: Control.Applicative.unwrapArrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT3T: // global
           R2 = R2;
           call Control.Applicative.$fGeneric1WrappedArrow2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.492177818 UTC

[section ""data" . Control.Applicative.getZipList_closure" {
     Control.Applicative.getZipList_closure:
         const Control.Applicative.getZipList_info;
 },
 Control.Applicative.getZipList_entry() //  [R2]
         { info_tbl: [(cbT40,
                       label: Control.Applicative.getZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT40: // global
           R2 = R2;
           call Control.Applicative.$fGeneric1ZipList2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.493525069 UTC

[section ""data" . Control.Applicative.optional_closure" {
     Control.Applicative.optional_closure:
         const Control.Applicative.optional_info;
 },
 $dApplicative_sbSAP_entry() //  [R1]
         { info_tbl: [(cbT4b,
                       label: $dApplicative_sbSAP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT4b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbT4c; else goto cbT4d;
       cbT4c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT4d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAS_entry() //  [R1]
         { info_tbl: [(cbT4i,
                       label: sat_sbSAS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT4i: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbT4j; else goto cbT4k;
       cbT4j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT4k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSAR_entry() //  [R1]
         { info_tbl: [(cbT4r,
                       label: sat_sbSAR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT4r: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbT4s; else goto cbT4t;
       cbT4s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT4t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbT4p_info;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbT4p() //  [R1]
         { info_tbl: [(cbT4p,
                       label: block_cbT4p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT4p: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.optional_entry() //  [R2, R3]
         { info_tbl: [(cbT4x,
                       label: Control.Applicative.optional_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT4x: // global
           _sbSAO::P64 = R3;
           _sbSAN::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbT4y; else goto cbT4z;
       cbT4z: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbT4B; else goto cbT4A;
       cbT4B: // global
           HpAlloc = 80;
           goto cbT4y;
       cbT4y: // global
           R3 = _sbSAO::P64;
           R2 = _sbSAN::P64;
           R1 = Control.Applicative.optional_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbT4A: // global
           I64[Hp - 72] = $dApplicative_sbSAP_info;
           P64[Hp - 56] = _sbSAN::P64;
           I64[Hp - 48] = sat_sbSAS_info;
           _cbT47::P64 = Hp - 72;
           P64[Hp - 32] = _cbT47::P64;
           I64[Hp - 24] = sat_sbSAR_info;
           P64[Hp - 8] = _sbSAO::P64;
           P64[Hp] = _cbT47::P64;
           R2 = _sbSAN::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 24;
           call GHC.Base.<|>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.495307447 UTC

[section ""cstring" . Control.Applicative.$trModule4_bytes" {
     Control.Applicative.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.495864588 UTC

[section ""data" . Control.Applicative.$trModule3_closure" {
     Control.Applicative.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.496368141 UTC

[section ""cstring" . Control.Applicative.$trModule2_bytes" {
     Control.Applicative.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,65,112,112,108,105,99,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.496932742 UTC

[section ""data" . Control.Applicative.$trModule1_closure" {
     Control.Applicative.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.499182944 UTC

[section ""data" . Control.Applicative.$trModule_closure" {
     Control.Applicative.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Applicative.$trModule3_closure+1;
         const Control.Applicative.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.499770537 UTC

[section ""data" . Control.Applicative.$tcWrappedMonad1_closure" {
     Control.Applicative.$tcWrappedMonad1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const GHC.Types.krep$*Arr*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.500254552 UTC

[section ""data" . Control.Applicative.$tcWrappedArrow1_closure" {
     Control.Applicative.$tcWrappedArrow1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const GHC.Types.krep$*->*->*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.500811968 UTC

[section ""data" . $krep_rbSvt_closure" {
     $krep_rbSvt_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.501334092 UTC

[section ""data" . $krep1_rbSvu_closure" {
     $krep1_rbSvu_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.501909721 UTC

[section ""data" . $krep2_rbSvv_closure" {
     $krep2_rbSvv_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.502469125 UTC

[section ""data" . $krep3_rbSvw_closure" {
     $krep3_rbSvw_closure:
         const :_con_info;
         const $krep2_rbSvv_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.503008755 UTC

[section ""data" . $krep4_rbSvx_closure" {
     $krep4_rbSvx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep3_rbSvw_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.503566994 UTC

[section ""data" . $krep5_rbSvy_closure" {
     $krep5_rbSvy_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep2_rbSvv_closure+2;
         const $krep1_rbSvu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.504129711 UTC

[section ""data" . $krep6_rbSvz_closure" {
     $krep6_rbSvz_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep5_rbSvy_closure+3;
         const $krep_rbSvt_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.50467207 UTC

[section ""cstring" . Control.Applicative.$tcWrappedMonad3_bytes" {
     Control.Applicative.$tcWrappedMonad3_bytes:
         I8[] [87,114,97,112,112,101,100,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.505170631 UTC

[section ""data" . Control.Applicative.$tcWrappedMonad2_closure" {
     Control.Applicative.$tcWrappedMonad2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tcWrappedMonad3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.505979199 UTC

[section ""data" . Control.Applicative.$tcWrappedMonad_closure" {
     Control.Applicative.$tcWrappedMonad_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tcWrappedMonad2_closure+1;
         const Control.Applicative.$tcWrappedMonad1_closure+4;
         const 12971590878300233698;
         const 12447260690856494251;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.50657427 UTC

[section ""data" . $krep7_rbSvA_closure" {
     $krep7_rbSvA_closure:
         const :_con_info;
         const $krep1_rbSvu_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.507146537 UTC

[section ""data" . $krep8_rbSvB_closure" {
     $krep8_rbSvB_closure:
         const :_con_info;
         const $krep2_rbSvv_closure+2;
         const $krep7_rbSvA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.507691004 UTC

[section ""data" . $krep9_rbSvC_closure" {
     $krep9_rbSvC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Applicative.$tcWrappedMonad_closure+1;
         const $krep8_rbSvB_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.508244268 UTC

[section ""data" . Control.Applicative.$tc'WrapMonad1_closure" {
     Control.Applicative.$tc'WrapMonad1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_rbSvy_closure+3;
         const $krep9_rbSvC_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.508794881 UTC

[section ""cstring" . Control.Applicative.$tc'WrapMonad3_bytes" {
     Control.Applicative.$tc'WrapMonad3_bytes:
         I8[] [39,87,114,97,112,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.509377483 UTC

[section ""data" . Control.Applicative.$tc'WrapMonad2_closure" {
     Control.Applicative.$tc'WrapMonad2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tc'WrapMonad3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.509966174 UTC

[section ""data" . Control.Applicative.$tc'WrapMonad_closure" {
     Control.Applicative.$tc'WrapMonad_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tc'WrapMonad2_closure+1;
         const Control.Applicative.$tc'WrapMonad1_closure+4;
         const 10363415327661881286;
         const 6845751270384138997;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.510513589 UTC

[section ""cstring" . Control.Applicative.$tcWrappedArrow3_bytes" {
     Control.Applicative.$tcWrappedArrow3_bytes:
         I8[] [87,114,97,112,112,101,100,65,114,114,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.511088031 UTC

[section ""data" . Control.Applicative.$tcWrappedArrow2_closure" {
     Control.Applicative.$tcWrappedArrow2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tcWrappedArrow3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.511629011 UTC

[section ""data" . Control.Applicative.$tcWrappedArrow_closure" {
     Control.Applicative.$tcWrappedArrow_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tcWrappedArrow2_closure+1;
         const Control.Applicative.$tcWrappedArrow1_closure+4;
         const 17995829375472255965;
         const 6668242383287740398;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.512198642 UTC

[section ""data" . $krep10_rbSvD_closure" {
     $krep10_rbSvD_closure:
         const :_con_info;
         const $krep_rbSvt_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.512726511 UTC

[section ""data" . $krep11_rbSvE_closure" {
     $krep11_rbSvE_closure:
         const :_con_info;
         const $krep1_rbSvu_closure+2;
         const $krep10_rbSvD_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.5132872 UTC

[section ""data" . $krep12_rbSvF_closure" {
     $krep12_rbSvF_closure:
         const :_con_info;
         const $krep2_rbSvv_closure+2;
         const $krep11_rbSvE_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.513822317 UTC

[section ""data" . $krep13_rbSvG_closure" {
     $krep13_rbSvG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Applicative.$tcWrappedArrow_closure+1;
         const $krep12_rbSvF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.514424136 UTC

[section ""data" . Control.Applicative.$tc'WrapArrow1_closure" {
     Control.Applicative.$tc'WrapArrow1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rbSvz_closure+3;
         const $krep13_rbSvG_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.51495871 UTC

[section ""cstring" . Control.Applicative.$tc'WrapArrow3_bytes" {
     Control.Applicative.$tc'WrapArrow3_bytes:
         I8[] [39,87,114,97,112,65,114,114,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.515490831 UTC

[section ""data" . Control.Applicative.$tc'WrapArrow2_closure" {
     Control.Applicative.$tc'WrapArrow2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tc'WrapArrow3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.516110606 UTC

[section ""data" . Control.Applicative.$tc'WrapArrow_closure" {
     Control.Applicative.$tc'WrapArrow_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tc'WrapArrow2_closure+1;
         const Control.Applicative.$tc'WrapArrow1_closure+4;
         const 4796259816778499037;
         const 13482613273239263357;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.516704677 UTC

[section ""data" . Control.Applicative.$tcZipList1_closure" {
     Control.Applicative.$tcZipList1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$fReadZipList11_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.517749709 UTC

[section ""data" . Control.Applicative.$tcZipList_closure" {
     Control.Applicative.$tcZipList_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tcZipList1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 11311650752326360483;
         const 5534599578149162946;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.518351038 UTC

[section ""data" . $krep14_rbSvH_closure" {
     $krep14_rbSvH_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Applicative.$tcZipList_closure+1;
         const $krep3_rbSvw_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.518896334 UTC

[section ""data" . Control.Applicative.$tc'ZipList1_closure" {
     Control.Applicative.$tc'ZipList1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rbSvx_closure+1;
         const $krep14_rbSvH_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.519483307 UTC

[section ""cstring" . Control.Applicative.$tc'ZipList3_bytes" {
     Control.Applicative.$tc'ZipList3_bytes:
         I8[] [39,90,105,112,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.520004724 UTC

[section ""data" . Control.Applicative.$tc'ZipList2_closure" {
     Control.Applicative.$tc'ZipList2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tc'ZipList3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.520569356 UTC

[section ""data" . Control.Applicative.$tc'ZipList_closure" {
     Control.Applicative.$tc'ZipList_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tc'ZipList2_closure+1;
         const Control.Applicative.$tc'ZipList1_closure+4;
         const 15353069281551614305;
         const 7665927634319452478;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.521174595 UTC

[section ""relreadonly" . SbSVf_srt" {
     SbSVf_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Control.Applicative.$fReadZipList2_closure;
         const GHC.Read.readField_closure;
         const Control.Applicative.$fReadZipList6_closure;
         const Control.Applicative.$fReadZipList_lexeme_closure;
         const Control.Applicative.$fReadZipList_lexeme1_closure;
         const GHC.Read.list3_closure;
         const Control.Applicative.$fReadZipList1_closure;
         const Control.Applicative.$fReadZipList_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Control.Applicative.$fReadZipList_$creadListPrec_closure;
         const Control.Applicative.$fReadZipList_$creadList_closure;
         const Control.Applicative.$fReadZipList_closure;
         const Control.Applicative.$fReadZipList3_closure;
         const Control.Applicative.$fShowZipList_$cshow_closure;
         const Control.Applicative.$fShowZipList_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.521878371 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:45.522936791 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedMonad1_closure" {
     Control.Applicative.$fFunctorWrappedMonad1_closure:
         const Control.Applicative.$fFunctorWrappedMonad1_info;
 },
 lvl_sbSvM_entry() //  [R1]
         { info_tbl: [(cbT4K,
                       label: lvl_sbSvM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT4K: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbT4L; else goto cbT4M;
       cbT4L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT4M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSvO_entry() //  [R1]
         { info_tbl: [(cbT4S,
                       label: sat_sbSvO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT4S: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fFunctorWrappedMonad1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbT4V,
                       label: Control.Applicative.$fFunctorWrappedMonad1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT4V: // global
           _sbSvL::P64 = R4;
           _sbSvK::P64 = R3;
           _sbSvJ::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbT4W; else goto cbT4X;
       cbT4X: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbT4Z; else goto cbT4Y;
       cbT4Z: // global
           HpAlloc = 48;
           goto cbT4W;
       cbT4W: // global
           R4 = _sbSvL::P64;
           R3 = _sbSvK::P64;
           R2 = _sbSvJ::P64;
           R1 = Control.Applicative.$fFunctorWrappedMonad1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbT4Y: // global
           I64[Hp - 40] = lvl_sbSvM_info;
           P64[Hp - 24] = _sbSvJ::P64;
           P64[Hp - 16] = _sbSvK::P64;
           I64[Hp - 8] = sat_sbSvO_info;
           P64[Hp] = Hp - 40;
           R2 = _sbSvJ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSvL::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.524738445 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedMonad_closure" {
     Control.Applicative.$fFunctorWrappedMonad_closure:
         const Control.Applicative.$fFunctorWrappedMonad_info;
 },
 sat_sbSvT_entry() //  [R1, R2, R3]
         { info_tbl: [(cbT59,
                       label: sat_sbSvT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT59: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fFunctorWrappedMonad1_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSvS_entry() //  [R1, R2, R3]
         { info_tbl: [(cbT5h,
                       label: sat_sbSvS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT5h: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.liftM_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fFunctorWrappedMonad_entry() //  [R2]
         { info_tbl: [(cbT5l,
                       label: Control.Applicative.$fFunctorWrappedMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT5l: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbT5p; else goto cbT5o;
       cbT5p: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Applicative.$fFunctorWrappedMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbT5o: // global
           I64[Hp - 48] = sat_sbSvT_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sbSvS_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.526172892 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedMonad3_closure" {
     Control.Applicative.$fApplicativeWrappedMonad3_closure:
         const Control.Applicative.$fApplicativeWrappedMonad3_info;
 },
 Control.Applicative.$fApplicativeWrappedMonad3_entry() //  [R2, R3]
         { info_tbl: [(cbT5w,
                       label: Control.Applicative.$fApplicativeWrappedMonad3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT5w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbT5x; else goto cbT5y;
       cbT5x: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedMonad3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbT5y: // global
           I64[Sp - 16] = block_cbT5u_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbT5u() //  [R1]
         { info_tbl: [(cbT5u,
                       label: block_cbT5u_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT5u: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.528673549 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedMonad2_closure" {
     Control.Applicative.$fApplicativeWrappedMonad2_closure:
         const Control.Applicative.$fApplicativeWrappedMonad2_info;
 },
 lvl_sbSw0_entry() //  [R1]
         { info_tbl: [(cbT5O,
                       label: lvl_sbSw0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT5O: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbT5P; else goto cbT5Q;
       cbT5P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT5Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSw2_entry() //  [R1]
         { info_tbl: [(cbT5W,
                       label: sat_sbSw2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT5W: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSw3_entry() //  [R1]
         { info_tbl: [(cbT5Z,
                       label: sat_sbSw3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT5Z: // global
           _sbSw3::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbT60; else goto cbT61;
       cbT61: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbT63; else goto cbT62;
       cbT63: // global
           HpAlloc = 40;
           goto cbT60;
       cbT60: // global
           R1 = _sbSw3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT62: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSw3::P64;
           _sbSvX::P64 = P64[_sbSw3::P64 + 16];
           _sbSvY::P64 = P64[_sbSw3::P64 + 24];
           I64[Hp - 32] = lvl_sbSw0_info;
           P64[Hp - 16] = _sbSvX::P64;
           I64[Hp - 8] = sat_sbSw2_info;
           P64[Hp] = Hp - 32;
           R2 = _sbSvX::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbSvY::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeWrappedMonad2_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbT64,
                       label: Control.Applicative.$fApplicativeWrappedMonad2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT64: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbT68; else goto cbT67;
       cbT68: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedMonad2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbT67: // global
           I64[Hp - 24] = sat_sbSw3_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R4 = R4;
           R3 = Hp - 24;
           R2 = R2;
           call GHC.Base.ap_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.531326504 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedMonad1_closure" {
     Control.Applicative.$fApplicativeWrappedMonad1_closure:
         const Control.Applicative.$fApplicativeWrappedMonad1_info;
 },
 lvl_sbSw8_entry() //  [R1]
         { info_tbl: [(cbT6m,
                       label: lvl_sbSw8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT6m: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbT6n; else goto cbT6o;
       cbT6n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT6o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSwa_entry() //  [R1]
         { info_tbl: [(cbT6u,
                       label: sat_sbSwa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT6u: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwb_entry() //  [R1, R2]
         { info_tbl: [(cbT6x,
                       label: sat_sbSwb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT6x: // global
           _sbSw7::P64 = R2;
           _sbSwb::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbT6y; else goto cbT6z;
       cbT6z: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbT6B; else goto cbT6A;
       cbT6B: // global
           HpAlloc = 48;
           goto cbT6y;
       cbT6y: // global
           R2 = _sbSw7::P64;
           R1 = _sbSwb::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbT6A: // global
           _sbSw4::P64 = P64[_sbSwb::P64 + 7];
           _sbSw6::P64 = P64[_sbSwb::P64 + 15];
           I64[Hp - 40] = lvl_sbSw8_info;
           P64[Hp - 24] = _sbSw4::P64;
           P64[Hp - 16] = _sbSw7::P64;
           I64[Hp - 8] = sat_sbSwa_info;
           P64[Hp] = Hp - 40;
           R2 = _sbSw4::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSw6::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fApplicativeWrappedMonad1_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbT6C,
                       label: Control.Applicative.$fApplicativeWrappedMonad1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT6C: // global
           _sbSw6::P64 = R4;
           _sbSw5::P64 = R3;
           _sbSw4::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbT6D; else goto cbT6E;
       cbT6E: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbT6G; else goto cbT6F;
       cbT6G: // global
           HpAlloc = 24;
           goto cbT6D;
       cbT6D: // global
           R4 = _sbSw6::P64;
           R3 = _sbSw5::P64;
           R2 = _sbSw4::P64;
           R1 = Control.Applicative.$fApplicativeWrappedMonad1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbT6F: // global
           I64[Hp - 16] = sat_sbSwb_info;
           P64[Hp - 8] = _sbSw4::P64;
           P64[Hp] = _sbSw6::P64;
           R2 = _sbSw4::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSw5::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.533841792 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedMonad_closure" {
     Control.Applicative.$fApplicativeWrappedMonad_closure:
         const Control.Applicative.$fApplicativeWrappedMonad_info;
 },
 sat_sbSwn_entry() //  [R1, R2, R3]
         { info_tbl: [(cbT6Q,
                       label: sat_sbSwn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT6Q: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedMonad1_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwm_entry() //  [R1, R2, R3]
         { info_tbl: [(cbT6Y,
                       label: sat_sbSwm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT6Y: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedMonad2_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwl_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbT76,
                       label: sat_sbSwl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT76: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.liftM2_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwh_entry() //  [R1, R2, R3]
         { info_tbl: [(cbT7e,
                       label: sat_sbSwh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT7e: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.ap_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwe_entry() //  [R1, R2]
         { info_tbl: [(cbT7m,
                       label: sat_sbSwe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT7m: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fApplicativeWrappedMonad3_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwd_entry() //  [R1]
         { info_tbl: [(cbT7t,
                       label: sat_sbSwd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT7t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbT7u; else goto cbT7v;
       cbT7u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT7v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fFunctorWrappedMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeWrappedMonad_entry() //  [R2]
         { info_tbl: [(cbT7x,
                       label: Control.Applicative.$fApplicativeWrappedMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT7x: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cbT7B; else goto cbT7A;
       cbT7B: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbT7A: // global
           I64[Hp - 152] = sat_sbSwn_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbSwm_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbSwl_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbSwh_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbSwe_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbSwd_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 87;
           P64[Hp - 24] = Hp - 102;
           P64[Hp - 16] = Hp - 117;
           P64[Hp - 8] = Hp - 134;
           P64[Hp] = Hp - 150;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.536017958 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_closure" {
     Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_closure:
         const Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_info;
 },
 sat_sbSwp_entry() //  [R1]
         { info_tbl: [(cbT7K,
                       label: sat_sbSwp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT7K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbT7L; else goto cbT7M;
       cbT7L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT7M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_entry() //  [R2]
         { info_tbl: [(cbT7N,
                       label: Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT7N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbT7R; else goto cbT7Q;
       cbT7R: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbT7Q: // global
           I64[Hp - 16] = sat_sbSwp_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Applicative.$fApplicativeWrappedMonad_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.538177834 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedMonad_$csome_closure" {
     Control.Applicative.$fAlternativeWrappedMonad_$csome_closure:
         const Control.Applicative.$fAlternativeWrappedMonad_$csome_info;
 },
 sat_sbSww_entry() //  [R1]
         { info_tbl: [(cbT8b,
                       label: sat_sbSww_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT8b: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbT8c; else goto cbT8d;
       cbT8c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT8d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbT89_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbT89() //  [R1]
         { info_tbl: [(cbT89,
                       label: block_cbT89_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT89: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 m2_sbSwt_entry() //  [R1]
         { info_tbl: [(cbT8h,
                       label: m2_sbSwt_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT8h: // global
           _sbSwt::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbT8i; else goto cbT8j;
       cbT8j: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbT8l; else goto cbT8k;
       cbT8l: // global
           HpAlloc = 24;
           goto cbT8i;
       cbT8i: // global
           R1 = _sbSwt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT8k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSwt::P64;
           _sbSwq::P64 = P64[_sbSwt::P64 + 16];
           _sbSws::P64 = P64[_sbSwt::P64 + 24];
           _sbSwu::P64 = P64[_sbSwt::P64 + 32];
           I64[Hp - 16] = sat_sbSww_info;
           P64[Hp] = _sbSws::P64;
           R2 = _sbSwq::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbSwu::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call GHC.Base.mplus_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbSwA_entry() //  [R1, R2]
         { info_tbl: [(cbT8A,
                       label: sat_sbSwA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT8A: // global
           _sbSwy::P64 = R2;
           _sbSwA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbT8B; else goto cbT8C;
       cbT8C: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbT8E; else goto cbT8D;
       cbT8E: // global
           HpAlloc = 24;
           goto cbT8B;
       cbT8B: // global
           R2 = _sbSwy::P64;
           R1 = _sbSwA::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbT8D: // global
           _sbSws::P64 = P64[_sbSwA::P64 + 7];
           _sbSwx::P64 = P64[_sbSwA::P64 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sbSwx::P64;
           P64[Hp] = _sbSwy::P64;
           R2 = _sbSws::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbSwB_entry() //  [R1, R2]
         { info_tbl: [(cbT8F,
                       label: sat_sbSwB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT8F: // global
           _sbSwx::P64 = R2;
           _sbSwB::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbT8G; else goto cbT8H;
       cbT8H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbT8J; else goto cbT8I;
       cbT8J: // global
           HpAlloc = 24;
           goto cbT8G;
       cbT8G: // global
           R2 = _sbSwx::P64;
           R1 = _sbSwB::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbT8I: // global
           _sbSws::P64 = P64[_sbSwB::P64 + 7];
           _sbSwt::P64 = P64[_sbSwB::P64 + 15];
           I64[Hp - 16] = sat_sbSwA_info;
           P64[Hp - 8] = _sbSws::P64;
           P64[Hp] = _sbSwx::P64;
           R2 = _sbSws::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSwt::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 some_v_sbSwu_entry() //  [R1]
         { info_tbl: [(cbT8K,
                       label: some_v_sbSwu_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT8K: // global
           _sbSwu::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbT8L; else goto cbT8M;
       cbT8M: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbT8O; else goto cbT8N;
       cbT8O: // global
           HpAlloc = 24;
           goto cbT8L;
       cbT8L: // global
           R1 = _sbSwu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT8N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSwu::P64;
           _sbSwr::P64 = P64[_sbSwu::P64 + 16];
           _sbSws::P64 = P64[_sbSwu::P64 + 24];
           _sbSwt::P64 = P64[_sbSwu::P64 + 32];
           I64[Hp - 16] = sat_sbSwB_info;
           P64[Hp - 8] = _sbSws::P64;
           P64[Hp] = _sbSwt::P64;
           R2 = _sbSws::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbSwr::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedMonad_$csome_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(cbT8P,
                       label: Control.Applicative.$fAlternativeWrappedMonad_$csome_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT8P: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbT8Q; else goto cbT8R;
       cbT8Q: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedMonad_$csome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbT8R: // global
           I64[Sp - 24] = block_cbT7W_info;
           _sbSwq::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _sbSwq::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbT7W() //  [R1]
         { info_tbl: [(cbT7W,
                       label: block_cbT7W_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT7W: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbT8U; else goto cbT8T;
       cbT8U: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbT8T: // global
           I64[Hp - 72] = m2_sbSwt_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           _cbT81::P64 = Hp - 32;
           P64[Hp - 40] = _cbT81::P64;
           I64[Hp - 32] = some_v_sbSwu_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 72;
           R1 = _cbT81::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.542234883 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedMonad_$cmany_closure" {
     Control.Applicative.$fAlternativeWrappedMonad_$cmany_closure:
         const Control.Applicative.$fAlternativeWrappedMonad_$cmany_info;
 },
 $dApplicative_sbSwF_entry() //  [R1]
         { info_tbl: [(cbT97,
                       label: $dApplicative_sbSwF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT97: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbT98; else goto cbT99;
       cbT98: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT99: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSwN_entry() //  [R1]
         { info_tbl: [(cbT9g,
                       label: sat_sbSwN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT9g: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbT9h; else goto cbT9i;
       cbT9h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT9i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbT9e_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbT9e() //  [R1]
         { info_tbl: [(cbT9e,
                       label: block_cbT9e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT9e: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSwJ_entry() //  [R1, R2]
         { info_tbl: [(cbT9B,
                       label: sat_sbSwJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT9B: // global
           _sbSwH::P64 = R2;
           _sbSwJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbT9C; else goto cbT9D;
       cbT9D: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbT9F; else goto cbT9E;
       cbT9F: // global
           HpAlloc = 24;
           goto cbT9C;
       cbT9C: // global
           R2 = _sbSwH::P64;
           R1 = _sbSwJ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbT9E: // global
           _sbSwF::P64 = P64[_sbSwJ::P64 + 7];
           _sbSwG::P64 = P64[_sbSwJ::P64 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sbSwG::P64;
           P64[Hp] = _sbSwH::P64;
           R2 = _sbSwF::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbSwK_entry() //  [R1, R2]
         { info_tbl: [(cbT9G,
                       label: sat_sbSwK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT9G: // global
           _sbSwG::P64 = R2;
           _sbSwK::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbT9H; else goto cbT9I;
       cbT9I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbT9K; else goto cbT9J;
       cbT9K: // global
           HpAlloc = 24;
           goto cbT9H;
       cbT9H: // global
           R2 = _sbSwG::P64;
           R1 = _sbSwK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbT9J: // global
           _sbSwE::P64 = P64[_sbSwK::P64 + 7];
           _sbSwF::P64 = P64[_sbSwK::P64 + 15];
           I64[Hp - 16] = sat_sbSwJ_info;
           P64[Hp - 8] = _sbSwF::P64;
           P64[Hp] = _sbSwG::P64;
           R2 = _sbSwF::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSwE::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbSwL_entry() //  [R1]
         { info_tbl: [(cbT9L,
                       label: sat_sbSwL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT9L: // global
           _sbSwL::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbT9M; else goto cbT9N;
       cbT9N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbT9P; else goto cbT9O;
       cbT9P: // global
           HpAlloc = 24;
           goto cbT9M;
       cbT9M: // global
           R1 = _sbSwL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT9O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSwL::P64;
           _sbSwD::P64 = P64[_sbSwL::P64 + 16];
           _sbSwE::P64 = P64[_sbSwL::P64 + 24];
           _sbSwF::P64 = P64[_sbSwL::P64 + 32];
           I64[Hp - 16] = sat_sbSwK_info;
           P64[Hp - 8] = _sbSwE::P64;
           P64[Hp] = _sbSwF::P64;
           R2 = _sbSwF::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbSwD::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 many_v_sbSwE_entry() //  [R1]
         { info_tbl: [(cbT9Q,
                       label: many_v_sbSwE_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT9Q: // global
           _sbSwE::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbT9R; else goto cbT9S;
       cbT9S: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbT9U; else goto cbT9T;
       cbT9U: // global
           HpAlloc = 88;
           goto cbT9R;
       cbT9R: // global
           R1 = _sbSwE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbT9T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSwE::P64;
           _sbSwC::P64 = P64[_sbSwE::P64 + 16];
           _sbSwD::P64 = P64[_sbSwE::P64 + 24];
           I64[Hp - 80] = $dApplicative_sbSwF_info;
           P64[Hp - 64] = _sbSwC::P64;
           I64[Hp - 56] = sat_sbSwN_info;
           _cbT93::P64 = Hp - 80;
           P64[Hp - 40] = _cbT93::P64;
           I64[Hp - 32] = sat_sbSwL_info;
           P64[Hp - 16] = _sbSwD::P64;
           P64[Hp - 8] = _sbSwE::P64;
           P64[Hp] = _cbT93::P64;
           R2 = _sbSwC::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call GHC.Base.mplus_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedMonad_$cmany_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(cbT9V,
                       label: Control.Applicative.$fAlternativeWrappedMonad_$cmany_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT9V: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbT9Z; else goto cbT9Y;
       cbT9Z: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedMonad_$cmany_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbT9Y: // global
           I64[Hp - 24] = many_v_sbSwE_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.54612592 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedMonad_closure" {
     Control.Applicative.$fAlternativeWrappedMonad_closure:
         const Control.Applicative.$fAlternativeWrappedMonad_info;
 },
 sat_sbSwV_entry() //  [R1, R2]
         { info_tbl: [(cbTa9,
                       label: sat_sbSwV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTa9: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fAlternativeWrappedMonad_$cmany_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwU_entry() //  [R1, R2]
         { info_tbl: [(cbTah,
                       label: sat_sbSwU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTah: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fAlternativeWrappedMonad_$csome_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwT_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTap,
                       label: sat_sbSwT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTap: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbTaq; else goto cbTar;
       cbTaq: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTar: // global
           _sbSwR::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSwR::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbSwQ_entry() //  [R1]
         { info_tbl: [(cbTaw,
                       label: sat_sbSwQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTaw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTax; else goto cbTay;
       cbTax: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTay: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSwP_entry() //  [R1]
         { info_tbl: [(cbTaD,
                       label: sat_sbSwP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTaD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTaE; else goto cbTaF;
       cbTaE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTaF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedMonad_entry() //  [R2]
         { info_tbl: [(cbTaH,
                       label: Control.Applicative.$fAlternativeWrappedMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTaH: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cbTaL; else goto cbTaK;
       cbTaL: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTaK: // global
           I64[Hp - 136] = sat_sbSwV_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbSwU_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbSwT_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbSwQ_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbSwP_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 102;
           P64[Hp - 8] = Hp - 119;
           P64[Hp] = Hp - 135;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.548391737 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedArrow2_closure" {
     Control.Applicative.$fFunctorWrappedArrow2_closure:
         const Control.Applicative.$fFunctorWrappedArrow2_info;
 },
 sat_sbSx0_entry() //  [R1]
         { info_tbl: [(cbTaU,
                       label: sat_sbSx0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTaU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbTaV; else goto cbTaW;
       cbTaV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTaW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fFunctorWrappedArrow2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbTaZ,
                       label: Control.Applicative.$fFunctorWrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTaZ: // global
           _sbSwY::P64 = R4;
           _sbSwX::P64 = R3;
           _sbSwW::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbTb0; else goto cbTb1;
       cbTb1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbTb3; else goto cbTb2;
       cbTb3: // global
           HpAlloc = 32;
           goto cbTb0;
       cbTb0: // global
           R4 = _sbSwY::P64;
           R3 = _sbSwX::P64;
           R2 = _sbSwW::P64;
           R1 = Control.Applicative.$fFunctorWrappedArrow2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTb2: // global
           I64[Hp - 24] = sat_sbSx0_info;
           P64[Hp - 8] = _sbSwW::P64;
           P64[Hp] = _sbSwX::P64;
           I64[Sp - 24] = block_cbTaX_info;
           R2 = _sbSwW::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbSwY::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbTaX() //  [R1]
         { info_tbl: [(cbTaX,
                       label: block_cbTaX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTaX: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.550216772 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedArrow1_closure" {
     Control.Applicative.$fFunctorWrappedArrow1_closure:
         const Control.Applicative.$fFunctorWrappedArrow1_info;
 },
 sat_sbSx6_entry() //  [R1]
         { info_tbl: [(cbTbk,
                       label: sat_sbSx6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTbk: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSx7_entry() //  [R1]
         { info_tbl: [(cbTbn,
                       label: sat_sbSx7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTbn: // global
           _sbSx7::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbTbo; else goto cbTbp;
       cbTbp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbTbr; else goto cbTbq;
       cbTbr: // global
           HpAlloc = 16;
           goto cbTbo;
       cbTbo: // global
           R1 = _sbSx7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTbq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSx7::P64;
           _sbSx1::P64 = P64[_sbSx7::P64 + 16];
           _sbSx2::P64 = P64[_sbSx7::P64 + 24];
           I64[Hp - 8] = sat_sbSx6_info;
           P64[Hp] = _sbSx2::P64;
           R2 = _sbSx1::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fFunctorWrappedArrow1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbTbu,
                       label: Control.Applicative.$fFunctorWrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTbu: // global
           _sbSx3::P64 = R4;
           _sbSx2::P64 = R3;
           _sbSx1::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbTbv; else goto cbTbw;
       cbTbw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbTby; else goto cbTbx;
       cbTby: // global
           HpAlloc = 32;
           goto cbTbv;
       cbTbv: // global
           R4 = _sbSx3::P64;
           R3 = _sbSx2::P64;
           R2 = _sbSx1::P64;
           R1 = Control.Applicative.$fFunctorWrappedArrow1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTbx: // global
           I64[Hp - 24] = sat_sbSx7_info;
           P64[Hp - 8] = _sbSx1::P64;
           P64[Hp] = _sbSx2::P64;
           I64[Sp - 24] = block_cbTbs_info;
           R2 = _sbSx1::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbSx3::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbTbs() //  [R1]
         { info_tbl: [(cbTbs,
                       label: block_cbTbs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTbs: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.552094803 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedArrow_closure" {
     Control.Applicative.$fFunctorWrappedArrow_closure:
         const Control.Applicative.$fFunctorWrappedArrow_info;
 },
 sat_sbSxa_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTbL,
                       label: sat_sbSxa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTbL: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fFunctorWrappedArrow1_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSx9_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTbT,
                       label: sat_sbSx9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTbT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fFunctorWrappedArrow2_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fFunctorWrappedArrow_entry() //  [R2]
         { info_tbl: [(cbTbX,
                       label: Control.Applicative.$fFunctorWrappedArrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTbX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbTc1; else goto cbTc0;
       cbTc1: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Applicative.$fFunctorWrappedArrow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTc0: // global
           I64[Hp - 48] = sat_sbSxa_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sbSx9_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.554006935 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow2_closure" {
     Control.Applicative.$fAlternativeWrappedArrow2_closure:
         const Control.Applicative.$fAlternativeWrappedArrow2_info;
 },
 sat_sbSxi_entry() //  [R1]
         { info_tbl: [(cbTca,
                       label: sat_sbSxi_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTca: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbTcb; else goto cbTcc;
       cbTcb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTcc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Arrow.&&&_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbSxg_entry() //  [R1, R2]
         { info_tbl: [(cbTcm,
                       label: sat_sbSxg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTcm: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Tuple.uncurry_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSxh_entry() //  [R1]
         { info_tbl: [(cbTcp,
                       label: sat_sbSxh_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTcp: // global
           _sbSxh::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbTcq; else goto cbTcr;
       cbTcr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbTct; else goto cbTcs;
       cbTct: // global
           HpAlloc = 16;
           goto cbTcq;
       cbTcq: // global
           R1 = _sbSxh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTcs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSxh::P64;
           _sbSxb::P64 = P64[_sbSxh::P64 + 16];
           _sbSxc::P64 = P64[_sbSxh::P64 + 24];
           I64[Hp - 8] = sat_sbSxg_info;
           P64[Hp] = _sbSxc::P64;
           R2 = _sbSxb::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow2_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cbTcw,
                       label: Control.Applicative.$fAlternativeWrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTcw: // global
           _sbSxe::P64 = R5;
           _sbSxd::P64 = R4;
           _sbSxc::P64 = R3;
           _sbSxb::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbTcx; else goto cbTcy;
       cbTcy: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbTcA; else goto cbTcz;
       cbTcA: // global
           HpAlloc = 72;
           goto cbTcx;
       cbTcx: // global
           R5 = _sbSxe::P64;
           R4 = _sbSxd::P64;
           R3 = _sbSxc::P64;
           R2 = _sbSxb::P64;
           R1 = Control.Applicative.$fAlternativeWrappedArrow2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTcz: // global
           I64[Hp - 64] = sat_sbSxi_info;
           P64[Hp - 48] = _sbSxb::P64;
           P64[Hp - 40] = _sbSxd::P64;
           P64[Hp - 32] = _sbSxe::P64;
           I64[Hp - 24] = sat_sbSxh_info;
           P64[Hp - 8] = _sbSxb::P64;
           P64[Hp] = _sbSxc::P64;
           I64[Sp - 24] = block_cbTcu_info;
           R2 = _sbSxb::P64;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbTcu() //  [R1]
         { info_tbl: [(cbTcu,
                       label: block_cbTcu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTcu: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbTc6::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbTc6::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.556154727 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow5_closure" {
     Control.Applicative.$fApplicativeWrappedArrow5_closure:
         const Control.Applicative.$fApplicativeWrappedArrow5_info;
 },
 sat_sbSxm_entry() //  [R1]
         { info_tbl: [(cbTcN,
                       label: sat_sbSxm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTcN: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fApplicativeWrappedArrow5_entry() //  [R2, R3]
         { info_tbl: [(cbTcQ,
                       label: Control.Applicative.$fApplicativeWrappedArrow5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTcQ: // global
           _sbSxk::P64 = R3;
           _sbSxj::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbTcR; else goto cbTcS;
       cbTcS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbTcU; else goto cbTcT;
       cbTcU: // global
           HpAlloc = 16;
           goto cbTcR;
       cbTcR: // global
           R3 = _sbSxk::P64;
           R2 = _sbSxj::P64;
           R1 = Control.Applicative.$fApplicativeWrappedArrow5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTcT: // global
           I64[Hp - 8] = sat_sbSxm_info;
           P64[Hp] = _sbSxk::P64;
           R2 = _sbSxj::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Arrow.arr_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.557343517 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow4_closure" {
     Control.Applicative.$fApplicativeWrappedArrow4_closure:
         const Control.Applicative.$fApplicativeWrappedArrow4_info;
 },
 Control.Applicative.$fApplicativeWrappedArrow4_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbTcZ,
                       label: Control.Applicative.$fApplicativeWrappedArrow4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTcZ: // global
           R5 = R4;
           R4 = R3;
           R3 = GHC.Base.breakpoint_closure+1;
           R2 = R2;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.558219227 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow3_closure" {
     Control.Applicative.$fApplicativeWrappedArrow3_closure:
         const Control.Applicative.$fApplicativeWrappedArrow3_info;
 },
 Control.Applicative.$fApplicativeWrappedArrow3_entry() //  [R3]
         { info_tbl: [(cbTd6,
                       label: Control.Applicative.$fApplicativeWrappedArrow3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTd6: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.559440442 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow2_closure" {
     Control.Applicative.$fApplicativeWrappedArrow2_closure:
         const Control.Applicative.$fApplicativeWrappedArrow2_info;
 },
 sat_sbSxu_entry() //  [R1]
         { info_tbl: [(cbTdl,
                       label: sat_sbSxu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTdl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbTdm; else goto cbTdn;
       cbTdm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTdn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Applicative.$fApplicativeWrappedArrow3_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSxv_entry() //  [R1]
         { info_tbl: [(cbTdq,
                       label: sat_sbSxv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTdq: // global
           _sbSxv::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbTdr; else goto cbTds;
       cbTds: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTdu; else goto cbTdt;
       cbTdu: // global
           HpAlloc = 24;
           goto cbTdr;
       cbTdr: // global
           R1 = _sbSxv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTdt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSxv::P64;
           _sbSxq::P64 = P64[_sbSxv::P64 + 16];
           _sbSxr::P64 = P64[_sbSxv::P64 + 24];
           I64[Hp - 16] = sat_sbSxu_info;
           P64[Hp] = _sbSxq::P64;
           I64[Sp - 40] = block_cbTdo_info;
           R2 = _sbSxq::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbSxr::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbTdo() //  [R1]
         { info_tbl: [(cbTdo,
                       label: block_cbTdo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTdo: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeWrappedArrow2_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbTdy,
                       label: Control.Applicative.$fApplicativeWrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTdy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbTdC; else goto cbTdB;
       cbTdC: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedArrow2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTdB: // global
           I64[Hp - 24] = sat_sbSxv_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R5 = R4;
           R4 = Hp - 24;
           R3 = GHC.Base.breakpoint_closure+1;
           R2 = R2;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.561127466 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow1_closure" {
     Control.Applicative.$fApplicativeWrappedArrow1_closure:
         const Control.Applicative.$fApplicativeWrappedArrow1_info;
 },
 Control.Applicative.$fApplicativeWrappedArrow1_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbTdH,
                       label: Control.Applicative.$fApplicativeWrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTdH: // global
           R5 = R4;
           R4 = R3;
           R3 = GHC.Base.const_closure+2;
           R2 = R2;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.562919348 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow_closure" {
     Control.Applicative.$fApplicativeWrappedArrow_closure:
         const Control.Applicative.$fApplicativeWrappedArrow_info;
 },
 sat_sbSxD_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTdT,
                       label: sat_sbSxD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTdT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedArrow1_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSxC_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTe1,
                       label: sat_sbSxC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTe1: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedArrow2_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSxB_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbTe9,
                       label: sat_sbSxB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTe9: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSxA_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTeh,
                       label: sat_sbSxA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTeh: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedArrow4_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSxz_entry() //  [R1, R2]
         { info_tbl: [(cbTep,
                       label: sat_sbSxz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTep: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fApplicativeWrappedArrow5_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSxy_entry() //  [R1]
         { info_tbl: [(cbTew,
                       label: sat_sbSxy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTew: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTex; else goto cbTey;
       cbTex: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTey: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fFunctorWrappedArrow_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeWrappedArrow_entry() //  [R2]
         { info_tbl: [(cbTeA,
                       label: Control.Applicative.$fApplicativeWrappedArrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTeA: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cbTeE; else goto cbTeD;
       cbTeE: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedArrow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTeD: // global
           I64[Hp - 152] = sat_sbSxD_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbSxC_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbSxB_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbSxA_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbSxz_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbSxy_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 87;
           P64[Hp - 24] = Hp - 102;
           P64[Hp - 16] = Hp - 117;
           P64[Hp - 8] = Hp - 134;
           P64[Hp] = Hp - 150;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.56515823 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_closure" {
     Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_closure:
         const Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_info;
 },
 sat_sbSxG_entry() //  [R1]
         { info_tbl: [(cbTeN,
                       label: sat_sbSxG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTeN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTeO; else goto cbTeP;
       cbTeO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTeP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_entry() //  [R2,
                                                                            R3]
         { info_tbl: [(cbTeQ,
                       label: Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTeQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTeU; else goto cbTeT;
       cbTeU: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTeT: // global
           I64[Hp - 16] = sat_sbSxG_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Applicative.$fApplicativeWrappedArrow_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.566336693 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow1_closure" {
     Control.Applicative.$fAlternativeWrappedArrow1_closure:
         const Control.Applicative.$fAlternativeWrappedArrow1_info;
 },
 Control.Applicative.$fAlternativeWrappedArrow1_entry() //  []
         { info_tbl: [(cbTeZ,
                       label: Control.Applicative.$fAlternativeWrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTeZ: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.567823582 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow_$csome_closure" {
     Control.Applicative.$fAlternativeWrappedArrow_$csome_closure:
         const Control.Applicative.$fAlternativeWrappedArrow_$csome_info;
 },
 sat_sbSxN_entry() //  [R1]
         { info_tbl: [(cbTfm,
                       label: sat_sbSxN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTfm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbTfn; else goto cbTfo;
       cbTfn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTfo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Applicative.$fAlternativeWrappedArrow1_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSxO_entry() //  [R1]
         { info_tbl: [(cbTfp,
                       label: sat_sbSxO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTfp: // global
           _sbSxO::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbTfq; else goto cbTfr;
       cbTfr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTft; else goto cbTfs;
       cbTft: // global
           HpAlloc = 24;
           goto cbTfq;
       cbTfq: // global
           R1 = _sbSxO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTfs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSxO::P64;
           _sbSxJ::P64 = P64[_sbSxO::P64 + 16];
           _sbSxL::P64 = P64[_sbSxO::P64 + 24];
           _sbSxM::P64 = P64[_sbSxO::P64 + 32];
           I64[Hp - 16] = sat_sbSxN_info;
           P64[Hp] = _sbSxM::P64;
           R2 = _sbSxJ::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbSxL::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call Control.Arrow.<+>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 some_v_sbSxL_entry() //  [R1]
         { info_tbl: [(cbTfu,
                       label: some_v_sbSxL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTfu: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbTfv; else goto cbTfw;
       cbTfv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTfw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cbTfa_info;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = R1;
           Sp = Sp - 48;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbTfa() //  [R1]
         { info_tbl: [(cbTfa,
                       label: block_cbTfa_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTfa: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbTfz; else goto cbTfy;
       cbTfz: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbTfy: // global
           I64[Hp - 32] = sat_sbSxO_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R5 = Hp - 32;
           R4 = P64[Sp + 16];
           R3 = GHC.Types.:_closure+2;
           R2 = R1;
           Sp = Sp + 32;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow_$csome_entry() //  [R2,
                                                                   R3, R4]
         { info_tbl: [(cbTfA,
                       label: Control.Applicative.$fAlternativeWrappedArrow_$csome_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTfA: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbTfE; else goto cbTfD;
       cbTfE: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedArrow_$csome_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTfD: // global
           I64[Hp - 32] = some_v_sbSxL_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.570571926 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow_$cmany_closure" {
     Control.Applicative.$fAlternativeWrappedArrow_$cmany_closure:
         const Control.Applicative.$fAlternativeWrappedArrow_$cmany_info;
 },
 $dApplicative_sbSxT_entry() //  [R1]
         { info_tbl: [(cbTfR,
                       label: $dApplicative_sbSxT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTfR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTfS; else goto cbTfT;
       cbTfS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTfT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSxV_entry() //  [R1]
         { info_tbl: [(cbTfY,
                       label: sat_sbSxV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTfY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbTfZ; else goto cbTg0;
       cbTfZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTg0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Applicative.$fAlternativeWrappedArrow1_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSxU_entry() //  [R1]
         { info_tbl: [(cbTg5,
                       label: sat_sbSxU_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTg5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTg6; else goto cbTg7;
       cbTg6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTg7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 24];
           R4 = P64[R1 + 16];
           R3 = GHC.Types.:_closure+2;
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 many_v_sbSxS_entry() //  [R1]
         { info_tbl: [(cbTg8,
                       label: many_v_sbSxS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTg8: // global
           _sbSxS::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbTg9; else goto cbTga;
       cbTga: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbTgc; else goto cbTgb;
       cbTgc: // global
           HpAlloc = 88;
           goto cbTg9;
       cbTg9: // global
           R1 = _sbSxS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTgb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSxS::P64;
           _sbSxP::P64 = P64[_sbSxS::P64 + 16];
           _sbSxQ::P64 = P64[_sbSxS::P64 + 24];
           _sbSxR::P64 = P64[_sbSxS::P64 + 32];
           I64[Hp - 80] = $dApplicative_sbSxT_info;
           P64[Hp - 64] = _sbSxP::P64;
           I64[Hp - 56] = sat_sbSxV_info;
           _cbTfN::P64 = Hp - 80;
           P64[Hp - 40] = _cbTfN::P64;
           I64[Hp - 32] = sat_sbSxU_info;
           P64[Hp - 16] = _sbSxR::P64;
           P64[Hp - 8] = _sbSxS::P64;
           P64[Hp] = _cbTfN::P64;
           R2 = _sbSxQ::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call Control.Arrow.<+>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow_$cmany_entry() //  [R2,
                                                                   R3, R4]
         { info_tbl: [(cbTgd,
                       label: Control.Applicative.$fAlternativeWrappedArrow_$cmany_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTgd: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbTgh; else goto cbTgg;
       cbTgh: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedArrow_$cmany_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTgg: // global
           I64[Hp - 32] = many_v_sbSxS_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.573366049 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow_closure" {
     Control.Applicative.$fAlternativeWrappedArrow_closure:
         const Control.Applicative.$fAlternativeWrappedArrow_info;
 },
 sat_sbSy4_entry() //  [R1, R2]
         { info_tbl: [(cbTgr,
                       label: sat_sbSy4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTgr: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Applicative.$fAlternativeWrappedArrow_$cmany_entry(R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSy3_entry() //  [R1, R2]
         { info_tbl: [(cbTgz,
                       label: sat_sbSy3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTgz: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Applicative.$fAlternativeWrappedArrow_$csome_entry(R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSy2_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTgH,
                       label: sat_sbSy2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTgH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbTgI; else goto cbTgJ;
       cbTgI: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTgJ: // global
           _sbSy0::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSy0::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Control.Arrow.<+>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbSxZ_entry() //  [R1]
         { info_tbl: [(cbTgO,
                       label: sat_sbSxZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTgO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTgP; else goto cbTgQ;
       cbTgP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTgQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.zeroArrow_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSxY_entry() //  [R1]
         { info_tbl: [(cbTgV,
                       label: sat_sbSxY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTgV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTgW; else goto cbTgX;
       cbTgW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTgX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_entry(R3,
                                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow_entry() //  [R2, R3]
         { info_tbl: [(cbTgZ,
                       label: Control.Applicative.$fAlternativeWrappedArrow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTgZ: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cbTh3; else goto cbTh2;
       cbTh3: // global
           HpAlloc = 168;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedArrow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTh2: // global
           I64[Hp - 160] = sat_sbSy4_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sbSy3_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sbSy2_info;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_sbSxZ_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbSxY_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 96;
           P64[Hp - 16] = Hp - 110;
           P64[Hp - 8] = Hp - 135;
           P64[Hp] = Hp - 159;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.57588156 UTC

[section ""data" . Control.Applicative.$wunsafeDrop_closure" {
     Control.Applicative.$wunsafeDrop_closure:
         const Control.Applicative.$wunsafeDrop_info;
 },
 Control.Applicative.$wunsafeDrop_entry() //  [R2, R3]
         { info_tbl: [(cbThf,
                       label: Control.Applicative.$wunsafeDrop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbThf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbThg; else goto ubThu;
       cbThg: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$wunsafeDrop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ubThu: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cbTh5() args: 0, res: 0, upd: 0;
     }
 },
 _cbTh5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTh5: // global
           I64[Sp - 8] = block_cbTh8_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubThw; else goto cbTh9;
       ubThw: // global
           call _cbTh8(R1) args: 0, res: 0, upd: 0;
       cbTh9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTh8() //  [R1]
         { info_tbl: [(cbTh8,
                       label: block_cbTh8_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTh8: // global
           if (R1 & 7 == 1) goto cbThc; else goto cbThd;
       cbThc: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbThd: // global
           _sbSy9::P64 = P64[R1 + 14];
           _sbSya::I64 = I64[Sp + 8];
           if (_sbSya::I64 != 1) goto cbThq; else goto cbThr;
       cbThq: // global
           I64[Sp + 8] = _sbSya::I64 - 1;
           P64[Sp + 16] = _sbSy9::P64;
           Sp = Sp + 8;
           call _cbTh5() args: 0, res: 0, upd: 0;
       cbThr: // global
           R1 = _sbSy9::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.577851446 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList2_closure" {
     Control.Applicative.$fAlternativeZipList2_closure:
         const Control.Applicative.$fAlternativeZipList2_info;
 },
 sat_sbSyg_entry() //  [R1]
         { info_tbl: [(cbThJ,
                       label: sat_sbSyg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbThJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbThK; else goto cbThL;
       cbThK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbThL: // global
           I64[Sp - 16] = block_cbThH_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbThH() //  [R1]
         { info_tbl: [(cbThH,
                       label: block_cbThH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbThH: // global
           _sbSyd::P64 = P64[Sp + 8];
           if (%MO_S_Gt_W64(R1, 0)) goto cbThS; else goto cbThT;
       cbThS: // global
           R3 = _sbSyd::P64;
           R2 = R1;
           Sp = Sp + 16;
           call Control.Applicative.$wunsafeDrop_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       cbThT: // global
           R1 = _sbSyd::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fAlternativeZipList2_entry() //  [R2, R3]
         { info_tbl: [(cbThU,
                       label: Control.Applicative.$fAlternativeZipList2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbThU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbThY; else goto cbThX;
       cbThY: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeZipList2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbThX: // global
           I64[Hp - 24] = sat_sbSyg_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = R2;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.580146073 UTC

[section ""data" . Control.Applicative.$fGeneric1ZipList1_closure" {
     Control.Applicative.$fGeneric1ZipList1_closure:
         const Control.Applicative.$fGeneric1ZipList1_info;
 },
 Control.Applicative.$fGeneric1ZipList1_entry() //  [R2]
         { info_tbl: [(cbTi3,
                       label: Control.Applicative.$fGeneric1ZipList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTi3: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.58142115 UTC

[section ""data" . Control.Applicative.$fGeneric1ZipList2_closure" {
     Control.Applicative.$fGeneric1ZipList2_closure:
         const Control.Applicative.$fGeneric1ZipList2_info;
 },
 Control.Applicative.$fGeneric1ZipList2_entry() //  [R2]
         { info_tbl: [(cbTia,
                       label: Control.Applicative.$fGeneric1ZipList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTia: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.582428427 UTC

[section ""data" . Control.Applicative.$fGeneric1ZipList_closure" {
     Control.Applicative.$fGeneric1ZipList_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Control.Applicative.$fGeneric1ZipList2_closure+1;
         const Control.Applicative.$fGeneric1ZipList1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.583456196 UTC

[section ""data" . Control.Applicative.$fGenericZipList1_closure" {
     Control.Applicative.$fGenericZipList1_closure:
         const Control.Applicative.$fGenericZipList1_info;
 },
 Control.Applicative.$fGenericZipList1_entry() //  [R2]
         { info_tbl: [(cbTih,
                       label: Control.Applicative.$fGenericZipList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTih: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.584707193 UTC

[section ""data" . Control.Applicative.$fGenericZipList2_closure" {
     Control.Applicative.$fGenericZipList2_closure:
         const Control.Applicative.$fGenericZipList2_info;
 },
 Control.Applicative.$fGenericZipList2_entry() //  [R2]
         { info_tbl: [(cbTio,
                       label: Control.Applicative.$fGenericZipList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTio: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.585798253 UTC

[section ""data" . Control.Applicative.$fGenericZipList_closure" {
     Control.Applicative.$fGenericZipList_closure:
         const GHC.Generics.C:Generic_con_info;
         const Control.Applicative.$fGenericZipList2_closure+1;
         const Control.Applicative.$fGenericZipList1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.586727579 UTC

[section ""data" . Control.Applicative.$fFoldableZipList_closure" {
     Control.Applicative.$fFoldableZipList_closure:
         const Data.Foldable.C:Foldable_con_info;
         const Data.Foldable.$fFoldableNonEmpty_$cfold1_closure+2;
         const Data.Foldable.$fFoldable[]_$cfoldMap_closure+3;
         const GHC.Base.foldr_closure+3;
         const Data.Foldable.$fFoldable[]_$cfoldr'_closure+3;
         const GHC.List.foldl_closure+3;
         const GHC.List.foldl'_closure+3;
         const GHC.List.foldr1_closure+2;
         const GHC.List.foldl1_closure+2;
         const GHC.Base.id_closure+1;
         const GHC.List.null_closure+1;
         const GHC.List.length_closure+1;
         const GHC.List.elem_closure+3;
         const GHC.List.maximum_closure+2;
         const GHC.List.minimum_closure+2;
         const GHC.List.sum_closure+1;
         const GHC.List.product_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.587829367 UTC

[section ""data" . Control.Applicative.$fFunctorZipList_closure" {
     Control.Applicative.$fFunctorZipList_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.map_closure+2;
         const GHC.Base.$fFunctor[]_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.58981481 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList6_closure" {
     Control.Applicative.$fApplicativeZipList6_closure:
         const Control.Applicative.$fApplicativeZipList6_info;
 },
 sat_sbSyu_entry() //  [R1]
         { info_tbl: [(cbTiL,
                       label: sat_sbSyu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTiL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTiM; else goto cbTiN;
       cbTiM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTiN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fApplicativeZipList6_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeZipList6_entry() //  [R2, R3]
         { info_tbl: [(cbTiS,
                       label: Control.Applicative.$fApplicativeZipList6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTiS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbTiT; else goto cbTiU;
       cbTiT: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeZipList6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTiU: // global
           I64[Sp - 16] = block_cbTiv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubTje; else goto cbTiw;
       ubTje: // global
           call _cbTiv(R1) args: 0, res: 0, upd: 0;
       cbTiw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTiv() //  [R1]
         { info_tbl: [(cbTiv,
                       label: block_cbTiv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTiv: // global
           if (R1 & 7 == 1) goto ubTj9; else goto cbTiQ;
       ubTj9: // global
           Sp = Sp + 16;
           call _cbTj1() args: 0, res: 0, upd: 0;
       cbTiQ: // global
           I64[Sp - 8] = block_cbTiB_info;
           _sbSyo::P64 = P64[R1 + 6];
           _sbSyp::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbSyp::P64;
           P64[Sp + 8] = _sbSyo::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubTjb; else goto cbTiC;
       ubTjb: // global
           call _cbTiB(R1) args: 0, res: 0, upd: 0;
       cbTiC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTiB() //  [R1]
         { info_tbl: [(cbTiB,
                       label: block_cbTiB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTiB: // global
           if (R1 & 7 == 1) goto ubTja; else goto cbTj4;
       ubTja: // global
           Sp = Sp + 24;
           call _cbTj1() args: 0, res: 0, upd: 0;
       cbTj4: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbTj7; else goto cbTj6;
       cbTj7: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbTj6: // global
           _sbSyr::P64 = P64[R1 + 6];
           _sbSys::P64 = P64[R1 + 14];
           I64[Hp - 80] = sat_sbSyu_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _sbSys::P64;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sbSyr::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbTj1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTj1: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.593200083 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList5_closure" {
     Control.Applicative.$fApplicativeZipList5_closure:
         const Control.Applicative.$fApplicativeZipList5_info;
 },
 Control.Applicative.$fApplicativeZipList5_entry() //  [R2, R3]
         { info_tbl: [(cbTjj,
                       label: Control.Applicative.$fApplicativeZipList5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTjj: // global
           R3 = R3;
           R2 = R2;
           call Control.Applicative.$fApplicativeZipList6_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.595523839 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList4_closure" {
     Control.Applicative.$fApplicativeZipList4_closure:
         const Control.Applicative.$fApplicativeZipList4_info;
 },
 sat_sbSyF_entry() //  [R1]
         { info_tbl: [(cbTjG,
                       label: sat_sbSyF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTjG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTjH; else goto cbTjI;
       cbTjH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTjI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fApplicativeZipList4_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeZipList4_entry() //  [R2, R3]
         { info_tbl: [(cbTjN,
                       label: Control.Applicative.$fApplicativeZipList4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTjN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTjO; else goto cbTjP;
       cbTjO: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeZipList4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTjP: // global
           I64[Sp - 16] = block_cbTjq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubTk8; else goto cbTjr;
       ubTk8: // global
           call _cbTjq(R1) args: 0, res: 0, upd: 0;
       cbTjr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTjq() //  [R1]
         { info_tbl: [(cbTjq,
                       label: block_cbTjq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTjq: // global
           if (R1 & 7 == 1) goto ubTk3; else goto cbTjL;
       ubTk3: // global
           Sp = Sp + 16;
           call _cbTjW() args: 0, res: 0, upd: 0;
       cbTjL: // global
           I64[Sp] = block_cbTjw_info;
           _sbSyB::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbSyB::P64;
           if (R1 & 7 != 0) goto ubTk5; else goto cbTjx;
       ubTk5: // global
           call _cbTjw(R1) args: 0, res: 0, upd: 0;
       cbTjx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTjw() //  [R1]
         { info_tbl: [(cbTjw,
                       label: block_cbTjw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTjw: // global
           if (R1 & 7 == 1) goto ubTk4; else goto cbTjY;
       ubTk4: // global
           Sp = Sp + 16;
           call _cbTjW() args: 0, res: 0, upd: 0;
       cbTjY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbTk1; else goto cbTk0;
       cbTk1: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbTk0: // global
           _sbSyD::P64 = P64[R1 + 6];
           _sbSyE::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_sbSyF_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sbSyE::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sbSyD::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbTjW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTjW: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.598644982 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList3_closure" {
     Control.Applicative.$fApplicativeZipList3_closure:
         const Control.Applicative.$fApplicativeZipList3_info;
 },
 Control.Applicative.$fApplicativeZipList3_entry() //  [R2, R3]
         { info_tbl: [(cbTkd,
                       label: Control.Applicative.$fApplicativeZipList3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTkd: // global
           R3 = R3;
           R2 = R2;
           call Control.Applicative.$fApplicativeZipList4_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.600769587 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList2_closure" {
     Control.Applicative.$fApplicativeZipList2_closure:
         const Control.Applicative.$fApplicativeZipList2_info;
 },
 sat_sbSyQ_entry() //  [R1]
         { info_tbl: [(cbTkA,
                       label: sat_sbSyQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTkA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTkB; else goto cbTkC;
       cbTkB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTkC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fApplicativeZipList2_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeZipList2_entry() //  [R2, R3]
         { info_tbl: [(cbTkH,
                       label: Control.Applicative.$fApplicativeZipList2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTkH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbTkI; else goto cbTkJ;
       cbTkI: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeZipList2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTkJ: // global
           I64[Sp - 16] = block_cbTkk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubTl2; else goto cbTkl;
       ubTl2: // global
           call _cbTkk(R1) args: 0, res: 0, upd: 0;
       cbTkl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTkk() //  [R1]
         { info_tbl: [(cbTkk,
                       label: block_cbTkk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTkk: // global
           if (R1 & 7 == 1) goto ubTkX; else goto cbTkF;
       ubTkX: // global
           Sp = Sp + 16;
           call _cbTkQ() args: 0, res: 0, upd: 0;
       cbTkF: // global
           I64[Sp - 8] = block_cbTkq_info;
           _sbSyL::P64 = P64[R1 + 6];
           _sbSyM::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbSyM::P64;
           P64[Sp + 8] = _sbSyL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubTkZ; else goto cbTkr;
       ubTkZ: // global
           call _cbTkq(R1) args: 0, res: 0, upd: 0;
       cbTkr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTkq() //  [R1]
         { info_tbl: [(cbTkq,
                       label: block_cbTkq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTkq: // global
           if (R1 & 7 == 1) goto ubTkY; else goto cbTkS;
       ubTkY: // global
           Sp = Sp + 24;
           call _cbTkQ() args: 0, res: 0, upd: 0;
       cbTkS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbTkV; else goto cbTkU;
       cbTkV: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbTkU: // global
           _sbSyP::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_sbSyQ_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sbSyP::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbTkQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTkQ: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.603917901 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList1_closure" {
     Control.Applicative.$fApplicativeZipList1_closure:
         const Control.Applicative.$fApplicativeZipList1_info;
 },
 Control.Applicative.$fApplicativeZipList1_entry() //  [R2, R3]
         { info_tbl: [(cbTl7,
                       label: Control.Applicative.$fApplicativeZipList1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTl7: // global
           R3 = R3;
           R2 = R2;
           call Control.Applicative.$fApplicativeZipList2_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.605060214 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList_closure" {
     Control.Applicative.$fApplicativeZipList_closure:
         const GHC.Base.C:Applicative_con_info;
         const Control.Applicative.$fFunctorZipList_closure+1;
         const GHC.List.repeat_closure+1;
         const Control.Applicative.$fApplicativeZipList5_closure+2;
         const GHC.List.zipWith_closure+3;
         const Control.Applicative.$fApplicativeZipList3_closure+2;
         const Control.Applicative.$fApplicativeZipList1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.606094303 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList_xs_closure" {
     Control.Applicative.$fAlternativeZipList_xs_closure:
         const :_con_info;
         const GHC.Types.[]_closure+1;
         const Control.Applicative.$fAlternativeZipList_xs_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.608120083 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList1_closure" {
     Control.Applicative.$fAlternativeZipList1_closure:
         const Control.Applicative.$fAlternativeZipList1_info;
 },
 sat_sbSz2_entry() //  [R1]
         { info_tbl: [(cbTlu,
                       label: sat_sbSz2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTlu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTlv; else goto cbTlw;
       cbTlv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTlw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeZipList1_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeZipList1_entry() //  [R2, R3]
         { info_tbl: [(cbTlB,
                       label: Control.Applicative.$fAlternativeZipList1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTlB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbTlC; else goto cbTlD;
       cbTlC: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeZipList1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTlD: // global
           I64[Sp - 16] = block_cbTle_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubTlX; else goto cbTlf;
       ubTlX: // global
           call _cbTle(R1) args: 0, res: 0, upd: 0;
       cbTlf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTle() //  [R1]
         { info_tbl: [(cbTle,
                       label: block_cbTle_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTle: // global
           if (R1 & 7 == 1) goto ubTlS; else goto cbTlz;
       ubTlS: // global
           Sp = Sp + 16;
           call _cbTlK() args: 0, res: 0, upd: 0;
       cbTlz: // global
           I64[Sp - 8] = block_cbTlk_info;
           _sbSyW::P64 = P64[R1 + 6];
           _sbSyX::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbSyX::P64;
           P64[Sp + 8] = _sbSyW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubTlU; else goto cbTll;
       ubTlU: // global
           call _cbTlk(R1) args: 0, res: 0, upd: 0;
       cbTll: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTlk() //  [R1]
         { info_tbl: [(cbTlk,
                       label: block_cbTlk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTlk: // global
           if (R1 & 7 == 1) goto ubTlT; else goto cbTlN;
       ubTlT: // global
           Sp = Sp + 24;
           call _cbTlK() args: 0, res: 0, upd: 0;
       cbTlN: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbTlQ; else goto cbTlP;
       cbTlQ: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbTlP: // global
           _sbSyZ::P64 = P64[R1 + 6];
           _sbSz0::P64 = P64[R1 + 14];
           I64[Hp - 72] = sat_sbSz2_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _sbSz0::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sbSyZ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbTlK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTlK: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.611773839 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList_$csome_closure" {
     Control.Applicative.$fAlternativeZipList_$csome_closure:
         const Control.Applicative.$fAlternativeZipList_$csome_info;
 },
 sat_sbSz5_entry() //  [R1]
         { info_tbl: [(cbTma,
                       label: sat_sbSz5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTma: // global
           R3 = Control.Applicative.$fAlternativeZipList_xs_closure+2;
           R2 = P64[R1 + 16];
           call Control.Applicative.$fAlternativeZipList2_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 some_v_sbSz4_entry() //  [R1]
         { info_tbl: [(cbTmd,
                       label: some_v_sbSz4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTmd: // global
           _sbSz4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbTme; else goto cbTmf;
       cbTmf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTmh; else goto cbTmg;
       cbTmh: // global
           HpAlloc = 24;
           goto cbTme;
       cbTme: // global
           R1 = _sbSz4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTmg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSz4::P64;
           _sbSz3::P64 = P64[_sbSz4::P64 + 16];
           I64[Hp - 16] = sat_sbSz5_info;
           P64[Hp] = _sbSz4::P64;
           R3 = Hp - 16;
           R2 = _sbSz3::P64;
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeZipList1_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeZipList_$csome_entry() //  [R2]
         { info_tbl: [(cbTmi,
                       label: Control.Applicative.$fAlternativeZipList_$csome_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTmi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTmm; else goto cbTml;
       cbTmm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeZipList_$csome_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTml: // global
           I64[Hp - 16] = some_v_sbSz4_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.617429207 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList_$cmany_closure" {
     Control.Applicative.$fAlternativeZipList_$cmany_closure:
         const Control.Applicative.$fAlternativeZipList_$cmany_info;
 },
 many_v_sbSz7_entry() //  [R1]
         { info_tbl: [(cbTmx,
                       label: many_v_sbSz7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTmx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbTmy; else goto cbTmz;
       cbTmy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTmz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbTmv_info;
           R3 = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Applicative.$fAlternativeZipList1_entry(R3,
                                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbTmv() //  [R1]
         { info_tbl: [(cbTmv,
                       label: block_cbTmv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTmv: // global
           R3 = Control.Applicative.$fAlternativeZipList_xs_closure+2;
           R2 = R1;
           Sp = Sp + 8;
           call Control.Applicative.$fAlternativeZipList2_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeZipList_$cmany_entry() //  [R2]
         { info_tbl: [(cbTmD,
                       label: Control.Applicative.$fAlternativeZipList_$cmany_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTmD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTmH; else goto cbTmG;
       cbTmH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeZipList_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTmG: // global
           I64[Hp - 16] = many_v_sbSz7_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.619301657 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList_closure" {
     Control.Applicative.$fAlternativeZipList_closure:
         const GHC.Base.C:Alternative_con_info;
         const Control.Applicative.$fApplicativeZipList_closure+1;
         const GHC.Types.[]_closure+1;
         const Control.Applicative.$fAlternativeZipList2_closure+2;
         const Control.Applicative.$fAlternativeZipList_$csome_closure+1;
         const Control.Applicative.$fAlternativeZipList_$cmany_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.620144971 UTC

[section ""cstring" . Control.Applicative.$fReadZipList11_bytes" {
     Control.Applicative.$fReadZipList11_bytes:
         I8[] [90,105,112,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.621335948 UTC

[section ""data" . Control.Applicative.$fReadZipList10_closure" {
     Control.Applicative.$fReadZipList10_closure:
         const Control.Applicative.$fReadZipList10_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Applicative.$fReadZipList10_entry() //  [R1]
         { info_tbl: [(cbTmO,
                       label: Control.Applicative.$fReadZipList10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTmO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTmP; else goto cbTmQ;
       cbTmP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTmQ: // global
           (_cbTmL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbTmL::I64 == 0) goto cbTmN; else goto cbTmM;
       cbTmN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbTmM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbTmL::I64;
           R2 = Control.Applicative.$fReadZipList11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.622681773 UTC

[section ""data" . Control.Applicative.$fReadZipList_lexeme1_closure" {
     Control.Applicative.$fReadZipList_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Control.Applicative.$fReadZipList10_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.623498807 UTC

[section ""cstring" . Control.Applicative.$fReadZipList9_bytes" {
     Control.Applicative.$fReadZipList9_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.624520981 UTC

[section ""data" . Control.Applicative.$fReadZipList8_closure" {
     Control.Applicative.$fReadZipList8_closure:
         const Control.Applicative.$fReadZipList8_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Applicative.$fReadZipList8_entry() //  [R1]
         { info_tbl: [(cbTmX,
                       label: Control.Applicative.$fReadZipList8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTmX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTmY; else goto cbTmZ;
       cbTmY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTmZ: // global
           (_cbTmU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbTmU::I64 == 0) goto cbTmW; else goto cbTmV;
       cbTmW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbTmV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbTmU::I64;
           R2 = Control.Applicative.$fReadZipList9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.625856883 UTC

[section ""data" . Control.Applicative.$fReadZipList_lexeme_closure" {
     Control.Applicative.$fReadZipList_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const Control.Applicative.$fReadZipList8_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.62666655 UTC

[section ""cstring" . Control.Applicative.$fReadZipList7_bytes" {
     Control.Applicative.$fReadZipList7_bytes:
         I8[] [103,101,116,90,105,112,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.627634243 UTC

[section ""data" . Control.Applicative.$fReadZipList6_closure" {
     Control.Applicative.$fReadZipList6_closure:
         const Control.Applicative.$fReadZipList6_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Applicative.$fReadZipList6_entry() //  [R1]
         { info_tbl: [(cbTn6,
                       label: Control.Applicative.$fReadZipList6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTn6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTn7; else goto cbTn8;
       cbTn7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTn8: // global
           (_cbTn3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbTn3::I64 == 0) goto cbTn5; else goto cbTn4;
       cbTn5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbTn4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbTn3::I64;
           R2 = Control.Applicative.$fReadZipList7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.62901732 UTC

[section ""data" . Control.Applicative.$fReadZipList5_closure" {
     Control.Applicative.$fReadZipList5_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.63002154 UTC

[section ""cstring" . Control.Applicative.$fReadZipList4_bytes" {
     Control.Applicative.$fReadZipList4_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.631043451 UTC

[section ""data" . Control.Applicative.$fReadZipList3_closure" {
     Control.Applicative.$fReadZipList3_closure:
         const Control.Applicative.$fReadZipList3_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Applicative.$fReadZipList3_entry() //  [R1]
         { info_tbl: [(cbTnf,
                       label: Control.Applicative.$fReadZipList3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTnf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTng; else goto cbTnh;
       cbTng: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTnh: // global
           (_cbTnc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbTnc::I64 == 0) goto cbTne; else goto cbTnd;
       cbTne: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbTnd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbTnc::I64;
           R2 = Control.Applicative.$fReadZipList4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.632393948 UTC

[section ""data" . Control.Applicative.$fReadZipList2_closure" {
     Control.Applicative.$fReadZipList2_closure:
         const Text.Read.Lex.Punc_con_info;
         const Control.Applicative.$fReadZipList3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.635698648 UTC

[section ""data" . Control.Applicative.$fReadZipList1_closure" {
     Control.Applicative.$fReadZipList1_closure:
         const Control.Applicative.$fReadZipList1_info;
         const 0;
 },
 lvl_sbSza_entry() //  [R1]
         { info_tbl: [(cbTnq,
                       label: lvl_sbSza_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTnq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbTnr; else goto cbTns;
       cbTnr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTns: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readListPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_sbSzb_entry() //  [R1]
         { info_tbl: [(cbTny,
                       label: ds_sbSzb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTny: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzm_entry() //  [R1]
         { info_tbl: [(cbTo9,
                       label: sat_sbSzm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTo9: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzp_entry() //  [R1, R2]
         { info_tbl: [(cbTof,
                       label: sat_sbSzp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTof: // global
           _sbSzk::P64 = R2;
           _sbSzp::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cbTog; else goto cbToh;
       cbToh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbToj; else goto cbToi;
       cbToj: // global
           HpAlloc = 24;
           goto cbTog;
       cbTog: // global
           R2 = _sbSzk::P64;
           R1 = _sbSzp::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbToi: // global
           _sbSze::P64 = P64[_sbSzp::P64 + 7];
           I64[Hp - 16] = sat_sbSzm_info;
           P64[Hp - 8] = _sbSze::P64;
           P64[Hp] = _sbSzk::P64;
           I64[Sp - 8] = block_cbToc_info;
           R3 = Hp - 15;
           R2 = Control.Applicative.$fReadZipList2_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbToc() //  [R1]
         { info_tbl: [(cbToc,
                       label: block_cbToc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbToc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbTom; else goto cbTol;
       cbTom: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbTol: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzq_entry() //  [R1, R2]
         { info_tbl: [(cbTon,
                       label: sat_sbSzq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTon: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbTor; else goto cbToq;
       cbTor: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbToq: // global
           _sbSzb::P64 = P64[R1 + 7];
           _sbSze::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sbSzp_info;
           P64[Hp] = _sbSze::P64;
           R5 = Hp - 7;
           R4 = Control.Applicative.$fReadZipList5_closure+1;
           R3 = _sbSzb::P64;
           R2 = Control.Applicative.$fReadZipList6_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzt_entry() //  [R1, R2]
         { info_tbl: [(cbTov,
                       label: sat_sbSzt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTov: // global
           _sbSzi::P64 = R2;
           _sbSzt::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cbTow; else goto cbTox;
       cbTox: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbToz; else goto cbToy;
       cbToz: // global
           HpAlloc = 24;
           goto cbTow;
       cbTow: // global
           R2 = _sbSzi::P64;
           R1 = _sbSzt::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbToy: // global
           _sbSzb::P64 = P64[_sbSzt::P64 + 7];
           _sbSze::P64 = P64[_sbSzt::P64 + 15];
           I64[Hp - 16] = sat_sbSzq_info;
           P64[Hp - 8] = _sbSzb::P64;
           P64[Hp] = _sbSze::P64;
           I64[Sp - 8] = block_cbTos_info;
           R3 = Hp - 15;
           R2 = Control.Applicative.$fReadZipList_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbTos() //  [R1]
         { info_tbl: [(cbTos,
                       label: block_cbTos_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTos: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbToC; else goto cbToB;
       cbToC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbToB: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzw_entry() //  [R1, R2, R3]
         { info_tbl: [(cbToD,
                       label: sat_sbSzw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbToD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbToE; else goto cbToF;
       cbToE: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbToF: // global
           I64[Sp - 24] = block_cbTnG_info;
           _sbSzb::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sbSzb::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubToS; else goto cbTnH;
       ubToS: // global
           call _cbTnG(R1) args: 0, res: 0, upd: 0;
       cbTnH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTnG() //  [R1]
         { info_tbl: [(cbTnG,
                       label: block_cbTnG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTnG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbToI; else goto cbToH;
       cbToI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbToH: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto cbToK; else goto cbToO;
       cbToK: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbToO: // global
           I64[Hp - 16] = sat_sbSzt_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cbToL_info;
           R3 = Hp - 15;
           R2 = Control.Applicative.$fReadZipList_lexeme1_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbToL() //  [R1]
         { info_tbl: [(cbToL,
                       label: block_cbToL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbToL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbToR; else goto cbToQ;
       cbToR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbToQ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fReadZipList1_entry() //  [R2]
         { info_tbl: [(cbToT,
                       label: Control.Applicative.$fReadZipList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbToT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbToX; else goto cbToW;
       cbToX: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbToW: // global
           I64[Hp - 48] = lvl_sbSza_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_sbSzb_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sbSzw_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.640645381 UTC

[section ""data" . Control.Applicative.$fReadZipList_$creadsPrec_closure" {
     Control.Applicative.$fReadZipList_$creadsPrec_closure:
         const Control.Applicative.$fReadZipList_$creadsPrec_info;
         const 0;
 },
 ds_sbSzy_entry() //  [R1]
         { info_tbl: [(cbTp6,
                       label: ds_sbSzy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTp6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTp7; else goto cbTp8;
       cbTp7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTp8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSzA_entry() //  [R1]
         { info_tbl: [(cbTpi,
                       label: sat_sbSzA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTpi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTpj; else goto cbTpk;
       cbTpj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTpk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSzB_entry() //  [R1, R2]
         { info_tbl: [(cbTpl,
                       label: sat_sbSzB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTpl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbTpp; else goto cbTpo;
       cbTpp: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTpo: // global
           _sbSzy::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sbSzA_info;
           P64[Hp - 8] = _sbSzy::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fReadZipList_$creadsPrec_entry() //  [R2]
         { info_tbl: [(cbTpq,
                       label: Control.Applicative.$fReadZipList_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTpq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbTpu; else goto cbTpt;
       cbTpu: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTpt: // global
           I64[Hp - 32] = ds_sbSzy_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sbSzB_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.642967541 UTC

[section ""data" . Control.Applicative.$fReadZipList_$creadListPrec_closure" {
     Control.Applicative.$fReadZipList_$creadListPrec_closure:
         const Control.Applicative.$fReadZipList_$creadListPrec_info;
         const 0;
 },
 sat_sbSzD_entry() //  [R1]
         { info_tbl: [(cbTpD,
                       label: sat_sbSzD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTpD: // global
           R2 = P64[R1 + 16];
           call Control.Applicative.$fReadZipList1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fReadZipList_$creadListPrec_entry() //  [R2]
         { info_tbl: [(cbTpG,
                       label: Control.Applicative.$fReadZipList_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTpG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTpK; else goto cbTpJ;
       cbTpK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTpJ: // global
           I64[Hp - 16] = sat_sbSzD_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.644352928 UTC

[section ""data" . Control.Applicative.$fReadZipList_$creadList_closure" {
     Control.Applicative.$fReadZipList_$creadList_closure:
         const Control.Applicative.$fReadZipList_$creadList_info;
         const 0;
 },
 sat_sbSzF_entry() //  [R1]
         { info_tbl: [(cbTpX,
                       label: sat_sbSzF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTpX: // global
           R2 = P64[R1 + 16];
           call Control.Applicative.$fReadZipList1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzG_entry() //  [R1]
         { info_tbl: [(cbTq0,
                       label: sat_sbSzG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTq0: // global
           _sbSzG::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbTq1; else goto cbTq2;
       cbTq2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTq4; else goto cbTq3;
       cbTq4: // global
           HpAlloc = 24;
           goto cbTq1;
       cbTq1: // global
           R1 = _sbSzG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTq3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSzG::P64;
           _sbSzE::P64 = P64[_sbSzG::P64 + 16];
           I64[Hp - 16] = sat_sbSzF_info;
           P64[Hp] = _sbSzE::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fReadZipList_$creadList_entry() //  [R2]
         { info_tbl: [(cbTq5,
                       label: Control.Applicative.$fReadZipList_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTq5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTq9; else goto cbTq8;
       cbTq9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTq8: // global
           I64[Hp - 16] = sat_sbSzG_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.646266734 UTC

[section ""data" . Control.Applicative.$fReadZipList_closure" {
     Control.Applicative.$fReadZipList_closure:
         const Control.Applicative.$fReadZipList_info;
         const 0;
 },
 sat_sbSzL_entry() //  [R1]
         { info_tbl: [(cbTqi,
                       label: sat_sbSzL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTqi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTqj; else goto cbTqk;
       cbTqj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTqk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSzK_entry() //  [R1]
         { info_tbl: [(cbTqp,
                       label: sat_sbSzK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTqp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTqq; else goto cbTqr;
       cbTqq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTqr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSzJ_entry() //  [R1]
         { info_tbl: [(cbTqw,
                       label: sat_sbSzJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTqw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTqx; else goto cbTqy;
       cbTqx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTqy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSzI_entry() //  [R1]
         { info_tbl: [(cbTqD,
                       label: sat_sbSzI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTqD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTqE; else goto cbTqF;
       cbTqE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTqF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fReadZipList_entry() //  [R2]
         { info_tbl: [(cbTqH,
                       label: Control.Applicative.$fReadZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTqH: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbTqL; else goto cbTqK;
       cbTqL: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTqK: // global
           I64[Hp - 128] = sat_sbSzL_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbSzK_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbSzJ_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbSzI_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.648436897 UTC

[section ""data" . Control.Applicative.$fEqZipList_closure" {
     Control.Applicative.$fEqZipList_closure:
         const Control.Applicative.$fEqZipList_info;
 },
 sat_sbSzO_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTqV,
                       label: sat_sbSzO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTqV: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fEq[]_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzN_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTr3,
                       label: sat_sbSzN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTr3: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fEq[]_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fEqZipList_entry() //  [R2]
         { info_tbl: [(cbTr7,
                       label: Control.Applicative.$fEqZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTr7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbTrb; else goto cbTra;
       cbTrb: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Applicative.$fEqZipList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTra: // global
           I64[Hp - 48] = sat_sbSzO_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sbSzN_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.649930181 UTC

[section ""data" . Control.Applicative.$fOrdZipList_$cp1Ord_closure" {
     Control.Applicative.$fOrdZipList_$cp1Ord_closure:
         const Control.Applicative.$fOrdZipList_$cp1Ord_info;
 },
 sat_sbSzQ_entry() //  [R1]
         { info_tbl: [(cbTrk,
                       label: sat_sbSzQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTrk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTrl; else goto cbTrm;
       cbTrl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTrm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fOrdZipList_$cp1Ord_entry() //  [R2]
         { info_tbl: [(cbTrn,
                       label: Control.Applicative.$fOrdZipList_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTrn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTrr; else goto cbTrq;
       cbTrr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fOrdZipList_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTrq: // global
           I64[Hp - 16] = sat_sbSzQ_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Applicative.$fEqZipList_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.651985192 UTC

[section ""data" . Control.Applicative.$fOrdZipList_closure" {
     Control.Applicative.$fOrdZipList_closure:
         const Control.Applicative.$fOrdZipList_info;
 },
 sat_sbSzZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTrB,
                       label: sat_sbSzZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTrB: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzY_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTrJ,
                       label: sat_sbSzY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTrJ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzX_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTrR,
                       label: sat_sbSzX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTrR: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzW_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTrZ,
                       label: sat_sbSzW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTrZ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$c>_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzV_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTs7,
                       label: sat_sbSzV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTs7: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzU_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTsf,
                       label: sat_sbSzU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTsf: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzT_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTsn,
                       label: sat_sbSzT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTsn: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzS_entry() //  [R1]
         { info_tbl: [(cbTsu,
                       label: sat_sbSzS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTsu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTsv; else goto cbTsw;
       cbTsv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTsw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fOrdZipList_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fOrdZipList_entry() //  [R2]
         { info_tbl: [(cbTsy,
                       label: Control.Applicative.$fOrdZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTsy: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cbTsC; else goto cbTsB;
       cbTsC: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = Control.Applicative.$fOrdZipList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTsB: // global
           I64[Hp - 200] = sat_sbSzZ_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sbSzY_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_sbSzX_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbSzW_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbSzV_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbSzU_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbSzT_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbSzS_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.657420319 UTC

[section ""cstring" . Control.Applicative.$fShowZipList3_bytes" {
     Control.Applicative.$fShowZipList3_bytes:
         I8[] [90,105,112,76,105,115,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.658094464 UTC

[section ""cstring" . Control.Applicative.$fShowZipList2_bytes" {
     Control.Applicative.$fShowZipList2_bytes:
         I8[] [103,101,116,90,105,112,76,105,115,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.660795242 UTC

[section ""data" . Control.Applicative.$w$cshowsPrec_closure" {
     Control.Applicative.$w$cshowsPrec_closure:
         const Control.Applicative.$w$cshowsPrec_info;
 },
 f_sbSA3_entry() //  [R1]
         { info_tbl: [(cbTsL,
                       label: f_sbSA3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTsL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbTsM; else goto cbTsN;
       cbTsM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTsN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.showList_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSA6_entry() //  [R1]
         { info_tbl: [(cbTt8,
                       label: sat_sbSA6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTt8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTt9; else goto cbTta;
       cbTt9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTta: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Control.Applicative.$fReadZipList4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSA7_entry() //  [R1]
         { info_tbl: [(cbTtb,
                       label: sat_sbSA7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTtb: // global
           _sbSA7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbTtc; else goto cbTtd;
       cbTtd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTtf; else goto cbTte;
       cbTtf: // global
           HpAlloc = 24;
           goto cbTtc;
       cbTtc: // global
           R1 = _sbSA7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTte: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSA7::P64;
           _sbSA3::P64 = P64[_sbSA7::P64 + 16];
           _sbSA5::P64 = P64[_sbSA7::P64 + 24];
           I64[Hp - 16] = sat_sbSA6_info;
           P64[Hp] = _sbSA5::P64;
           R2 = Hp - 16;
           R1 = _sbSA3::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSA8_entry() //  [R1]
         { info_tbl: [(cbTtg,
                       label: sat_sbSA8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTtg: // global
           _sbSA8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbTth; else goto cbTti;
       cbTti: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbTtk; else goto cbTtj;
       cbTtk: // global
           HpAlloc = 32;
           goto cbTth;
       cbTth: // global
           R1 = _sbSA8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTtj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSA8::P64;
           _sbSA3::P64 = P64[_sbSA8::P64 + 16];
           _sbSA5::P64 = P64[_sbSA8::P64 + 24];
           I64[Hp - 24] = sat_sbSA7_info;
           P64[Hp - 8] = _sbSA3::P64;
           P64[Hp] = _sbSA5::P64;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSA9_entry() //  [R1, R2]
         { info_tbl: [(cbTtl,
                       label: sat_sbSA9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTtl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbTtp; else goto cbTto;
       cbTtp: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTto: // global
           _sbSA3::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sbSA8_info;
           P64[Hp - 8] = _sbSA3::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSAc_entry() //  [R1]
         { info_tbl: [(cbTtN,
                       label: sat_sbSAc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTtN: // global
           _sbSAc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbTtO; else goto cbTtP;
       cbTtP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTtR; else goto cbTtQ;
       cbTtR: // global
           HpAlloc = 24;
           goto cbTtO;
       cbTtO: // global
           R1 = _sbSAc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTtQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSAc::P64;
           _sbSAa::P64 = P64[_sbSAc::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sbSAa::P64;
           R3 = Hp - 14;
           R2 = Control.Applicative.$fReadZipList4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAd_entry() //  [R1]
         { info_tbl: [(cbTtS,
                       label: sat_sbSAd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTtS: // global
           _sbSAd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbTtT; else goto cbTtU;
       cbTtU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTtW; else goto cbTtV;
       cbTtW: // global
           HpAlloc = 24;
           goto cbTtT;
       cbTtT: // global
           R1 = _sbSAd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTtV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSAd::P64;
           _sbSA3::P64 = P64[_sbSAd::P64 + 16];
           _sbSAa::P64 = P64[_sbSAd::P64 + 24];
           I64[Hp - 16] = sat_sbSAc_info;
           P64[Hp] = _sbSAa::P64;
           R2 = Hp - 16;
           R1 = _sbSA3::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAe_entry() //  [R1]
         { info_tbl: [(cbTtX,
                       label: sat_sbSAe_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTtX: // global
           _sbSAe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbTtY; else goto cbTtZ;
       cbTtZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbTu1; else goto cbTu0;
       cbTu1: // global
           HpAlloc = 32;
           goto cbTtY;
       cbTtY: // global
           R1 = _sbSAe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTu0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSAe::P64;
           _sbSA3::P64 = P64[_sbSAe::P64 + 16];
           _sbSAa::P64 = P64[_sbSAe::P64 + 24];
           I64[Hp - 24] = sat_sbSAd_info;
           P64[Hp - 8] = _sbSA3::P64;
           P64[Hp] = _sbSAa::P64;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAf_entry() //  [R1]
         { info_tbl: [(cbTu2,
                       label: sat_sbSAf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTu2: // global
           _sbSAf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbTu3; else goto cbTu4;
       cbTu4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbTu6; else goto cbTu5;
       cbTu6: // global
           HpAlloc = 32;
           goto cbTu3;
       cbTu3: // global
           R1 = _sbSAf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTu5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSAf::P64;
           _sbSA3::P64 = P64[_sbSAf::P64 + 16];
           _sbSAa::P64 = P64[_sbSAf::P64 + 24];
           I64[Hp - 24] = sat_sbSAe_info;
           P64[Hp - 8] = _sbSA3::P64;
           P64[Hp] = _sbSAa::P64;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAg_entry() //  [R1, R2]
         { info_tbl: [(cbTu8,
                       label: sat_sbSAg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTu8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbTuc; else goto cbTub;
       cbTuc: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTub: // global
           _sbSA3::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_sbSAf_info;
           P64[Hp - 32] = _sbSA3::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cbTug,
                       label: Control.Applicative.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTug: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbTuk; else goto cbTuj;
       cbTuk: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTuj: // global
           I64[Hp - 40] = f_sbSA3_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _cbTsH::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto cbTue; else goto cbTuf;
       cbTue: // global
           I64[Hp - 8] = sat_sbSA9_info;
           P64[Hp] = _cbTsH::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbTuf: // global
           I64[Hp - 8] = sat_sbSAg_info;
           P64[Hp] = _cbTsH::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.666679893 UTC

[section ""data" . Control.Applicative.$fShowZipList_$cshowsPrec_closure" {
     Control.Applicative.$fShowZipList_$cshowsPrec_closure:
         const Control.Applicative.$fShowZipList_$cshowsPrec_info;
 },
 Control.Applicative.$fShowZipList_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbTus,
                       label: Control.Applicative.$fShowZipList_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTus: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbTut; else goto cbTuu;
       cbTut: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fShowZipList_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTuu: // global
           I64[Sp - 24] = block_cbTup_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubTuy; else goto cbTuq;
       ubTuy: // global
           call _cbTup(R1) args: 0, res: 0, upd: 0;
       cbTuq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTup() //  [R1]
         { info_tbl: [(cbTup,
                       label: block_cbTup_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTup: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Control.Applicative.$w$cshowsPrec_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.668553041 UTC

[section ""data" . Control.Applicative.$fShowZipList_$cshow_closure" {
     Control.Applicative.$fShowZipList_$cshow_closure:
         const Control.Applicative.$fShowZipList_$cshow_info;
         const 0;
 },
 sat_sbSAo_entry() //  [R1]
         { info_tbl: [(cbTuL,
                       label: sat_sbSAo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTuL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbTuM; else goto cbTuN;
       cbTuM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTuN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Control.Applicative.$fReadZipList3_closure;
           Sp = Sp - 40;
           call GHC.Show.showList_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbSAp_entry() //  [R1]
         { info_tbl: [(cbTuO,
                       label: sat_sbSAp_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTuO: // global
           _sbSAp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbTuP; else goto cbTuQ;
       cbTuQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbTuS; else goto cbTuR;
       cbTuS: // global
           HpAlloc = 32;
           goto cbTuP;
       cbTuP: // global
           R1 = _sbSAp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTuR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSAp::P64;
           _sbSAm::P64 = P64[_sbSAp::P64 + 16];
           _sbSAn::P64 = P64[_sbSAp::P64 + 24];
           I64[Hp - 24] = sat_sbSAo_info;
           P64[Hp - 8] = _sbSAm::P64;
           P64[Hp] = _sbSAn::P64;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fShowZipList_$cshow_entry() //  [R2, R3]
         { info_tbl: [(cbTuT,
                       label: Control.Applicative.$fShowZipList_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTuT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbTuX; else goto cbTuW;
       cbTuX: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fShowZipList_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTuW: // global
           I64[Hp - 24] = sat_sbSAp_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.67047255 UTC

[section ""data" . Control.Applicative.$fShowZipList1_closure" {
     Control.Applicative.$fShowZipList1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.671546925 UTC

[section ""data" . Control.Applicative.$fShowZipList_$cshowList_closure" {
     Control.Applicative.$fShowZipList_$cshowList_closure:
         const Control.Applicative.$fShowZipList_$cshowList_info;
 },
 sat_sbSAu_entry() //  [R1, R2]
         { info_tbl: [(cbTv7,
                       label: sat_sbSAu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTv7: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Control.Applicative.$w$cshowsPrec_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fShowZipList_$cshowList_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cbTva,
                       label: Control.Applicative.$fShowZipList_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTva: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbTve; else goto cbTvd;
       cbTve: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fShowZipList_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTvd: // global
           I64[Hp - 8] = sat_sbSAu_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.673370029 UTC

[section ""data" . Control.Applicative.$fShowZipList_closure" {
     Control.Applicative.$fShowZipList_closure:
         const Control.Applicative.$fShowZipList_info;
         const 0;
 },
 sat_sbSAy_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTvo,
                       label: sat_sbSAy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTvo: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fShowZipList_$cshowList_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSAx_entry() //  [R1, R2]
         { info_tbl: [(cbTvw,
                       label: sat_sbSAx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTvw: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fShowZipList_$cshow_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSAw_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTvE,
                       label: sat_sbSAw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTvE: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fShowZipList_$cshowsPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fShowZipList_entry() //  [R2]
         { info_tbl: [(cbTvI,
                       label: Control.Applicative.$fShowZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTvI: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbTvM; else goto cbTvL;
       cbTvM: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Control.Applicative.$fShowZipList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTvL: // global
           I64[Hp - 72] = sat_sbSAy_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbSAx_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbSAw_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.675270132 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedArrow1_closure" {
     Control.Applicative.$fGeneric1WrappedArrow1_closure:
         const Control.Applicative.$fGeneric1WrappedArrow1_info;
 },
 Control.Applicative.$fGeneric1WrappedArrow1_entry() //  [R2]
         { info_tbl: [(cbTvR,
                       label: Control.Applicative.$fGeneric1WrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTvR: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.676234384 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedArrow2_closure" {
     Control.Applicative.$fGeneric1WrappedArrow2_closure:
         const Control.Applicative.$fGeneric1WrappedArrow2_info;
 },
 Control.Applicative.$fGeneric1WrappedArrow2_entry() //  [R2]
         { info_tbl: [(cbTvY,
                       label: Control.Applicative.$fGeneric1WrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTvY: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.677099841 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedArrow_closure" {
     Control.Applicative.$fGeneric1WrappedArrow_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Control.Applicative.$fGeneric1WrappedArrow2_closure+1;
         const Control.Applicative.$fGeneric1WrappedArrow1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.67798139 UTC

[section ""data" . Control.Applicative.$fGenericWrappedArrow1_closure" {
     Control.Applicative.$fGenericWrappedArrow1_closure:
         const Control.Applicative.$fGenericWrappedArrow1_info;
 },
 Control.Applicative.$fGenericWrappedArrow1_entry() //  [R2]
         { info_tbl: [(cbTw5,
                       label: Control.Applicative.$fGenericWrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTw5: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.678917994 UTC

[section ""data" . Control.Applicative.$fGenericWrappedArrow2_closure" {
     Control.Applicative.$fGenericWrappedArrow2_closure:
         const Control.Applicative.$fGenericWrappedArrow2_info;
 },
 Control.Applicative.$fGenericWrappedArrow2_entry() //  [R2]
         { info_tbl: [(cbTwc,
                       label: Control.Applicative.$fGenericWrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTwc: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.679860924 UTC

[section ""data" . Control.Applicative.$fGenericWrappedArrow_closure" {
     Control.Applicative.$fGenericWrappedArrow_closure:
         const GHC.Generics.C:Generic_con_info;
         const Control.Applicative.$fGenericWrappedArrow2_closure+1;
         const Control.Applicative.$fGenericWrappedArrow1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.681403201 UTC

[section ""data" . Control.Applicative.$fMonadWrappedMonad_closure" {
     Control.Applicative.$fMonadWrappedMonad_closure:
         const Control.Applicative.$fMonadWrappedMonad_info;
 },
 sat_sbSAI_entry() //  [R1]
         { info_tbl: [(cbTwn,
                       label: sat_sbSAI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTwn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTwo; else goto cbTwp;
       cbTwo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTwp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.fail_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAH_entry() //  [R1]
         { info_tbl: [(cbTwu,
                       label: sat_sbSAH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTwu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTwv; else goto cbTww;
       cbTwv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTww: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAG_entry() //  [R1]
         { info_tbl: [(cbTwB,
                       label: sat_sbSAG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTwB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTwC; else goto cbTwD;
       cbTwC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTwD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.>>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAF_entry() //  [R1]
         { info_tbl: [(cbTwI,
                       label: sat_sbSAF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTwI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTwJ; else goto cbTwK;
       cbTwJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTwK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.>>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAE_entry() //  [R1]
         { info_tbl: [(cbTwP,
                       label: sat_sbSAE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTwP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTwQ; else goto cbTwR;
       cbTwQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTwR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fApplicativeWrappedMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fMonadWrappedMonad_entry() //  [R2]
         { info_tbl: [(cbTwT,
                       label: Control.Applicative.$fMonadWrappedMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTwT: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cbTwX; else goto cbTwW;
       cbTwX: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Control.Applicative.$fMonadWrappedMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTwW: // global
           I64[Hp - 160] = sat_sbSAI_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbSAH_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbSAG_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbSAF_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbSAE_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.683999806 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedMonad1_closure" {
     Control.Applicative.$fGeneric1WrappedMonad1_closure:
         const Control.Applicative.$fGeneric1WrappedMonad1_info;
 },
 Control.Applicative.$fGeneric1WrappedMonad1_entry() //  [R2]
         { info_tbl: [(cbTx2,
                       label: Control.Applicative.$fGeneric1WrappedMonad1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTx2: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.684958713 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedMonad2_closure" {
     Control.Applicative.$fGeneric1WrappedMonad2_closure:
         const Control.Applicative.$fGeneric1WrappedMonad2_info;
 },
 Control.Applicative.$fGeneric1WrappedMonad2_entry() //  [R2]
         { info_tbl: [(cbTx9,
                       label: Control.Applicative.$fGeneric1WrappedMonad2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTx9: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.685897753 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedMonad_closure" {
     Control.Applicative.$fGeneric1WrappedMonad_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Control.Applicative.$fGeneric1WrappedMonad2_closure+1;
         const Control.Applicative.$fGeneric1WrappedMonad1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.686791401 UTC

[section ""data" . Control.Applicative.$fGenericWrappedMonad1_closure" {
     Control.Applicative.$fGenericWrappedMonad1_closure:
         const Control.Applicative.$fGenericWrappedMonad1_info;
 },
 Control.Applicative.$fGenericWrappedMonad1_entry() //  [R2]
         { info_tbl: [(cbTxg,
                       label: Control.Applicative.$fGenericWrappedMonad1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTxg: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.68776921 UTC

[section ""data" . Control.Applicative.$fGenericWrappedMonad2_closure" {
     Control.Applicative.$fGenericWrappedMonad2_closure:
         const Control.Applicative.$fGenericWrappedMonad2_info;
 },
 Control.Applicative.$fGenericWrappedMonad2_entry() //  [R2]
         { info_tbl: [(cbTxn,
                       label: Control.Applicative.$fGenericWrappedMonad2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTxn: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.688613339 UTC

[section ""data" . Control.Applicative.$fGenericWrappedMonad_closure" {
     Control.Applicative.$fGenericWrappedMonad_closure:
         const GHC.Generics.C:Generic_con_info;
         const Control.Applicative.$fGenericWrappedMonad2_closure+1;
         const Control.Applicative.$fGenericWrappedMonad1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.69183135 UTC

[section ""data" . Control.Applicative.unwrapMonad_closure" {
     Control.Applicative.unwrapMonad_closure:
         const Control.Applicative.unwrapMonad_info;
 },
 Control.Applicative.unwrapMonad_entry() //  [R2]
         { info_tbl: [(cbTxu,
                       label: Control.Applicative.unwrapMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTxu: // global
           R2 = R2;
           call Control.Applicative.$fGeneric1WrappedMonad2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.692687408 UTC

[section ""data" . Control.Applicative.unwrapArrow_closure" {
     Control.Applicative.unwrapArrow_closure:
         const Control.Applicative.unwrapArrow_info;
 },
 Control.Applicative.unwrapArrow_entry() //  [R2]
         { info_tbl: [(cbTxB,
                       label: Control.Applicative.unwrapArrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTxB: // global
           R2 = R2;
           call Control.Applicative.$fGeneric1WrappedArrow2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.693626697 UTC

[section ""data" . Control.Applicative.getZipList_closure" {
     Control.Applicative.getZipList_closure:
         const Control.Applicative.getZipList_info;
 },
 Control.Applicative.getZipList_entry() //  [R2]
         { info_tbl: [(cbTxI,
                       label: Control.Applicative.getZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTxI: // global
           R2 = R2;
           call Control.Applicative.$fGeneric1ZipList2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.695136528 UTC

[section ""data" . Control.Applicative.optional_closure" {
     Control.Applicative.optional_closure:
         const Control.Applicative.optional_info;
 },
 $dApplicative_sbSAP_entry() //  [R1]
         { info_tbl: [(cbTxT,
                       label: $dApplicative_sbSAP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTxT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTxU; else goto cbTxV;
       cbTxU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTxV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAS_entry() //  [R1]
         { info_tbl: [(cbTy0,
                       label: sat_sbSAS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTy0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbTy1; else goto cbTy2;
       cbTy1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTy2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSAR_entry() //  [R1]
         { info_tbl: [(cbTy9,
                       label: sat_sbSAR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTy9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbTya; else goto cbTyb;
       cbTya: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTyb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbTy7_info;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbTy7() //  [R1]
         { info_tbl: [(cbTy7,
                       label: block_cbTy7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTy7: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.optional_entry() //  [R2, R3]
         { info_tbl: [(cbTyf,
                       label: Control.Applicative.optional_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTyf: // global
           _sbSAO::P64 = R3;
           _sbSAN::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbTyg; else goto cbTyh;
       cbTyh: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbTyj; else goto cbTyi;
       cbTyj: // global
           HpAlloc = 80;
           goto cbTyg;
       cbTyg: // global
           R3 = _sbSAO::P64;
           R2 = _sbSAN::P64;
           R1 = Control.Applicative.optional_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTyi: // global
           I64[Hp - 72] = $dApplicative_sbSAP_info;
           P64[Hp - 56] = _sbSAN::P64;
           I64[Hp - 48] = sat_sbSAS_info;
           _cbTxP::P64 = Hp - 72;
           P64[Hp - 32] = _cbTxP::P64;
           I64[Hp - 24] = sat_sbSAR_info;
           P64[Hp - 8] = _sbSAO::P64;
           P64[Hp] = _cbTxP::P64;
           R2 = _sbSAN::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 24;
           call GHC.Base.<|>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.697172911 UTC

[section ""cstring" . Control.Applicative.$trModule4_bytes" {
     Control.Applicative.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.697847926 UTC

[section ""data" . Control.Applicative.$trModule3_closure" {
     Control.Applicative.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.698454314 UTC

[section ""cstring" . Control.Applicative.$trModule2_bytes" {
     Control.Applicative.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,65,112,112,108,105,99,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.69910055 UTC

[section ""data" . Control.Applicative.$trModule1_closure" {
     Control.Applicative.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.699752441 UTC

[section ""data" . Control.Applicative.$trModule_closure" {
     Control.Applicative.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Applicative.$trModule3_closure+1;
         const Control.Applicative.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.700417416 UTC

[section ""data" . Control.Applicative.$tcWrappedMonad1_closure" {
     Control.Applicative.$tcWrappedMonad1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const GHC.Types.krep$*Arr*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.701072655 UTC

[section ""data" . Control.Applicative.$tcWrappedArrow1_closure" {
     Control.Applicative.$tcWrappedArrow1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const GHC.Types.krep$*->*->*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.702146158 UTC

[section ""data" . $krep_rbSvt_closure" {
     $krep_rbSvt_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.702781483 UTC

[section ""data" . $krep1_rbSvu_closure" {
     $krep1_rbSvu_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.703403425 UTC

[section ""data" . $krep2_rbSvv_closure" {
     $krep2_rbSvv_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.704066107 UTC

[section ""data" . $krep3_rbSvw_closure" {
     $krep3_rbSvw_closure:
         const :_con_info;
         const $krep2_rbSvv_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.704726341 UTC

[section ""data" . $krep4_rbSvx_closure" {
     $krep4_rbSvx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep3_rbSvw_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.705414895 UTC

[section ""data" . $krep5_rbSvy_closure" {
     $krep5_rbSvy_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep2_rbSvv_closure+2;
         const $krep1_rbSvu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.706063478 UTC

[section ""data" . $krep6_rbSvz_closure" {
     $krep6_rbSvz_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep5_rbSvy_closure+3;
         const $krep_rbSvt_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.70670614 UTC

[section ""cstring" . Control.Applicative.$tcWrappedMonad3_bytes" {
     Control.Applicative.$tcWrappedMonad3_bytes:
         I8[] [87,114,97,112,112,101,100,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.707360595 UTC

[section ""data" . Control.Applicative.$tcWrappedMonad2_closure" {
     Control.Applicative.$tcWrappedMonad2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tcWrappedMonad3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.708059429 UTC

[section ""data" . Control.Applicative.$tcWrappedMonad_closure" {
     Control.Applicative.$tcWrappedMonad_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tcWrappedMonad2_closure+1;
         const Control.Applicative.$tcWrappedMonad1_closure+4;
         const 12971590878300233698;
         const 12447260690856494251;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.709166956 UTC

[section ""data" . $krep7_rbSvA_closure" {
     $krep7_rbSvA_closure:
         const :_con_info;
         const $krep1_rbSvu_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.709954692 UTC

[section ""data" . $krep8_rbSvB_closure" {
     $krep8_rbSvB_closure:
         const :_con_info;
         const $krep2_rbSvv_closure+2;
         const $krep7_rbSvA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.710622899 UTC

[section ""data" . $krep9_rbSvC_closure" {
     $krep9_rbSvC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Applicative.$tcWrappedMonad_closure+1;
         const $krep8_rbSvB_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.711322054 UTC

[section ""data" . Control.Applicative.$tc'WrapMonad1_closure" {
     Control.Applicative.$tc'WrapMonad1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_rbSvy_closure+3;
         const $krep9_rbSvC_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.711974329 UTC

[section ""cstring" . Control.Applicative.$tc'WrapMonad3_bytes" {
     Control.Applicative.$tc'WrapMonad3_bytes:
         I8[] [39,87,114,97,112,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.712550574 UTC

[section ""data" . Control.Applicative.$tc'WrapMonad2_closure" {
     Control.Applicative.$tc'WrapMonad2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tc'WrapMonad3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.713153969 UTC

[section ""data" . Control.Applicative.$tc'WrapMonad_closure" {
     Control.Applicative.$tc'WrapMonad_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tc'WrapMonad2_closure+1;
         const Control.Applicative.$tc'WrapMonad1_closure+4;
         const 10363415327661881286;
         const 6845751270384138997;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.713877383 UTC

[section ""cstring" . Control.Applicative.$tcWrappedArrow3_bytes" {
     Control.Applicative.$tcWrappedArrow3_bytes:
         I8[] [87,114,97,112,112,101,100,65,114,114,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.714498522 UTC

[section ""data" . Control.Applicative.$tcWrappedArrow2_closure" {
     Control.Applicative.$tcWrappedArrow2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tcWrappedArrow3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.71510633 UTC

[section ""data" . Control.Applicative.$tcWrappedArrow_closure" {
     Control.Applicative.$tcWrappedArrow_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tcWrappedArrow2_closure+1;
         const Control.Applicative.$tcWrappedArrow1_closure+4;
         const 17995829375472255965;
         const 6668242383287740398;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.715995068 UTC

[section ""data" . $krep10_rbSvD_closure" {
     $krep10_rbSvD_closure:
         const :_con_info;
         const $krep_rbSvt_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.716689136 UTC

[section ""data" . $krep11_rbSvE_closure" {
     $krep11_rbSvE_closure:
         const :_con_info;
         const $krep1_rbSvu_closure+2;
         const $krep10_rbSvD_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.717610774 UTC

[section ""data" . $krep12_rbSvF_closure" {
     $krep12_rbSvF_closure:
         const :_con_info;
         const $krep2_rbSvv_closure+2;
         const $krep11_rbSvE_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.718238858 UTC

[section ""data" . $krep13_rbSvG_closure" {
     $krep13_rbSvG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Applicative.$tcWrappedArrow_closure+1;
         const $krep12_rbSvF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.718914155 UTC

[section ""data" . Control.Applicative.$tc'WrapArrow1_closure" {
     Control.Applicative.$tc'WrapArrow1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rbSvz_closure+3;
         const $krep13_rbSvG_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.719562152 UTC

[section ""cstring" . Control.Applicative.$tc'WrapArrow3_bytes" {
     Control.Applicative.$tc'WrapArrow3_bytes:
         I8[] [39,87,114,97,112,65,114,114,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.720139032 UTC

[section ""data" . Control.Applicative.$tc'WrapArrow2_closure" {
     Control.Applicative.$tc'WrapArrow2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tc'WrapArrow3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.720739752 UTC

[section ""data" . Control.Applicative.$tc'WrapArrow_closure" {
     Control.Applicative.$tc'WrapArrow_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tc'WrapArrow2_closure+1;
         const Control.Applicative.$tc'WrapArrow1_closure+4;
         const 4796259816778499037;
         const 13482613273239263357;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.721493616 UTC

[section ""data" . Control.Applicative.$tcZipList1_closure" {
     Control.Applicative.$tcZipList1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$fReadZipList11_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.722086128 UTC

[section ""data" . Control.Applicative.$tcZipList_closure" {
     Control.Applicative.$tcZipList_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tcZipList1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 11311650752326360483;
         const 5534599578149162946;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.722697789 UTC

[section ""data" . $krep14_rbSvH_closure" {
     $krep14_rbSvH_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Applicative.$tcZipList_closure+1;
         const $krep3_rbSvw_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.723302094 UTC

[section ""data" . Control.Applicative.$tc'ZipList1_closure" {
     Control.Applicative.$tc'ZipList1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rbSvx_closure+1;
         const $krep14_rbSvH_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.725047869 UTC

[section ""cstring" . Control.Applicative.$tc'ZipList3_bytes" {
     Control.Applicative.$tc'ZipList3_bytes:
         I8[] [39,90,105,112,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.725660398 UTC

[section ""data" . Control.Applicative.$tc'ZipList2_closure" {
     Control.Applicative.$tc'ZipList2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tc'ZipList3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.726222351 UTC

[section ""data" . Control.Applicative.$tc'ZipList_closure" {
     Control.Applicative.$tc'ZipList_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tc'ZipList2_closure+1;
         const Control.Applicative.$tc'ZipList1_closure+4;
         const 15353069281551614305;
         const 7665927634319452478;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.726834273 UTC

[section ""relreadonly" . SbSVf_srt" {
     SbSVf_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Control.Applicative.$fReadZipList2_closure;
         const GHC.Read.readField_closure;
         const Control.Applicative.$fReadZipList6_closure;
         const Control.Applicative.$fReadZipList_lexeme_closure;
         const Control.Applicative.$fReadZipList_lexeme1_closure;
         const GHC.Read.list3_closure;
         const Control.Applicative.$fReadZipList1_closure;
         const Control.Applicative.$fReadZipList_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Control.Applicative.$fReadZipList_$creadListPrec_closure;
         const Control.Applicative.$fReadZipList_$creadList_closure;
         const Control.Applicative.$fReadZipList_closure;
         const Control.Applicative.$fReadZipList3_closure;
         const Control.Applicative.$fShowZipList_$cshow_closure;
         const Control.Applicative.$fShowZipList_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.727731518 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:45.729379153 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedMonad1_closure" {
     Control.Applicative.$fFunctorWrappedMonad1_closure:
         const Control.Applicative.$fFunctorWrappedMonad1_info;
 },
 lvl_sbSvM_entry() //  [R1]
         { info_tbl: [(cbTys,
                       label: lvl_sbSvM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTys: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbTyt; else goto cbTyu;
       cbTyt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTyu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSvO_entry() //  [R1]
         { info_tbl: [(cbTyA,
                       label: sat_sbSvO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTyA: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fFunctorWrappedMonad1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbTyD,
                       label: Control.Applicative.$fFunctorWrappedMonad1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTyD: // global
           _sbSvL::P64 = R4;
           _sbSvK::P64 = R3;
           _sbSvJ::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbTyE; else goto cbTyF;
       cbTyF: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbTyH; else goto cbTyG;
       cbTyH: // global
           HpAlloc = 48;
           goto cbTyE;
       cbTyE: // global
           R4 = _sbSvL::P64;
           R3 = _sbSvK::P64;
           R2 = _sbSvJ::P64;
           R1 = Control.Applicative.$fFunctorWrappedMonad1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTyG: // global
           I64[Hp - 40] = lvl_sbSvM_info;
           P64[Hp - 24] = _sbSvJ::P64;
           P64[Hp - 16] = _sbSvK::P64;
           I64[Hp - 8] = sat_sbSvO_info;
           P64[Hp] = Hp - 40;
           R2 = _sbSvJ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSvL::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.73733221 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedMonad_closure" {
     Control.Applicative.$fFunctorWrappedMonad_closure:
         const Control.Applicative.$fFunctorWrappedMonad_info;
 },
 sat_sbSvT_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTz6,
                       label: sat_sbSvT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTz6: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fFunctorWrappedMonad1_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSvS_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTze,
                       label: sat_sbSvS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTze: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.liftM_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fFunctorWrappedMonad_entry() //  [R2]
         { info_tbl: [(cbTzi,
                       label: Control.Applicative.$fFunctorWrappedMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTzi: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbTzm; else goto cbTzl;
       cbTzm: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Applicative.$fFunctorWrappedMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTzl: // global
           I64[Hp - 48] = sat_sbSvT_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sbSvS_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.744326942 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedMonad3_closure" {
     Control.Applicative.$fApplicativeWrappedMonad3_closure:
         const Control.Applicative.$fApplicativeWrappedMonad3_info;
 },
 Control.Applicative.$fApplicativeWrappedMonad3_entry() //  [R2, R3]
         { info_tbl: [(cbTzG,
                       label: Control.Applicative.$fApplicativeWrappedMonad3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTzG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTzH; else goto cbTzI;
       cbTzH: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedMonad3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTzI: // global
           I64[Sp - 16] = block_cbTzE_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbTzE() //  [R1]
         { info_tbl: [(cbTzE,
                       label: block_cbTzE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTzE: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.750347209 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedMonad2_closure" {
     Control.Applicative.$fApplicativeWrappedMonad2_closure:
         const Control.Applicative.$fApplicativeWrappedMonad2_info;
 },
 lvl_sbSw0_entry() //  [R1]
         { info_tbl: [(cbTA6,
                       label: lvl_sbSw0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTA6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbTA7; else goto cbTA8;
       cbTA7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTA8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSw2_entry() //  [R1]
         { info_tbl: [(cbTAe,
                       label: sat_sbSw2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTAe: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSw3_entry() //  [R1]
         { info_tbl: [(cbTAh,
                       label: sat_sbSw3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTAh: // global
           _sbSw3::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbTAi; else goto cbTAj;
       cbTAj: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbTAl; else goto cbTAk;
       cbTAl: // global
           HpAlloc = 40;
           goto cbTAi;
       cbTAi: // global
           R1 = _sbSw3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTAk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSw3::P64;
           _sbSvX::P64 = P64[_sbSw3::P64 + 16];
           _sbSvY::P64 = P64[_sbSw3::P64 + 24];
           I64[Hp - 32] = lvl_sbSw0_info;
           P64[Hp - 16] = _sbSvX::P64;
           I64[Hp - 8] = sat_sbSw2_info;
           P64[Hp] = Hp - 32;
           R2 = _sbSvX::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbSvY::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeWrappedMonad2_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbTAm,
                       label: Control.Applicative.$fApplicativeWrappedMonad2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTAm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbTAq; else goto cbTAp;
       cbTAq: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedMonad2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTAp: // global
           I64[Hp - 24] = sat_sbSw3_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R4 = R4;
           R3 = Hp - 24;
           R2 = R2;
           call GHC.Base.ap_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.761043481 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedMonad1_closure" {
     Control.Applicative.$fApplicativeWrappedMonad1_closure:
         const Control.Applicative.$fApplicativeWrappedMonad1_info;
 },
 lvl_sbSw8_entry() //  [R1]
         { info_tbl: [(cbTAV,
                       label: lvl_sbSw8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTAV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbTAW; else goto cbTAX;
       cbTAW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTAX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSwa_entry() //  [R1]
         { info_tbl: [(cbTB3,
                       label: sat_sbSwa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTB3: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwb_entry() //  [R1, R2]
         { info_tbl: [(cbTB6,
                       label: sat_sbSwb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTB6: // global
           _sbSw7::P64 = R2;
           _sbSwb::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbTB7; else goto cbTB8;
       cbTB8: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbTBa; else goto cbTB9;
       cbTBa: // global
           HpAlloc = 48;
           goto cbTB7;
       cbTB7: // global
           R2 = _sbSw7::P64;
           R1 = _sbSwb::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTB9: // global
           _sbSw4::P64 = P64[_sbSwb::P64 + 7];
           _sbSw6::P64 = P64[_sbSwb::P64 + 15];
           I64[Hp - 40] = lvl_sbSw8_info;
           P64[Hp - 24] = _sbSw4::P64;
           P64[Hp - 16] = _sbSw7::P64;
           I64[Hp - 8] = sat_sbSwa_info;
           P64[Hp] = Hp - 40;
           R2 = _sbSw4::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSw6::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fApplicativeWrappedMonad1_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbTBb,
                       label: Control.Applicative.$fApplicativeWrappedMonad1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTBb: // global
           _sbSw6::P64 = R4;
           _sbSw5::P64 = R3;
           _sbSw4::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbTBc; else goto cbTBd;
       cbTBd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTBf; else goto cbTBe;
       cbTBf: // global
           HpAlloc = 24;
           goto cbTBc;
       cbTBc: // global
           R4 = _sbSw6::P64;
           R3 = _sbSw5::P64;
           R2 = _sbSw4::P64;
           R1 = Control.Applicative.$fApplicativeWrappedMonad1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTBe: // global
           I64[Hp - 16] = sat_sbSwb_info;
           P64[Hp - 8] = _sbSw4::P64;
           P64[Hp] = _sbSw6::P64;
           R2 = _sbSw4::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSw5::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.771787371 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedMonad_closure" {
     Control.Applicative.$fApplicativeWrappedMonad_closure:
         const Control.Applicative.$fApplicativeWrappedMonad_info;
 },
 sat_sbSwn_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTBJ,
                       label: sat_sbSwn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTBJ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedMonad1_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwm_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTBR,
                       label: sat_sbSwm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTBR: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedMonad2_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwl_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbTBZ,
                       label: sat_sbSwl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTBZ: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.liftM2_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwh_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTC7,
                       label: sat_sbSwh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTC7: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.ap_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwe_entry() //  [R1, R2]
         { info_tbl: [(cbTCf,
                       label: sat_sbSwe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTCf: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fApplicativeWrappedMonad3_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwd_entry() //  [R1]
         { info_tbl: [(cbTCm,
                       label: sat_sbSwd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTCm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTCn; else goto cbTCo;
       cbTCn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTCo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fFunctorWrappedMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeWrappedMonad_entry() //  [R2]
         { info_tbl: [(cbTCq,
                       label: Control.Applicative.$fApplicativeWrappedMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTCq: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cbTCu; else goto cbTCt;
       cbTCu: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTCt: // global
           I64[Hp - 152] = sat_sbSwn_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbSwm_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbSwl_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbSwh_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbSwe_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbSwd_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 87;
           P64[Hp - 24] = Hp - 102;
           P64[Hp - 16] = Hp - 117;
           P64[Hp - 8] = Hp - 134;
           P64[Hp] = Hp - 150;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.785960448 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_closure" {
     Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_closure:
         const Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_info;
 },
 sat_sbSwp_entry() //  [R1]
         { info_tbl: [(cbTD7,
                       label: sat_sbSwp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTD7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTD8; else goto cbTD9;
       cbTD8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTD9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_entry() //  [R2]
         { info_tbl: [(cbTDa,
                       label: Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTDa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTDe; else goto cbTDd;
       cbTDe: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTDd: // global
           I64[Hp - 16] = sat_sbSwp_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Applicative.$fApplicativeWrappedMonad_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.792456766 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedMonad_$csome_closure" {
     Control.Applicative.$fAlternativeWrappedMonad_$csome_closure:
         const Control.Applicative.$fAlternativeWrappedMonad_$csome_info;
 },
 sat_sbSww_entry() //  [R1]
         { info_tbl: [(cbTDG,
                       label: sat_sbSww_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTDG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbTDH; else goto cbTDI;
       cbTDH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTDI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbTDE_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbTDE() //  [R1]
         { info_tbl: [(cbTDE,
                       label: block_cbTDE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTDE: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 m2_sbSwt_entry() //  [R1]
         { info_tbl: [(cbTDM,
                       label: m2_sbSwt_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTDM: // global
           _sbSwt::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbTDN; else goto cbTDO;
       cbTDO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTDQ; else goto cbTDP;
       cbTDQ: // global
           HpAlloc = 24;
           goto cbTDN;
       cbTDN: // global
           R1 = _sbSwt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTDP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSwt::P64;
           _sbSwq::P64 = P64[_sbSwt::P64 + 16];
           _sbSws::P64 = P64[_sbSwt::P64 + 24];
           _sbSwu::P64 = P64[_sbSwt::P64 + 32];
           I64[Hp - 16] = sat_sbSww_info;
           P64[Hp] = _sbSws::P64;
           R2 = _sbSwq::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbSwu::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call GHC.Base.mplus_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbSwA_entry() //  [R1, R2]
         { info_tbl: [(cbTE5,
                       label: sat_sbSwA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTE5: // global
           _sbSwy::P64 = R2;
           _sbSwA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbTE6; else goto cbTE7;
       cbTE7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTE9; else goto cbTE8;
       cbTE9: // global
           HpAlloc = 24;
           goto cbTE6;
       cbTE6: // global
           R2 = _sbSwy::P64;
           R1 = _sbSwA::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTE8: // global
           _sbSws::P64 = P64[_sbSwA::P64 + 7];
           _sbSwx::P64 = P64[_sbSwA::P64 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sbSwx::P64;
           P64[Hp] = _sbSwy::P64;
           R2 = _sbSws::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbSwB_entry() //  [R1, R2]
         { info_tbl: [(cbTEa,
                       label: sat_sbSwB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTEa: // global
           _sbSwx::P64 = R2;
           _sbSwB::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbTEb; else goto cbTEc;
       cbTEc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTEe; else goto cbTEd;
       cbTEe: // global
           HpAlloc = 24;
           goto cbTEb;
       cbTEb: // global
           R2 = _sbSwx::P64;
           R1 = _sbSwB::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTEd: // global
           _sbSws::P64 = P64[_sbSwB::P64 + 7];
           _sbSwt::P64 = P64[_sbSwB::P64 + 15];
           I64[Hp - 16] = sat_sbSwA_info;
           P64[Hp - 8] = _sbSws::P64;
           P64[Hp] = _sbSwx::P64;
           R2 = _sbSws::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSwt::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 some_v_sbSwu_entry() //  [R1]
         { info_tbl: [(cbTEf,
                       label: some_v_sbSwu_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTEf: // global
           _sbSwu::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbTEg; else goto cbTEh;
       cbTEh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTEj; else goto cbTEi;
       cbTEj: // global
           HpAlloc = 24;
           goto cbTEg;
       cbTEg: // global
           R1 = _sbSwu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTEi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSwu::P64;
           _sbSwr::P64 = P64[_sbSwu::P64 + 16];
           _sbSws::P64 = P64[_sbSwu::P64 + 24];
           _sbSwt::P64 = P64[_sbSwu::P64 + 32];
           I64[Hp - 16] = sat_sbSwB_info;
           P64[Hp - 8] = _sbSws::P64;
           P64[Hp] = _sbSwt::P64;
           R2 = _sbSws::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbSwr::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedMonad_$csome_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(cbTEk,
                       label: Control.Applicative.$fAlternativeWrappedMonad_$csome_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTEk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbTEl; else goto cbTEm;
       cbTEl: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedMonad_$csome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTEm: // global
           I64[Sp - 24] = block_cbTDr_info;
           _sbSwq::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _sbSwq::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbTDr() //  [R1]
         { info_tbl: [(cbTDr,
                       label: block_cbTDr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTDr: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbTEp; else goto cbTEo;
       cbTEp: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbTEo: // global
           I64[Hp - 72] = m2_sbSwt_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           _cbTDw::P64 = Hp - 32;
           P64[Hp - 40] = _cbTDw::P64;
           I64[Hp - 32] = some_v_sbSwu_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 72;
           R1 = _cbTDw::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.812318732 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedMonad_$cmany_closure" {
     Control.Applicative.$fAlternativeWrappedMonad_$cmany_closure:
         const Control.Applicative.$fAlternativeWrappedMonad_$cmany_info;
 },
 $dApplicative_sbSwF_entry() //  [R1]
         { info_tbl: [(cbTFe,
                       label: $dApplicative_sbSwF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTFe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTFf; else goto cbTFg;
       cbTFf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTFg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSwN_entry() //  [R1]
         { info_tbl: [(cbTFn,
                       label: sat_sbSwN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTFn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbTFo; else goto cbTFp;
       cbTFo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTFp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbTFl_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbTFl() //  [R1]
         { info_tbl: [(cbTFl,
                       label: block_cbTFl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTFl: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSwJ_entry() //  [R1, R2]
         { info_tbl: [(cbTFI,
                       label: sat_sbSwJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTFI: // global
           _sbSwH::P64 = R2;
           _sbSwJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbTFJ; else goto cbTFK;
       cbTFK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTFM; else goto cbTFL;
       cbTFM: // global
           HpAlloc = 24;
           goto cbTFJ;
       cbTFJ: // global
           R2 = _sbSwH::P64;
           R1 = _sbSwJ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTFL: // global
           _sbSwF::P64 = P64[_sbSwJ::P64 + 7];
           _sbSwG::P64 = P64[_sbSwJ::P64 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sbSwG::P64;
           P64[Hp] = _sbSwH::P64;
           R2 = _sbSwF::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbSwK_entry() //  [R1, R2]
         { info_tbl: [(cbTFN,
                       label: sat_sbSwK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTFN: // global
           _sbSwG::P64 = R2;
           _sbSwK::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbTFO; else goto cbTFP;
       cbTFP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTFR; else goto cbTFQ;
       cbTFR: // global
           HpAlloc = 24;
           goto cbTFO;
       cbTFO: // global
           R2 = _sbSwG::P64;
           R1 = _sbSwK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTFQ: // global
           _sbSwE::P64 = P64[_sbSwK::P64 + 7];
           _sbSwF::P64 = P64[_sbSwK::P64 + 15];
           I64[Hp - 16] = sat_sbSwJ_info;
           P64[Hp - 8] = _sbSwF::P64;
           P64[Hp] = _sbSwG::P64;
           R2 = _sbSwF::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSwE::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbSwL_entry() //  [R1]
         { info_tbl: [(cbTFS,
                       label: sat_sbSwL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTFS: // global
           _sbSwL::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbTFT; else goto cbTFU;
       cbTFU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTFW; else goto cbTFV;
       cbTFW: // global
           HpAlloc = 24;
           goto cbTFT;
       cbTFT: // global
           R1 = _sbSwL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTFV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSwL::P64;
           _sbSwD::P64 = P64[_sbSwL::P64 + 16];
           _sbSwE::P64 = P64[_sbSwL::P64 + 24];
           _sbSwF::P64 = P64[_sbSwL::P64 + 32];
           I64[Hp - 16] = sat_sbSwK_info;
           P64[Hp - 8] = _sbSwE::P64;
           P64[Hp] = _sbSwF::P64;
           R2 = _sbSwF::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbSwD::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 many_v_sbSwE_entry() //  [R1]
         { info_tbl: [(cbTFX,
                       label: many_v_sbSwE_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTFX: // global
           _sbSwE::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbTFY; else goto cbTFZ;
       cbTFZ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbTG1; else goto cbTG0;
       cbTG1: // global
           HpAlloc = 88;
           goto cbTFY;
       cbTFY: // global
           R1 = _sbSwE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTG0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSwE::P64;
           _sbSwC::P64 = P64[_sbSwE::P64 + 16];
           _sbSwD::P64 = P64[_sbSwE::P64 + 24];
           I64[Hp - 80] = $dApplicative_sbSwF_info;
           P64[Hp - 64] = _sbSwC::P64;
           I64[Hp - 56] = sat_sbSwN_info;
           _cbTFa::P64 = Hp - 80;
           P64[Hp - 40] = _cbTFa::P64;
           I64[Hp - 32] = sat_sbSwL_info;
           P64[Hp - 16] = _sbSwD::P64;
           P64[Hp - 8] = _sbSwE::P64;
           P64[Hp] = _cbTFa::P64;
           R2 = _sbSwC::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call GHC.Base.mplus_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedMonad_$cmany_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(cbTG2,
                       label: Control.Applicative.$fAlternativeWrappedMonad_$cmany_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTG2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbTG6; else goto cbTG5;
       cbTG6: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedMonad_$cmany_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTG5: // global
           I64[Hp - 24] = many_v_sbSwE_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.830949039 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedMonad_closure" {
     Control.Applicative.$fAlternativeWrappedMonad_closure:
         const Control.Applicative.$fAlternativeWrappedMonad_info;
 },
 sat_sbSwV_entry() //  [R1, R2]
         { info_tbl: [(cbTGQ,
                       label: sat_sbSwV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTGQ: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fAlternativeWrappedMonad_$cmany_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwU_entry() //  [R1, R2]
         { info_tbl: [(cbTGY,
                       label: sat_sbSwU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTGY: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fAlternativeWrappedMonad_$csome_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSwT_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTH6,
                       label: sat_sbSwT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTH6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbTH7; else goto cbTH8;
       cbTH7: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTH8: // global
           _sbSwR::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSwR::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbSwQ_entry() //  [R1]
         { info_tbl: [(cbTHd,
                       label: sat_sbSwQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTHd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTHe; else goto cbTHf;
       cbTHe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTHf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSwP_entry() //  [R1]
         { info_tbl: [(cbTHk,
                       label: sat_sbSwP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTHk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTHl; else goto cbTHm;
       cbTHl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTHm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedMonad_entry() //  [R2]
         { info_tbl: [(cbTHo,
                       label: Control.Applicative.$fAlternativeWrappedMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTHo: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cbTHs; else goto cbTHr;
       cbTHs: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTHr: // global
           I64[Hp - 136] = sat_sbSwV_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbSwU_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbSwT_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbSwQ_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbSwP_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 102;
           P64[Hp - 8] = Hp - 119;
           P64[Hp] = Hp - 135;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.84440035 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedArrow2_closure" {
     Control.Applicative.$fFunctorWrappedArrow2_closure:
         const Control.Applicative.$fFunctorWrappedArrow2_info;
 },
 sat_sbSx0_entry() //  [R1]
         { info_tbl: [(cbTI3,
                       label: sat_sbSx0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTI3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbTI4; else goto cbTI5;
       cbTI4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTI5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fFunctorWrappedArrow2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbTI8,
                       label: Control.Applicative.$fFunctorWrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTI8: // global
           _sbSwY::P64 = R4;
           _sbSwX::P64 = R3;
           _sbSwW::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbTI9; else goto cbTIa;
       cbTIa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbTIc; else goto cbTIb;
       cbTIc: // global
           HpAlloc = 32;
           goto cbTI9;
       cbTI9: // global
           R4 = _sbSwY::P64;
           R3 = _sbSwX::P64;
           R2 = _sbSwW::P64;
           R1 = Control.Applicative.$fFunctorWrappedArrow2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTIb: // global
           I64[Hp - 24] = sat_sbSx0_info;
           P64[Hp - 8] = _sbSwW::P64;
           P64[Hp] = _sbSwX::P64;
           I64[Sp - 24] = block_cbTI6_info;
           R2 = _sbSwW::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbSwY::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbTI6() //  [R1]
         { info_tbl: [(cbTI6,
                       label: block_cbTI6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTI6: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.852034189 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedArrow1_closure" {
     Control.Applicative.$fFunctorWrappedArrow1_closure:
         const Control.Applicative.$fFunctorWrappedArrow1_info;
 },
 sat_sbSx6_entry() //  [R1]
         { info_tbl: [(cbTIH,
                       label: sat_sbSx6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTIH: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSx7_entry() //  [R1]
         { info_tbl: [(cbTIK,
                       label: sat_sbSx7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTIK: // global
           _sbSx7::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbTIL; else goto cbTIM;
       cbTIM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbTIO; else goto cbTIN;
       cbTIO: // global
           HpAlloc = 16;
           goto cbTIL;
       cbTIL: // global
           R1 = _sbSx7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTIN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSx7::P64;
           _sbSx1::P64 = P64[_sbSx7::P64 + 16];
           _sbSx2::P64 = P64[_sbSx7::P64 + 24];
           I64[Hp - 8] = sat_sbSx6_info;
           P64[Hp] = _sbSx2::P64;
           R2 = _sbSx1::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fFunctorWrappedArrow1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbTIR,
                       label: Control.Applicative.$fFunctorWrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTIR: // global
           _sbSx3::P64 = R4;
           _sbSx2::P64 = R3;
           _sbSx1::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbTIS; else goto cbTIT;
       cbTIT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbTIV; else goto cbTIU;
       cbTIV: // global
           HpAlloc = 32;
           goto cbTIS;
       cbTIS: // global
           R4 = _sbSx3::P64;
           R3 = _sbSx2::P64;
           R2 = _sbSx1::P64;
           R1 = Control.Applicative.$fFunctorWrappedArrow1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTIU: // global
           I64[Hp - 24] = sat_sbSx7_info;
           P64[Hp - 8] = _sbSx1::P64;
           P64[Hp] = _sbSx2::P64;
           I64[Sp - 24] = block_cbTIP_info;
           R2 = _sbSx1::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbSx3::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbTIP() //  [R1]
         { info_tbl: [(cbTIP,
                       label: block_cbTIP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTIP: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.861344574 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedArrow_closure" {
     Control.Applicative.$fFunctorWrappedArrow_closure:
         const Control.Applicative.$fFunctorWrappedArrow_info;
 },
 sat_sbSxa_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTJp,
                       label: sat_sbSxa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTJp: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fFunctorWrappedArrow1_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSx9_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTJx,
                       label: sat_sbSx9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTJx: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fFunctorWrappedArrow2_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fFunctorWrappedArrow_entry() //  [R2]
         { info_tbl: [(cbTJB,
                       label: Control.Applicative.$fFunctorWrappedArrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTJB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbTJF; else goto cbTJE;
       cbTJF: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Applicative.$fFunctorWrappedArrow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTJE: // global
           I64[Hp - 48] = sat_sbSxa_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sbSx9_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.868485891 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow2_closure" {
     Control.Applicative.$fAlternativeWrappedArrow2_closure:
         const Control.Applicative.$fAlternativeWrappedArrow2_info;
 },
 sat_sbSxi_entry() //  [R1]
         { info_tbl: [(cbTK1,
                       label: sat_sbSxi_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTK1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbTK2; else goto cbTK3;
       cbTK2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTK3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Arrow.&&&_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbSxg_entry() //  [R1, R2]
         { info_tbl: [(cbTKd,
                       label: sat_sbSxg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTKd: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Tuple.uncurry_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSxh_entry() //  [R1]
         { info_tbl: [(cbTKg,
                       label: sat_sbSxh_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTKg: // global
           _sbSxh::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbTKh; else goto cbTKi;
       cbTKi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbTKk; else goto cbTKj;
       cbTKk: // global
           HpAlloc = 16;
           goto cbTKh;
       cbTKh: // global
           R1 = _sbSxh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTKj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSxh::P64;
           _sbSxb::P64 = P64[_sbSxh::P64 + 16];
           _sbSxc::P64 = P64[_sbSxh::P64 + 24];
           I64[Hp - 8] = sat_sbSxg_info;
           P64[Hp] = _sbSxc::P64;
           R2 = _sbSxb::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow2_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cbTKn,
                       label: Control.Applicative.$fAlternativeWrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTKn: // global
           _sbSxe::P64 = R5;
           _sbSxd::P64 = R4;
           _sbSxc::P64 = R3;
           _sbSxb::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbTKo; else goto cbTKp;
       cbTKp: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbTKr; else goto cbTKq;
       cbTKr: // global
           HpAlloc = 72;
           goto cbTKo;
       cbTKo: // global
           R5 = _sbSxe::P64;
           R4 = _sbSxd::P64;
           R3 = _sbSxc::P64;
           R2 = _sbSxb::P64;
           R1 = Control.Applicative.$fAlternativeWrappedArrow2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTKq: // global
           I64[Hp - 64] = sat_sbSxi_info;
           P64[Hp - 48] = _sbSxb::P64;
           P64[Hp - 40] = _sbSxd::P64;
           P64[Hp - 32] = _sbSxe::P64;
           I64[Hp - 24] = sat_sbSxh_info;
           P64[Hp - 8] = _sbSxb::P64;
           P64[Hp] = _sbSxc::P64;
           I64[Sp - 24] = block_cbTKl_info;
           R2 = _sbSxb::P64;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbTKl() //  [R1]
         { info_tbl: [(cbTKl,
                       label: block_cbTKl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTKl: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbTJX::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbTJX::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.880655463 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow5_closure" {
     Control.Applicative.$fApplicativeWrappedArrow5_closure:
         const Control.Applicative.$fApplicativeWrappedArrow5_info;
 },
 sat_sbSxm_entry() //  [R1]
         { info_tbl: [(cbTL3,
                       label: sat_sbSxm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTL3: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fApplicativeWrappedArrow5_entry() //  [R2, R3]
         { info_tbl: [(cbTL6,
                       label: Control.Applicative.$fApplicativeWrappedArrow5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTL6: // global
           _sbSxk::P64 = R3;
           _sbSxj::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbTL7; else goto cbTL8;
       cbTL8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbTLa; else goto cbTL9;
       cbTLa: // global
           HpAlloc = 16;
           goto cbTL7;
       cbTL7: // global
           R3 = _sbSxk::P64;
           R2 = _sbSxj::P64;
           R1 = Control.Applicative.$fApplicativeWrappedArrow5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTL9: // global
           I64[Hp - 8] = sat_sbSxm_info;
           P64[Hp] = _sbSxk::P64;
           R2 = _sbSxj::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Arrow.arr_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.886330698 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow4_closure" {
     Control.Applicative.$fApplicativeWrappedArrow4_closure:
         const Control.Applicative.$fApplicativeWrappedArrow4_info;
 },
 Control.Applicative.$fApplicativeWrappedArrow4_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbTLo,
                       label: Control.Applicative.$fApplicativeWrappedArrow4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTLo: // global
           R5 = R4;
           R4 = R3;
           R3 = GHC.Base.breakpoint_closure+1;
           R2 = R2;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.889601508 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow3_closure" {
     Control.Applicative.$fApplicativeWrappedArrow3_closure:
         const Control.Applicative.$fApplicativeWrappedArrow3_info;
 },
 Control.Applicative.$fApplicativeWrappedArrow3_entry() //  [R3]
         { info_tbl: [(cbTLz,
                       label: Control.Applicative.$fApplicativeWrappedArrow3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTLz: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.893193982 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow2_closure" {
     Control.Applicative.$fApplicativeWrappedArrow2_closure:
         const Control.Applicative.$fApplicativeWrappedArrow2_info;
 },
 sat_sbSxu_entry() //  [R1]
         { info_tbl: [(cbTLS,
                       label: sat_sbSxu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTLS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbTLT; else goto cbTLU;
       cbTLT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTLU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Applicative.$fApplicativeWrappedArrow3_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSxv_entry() //  [R1]
         { info_tbl: [(cbTLX,
                       label: sat_sbSxv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTLX: // global
           _sbSxv::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbTLY; else goto cbTLZ;
       cbTLZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTM1; else goto cbTM0;
       cbTM1: // global
           HpAlloc = 24;
           goto cbTLY;
       cbTLY: // global
           R1 = _sbSxv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTM0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSxv::P64;
           _sbSxq::P64 = P64[_sbSxv::P64 + 16];
           _sbSxr::P64 = P64[_sbSxv::P64 + 24];
           I64[Hp - 16] = sat_sbSxu_info;
           P64[Hp] = _sbSxq::P64;
           I64[Sp - 40] = block_cbTLV_info;
           R2 = _sbSxq::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbSxr::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbTLV() //  [R1]
         { info_tbl: [(cbTLV,
                       label: block_cbTLV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTLV: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeWrappedArrow2_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbTM5,
                       label: Control.Applicative.$fApplicativeWrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTM5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbTM9; else goto cbTM8;
       cbTM9: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedArrow2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTM8: // global
           I64[Hp - 24] = sat_sbSxv_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R5 = R4;
           R4 = Hp - 24;
           R3 = GHC.Base.breakpoint_closure+1;
           R2 = R2;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.902564372 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow1_closure" {
     Control.Applicative.$fApplicativeWrappedArrow1_closure:
         const Control.Applicative.$fApplicativeWrappedArrow1_info;
 },
 Control.Applicative.$fApplicativeWrappedArrow1_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbTMu,
                       label: Control.Applicative.$fApplicativeWrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTMu: // global
           R5 = R4;
           R4 = R3;
           R3 = GHC.Base.const_closure+2;
           R2 = R2;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.906936262 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow_closure" {
     Control.Applicative.$fApplicativeWrappedArrow_closure:
         const Control.Applicative.$fApplicativeWrappedArrow_info;
 },
 sat_sbSxD_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTMK,
                       label: sat_sbSxD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTMK: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedArrow1_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSxC_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTMS,
                       label: sat_sbSxC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTMS: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedArrow2_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSxB_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbTN0,
                       label: sat_sbSxB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTN0: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSxA_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTN8,
                       label: sat_sbSxA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTN8: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedArrow4_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSxz_entry() //  [R1, R2]
         { info_tbl: [(cbTNg,
                       label: sat_sbSxz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTNg: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fApplicativeWrappedArrow5_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSxy_entry() //  [R1]
         { info_tbl: [(cbTNn,
                       label: sat_sbSxy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTNn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTNo; else goto cbTNp;
       cbTNo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTNp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fFunctorWrappedArrow_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeWrappedArrow_entry() //  [R2]
         { info_tbl: [(cbTNr,
                       label: Control.Applicative.$fApplicativeWrappedArrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTNr: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cbTNv; else goto cbTNu;
       cbTNv: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedArrow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbTNu: // global
           I64[Hp - 152] = sat_sbSxD_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbSxC_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbSxB_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbSxA_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbSxz_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbSxy_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 87;
           P64[Hp - 24] = Hp - 102;
           P64[Hp - 16] = Hp - 117;
           P64[Hp - 8] = Hp - 134;
           P64[Hp] = Hp - 150;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.921533768 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_closure" {
     Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_closure:
         const Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_info;
 },
 sat_sbSxG_entry() //  [R1]
         { info_tbl: [(cbTO8,
                       label: sat_sbSxG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTO8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTO9; else goto cbTOa;
       cbTO9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTOa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_entry() //  [R2,
                                                                            R3]
         { info_tbl: [(cbTOb,
                       label: Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTOb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTOf; else goto cbTOe;
       cbTOf: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTOe: // global
           I64[Hp - 16] = sat_sbSxG_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Applicative.$fApplicativeWrappedArrow_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.926890735 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow1_closure" {
     Control.Applicative.$fAlternativeWrappedArrow1_closure:
         const Control.Applicative.$fAlternativeWrappedArrow1_info;
 },
 Control.Applicative.$fAlternativeWrappedArrow1_entry() //  []
         { info_tbl: [(cbTOs,
                       label: Control.Applicative.$fAlternativeWrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTOs: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.930898617 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow_$csome_closure" {
     Control.Applicative.$fAlternativeWrappedArrow_$csome_closure:
         const Control.Applicative.$fAlternativeWrappedArrow_$csome_info;
 },
 sat_sbSxN_entry() //  [R1]
         { info_tbl: [(cbTOU,
                       label: sat_sbSxN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTOU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbTOV; else goto cbTOW;
       cbTOV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTOW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Applicative.$fAlternativeWrappedArrow1_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSxO_entry() //  [R1]
         { info_tbl: [(cbTOX,
                       label: sat_sbSxO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTOX: // global
           _sbSxO::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbTOY; else goto cbTOZ;
       cbTOZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTP1; else goto cbTP0;
       cbTP1: // global
           HpAlloc = 24;
           goto cbTOY;
       cbTOY: // global
           R1 = _sbSxO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTP0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSxO::P64;
           _sbSxJ::P64 = P64[_sbSxO::P64 + 16];
           _sbSxL::P64 = P64[_sbSxO::P64 + 24];
           _sbSxM::P64 = P64[_sbSxO::P64 + 32];
           I64[Hp - 16] = sat_sbSxN_info;
           P64[Hp] = _sbSxM::P64;
           R2 = _sbSxJ::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbSxL::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call Control.Arrow.<+>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 some_v_sbSxL_entry() //  [R1]
         { info_tbl: [(cbTP2,
                       label: some_v_sbSxL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTP2: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbTP3; else goto cbTP4;
       cbTP3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTP4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cbTOI_info;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = R1;
           Sp = Sp - 48;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbTOI() //  [R1]
         { info_tbl: [(cbTOI,
                       label: block_cbTOI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTOI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbTP7; else goto cbTP6;
       cbTP7: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbTP6: // global
           I64[Hp - 32] = sat_sbSxO_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R5 = Hp - 32;
           R4 = P64[Sp + 16];
           R3 = GHC.Types.:_closure+2;
           R2 = R1;
           Sp = Sp + 32;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow_$csome_entry() //  [R2,
                                                                   R3, R4]
         { info_tbl: [(cbTP8,
                       label: Control.Applicative.$fAlternativeWrappedArrow_$csome_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTP8: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbTPc; else goto cbTPb;
       cbTPc: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedArrow_$csome_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTPb: // global
           I64[Hp - 32] = some_v_sbSxL_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.943304356 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow_$cmany_closure" {
     Control.Applicative.$fAlternativeWrappedArrow_$cmany_closure:
         const Control.Applicative.$fAlternativeWrappedArrow_$cmany_info;
 },
 $dApplicative_sbSxT_entry() //  [R1]
         { info_tbl: [(cbTPN,
                       label: $dApplicative_sbSxT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTPN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTPO; else goto cbTPP;
       cbTPO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTPP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSxV_entry() //  [R1]
         { info_tbl: [(cbTPU,
                       label: sat_sbSxV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTPU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbTPV; else goto cbTPW;
       cbTPV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTPW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Applicative.$fAlternativeWrappedArrow1_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSxU_entry() //  [R1]
         { info_tbl: [(cbTQ1,
                       label: sat_sbSxU_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTQ1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTQ2; else goto cbTQ3;
       cbTQ2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTQ3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 24];
           R4 = P64[R1 + 16];
           R3 = GHC.Types.:_closure+2;
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 many_v_sbSxS_entry() //  [R1]
         { info_tbl: [(cbTQ4,
                       label: many_v_sbSxS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTQ4: // global
           _sbSxS::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbTQ5; else goto cbTQ6;
       cbTQ6: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbTQ8; else goto cbTQ7;
       cbTQ8: // global
           HpAlloc = 88;
           goto cbTQ5;
       cbTQ5: // global
           R1 = _sbSxS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTQ7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSxS::P64;
           _sbSxP::P64 = P64[_sbSxS::P64 + 16];
           _sbSxQ::P64 = P64[_sbSxS::P64 + 24];
           _sbSxR::P64 = P64[_sbSxS::P64 + 32];
           I64[Hp - 80] = $dApplicative_sbSxT_info;
           P64[Hp - 64] = _sbSxP::P64;
           I64[Hp - 56] = sat_sbSxV_info;
           _cbTPJ::P64 = Hp - 80;
           P64[Hp - 40] = _cbTPJ::P64;
           I64[Hp - 32] = sat_sbSxU_info;
           P64[Hp - 16] = _sbSxR::P64;
           P64[Hp - 8] = _sbSxS::P64;
           P64[Hp] = _cbTPJ::P64;
           R2 = _sbSxQ::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call Control.Arrow.<+>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow_$cmany_entry() //  [R2,
                                                                   R3, R4]
         { info_tbl: [(cbTQ9,
                       label: Control.Applicative.$fAlternativeWrappedArrow_$cmany_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTQ9: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbTQd; else goto cbTQc;
       cbTQd: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedArrow_$cmany_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTQc: // global
           I64[Hp - 32] = many_v_sbSxS_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.956391678 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow_closure" {
     Control.Applicative.$fAlternativeWrappedArrow_closure:
         const Control.Applicative.$fAlternativeWrappedArrow_info;
 },
 sat_sbSy4_entry() //  [R1, R2]
         { info_tbl: [(cbTQJ,
                       label: sat_sbSy4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTQJ: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Applicative.$fAlternativeWrappedArrow_$cmany_entry(R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSy3_entry() //  [R1, R2]
         { info_tbl: [(cbTQR,
                       label: sat_sbSy3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTQR: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Applicative.$fAlternativeWrappedArrow_$csome_entry(R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSy2_entry() //  [R1, R2, R3]
         { info_tbl: [(cbTQZ,
                       label: sat_sbSy2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTQZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbTR0; else goto cbTR1;
       cbTR0: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTR1: // global
           _sbSy0::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbSy0::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Control.Arrow.<+>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbSxZ_entry() //  [R1]
         { info_tbl: [(cbTR6,
                       label: sat_sbSxZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTR6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTR7; else goto cbTR8;
       cbTR7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTR8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.zeroArrow_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSxY_entry() //  [R1]
         { info_tbl: [(cbTRd,
                       label: sat_sbSxY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTRd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTRe; else goto cbTRf;
       cbTRe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTRf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_entry(R3,
                                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow_entry() //  [R2, R3]
         { info_tbl: [(cbTRh,
                       label: Control.Applicative.$fAlternativeWrappedArrow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTRh: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cbTRl; else goto cbTRk;
       cbTRl: // global
           HpAlloc = 168;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedArrow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTRk: // global
           I64[Hp - 160] = sat_sbSy4_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sbSy3_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sbSy2_info;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_sbSxZ_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbSxY_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 96;
           P64[Hp - 16] = Hp - 110;
           P64[Hp - 8] = Hp - 135;
           P64[Hp] = Hp - 159;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.969541372 UTC

[section ""data" . Control.Applicative.$wunsafeDrop_closure" {
     Control.Applicative.$wunsafeDrop_closure:
         const Control.Applicative.$wunsafeDrop_info;
 },
 Control.Applicative.$wunsafeDrop_entry() //  [R2, R3]
         { info_tbl: [(cbTRZ,
                       label: Control.Applicative.$wunsafeDrop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTRZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbTS0; else goto ubTSe;
       cbTS0: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$wunsafeDrop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ubTSe: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cbTRP() args: 0, res: 0, upd: 0;
     }
 },
 _cbTRP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTRP: // global
           I64[Sp - 8] = block_cbTRS_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubTSg; else goto cbTRT;
       ubTSg: // global
           call _cbTRS(R1) args: 0, res: 0, upd: 0;
       cbTRT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTRS() //  [R1]
         { info_tbl: [(cbTRS,
                       label: block_cbTRS_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTRS: // global
           if (R1 & 7 == 1) goto cbTRW; else goto cbTRX;
       cbTRW: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbTRX: // global
           _sbSy9::P64 = P64[R1 + 14];
           _sbSya::I64 = I64[Sp + 8];
           if (_sbSya::I64 != 1) goto cbTSa; else goto cbTSb;
       cbTSa: // global
           I64[Sp + 8] = _sbSya::I64 - 1;
           P64[Sp + 16] = _sbSy9::P64;
           Sp = Sp + 8;
           call _cbTRP() args: 0, res: 0, upd: 0;
       cbTSb: // global
           R1 = _sbSy9::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.976595834 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList2_closure" {
     Control.Applicative.$fAlternativeZipList2_closure:
         const Control.Applicative.$fAlternativeZipList2_info;
 },
 sat_sbSyg_entry() //  [R1]
         { info_tbl: [(cbTSK,
                       label: sat_sbSyg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTSK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTSL; else goto cbTSM;
       cbTSL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTSM: // global
           I64[Sp - 16] = block_cbTSI_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbTSI() //  [R1]
         { info_tbl: [(cbTSI,
                       label: block_cbTSI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTSI: // global
           _sbSyd::P64 = P64[Sp + 8];
           if (%MO_S_Gt_W64(R1, 0)) goto cbTST; else goto cbTSU;
       cbTST: // global
           R3 = _sbSyd::P64;
           R2 = R1;
           Sp = Sp + 16;
           call Control.Applicative.$wunsafeDrop_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       cbTSU: // global
           R1 = _sbSyd::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fAlternativeZipList2_entry() //  [R2, R3]
         { info_tbl: [(cbTSV,
                       label: Control.Applicative.$fAlternativeZipList2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTSV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbTSZ; else goto cbTSY;
       cbTSZ: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeZipList2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTSY: // global
           I64[Hp - 24] = sat_sbSyg_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = R2;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.983940985 UTC

[section ""data" . Control.Applicative.$fGeneric1ZipList1_closure" {
     Control.Applicative.$fGeneric1ZipList1_closure:
         const Control.Applicative.$fGeneric1ZipList1_info;
 },
 Control.Applicative.$fGeneric1ZipList1_entry() //  [R2]
         { info_tbl: [(cbTTi,
                       label: Control.Applicative.$fGeneric1ZipList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTTi: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.987415155 UTC

[section ""data" . Control.Applicative.$fGeneric1ZipList2_closure" {
     Control.Applicative.$fGeneric1ZipList2_closure:
         const Control.Applicative.$fGeneric1ZipList2_info;
 },
 Control.Applicative.$fGeneric1ZipList2_entry() //  [R2]
         { info_tbl: [(cbTTt,
                       label: Control.Applicative.$fGeneric1ZipList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTTt: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.991131072 UTC

[section ""data" . Control.Applicative.$fGeneric1ZipList_closure" {
     Control.Applicative.$fGeneric1ZipList_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Control.Applicative.$fGeneric1ZipList2_closure+1;
         const Control.Applicative.$fGeneric1ZipList1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.992861738 UTC

[section ""data" . Control.Applicative.$fGenericZipList1_closure" {
     Control.Applicative.$fGenericZipList1_closure:
         const Control.Applicative.$fGenericZipList1_info;
 },
 Control.Applicative.$fGenericZipList1_entry() //  [R2]
         { info_tbl: [(cbTTH,
                       label: Control.Applicative.$fGenericZipList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTTH: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.995969562 UTC

[section ""data" . Control.Applicative.$fGenericZipList2_closure" {
     Control.Applicative.$fGenericZipList2_closure:
         const Control.Applicative.$fGenericZipList2_info;
 },
 Control.Applicative.$fGenericZipList2_entry() //  [R2]
         { info_tbl: [(cbTTS,
                       label: Control.Applicative.$fGenericZipList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTTS: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:45.999256696 UTC

[section ""data" . Control.Applicative.$fGenericZipList_closure" {
     Control.Applicative.$fGenericZipList_closure:
         const GHC.Generics.C:Generic_con_info;
         const Control.Applicative.$fGenericZipList2_closure+1;
         const Control.Applicative.$fGenericZipList1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.0008892 UTC

[section ""data" . Control.Applicative.$fFoldableZipList_closure" {
     Control.Applicative.$fFoldableZipList_closure:
         const Data.Foldable.C:Foldable_con_info;
         const Data.Foldable.$fFoldableNonEmpty_$cfold1_closure+2;
         const Data.Foldable.$fFoldable[]_$cfoldMap_closure+3;
         const GHC.Base.foldr_closure+3;
         const Data.Foldable.$fFoldable[]_$cfoldr'_closure+3;
         const GHC.List.foldl_closure+3;
         const GHC.List.foldl'_closure+3;
         const GHC.List.foldr1_closure+2;
         const GHC.List.foldl1_closure+2;
         const GHC.Base.id_closure+1;
         const GHC.List.null_closure+1;
         const GHC.List.length_closure+1;
         const GHC.List.elem_closure+3;
         const GHC.List.maximum_closure+2;
         const GHC.List.minimum_closure+2;
         const GHC.List.sum_closure+1;
         const GHC.List.product_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.00280784 UTC

[section ""data" . Control.Applicative.$fFunctorZipList_closure" {
     Control.Applicative.$fFunctorZipList_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.map_closure+2;
         const GHC.Base.$fFunctor[]_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.005271983 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList6_closure" {
     Control.Applicative.$fApplicativeZipList6_closure:
         const Control.Applicative.$fApplicativeZipList6_info;
 },
 sat_sbSyu_entry() //  [R1]
         { info_tbl: [(cbTUo,
                       label: sat_sbSyu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTUo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTUp; else goto cbTUq;
       cbTUp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTUq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fApplicativeZipList6_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeZipList6_entry() //  [R2, R3]
         { info_tbl: [(cbTUv,
                       label: Control.Applicative.$fApplicativeZipList6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTUv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbTUw; else goto cbTUx;
       cbTUw: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeZipList6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTUx: // global
           I64[Sp - 16] = block_cbTU8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubTUR; else goto cbTU9;
       ubTUR: // global
           call _cbTU8(R1) args: 0, res: 0, upd: 0;
       cbTU9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTU8() //  [R1]
         { info_tbl: [(cbTU8,
                       label: block_cbTU8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTU8: // global
           if (R1 & 7 == 1) goto ubTUM; else goto cbTUt;
       ubTUM: // global
           Sp = Sp + 16;
           call _cbTUE() args: 0, res: 0, upd: 0;
       cbTUt: // global
           I64[Sp - 8] = block_cbTUe_info;
           _sbSyo::P64 = P64[R1 + 6];
           _sbSyp::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbSyp::P64;
           P64[Sp + 8] = _sbSyo::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubTUO; else goto cbTUf;
       ubTUO: // global
           call _cbTUe(R1) args: 0, res: 0, upd: 0;
       cbTUf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTUe() //  [R1]
         { info_tbl: [(cbTUe,
                       label: block_cbTUe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTUe: // global
           if (R1 & 7 == 1) goto ubTUN; else goto cbTUH;
       ubTUN: // global
           Sp = Sp + 24;
           call _cbTUE() args: 0, res: 0, upd: 0;
       cbTUH: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbTUK; else goto cbTUJ;
       cbTUK: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbTUJ: // global
           _sbSyr::P64 = P64[R1 + 6];
           _sbSys::P64 = P64[R1 + 14];
           I64[Hp - 80] = sat_sbSyu_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _sbSys::P64;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sbSyr::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbTUE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTUE: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.015840583 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList5_closure" {
     Control.Applicative.$fApplicativeZipList5_closure:
         const Control.Applicative.$fApplicativeZipList5_info;
 },
 Control.Applicative.$fApplicativeZipList5_entry() //  [R2, R3]
         { info_tbl: [(cbTVp,
                       label: Control.Applicative.$fApplicativeZipList5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTVp: // global
           R3 = R3;
           R2 = R2;
           call Control.Applicative.$fApplicativeZipList6_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.020159849 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList4_closure" {
     Control.Applicative.$fApplicativeZipList4_closure:
         const Control.Applicative.$fApplicativeZipList4_info;
 },
 sat_sbSyF_entry() //  [R1]
         { info_tbl: [(cbTVQ,
                       label: sat_sbSyF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTVQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTVR; else goto cbTVS;
       cbTVR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTVS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fApplicativeZipList4_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeZipList4_entry() //  [R2, R3]
         { info_tbl: [(cbTVX,
                       label: Control.Applicative.$fApplicativeZipList4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTVX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTVY; else goto cbTVZ;
       cbTVY: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeZipList4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTVZ: // global
           I64[Sp - 16] = block_cbTVA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubTWi; else goto cbTVB;
       ubTWi: // global
           call _cbTVA(R1) args: 0, res: 0, upd: 0;
       cbTVB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTVA() //  [R1]
         { info_tbl: [(cbTVA,
                       label: block_cbTVA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTVA: // global
           if (R1 & 7 == 1) goto ubTWd; else goto cbTVV;
       ubTWd: // global
           Sp = Sp + 16;
           call _cbTW6() args: 0, res: 0, upd: 0;
       cbTVV: // global
           I64[Sp] = block_cbTVG_info;
           _sbSyB::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbSyB::P64;
           if (R1 & 7 != 0) goto ubTWf; else goto cbTVH;
       ubTWf: // global
           call _cbTVG(R1) args: 0, res: 0, upd: 0;
       cbTVH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTVG() //  [R1]
         { info_tbl: [(cbTVG,
                       label: block_cbTVG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTVG: // global
           if (R1 & 7 == 1) goto ubTWe; else goto cbTW8;
       ubTWe: // global
           Sp = Sp + 16;
           call _cbTW6() args: 0, res: 0, upd: 0;
       cbTW8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbTWb; else goto cbTWa;
       cbTWb: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbTWa: // global
           _sbSyD::P64 = P64[R1 + 6];
           _sbSyE::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_sbSyF_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sbSyE::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sbSyD::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbTW6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTW6: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.033914084 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList3_closure" {
     Control.Applicative.$fApplicativeZipList3_closure:
         const Control.Applicative.$fApplicativeZipList3_info;
 },
 Control.Applicative.$fApplicativeZipList3_entry() //  [R2, R3]
         { info_tbl: [(cbTWO,
                       label: Control.Applicative.$fApplicativeZipList3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTWO: // global
           R3 = R3;
           R2 = R2;
           call Control.Applicative.$fApplicativeZipList4_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.038688004 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList2_closure" {
     Control.Applicative.$fApplicativeZipList2_closure:
         const Control.Applicative.$fApplicativeZipList2_info;
 },
 sat_sbSyQ_entry() //  [R1]
         { info_tbl: [(cbTXf,
                       label: sat_sbSyQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTXf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTXg; else goto cbTXh;
       cbTXg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTXh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fApplicativeZipList2_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeZipList2_entry() //  [R2, R3]
         { info_tbl: [(cbTXm,
                       label: Control.Applicative.$fApplicativeZipList2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTXm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbTXn; else goto cbTXo;
       cbTXn: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeZipList2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTXo: // global
           I64[Sp - 16] = block_cbTWZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubTXH; else goto cbTX0;
       ubTXH: // global
           call _cbTWZ(R1) args: 0, res: 0, upd: 0;
       cbTX0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTWZ() //  [R1]
         { info_tbl: [(cbTWZ,
                       label: block_cbTWZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTWZ: // global
           if (R1 & 7 == 1) goto ubTXC; else goto cbTXk;
       ubTXC: // global
           Sp = Sp + 16;
           call _cbTXv() args: 0, res: 0, upd: 0;
       cbTXk: // global
           I64[Sp - 8] = block_cbTX5_info;
           _sbSyL::P64 = P64[R1 + 6];
           _sbSyM::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbSyM::P64;
           P64[Sp + 8] = _sbSyL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubTXE; else goto cbTX6;
       ubTXE: // global
           call _cbTX5(R1) args: 0, res: 0, upd: 0;
       cbTX6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTX5() //  [R1]
         { info_tbl: [(cbTX5,
                       label: block_cbTX5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTX5: // global
           if (R1 & 7 == 1) goto ubTXD; else goto cbTXx;
       ubTXD: // global
           Sp = Sp + 24;
           call _cbTXv() args: 0, res: 0, upd: 0;
       cbTXx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbTXA; else goto cbTXz;
       cbTXA: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbTXz: // global
           _sbSyP::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_sbSyQ_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sbSyP::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbTXv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTXv: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.051400683 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList1_closure" {
     Control.Applicative.$fApplicativeZipList1_closure:
         const Control.Applicative.$fApplicativeZipList1_info;
 },
 Control.Applicative.$fApplicativeZipList1_entry() //  [R2, R3]
         { info_tbl: [(cbTYe,
                       label: Control.Applicative.$fApplicativeZipList1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTYe: // global
           R3 = R3;
           R2 = R2;
           call Control.Applicative.$fApplicativeZipList2_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.05522243 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList_closure" {
     Control.Applicative.$fApplicativeZipList_closure:
         const GHC.Base.C:Applicative_con_info;
         const Control.Applicative.$fFunctorZipList_closure+1;
         const GHC.List.repeat_closure+1;
         const Control.Applicative.$fApplicativeZipList5_closure+2;
         const GHC.List.zipWith_closure+3;
         const Control.Applicative.$fApplicativeZipList3_closure+2;
         const Control.Applicative.$fApplicativeZipList1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.057421333 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList_xs_closure" {
     Control.Applicative.$fAlternativeZipList_xs_closure:
         const :_con_info;
         const GHC.Types.[]_closure+1;
         const Control.Applicative.$fAlternativeZipList_xs_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.060299868 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList1_closure" {
     Control.Applicative.$fAlternativeZipList1_closure:
         const Control.Applicative.$fAlternativeZipList1_info;
 },
 sat_sbSz2_entry() //  [R1]
         { info_tbl: [(cbTYH,
                       label: sat_sbSz2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTYH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbTYI; else goto cbTYJ;
       cbTYI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTYJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeZipList1_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeZipList1_entry() //  [R2, R3]
         { info_tbl: [(cbTYO,
                       label: Control.Applicative.$fAlternativeZipList1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTYO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbTYP; else goto cbTYQ;
       cbTYP: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeZipList1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTYQ: // global
           I64[Sp - 16] = block_cbTYr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubTZa; else goto cbTYs;
       ubTZa: // global
           call _cbTYr(R1) args: 0, res: 0, upd: 0;
       cbTYs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTYr() //  [R1]
         { info_tbl: [(cbTYr,
                       label: block_cbTYr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTYr: // global
           if (R1 & 7 == 1) goto ubTZ5; else goto cbTYM;
       ubTZ5: // global
           Sp = Sp + 16;
           call _cbTYX() args: 0, res: 0, upd: 0;
       cbTYM: // global
           I64[Sp - 8] = block_cbTYx_info;
           _sbSyW::P64 = P64[R1 + 6];
           _sbSyX::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbSyX::P64;
           P64[Sp + 8] = _sbSyW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubTZ7; else goto cbTYy;
       ubTZ7: // global
           call _cbTYx(R1) args: 0, res: 0, upd: 0;
       cbTYy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTYx() //  [R1]
         { info_tbl: [(cbTYx,
                       label: block_cbTYx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTYx: // global
           if (R1 & 7 == 1) goto ubTZ6; else goto cbTZ0;
       ubTZ6: // global
           Sp = Sp + 24;
           call _cbTYX() args: 0, res: 0, upd: 0;
       cbTZ0: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbTZ3; else goto cbTZ2;
       cbTZ3: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbTZ2: // global
           _sbSyZ::P64 = P64[R1 + 6];
           _sbSz0::P64 = P64[R1 + 14];
           I64[Hp - 72] = sat_sbSz2_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _sbSz0::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sbSyZ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbTYX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTYX: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.072905529 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList_$csome_closure" {
     Control.Applicative.$fAlternativeZipList_$csome_closure:
         const Control.Applicative.$fAlternativeZipList_$csome_info;
 },
 sat_sbSz5_entry() //  [R1]
         { info_tbl: [(cbTZQ,
                       label: sat_sbSz5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTZQ: // global
           R3 = Control.Applicative.$fAlternativeZipList_xs_closure+2;
           R2 = P64[R1 + 16];
           call Control.Applicative.$fAlternativeZipList2_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 some_v_sbSz4_entry() //  [R1]
         { info_tbl: [(cbTZT,
                       label: some_v_sbSz4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTZT: // global
           _sbSz4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbTZU; else goto cbTZV;
       cbTZV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbTZX; else goto cbTZW;
       cbTZX: // global
           HpAlloc = 24;
           goto cbTZU;
       cbTZU: // global
           R1 = _sbSz4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbTZW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSz4::P64;
           _sbSz3::P64 = P64[_sbSz4::P64 + 16];
           I64[Hp - 16] = sat_sbSz5_info;
           P64[Hp] = _sbSz4::P64;
           R3 = Hp - 16;
           R2 = _sbSz3::P64;
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeZipList1_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeZipList_$csome_entry() //  [R2]
         { info_tbl: [(cbTZY,
                       label: Control.Applicative.$fAlternativeZipList_$csome_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTZY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbU02; else goto cbU01;
       cbU02: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeZipList_$csome_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbU01: // global
           I64[Hp - 16] = some_v_sbSz4_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.080461825 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList_$cmany_closure" {
     Control.Applicative.$fAlternativeZipList_$cmany_closure:
         const Control.Applicative.$fAlternativeZipList_$cmany_info;
 },
 many_v_sbSz7_entry() //  [R1]
         { info_tbl: [(cbU0q,
                       label: many_v_sbSz7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU0q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbU0r; else goto cbU0s;
       cbU0r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbU0s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbU0o_info;
           R3 = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Applicative.$fAlternativeZipList1_entry(R3,
                                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbU0o() //  [R1]
         { info_tbl: [(cbU0o,
                       label: block_cbU0o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU0o: // global
           R3 = Control.Applicative.$fAlternativeZipList_xs_closure+2;
           R2 = R1;
           Sp = Sp + 8;
           call Control.Applicative.$fAlternativeZipList2_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeZipList_$cmany_entry() //  [R2]
         { info_tbl: [(cbU0w,
                       label: Control.Applicative.$fAlternativeZipList_$cmany_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU0w: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbU0A; else goto cbU0z;
       cbU0A: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeZipList_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbU0z: // global
           I64[Hp - 16] = many_v_sbSz7_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.087249498 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList_closure" {
     Control.Applicative.$fAlternativeZipList_closure:
         const GHC.Base.C:Alternative_con_info;
         const Control.Applicative.$fApplicativeZipList_closure+1;
         const GHC.Types.[]_closure+1;
         const Control.Applicative.$fAlternativeZipList2_closure+2;
         const Control.Applicative.$fAlternativeZipList_$csome_closure+1;
         const Control.Applicative.$fAlternativeZipList_$cmany_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.089012658 UTC

[section ""cstring" . Control.Applicative.$fReadZipList11_bytes" {
     Control.Applicative.$fReadZipList11_bytes:
         I8[] [90,105,112,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.090846908 UTC

[section ""data" . Control.Applicative.$fReadZipList10_closure" {
     Control.Applicative.$fReadZipList10_closure:
         const Control.Applicative.$fReadZipList10_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Applicative.$fReadZipList10_entry() //  [R1]
         { info_tbl: [(cbU0W,
                       label: Control.Applicative.$fReadZipList10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU0W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbU0X; else goto cbU0Y;
       cbU0X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbU0Y: // global
           (_cbU0T::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbU0T::I64 == 0) goto cbU0V; else goto cbU0U;
       cbU0V: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbU0U: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbU0T::I64;
           R2 = Control.Applicative.$fReadZipList11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.094637681 UTC

[section ""data" . Control.Applicative.$fReadZipList_lexeme1_closure" {
     Control.Applicative.$fReadZipList_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Control.Applicative.$fReadZipList10_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.096282646 UTC

[section ""cstring" . Control.Applicative.$fReadZipList9_bytes" {
     Control.Applicative.$fReadZipList9_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.099024673 UTC

[section ""data" . Control.Applicative.$fReadZipList8_closure" {
     Control.Applicative.$fReadZipList8_closure:
         const Control.Applicative.$fReadZipList8_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Applicative.$fReadZipList8_entry() //  [R1]
         { info_tbl: [(cbU1e,
                       label: Control.Applicative.$fReadZipList8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU1e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbU1f; else goto cbU1g;
       cbU1f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbU1g: // global
           (_cbU1b::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbU1b::I64 == 0) goto cbU1d; else goto cbU1c;
       cbU1d: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbU1c: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbU1b::I64;
           R2 = Control.Applicative.$fReadZipList9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.102722611 UTC

[section ""data" . Control.Applicative.$fReadZipList_lexeme_closure" {
     Control.Applicative.$fReadZipList_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const Control.Applicative.$fReadZipList8_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.104404247 UTC

[section ""cstring" . Control.Applicative.$fReadZipList7_bytes" {
     Control.Applicative.$fReadZipList7_bytes:
         I8[] [103,101,116,90,105,112,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.106188716 UTC

[section ""data" . Control.Applicative.$fReadZipList6_closure" {
     Control.Applicative.$fReadZipList6_closure:
         const Control.Applicative.$fReadZipList6_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Applicative.$fReadZipList6_entry() //  [R1]
         { info_tbl: [(cbU1w,
                       label: Control.Applicative.$fReadZipList6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU1w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbU1x; else goto cbU1y;
       cbU1x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbU1y: // global
           (_cbU1t::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbU1t::I64 == 0) goto cbU1v; else goto cbU1u;
       cbU1v: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbU1u: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbU1t::I64;
           R2 = Control.Applicative.$fReadZipList7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.110149727 UTC

[section ""data" . Control.Applicative.$fReadZipList5_closure" {
     Control.Applicative.$fReadZipList5_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.111750581 UTC

[section ""cstring" . Control.Applicative.$fReadZipList4_bytes" {
     Control.Applicative.$fReadZipList4_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.113551711 UTC

[section ""data" . Control.Applicative.$fReadZipList3_closure" {
     Control.Applicative.$fReadZipList3_closure:
         const Control.Applicative.$fReadZipList3_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Applicative.$fReadZipList3_entry() //  [R1]
         { info_tbl: [(cbU1O,
                       label: Control.Applicative.$fReadZipList3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU1O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbU1P; else goto cbU1Q;
       cbU1P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbU1Q: // global
           (_cbU1L::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbU1L::I64 == 0) goto cbU1N; else goto cbU1M;
       cbU1N: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbU1M: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbU1L::I64;
           R2 = Control.Applicative.$fReadZipList4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.117312099 UTC

[section ""data" . Control.Applicative.$fReadZipList2_closure" {
     Control.Applicative.$fReadZipList2_closure:
         const Text.Read.Lex.Punc_con_info;
         const Control.Applicative.$fReadZipList3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.120749811 UTC

[section ""data" . Control.Applicative.$fReadZipList1_closure" {
     Control.Applicative.$fReadZipList1_closure:
         const Control.Applicative.$fReadZipList1_info;
         const 0;
 },
 lvl_sbSza_entry() //  [R1]
         { info_tbl: [(cbU27,
                       label: lvl_sbSza_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU27: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbU28; else goto cbU29;
       cbU28: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbU29: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readListPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_sbSzb_entry() //  [R1]
         { info_tbl: [(cbU2f,
                       label: ds_sbSzb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU2f: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzm_entry() //  [R1]
         { info_tbl: [(cbU2Q,
                       label: sat_sbSzm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU2Q: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzp_entry() //  [R1, R2]
         { info_tbl: [(cbU2W,
                       label: sat_sbSzp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU2W: // global
           _sbSzk::P64 = R2;
           _sbSzp::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cbU2X; else goto cbU2Y;
       cbU2Y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbU30; else goto cbU2Z;
       cbU30: // global
           HpAlloc = 24;
           goto cbU2X;
       cbU2X: // global
           R2 = _sbSzk::P64;
           R1 = _sbSzp::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbU2Z: // global
           _sbSze::P64 = P64[_sbSzp::P64 + 7];
           I64[Hp - 16] = sat_sbSzm_info;
           P64[Hp - 8] = _sbSze::P64;
           P64[Hp] = _sbSzk::P64;
           I64[Sp - 8] = block_cbU2T_info;
           R3 = Hp - 15;
           R2 = Control.Applicative.$fReadZipList2_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbU2T() //  [R1]
         { info_tbl: [(cbU2T,
                       label: block_cbU2T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU2T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbU33; else goto cbU32;
       cbU33: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbU32: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzq_entry() //  [R1, R2]
         { info_tbl: [(cbU34,
                       label: sat_sbSzq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU34: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbU38; else goto cbU37;
       cbU38: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbU37: // global
           _sbSzb::P64 = P64[R1 + 7];
           _sbSze::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sbSzp_info;
           P64[Hp] = _sbSze::P64;
           R5 = Hp - 7;
           R4 = Control.Applicative.$fReadZipList5_closure+1;
           R3 = _sbSzb::P64;
           R2 = Control.Applicative.$fReadZipList6_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzt_entry() //  [R1, R2]
         { info_tbl: [(cbU3c,
                       label: sat_sbSzt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU3c: // global
           _sbSzi::P64 = R2;
           _sbSzt::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cbU3d; else goto cbU3e;
       cbU3e: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbU3g; else goto cbU3f;
       cbU3g: // global
           HpAlloc = 24;
           goto cbU3d;
       cbU3d: // global
           R2 = _sbSzi::P64;
           R1 = _sbSzt::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbU3f: // global
           _sbSzb::P64 = P64[_sbSzt::P64 + 7];
           _sbSze::P64 = P64[_sbSzt::P64 + 15];
           I64[Hp - 16] = sat_sbSzq_info;
           P64[Hp - 8] = _sbSzb::P64;
           P64[Hp] = _sbSze::P64;
           I64[Sp - 8] = block_cbU39_info;
           R3 = Hp - 15;
           R2 = Control.Applicative.$fReadZipList_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbU39() //  [R1]
         { info_tbl: [(cbU39,
                       label: block_cbU39_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU39: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbU3j; else goto cbU3i;
       cbU3j: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbU3i: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzw_entry() //  [R1, R2, R3]
         { info_tbl: [(cbU3k,
                       label: sat_sbSzw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU3k: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbU3l; else goto cbU3m;
       cbU3l: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbU3m: // global
           I64[Sp - 24] = block_cbU2n_info;
           _sbSzb::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sbSzb::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubU3z; else goto cbU2o;
       ubU3z: // global
           call _cbU2n(R1) args: 0, res: 0, upd: 0;
       cbU2o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbU2n() //  [R1]
         { info_tbl: [(cbU2n,
                       label: block_cbU2n_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU2n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbU3p; else goto cbU3o;
       cbU3p: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbU3o: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto cbU3r; else goto cbU3v;
       cbU3r: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbU3v: // global
           I64[Hp - 16] = sat_sbSzt_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cbU3s_info;
           R3 = Hp - 15;
           R2 = Control.Applicative.$fReadZipList_lexeme1_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbU3s() //  [R1]
         { info_tbl: [(cbU3s,
                       label: block_cbU3s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU3s: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbU3y; else goto cbU3x;
       cbU3y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbU3x: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fReadZipList1_entry() //  [R2]
         { info_tbl: [(cbU3A,
                       label: Control.Applicative.$fReadZipList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU3A: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbU3E; else goto cbU3D;
       cbU3E: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbU3D: // global
           I64[Hp - 48] = lvl_sbSza_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_sbSzb_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sbSzw_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.146384808 UTC

[section ""data" . Control.Applicative.$fReadZipList_$creadsPrec_closure" {
     Control.Applicative.$fReadZipList_$creadsPrec_closure:
         const Control.Applicative.$fReadZipList_$creadsPrec_info;
         const 0;
 },
 ds_sbSzy_entry() //  [R1]
         { info_tbl: [(cbU4B,
                       label: ds_sbSzy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU4B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbU4C; else goto cbU4D;
       cbU4C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbU4D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSzA_entry() //  [R1]
         { info_tbl: [(cbU4N,
                       label: sat_sbSzA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU4N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbU4O; else goto cbU4P;
       cbU4O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbU4P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSzB_entry() //  [R1, R2]
         { info_tbl: [(cbU4Q,
                       label: sat_sbSzB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU4Q: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbU4U; else goto cbU4T;
       cbU4U: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbU4T: // global
           _sbSzy::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sbSzA_info;
           P64[Hp - 8] = _sbSzy::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fReadZipList_$creadsPrec_entry() //  [R2]
         { info_tbl: [(cbU4V,
                       label: Control.Applicative.$fReadZipList_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU4V: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbU4Z; else goto cbU4Y;
       cbU4Z: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbU4Y: // global
           I64[Hp - 32] = ds_sbSzy_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sbSzB_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.155929775 UTC

[section ""data" . Control.Applicative.$fReadZipList_$creadListPrec_closure" {
     Control.Applicative.$fReadZipList_$creadListPrec_closure:
         const Control.Applicative.$fReadZipList_$creadListPrec_info;
         const 0;
 },
 sat_sbSzD_entry() //  [R1]
         { info_tbl: [(cbU5p,
                       label: sat_sbSzD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU5p: // global
           R2 = P64[R1 + 16];
           call Control.Applicative.$fReadZipList1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fReadZipList_$creadListPrec_entry() //  [R2]
         { info_tbl: [(cbU5s,
                       label: Control.Applicative.$fReadZipList_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU5s: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbU5w; else goto cbU5v;
       cbU5w: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbU5v: // global
           I64[Hp - 16] = sat_sbSzD_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.161228443 UTC

[section ""data" . Control.Applicative.$fReadZipList_$creadList_closure" {
     Control.Applicative.$fReadZipList_$creadList_closure:
         const Control.Applicative.$fReadZipList_$creadList_info;
         const 0;
 },
 sat_sbSzF_entry() //  [R1]
         { info_tbl: [(cbU5Q,
                       label: sat_sbSzF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU5Q: // global
           R2 = P64[R1 + 16];
           call Control.Applicative.$fReadZipList1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzG_entry() //  [R1]
         { info_tbl: [(cbU5T,
                       label: sat_sbSzG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU5T: // global
           _sbSzG::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbU5U; else goto cbU5V;
       cbU5V: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbU5X; else goto cbU5W;
       cbU5X: // global
           HpAlloc = 24;
           goto cbU5U;
       cbU5U: // global
           R1 = _sbSzG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbU5W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSzG::P64;
           _sbSzE::P64 = P64[_sbSzG::P64 + 16];
           I64[Hp - 16] = sat_sbSzF_info;
           P64[Hp] = _sbSzE::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fReadZipList_$creadList_entry() //  [R2]
         { info_tbl: [(cbU5Y,
                       label: Control.Applicative.$fReadZipList_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU5Y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbU62; else goto cbU61;
       cbU62: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbU61: // global
           I64[Hp - 16] = sat_sbSzG_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.169501352 UTC

[section ""data" . Control.Applicative.$fReadZipList_closure" {
     Control.Applicative.$fReadZipList_closure:
         const Control.Applicative.$fReadZipList_info;
         const 0;
 },
 sat_sbSzL_entry() //  [R1]
         { info_tbl: [(cbU6m,
                       label: sat_sbSzL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU6m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbU6n; else goto cbU6o;
       cbU6n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbU6o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSzK_entry() //  [R1]
         { info_tbl: [(cbU6t,
                       label: sat_sbSzK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU6t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbU6u; else goto cbU6v;
       cbU6u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbU6v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSzJ_entry() //  [R1]
         { info_tbl: [(cbU6A,
                       label: sat_sbSzJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU6A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbU6B; else goto cbU6C;
       cbU6B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbU6C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSzI_entry() //  [R1]
         { info_tbl: [(cbU6H,
                       label: sat_sbSzI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU6H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbU6I; else goto cbU6J;
       cbU6I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbU6J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fReadZipList_entry() //  [R2]
         { info_tbl: [(cbU6L,
                       label: Control.Applicative.$fReadZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU6L: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbU6P; else goto cbU6O;
       cbU6P: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbU6O: // global
           I64[Hp - 128] = sat_sbSzL_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbSzK_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbSzJ_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbSzI_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.180865915 UTC

[section ""data" . Control.Applicative.$fEqZipList_closure" {
     Control.Applicative.$fEqZipList_closure:
         const Control.Applicative.$fEqZipList_info;
 },
 sat_sbSzO_entry() //  [R1, R2, R3]
         { info_tbl: [(cbU7o,
                       label: sat_sbSzO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU7o: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fEq[]_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzN_entry() //  [R1, R2, R3]
         { info_tbl: [(cbU7w,
                       label: sat_sbSzN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU7w: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fEq[]_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fEqZipList_entry() //  [R2]
         { info_tbl: [(cbU7A,
                       label: Control.Applicative.$fEqZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU7A: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbU7E; else goto cbU7D;
       cbU7E: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Applicative.$fEqZipList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbU7D: // global
           I64[Hp - 48] = sat_sbSzO_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sbSzN_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.187926629 UTC

[section ""data" . Control.Applicative.$fOrdZipList_$cp1Ord_closure" {
     Control.Applicative.$fOrdZipList_$cp1Ord_closure:
         const Control.Applicative.$fOrdZipList_$cp1Ord_info;
 },
 sat_sbSzQ_entry() //  [R1]
         { info_tbl: [(cbU80,
                       label: sat_sbSzQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU80: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbU81; else goto cbU82;
       cbU81: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbU82: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fOrdZipList_$cp1Ord_entry() //  [R2]
         { info_tbl: [(cbU83,
                       label: Control.Applicative.$fOrdZipList_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU83: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbU87; else goto cbU86;
       cbU87: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fOrdZipList_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbU86: // global
           I64[Hp - 16] = sat_sbSzQ_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Applicative.$fEqZipList_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.194462098 UTC

[section ""data" . Control.Applicative.$fOrdZipList_closure" {
     Control.Applicative.$fOrdZipList_closure:
         const Control.Applicative.$fOrdZipList_info;
 },
 sat_sbSzZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cbU8p,
                       label: sat_sbSzZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU8p: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzY_entry() //  [R1, R2, R3]
         { info_tbl: [(cbU8x,
                       label: sat_sbSzY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU8x: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzX_entry() //  [R1, R2, R3]
         { info_tbl: [(cbU8F,
                       label: sat_sbSzX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU8F: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzW_entry() //  [R1, R2, R3]
         { info_tbl: [(cbU8N,
                       label: sat_sbSzW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU8N: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$c>_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzV_entry() //  [R1, R2, R3]
         { info_tbl: [(cbU8V,
                       label: sat_sbSzV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU8V: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzU_entry() //  [R1, R2, R3]
         { info_tbl: [(cbU93,
                       label: sat_sbSzU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU93: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzT_entry() //  [R1, R2, R3]
         { info_tbl: [(cbU9b,
                       label: sat_sbSzT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU9b: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSzS_entry() //  [R1]
         { info_tbl: [(cbU9i,
                       label: sat_sbSzS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU9i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbU9j; else goto cbU9k;
       cbU9j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbU9k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fOrdZipList_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fOrdZipList_entry() //  [R2]
         { info_tbl: [(cbU9m,
                       label: Control.Applicative.$fOrdZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU9m: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cbU9q; else goto cbU9p;
       cbU9q: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = Control.Applicative.$fOrdZipList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbU9p: // global
           I64[Hp - 200] = sat_sbSzZ_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sbSzY_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_sbSzX_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbSzW_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbSzV_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbSzU_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbSzT_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbSzS_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.211921793 UTC

[section ""cstring" . Control.Applicative.$fShowZipList3_bytes" {
     Control.Applicative.$fShowZipList3_bytes:
         I8[] [90,105,112,76,105,115,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.213610056 UTC

[section ""cstring" . Control.Applicative.$fShowZipList2_bytes" {
     Control.Applicative.$fShowZipList2_bytes:
         I8[] [103,101,116,90,105,112,76,105,115,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.217113417 UTC

[section ""data" . Control.Applicative.$w$cshowsPrec_closure" {
     Control.Applicative.$w$cshowsPrec_closure:
         const Control.Applicative.$w$cshowsPrec_info;
 },
 f_sbSA3_entry() //  [R1]
         { info_tbl: [(cbUad,
                       label: f_sbSA3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUad: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbUae; else goto cbUaf;
       cbUae: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUaf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.showList_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSA6_entry() //  [R1]
         { info_tbl: [(cbUaA,
                       label: sat_sbSA6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUaA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUaB; else goto cbUaC;
       cbUaB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUaC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Control.Applicative.$fReadZipList4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSA7_entry() //  [R1]
         { info_tbl: [(cbUaD,
                       label: sat_sbSA7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUaD: // global
           _sbSA7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbUaE; else goto cbUaF;
       cbUaF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUaH; else goto cbUaG;
       cbUaH: // global
           HpAlloc = 24;
           goto cbUaE;
       cbUaE: // global
           R1 = _sbSA7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUaG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSA7::P64;
           _sbSA3::P64 = P64[_sbSA7::P64 + 16];
           _sbSA5::P64 = P64[_sbSA7::P64 + 24];
           I64[Hp - 16] = sat_sbSA6_info;
           P64[Hp] = _sbSA5::P64;
           R2 = Hp - 16;
           R1 = _sbSA3::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSA8_entry() //  [R1]
         { info_tbl: [(cbUaI,
                       label: sat_sbSA8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUaI: // global
           _sbSA8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbUaJ; else goto cbUaK;
       cbUaK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbUaM; else goto cbUaL;
       cbUaM: // global
           HpAlloc = 32;
           goto cbUaJ;
       cbUaJ: // global
           R1 = _sbSA8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUaL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSA8::P64;
           _sbSA3::P64 = P64[_sbSA8::P64 + 16];
           _sbSA5::P64 = P64[_sbSA8::P64 + 24];
           I64[Hp - 24] = sat_sbSA7_info;
           P64[Hp - 8] = _sbSA3::P64;
           P64[Hp] = _sbSA5::P64;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSA9_entry() //  [R1, R2]
         { info_tbl: [(cbUaN,
                       label: sat_sbSA9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUaN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbUaR; else goto cbUaQ;
       cbUaR: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUaQ: // global
           _sbSA3::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sbSA8_info;
           P64[Hp - 8] = _sbSA3::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSAc_entry() //  [R1]
         { info_tbl: [(cbUbf,
                       label: sat_sbSAc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUbf: // global
           _sbSAc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbUbg; else goto cbUbh;
       cbUbh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUbj; else goto cbUbi;
       cbUbj: // global
           HpAlloc = 24;
           goto cbUbg;
       cbUbg: // global
           R1 = _sbSAc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUbi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSAc::P64;
           _sbSAa::P64 = P64[_sbSAc::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sbSAa::P64;
           R3 = Hp - 14;
           R2 = Control.Applicative.$fReadZipList4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAd_entry() //  [R1]
         { info_tbl: [(cbUbk,
                       label: sat_sbSAd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUbk: // global
           _sbSAd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbUbl; else goto cbUbm;
       cbUbm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUbo; else goto cbUbn;
       cbUbo: // global
           HpAlloc = 24;
           goto cbUbl;
       cbUbl: // global
           R1 = _sbSAd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUbn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSAd::P64;
           _sbSA3::P64 = P64[_sbSAd::P64 + 16];
           _sbSAa::P64 = P64[_sbSAd::P64 + 24];
           I64[Hp - 16] = sat_sbSAc_info;
           P64[Hp] = _sbSAa::P64;
           R2 = Hp - 16;
           R1 = _sbSA3::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAe_entry() //  [R1]
         { info_tbl: [(cbUbp,
                       label: sat_sbSAe_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUbp: // global
           _sbSAe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbUbq; else goto cbUbr;
       cbUbr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbUbt; else goto cbUbs;
       cbUbt: // global
           HpAlloc = 32;
           goto cbUbq;
       cbUbq: // global
           R1 = _sbSAe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUbs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSAe::P64;
           _sbSA3::P64 = P64[_sbSAe::P64 + 16];
           _sbSAa::P64 = P64[_sbSAe::P64 + 24];
           I64[Hp - 24] = sat_sbSAd_info;
           P64[Hp - 8] = _sbSA3::P64;
           P64[Hp] = _sbSAa::P64;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAf_entry() //  [R1]
         { info_tbl: [(cbUbu,
                       label: sat_sbSAf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUbu: // global
           _sbSAf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbUbv; else goto cbUbw;
       cbUbw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbUby; else goto cbUbx;
       cbUby: // global
           HpAlloc = 32;
           goto cbUbv;
       cbUbv: // global
           R1 = _sbSAf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUbx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSAf::P64;
           _sbSA3::P64 = P64[_sbSAf::P64 + 16];
           _sbSAa::P64 = P64[_sbSAf::P64 + 24];
           I64[Hp - 24] = sat_sbSAe_info;
           P64[Hp - 8] = _sbSA3::P64;
           P64[Hp] = _sbSAa::P64;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAg_entry() //  [R1, R2]
         { info_tbl: [(cbUbA,
                       label: sat_sbSAg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUbA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbUbE; else goto cbUbD;
       cbUbE: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUbD: // global
           _sbSA3::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_sbSAf_info;
           P64[Hp - 32] = _sbSA3::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cbUbI,
                       label: Control.Applicative.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUbI: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbUbM; else goto cbUbL;
       cbUbM: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUbL: // global
           I64[Hp - 40] = f_sbSA3_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _cbUa9::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto cbUbG; else goto cbUbH;
       cbUbG: // global
           I64[Hp - 8] = sat_sbSA9_info;
           P64[Hp] = _cbUa9::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbUbH: // global
           I64[Hp - 8] = sat_sbSAg_info;
           P64[Hp] = _cbUa9::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.242006992 UTC

[section ""data" . Control.Applicative.$fShowZipList_$cshowsPrec_closure" {
     Control.Applicative.$fShowZipList_$cshowsPrec_closure:
         const Control.Applicative.$fShowZipList_$cshowsPrec_info;
 },
 Control.Applicative.$fShowZipList_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbUcF,
                       label: Control.Applicative.$fShowZipList_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUcF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbUcG; else goto cbUcH;
       cbUcG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fShowZipList_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUcH: // global
           I64[Sp - 24] = block_cbUcC_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubUcL; else goto cbUcD;
       ubUcL: // global
           call _cbUcC(R1) args: 0, res: 0, upd: 0;
       cbUcD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbUcC() //  [R1]
         { info_tbl: [(cbUcC,
                       label: block_cbUcC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUcC: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Control.Applicative.$w$cshowsPrec_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.248567707 UTC

[section ""data" . Control.Applicative.$fShowZipList_$cshow_closure" {
     Control.Applicative.$fShowZipList_$cshow_closure:
         const Control.Applicative.$fShowZipList_$cshow_info;
         const 0;
 },
 sat_sbSAo_entry() //  [R1]
         { info_tbl: [(cbUd7,
                       label: sat_sbSAo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUd7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbUd8; else goto cbUd9;
       cbUd8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUd9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Control.Applicative.$fReadZipList3_closure;
           Sp = Sp - 40;
           call GHC.Show.showList_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbSAp_entry() //  [R1]
         { info_tbl: [(cbUda,
                       label: sat_sbSAp_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUda: // global
           _sbSAp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbUdb; else goto cbUdc;
       cbUdc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbUde; else goto cbUdd;
       cbUde: // global
           HpAlloc = 32;
           goto cbUdb;
       cbUdb: // global
           R1 = _sbSAp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUdd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbSAp::P64;
           _sbSAm::P64 = P64[_sbSAp::P64 + 16];
           _sbSAn::P64 = P64[_sbSAp::P64 + 24];
           I64[Hp - 24] = sat_sbSAo_info;
           P64[Hp - 8] = _sbSAm::P64;
           P64[Hp] = _sbSAn::P64;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fShowZipList_$cshow_entry() //  [R2, R3]
         { info_tbl: [(cbUdf,
                       label: Control.Applicative.$fShowZipList_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUdf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbUdj; else goto cbUdi;
       cbUdj: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fShowZipList_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUdi: // global
           I64[Hp - 24] = sat_sbSAp_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.25633045 UTC

[section ""data" . Control.Applicative.$fShowZipList1_closure" {
     Control.Applicative.$fShowZipList1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.25839306 UTC

[section ""data" . Control.Applicative.$fShowZipList_$cshowList_closure" {
     Control.Applicative.$fShowZipList_$cshowList_closure:
         const Control.Applicative.$fShowZipList_$cshowList_info;
 },
 sat_sbSAu_entry() //  [R1, R2]
         { info_tbl: [(cbUdH,
                       label: sat_sbSAu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUdH: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Control.Applicative.$w$cshowsPrec_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fShowZipList_$cshowList_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cbUdK,
                       label: Control.Applicative.$fShowZipList_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUdK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbUdO; else goto cbUdN;
       cbUdO: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fShowZipList_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUdN: // global
           I64[Hp - 8] = sat_sbSAu_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.264128593 UTC

[section ""data" . Control.Applicative.$fShowZipList_closure" {
     Control.Applicative.$fShowZipList_closure:
         const Control.Applicative.$fShowZipList_info;
         const 0;
 },
 sat_sbSAy_entry() //  [R1, R2, R3]
         { info_tbl: [(cbUe5,
                       label: sat_sbSAy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUe5: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fShowZipList_$cshowList_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSAx_entry() //  [R1, R2]
         { info_tbl: [(cbUed,
                       label: sat_sbSAx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUed: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fShowZipList_$cshow_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbSAw_entry() //  [R1, R2, R3]
         { info_tbl: [(cbUel,
                       label: sat_sbSAw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUel: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fShowZipList_$cshowsPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fShowZipList_entry() //  [R2]
         { info_tbl: [(cbUep,
                       label: Control.Applicative.$fShowZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUep: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbUet; else goto cbUes;
       cbUet: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Control.Applicative.$fShowZipList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUes: // global
           I64[Hp - 72] = sat_sbSAy_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbSAx_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbSAw_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.273002639 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedArrow1_closure" {
     Control.Applicative.$fGeneric1WrappedArrow1_closure:
         const Control.Applicative.$fGeneric1WrappedArrow1_info;
 },
 Control.Applicative.$fGeneric1WrappedArrow1_entry() //  [R2]
         { info_tbl: [(cbUeP,
                       label: Control.Applicative.$fGeneric1WrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUeP: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.276310996 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedArrow2_closure" {
     Control.Applicative.$fGeneric1WrappedArrow2_closure:
         const Control.Applicative.$fGeneric1WrappedArrow2_info;
 },
 Control.Applicative.$fGeneric1WrappedArrow2_entry() //  [R2]
         { info_tbl: [(cbUf0,
                       label: Control.Applicative.$fGeneric1WrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUf0: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.280344996 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedArrow_closure" {
     Control.Applicative.$fGeneric1WrappedArrow_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Control.Applicative.$fGeneric1WrappedArrow2_closure+1;
         const Control.Applicative.$fGeneric1WrappedArrow1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.282252282 UTC

[section ""data" . Control.Applicative.$fGenericWrappedArrow1_closure" {
     Control.Applicative.$fGenericWrappedArrow1_closure:
         const Control.Applicative.$fGenericWrappedArrow1_info;
 },
 Control.Applicative.$fGenericWrappedArrow1_entry() //  [R2]
         { info_tbl: [(cbUfc,
                       label: Control.Applicative.$fGenericWrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUfc: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.285414121 UTC

[section ""data" . Control.Applicative.$fGenericWrappedArrow2_closure" {
     Control.Applicative.$fGenericWrappedArrow2_closure:
         const Control.Applicative.$fGenericWrappedArrow2_info;
 },
 Control.Applicative.$fGenericWrappedArrow2_entry() //  [R2]
         { info_tbl: [(cbUfn,
                       label: Control.Applicative.$fGenericWrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUfn: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.288439126 UTC

[section ""data" . Control.Applicative.$fGenericWrappedArrow_closure" {
     Control.Applicative.$fGenericWrappedArrow_closure:
         const GHC.Generics.C:Generic_con_info;
         const Control.Applicative.$fGenericWrappedArrow2_closure+1;
         const Control.Applicative.$fGenericWrappedArrow1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.29121019 UTC

[section ""data" . Control.Applicative.$fMonadWrappedMonad_closure" {
     Control.Applicative.$fMonadWrappedMonad_closure:
         const Control.Applicative.$fMonadWrappedMonad_info;
 },
 sat_sbSAI_entry() //  [R1]
         { info_tbl: [(cbUfD,
                       label: sat_sbSAI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUfD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUfE; else goto cbUfF;
       cbUfE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUfF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.fail_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAH_entry() //  [R1]
         { info_tbl: [(cbUfK,
                       label: sat_sbSAH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUfK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUfL; else goto cbUfM;
       cbUfL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUfM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAG_entry() //  [R1]
         { info_tbl: [(cbUfR,
                       label: sat_sbSAG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUfR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUfS; else goto cbUfT;
       cbUfS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUfT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.>>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAF_entry() //  [R1]
         { info_tbl: [(cbUfY,
                       label: sat_sbSAF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUfY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUfZ; else goto cbUg0;
       cbUfZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUg0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.>>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAE_entry() //  [R1]
         { info_tbl: [(cbUg5,
                       label: sat_sbSAE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUg5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUg6; else goto cbUg7;
       cbUg6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUg7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fApplicativeWrappedMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fMonadWrappedMonad_entry() //  [R2]
         { info_tbl: [(cbUg9,
                       label: Control.Applicative.$fMonadWrappedMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUg9: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cbUgd; else goto cbUgc;
       cbUgd: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Control.Applicative.$fMonadWrappedMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUgc: // global
           I64[Hp - 160] = sat_sbSAI_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbSAH_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbSAG_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbSAF_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbSAE_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.303809444 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedMonad1_closure" {
     Control.Applicative.$fGeneric1WrappedMonad1_closure:
         const Control.Applicative.$fGeneric1WrappedMonad1_info;
 },
 Control.Applicative.$fGeneric1WrappedMonad1_entry() //  [R2]
         { info_tbl: [(cbUgM,
                       label: Control.Applicative.$fGeneric1WrappedMonad1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUgM: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.307477131 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedMonad2_closure" {
     Control.Applicative.$fGeneric1WrappedMonad2_closure:
         const Control.Applicative.$fGeneric1WrappedMonad2_info;
 },
 Control.Applicative.$fGeneric1WrappedMonad2_entry() //  [R2]
         { info_tbl: [(cbUgX,
                       label: Control.Applicative.$fGeneric1WrappedMonad2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUgX: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.310655362 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedMonad_closure" {
     Control.Applicative.$fGeneric1WrappedMonad_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Control.Applicative.$fGeneric1WrappedMonad2_closure+1;
         const Control.Applicative.$fGeneric1WrappedMonad1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.313120156 UTC

[section ""data" . Control.Applicative.$fGenericWrappedMonad1_closure" {
     Control.Applicative.$fGenericWrappedMonad1_closure:
         const Control.Applicative.$fGenericWrappedMonad1_info;
 },
 Control.Applicative.$fGenericWrappedMonad1_entry() //  [R2]
         { info_tbl: [(cbUh9,
                       label: Control.Applicative.$fGenericWrappedMonad1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUh9: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.316328514 UTC

[section ""data" . Control.Applicative.$fGenericWrappedMonad2_closure" {
     Control.Applicative.$fGenericWrappedMonad2_closure:
         const Control.Applicative.$fGenericWrappedMonad2_info;
 },
 Control.Applicative.$fGenericWrappedMonad2_entry() //  [R2]
         { info_tbl: [(cbUhk,
                       label: Control.Applicative.$fGenericWrappedMonad2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUhk: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.319441938 UTC

[section ""data" . Control.Applicative.$fGenericWrappedMonad_closure" {
     Control.Applicative.$fGenericWrappedMonad_closure:
         const GHC.Generics.C:Generic_con_info;
         const Control.Applicative.$fGenericWrappedMonad2_closure+1;
         const Control.Applicative.$fGenericWrappedMonad1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.321630132 UTC

[section ""data" . Control.Applicative.unwrapMonad_closure" {
     Control.Applicative.unwrapMonad_closure:
         const Control.Applicative.unwrapMonad_info;
 },
 Control.Applicative.unwrapMonad_entry() //  [R2]
         { info_tbl: [(cbUhw,
                       label: Control.Applicative.unwrapMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUhw: // global
           R2 = R2;
           call Control.Applicative.$fGeneric1WrappedMonad2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.324866139 UTC

[section ""data" . Control.Applicative.unwrapArrow_closure" {
     Control.Applicative.unwrapArrow_closure:
         const Control.Applicative.unwrapArrow_info;
 },
 Control.Applicative.unwrapArrow_entry() //  [R2]
         { info_tbl: [(cbUhH,
                       label: Control.Applicative.unwrapArrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUhH: // global
           R2 = R2;
           call Control.Applicative.$fGeneric1WrappedArrow2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.328084116 UTC

[section ""data" . Control.Applicative.getZipList_closure" {
     Control.Applicative.getZipList_closure:
         const Control.Applicative.getZipList_info;
 },
 Control.Applicative.getZipList_entry() //  [R2]
         { info_tbl: [(cbUhS,
                       label: Control.Applicative.getZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUhS: // global
           R2 = R2;
           call Control.Applicative.$fGeneric1ZipList2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.331724191 UTC

[section ""data" . Control.Applicative.optional_closure" {
     Control.Applicative.optional_closure:
         const Control.Applicative.optional_info;
 },
 $dApplicative_sbSAP_entry() //  [R1]
         { info_tbl: [(cbUi7,
                       label: $dApplicative_sbSAP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUi7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUi8; else goto cbUi9;
       cbUi8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUi9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbSAS_entry() //  [R1]
         { info_tbl: [(cbUie,
                       label: sat_sbSAS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUie: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbUif; else goto cbUig;
       cbUif: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUig: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbSAR_entry() //  [R1]
         { info_tbl: [(cbUin,
                       label: sat_sbSAR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUin: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbUio; else goto cbUip;
       cbUio: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUip: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbUil_info;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbUil() //  [R1]
         { info_tbl: [(cbUil,
                       label: block_cbUil_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUil: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.optional_entry() //  [R2, R3]
         { info_tbl: [(cbUit,
                       label: Control.Applicative.optional_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUit: // global
           _sbSAO::P64 = R3;
           _sbSAN::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbUiu; else goto cbUiv;
       cbUiv: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbUix; else goto cbUiw;
       cbUix: // global
           HpAlloc = 80;
           goto cbUiu;
       cbUiu: // global
           R3 = _sbSAO::P64;
           R2 = _sbSAN::P64;
           R1 = Control.Applicative.optional_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUiw: // global
           I64[Hp - 72] = $dApplicative_sbSAP_info;
           P64[Hp - 56] = _sbSAN::P64;
           I64[Hp - 48] = sat_sbSAS_info;
           _cbUi3::P64 = Hp - 72;
           P64[Hp - 32] = _cbUi3::P64;
           I64[Hp - 24] = sat_sbSAR_info;
           P64[Hp - 8] = _sbSAO::P64;
           P64[Hp] = _cbUi3::P64;
           R2 = _sbSAN::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 24;
           call GHC.Base.<|>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.343649175 UTC

[section ""cstring" . Control.Applicative.$trModule4_bytes" {
     Control.Applicative.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.345338674 UTC

[section ""data" . Control.Applicative.$trModule3_closure" {
     Control.Applicative.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.346970846 UTC

[section ""cstring" . Control.Applicative.$trModule2_bytes" {
     Control.Applicative.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,65,112,112,108,105,99,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.348556004 UTC

[section ""data" . Control.Applicative.$trModule1_closure" {
     Control.Applicative.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.350274842 UTC

[section ""data" . Control.Applicative.$trModule_closure" {
     Control.Applicative.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Applicative.$trModule3_closure+1;
         const Control.Applicative.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.351963763 UTC

[section ""data" . Control.Applicative.$tcWrappedMonad1_closure" {
     Control.Applicative.$tcWrappedMonad1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const GHC.Types.krep$*Arr*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.353916569 UTC

[section ""data" . Control.Applicative.$tcWrappedArrow1_closure" {
     Control.Applicative.$tcWrappedArrow1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const GHC.Types.krep$*->*->*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.355665044 UTC

[section ""data" . $krep_rbSvt_closure" {
     $krep_rbSvt_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.357291613 UTC

[section ""data" . $krep1_rbSvu_closure" {
     $krep1_rbSvu_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.358985202 UTC

[section ""data" . $krep2_rbSvv_closure" {
     $krep2_rbSvv_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.360589976 UTC

[section ""data" . $krep3_rbSvw_closure" {
     $krep3_rbSvw_closure:
         const :_con_info;
         const $krep2_rbSvv_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.362296126 UTC

[section ""data" . $krep4_rbSvx_closure" {
     $krep4_rbSvx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep3_rbSvw_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.364003021 UTC

[section ""data" . $krep5_rbSvy_closure" {
     $krep5_rbSvy_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep2_rbSvv_closure+2;
         const $krep1_rbSvu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.365677876 UTC

[section ""data" . $krep6_rbSvz_closure" {
     $krep6_rbSvz_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep5_rbSvy_closure+3;
         const $krep_rbSvt_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.367887024 UTC

[section ""cstring" . Control.Applicative.$tcWrappedMonad3_bytes" {
     Control.Applicative.$tcWrappedMonad3_bytes:
         I8[] [87,114,97,112,112,101,100,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.370107713 UTC

[section ""data" . Control.Applicative.$tcWrappedMonad2_closure" {
     Control.Applicative.$tcWrappedMonad2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tcWrappedMonad3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.371797046 UTC

[section ""data" . Control.Applicative.$tcWrappedMonad_closure" {
     Control.Applicative.$tcWrappedMonad_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tcWrappedMonad2_closure+1;
         const Control.Applicative.$tcWrappedMonad1_closure+4;
         const 12971590878300233698;
         const 12447260690856494251;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.373662416 UTC

[section ""data" . $krep7_rbSvA_closure" {
     $krep7_rbSvA_closure:
         const :_con_info;
         const $krep1_rbSvu_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.375233459 UTC

[section ""data" . $krep8_rbSvB_closure" {
     $krep8_rbSvB_closure:
         const :_con_info;
         const $krep2_rbSvv_closure+2;
         const $krep7_rbSvA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.376909522 UTC

[section ""data" . $krep9_rbSvC_closure" {
     $krep9_rbSvC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Applicative.$tcWrappedMonad_closure+1;
         const $krep8_rbSvB_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.378656408 UTC

[section ""data" . Control.Applicative.$tc'WrapMonad1_closure" {
     Control.Applicative.$tc'WrapMonad1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_rbSvy_closure+3;
         const $krep9_rbSvC_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.380407324 UTC

[section ""cstring" . Control.Applicative.$tc'WrapMonad3_bytes" {
     Control.Applicative.$tc'WrapMonad3_bytes:
         I8[] [39,87,114,97,112,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.382053406 UTC

[section ""data" . Control.Applicative.$tc'WrapMonad2_closure" {
     Control.Applicative.$tc'WrapMonad2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tc'WrapMonad3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.383695521 UTC

[section ""data" . Control.Applicative.$tc'WrapMonad_closure" {
     Control.Applicative.$tc'WrapMonad_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tc'WrapMonad2_closure+1;
         const Control.Applicative.$tc'WrapMonad1_closure+4;
         const 10363415327661881286;
         const 6845751270384138997;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.386037827 UTC

[section ""cstring" . Control.Applicative.$tcWrappedArrow3_bytes" {
     Control.Applicative.$tcWrappedArrow3_bytes:
         I8[] [87,114,97,112,112,101,100,65,114,114,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.387575376 UTC

[section ""data" . Control.Applicative.$tcWrappedArrow2_closure" {
     Control.Applicative.$tcWrappedArrow2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tcWrappedArrow3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.390146959 UTC

[section ""data" . Control.Applicative.$tcWrappedArrow_closure" {
     Control.Applicative.$tcWrappedArrow_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tcWrappedArrow2_closure+1;
         const Control.Applicative.$tcWrappedArrow1_closure+4;
         const 17995829375472255965;
         const 6668242383287740398;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.392290432 UTC

[section ""data" . $krep10_rbSvD_closure" {
     $krep10_rbSvD_closure:
         const :_con_info;
         const $krep_rbSvt_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.394251404 UTC

[section ""data" . $krep11_rbSvE_closure" {
     $krep11_rbSvE_closure:
         const :_con_info;
         const $krep1_rbSvu_closure+2;
         const $krep10_rbSvD_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.396763368 UTC

[section ""data" . $krep12_rbSvF_closure" {
     $krep12_rbSvF_closure:
         const :_con_info;
         const $krep2_rbSvv_closure+2;
         const $krep11_rbSvE_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.398623306 UTC

[section ""data" . $krep13_rbSvG_closure" {
     $krep13_rbSvG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Applicative.$tcWrappedArrow_closure+1;
         const $krep12_rbSvF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.400343569 UTC

[section ""data" . Control.Applicative.$tc'WrapArrow1_closure" {
     Control.Applicative.$tc'WrapArrow1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rbSvz_closure+3;
         const $krep13_rbSvG_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.402183412 UTC

[section ""cstring" . Control.Applicative.$tc'WrapArrow3_bytes" {
     Control.Applicative.$tc'WrapArrow3_bytes:
         I8[] [39,87,114,97,112,65,114,114,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.404137421 UTC

[section ""data" . Control.Applicative.$tc'WrapArrow2_closure" {
     Control.Applicative.$tc'WrapArrow2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tc'WrapArrow3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.406520268 UTC

[section ""data" . Control.Applicative.$tc'WrapArrow_closure" {
     Control.Applicative.$tc'WrapArrow_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tc'WrapArrow2_closure+1;
         const Control.Applicative.$tc'WrapArrow1_closure+4;
         const 4796259816778499037;
         const 13482613273239263357;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.40863886 UTC

[section ""data" . Control.Applicative.$tcZipList1_closure" {
     Control.Applicative.$tcZipList1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$fReadZipList11_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.410525013 UTC

[section ""data" . Control.Applicative.$tcZipList_closure" {
     Control.Applicative.$tcZipList_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tcZipList1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 11311650752326360483;
         const 5534599578149162946;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.412545023 UTC

[section ""data" . $krep14_rbSvH_closure" {
     $krep14_rbSvH_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Applicative.$tcZipList_closure+1;
         const $krep3_rbSvw_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.414474875 UTC

[section ""data" . Control.Applicative.$tc'ZipList1_closure" {
     Control.Applicative.$tc'ZipList1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rbSvx_closure+1;
         const $krep14_rbSvH_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.41634269 UTC

[section ""cstring" . Control.Applicative.$tc'ZipList3_bytes" {
     Control.Applicative.$tc'ZipList3_bytes:
         I8[] [39,90,105,112,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.418679203 UTC

[section ""data" . Control.Applicative.$tc'ZipList2_closure" {
     Control.Applicative.$tc'ZipList2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tc'ZipList3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.420464807 UTC

[section ""data" . Control.Applicative.$tc'ZipList_closure" {
     Control.Applicative.$tc'ZipList_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tc'ZipList2_closure+1;
         const Control.Applicative.$tc'ZipList1_closure+4;
         const 15353069281551614305;
         const 7665927634319452478;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:46.422254063 UTC

[section ""relreadonly" . SbSVf_srt" {
     SbSVf_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Control.Applicative.$fReadZipList2_closure;
         const GHC.Read.readField_closure;
         const Control.Applicative.$fReadZipList6_closure;
         const Control.Applicative.$fReadZipList_lexeme_closure;
         const Control.Applicative.$fReadZipList_lexeme1_closure;
         const GHC.Read.list3_closure;
         const Control.Applicative.$fReadZipList1_closure;
         const Control.Applicative.$fReadZipList_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Control.Applicative.$fReadZipList_$creadListPrec_closure;
         const Control.Applicative.$fReadZipList_$creadList_closure;
         const Control.Applicative.$fReadZipList_closure;
         const Control.Applicative.$fReadZipList3_closure;
         const Control.Applicative.$fShowZipList_$cshow_closure;
         const Control.Applicative.$fShowZipList_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.323733696 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:48.325795647 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedMonad1_closure" {
     Control.Applicative.$fFunctorWrappedMonad1_closure:
         const Control.Applicative.$fFunctorWrappedMonad1_info;
 },
 lvl_sbUjF_entry() //  [R1]
         { info_tbl: [(cbUoU,
                       label: lvl_sbUjF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUoU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbUoV; else goto cbUoW;
       cbUoV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUoW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbUjH_entry() //  [R1]
         { info_tbl: [(cbUp2,
                       label: sat_sbUjH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUp2: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fFunctorWrappedMonad1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbUp5,
                       label: Control.Applicative.$fFunctorWrappedMonad1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUp5: // global
           _sbUjE::P64 = R4;
           _sbUjD::P64 = R3;
           _sbUjC::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbUp6; else goto cbUp7;
       cbUp7: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbUp9; else goto cbUp8;
       cbUp9: // global
           HpAlloc = 48;
           goto cbUp6;
       cbUp6: // global
           R4 = _sbUjE::P64;
           R3 = _sbUjD::P64;
           R2 = _sbUjC::P64;
           R1 = Control.Applicative.$fFunctorWrappedMonad1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUp8: // global
           I64[Hp - 40] = lvl_sbUjF_info;
           P64[Hp - 24] = _sbUjC::P64;
           P64[Hp - 16] = _sbUjD::P64;
           I64[Hp - 8] = sat_sbUjH_info;
           P64[Hp] = Hp - 40;
           R2 = _sbUjC::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbUjE::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.336058646 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedMonad_closure" {
     Control.Applicative.$fFunctorWrappedMonad_closure:
         const Control.Applicative.$fFunctorWrappedMonad_info;
 },
 sat_sbUjM_entry() //  [R1, R2, R3]
         { info_tbl: [(cbUpD,
                       label: sat_sbUjM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUpD: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fFunctorWrappedMonad1_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUjL_entry() //  [R1, R2, R3]
         { info_tbl: [(cbUpL,
                       label: sat_sbUjL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUpL: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.liftM_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fFunctorWrappedMonad_entry() //  [R2]
         { info_tbl: [(cbUpP,
                       label: Control.Applicative.$fFunctorWrappedMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUpP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbUpT; else goto cbUpS;
       cbUpT: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Applicative.$fFunctorWrappedMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUpS: // global
           I64[Hp - 48] = sat_sbUjM_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sbUjL_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.354285957 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedMonad3_closure" {
     Control.Applicative.$fApplicativeWrappedMonad3_closure:
         const Control.Applicative.$fApplicativeWrappedMonad3_info;
 },
 Control.Applicative.$fApplicativeWrappedMonad3_entry() //  [R2, R3]
         { info_tbl: [(cbUqg,
                       label: Control.Applicative.$fApplicativeWrappedMonad3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUqg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUqh; else goto cbUqi;
       cbUqh: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedMonad3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUqi: // global
           I64[Sp - 16] = block_cbUqe_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbUqe() //  [R1]
         { info_tbl: [(cbUqe,
                       label: block_cbUqe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUqe: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.360037077 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedMonad2_closure" {
     Control.Applicative.$fApplicativeWrappedMonad2_closure:
         const Control.Applicative.$fApplicativeWrappedMonad2_info;
 },
 lvl_sbUjT_entry() //  [R1]
         { info_tbl: [(cbUqI,
                       label: lvl_sbUjT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUqI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbUqJ; else goto cbUqK;
       cbUqJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUqK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbUjV_entry() //  [R1]
         { info_tbl: [(cbUqQ,
                       label: sat_sbUjV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUqQ: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUjW_entry() //  [R1]
         { info_tbl: [(cbUqT,
                       label: sat_sbUjW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUqT: // global
           _sbUjW::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbUqU; else goto cbUqV;
       cbUqV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbUqX; else goto cbUqW;
       cbUqX: // global
           HpAlloc = 40;
           goto cbUqU;
       cbUqU: // global
           R1 = _sbUjW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUqW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbUjW::P64;
           _sbUjQ::P64 = P64[_sbUjW::P64 + 16];
           _sbUjR::P64 = P64[_sbUjW::P64 + 24];
           I64[Hp - 32] = lvl_sbUjT_info;
           P64[Hp - 16] = _sbUjQ::P64;
           I64[Hp - 8] = sat_sbUjV_info;
           P64[Hp] = Hp - 32;
           R2 = _sbUjQ::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbUjR::P64;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeWrappedMonad2_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbUqY,
                       label: Control.Applicative.$fApplicativeWrappedMonad2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUqY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbUr2; else goto cbUr1;
       cbUr2: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedMonad2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUr1: // global
           I64[Hp - 24] = sat_sbUjW_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R4 = R4;
           R3 = Hp - 24;
           R2 = R2;
           call GHC.Base.ap_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.370696798 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedMonad1_closure" {
     Control.Applicative.$fApplicativeWrappedMonad1_closure:
         const Control.Applicative.$fApplicativeWrappedMonad1_info;
 },
 lvl_sbUk1_entry() //  [R1]
         { info_tbl: [(cbUrG,
                       label: lvl_sbUk1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUrG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbUrH; else goto cbUrI;
       cbUrH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUrI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbUk3_entry() //  [R1]
         { info_tbl: [(cbUrO,
                       label: sat_sbUk3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUrO: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUk4_entry() //  [R1, R2]
         { info_tbl: [(cbUrR,
                       label: sat_sbUk4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUrR: // global
           _sbUk0::P64 = R2;
           _sbUk4::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbUrS; else goto cbUrT;
       cbUrT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbUrV; else goto cbUrU;
       cbUrV: // global
           HpAlloc = 48;
           goto cbUrS;
       cbUrS: // global
           R2 = _sbUk0::P64;
           R1 = _sbUk4::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUrU: // global
           _sbUjX::P64 = P64[_sbUk4::P64 + 7];
           _sbUjZ::P64 = P64[_sbUk4::P64 + 15];
           I64[Hp - 40] = lvl_sbUk1_info;
           P64[Hp - 24] = _sbUjX::P64;
           P64[Hp - 16] = _sbUk0::P64;
           I64[Hp - 8] = sat_sbUk3_info;
           P64[Hp] = Hp - 40;
           R2 = _sbUjX::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbUjZ::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fApplicativeWrappedMonad1_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbUrW,
                       label: Control.Applicative.$fApplicativeWrappedMonad1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUrW: // global
           _sbUjZ::P64 = R4;
           _sbUjY::P64 = R3;
           _sbUjX::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbUrX; else goto cbUrY;
       cbUrY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUs0; else goto cbUrZ;
       cbUs0: // global
           HpAlloc = 24;
           goto cbUrX;
       cbUrX: // global
           R4 = _sbUjZ::P64;
           R3 = _sbUjY::P64;
           R2 = _sbUjX::P64;
           R1 = Control.Applicative.$fApplicativeWrappedMonad1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUrZ: // global
           I64[Hp - 16] = sat_sbUk4_info;
           P64[Hp - 8] = _sbUjX::P64;
           P64[Hp] = _sbUjZ::P64;
           R2 = _sbUjX::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbUjY::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.381717752 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedMonad_closure" {
     Control.Applicative.$fApplicativeWrappedMonad_closure:
         const Control.Applicative.$fApplicativeWrappedMonad_info;
 },
 sat_sbUkg_entry() //  [R1, R2, R3]
         { info_tbl: [(cbUsB,
                       label: sat_sbUkg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUsB: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedMonad1_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUkf_entry() //  [R1, R2, R3]
         { info_tbl: [(cbUsJ,
                       label: sat_sbUkf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUsJ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedMonad2_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUke_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbUsR,
                       label: sat_sbUke_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUsR: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.liftM2_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUka_entry() //  [R1, R2, R3]
         { info_tbl: [(cbUsZ,
                       label: sat_sbUka_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUsZ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.ap_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUk7_entry() //  [R1, R2]
         { info_tbl: [(cbUt7,
                       label: sat_sbUk7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUt7: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fApplicativeWrappedMonad3_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUk6_entry() //  [R1]
         { info_tbl: [(cbUte,
                       label: sat_sbUk6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUte: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUtf; else goto cbUtg;
       cbUtf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUtg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fFunctorWrappedMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeWrappedMonad_entry() //  [R2]
         { info_tbl: [(cbUti,
                       label: Control.Applicative.$fApplicativeWrappedMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUti: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cbUtm; else goto cbUtl;
       cbUtm: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUtl: // global
           I64[Hp - 152] = sat_sbUkg_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbUkf_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbUke_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbUka_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbUk7_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbUk6_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 87;
           P64[Hp - 24] = Hp - 102;
           P64[Hp - 16] = Hp - 117;
           P64[Hp - 8] = Hp - 134;
           P64[Hp] = Hp - 150;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.398192832 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_closure" {
     Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_closure:
         const Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_info;
 },
 sat_sbUki_entry() //  [R1]
         { info_tbl: [(cbUu7,
                       label: sat_sbUki_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUu7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUu8; else goto cbUu9;
       cbUu8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUu9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_entry() //  [R2]
         { info_tbl: [(cbUua,
                       label: Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUua: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUue; else goto cbUud;
       cbUue: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUud: // global
           I64[Hp - 16] = sat_sbUki_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Applicative.$fApplicativeWrappedMonad_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.404473615 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedMonad_$csome_closure" {
     Control.Applicative.$fAlternativeWrappedMonad_$csome_closure:
         const Control.Applicative.$fAlternativeWrappedMonad_$csome_info;
 },
 sat_sbUkp_entry() //  [R1]
         { info_tbl: [(cbUuI,
                       label: sat_sbUkp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUuI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbUuJ; else goto cbUuK;
       cbUuJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUuK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbUuG_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbUuG() //  [R1]
         { info_tbl: [(cbUuG,
                       label: block_cbUuG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUuG: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 m2_sbUkm_entry() //  [R1]
         { info_tbl: [(cbUuO,
                       label: m2_sbUkm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUuO: // global
           _sbUkm::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbUuP; else goto cbUuQ;
       cbUuQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUuS; else goto cbUuR;
       cbUuS: // global
           HpAlloc = 24;
           goto cbUuP;
       cbUuP: // global
           R1 = _sbUkm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUuR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbUkm::P64;
           _sbUkj::P64 = P64[_sbUkm::P64 + 16];
           _sbUkl::P64 = P64[_sbUkm::P64 + 24];
           _sbUkn::P64 = P64[_sbUkm::P64 + 32];
           I64[Hp - 16] = sat_sbUkp_info;
           P64[Hp] = _sbUkl::P64;
           R2 = _sbUkj::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbUkn::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call GHC.Base.mplus_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbUkt_entry() //  [R1, R2]
         { info_tbl: [(cbUv7,
                       label: sat_sbUkt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUv7: // global
           _sbUkr::P64 = R2;
           _sbUkt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbUv8; else goto cbUv9;
       cbUv9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUvb; else goto cbUva;
       cbUvb: // global
           HpAlloc = 24;
           goto cbUv8;
       cbUv8: // global
           R2 = _sbUkr::P64;
           R1 = _sbUkt::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUva: // global
           _sbUkl::P64 = P64[_sbUkt::P64 + 7];
           _sbUkq::P64 = P64[_sbUkt::P64 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sbUkq::P64;
           P64[Hp] = _sbUkr::P64;
           R2 = _sbUkl::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbUku_entry() //  [R1, R2]
         { info_tbl: [(cbUvc,
                       label: sat_sbUku_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUvc: // global
           _sbUkq::P64 = R2;
           _sbUku::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbUvd; else goto cbUve;
       cbUve: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUvg; else goto cbUvf;
       cbUvg: // global
           HpAlloc = 24;
           goto cbUvd;
       cbUvd: // global
           R2 = _sbUkq::P64;
           R1 = _sbUku::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUvf: // global
           _sbUkl::P64 = P64[_sbUku::P64 + 7];
           _sbUkm::P64 = P64[_sbUku::P64 + 15];
           I64[Hp - 16] = sat_sbUkt_info;
           P64[Hp - 8] = _sbUkl::P64;
           P64[Hp] = _sbUkq::P64;
           R2 = _sbUkl::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbUkm::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 some_v_sbUkn_entry() //  [R1]
         { info_tbl: [(cbUvh,
                       label: some_v_sbUkn_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUvh: // global
           _sbUkn::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbUvi; else goto cbUvj;
       cbUvj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUvl; else goto cbUvk;
       cbUvl: // global
           HpAlloc = 24;
           goto cbUvi;
       cbUvi: // global
           R1 = _sbUkn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUvk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbUkn::P64;
           _sbUkk::P64 = P64[_sbUkn::P64 + 16];
           _sbUkl::P64 = P64[_sbUkn::P64 + 24];
           _sbUkm::P64 = P64[_sbUkn::P64 + 32];
           I64[Hp - 16] = sat_sbUku_info;
           P64[Hp - 8] = _sbUkl::P64;
           P64[Hp] = _sbUkm::P64;
           R2 = _sbUkl::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbUkk::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedMonad_$csome_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(cbUvm,
                       label: Control.Applicative.$fAlternativeWrappedMonad_$csome_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUvm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbUvn; else goto cbUvo;
       cbUvn: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedMonad_$csome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUvo: // global
           I64[Sp - 24] = block_cbUut_info;
           _sbUkj::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _sbUkj::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbUut() //  [R1]
         { info_tbl: [(cbUut,
                       label: block_cbUut_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUut: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbUvr; else goto cbUvq;
       cbUvr: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbUvq: // global
           I64[Hp - 72] = m2_sbUkm_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           _cbUuy::P64 = Hp - 32;
           P64[Hp - 40] = _cbUuy::P64;
           I64[Hp - 32] = some_v_sbUkn_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 72;
           R1 = _cbUuy::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.423681386 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedMonad_$cmany_closure" {
     Control.Applicative.$fAlternativeWrappedMonad_$cmany_closure:
         const Control.Applicative.$fAlternativeWrappedMonad_$cmany_info;
 },
 $dApplicative_sbUky_entry() //  [R1]
         { info_tbl: [(cbUwy,
                       label: $dApplicative_sbUky_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUwy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUwz; else goto cbUwA;
       cbUwz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUwA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUkG_entry() //  [R1]
         { info_tbl: [(cbUwH,
                       label: sat_sbUkG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUwH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbUwI; else goto cbUwJ;
       cbUwI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUwJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbUwF_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbUwF() //  [R1]
         { info_tbl: [(cbUwF,
                       label: block_cbUwF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUwF: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbUkC_entry() //  [R1, R2]
         { info_tbl: [(cbUx2,
                       label: sat_sbUkC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUx2: // global
           _sbUkA::P64 = R2;
           _sbUkC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbUx3; else goto cbUx4;
       cbUx4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUx6; else goto cbUx5;
       cbUx6: // global
           HpAlloc = 24;
           goto cbUx3;
       cbUx3: // global
           R2 = _sbUkA::P64;
           R1 = _sbUkC::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUx5: // global
           _sbUky::P64 = P64[_sbUkC::P64 + 7];
           _sbUkz::P64 = P64[_sbUkC::P64 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sbUkz::P64;
           P64[Hp] = _sbUkA::P64;
           R2 = _sbUky::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sbUkD_entry() //  [R1, R2]
         { info_tbl: [(cbUx7,
                       label: sat_sbUkD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUx7: // global
           _sbUkz::P64 = R2;
           _sbUkD::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbUx8; else goto cbUx9;
       cbUx9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUxb; else goto cbUxa;
       cbUxb: // global
           HpAlloc = 24;
           goto cbUx8;
       cbUx8: // global
           R2 = _sbUkz::P64;
           R1 = _sbUkD::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUxa: // global
           _sbUkx::P64 = P64[_sbUkD::P64 + 7];
           _sbUky::P64 = P64[_sbUkD::P64 + 15];
           I64[Hp - 16] = sat_sbUkC_info;
           P64[Hp - 8] = _sbUky::P64;
           P64[Hp] = _sbUkz::P64;
           R2 = _sbUky::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbUkx::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbUkE_entry() //  [R1]
         { info_tbl: [(cbUxc,
                       label: sat_sbUkE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUxc: // global
           _sbUkE::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbUxd; else goto cbUxe;
       cbUxe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUxg; else goto cbUxf;
       cbUxg: // global
           HpAlloc = 24;
           goto cbUxd;
       cbUxd: // global
           R1 = _sbUkE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUxf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbUkE::P64;
           _sbUkw::P64 = P64[_sbUkE::P64 + 16];
           _sbUkx::P64 = P64[_sbUkE::P64 + 24];
           _sbUky::P64 = P64[_sbUkE::P64 + 32];
           I64[Hp - 16] = sat_sbUkD_info;
           P64[Hp - 8] = _sbUkx::P64;
           P64[Hp] = _sbUky::P64;
           R2 = _sbUky::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbUkw::P64;
           P64[Sp - 24] = Hp - 15;
           Sp = Sp - 40;
           call GHC.Base.>>=_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 many_v_sbUkx_entry() //  [R1]
         { info_tbl: [(cbUxh,
                       label: many_v_sbUkx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUxh: // global
           _sbUkx::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbUxi; else goto cbUxj;
       cbUxj: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbUxl; else goto cbUxk;
       cbUxl: // global
           HpAlloc = 88;
           goto cbUxi;
       cbUxi: // global
           R1 = _sbUkx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUxk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbUkx::P64;
           _sbUkv::P64 = P64[_sbUkx::P64 + 16];
           _sbUkw::P64 = P64[_sbUkx::P64 + 24];
           I64[Hp - 80] = $dApplicative_sbUky_info;
           P64[Hp - 64] = _sbUkv::P64;
           I64[Hp - 56] = sat_sbUkG_info;
           _cbUwu::P64 = Hp - 80;
           P64[Hp - 40] = _cbUwu::P64;
           I64[Hp - 32] = sat_sbUkE_info;
           P64[Hp - 16] = _sbUkw::P64;
           P64[Hp - 8] = _sbUkx::P64;
           P64[Hp] = _cbUwu::P64;
           R2 = _sbUkv::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call GHC.Base.mplus_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedMonad_$cmany_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(cbUxm,
                       label: Control.Applicative.$fAlternativeWrappedMonad_$cmany_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUxm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbUxq; else goto cbUxp;
       cbUxq: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedMonad_$cmany_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUxp: // global
           I64[Hp - 24] = many_v_sbUkx_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.443780189 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedMonad_closure" {
     Control.Applicative.$fAlternativeWrappedMonad_closure:
         const Control.Applicative.$fAlternativeWrappedMonad_info;
 },
 sat_sbUkO_entry() //  [R1, R2]
         { info_tbl: [(cbUyt,
                       label: sat_sbUkO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUyt: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fAlternativeWrappedMonad_$cmany_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUkN_entry() //  [R1, R2]
         { info_tbl: [(cbUyB,
                       label: sat_sbUkN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUyB: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fAlternativeWrappedMonad_$csome_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUkM_entry() //  [R1, R2, R3]
         { info_tbl: [(cbUyJ,
                       label: sat_sbUkM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUyJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbUyK; else goto cbUyL;
       cbUyK: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUyL: // global
           _sbUkK::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbUkK::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.mplus_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbUkJ_entry() //  [R1]
         { info_tbl: [(cbUyQ,
                       label: sat_sbUkJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUyQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUyR; else goto cbUyS;
       cbUyR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUyS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUkI_entry() //  [R1]
         { info_tbl: [(cbUyX,
                       label: sat_sbUkI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUyX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUyY; else goto cbUyZ;
       cbUyY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUyZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedMonad_entry() //  [R2]
         { info_tbl: [(cbUz1,
                       label: Control.Applicative.$fAlternativeWrappedMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUz1: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cbUz5; else goto cbUz4;
       cbUz5: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUz4: // global
           I64[Hp - 136] = sat_sbUkO_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbUkN_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbUkM_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbUkJ_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbUkI_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 102;
           P64[Hp - 8] = Hp - 119;
           P64[Hp] = Hp - 135;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.456324437 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedArrow2_closure" {
     Control.Applicative.$fFunctorWrappedArrow2_closure:
         const Control.Applicative.$fFunctorWrappedArrow2_info;
 },
 sat_sbUkT_entry() //  [R1]
         { info_tbl: [(cbUzP,
                       label: sat_sbUkT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUzP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbUzQ; else goto cbUzR;
       cbUzQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUzR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fFunctorWrappedArrow2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbUzU,
                       label: Control.Applicative.$fFunctorWrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUzU: // global
           _sbUkR::P64 = R4;
           _sbUkQ::P64 = R3;
           _sbUkP::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbUzV; else goto cbUzW;
       cbUzW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbUzY; else goto cbUzX;
       cbUzY: // global
           HpAlloc = 32;
           goto cbUzV;
       cbUzV: // global
           R4 = _sbUkR::P64;
           R3 = _sbUkQ::P64;
           R2 = _sbUkP::P64;
           R1 = Control.Applicative.$fFunctorWrappedArrow2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUzX: // global
           I64[Hp - 24] = sat_sbUkT_info;
           P64[Hp - 8] = _sbUkP::P64;
           P64[Hp] = _sbUkQ::P64;
           I64[Sp - 24] = block_cbUzS_info;
           R2 = _sbUkP::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbUkR::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbUzS() //  [R1]
         { info_tbl: [(cbUzS,
                       label: block_cbUzS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUzS: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.464188179 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedArrow1_closure" {
     Control.Applicative.$fFunctorWrappedArrow1_closure:
         const Control.Applicative.$fFunctorWrappedArrow1_info;
 },
 sat_sbUkZ_entry() //  [R1]
         { info_tbl: [(cbUAy,
                       label: sat_sbUkZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUAy: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUl0_entry() //  [R1]
         { info_tbl: [(cbUAB,
                       label: sat_sbUl0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUAB: // global
           _sbUl0::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbUAC; else goto cbUAD;
       cbUAD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbUAF; else goto cbUAE;
       cbUAF: // global
           HpAlloc = 16;
           goto cbUAC;
       cbUAC: // global
           R1 = _sbUl0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUAE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbUl0::P64;
           _sbUkU::P64 = P64[_sbUl0::P64 + 16];
           _sbUkV::P64 = P64[_sbUl0::P64 + 24];
           I64[Hp - 8] = sat_sbUkZ_info;
           P64[Hp] = _sbUkV::P64;
           R2 = _sbUkU::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fFunctorWrappedArrow1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbUAI,
                       label: Control.Applicative.$fFunctorWrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUAI: // global
           _sbUkW::P64 = R4;
           _sbUkV::P64 = R3;
           _sbUkU::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbUAJ; else goto cbUAK;
       cbUAK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbUAM; else goto cbUAL;
       cbUAM: // global
           HpAlloc = 32;
           goto cbUAJ;
       cbUAJ: // global
           R4 = _sbUkW::P64;
           R3 = _sbUkV::P64;
           R2 = _sbUkU::P64;
           R1 = Control.Applicative.$fFunctorWrappedArrow1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUAL: // global
           I64[Hp - 24] = sat_sbUl0_info;
           P64[Hp - 8] = _sbUkU::P64;
           P64[Hp] = _sbUkV::P64;
           I64[Sp - 24] = block_cbUAG_info;
           R2 = _sbUkU::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sbUkW::P64;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbUAG() //  [R1]
         { info_tbl: [(cbUAG,
                       label: block_cbUAG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUAG: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.474425356 UTC

[section ""data" . Control.Applicative.$fFunctorWrappedArrow_closure" {
     Control.Applicative.$fFunctorWrappedArrow_closure:
         const Control.Applicative.$fFunctorWrappedArrow_info;
 },
 sat_sbUl3_entry() //  [R1, R2, R3]
         { info_tbl: [(cbUBm,
                       label: sat_sbUl3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUBm: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fFunctorWrappedArrow1_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUl2_entry() //  [R1, R2, R3]
         { info_tbl: [(cbUBu,
                       label: sat_sbUl2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUBu: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fFunctorWrappedArrow2_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fFunctorWrappedArrow_entry() //  [R2]
         { info_tbl: [(cbUBy,
                       label: Control.Applicative.$fFunctorWrappedArrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUBy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbUBC; else goto cbUBB;
       cbUBC: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Applicative.$fFunctorWrappedArrow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUBB: // global
           I64[Hp - 48] = sat_sbUl3_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sbUl2_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.481698724 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow2_closure" {
     Control.Applicative.$fAlternativeWrappedArrow2_closure:
         const Control.Applicative.$fAlternativeWrappedArrow2_info;
 },
 sat_sbUlb_entry() //  [R1]
         { info_tbl: [(cbUC1,
                       label: sat_sbUlb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUC1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbUC2; else goto cbUC3;
       cbUC2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUC3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Control.Arrow.&&&_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbUl9_entry() //  [R1, R2]
         { info_tbl: [(cbUCd,
                       label: sat_sbUl9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUCd: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Tuple.uncurry_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUla_entry() //  [R1]
         { info_tbl: [(cbUCg,
                       label: sat_sbUla_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUCg: // global
           _sbUla::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbUCh; else goto cbUCi;
       cbUCi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbUCk; else goto cbUCj;
       cbUCk: // global
           HpAlloc = 16;
           goto cbUCh;
       cbUCh: // global
           R1 = _sbUla::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUCj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbUla::P64;
           _sbUl4::P64 = P64[_sbUla::P64 + 16];
           _sbUl5::P64 = P64[_sbUla::P64 + 24];
           I64[Hp - 8] = sat_sbUl9_info;
           P64[Hp] = _sbUl5::P64;
           R2 = _sbUl4::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 7;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow2_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cbUCn,
                       label: Control.Applicative.$fAlternativeWrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUCn: // global
           _sbUl7::P64 = R5;
           _sbUl6::P64 = R4;
           _sbUl5::P64 = R3;
           _sbUl4::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbUCo; else goto cbUCp;
       cbUCp: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbUCr; else goto cbUCq;
       cbUCr: // global
           HpAlloc = 72;
           goto cbUCo;
       cbUCo: // global
           R5 = _sbUl7::P64;
           R4 = _sbUl6::P64;
           R3 = _sbUl5::P64;
           R2 = _sbUl4::P64;
           R1 = Control.Applicative.$fAlternativeWrappedArrow2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUCq: // global
           I64[Hp - 64] = sat_sbUlb_info;
           P64[Hp - 48] = _sbUl4::P64;
           P64[Hp - 40] = _sbUl6::P64;
           P64[Hp - 32] = _sbUl7::P64;
           I64[Hp - 24] = sat_sbUla_info;
           P64[Hp - 8] = _sbUl4::P64;
           P64[Hp] = _sbUl5::P64;
           I64[Sp - 24] = block_cbUCl_info;
           R2 = _sbUl4::P64;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbUCl() //  [R1]
         { info_tbl: [(cbUCl,
                       label: block_cbUCl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUCl: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbUBX::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbUBX::P64;
           call Control.Category.._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.49484382 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow5_closure" {
     Control.Applicative.$fApplicativeWrappedArrow5_closure:
         const Control.Applicative.$fApplicativeWrappedArrow5_info;
 },
 sat_sbUlf_entry() //  [R1]
         { info_tbl: [(cbUDc,
                       label: sat_sbUlf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUDc: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fApplicativeWrappedArrow5_entry() //  [R2, R3]
         { info_tbl: [(cbUDf,
                       label: Control.Applicative.$fApplicativeWrappedArrow5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUDf: // global
           _sbUld::P64 = R3;
           _sbUlc::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbUDg; else goto cbUDh;
       cbUDh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbUDj; else goto cbUDi;
       cbUDj: // global
           HpAlloc = 16;
           goto cbUDg;
       cbUDg: // global
           R3 = _sbUld::P64;
           R2 = _sbUlc::P64;
           R1 = Control.Applicative.$fApplicativeWrappedArrow5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUDi: // global
           I64[Hp - 8] = sat_sbUlf_info;
           P64[Hp] = _sbUld::P64;
           R2 = _sbUlc::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call Control.Arrow.arr_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.50031547 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow4_closure" {
     Control.Applicative.$fApplicativeWrappedArrow4_closure:
         const Control.Applicative.$fApplicativeWrappedArrow4_info;
 },
 Control.Applicative.$fApplicativeWrappedArrow4_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbUDz,
                       label: Control.Applicative.$fApplicativeWrappedArrow4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUDz: // global
           R5 = R4;
           R4 = R3;
           R3 = GHC.Base.breakpoint_closure+1;
           R2 = R2;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.503654205 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow3_closure" {
     Control.Applicative.$fApplicativeWrappedArrow3_closure:
         const Control.Applicative.$fApplicativeWrappedArrow3_info;
 },
 Control.Applicative.$fApplicativeWrappedArrow3_entry() //  [R3]
         { info_tbl: [(cbUDL,
                       label: Control.Applicative.$fApplicativeWrappedArrow3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUDL: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.507746092 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow2_closure" {
     Control.Applicative.$fApplicativeWrappedArrow2_closure:
         const Control.Applicative.$fApplicativeWrappedArrow2_info;
 },
 sat_sbUln_entry() //  [R1]
         { info_tbl: [(cbUE4,
                       label: sat_sbUln_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUE4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbUE5; else goto cbUE6;
       cbUE5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUE6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Applicative.$fApplicativeWrappedArrow3_closure+2;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbUlo_entry() //  [R1]
         { info_tbl: [(cbUE9,
                       label: sat_sbUlo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUE9: // global
           _sbUlo::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbUEa; else goto cbUEb;
       cbUEb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUEd; else goto cbUEc;
       cbUEd: // global
           HpAlloc = 24;
           goto cbUEa;
       cbUEa: // global
           R1 = _sbUlo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUEc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbUlo::P64;
           _sbUlj::P64 = P64[_sbUlo::P64 + 16];
           _sbUlk::P64 = P64[_sbUlo::P64 + 24];
           I64[Hp - 16] = sat_sbUln_info;
           P64[Hp] = _sbUlj::P64;
           I64[Sp - 40] = block_cbUE7_info;
           R2 = _sbUlj::P64;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _sbUlk::P64;
           Sp = Sp - 40;
           call Control.Arrow.$p1Arrow_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbUE7() //  [R1]
         { info_tbl: [(cbUE7,
                       label: block_cbUE7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUE7: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Control.Category.._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeWrappedArrow2_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbUEh,
                       label: Control.Applicative.$fApplicativeWrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUEh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbUEl; else goto cbUEk;
       cbUEl: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedArrow2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUEk: // global
           I64[Hp - 24] = sat_sbUlo_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R5 = R4;
           R4 = Hp - 24;
           R3 = GHC.Base.breakpoint_closure+1;
           R2 = R2;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.518239768 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow1_closure" {
     Control.Applicative.$fApplicativeWrappedArrow1_closure:
         const Control.Applicative.$fApplicativeWrappedArrow1_info;
 },
 Control.Applicative.$fApplicativeWrappedArrow1_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbUEP,
                       label: Control.Applicative.$fApplicativeWrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUEP: // global
           R5 = R4;
           R4 = R3;
           R3 = GHC.Base.const_closure+2;
           R2 = R2;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.522298943 UTC

[section ""data" . Control.Applicative.$fApplicativeWrappedArrow_closure" {
     Control.Applicative.$fApplicativeWrappedArrow_closure:
         const Control.Applicative.$fApplicativeWrappedArrow_info;
 },
 sat_sbUlw_entry() //  [R1, R2, R3]
         { info_tbl: [(cbUF6,
                       label: sat_sbUlw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUF6: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedArrow1_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUlv_entry() //  [R1, R2, R3]
         { info_tbl: [(cbUFe,
                       label: sat_sbUlv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUFe: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedArrow2_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUlu_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbUFm,
                       label: sat_sbUlu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUFm: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUlt_entry() //  [R1, R2, R3]
         { info_tbl: [(cbUFu,
                       label: sat_sbUlt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUFu: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fApplicativeWrappedArrow4_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUls_entry() //  [R1, R2]
         { info_tbl: [(cbUFC,
                       label: sat_sbUls_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUFC: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fApplicativeWrappedArrow5_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUlr_entry() //  [R1]
         { info_tbl: [(cbUFJ,
                       label: sat_sbUlr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUFJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUFK; else goto cbUFL;
       cbUFK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUFL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fFunctorWrappedArrow_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeWrappedArrow_entry() //  [R2]
         { info_tbl: [(cbUFN,
                       label: Control.Applicative.$fApplicativeWrappedArrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUFN: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cbUFR; else goto cbUFQ;
       cbUFR: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeWrappedArrow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUFQ: // global
           I64[Hp - 152] = sat_sbUlw_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbUlv_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbUlu_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbUlt_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbUls_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbUlr_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 87;
           P64[Hp - 24] = Hp - 102;
           P64[Hp - 16] = Hp - 117;
           P64[Hp - 8] = Hp - 134;
           P64[Hp] = Hp - 150;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.536102826 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_closure" {
     Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_closure:
         const Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_info;
 },
 sat_sbUlz_entry() //  [R1]
         { info_tbl: [(cbUGC,
                       label: sat_sbUlz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUGC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUGD; else goto cbUGE;
       cbUGD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUGE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_entry() //  [R2,
                                                                            R3]
         { info_tbl: [(cbUGF,
                       label: Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUGF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUGJ; else goto cbUGI;
       cbUGJ: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUGI: // global
           I64[Hp - 16] = sat_sbUlz_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Applicative.$fApplicativeWrappedArrow_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.541481483 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow1_closure" {
     Control.Applicative.$fAlternativeWrappedArrow1_closure:
         const Control.Applicative.$fAlternativeWrappedArrow1_info;
 },
 Control.Applicative.$fAlternativeWrappedArrow1_entry() //  []
         { info_tbl: [(cbUGY,
                       label: Control.Applicative.$fAlternativeWrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUGY: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.546171645 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow_$csome_closure" {
     Control.Applicative.$fAlternativeWrappedArrow_$csome_closure:
         const Control.Applicative.$fAlternativeWrappedArrow_$csome_info;
 },
 sat_sbUlG_entry() //  [R1]
         { info_tbl: [(cbUHr,
                       label: sat_sbUlG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUHr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbUHs; else goto cbUHt;
       cbUHs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUHt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Applicative.$fAlternativeWrappedArrow1_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbUlH_entry() //  [R1]
         { info_tbl: [(cbUHu,
                       label: sat_sbUlH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUHu: // global
           _sbUlH::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbUHv; else goto cbUHw;
       cbUHw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUHy; else goto cbUHx;
       cbUHy: // global
           HpAlloc = 24;
           goto cbUHv;
       cbUHv: // global
           R1 = _sbUlH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUHx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbUlH::P64;
           _sbUlC::P64 = P64[_sbUlH::P64 + 16];
           _sbUlE::P64 = P64[_sbUlH::P64 + 24];
           _sbUlF::P64 = P64[_sbUlH::P64 + 32];
           I64[Hp - 16] = sat_sbUlG_info;
           P64[Hp] = _sbUlF::P64;
           R2 = _sbUlC::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sbUlE::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call Control.Arrow.<+>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 some_v_sbUlE_entry() //  [R1]
         { info_tbl: [(cbUHz,
                       label: some_v_sbUlE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUHz: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbUHA; else goto cbUHB;
       cbUHA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUHB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cbUHf_info;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = R1;
           Sp = Sp - 48;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbUHf() //  [R1]
         { info_tbl: [(cbUHf,
                       label: block_cbUHf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUHf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbUHE; else goto cbUHD;
       cbUHE: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbUHD: // global
           I64[Hp - 32] = sat_sbUlH_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R5 = Hp - 32;
           R4 = P64[Sp + 16];
           R3 = GHC.Types.:_closure+2;
           R2 = R1;
           Sp = Sp + 32;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow_$csome_entry() //  [R2,
                                                                   R3, R4]
         { info_tbl: [(cbUHF,
                       label: Control.Applicative.$fAlternativeWrappedArrow_$csome_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUHF: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbUHJ; else goto cbUHI;
       cbUHJ: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedArrow_$csome_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUHI: // global
           I64[Hp - 32] = some_v_sbUlE_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.558286642 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow_$cmany_closure" {
     Control.Applicative.$fAlternativeWrappedArrow_$cmany_closure:
         const Control.Applicative.$fAlternativeWrappedArrow_$cmany_info;
 },
 $dApplicative_sbUlM_entry() //  [R1]
         { info_tbl: [(cbUIv,
                       label: $dApplicative_sbUlM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUIv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUIw; else goto cbUIx;
       cbUIw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUIx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.$p1ArrowZero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUlO_entry() //  [R1]
         { info_tbl: [(cbUIC,
                       label: sat_sbUlO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUIC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbUID; else goto cbUIE;
       cbUID: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUIE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Control.Applicative.$fAlternativeWrappedArrow1_closure+1;
           Sp = Sp - 32;
           call Control.Arrow.arr_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbUlN_entry() //  [R1]
         { info_tbl: [(cbUIJ,
                       label: sat_sbUlN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUIJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUIK; else goto cbUIL;
       cbUIK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUIL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 24];
           R4 = P64[R1 + 16];
           R3 = GHC.Types.:_closure+2;
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeWrappedArrow2_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 many_v_sbUlL_entry() //  [R1]
         { info_tbl: [(cbUIM,
                       label: many_v_sbUlL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUIM: // global
           _sbUlL::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbUIN; else goto cbUIO;
       cbUIO: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbUIQ; else goto cbUIP;
       cbUIQ: // global
           HpAlloc = 88;
           goto cbUIN;
       cbUIN: // global
           R1 = _sbUlL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUIP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbUlL::P64;
           _sbUlI::P64 = P64[_sbUlL::P64 + 16];
           _sbUlJ::P64 = P64[_sbUlL::P64 + 24];
           _sbUlK::P64 = P64[_sbUlL::P64 + 32];
           I64[Hp - 80] = $dApplicative_sbUlM_info;
           P64[Hp - 64] = _sbUlI::P64;
           I64[Hp - 56] = sat_sbUlO_info;
           _cbUIr::P64 = Hp - 80;
           P64[Hp - 40] = _cbUIr::P64;
           I64[Hp - 32] = sat_sbUlN_info;
           P64[Hp - 16] = _sbUlK::P64;
           P64[Hp - 8] = _sbUlL::P64;
           P64[Hp] = _cbUIr::P64;
           R2 = _sbUlJ::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call Control.Arrow.<+>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow_$cmany_entry() //  [R2,
                                                                   R3, R4]
         { info_tbl: [(cbUIR,
                       label: Control.Applicative.$fAlternativeWrappedArrow_$cmany_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUIR: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbUIV; else goto cbUIU;
       cbUIV: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedArrow_$cmany_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUIU: // global
           I64[Hp - 32] = many_v_sbUlL_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.571345347 UTC

[section ""data" . Control.Applicative.$fAlternativeWrappedArrow_closure" {
     Control.Applicative.$fAlternativeWrappedArrow_closure:
         const Control.Applicative.$fAlternativeWrappedArrow_info;
 },
 sat_sbUlX_entry() //  [R1, R2]
         { info_tbl: [(cbUJD,
                       label: sat_sbUlX_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUJD: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Applicative.$fAlternativeWrappedArrow_$cmany_entry(R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUlW_entry() //  [R1, R2]
         { info_tbl: [(cbUJL,
                       label: sat_sbUlW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUJL: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call Control.Applicative.$fAlternativeWrappedArrow_$csome_entry(R4,
                                                                           R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUlV_entry() //  [R1, R2, R3]
         { info_tbl: [(cbUJT,
                       label: sat_sbUlV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUJT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbUJU; else goto cbUJV;
       cbUJU: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUJV: // global
           _sbUlT::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sbUlT::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call Control.Arrow.<+>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbUlS_entry() //  [R1]
         { info_tbl: [(cbUK0,
                       label: sat_sbUlS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUK0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUK1; else goto cbUK2;
       cbUK1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUK2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Arrow.zeroArrow_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUlR_entry() //  [R1]
         { info_tbl: [(cbUK7,
                       label: sat_sbUlR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUK7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUK8; else goto cbUK9;
       cbUK8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUK9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative_entry(R3,
                                                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeWrappedArrow_entry() //  [R2, R3]
         { info_tbl: [(cbUKb,
                       label: Control.Applicative.$fAlternativeWrappedArrow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUKb: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cbUKf; else goto cbUKe;
       cbUKf: // global
           HpAlloc = 168;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeWrappedArrow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUKe: // global
           I64[Hp - 160] = sat_sbUlX_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sbUlW_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sbUlV_info;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_sbUlS_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbUlR_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 96;
           P64[Hp - 16] = Hp - 110;
           P64[Hp - 8] = Hp - 135;
           P64[Hp] = Hp - 159;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.584576723 UTC

[section ""data" . Control.Applicative.$wunsafeDrop_closure" {
     Control.Applicative.$wunsafeDrop_closure:
         const Control.Applicative.$wunsafeDrop_info;
 },
 Control.Applicative.$wunsafeDrop_entry() //  [R2, R3]
         { info_tbl: [(cbUL2,
                       label: Control.Applicative.$wunsafeDrop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUL2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbUL3; else goto ubULh;
       cbUL3: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$wunsafeDrop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ubULh: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cbUKS() args: 0, res: 0, upd: 0;
     }
 },
 _cbUKS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUKS: // global
           I64[Sp - 8] = block_cbUKV_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubULj; else goto cbUKW;
       ubULj: // global
           call _cbUKV(R1) args: 0, res: 0, upd: 0;
       cbUKW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbUKV() //  [R1]
         { info_tbl: [(cbUKV,
                       label: block_cbUKV_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUKV: // global
           if (R1 & 7 == 1) goto cbUKZ; else goto cbUL0;
       cbUKZ: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbUL0: // global
           _sbUm2::P64 = P64[R1 + 14];
           _sbUm3::I64 = I64[Sp + 8];
           if (_sbUm3::I64 != 1) goto cbULd; else goto cbULe;
       cbULd: // global
           I64[Sp + 8] = _sbUm3::I64 - 1;
           P64[Sp + 16] = _sbUm2::P64;
           Sp = Sp + 8;
           call _cbUKS() args: 0, res: 0, upd: 0;
       cbULe: // global
           R1 = _sbUm2::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.592674781 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList2_closure" {
     Control.Applicative.$fAlternativeZipList2_closure:
         const Control.Applicative.$fAlternativeZipList2_info;
 },
 sat_sbUm9_entry() //  [R1]
         { info_tbl: [(cbULP,
                       label: sat_sbUm9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbULP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbULQ; else goto cbULR;
       cbULQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbULR: // global
           I64[Sp - 16] = block_cbULN_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbULN() //  [R1]
         { info_tbl: [(cbULN,
                       label: block_cbULN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbULN: // global
           _sbUm6::P64 = P64[Sp + 8];
           if (%MO_S_Gt_W64(R1, 0)) goto cbULY; else goto cbULZ;
       cbULY: // global
           R3 = _sbUm6::P64;
           R2 = R1;
           Sp = Sp + 16;
           call Control.Applicative.$wunsafeDrop_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       cbULZ: // global
           R1 = _sbUm6::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fAlternativeZipList2_entry() //  [R2, R3]
         { info_tbl: [(cbUM0,
                       label: Control.Applicative.$fAlternativeZipList2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUM0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbUM4; else goto cbUM3;
       cbUM4: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeZipList2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUM3: // global
           I64[Hp - 24] = sat_sbUm9_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = R2;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.600248243 UTC

[section ""data" . Control.Applicative.$fGeneric1ZipList1_closure" {
     Control.Applicative.$fGeneric1ZipList1_closure:
         const Control.Applicative.$fGeneric1ZipList1_info;
 },
 Control.Applicative.$fGeneric1ZipList1_entry() //  [R2]
         { info_tbl: [(cbUMp,
                       label: Control.Applicative.$fGeneric1ZipList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUMp: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.603584233 UTC

[section ""data" . Control.Applicative.$fGeneric1ZipList2_closure" {
     Control.Applicative.$fGeneric1ZipList2_closure:
         const Control.Applicative.$fGeneric1ZipList2_info;
 },
 Control.Applicative.$fGeneric1ZipList2_entry() //  [R2]
         { info_tbl: [(cbUMA,
                       label: Control.Applicative.$fGeneric1ZipList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUMA: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.606868467 UTC

[section ""data" . Control.Applicative.$fGeneric1ZipList_closure" {
     Control.Applicative.$fGeneric1ZipList_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Control.Applicative.$fGeneric1ZipList2_closure+1;
         const Control.Applicative.$fGeneric1ZipList1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.608726326 UTC

[section ""data" . Control.Applicative.$fGenericZipList1_closure" {
     Control.Applicative.$fGenericZipList1_closure:
         const Control.Applicative.$fGenericZipList1_info;
 },
 Control.Applicative.$fGenericZipList1_entry() //  [R2]
         { info_tbl: [(cbUMO,
                       label: Control.Applicative.$fGenericZipList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUMO: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.612793289 UTC

[section ""data" . Control.Applicative.$fGenericZipList2_closure" {
     Control.Applicative.$fGenericZipList2_closure:
         const Control.Applicative.$fGenericZipList2_info;
 },
 Control.Applicative.$fGenericZipList2_entry() //  [R2]
         { info_tbl: [(cbUMZ,
                       label: Control.Applicative.$fGenericZipList2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUMZ: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.616081394 UTC

[section ""data" . Control.Applicative.$fGenericZipList_closure" {
     Control.Applicative.$fGenericZipList_closure:
         const GHC.Generics.C:Generic_con_info;
         const Control.Applicative.$fGenericZipList2_closure+1;
         const Control.Applicative.$fGenericZipList1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.618634964 UTC

[section ""data" . Control.Applicative.$fFoldableZipList_closure" {
     Control.Applicative.$fFoldableZipList_closure:
         const Data.Foldable.C:Foldable_con_info;
         const Data.Foldable.$fFoldableNonEmpty_$cfold1_closure+2;
         const Data.Foldable.$fFoldable[]_$cfoldMap_closure+3;
         const GHC.Base.foldr_closure+3;
         const Data.Foldable.$fFoldable[]_$cfoldr'_closure+3;
         const GHC.List.foldl_closure+3;
         const GHC.List.foldl'_closure+3;
         const GHC.List.foldr1_closure+2;
         const GHC.List.foldl1_closure+2;
         const GHC.Base.id_closure+1;
         const GHC.List.null_closure+1;
         const GHC.List.length_closure+1;
         const GHC.List.elem_closure+3;
         const GHC.List.maximum_closure+2;
         const GHC.List.minimum_closure+2;
         const GHC.List.sum_closure+1;
         const GHC.List.product_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.620731894 UTC

[section ""data" . Control.Applicative.$fFunctorZipList_closure" {
     Control.Applicative.$fFunctorZipList_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.map_closure+2;
         const GHC.Base.$fFunctor[]_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.6233521 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList6_closure" {
     Control.Applicative.$fApplicativeZipList6_closure:
         const Control.Applicative.$fApplicativeZipList6_info;
 },
 sat_sbUmn_entry() //  [R1]
         { info_tbl: [(cbUNv,
                       label: sat_sbUmn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUNv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUNw; else goto cbUNx;
       cbUNw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUNx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fApplicativeZipList6_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeZipList6_entry() //  [R2, R3]
         { info_tbl: [(cbUNC,
                       label: Control.Applicative.$fApplicativeZipList6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUNC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbUND; else goto cbUNE;
       cbUND: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeZipList6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUNE: // global
           I64[Sp - 16] = block_cbUNf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubUNY; else goto cbUNg;
       ubUNY: // global
           call _cbUNf(R1) args: 0, res: 0, upd: 0;
       cbUNg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbUNf() //  [R1]
         { info_tbl: [(cbUNf,
                       label: block_cbUNf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUNf: // global
           if (R1 & 7 == 1) goto ubUNT; else goto cbUNA;
       ubUNT: // global
           Sp = Sp + 16;
           call _cbUNL() args: 0, res: 0, upd: 0;
       cbUNA: // global
           I64[Sp - 8] = block_cbUNl_info;
           _sbUmh::P64 = P64[R1 + 6];
           _sbUmi::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbUmi::P64;
           P64[Sp + 8] = _sbUmh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubUNV; else goto cbUNm;
       ubUNV: // global
           call _cbUNl(R1) args: 0, res: 0, upd: 0;
       cbUNm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbUNl() //  [R1]
         { info_tbl: [(cbUNl,
                       label: block_cbUNl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUNl: // global
           if (R1 & 7 == 1) goto ubUNU; else goto cbUNO;
       ubUNU: // global
           Sp = Sp + 24;
           call _cbUNL() args: 0, res: 0, upd: 0;
       cbUNO: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbUNR; else goto cbUNQ;
       cbUNR: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbUNQ: // global
           _sbUmk::P64 = P64[R1 + 6];
           _sbUml::P64 = P64[R1 + 14];
           I64[Hp - 80] = sat_sbUmn_info;
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _sbUml::P64;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sbUmk::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbUNL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUNL: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.635035283 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList5_closure" {
     Control.Applicative.$fApplicativeZipList5_closure:
         const Control.Applicative.$fApplicativeZipList5_info;
 },
 Control.Applicative.$fApplicativeZipList5_entry() //  [R2, R3]
         { info_tbl: [(cbUOD,
                       label: Control.Applicative.$fApplicativeZipList5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUOD: // global
           R3 = R3;
           R2 = R2;
           call Control.Applicative.$fApplicativeZipList6_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.639035838 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList4_closure" {
     Control.Applicative.$fApplicativeZipList4_closure:
         const Control.Applicative.$fApplicativeZipList4_info;
 },
 sat_sbUmy_entry() //  [R1]
         { info_tbl: [(cbUP4,
                       label: sat_sbUmy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUP4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUP5; else goto cbUP6;
       cbUP5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUP6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fApplicativeZipList4_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeZipList4_entry() //  [R2, R3]
         { info_tbl: [(cbUPb,
                       label: Control.Applicative.$fApplicativeZipList4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUPb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUPc; else goto cbUPd;
       cbUPc: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeZipList4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUPd: // global
           I64[Sp - 16] = block_cbUOO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubUPw; else goto cbUOP;
       ubUPw: // global
           call _cbUOO(R1) args: 0, res: 0, upd: 0;
       cbUOP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbUOO() //  [R1]
         { info_tbl: [(cbUOO,
                       label: block_cbUOO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUOO: // global
           if (R1 & 7 == 1) goto ubUPr; else goto cbUP9;
       ubUPr: // global
           Sp = Sp + 16;
           call _cbUPk() args: 0, res: 0, upd: 0;
       cbUP9: // global
           I64[Sp] = block_cbUOU_info;
           _sbUmu::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbUmu::P64;
           if (R1 & 7 != 0) goto ubUPt; else goto cbUOV;
       ubUPt: // global
           call _cbUOU(R1) args: 0, res: 0, upd: 0;
       cbUOV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbUOU() //  [R1]
         { info_tbl: [(cbUOU,
                       label: block_cbUOU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUOU: // global
           if (R1 & 7 == 1) goto ubUPs; else goto cbUPm;
       ubUPs: // global
           Sp = Sp + 16;
           call _cbUPk() args: 0, res: 0, upd: 0;
       cbUPm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbUPp; else goto cbUPo;
       cbUPp: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbUPo: // global
           _sbUmw::P64 = P64[R1 + 6];
           _sbUmx::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_sbUmy_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sbUmx::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sbUmw::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbUPk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUPk: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.650005241 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList3_closure" {
     Control.Applicative.$fApplicativeZipList3_closure:
         const Control.Applicative.$fApplicativeZipList3_info;
 },
 Control.Applicative.$fApplicativeZipList3_entry() //  [R2, R3]
         { info_tbl: [(cbUQ8,
                       label: Control.Applicative.$fApplicativeZipList3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUQ8: // global
           R3 = R3;
           R2 = R2;
           call Control.Applicative.$fApplicativeZipList4_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.654027941 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList2_closure" {
     Control.Applicative.$fApplicativeZipList2_closure:
         const Control.Applicative.$fApplicativeZipList2_info;
 },
 sat_sbUmJ_entry() //  [R1]
         { info_tbl: [(cbUQz,
                       label: sat_sbUmJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUQz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUQA; else goto cbUQB;
       cbUQA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUQB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fApplicativeZipList2_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fApplicativeZipList2_entry() //  [R2, R3]
         { info_tbl: [(cbUQG,
                       label: Control.Applicative.$fApplicativeZipList2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUQG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbUQH; else goto cbUQI;
       cbUQH: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fApplicativeZipList2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUQI: // global
           I64[Sp - 16] = block_cbUQj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubUR1; else goto cbUQk;
       ubUR1: // global
           call _cbUQj(R1) args: 0, res: 0, upd: 0;
       cbUQk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbUQj() //  [R1]
         { info_tbl: [(cbUQj,
                       label: block_cbUQj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUQj: // global
           if (R1 & 7 == 1) goto ubUQW; else goto cbUQE;
       ubUQW: // global
           Sp = Sp + 16;
           call _cbUQP() args: 0, res: 0, upd: 0;
       cbUQE: // global
           I64[Sp - 8] = block_cbUQp_info;
           _sbUmE::P64 = P64[R1 + 6];
           _sbUmF::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbUmF::P64;
           P64[Sp + 8] = _sbUmE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubUQY; else goto cbUQq;
       ubUQY: // global
           call _cbUQp(R1) args: 0, res: 0, upd: 0;
       cbUQq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbUQp() //  [R1]
         { info_tbl: [(cbUQp,
                       label: block_cbUQp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUQp: // global
           if (R1 & 7 == 1) goto ubUQX; else goto cbUQR;
       ubUQX: // global
           Sp = Sp + 24;
           call _cbUQP() args: 0, res: 0, upd: 0;
       cbUQR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbUQU; else goto cbUQT;
       cbUQU: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbUQT: // global
           _sbUmI::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_sbUmJ_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sbUmI::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbUQP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUQP: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.66529451 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList1_closure" {
     Control.Applicative.$fApplicativeZipList1_closure:
         const Control.Applicative.$fApplicativeZipList1_info;
 },
 Control.Applicative.$fApplicativeZipList1_entry() //  [R2, R3]
         { info_tbl: [(cbURE,
                       label: Control.Applicative.$fApplicativeZipList1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbURE: // global
           R3 = R3;
           R2 = R2;
           call Control.Applicative.$fApplicativeZipList2_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.668431457 UTC

[section ""data" . Control.Applicative.$fApplicativeZipList_closure" {
     Control.Applicative.$fApplicativeZipList_closure:
         const GHC.Base.C:Applicative_con_info;
         const Control.Applicative.$fFunctorZipList_closure+1;
         const GHC.List.repeat_closure+1;
         const Control.Applicative.$fApplicativeZipList5_closure+2;
         const GHC.List.zipWith_closure+3;
         const Control.Applicative.$fApplicativeZipList3_closure+2;
         const Control.Applicative.$fApplicativeZipList1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.670533878 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList_xs_closure" {
     Control.Applicative.$fAlternativeZipList_xs_closure:
         const :_con_info;
         const GHC.Types.[]_closure+1;
         const Control.Applicative.$fAlternativeZipList_xs_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.673137036 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList1_closure" {
     Control.Applicative.$fAlternativeZipList1_closure:
         const Control.Applicative.$fAlternativeZipList1_info;
 },
 sat_sbUmV_entry() //  [R1]
         { info_tbl: [(cbUS7,
                       label: sat_sbUmV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUS7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUS8; else goto cbUS9;
       cbUS8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUS9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeZipList1_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeZipList1_entry() //  [R2, R3]
         { info_tbl: [(cbUSe,
                       label: Control.Applicative.$fAlternativeZipList1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUSe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbUSf; else goto cbUSg;
       cbUSf: // global
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeZipList1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUSg: // global
           I64[Sp - 16] = block_cbURR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubUSA; else goto cbURS;
       ubUSA: // global
           call _cbURR(R1) args: 0, res: 0, upd: 0;
       cbURS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbURR() //  [R1]
         { info_tbl: [(cbURR,
                       label: block_cbURR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbURR: // global
           if (R1 & 7 == 1) goto ubUSv; else goto cbUSc;
       ubUSv: // global
           Sp = Sp + 16;
           call _cbUSn() args: 0, res: 0, upd: 0;
       cbUSc: // global
           I64[Sp - 8] = block_cbURX_info;
           _sbUmP::P64 = P64[R1 + 6];
           _sbUmQ::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbUmQ::P64;
           P64[Sp + 8] = _sbUmP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubUSx; else goto cbURY;
       ubUSx: // global
           call _cbURX(R1) args: 0, res: 0, upd: 0;
       cbURY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbURX() //  [R1]
         { info_tbl: [(cbURX,
                       label: block_cbURX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbURX: // global
           if (R1 & 7 == 1) goto ubUSw; else goto cbUSq;
       ubUSw: // global
           Sp = Sp + 24;
           call _cbUSn() args: 0, res: 0, upd: 0;
       cbUSq: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbUSt; else goto cbUSs;
       cbUSt: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbUSs: // global
           _sbUmS::P64 = P64[R1 + 6];
           _sbUmT::P64 = P64[R1 + 14];
           I64[Hp - 72] = sat_sbUmV_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _sbUmT::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sbUmS::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbUSn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUSn: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.685257653 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList_$csome_closure" {
     Control.Applicative.$fAlternativeZipList_$csome_closure:
         const Control.Applicative.$fAlternativeZipList_$csome_info;
 },
 sat_sbUmY_entry() //  [R1]
         { info_tbl: [(cbUTn,
                       label: sat_sbUmY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUTn: // global
           R3 = Control.Applicative.$fAlternativeZipList_xs_closure+2;
           R2 = P64[R1 + 16];
           call Control.Applicative.$fAlternativeZipList2_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 some_v_sbUmX_entry() //  [R1]
         { info_tbl: [(cbUTq,
                       label: some_v_sbUmX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUTq: // global
           _sbUmX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbUTr; else goto cbUTs;
       cbUTs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUTu; else goto cbUTt;
       cbUTu: // global
           HpAlloc = 24;
           goto cbUTr;
       cbUTr: // global
           R1 = _sbUmX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUTt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbUmX::P64;
           _sbUmW::P64 = P64[_sbUmX::P64 + 16];
           I64[Hp - 16] = sat_sbUmY_info;
           P64[Hp] = _sbUmX::P64;
           R3 = Hp - 16;
           R2 = _sbUmW::P64;
           Sp = Sp - 16;
           call Control.Applicative.$fAlternativeZipList1_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeZipList_$csome_entry() //  [R2]
         { info_tbl: [(cbUTv,
                       label: Control.Applicative.$fAlternativeZipList_$csome_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUTv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUTz; else goto cbUTy;
       cbUTz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeZipList_$csome_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUTy: // global
           I64[Hp - 16] = some_v_sbUmX_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.693108922 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList_$cmany_closure" {
     Control.Applicative.$fAlternativeZipList_$cmany_closure:
         const Control.Applicative.$fAlternativeZipList_$cmany_info;
 },
 many_v_sbUn0_entry() //  [R1]
         { info_tbl: [(cbUU0,
                       label: many_v_sbUn0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUU0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbUU1; else goto cbUU2;
       cbUU1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUU2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbUTY_info;
           R3 = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Control.Applicative.$fAlternativeZipList1_entry(R3,
                                                                R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbUTY() //  [R1]
         { info_tbl: [(cbUTY,
                       label: block_cbUTY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUTY: // global
           R3 = Control.Applicative.$fAlternativeZipList_xs_closure+2;
           R2 = R1;
           Sp = Sp + 8;
           call Control.Applicative.$fAlternativeZipList2_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fAlternativeZipList_$cmany_entry() //  [R2]
         { info_tbl: [(cbUU6,
                       label: Control.Applicative.$fAlternativeZipList_$cmany_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUU6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUUa; else goto cbUU9;
       cbUUa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fAlternativeZipList_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUU9: // global
           I64[Hp - 16] = many_v_sbUn0_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.701853886 UTC

[section ""data" . Control.Applicative.$fAlternativeZipList_closure" {
     Control.Applicative.$fAlternativeZipList_closure:
         const GHC.Base.C:Alternative_con_info;
         const Control.Applicative.$fApplicativeZipList_closure+1;
         const GHC.Types.[]_closure+1;
         const Control.Applicative.$fAlternativeZipList2_closure+2;
         const Control.Applicative.$fAlternativeZipList_$csome_closure+1;
         const Control.Applicative.$fAlternativeZipList_$cmany_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.703825189 UTC

[section ""cstring" . Control.Applicative.$fReadZipList11_bytes" {
     Control.Applicative.$fReadZipList11_bytes:
         I8[] [90,105,112,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.705957248 UTC

[section ""data" . Control.Applicative.$fReadZipList10_closure" {
     Control.Applicative.$fReadZipList10_closure:
         const Control.Applicative.$fReadZipList10_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Applicative.$fReadZipList10_entry() //  [R1]
         { info_tbl: [(cbUUz,
                       label: Control.Applicative.$fReadZipList10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUUz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUUA; else goto cbUUB;
       cbUUA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUUB: // global
           (_cbUUw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbUUw::I64 == 0) goto cbUUy; else goto cbUUx;
       cbUUy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbUUx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbUUw::I64;
           R2 = Control.Applicative.$fReadZipList11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.710106062 UTC

[section ""data" . Control.Applicative.$fReadZipList_lexeme1_closure" {
     Control.Applicative.$fReadZipList_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Control.Applicative.$fReadZipList10_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.711912102 UTC

[section ""cstring" . Control.Applicative.$fReadZipList9_bytes" {
     Control.Applicative.$fReadZipList9_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.713855335 UTC

[section ""data" . Control.Applicative.$fReadZipList8_closure" {
     Control.Applicative.$fReadZipList8_closure:
         const Control.Applicative.$fReadZipList8_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Applicative.$fReadZipList8_entry() //  [R1]
         { info_tbl: [(cbUUS,
                       label: Control.Applicative.$fReadZipList8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUUS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUUT; else goto cbUUU;
       cbUUT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUUU: // global
           (_cbUUP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbUUP::I64 == 0) goto cbUUR; else goto cbUUQ;
       cbUUR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbUUQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbUUP::I64;
           R2 = Control.Applicative.$fReadZipList9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.7181656 UTC

[section ""data" . Control.Applicative.$fReadZipList_lexeme_closure" {
     Control.Applicative.$fReadZipList_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const Control.Applicative.$fReadZipList8_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.719910857 UTC

[section ""cstring" . Control.Applicative.$fReadZipList7_bytes" {
     Control.Applicative.$fReadZipList7_bytes:
         I8[] [103,101,116,90,105,112,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.72195383 UTC

[section ""data" . Control.Applicative.$fReadZipList6_closure" {
     Control.Applicative.$fReadZipList6_closure:
         const Control.Applicative.$fReadZipList6_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Applicative.$fReadZipList6_entry() //  [R1]
         { info_tbl: [(cbUVb,
                       label: Control.Applicative.$fReadZipList6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUVb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUVc; else goto cbUVd;
       cbUVc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUVd: // global
           (_cbUV8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbUV8::I64 == 0) goto cbUVa; else goto cbUV9;
       cbUVa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbUV9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbUV8::I64;
           R2 = Control.Applicative.$fReadZipList7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.726198439 UTC

[section ""data" . Control.Applicative.$fReadZipList5_closure" {
     Control.Applicative.$fReadZipList5_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.728756244 UTC

[section ""cstring" . Control.Applicative.$fReadZipList4_bytes" {
     Control.Applicative.$fReadZipList4_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.731158637 UTC

[section ""data" . Control.Applicative.$fReadZipList3_closure" {
     Control.Applicative.$fReadZipList3_closure:
         const Control.Applicative.$fReadZipList3_info;
         const 0;
         const 0;
         const 0;
 },
 Control.Applicative.$fReadZipList3_entry() //  [R1]
         { info_tbl: [(cbUVu,
                       label: Control.Applicative.$fReadZipList3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUVu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUVv; else goto cbUVw;
       cbUVv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUVw: // global
           (_cbUVr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbUVr::I64 == 0) goto cbUVt; else goto cbUVs;
       cbUVt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbUVs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbUVr::I64;
           R2 = Control.Applicative.$fReadZipList4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.735214051 UTC

[section ""data" . Control.Applicative.$fReadZipList2_closure" {
     Control.Applicative.$fReadZipList2_closure:
         const Text.Read.Lex.Punc_con_info;
         const Control.Applicative.$fReadZipList3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.738928807 UTC

[section ""data" . Control.Applicative.$fReadZipList1_closure" {
     Control.Applicative.$fReadZipList1_closure:
         const Control.Applicative.$fReadZipList1_info;
         const 0;
 },
 lvl_sbUn3_entry() //  [R1]
         { info_tbl: [(cbUVO,
                       label: lvl_sbUn3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUVO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbUVP; else goto cbUVQ;
       cbUVP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUVQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readListPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_sbUn4_entry() //  [R1]
         { info_tbl: [(cbUVW,
                       label: ds_sbUn4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUVW: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUnf_entry() //  [R1]
         { info_tbl: [(cbUWx,
                       label: sat_sbUnf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUWx: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUni_entry() //  [R1, R2]
         { info_tbl: [(cbUWD,
                       label: sat_sbUni_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUWD: // global
           _sbUnd::P64 = R2;
           _sbUni::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cbUWE; else goto cbUWF;
       cbUWF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUWH; else goto cbUWG;
       cbUWH: // global
           HpAlloc = 24;
           goto cbUWE;
       cbUWE: // global
           R2 = _sbUnd::P64;
           R1 = _sbUni::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUWG: // global
           _sbUn7::P64 = P64[_sbUni::P64 + 7];
           I64[Hp - 16] = sat_sbUnf_info;
           P64[Hp - 8] = _sbUn7::P64;
           P64[Hp] = _sbUnd::P64;
           I64[Sp - 8] = block_cbUWA_info;
           R3 = Hp - 15;
           R2 = Control.Applicative.$fReadZipList2_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbUWA() //  [R1]
         { info_tbl: [(cbUWA,
                       label: block_cbUWA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUWA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbUWK; else goto cbUWJ;
       cbUWK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbUWJ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUnj_entry() //  [R1, R2]
         { info_tbl: [(cbUWL,
                       label: sat_sbUnj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUWL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbUWP; else goto cbUWO;
       cbUWP: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUWO: // global
           _sbUn4::P64 = P64[R1 + 7];
           _sbUn7::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sbUni_info;
           P64[Hp] = _sbUn7::P64;
           R5 = Hp - 7;
           R4 = Control.Applicative.$fReadZipList5_closure+1;
           R3 = _sbUn4::P64;
           R2 = Control.Applicative.$fReadZipList6_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUnm_entry() //  [R1, R2]
         { info_tbl: [(cbUWT,
                       label: sat_sbUnm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUWT: // global
           _sbUnb::P64 = R2;
           _sbUnm::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cbUWU; else goto cbUWV;
       cbUWV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUWX; else goto cbUWW;
       cbUWX: // global
           HpAlloc = 24;
           goto cbUWU;
       cbUWU: // global
           R2 = _sbUnb::P64;
           R1 = _sbUnm::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUWW: // global
           _sbUn4::P64 = P64[_sbUnm::P64 + 7];
           _sbUn7::P64 = P64[_sbUnm::P64 + 15];
           I64[Hp - 16] = sat_sbUnj_info;
           P64[Hp - 8] = _sbUn4::P64;
           P64[Hp] = _sbUn7::P64;
           I64[Sp - 8] = block_cbUWQ_info;
           R3 = Hp - 15;
           R2 = Control.Applicative.$fReadZipList_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbUWQ() //  [R1]
         { info_tbl: [(cbUWQ,
                       label: block_cbUWQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUWQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbUX0; else goto cbUWZ;
       cbUX0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbUWZ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUnp_entry() //  [R1, R2, R3]
         { info_tbl: [(cbUX1,
                       label: sat_sbUnp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUX1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbUX2; else goto cbUX3;
       cbUX2: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUX3: // global
           I64[Sp - 24] = block_cbUW4_info;
           _sbUn4::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _sbUn4::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubUXg; else goto cbUW5;
       ubUXg: // global
           call _cbUW4(R1) args: 0, res: 0, upd: 0;
       cbUW5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbUW4() //  [R1]
         { info_tbl: [(cbUW4,
                       label: block_cbUW4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUW4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUX6; else goto cbUX5;
       cbUX6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbUX5: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto cbUX8; else goto cbUXc;
       cbUX8: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbUXc: // global
           I64[Hp - 16] = sat_sbUnm_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cbUX9_info;
           R3 = Hp - 15;
           R2 = Control.Applicative.$fReadZipList_lexeme1_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbUX9() //  [R1]
         { info_tbl: [(cbUX9,
                       label: block_cbUX9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUX9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbUXf; else goto cbUXe;
       cbUXf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbUXe: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fReadZipList1_entry() //  [R2]
         { info_tbl: [(cbUXh,
                       label: Control.Applicative.$fReadZipList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUXh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbUXl; else goto cbUXk;
       cbUXl: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUXk: // global
           I64[Hp - 48] = lvl_sbUn3_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_sbUn4_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_sbUnp_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.768452047 UTC

[section ""data" . Control.Applicative.$fReadZipList_$creadsPrec_closure" {
     Control.Applicative.$fReadZipList_$creadsPrec_closure:
         const Control.Applicative.$fReadZipList_$creadsPrec_info;
         const 0;
 },
 ds_sbUnr_entry() //  [R1]
         { info_tbl: [(cbUYC,
                       label: ds_sbUnr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUYC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUYD; else goto cbUYE;
       cbUYD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUYE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUnt_entry() //  [R1]
         { info_tbl: [(cbUYO,
                       label: sat_sbUnt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUYO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbUYP; else goto cbUYQ;
       cbUYP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbUYQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUnu_entry() //  [R1, R2]
         { info_tbl: [(cbUYR,
                       label: sat_sbUnu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUYR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbUYV; else goto cbUYU;
       cbUYV: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUYU: // global
           _sbUnr::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sbUnt_info;
           P64[Hp - 8] = _sbUnr::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fReadZipList_$creadsPrec_entry() //  [R2]
         { info_tbl: [(cbUYW,
                       label: Control.Applicative.$fReadZipList_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUYW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbUZ0; else goto cbUYZ;
       cbUZ0: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUYZ: // global
           I64[Hp - 32] = ds_sbUnr_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_sbUnu_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.782285447 UTC

[section ""data" . Control.Applicative.$fReadZipList_$creadListPrec_closure" {
     Control.Applicative.$fReadZipList_$creadListPrec_closure:
         const Control.Applicative.$fReadZipList_$creadListPrec_info;
         const 0;
 },
 sat_sbUnw_entry() //  [R1]
         { info_tbl: [(cbUZx,
                       label: sat_sbUnw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUZx: // global
           R2 = P64[R1 + 16];
           call Control.Applicative.$fReadZipList1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fReadZipList_$creadListPrec_entry() //  [R2]
         { info_tbl: [(cbUZA,
                       label: Control.Applicative.$fReadZipList_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUZA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbUZE; else goto cbUZD;
       cbUZE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbUZD: // global
           I64[Hp - 16] = sat_sbUnw_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.789806408 UTC

[section ""data" . Control.Applicative.$fReadZipList_$creadList_closure" {
     Control.Applicative.$fReadZipList_$creadList_closure:
         const Control.Applicative.$fReadZipList_$creadList_info;
         const 0;
 },
 sat_sbUny_entry() //  [R1]
         { info_tbl: [(cbUZZ,
                       label: sat_sbUny_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUZZ: // global
           R2 = P64[R1 + 16];
           call Control.Applicative.$fReadZipList1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUnz_entry() //  [R1]
         { info_tbl: [(cbV02,
                       label: sat_sbUnz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV02: // global
           _sbUnz::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbV03; else goto cbV04;
       cbV04: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbV06; else goto cbV05;
       cbV06: // global
           HpAlloc = 24;
           goto cbV03;
       cbV03: // global
           R1 = _sbUnz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbV05: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbUnz::P64;
           _sbUnx::P64 = P64[_sbUnz::P64 + 16];
           I64[Hp - 16] = sat_sbUny_info;
           P64[Hp] = _sbUnx::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fReadZipList_$creadList_entry() //  [R2]
         { info_tbl: [(cbV07,
                       label: Control.Applicative.$fReadZipList_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV07: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbV0b; else goto cbV0a;
       cbV0b: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbV0a: // global
           I64[Hp - 16] = sat_sbUnz_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.800185008 UTC

[section ""data" . Control.Applicative.$fReadZipList_closure" {
     Control.Applicative.$fReadZipList_closure:
         const Control.Applicative.$fReadZipList_info;
         const 0;
 },
 sat_sbUnE_entry() //  [R1]
         { info_tbl: [(cbV0D,
                       label: sat_sbUnE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV0D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbV0E; else goto cbV0F;
       cbV0E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbV0F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUnD_entry() //  [R1]
         { info_tbl: [(cbV0K,
                       label: sat_sbUnD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV0K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbV0L; else goto cbV0M;
       cbV0L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbV0M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUnC_entry() //  [R1]
         { info_tbl: [(cbV0R,
                       label: sat_sbUnC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV0R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbV0S; else goto cbV0T;
       cbV0S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbV0T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUnB_entry() //  [R1]
         { info_tbl: [(cbV0Y,
                       label: sat_sbUnB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV0Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbV0Z; else goto cbV10;
       cbV0Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbV10: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fReadZipList_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fReadZipList_entry() //  [R2]
         { info_tbl: [(cbV12,
                       label: Control.Applicative.$fReadZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV12: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbV16; else goto cbV15;
       cbV16: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Control.Applicative.$fReadZipList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbV15: // global
           I64[Hp - 128] = sat_sbUnE_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbUnD_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbUnC_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbUnB_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.815741044 UTC

[section ""data" . Control.Applicative.$fEqZipList_closure" {
     Control.Applicative.$fEqZipList_closure:
         const Control.Applicative.$fEqZipList_info;
 },
 sat_sbUnH_entry() //  [R1, R2, R3]
         { info_tbl: [(cbV1O,
                       label: sat_sbUnH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV1O: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fEq[]_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUnG_entry() //  [R1, R2, R3]
         { info_tbl: [(cbV1W,
                       label: sat_sbUnG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV1W: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fEq[]_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fEqZipList_entry() //  [R2]
         { info_tbl: [(cbV20,
                       label: Control.Applicative.$fEqZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV20: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbV24; else goto cbV23;
       cbV24: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Control.Applicative.$fEqZipList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbV23: // global
           I64[Hp - 48] = sat_sbUnH_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sbUnG_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.825545385 UTC

[section ""data" . Control.Applicative.$fOrdZipList_$cp1Ord_closure" {
     Control.Applicative.$fOrdZipList_$cp1Ord_closure:
         const Control.Applicative.$fOrdZipList_$cp1Ord_info;
 },
 sat_sbUnJ_entry() //  [R1]
         { info_tbl: [(cbV2t,
                       label: sat_sbUnJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV2t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbV2u; else goto cbV2v;
       cbV2u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbV2v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fOrdZipList_$cp1Ord_entry() //  [R2]
         { info_tbl: [(cbV2w,
                       label: Control.Applicative.$fOrdZipList_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV2w: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbV2A; else goto cbV2z;
       cbV2A: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Control.Applicative.$fOrdZipList_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbV2z: // global
           I64[Hp - 16] = sat_sbUnJ_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Control.Applicative.$fEqZipList_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.83236893 UTC

[section ""data" . Control.Applicative.$fOrdZipList_closure" {
     Control.Applicative.$fOrdZipList_closure:
         const Control.Applicative.$fOrdZipList_info;
 },
 sat_sbUnS_entry() //  [R1, R2, R3]
         { info_tbl: [(cbV2U,
                       label: sat_sbUnS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV2U: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUnR_entry() //  [R1, R2, R3]
         { info_tbl: [(cbV32,
                       label: sat_sbUnR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV32: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUnQ_entry() //  [R1, R2, R3]
         { info_tbl: [(cbV3a,
                       label: sat_sbUnQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV3a: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUnP_entry() //  [R1, R2, R3]
         { info_tbl: [(cbV3i,
                       label: sat_sbUnP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV3i: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$c>_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUnO_entry() //  [R1, R2, R3]
         { info_tbl: [(cbV3q,
                       label: sat_sbUnO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV3q: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUnN_entry() //  [R1, R2, R3]
         { info_tbl: [(cbV3y,
                       label: sat_sbUnN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV3y: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUnM_entry() //  [R1, R2, R3]
         { info_tbl: [(cbV3G,
                       label: sat_sbUnM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV3G: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUnL_entry() //  [R1]
         { info_tbl: [(cbV3N,
                       label: sat_sbUnL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV3N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbV3O; else goto cbV3P;
       cbV3O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbV3P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fOrdZipList_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fOrdZipList_entry() //  [R2]
         { info_tbl: [(cbV3R,
                       label: Control.Applicative.$fOrdZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV3R: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cbV3V; else goto cbV3U;
       cbV3V: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = Control.Applicative.$fOrdZipList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbV3U: // global
           I64[Hp - 200] = sat_sbUnS_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sbUnR_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_sbUnQ_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sbUnP_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbUnO_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sbUnN_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sbUnM_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbUnL_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.850286935 UTC

[section ""cstring" . Control.Applicative.$fShowZipList3_bytes" {
     Control.Applicative.$fShowZipList3_bytes:
         I8[] [90,105,112,76,105,115,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.852033997 UTC

[section ""cstring" . Control.Applicative.$fShowZipList2_bytes" {
     Control.Applicative.$fShowZipList2_bytes:
         I8[] [103,101,116,90,105,112,76,105,115,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.855756203 UTC

[section ""data" . Control.Applicative.$w$cshowsPrec_closure" {
     Control.Applicative.$w$cshowsPrec_closure:
         const Control.Applicative.$w$cshowsPrec_info;
 },
 f_sbUnW_entry() //  [R1]
         { info_tbl: [(cbV4S,
                       label: f_sbUnW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV4S: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbV4T; else goto cbV4U;
       cbV4T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbV4U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.showList_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbUnZ_entry() //  [R1]
         { info_tbl: [(cbV5f,
                       label: sat_sbUnZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV5f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbV5g; else goto cbV5h;
       cbV5g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbV5h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Control.Applicative.$fReadZipList4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUo0_entry() //  [R1]
         { info_tbl: [(cbV5i,
                       label: sat_sbUo0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV5i: // global
           _sbUo0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbV5j; else goto cbV5k;
       cbV5k: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbV5m; else goto cbV5l;
       cbV5m: // global
           HpAlloc = 24;
           goto cbV5j;
       cbV5j: // global
           R1 = _sbUo0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbV5l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbUo0::P64;
           _sbUnW::P64 = P64[_sbUo0::P64 + 16];
           _sbUnY::P64 = P64[_sbUo0::P64 + 24];
           I64[Hp - 16] = sat_sbUnZ_info;
           P64[Hp] = _sbUnY::P64;
           R2 = Hp - 16;
           R1 = _sbUnW::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUo1_entry() //  [R1]
         { info_tbl: [(cbV5n,
                       label: sat_sbUo1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV5n: // global
           _sbUo1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbV5o; else goto cbV5p;
       cbV5p: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbV5r; else goto cbV5q;
       cbV5r: // global
           HpAlloc = 32;
           goto cbV5o;
       cbV5o: // global
           R1 = _sbUo1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbV5q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbUo1::P64;
           _sbUnW::P64 = P64[_sbUo1::P64 + 16];
           _sbUnY::P64 = P64[_sbUo1::P64 + 24];
           I64[Hp - 24] = sat_sbUo0_info;
           P64[Hp - 8] = _sbUnW::P64;
           P64[Hp] = _sbUnY::P64;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUo2_entry() //  [R1, R2]
         { info_tbl: [(cbV5s,
                       label: sat_sbUo2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV5s: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbV5w; else goto cbV5v;
       cbV5w: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbV5v: // global
           _sbUnW::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_sbUo1_info;
           P64[Hp - 8] = _sbUnW::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUo5_entry() //  [R1]
         { info_tbl: [(cbV5U,
                       label: sat_sbUo5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV5U: // global
           _sbUo5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbV5V; else goto cbV5W;
       cbV5W: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbV5Y; else goto cbV5X;
       cbV5Y: // global
           HpAlloc = 24;
           goto cbV5V;
       cbV5V: // global
           R1 = _sbUo5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbV5X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbUo5::P64;
           _sbUo3::P64 = P64[_sbUo5::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sbUo3::P64;
           R3 = Hp - 14;
           R2 = Control.Applicative.$fReadZipList4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUo6_entry() //  [R1]
         { info_tbl: [(cbV5Z,
                       label: sat_sbUo6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV5Z: // global
           _sbUo6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbV60; else goto cbV61;
       cbV61: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbV63; else goto cbV62;
       cbV63: // global
           HpAlloc = 24;
           goto cbV60;
       cbV60: // global
           R1 = _sbUo6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbV62: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbUo6::P64;
           _sbUnW::P64 = P64[_sbUo6::P64 + 16];
           _sbUo3::P64 = P64[_sbUo6::P64 + 24];
           I64[Hp - 16] = sat_sbUo5_info;
           P64[Hp] = _sbUo3::P64;
           R2 = Hp - 16;
           R1 = _sbUnW::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUo7_entry() //  [R1]
         { info_tbl: [(cbV64,
                       label: sat_sbUo7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV64: // global
           _sbUo7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbV65; else goto cbV66;
       cbV66: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbV68; else goto cbV67;
       cbV68: // global
           HpAlloc = 32;
           goto cbV65;
       cbV65: // global
           R1 = _sbUo7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbV67: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbUo7::P64;
           _sbUnW::P64 = P64[_sbUo7::P64 + 16];
           _sbUo3::P64 = P64[_sbUo7::P64 + 24];
           I64[Hp - 24] = sat_sbUo6_info;
           P64[Hp - 8] = _sbUnW::P64;
           P64[Hp] = _sbUo3::P64;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUo8_entry() //  [R1]
         { info_tbl: [(cbV69,
                       label: sat_sbUo8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV69: // global
           _sbUo8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbV6a; else goto cbV6b;
       cbV6b: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbV6d; else goto cbV6c;
       cbV6d: // global
           HpAlloc = 32;
           goto cbV6a;
       cbV6a: // global
           R1 = _sbUo8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbV6c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbUo8::P64;
           _sbUnW::P64 = P64[_sbUo8::P64 + 16];
           _sbUo3::P64 = P64[_sbUo8::P64 + 24];
           I64[Hp - 24] = sat_sbUo7_info;
           P64[Hp - 8] = _sbUnW::P64;
           P64[Hp] = _sbUo3::P64;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUo9_entry() //  [R1, R2]
         { info_tbl: [(cbV6f,
                       label: sat_sbUo9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV6f: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbV6j; else goto cbV6i;
       cbV6j: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbV6i: // global
           _sbUnW::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_sbUo8_info;
           P64[Hp - 32] = _sbUnW::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cbV6n,
                       label: Control.Applicative.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV6n: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbV6r; else goto cbV6q;
       cbV6r: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbV6q: // global
           I64[Hp - 40] = f_sbUnW_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _cbV4O::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto cbV6l; else goto cbV6m;
       cbV6l: // global
           I64[Hp - 8] = sat_sbUo2_info;
           P64[Hp] = _cbV4O::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbV6m: // global
           I64[Hp - 8] = sat_sbUo9_info;
           P64[Hp] = _cbV4O::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.882706331 UTC

[section ""data" . Control.Applicative.$fShowZipList_$cshowsPrec_closure" {
     Control.Applicative.$fShowZipList_$cshowsPrec_closure:
         const Control.Applicative.$fShowZipList_$cshowsPrec_info;
 },
 Control.Applicative.$fShowZipList_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbV7H,
                       label: Control.Applicative.$fShowZipList_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV7H: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbV7I; else goto cbV7J;
       cbV7I: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fShowZipList_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbV7J: // global
           I64[Sp - 24] = block_cbV7E_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubV7N; else goto cbV7F;
       ubV7N: // global
           call _cbV7E(R1) args: 0, res: 0, upd: 0;
       cbV7F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbV7E() //  [R1]
         { info_tbl: [(cbV7E,
                       label: block_cbV7E_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV7E: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Control.Applicative.$w$cshowsPrec_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.888489394 UTC

[section ""data" . Control.Applicative.$fShowZipList_$cshow_closure" {
     Control.Applicative.$fShowZipList_$cshow_closure:
         const Control.Applicative.$fShowZipList_$cshow_info;
         const 0;
 },
 sat_sbUoh_entry() //  [R1]
         { info_tbl: [(cbV8a,
                       label: sat_sbUoh_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV8a: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbV8b; else goto cbV8c;
       cbV8b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbV8c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Control.Applicative.$fReadZipList3_closure;
           Sp = Sp - 40;
           call GHC.Show.showList_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbUoi_entry() //  [R1]
         { info_tbl: [(cbV8d,
                       label: sat_sbUoi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV8d: // global
           _sbUoi::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbV8e; else goto cbV8f;
       cbV8f: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbV8h; else goto cbV8g;
       cbV8h: // global
           HpAlloc = 32;
           goto cbV8e;
       cbV8e: // global
           R1 = _sbUoi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbV8g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbUoi::P64;
           _sbUof::P64 = P64[_sbUoi::P64 + 16];
           _sbUog::P64 = P64[_sbUoi::P64 + 24];
           I64[Hp - 24] = sat_sbUoh_info;
           P64[Hp - 8] = _sbUof::P64;
           P64[Hp] = _sbUog::P64;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fShowZipList_$cshow_entry() //  [R2, R3]
         { info_tbl: [(cbV8i,
                       label: Control.Applicative.$fShowZipList_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV8i: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbV8m; else goto cbV8l;
       cbV8m: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fShowZipList_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbV8l: // global
           I64[Hp - 24] = sat_sbUoi_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Control.Applicative.$fShowZipList3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.896424611 UTC

[section ""data" . Control.Applicative.$fShowZipList1_closure" {
     Control.Applicative.$fShowZipList1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.898501576 UTC

[section ""data" . Control.Applicative.$fShowZipList_$cshowList_closure" {
     Control.Applicative.$fShowZipList_$cshowList_closure:
         const Control.Applicative.$fShowZipList_$cshowList_info;
 },
 sat_sbUon_entry() //  [R1, R2]
         { info_tbl: [(cbV8Q,
                       label: sat_sbUon_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV8Q: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Control.Applicative.$w$cshowsPrec_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fShowZipList_$cshowList_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cbV8T,
                       label: Control.Applicative.$fShowZipList_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV8T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbV8X; else goto cbV8W;
       cbV8X: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Control.Applicative.$fShowZipList_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbV8W: // global
           I64[Hp - 8] = sat_sbUon_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.904715648 UTC

[section ""data" . Control.Applicative.$fShowZipList_closure" {
     Control.Applicative.$fShowZipList_closure:
         const Control.Applicative.$fShowZipList_info;
         const 0;
 },
 sat_sbUor_entry() //  [R1, R2, R3]
         { info_tbl: [(cbV9f,
                       label: sat_sbUor_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV9f: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fShowZipList_$cshowList_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUoq_entry() //  [R1, R2]
         { info_tbl: [(cbV9n,
                       label: sat_sbUoq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV9n: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Control.Applicative.$fShowZipList_$cshow_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbUop_entry() //  [R1, R2, R3]
         { info_tbl: [(cbV9v,
                       label: sat_sbUop_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV9v: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Control.Applicative.$fShowZipList_$cshowsPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Control.Applicative.$fShowZipList_entry() //  [R2]
         { info_tbl: [(cbV9z,
                       label: Control.Applicative.$fShowZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV9z: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbV9D; else goto cbV9C;
       cbV9D: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Control.Applicative.$fShowZipList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbV9C: // global
           I64[Hp - 72] = sat_sbUor_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sbUoq_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sbUop_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.913335002 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedArrow1_closure" {
     Control.Applicative.$fGeneric1WrappedArrow1_closure:
         const Control.Applicative.$fGeneric1WrappedArrow1_info;
 },
 Control.Applicative.$fGeneric1WrappedArrow1_entry() //  [R2]
         { info_tbl: [(cbVa3,
                       label: Control.Applicative.$fGeneric1WrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVa3: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.916574419 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedArrow2_closure" {
     Control.Applicative.$fGeneric1WrappedArrow2_closure:
         const Control.Applicative.$fGeneric1WrappedArrow2_info;
 },
 Control.Applicative.$fGeneric1WrappedArrow2_entry() //  [R2]
         { info_tbl: [(cbVae,
                       label: Control.Applicative.$fGeneric1WrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVae: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.919663389 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedArrow_closure" {
     Control.Applicative.$fGeneric1WrappedArrow_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Control.Applicative.$fGeneric1WrappedArrow2_closure+1;
         const Control.Applicative.$fGeneric1WrappedArrow1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.921847993 UTC

[section ""data" . Control.Applicative.$fGenericWrappedArrow1_closure" {
     Control.Applicative.$fGenericWrappedArrow1_closure:
         const Control.Applicative.$fGenericWrappedArrow1_info;
 },
 Control.Applicative.$fGenericWrappedArrow1_entry() //  [R2]
         { info_tbl: [(cbVaq,
                       label: Control.Applicative.$fGenericWrappedArrow1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVaq: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.92501068 UTC

[section ""data" . Control.Applicative.$fGenericWrappedArrow2_closure" {
     Control.Applicative.$fGenericWrappedArrow2_closure:
         const Control.Applicative.$fGenericWrappedArrow2_info;
 },
 Control.Applicative.$fGenericWrappedArrow2_entry() //  [R2]
         { info_tbl: [(cbVaB,
                       label: Control.Applicative.$fGenericWrappedArrow2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVaB: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.928198546 UTC

[section ""data" . Control.Applicative.$fGenericWrappedArrow_closure" {
     Control.Applicative.$fGenericWrappedArrow_closure:
         const GHC.Generics.C:Generic_con_info;
         const Control.Applicative.$fGenericWrappedArrow2_closure+1;
         const Control.Applicative.$fGenericWrappedArrow1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.930682887 UTC

[section ""data" . Control.Applicative.$fMonadWrappedMonad_closure" {
     Control.Applicative.$fMonadWrappedMonad_closure:
         const Control.Applicative.$fMonadWrappedMonad_info;
 },
 sat_sbUoB_entry() //  [R1]
         { info_tbl: [(cbVaR,
                       label: sat_sbUoB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVaR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbVaS; else goto cbVaT;
       cbVaS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbVaT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.fail_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUoA_entry() //  [R1]
         { info_tbl: [(cbVaY,
                       label: sat_sbUoA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVaY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbVaZ; else goto cbVb0;
       cbVaZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbVb0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUoz_entry() //  [R1]
         { info_tbl: [(cbVb5,
                       label: sat_sbUoz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVb5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbVb6; else goto cbVb7;
       cbVb6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbVb7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.>>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUoy_entry() //  [R1]
         { info_tbl: [(cbVbc,
                       label: sat_sbUoy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVbc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbVbd; else goto cbVbe;
       cbVbd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbVbe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.>>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUox_entry() //  [R1]
         { info_tbl: [(cbVbj,
                       label: sat_sbUox_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVbj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbVbk; else goto cbVbl;
       cbVbk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbVbl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Control.Applicative.$fApplicativeWrappedMonad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Control.Applicative.$fMonadWrappedMonad_entry() //  [R2]
         { info_tbl: [(cbVbn,
                       label: Control.Applicative.$fMonadWrappedMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVbn: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cbVbr; else goto cbVbq;
       cbVbr: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Control.Applicative.$fMonadWrappedMonad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbVbq: // global
           I64[Hp - 160] = sat_sbUoB_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sbUoA_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbUoz_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sbUoy_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbUox_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.944698603 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedMonad1_closure" {
     Control.Applicative.$fGeneric1WrappedMonad1_closure:
         const Control.Applicative.$fGeneric1WrappedMonad1_info;
 },
 Control.Applicative.$fGeneric1WrappedMonad1_entry() //  [R2]
         { info_tbl: [(cbVcb,
                       label: Control.Applicative.$fGeneric1WrappedMonad1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVcb: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.947844519 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedMonad2_closure" {
     Control.Applicative.$fGeneric1WrappedMonad2_closure:
         const Control.Applicative.$fGeneric1WrappedMonad2_info;
 },
 Control.Applicative.$fGeneric1WrappedMonad2_entry() //  [R2]
         { info_tbl: [(cbVcm,
                       label: Control.Applicative.$fGeneric1WrappedMonad2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVcm: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.950834208 UTC

[section ""data" . Control.Applicative.$fGeneric1WrappedMonad_closure" {
     Control.Applicative.$fGeneric1WrappedMonad_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Control.Applicative.$fGeneric1WrappedMonad2_closure+1;
         const Control.Applicative.$fGeneric1WrappedMonad1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.952592594 UTC

[section ""data" . Control.Applicative.$fGenericWrappedMonad1_closure" {
     Control.Applicative.$fGenericWrappedMonad1_closure:
         const Control.Applicative.$fGenericWrappedMonad1_info;
 },
 Control.Applicative.$fGenericWrappedMonad1_entry() //  [R2]
         { info_tbl: [(cbVcy,
                       label: Control.Applicative.$fGenericWrappedMonad1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVcy: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.955716835 UTC

[section ""data" . Control.Applicative.$fGenericWrappedMonad2_closure" {
     Control.Applicative.$fGenericWrappedMonad2_closure:
         const Control.Applicative.$fGenericWrappedMonad2_info;
 },
 Control.Applicative.$fGenericWrappedMonad2_entry() //  [R2]
         { info_tbl: [(cbVcJ,
                       label: Control.Applicative.$fGenericWrappedMonad2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVcJ: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.959240309 UTC

[section ""data" . Control.Applicative.$fGenericWrappedMonad_closure" {
     Control.Applicative.$fGenericWrappedMonad_closure:
         const GHC.Generics.C:Generic_con_info;
         const Control.Applicative.$fGenericWrappedMonad2_closure+1;
         const Control.Applicative.$fGenericWrappedMonad1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.961041433 UTC

[section ""data" . Control.Applicative.unwrapMonad_closure" {
     Control.Applicative.unwrapMonad_closure:
         const Control.Applicative.unwrapMonad_info;
 },
 Control.Applicative.unwrapMonad_entry() //  [R2]
         { info_tbl: [(cbVcV,
                       label: Control.Applicative.unwrapMonad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVcV: // global
           R2 = R2;
           call Control.Applicative.$fGeneric1WrappedMonad2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.964717741 UTC

[section ""data" . Control.Applicative.unwrapArrow_closure" {
     Control.Applicative.unwrapArrow_closure:
         const Control.Applicative.unwrapArrow_info;
 },
 Control.Applicative.unwrapArrow_entry() //  [R2]
         { info_tbl: [(cbVd6,
                       label: Control.Applicative.unwrapArrow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVd6: // global
           R2 = R2;
           call Control.Applicative.$fGeneric1WrappedArrow2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.967787359 UTC

[section ""data" . Control.Applicative.getZipList_closure" {
     Control.Applicative.getZipList_closure:
         const Control.Applicative.getZipList_info;
 },
 Control.Applicative.getZipList_entry() //  [R2]
         { info_tbl: [(cbVdh,
                       label: Control.Applicative.getZipList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVdh: // global
           R2 = R2;
           call Control.Applicative.$fGeneric1ZipList2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.972049827 UTC

[section ""data" . Control.Applicative.optional_closure" {
     Control.Applicative.optional_closure:
         const Control.Applicative.optional_info;
 },
 $dApplicative_sbUoI_entry() //  [R1]
         { info_tbl: [(cbVdw,
                       label: $dApplicative_sbUoI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVdw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbVdx; else goto cbVdy;
       cbVdx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbVdy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbUoL_entry() //  [R1]
         { info_tbl: [(cbVdD,
                       label: sat_sbUoL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVdD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbVdE; else goto cbVdF;
       cbVdE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbVdF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbUoK_entry() //  [R1]
         { info_tbl: [(cbVdM,
                       label: sat_sbUoK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVdM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbVdN; else goto cbVdO;
       cbVdN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbVdO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbVdK_info;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbVdK() //  [R1]
         { info_tbl: [(cbVdK,
                       label: block_cbVdK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVdK: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Control.Applicative.optional_entry() //  [R2, R3]
         { info_tbl: [(cbVdS,
                       label: Control.Applicative.optional_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVdS: // global
           _sbUoH::P64 = R3;
           _sbUoG::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbVdT; else goto cbVdU;
       cbVdU: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbVdW; else goto cbVdV;
       cbVdW: // global
           HpAlloc = 80;
           goto cbVdT;
       cbVdT: // global
           R3 = _sbUoH::P64;
           R2 = _sbUoG::P64;
           R1 = Control.Applicative.optional_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbVdV: // global
           I64[Hp - 72] = $dApplicative_sbUoI_info;
           P64[Hp - 56] = _sbUoG::P64;
           I64[Hp - 48] = sat_sbUoL_info;
           _cbVds::P64 = Hp - 72;
           P64[Hp - 32] = _cbVds::P64;
           I64[Hp - 24] = sat_sbUoK_info;
           P64[Hp - 8] = _sbUoH::P64;
           P64[Hp] = _cbVds::P64;
           R2 = _sbUoG::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 24;
           call GHC.Base.<|>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.983162771 UTC

[section ""cstring" . Control.Applicative.$trModule4_bytes" {
     Control.Applicative.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.984740782 UTC

[section ""data" . Control.Applicative.$trModule3_closure" {
     Control.Applicative.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.986424108 UTC

[section ""cstring" . Control.Applicative.$trModule2_bytes" {
     Control.Applicative.$trModule2_bytes:
         I8[] [67,111,110,116,114,111,108,46,65,112,112,108,105,99,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.988044108 UTC

[section ""data" . Control.Applicative.$trModule1_closure" {
     Control.Applicative.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.98977665 UTC

[section ""data" . Control.Applicative.$trModule_closure" {
     Control.Applicative.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Control.Applicative.$trModule3_closure+1;
         const Control.Applicative.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.991444219 UTC

[section ""data" . Control.Applicative.$tcWrappedMonad1_closure" {
     Control.Applicative.$tcWrappedMonad1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const GHC.Types.krep$*Arr*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.993215439 UTC

[section ""data" . Control.Applicative.$tcWrappedArrow1_closure" {
     Control.Applicative.$tcWrappedArrow1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const GHC.Types.krep$*->*->*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.995683702 UTC

[section ""data" . $krep_rbSvt_closure" {
     $krep_rbSvt_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.997321614 UTC

[section ""data" . $krep1_rbSvu_closure" {
     $krep1_rbSvu_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:48.998879614 UTC

[section ""data" . $krep2_rbSvv_closure" {
     $krep2_rbSvv_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.000439552 UTC

[section ""data" . $krep3_rbSvw_closure" {
     $krep3_rbSvw_closure:
         const :_con_info;
         const $krep2_rbSvv_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.001944046 UTC

[section ""data" . $krep4_rbSvx_closure" {
     $krep4_rbSvx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep3_rbSvw_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.003569174 UTC

[section ""data" . $krep5_rbSvy_closure" {
     $krep5_rbSvy_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep2_rbSvv_closure+2;
         const $krep1_rbSvu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.005177952 UTC

[section ""data" . $krep6_rbSvz_closure" {
     $krep6_rbSvz_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep5_rbSvy_closure+3;
         const $krep_rbSvt_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.006753264 UTC

[section ""cstring" . Control.Applicative.$tcWrappedMonad3_bytes" {
     Control.Applicative.$tcWrappedMonad3_bytes:
         I8[] [87,114,97,112,112,101,100,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.008284187 UTC

[section ""data" . Control.Applicative.$tcWrappedMonad2_closure" {
     Control.Applicative.$tcWrappedMonad2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tcWrappedMonad3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.009937062 UTC

[section ""data" . Control.Applicative.$tcWrappedMonad_closure" {
     Control.Applicative.$tcWrappedMonad_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tcWrappedMonad2_closure+1;
         const Control.Applicative.$tcWrappedMonad1_closure+4;
         const 12971590878300233698;
         const 12447260690856494251;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.011668306 UTC

[section ""data" . $krep7_rbSvA_closure" {
     $krep7_rbSvA_closure:
         const :_con_info;
         const $krep1_rbSvu_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.014075276 UTC

[section ""data" . $krep8_rbSvB_closure" {
     $krep8_rbSvB_closure:
         const :_con_info;
         const $krep2_rbSvv_closure+2;
         const $krep7_rbSvA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.015597066 UTC

[section ""data" . $krep9_rbSvC_closure" {
     $krep9_rbSvC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Applicative.$tcWrappedMonad_closure+1;
         const $krep8_rbSvB_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.017264577 UTC

[section ""data" . Control.Applicative.$tc'WrapMonad1_closure" {
     Control.Applicative.$tc'WrapMonad1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_rbSvy_closure+3;
         const $krep9_rbSvC_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.019427455 UTC

[section ""cstring" . Control.Applicative.$tc'WrapMonad3_bytes" {
     Control.Applicative.$tc'WrapMonad3_bytes:
         I8[] [39,87,114,97,112,77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.021070696 UTC

[section ""data" . Control.Applicative.$tc'WrapMonad2_closure" {
     Control.Applicative.$tc'WrapMonad2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tc'WrapMonad3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.022673389 UTC

[section ""data" . Control.Applicative.$tc'WrapMonad_closure" {
     Control.Applicative.$tc'WrapMonad_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tc'WrapMonad2_closure+1;
         const Control.Applicative.$tc'WrapMonad1_closure+4;
         const 10363415327661881286;
         const 6845751270384138997;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.024397293 UTC

[section ""cstring" . Control.Applicative.$tcWrappedArrow3_bytes" {
     Control.Applicative.$tcWrappedArrow3_bytes:
         I8[] [87,114,97,112,112,101,100,65,114,114,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.026428026 UTC

[section ""data" . Control.Applicative.$tcWrappedArrow2_closure" {
     Control.Applicative.$tcWrappedArrow2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tcWrappedArrow3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.028000655 UTC

[section ""data" . Control.Applicative.$tcWrappedArrow_closure" {
     Control.Applicative.$tcWrappedArrow_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tcWrappedArrow2_closure+1;
         const Control.Applicative.$tcWrappedArrow1_closure+4;
         const 17995829375472255965;
         const 6668242383287740398;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.029662376 UTC

[section ""data" . $krep10_rbSvD_closure" {
     $krep10_rbSvD_closure:
         const :_con_info;
         const $krep_rbSvt_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.031293054 UTC

[section ""data" . $krep11_rbSvE_closure" {
     $krep11_rbSvE_closure:
         const :_con_info;
         const $krep1_rbSvu_closure+2;
         const $krep10_rbSvD_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.032945825 UTC

[section ""data" . $krep12_rbSvF_closure" {
     $krep12_rbSvF_closure:
         const :_con_info;
         const $krep2_rbSvv_closure+2;
         const $krep11_rbSvE_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.03455955 UTC

[section ""data" . $krep13_rbSvG_closure" {
     $krep13_rbSvG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Applicative.$tcWrappedArrow_closure+1;
         const $krep12_rbSvF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.036155307 UTC

[section ""data" . Control.Applicative.$tc'WrapArrow1_closure" {
     Control.Applicative.$tc'WrapArrow1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rbSvz_closure+3;
         const $krep13_rbSvG_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.038214526 UTC

[section ""cstring" . Control.Applicative.$tc'WrapArrow3_bytes" {
     Control.Applicative.$tc'WrapArrow3_bytes:
         I8[] [39,87,114,97,112,65,114,114,111,119]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.039795748 UTC

[section ""data" . Control.Applicative.$tc'WrapArrow2_closure" {
     Control.Applicative.$tc'WrapArrow2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tc'WrapArrow3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.041439261 UTC

[section ""data" . Control.Applicative.$tc'WrapArrow_closure" {
     Control.Applicative.$tc'WrapArrow_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tc'WrapArrow2_closure+1;
         const Control.Applicative.$tc'WrapArrow1_closure+4;
         const 4796259816778499037;
         const 13482613273239263357;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.043692579 UTC

[section ""data" . Control.Applicative.$tcZipList1_closure" {
     Control.Applicative.$tcZipList1_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$fReadZipList11_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.045368065 UTC

[section ""data" . Control.Applicative.$tcZipList_closure" {
     Control.Applicative.$tcZipList_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tcZipList1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 11311650752326360483;
         const 5534599578149162946;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.047125212 UTC

[section ""data" . $krep14_rbSvH_closure" {
     $krep14_rbSvH_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Control.Applicative.$tcZipList_closure+1;
         const $krep3_rbSvw_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.048735799 UTC

[section ""data" . Control.Applicative.$tc'ZipList1_closure" {
     Control.Applicative.$tc'ZipList1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rbSvx_closure+1;
         const $krep14_rbSvH_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.050809814 UTC

[section ""cstring" . Control.Applicative.$tc'ZipList3_bytes" {
     Control.Applicative.$tc'ZipList3_bytes:
         I8[] [39,90,105,112,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.052380382 UTC

[section ""data" . Control.Applicative.$tc'ZipList2_closure" {
     Control.Applicative.$tc'ZipList2_closure:
         const GHC.Types.TrNameS_con_info;
         const Control.Applicative.$tc'ZipList3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.054014031 UTC

[section ""data" . Control.Applicative.$tc'ZipList_closure" {
     Control.Applicative.$tc'ZipList_closure:
         const GHC.Types.TyCon_con_info;
         const Control.Applicative.$trModule_closure+1;
         const Control.Applicative.$tc'ZipList2_closure+1;
         const Control.Applicative.$tc'ZipList1_closure+4;
         const 15353069281551614305;
         const 7665927634319452478;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.055727813 UTC

[section ""relreadonly" . SbUXm_srt" {
     SbUXm_srt:
         const Text.Read.Lex.$wexpect_closure;
         const Control.Applicative.$fReadZipList2_closure;
         const GHC.Read.readField_closure;
         const Control.Applicative.$fReadZipList6_closure;
         const Control.Applicative.$fReadZipList_lexeme_closure;
         const Control.Applicative.$fReadZipList_lexeme1_closure;
         const GHC.Read.list3_closure;
         const Control.Applicative.$fReadZipList1_closure;
         const Control.Applicative.$fReadZipList_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Control.Applicative.$fReadZipList_$creadListPrec_closure;
         const Control.Applicative.$fReadZipList_$creadList_closure;
         const Control.Applicative.$fReadZipList_closure;
         const Control.Applicative.$fReadZipList3_closure;
         const Control.Applicative.$fShowZipList_$cshow_closure;
         const Control.Applicative.$fShowZipList_closure;
 }]

