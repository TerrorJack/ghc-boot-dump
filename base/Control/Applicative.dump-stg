
==================== Pre unarise: ====================
2018-03-16 16:06:45.290642015 UTC

Control.Applicative.$fFunctorWrappedMonad1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b. a -> Control.Applicative.WrappedMonad m b -> m a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbSvJ x_sbSvK eta_sbSvL]
        let {
          lvl_sbSvM [Occ=OnceL] :: m_XbS7L a_abS5L
          [LclId] =
              [$dMonad_sbSvJ x_sbSvK] \u []
                  GHC.Base.return $dMonad_sbSvJ x_sbSvK; } in
        let {
          sat_sbSvO [Occ=Once] :: b_abS5M -> m_XbS7L a_abS5L
          [LclId] =
              [lvl_sbSvM] \r [x1_sbSvN] lvl_sbSvM;
        } in  GHC.Base.>>= $dMonad_sbSvJ eta_sbSvL sat_sbSvO;

Control.Applicative.$fFunctorWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     GHC.Base.Functor (Control.Applicative.WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,C(U),A)>m] =
    [] \r [$dMonad_sbSvP]
        let {
          sat_sbSvT [Occ=Once]
            :: forall a b.
               a
               -> Control.Applicative.WrappedMonad m_XbS7K b
               -> Control.Applicative.WrappedMonad m_XbS7K a
          [LclId] =
              [$dMonad_sbSvP] \r [eta_B2 eta_B1]
                  Control.Applicative.$fFunctorWrappedMonad1
                      $dMonad_sbSvP eta_B2 eta_B1; } in
        let {
          sat_sbSvS [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Control.Applicative.WrappedMonad m_XbS7K a
               -> Control.Applicative.WrappedMonad m_XbS7K b
          [LclId] =
              [$dMonad_sbSvP] \r [f_sbSvQ ds_sbSvR]
                  GHC.Base.liftM $dMonad_sbSvP f_sbSvQ ds_sbSvR;
        } in  GHC.Base.C:Functor [sat_sbSvS sat_sbSvT];

Control.Applicative.$fApplicativeWrappedMonad3
  :: forall (m :: * -> *). GHC.Base.Monad m => forall a. a -> m a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbSvU eta_sbSvV]
        case GHC.Base.$p1Monad $dMonad_sbSvU of sat_sbSvW {
          __DEFAULT -> GHC.Base.pure sat_sbSvW eta_sbSvV;
        };

Control.Applicative.$fApplicativeWrappedMonad2
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m b -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbSvX a1_sbSvY a2_sbSvZ]
        let {
          sat_sbSw3 [Occ=Once] :: m_XbS74 (b_abS5b -> b_abS5b)
          [LclId] =
              [$dMonad_sbSvX a1_sbSvY] \u []
                  let {
                    lvl_sbSw0 [Occ=OnceL] :: m_XbS74 (b_abS5b -> b_abS5b)
                    [LclId] =
                        [$dMonad_sbSvX] \u []
                            GHC.Base.return $dMonad_sbSvX GHC.Base.breakpoint; } in
                  let {
                    sat_sbSw2 [Occ=Once] :: a_abS5a -> m_XbS74 (b_abS5b -> b_abS5b)
                    [LclId] =
                        [lvl_sbSw0] \r [x1_sbSw1] lvl_sbSw0;
                  } in  GHC.Base.>>= $dMonad_sbSvX a1_sbSvY sat_sbSw2;
        } in  GHC.Base.ap $dMonad_sbSvX sat_sbSw3 a2_sbSvZ;

Control.Applicative.$fApplicativeWrappedMonad1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m b -> m a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbSw4 ds_sbSw5 ds1_sbSw6]
        let {
          sat_sbSwb [Occ=Once] :: a_abS5k -> m_XbS9j a_abS5k
          [LclId] =
              [$dMonad_sbSw4 ds1_sbSw6] \r [x1_sbSw7]
                  let {
                    lvl_sbSw8 [Occ=OnceL] :: m_XbS9j a_abS5k
                    [LclId] =
                        [$dMonad_sbSw4 x1_sbSw7] \u []
                            GHC.Base.return $dMonad_sbSw4 x1_sbSw7; } in
                  let {
                    sat_sbSwa [Occ=Once] :: b_abS5l -> m_XbS9j a_abS5k
                    [LclId] =
                        [lvl_sbSw8] \r [x2_sbSw9] lvl_sbSw8;
                  } in  GHC.Base.>>= $dMonad_sbSw4 ds1_sbSw6 sat_sbSwa;
        } in  GHC.Base.>>= $dMonad_sbSw4 ds_sbSw5 sat_sbSwb;

Control.Applicative.$fApplicativeWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     GHC.Base.Applicative (Control.Applicative.WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A)>m] =
    [] \r [$dMonad_sbSwc]
        let {
          sat_sbSwn [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_XbS6X a
               -> Control.Applicative.WrappedMonad m_XbS6X b
               -> Control.Applicative.WrappedMonad m_XbS6X a
          [LclId] =
              [$dMonad_sbSwc] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedMonad1
                      $dMonad_sbSwc eta_B2 eta_B1; } in
        let {
          sat_sbSwm [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_XbS6X a
               -> Control.Applicative.WrappedMonad m_XbS6X b
               -> Control.Applicative.WrappedMonad m_XbS6X b
          [LclId] =
              [$dMonad_sbSwc] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedMonad2
                      $dMonad_sbSwc eta_B2 eta_B1; } in
        let {
          sat_sbSwl [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Control.Applicative.WrappedMonad m_XbS6X a
               -> Control.Applicative.WrappedMonad m_XbS6X b
               -> Control.Applicative.WrappedMonad m_XbS6X c
          [LclId] =
              [$dMonad_sbSwc] \r [f_sbSwi ds_sbSwj ds1_sbSwk]
                  GHC.Base.liftM2 $dMonad_sbSwc f_sbSwi ds_sbSwj ds1_sbSwk; } in
        let {
          sat_sbSwh [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_XbS6X (a -> b)
               -> Control.Applicative.WrappedMonad m_XbS6X a
               -> Control.Applicative.WrappedMonad m_XbS6X b
          [LclId] =
              [$dMonad_sbSwc] \r [ds_sbSwf ds1_sbSwg]
                  GHC.Base.ap $dMonad_sbSwc ds_sbSwf ds1_sbSwg; } in
        let {
          sat_sbSwe [Occ=Once]
            :: forall a. a -> Control.Applicative.WrappedMonad m_XbS6X a
          [LclId] =
              [$dMonad_sbSwc] \r [eta_B1]
                  Control.Applicative.$fApplicativeWrappedMonad3
                      $dMonad_sbSwc eta_B1; } in
        let {
          sat_sbSwd [Occ=Once]
            :: GHC.Base.Functor (Control.Applicative.WrappedMonad m_XbS6X)
          [LclId] =
              [$dMonad_sbSwc] \u []
                  Control.Applicative.$fFunctorWrappedMonad $dMonad_sbSwc;
        } in 
          GHC.Base.C:Applicative [sat_sbSwd
                                  sat_sbSwe
                                  sat_sbSwh
                                  sat_sbSwl
                                  sat_sbSwm
                                  sat_sbSwn];

Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Base.Applicative (Control.Applicative.WrappedMonad m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbSwo]
        let {
          sat_sbSwp [Occ=Once,
                     Dmd=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A)>]
            :: GHC.Base.Monad m_XbS6t
          [LclId] =
              [$dMonadPlus_sbSwo] \u [] GHC.Base.$p2MonadPlus $dMonadPlus_sbSwo;
        } in  Control.Applicative.$fApplicativeWrappedMonad sat_sbSwp;

Control.Applicative.$fAlternativeWrappedMonad_$csome
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall a.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbSwq eta_sbSwr]
        case
            GHC.Base.$p2MonadPlus $dMonadPlus_sbSwq
        of
        $dApplicative_sbSws [Dmd=<S(LC(C(S))LLL),U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A)>]
        { __DEFAULT ->
              let {
                m2_sbSwt [Occ=OnceL] :: m_XbS6w [a_abS46]
                [LclId] =
                    [$dMonadPlus_sbSwq $dApplicative_sbSws some_v_sbSwu] \u []
                        let {
                          sat_sbSww [Occ=Once] :: m_XbS6w [a_abS46]
                          [LclId] =
                              [$dApplicative_sbSws] \u []
                                  case GHC.Base.$p1Monad $dApplicative_sbSws of sat_sbSwv {
                                    __DEFAULT -> GHC.Base.pure sat_sbSwv GHC.Types.[];
                                  };
                        } in  GHC.Base.mplus $dMonadPlus_sbSwq some_v_sbSwu sat_sbSww;
                some_v_sbSwu [Occ=LoopBreaker] :: m_XbS6w [a_abS46]
                [LclId] =
                    [eta_sbSwr $dApplicative_sbSws m2_sbSwt] \u []
                        let {
                          sat_sbSwB [Occ=Once] :: a_abS46 -> m_XbS6w [a_abS46]
                          [LclId] =
                              [$dApplicative_sbSws m2_sbSwt] \r [x1_sbSwx]
                                  let {
                                    sat_sbSwA [Occ=Once] :: [a_abS46] -> m_XbS6w [a_abS46]
                                    [LclId] =
                                        [$dApplicative_sbSws x1_sbSwx] \r [x2_sbSwy]
                                            let {
                                              sat_sbSwz [Occ=Once] :: [a_abS46]
                                              [LclId] =
                                                  CCCS :! [x1_sbSwx x2_sbSwy];
                                            } in  GHC.Base.return $dApplicative_sbSws sat_sbSwz;
                                  } in  GHC.Base.>>= $dApplicative_sbSws m2_sbSwt sat_sbSwA;
                        } in  GHC.Base.>>= $dApplicative_sbSws eta_sbSwr sat_sbSwB;
              } in  some_v_sbSwu;
        };

Control.Applicative.$fAlternativeWrappedMonad_$cmany
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall a.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))),U(A,U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbSwC eta_sbSwD]
        let {
          many_v_sbSwE [Occ=LoopBreaker] :: m_XbS6v [a_abS4e]
          [LclId] =
              [$dMonadPlus_sbSwC eta_sbSwD many_v_sbSwE] \u []
                  let {
                    $dApplicative_sbSwF [Dmd=<L,U(1*U(A,1*C1(U),A,A,A,A),C(C1(U)),A,C(U),A)>]
                      :: GHC.Base.Monad m_XbS6v
                    [LclId] =
                        [$dMonadPlus_sbSwC] \u []
                            GHC.Base.$p2MonadPlus $dMonadPlus_sbSwC; } in
                  let {
                    sat_sbSwN [Occ=Once] :: m_XbS6v [a_abS4e]
                    [LclId] =
                        [$dApplicative_sbSwF] \u []
                            case GHC.Base.$p1Monad $dApplicative_sbSwF of sat_sbSwM {
                              __DEFAULT -> GHC.Base.pure sat_sbSwM GHC.Types.[];
                            }; } in
                  let {
                    sat_sbSwL [Occ=Once] :: m_XbS6v [a_abS4e]
                    [LclId] =
                        [eta_sbSwD many_v_sbSwE $dApplicative_sbSwF] \u []
                            let {
                              sat_sbSwK [Occ=Once] :: a_abS4e -> m_XbS6v [a_abS4e]
                              [LclId] =
                                  [many_v_sbSwE $dApplicative_sbSwF] \r [x1_sbSwG]
                                      let {
                                        sat_sbSwJ [Occ=Once] :: [a_abS4e] -> m_XbS6v [a_abS4e]
                                        [LclId] =
                                            [$dApplicative_sbSwF x1_sbSwG] \r [x2_sbSwH]
                                                let {
                                                  sat_sbSwI [Occ=Once] :: [a_abS4e]
                                                  [LclId] =
                                                      CCCS :! [x1_sbSwG x2_sbSwH];
                                                } in  GHC.Base.return $dApplicative_sbSwF sat_sbSwI;
                                      } in  GHC.Base.>>= $dApplicative_sbSwF many_v_sbSwE sat_sbSwJ;
                            } in  GHC.Base.>>= $dApplicative_sbSwF eta_sbSwD sat_sbSwK;
                  } in  GHC.Base.mplus $dMonadPlus_sbSwC sat_sbSwL sat_sbSwN;
        } in  many_v_sbSwE;

Control.Applicative.$fAlternativeWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Base.Alternative (Control.Applicative.WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),1*U,C(C1(U)))>m] =
    [] \r [$dMonadPlus_sbSwO]
        let {
          sat_sbSwV [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedMonad m_XbS6u a
               -> Control.Applicative.WrappedMonad m_XbS6u [a]
          [LclId] =
              [$dMonadPlus_sbSwO] \r [eta_B1]
                  Control.Applicative.$fAlternativeWrappedMonad_$cmany
                      $dMonadPlus_sbSwO eta_B1; } in
        let {
          sat_sbSwU [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedMonad m_XbS6u a
               -> Control.Applicative.WrappedMonad m_XbS6u [a]
          [LclId] =
              [$dMonadPlus_sbSwO] \r [eta_B1]
                  Control.Applicative.$fAlternativeWrappedMonad_$csome
                      $dMonadPlus_sbSwO eta_B1; } in
        let {
          sat_sbSwT [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedMonad m_XbS6u a
               -> Control.Applicative.WrappedMonad m_XbS6u a
               -> Control.Applicative.WrappedMonad m_XbS6u a
          [LclId] =
              [$dMonadPlus_sbSwO] \r [ds_sbSwR ds1_sbSwS]
                  GHC.Base.mplus $dMonadPlus_sbSwO ds_sbSwR ds1_sbSwS; } in
        let {
          sat_sbSwQ [Occ=Once]
            :: forall a. Control.Applicative.WrappedMonad m_XbS6u a
          [LclId] =
              [$dMonadPlus_sbSwO] \u [] GHC.Base.mzero $dMonadPlus_sbSwO; } in
        let {
          sat_sbSwP [Occ=Once]
            :: GHC.Base.Applicative (Control.Applicative.WrappedMonad m_XbS6u)
          [LclId] =
              [$dMonadPlus_sbSwO] \u []
                  Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative
                      $dMonadPlus_sbSwO;
        } in 
          GHC.Base.C:Alternative [sat_sbSwP
                                  sat_sbSwQ
                                  sat_sbSwT
                                  sat_sbSwU
                                  sat_sbSwV];

Control.Applicative.$fFunctorWrappedArrow2
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     (a1 -> b1) -> Control.Applicative.WrappedArrow a b a1 -> a b b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbSwW eta_sbSwX eta1_sbSwY]
        let {
          sat_sbSx0 [Occ=Once] :: a_abS32 a1_abS38 b1_abS39
          [LclId] =
              [$dArrow_sbSwW eta_sbSwX] \u []
                  Control.Arrow.arr $dArrow_sbSwW eta_sbSwX;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbSwW of sat_sbSwZ {
            __DEFAULT -> Control.Category.. sat_sbSwZ sat_sbSx0 eta1_sbSwY;
          };

Control.Applicative.$fFunctorWrappedArrow1
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     a1 -> Control.Applicative.WrappedArrow a b b1 -> a b a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbSx1 x_sbSx2 eta_sbSx3]
        let {
          sat_sbSx7 [Occ=Once] :: a_XbS5D b1_abS3t a1_abS3s
          [LclId] =
              [$dArrow_sbSx1 x_sbSx2] \u []
                  let {
                    sat_sbSx6 [Occ=Once] :: b1_abS3t -> a1_abS3s
                    [LclId] =
                        [x_sbSx2] \r [ds_sbSx5] x_sbSx2;
                  } in  Control.Arrow.arr $dArrow_sbSx1 sat_sbSx6;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbSx1 of sat_sbSx4 {
            __DEFAULT -> Control.Category.. sat_sbSx4 sat_sbSx7 eta_sbSx3;
          };

Control.Applicative.$fFunctorWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     GHC.Base.Functor (Control.Applicative.WrappedArrow a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,A)>m] =
    [] \r [$dArrow_sbSx8]
        let {
          sat_sbSxa [Occ=Once]
            :: forall a b.
               a
               -> Control.Applicative.WrappedArrow a_XbS5M b_XbS5O b
               -> Control.Applicative.WrappedArrow a_XbS5M b_XbS5O a
          [LclId] =
              [$dArrow_sbSx8] \r [eta_B2 eta_B1]
                  Control.Applicative.$fFunctorWrappedArrow1
                      $dArrow_sbSx8 eta_B2 eta_B1; } in
        let {
          sat_sbSx9 [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Control.Applicative.WrappedArrow a_XbS5M b_XbS5O a
               -> Control.Applicative.WrappedArrow a_XbS5M b_XbS5O b
          [LclId] =
              [$dArrow_sbSx8] \r [eta_B2 eta_B1]
                  Control.Applicative.$fFunctorWrappedArrow2
                      $dArrow_sbSx8 eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sbSx9 sat_sbSxa];

Control.Applicative.$fAlternativeWrappedArrow2
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1 c.
     (a1 -> b1 -> c)
     -> Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b b1
     -> a b c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,1*C1(C1(U)))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbSxb eta_sbSxc eta1_sbSxd eta2_sbSxe]
        let {
          sat_sbSxi [Occ=Once] :: a_abS1H b_abS1I (a1_abS2g, b1_abS2h)
          [LclId] =
              [$dArrow_sbSxb eta1_sbSxd eta2_sbSxe] \u []
                  Control.Arrow.&&& $dArrow_sbSxb eta1_sbSxd eta2_sbSxe; } in
        let {
          sat_sbSxh [Occ=Once] :: a_abS1H (a1_abS2g, b1_abS2h) c_abS2i
          [LclId] =
              [$dArrow_sbSxb eta_sbSxc] \u []
                  let {
                    sat_sbSxg [Occ=Once] :: (a1_abS2g, b1_abS2h) -> c_abS2i
                    [LclId] =
                        [eta_sbSxc] \r [eta_B1] Data.Tuple.uncurry eta_sbSxc eta_B1;
                  } in  Control.Arrow.arr $dArrow_sbSxb sat_sbSxg;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbSxb of sat_sbSxf {
            __DEFAULT -> Control.Category.. sat_sbSxf sat_sbSxh sat_sbSxi;
          };

Control.Applicative.$fApplicativeWrappedArrow5
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1. a1 -> a b a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbSxj x_sbSxk]
        let {
          sat_sbSxm [Occ=Once] :: b_XbS4F -> a1_abS1R
          [LclId] =
              [x_sbSxk] \r [ds_sbSxl] x_sbSxk;
        } in  Control.Arrow.arr $dArrow_sbSxj sat_sbSxm;

Control.Applicative.$fApplicativeWrappedArrow4
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     Control.Applicative.WrappedArrow a b (a1 -> b1)
     -> Control.Applicative.WrappedArrow a b a1 -> a b b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbSxn eta_B2 eta_B1]
        Control.Applicative.$fAlternativeWrappedArrow2
            $dArrow_sbSxn GHC.Base.breakpoint eta_B2 eta_B1;

Control.Applicative.$fApplicativeWrappedArrow3
  :: forall b a. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbSxo eta_sbSxp] eta_sbSxp;

Control.Applicative.$fApplicativeWrappedArrow2
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b b1 -> a b b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbSxq a2_sbSxr a3_sbSxs]
        let {
          sat_sbSxv [Occ=Once]
            :: Control.Applicative.WrappedArrow
                 a_XbS4Q b_XbS4S (b1_abS2K -> b1_abS2K)
          [LclId] =
              [$dArrow_sbSxq a2_sbSxr] \u []
                  let {
                    sat_sbSxu [Occ=Once] :: a_XbS4Q a1_abS2J (b1_abS2K -> b1_abS2K)
                    [LclId] =
                        [$dArrow_sbSxq] \u []
                            Control.Arrow.arr
                                $dArrow_sbSxq Control.Applicative.$fApplicativeWrappedArrow3;
                  } in 
                    case Control.Arrow.$p1Arrow $dArrow_sbSxq of sat_sbSxt {
                      __DEFAULT -> Control.Category.. sat_sbSxt sat_sbSxu a2_sbSxr;
                    };
        } in 
          Control.Applicative.$fAlternativeWrappedArrow2
              $dArrow_sbSxq GHC.Base.breakpoint sat_sbSxv a3_sbSxs;

Control.Applicative.$fApplicativeWrappedArrow1
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b b1 -> a b a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbSxw eta_B2 eta_B1]
        Control.Applicative.$fAlternativeWrappedArrow2
            $dArrow_sbSxw GHC.Base.const eta_B2 eta_B1;

Control.Applicative.$fApplicativeWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     GHC.Base.Applicative (Control.Applicative.WrappedArrow a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>m] =
    [] \r [$dArrow_sbSxx]
        let {
          sat_sbSxD [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
          [LclId] =
              [$dArrow_sbSxx] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedArrow1
                      $dArrow_sbSxx eta_B2 eta_B1; } in
        let {
          sat_sbSxC [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
          [LclId] =
              [$dArrow_sbSxx] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedArrow2
                      $dArrow_sbSxx eta_B2 eta_B1; } in
        let {
          sat_sbSxB [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b c
          [LclId] =
              [$dArrow_sbSxx] \r [eta_B3 eta_B2 eta_B1]
                  Control.Applicative.$fAlternativeWrappedArrow2
                      $dArrow_sbSxx eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbSxA [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedArrow a_XbS4O b_XbS8b (a -> b)
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
          [LclId] =
              [$dArrow_sbSxx] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedArrow4
                      $dArrow_sbSxx eta_B2 eta_B1; } in
        let {
          sat_sbSxz [Occ=Once]
            :: forall a.
               a -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
          [LclId] =
              [$dArrow_sbSxx] \r [eta_B1]
                  Control.Applicative.$fApplicativeWrappedArrow5
                      $dArrow_sbSxx eta_B1; } in
        let {
          sat_sbSxy [Occ=Once]
            :: GHC.Base.Functor
                 (Control.Applicative.WrappedArrow a_XbS4O b_XbS8b)
          [LclId] =
              [$dArrow_sbSxx] \u []
                  Control.Applicative.$fFunctorWrappedArrow $dArrow_sbSxx;
        } in 
          GHC.Base.C:Applicative [sat_sbSxy
                                  sat_sbSxz
                                  sat_sbSxA
                                  sat_sbSxB
                                  sat_sbSxC
                                  sat_sbSxD];

Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative
  :: forall (a :: * -> * -> *) b.
     (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
     GHC.Base.Applicative (Control.Applicative.WrappedArrow a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)><L,A>m,
 Unf=OtherCon []] =
    [] \r [$dArrowZero_sbSxE $dArrowPlus_sbSxF]
        let {
          sat_sbSxG [Occ=Once, Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
            :: Control.Arrow.Arrow a_XbS4i
          [LclId] =
              [$dArrowZero_sbSxE] \u []
                  Control.Arrow.$p1ArrowZero $dArrowZero_sbSxE;
        } in  Control.Applicative.$fApplicativeWrappedArrow sat_sbSxG;

Control.Applicative.$fAlternativeWrappedArrow1
  :: forall b a. b -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sbSxH] [] [];

Control.Applicative.$fAlternativeWrappedArrow_$csome
  :: forall (a :: * -> * -> *) b.
     (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
     forall a1.
     Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b [a1]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)><L,U(A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowZero_sbSxI $dArrowPlus_sbSxJ eta_sbSxK]
        let {
          some_v_sbSxL [Occ=LoopBreaker] :: a_XbS4l b_XbS4n [a1_abS1s]
          [LclId] =
              [$dArrowZero_sbSxI $dArrowPlus_sbSxJ eta_sbSxK some_v_sbSxL] \u []
                  case
                      Control.Arrow.$p1ArrowZero $dArrowZero_sbSxI
                  of
                  $dApplicative_sbSxM [Dmd=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
                  { __DEFAULT ->
                        let {
                          sat_sbSxO [Occ=Once]
                            :: Control.Applicative.WrappedArrow a_XbS4l b_XbS4n [a1_abS1s]
                          [LclId] =
                              [$dArrowPlus_sbSxJ some_v_sbSxL $dApplicative_sbSxM] \u []
                                  let {
                                    sat_sbSxN [Occ=Once] :: a_XbS4l b_XbS4n [a1_abS1s]
                                    [LclId] =
                                        [$dApplicative_sbSxM] \u []
                                            Control.Arrow.arr
                                                $dApplicative_sbSxM
                                                Control.Applicative.$fAlternativeWrappedArrow1;
                                  } in  Control.Arrow.<+> $dArrowPlus_sbSxJ some_v_sbSxL sat_sbSxN;
                        } in 
                          Control.Applicative.$fAlternativeWrappedArrow2
                              $dApplicative_sbSxM GHC.Types.: eta_sbSxK sat_sbSxO;
                  };
        } in  some_v_sbSxL;

Control.Applicative.$fAlternativeWrappedArrow_$cmany
  :: forall (a :: * -> * -> *) b.
     (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
     forall a1.
     Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b [a1]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)><S(LC(C(S))),U(A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowZero_sbSxP $dArrowPlus_sbSxQ eta_sbSxR]
        let {
          many_v_sbSxS [Occ=LoopBreaker] :: a_XbS4k b_XbS4m [a1_abS1A]
          [LclId] =
              [$dArrowZero_sbSxP $dArrowPlus_sbSxQ eta_sbSxR many_v_sbSxS] \u []
                  let {
                    $dApplicative_sbSxT [Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
                      :: Control.Arrow.Arrow a_XbS4k
                    [LclId] =
                        [$dArrowZero_sbSxP] \u []
                            Control.Arrow.$p1ArrowZero $dArrowZero_sbSxP; } in
                  let {
                    sat_sbSxV [Occ=Once] :: a_XbS4k b_XbS4m [a1_abS1A]
                    [LclId] =
                        [$dApplicative_sbSxT] \u []
                            Control.Arrow.arr
                                $dApplicative_sbSxT
                                Control.Applicative.$fAlternativeWrappedArrow1; } in
                  let {
                    sat_sbSxU [Occ=Once] :: a_XbS4k b_XbS4m [a1_abS1A]
                    [LclId] =
                        [eta_sbSxR many_v_sbSxS $dApplicative_sbSxT] \u []
                            Control.Applicative.$fAlternativeWrappedArrow2
                                $dApplicative_sbSxT GHC.Types.: eta_sbSxR many_v_sbSxS;
                  } in  Control.Arrow.<+> $dArrowPlus_sbSxQ sat_sbSxU sat_sbSxV;
        } in  many_v_sbSxS;

Control.Applicative.$fAlternativeWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b.
     (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
     GHC.Base.Alternative (Control.Applicative.WrappedArrow a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),1*U)><L,U(A,C(C1(U)))>m] =
    [] \r [$dArrowZero_sbSxW $dArrowPlus_sbSxX]
        let {
          sat_sbSy4 [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
               -> Control.Applicative.WrappedArrow a_XbS4j b_XbS4l [a]
          [LclId] =
              [$dArrowZero_sbSxW $dArrowPlus_sbSxX] \r [eta_B1]
                  Control.Applicative.$fAlternativeWrappedArrow_$cmany
                      $dArrowZero_sbSxW $dArrowPlus_sbSxX eta_B1; } in
        let {
          sat_sbSy3 [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
               -> Control.Applicative.WrappedArrow a_XbS4j b_XbS4l [a]
          [LclId] =
              [$dArrowZero_sbSxW $dArrowPlus_sbSxX] \r [eta_B1]
                  Control.Applicative.$fAlternativeWrappedArrow_$csome
                      $dArrowZero_sbSxW $dArrowPlus_sbSxX eta_B1; } in
        let {
          sat_sbSy2 [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
               -> Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
               -> Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
          [LclId] =
              [$dArrowPlus_sbSxX] \r [ds_sbSy0 ds1_sbSy1]
                  Control.Arrow.<+> $dArrowPlus_sbSxX ds_sbSy0 ds1_sbSy1; } in
        let {
          sat_sbSxZ [Occ=Once]
            :: forall a. Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
          [LclId] =
              [$dArrowZero_sbSxW] \u []
                  Control.Arrow.zeroArrow $dArrowZero_sbSxW; } in
        let {
          sat_sbSxY [Occ=Once]
            :: GHC.Base.Applicative
                 (Control.Applicative.WrappedArrow a_XbS4j b_XbS4l)
          [LclId] =
              [$dArrowZero_sbSxW $dArrowPlus_sbSxX] \u []
                  Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative
                      $dArrowZero_sbSxW $dArrowPlus_sbSxX;
        } in 
          GHC.Base.C:Alternative [sat_sbSxY
                                  sat_sbSxZ
                                  sat_sbSy2
                                  sat_sbSy3
                                  sat_sbSy4];

Control.Applicative.$wunsafeDrop [InlPrag=NOUSERINLINE[0],
                                  Occ=LoopBreaker]
  :: forall a1. GHC.Prim.Int# -> [a1] -> [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_sbSy5 w_sbSy6]
        case w_sbSy6 of {
          [] -> [] [];
          : _ [Occ=Dead] ipv2_sbSy9 [Occ=Once*] ->
              case ww_sbSy5 of ds3_sbSya {
                __DEFAULT ->
                    case -# [ds3_sbSya 1#] of sat_sbSyb {
                      __DEFAULT -> Control.Applicative.$wunsafeDrop sat_sbSyb ipv2_sbSy9;
                    };
                1# -> ipv2_sbSy9;
              };
        };

Control.Applicative.$fAlternativeZipList2
  :: forall a.
     Control.Applicative.ZipList a
     -> Control.Applicative.ZipList a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbSyc ds1_sbSyd]
        let {
          sat_sbSyg [Occ=Once, Dmd=<L,1*U>] :: [a_abRZs]
          [LclId] =
              [ds_sbSyc ds1_sbSyd] \s []
                  case GHC.List.$wlenAcc ds_sbSyc 0# of ww2_sbSye {
                    __DEFAULT ->
                        case <=# [ww2_sbSye 0#] of {
                          __DEFAULT -> Control.Applicative.$wunsafeDrop ww2_sbSye ds1_sbSyd;
                          1# -> ds1_sbSyd;
                        };
                  };
        } in  GHC.Base.++ ds_sbSyc sat_sbSyg;

Control.Applicative.$fGeneric1ZipList1
  :: forall a.
     GHC.Generics.Rep1 Control.Applicative.ZipList a
     -> GHC.Generics.Rep1 Control.Applicative.ZipList a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbSyh] ds_sbSyh;

Control.Applicative.$fGeneric1ZipList2
  :: forall a.
     Control.Applicative.ZipList a -> Control.Applicative.ZipList a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sbSyi] x_sbSyi;

Control.Applicative.$fGeneric1ZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Control.Applicative.ZipList
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Control.Applicative.$fGeneric1ZipList2
                                            Control.Applicative.$fGeneric1ZipList1];

Control.Applicative.$fGenericZipList1
  :: forall a x.
     GHC.Generics.Rep (Control.Applicative.ZipList a) x
     -> GHC.Generics.Rep (Control.Applicative.ZipList a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbSyj] ds_sbSyj;

Control.Applicative.$fGenericZipList2
  :: forall a x.
     Control.Applicative.ZipList a -> Control.Applicative.ZipList a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sbSyk] x1_sbSyk;

Control.Applicative.$fGenericZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Control.Applicative.ZipList a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Control.Applicative.$fGenericZipList2
                                           Control.Applicative.$fGenericZipList1];

Control.Applicative.$fFoldableZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Control.Applicative.ZipList
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableNonEmpty_$cfold1
                                             Data.Foldable.$fFoldable[]_$cfoldMap
                                             GHC.Base.foldr
                                             Data.Foldable.$fFoldable[]_$cfoldr'
                                             GHC.List.foldl
                                             GHC.List.foldl'
                                             GHC.List.foldr1
                                             GHC.List.foldl1
                                             GHC.Base.id
                                             GHC.List.null
                                             GHC.List.length
                                             GHC.List.elem
                                             GHC.List.maximum
                                             GHC.List.minimum
                                             GHC.List.sum
                                             GHC.List.product];

Control.Applicative.$fFunctorZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Control.Applicative.ZipList
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.map
                                       GHC.Base.$fFunctor[]_$c<$];

Control.Applicative.$fApplicativeZipList6 [Occ=LoopBreaker]
  :: forall a b. [a -> b] -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbSyl ds1_sbSym]
        case ds_sbSyl of {
          [] -> [] [];
          : ipv_sbSyo [Occ=Once!] ipv1_sbSyp [Occ=Once] ->
              case ds1_sbSym of {
                [] -> [] [];
                : ipv2_sbSyr [Occ=Once] ipv3_sbSys [Occ=Once] ->
                    let {
                      sat_sbSyu [Occ=Once] :: [b_abS0e]
                      [LclId] =
                          [ipv1_sbSyp ipv3_sbSys] \u []
                              Control.Applicative.$fApplicativeZipList6
                                  ipv1_sbSyp ipv3_sbSys; } in
                    let {
                      sat_sbSyt [Occ=Once] :: b_abS0e
                      [LclId] =
                          [ipv_sbSyo ipv2_sbSyr] \u [] ipv_sbSyo ipv2_sbSyr;
                    } in  : [sat_sbSyt sat_sbSyu];
              };
        };

Control.Applicative.$fApplicativeZipList5
  :: forall a b.
     Control.Applicative.ZipList (a -> b)
     -> Control.Applicative.ZipList a -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbSyv ds1_sbSyw]
        Control.Applicative.$fApplicativeZipList6 ds_sbSyv ds1_sbSyw;

Control.Applicative.$fApplicativeZipList4 [Occ=LoopBreaker]
  :: forall a b. [a] -> [b] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbSyx eta_sbSyy]
        case ds_sbSyx of {
          [] -> [] [];
          : _ [Occ=Dead] ys_sbSyB [Occ=Once] ->
              case eta_sbSyy of {
                [] -> [] [];
                : y1_sbSyD [Occ=Once] ys1_sbSyE [Occ=Once] ->
                    let {
                      sat_sbSyF [Occ=Once] :: [b_abS0z]
                      [LclId] =
                          [ys_sbSyB ys1_sbSyE] \u []
                              Control.Applicative.$fApplicativeZipList4 ys_sbSyB ys1_sbSyE;
                    } in  : [y1_sbSyD sat_sbSyF];
              };
        };

Control.Applicative.$fApplicativeZipList3
  :: forall a b.
     Control.Applicative.ZipList a
     -> Control.Applicative.ZipList b -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_sbSyG a2_sbSyH]
        Control.Applicative.$fApplicativeZipList4 a1_sbSyG a2_sbSyH;

Control.Applicative.$fApplicativeZipList2 [Occ=LoopBreaker]
  :: forall b a. [a] -> [b] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbSyI ds1_sbSyJ]
        case ds_sbSyI of {
          [] -> [] [];
          : ipv_sbSyL [Occ=Once] ipv1_sbSyM [Occ=Once] ->
              case ds1_sbSyJ of {
                [] -> [] [];
                : _ [Occ=Dead] ipv3_sbSyP [Occ=Once] ->
                    let {
                      sat_sbSyQ [Occ=Once] :: [a_abS0I]
                      [LclId] =
                          [ipv1_sbSyM ipv3_sbSyP] \u []
                              Control.Applicative.$fApplicativeZipList2 ipv1_sbSyM ipv3_sbSyP;
                    } in  : [ipv_sbSyL sat_sbSyQ];
              };
        };

Control.Applicative.$fApplicativeZipList1
  :: forall b a.
     Control.Applicative.ZipList a
     -> Control.Applicative.ZipList b -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbSyR ds1_sbSyS]
        Control.Applicative.$fApplicativeZipList2 ds_sbSyR ds1_sbSyS;

Control.Applicative.$fApplicativeZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Control.Applicative.ZipList
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Control.Applicative.$fFunctorZipList
                                           GHC.List.repeat
                                           Control.Applicative.$fApplicativeZipList5
                                           GHC.List.zipWith
                                           Control.Applicative.$fApplicativeZipList3
                                           Control.Applicative.$fApplicativeZipList1];

Control.Applicative.$fAlternativeZipList_xs [Occ=LoopBreaker]
  :: forall a. [[a]]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Types.[]
                      Control.Applicative.$fAlternativeZipList_xs];

Control.Applicative.$fAlternativeZipList1 [Occ=LoopBreaker]
  :: forall a. [a] -> [[a]] -> [[a]]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbSyT ds1_sbSyU]
        case ds_sbSyT of {
          [] -> [] [];
          : ipv_sbSyW [Occ=Once] ipv1_sbSyX [Occ=Once] ->
              case ds1_sbSyU of {
                [] -> [] [];
                : ipv2_sbSyZ [Occ=Once] ipv3_sbSz0 [Occ=Once] ->
                    let {
                      sat_sbSz2 [Occ=Once] :: [[a_abRZG]]
                      [LclId] =
                          [ipv1_sbSyX ipv3_sbSz0] \u []
                              Control.Applicative.$fAlternativeZipList1
                                  ipv1_sbSyX ipv3_sbSz0; } in
                    let {
                      sat_sbSz1 [Occ=Once] :: [a_abRZG]
                      [LclId] =
                          CCCS :! [ipv_sbSyW ipv2_sbSyZ];
                    } in  : [sat_sbSz1 sat_sbSz2];
              };
        };

Control.Applicative.$fAlternativeZipList_$csome
  :: forall a.
     Control.Applicative.ZipList a -> Control.Applicative.ZipList [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sbSz3]
        let {
          some_v_sbSz4 [Occ=LoopBreaker] :: [[a_abRZG]]
          [LclId] =
              [v_sbSz3 some_v_sbSz4] \u []
                  let {
                    sat_sbSz5 [Occ=Once, Dmd=<L,1*U>] :: [[a_abRZG]]
                    [LclId] =
                        [some_v_sbSz4] \s []
                            Control.Applicative.$fAlternativeZipList2
                                some_v_sbSz4 Control.Applicative.$fAlternativeZipList_xs;
                  } in  Control.Applicative.$fAlternativeZipList1 v_sbSz3 sat_sbSz5;
        } in  some_v_sbSz4;

Control.Applicative.$fAlternativeZipList_$cmany
  :: forall a.
     Control.Applicative.ZipList a -> Control.Applicative.ZipList [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sbSz6]
        let {
          many_v_sbSz7 [Occ=LoopBreaker] :: [[a_abRZO]]
          [LclId] =
              [v_sbSz6 many_v_sbSz7] \u []
                  case
                      Control.Applicative.$fAlternativeZipList1 v_sbSz6 many_v_sbSz7
                  of
                  sat_sbSz8
                  { __DEFAULT ->
                        Control.Applicative.$fAlternativeZipList2
                            sat_sbSz8 Control.Applicative.$fAlternativeZipList_xs;
                  };
        } in  many_v_sbSz7;

Control.Applicative.$fAlternativeZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Control.Applicative.ZipList
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Control.Applicative.$fApplicativeZipList
                                           GHC.Types.[]
                                           Control.Applicative.$fAlternativeZipList2
                                           Control.Applicative.$fAlternativeZipList_$csome
                                           Control.Applicative.$fAlternativeZipList_$cmany];

Control.Applicative.$fReadZipList11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ZipList"#;

Control.Applicative.$fReadZipList10 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Control.Applicative.$fReadZipList11;

Control.Applicative.$fReadZipList_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Control.Applicative.$fReadZipList10];

Control.Applicative.$fReadZipList9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "{"#;

Control.Applicative.$fReadZipList8 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Control.Applicative.$fReadZipList9;

Control.Applicative.$fReadZipList_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Control.Applicative.$fReadZipList8];

Control.Applicative.$fReadZipList7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getZipList"#;

Control.Applicative.$fReadZipList6 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Control.Applicative.$fReadZipList7;

Control.Applicative.$fReadZipList5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Control.Applicative.$fReadZipList4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "}"#;

Control.Applicative.$fReadZipList3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Control.Applicative.$fReadZipList4;

Control.Applicative.$fReadZipList2 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Control.Applicative.$fReadZipList3];

Control.Applicative.$fReadZipList1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Control.Applicative.ZipList a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,A,1*C1(U))>, Unf=OtherCon []] =
    [] \r [$dRead_sbSz9]
        let {
          lvl_sbSza [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP [a_abRO3]
          [LclId] =
              [$dRead_sbSz9] \u []
                  GHC.Read.readListPrec
                      $dRead_sbSz9 Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sbSzb [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP [a_abRO3]
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl_sbSza] \r [ds1_sbSzc] lvl_sbSza; } in
        let {
          sat_sbSzw [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Control.Applicative.ZipList a_abRO3)
          [LclId] =
              [ds_sbSzb] \r [c_sbSzd eta_sbSze]
                  case c_sbSzd of {
                    GHC.Types.I# x_sbSzg [Occ=Once] ->
                        case <=# [x_sbSzg 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sbSzt [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sbSzb eta_sbSze] \r [a1_sbSzi]
                                        let {
                                          sat_sbSzq [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sbSzb eta_sbSze] \r [a2_sbSzj]
                                                  let {
                                                    sat_sbSzp [Occ=Once]
                                                      :: [a_abRO3]
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sbSze] \r [a3_sbSzk]
                                                            let {
                                                              sat_sbSzm [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sbSze a3_sbSzk] \r [a4_sbSzl]
                                                                      eta_sbSze a3_sbSzk;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Control.Applicative.$fReadZipList2
                                                                      sat_sbSzm
                                                              of
                                                              { Unit# ww1_sbSzo [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sbSzo];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Control.Applicative.$fReadZipList6
                                                        ds_sbSzb
                                                        Control.Applicative.$fReadZipList5
                                                        sat_sbSzp;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Control.Applicative.$fReadZipList_lexeme sat_sbSzq
                                          of
                                          { Unit# ww1_sbSzs [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sbSzs];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Control.Applicative.$fReadZipList_lexeme1 sat_sbSzt
                                of
                                { Unit# ww1_sbSzv [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sbSzv];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sbSzw;

Control.Applicative.$fReadZipList_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Control.Applicative.ZipList a)
[GblId, Arity=1, Str=<L,1*U(A,A,A,1*C1(U))>, Unf=OtherCon []] =
    [] \r [$dRead_sbSzx]
        let {
          ds_sbSzy [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Control.Applicative.ZipList a_XbRSJ
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sbSzx] \u []
                  Control.Applicative.$fReadZipList1 $dRead_sbSzx; } in
        let {
          sat_sbSzB [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Control.Applicative.ZipList a_XbRSJ)
          [LclId] =
              [ds_sbSzy] \r [n_sbSzz]
                  let {
                    sat_sbSzA [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Control.Applicative.ZipList a_XbRSJ)
                    [LclId] =
                        [ds_sbSzy n_sbSzz] \u []
                            ds_sbSzy
                                n_sbSzz Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sbSzA;
        } in  sat_sbSzB;

Control.Applicative.$fReadZipList_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Control.Applicative.ZipList a]
[GblId, Arity=1, Str=<L,1*U(A,A,A,1*C1(U))>, Unf=OtherCon []] =
    [] \r [$dRead_sbSzC]
        let {
          sat_sbSzD [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Control.Applicative.ZipList a_XbRSH)
          [LclId] =
              [$dRead_sbSzC] \s []
                  Control.Applicative.$fReadZipList1 $dRead_sbSzC;
        } in  GHC.Read.list sat_sbSzD;

Control.Applicative.$fReadZipList_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Control.Applicative.ZipList a]
[GblId, Arity=1, Str=<L,1*U(A,A,A,1*C1(U))>, Unf=OtherCon []] =
    [] \r [$dRead_sbSzE]
        let {
          sat_sbSzG [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Control.Applicative.ZipList a_XbRSI]
          [LclId] =
              [$dRead_sbSzE] \u []
                  let {
                    sat_sbSzF [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Control.Applicative.ZipList a_XbRSI)
                    [LclId] =
                        [$dRead_sbSzE] \s []
                            Control.Applicative.$fReadZipList1 $dRead_sbSzE;
                  } in 
                    GHC.Read.list
                        sat_sbSzF
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sbSzG;

Control.Applicative.$fReadZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Control.Applicative.ZipList a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,C(U))>m] =
    [] \r [$dRead_sbSzH]
        let {
          sat_sbSzL [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Control.Applicative.ZipList a_XbRSG]
          [LclId] =
              [$dRead_sbSzH] \u []
                  Control.Applicative.$fReadZipList_$creadListPrec $dRead_sbSzH; } in
        let {
          sat_sbSzK [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Control.Applicative.ZipList a_XbRSG)
          [LclId] =
              [$dRead_sbSzH] \u []
                  Control.Applicative.$fReadZipList1 $dRead_sbSzH; } in
        let {
          sat_sbSzJ [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Control.Applicative.ZipList a_XbRSG]
          [LclId] =
              [$dRead_sbSzH] \u []
                  Control.Applicative.$fReadZipList_$creadList $dRead_sbSzH; } in
        let {
          sat_sbSzI [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Control.Applicative.ZipList a_XbRSG)
          [LclId] =
              [$dRead_sbSzH] \u []
                  Control.Applicative.$fReadZipList_$creadsPrec $dRead_sbSzH;
        } in  GHC.Read.C:Read [sat_sbSzI sat_sbSzJ sat_sbSzK sat_sbSzL];

Control.Applicative.$fEqZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Control.Applicative.ZipList a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sbSzM]
        let {
          sat_sbSzO [Occ=Once]
            :: Control.Applicative.ZipList a_abRLG
               -> Control.Applicative.ZipList a_abRLG -> GHC.Types.Bool
          [LclId] =
              [$dEq_sbSzM] \r [eta_B2 eta_B1]
                  GHC.Classes.$fEq[]_$c/= $dEq_sbSzM eta_B2 eta_B1; } in
        let {
          sat_sbSzN [Occ=Once]
            :: Control.Applicative.ZipList a_abRLG
               -> Control.Applicative.ZipList a_abRLG -> GHC.Types.Bool
          [LclId] =
              [$dEq_sbSzM] \r [eta_B2 eta_B1]
                  GHC.Classes.$fEq[]_$c== $dEq_sbSzM eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sbSzN sat_sbSzO];

Control.Applicative.$fOrdZipList_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Control.Applicative.ZipList a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sbSzP]
        let {
          sat_sbSzQ [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_abRMe
          [LclId] =
              [$dOrd_sbSzP] \u [] GHC.Classes.$p1Ord $dOrd_sbSzP;
        } in  Control.Applicative.$fEqZipList sat_sbSzQ;

Control.Applicative.$fOrdZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Control.Applicative.ZipList a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_sbSzR]
        let {
          sat_sbSzZ [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe
          [LclId] =
              [$dOrd_sbSzR] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$cmin $dOrd_sbSzR eta_B2 eta_B1; } in
        let {
          sat_sbSzY [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe
          [LclId] =
              [$dOrd_sbSzR] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$cmax $dOrd_sbSzR eta_B2 eta_B1; } in
        let {
          sat_sbSzX [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbSzR] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$c>= $dOrd_sbSzR eta_B2 eta_B1; } in
        let {
          sat_sbSzW [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbSzR] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$c> $dOrd_sbSzR eta_B2 eta_B1; } in
        let {
          sat_sbSzV [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbSzR] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$c<= $dOrd_sbSzR eta_B2 eta_B1; } in
        let {
          sat_sbSzU [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbSzR] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$c< $dOrd_sbSzR eta_B2 eta_B1; } in
        let {
          sat_sbSzT [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sbSzR] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$ccompare $dOrd_sbSzR eta_B2 eta_B1; } in
        let {
          sat_sbSzS [Occ=Once]
            :: GHC.Classes.Eq (Control.Applicative.ZipList a_abRMe)
          [LclId] =
              [$dOrd_sbSzR] \u []
                  Control.Applicative.$fOrdZipList_$cp1Ord $dOrd_sbSzR;
        } in 
          GHC.Classes.C:Ord [sat_sbSzS
                             sat_sbSzT
                             sat_sbSzU
                             sat_sbSzV
                             sat_sbSzW
                             sat_sbSzX
                             sat_sbSzY
                             sat_sbSzZ];

Control.Applicative.$fShowZipList3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ZipList {"#;

Control.Applicative.$fShowZipList2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getZipList = "#;

Control.Applicative.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Control.Applicative.ZipList a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C(U)))><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbSA0 ww_sbSA1 w1_sbSA2]
        let {
          f_sbSA3 [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sbSA0 w1_sbSA2] \u [] GHC.Show.showList w_sbSA0 w1_sbSA2;
        } in 
          case >=# [ww_sbSA1 11#] of {
            __DEFAULT ->
                let {
                  sat_sbSA9 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sbSA3] \r [x_sbSA5]
                          let {
                            sat_sbSA8 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sbSA3 x_sbSA5] \u []
                                    let {
                                      sat_sbSA7 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sbSA3 x_sbSA5] \u []
                                              let {
                                                sat_sbSA6 [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sbSA5] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Control.Applicative.$fReadZipList4
                                                            x_sbSA5;
                                              } in  f_sbSA3 sat_sbSA6;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Control.Applicative.$fShowZipList2 sat_sbSA7;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Control.Applicative.$fShowZipList3 sat_sbSA8;
                } in  sat_sbSA9;
            1# ->
                let {
                  sat_sbSAg [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sbSA3] \r [x_sbSAa]
                          let {
                            sat_sbSAf [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sbSA3 x_sbSAa] \u []
                                    let {
                                      sat_sbSAe [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sbSA3 x_sbSAa] \u []
                                              let {
                                                sat_sbSAd [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sbSA3 x_sbSAa] \u []
                                                        let {
                                                          sat_sbSAc [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sbSAa] \u []
                                                                  let {
                                                                    sat_sbSAb [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sbSAa];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Control.Applicative.$fReadZipList4
                                                                        sat_sbSAb;
                                                        } in  f_sbSA3 sat_sbSAc;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Control.Applicative.$fShowZipList2 sat_sbSAd;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Control.Applicative.$fShowZipList3 sat_sbSAe;
                          } in  : [GHC.Show.$fShow(,)4 sat_sbSAf];
                } in  sat_sbSAg;
          };

Control.Applicative.$fShowZipList_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Control.Applicative.ZipList a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C(U)))><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbSAh w1_sbSAi w2_sbSAj]
        case w1_sbSAi of {
          GHC.Types.I# ww1_sbSAl [Occ=Once] ->
              Control.Applicative.$w$cshowsPrec w_sbSAh ww1_sbSAl w2_sbSAj;
        };

Control.Applicative.$fShowZipList_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Control.Applicative.ZipList a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C1(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sbSAm x_sbSAn]
        let {
          sat_sbSAp [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sbSAm x_sbSAn] \u []
                  let {
                    sat_sbSAo [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sbSAm x_sbSAn] \u []
                            GHC.Show.showList
                                $dShow_sbSAm x_sbSAn Control.Applicative.$fReadZipList3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Control.Applicative.$fShowZipList2 sat_sbSAo;
        } in 
          GHC.CString.unpackAppendCString#
              Control.Applicative.$fShowZipList3 sat_sbSAp;

Control.Applicative.$fShowZipList1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Control.Applicative.$fShowZipList_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Control.Applicative.ZipList a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sbSAq ls_sbSAr s_sbSAs]
        let {
          sat_sbSAu [Occ=Once]
            :: Control.Applicative.ZipList a_abRLb -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbSAq] \r [w_sbSAt]
                  Control.Applicative.$w$cshowsPrec $dShow_sbSAq 0# w_sbSAt;
        } in  GHC.Show.showList__ sat_sbSAu ls_sbSAr s_sbSAs;

Control.Applicative.$fShowZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Control.Applicative.ZipList a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C(U)))>m] =
    [] \r [$dShow_sbSAv]
        let {
          sat_sbSAy [Occ=Once]
            :: [Control.Applicative.ZipList a_abRLb] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbSAv] \r [eta_B2 eta_B1]
                  Control.Applicative.$fShowZipList_$cshowList
                      $dShow_sbSAv eta_B2 eta_B1; } in
        let {
          sat_sbSAx [Occ=Once]
            :: Control.Applicative.ZipList a_abRLb -> GHC.Base.String
          [LclId] =
              [$dShow_sbSAv] \r [eta_B1]
                  Control.Applicative.$fShowZipList_$cshow $dShow_sbSAv eta_B1; } in
        let {
          sat_sbSAw [Occ=Once]
            :: GHC.Types.Int
               -> Control.Applicative.ZipList a_abRLb -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbSAv] \r [eta_B2 eta_B1]
                  Control.Applicative.$fShowZipList_$cshowsPrec
                      $dShow_sbSAv eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sbSAw sat_sbSAx sat_sbSAy];

Control.Applicative.$fGeneric1WrappedArrow1
  :: forall (a1 :: * -> * -> *) b a2.
     GHC.Generics.Rep1 (Control.Applicative.WrappedArrow a1 b) a2
     -> GHC.Generics.Rep1 (Control.Applicative.WrappedArrow a1 b) a2
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbSAz] ds_sbSAz;

Control.Applicative.$fGeneric1WrappedArrow2
  :: forall (a1 :: * -> * -> *) b a2.
     Control.Applicative.WrappedArrow a1 b a2
     -> Control.Applicative.WrappedArrow a1 b a2
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sbSAA] x_sbSAA;

Control.Applicative.$fGeneric1WrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b.
     GHC.Generics.Generic1 (Control.Applicative.WrappedArrow a b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Control.Applicative.$fGeneric1WrappedArrow2
                                            Control.Applicative.$fGeneric1WrappedArrow1];

Control.Applicative.$fGenericWrappedArrow1
  :: forall (a :: * -> * -> *) b c x.
     GHC.Generics.Rep (Control.Applicative.WrappedArrow a b c) x
     -> GHC.Generics.Rep (Control.Applicative.WrappedArrow a b c) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbSAB] ds_sbSAB;

Control.Applicative.$fGenericWrappedArrow2
  :: forall (a :: * -> * -> *) b c x.
     Control.Applicative.WrappedArrow a b c
     -> Control.Applicative.WrappedArrow a b c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sbSAC] x1_sbSAC;

Control.Applicative.$fGenericWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b c.
     GHC.Generics.Generic (Control.Applicative.WrappedArrow a b c)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Control.Applicative.$fGenericWrappedArrow2
                                           Control.Applicative.$fGenericWrappedArrow1];

Control.Applicative.$fMonadWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     GHC.Base.Monad (Control.Applicative.WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(U),A,A,A,A),U,1*U,U,1*U)>m] =
    [] \r [$dMonad_sbSAD]
        let {
          sat_sbSAI [Occ=Once]
            :: forall a.
               GHC.Base.String -> Control.Applicative.WrappedMonad m_abRHy a
          [LclId] =
              [$dMonad_sbSAD] \u [] GHC.Base.fail $dMonad_sbSAD; } in
        let {
          sat_sbSAH [Occ=Once]
            :: forall a. a -> Control.Applicative.WrappedMonad m_abRHy a
          [LclId] =
              [$dMonad_sbSAD] \u [] GHC.Base.return $dMonad_sbSAD; } in
        let {
          sat_sbSAG [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_abRHy a
               -> Control.Applicative.WrappedMonad m_abRHy b
               -> Control.Applicative.WrappedMonad m_abRHy b
          [LclId] =
              [$dMonad_sbSAD] \u [] GHC.Base.>> $dMonad_sbSAD; } in
        let {
          sat_sbSAF [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_abRHy a
               -> (a -> Control.Applicative.WrappedMonad m_abRHy b)
               -> Control.Applicative.WrappedMonad m_abRHy b
          [LclId] =
              [$dMonad_sbSAD] \u [] GHC.Base.>>= $dMonad_sbSAD; } in
        let {
          sat_sbSAE [Occ=Once]
            :: GHC.Base.Applicative (Control.Applicative.WrappedMonad m_abRHy)
          [LclId] =
              [$dMonad_sbSAD] \u []
                  Control.Applicative.$fApplicativeWrappedMonad $dMonad_sbSAD;
        } in 
          GHC.Base.C:Monad [sat_sbSAE
                            sat_sbSAF
                            sat_sbSAG
                            sat_sbSAH
                            sat_sbSAI];

Control.Applicative.$fGeneric1WrappedMonad1
  :: forall (m :: * -> *) a.
     GHC.Generics.Rep1 (Control.Applicative.WrappedMonad m) a
     -> GHC.Generics.Rep1 (Control.Applicative.WrappedMonad m) a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbSAJ] ds_sbSAJ;

Control.Applicative.$fGeneric1WrappedMonad2
  :: forall (m :: * -> *) a.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sbSAK] x_sbSAK;

Control.Applicative.$fGeneric1WrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Generics.Generic1 (Control.Applicative.WrappedMonad m)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Control.Applicative.$fGeneric1WrappedMonad2
                                            Control.Applicative.$fGeneric1WrappedMonad1];

Control.Applicative.$fGenericWrappedMonad1
  :: forall (m :: * -> *) a x.
     GHC.Generics.Rep (Control.Applicative.WrappedMonad m a) x
     -> GHC.Generics.Rep (Control.Applicative.WrappedMonad m a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbSAL] ds_sbSAL;

Control.Applicative.$fGenericWrappedMonad2
  :: forall (m :: * -> *) a x.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sbSAM] x1_sbSAM;

Control.Applicative.$fGenericWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *) a.
     GHC.Generics.Generic (Control.Applicative.WrappedMonad m a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Control.Applicative.$fGenericWrappedMonad2
                                           Control.Applicative.$fGenericWrappedMonad1];

Control.Applicative.unwrapMonad
  :: forall (m :: * -> *) a.
     Control.Applicative.WrappedMonad m a -> m a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Control.Applicative.$fGeneric1WrappedMonad2 eta_B1;

Control.Applicative.unwrapArrow
  :: forall (a :: * -> * -> *) b c.
     Control.Applicative.WrappedArrow a b c -> a b c
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Control.Applicative.$fGeneric1WrappedArrow2 eta_B1;

Control.Applicative.getZipList
  :: forall a. Control.Applicative.ZipList a -> [a]
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Control.Applicative.$fGeneric1ZipList2 eta_B1;

Control.Applicative.optional
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     f a -> f (GHC.Base.Maybe a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LL),U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,1*C1(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sbSAN eta_sbSAO]
        let {
          $dApplicative_sbSAP [Dmd=<L,U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)>]
            :: GHC.Base.Applicative f_abRFg
          [LclId] =
              [$dAlternative_sbSAN] \u []
                  GHC.Base.$p1Alternative $dAlternative_sbSAN; } in
        let {
          sat_sbSAS [Occ=Once] :: f_abRFg (GHC.Base.Maybe a_abRFh)
          [LclId] =
              [$dApplicative_sbSAP] \u []
                  GHC.Base.pure $dApplicative_sbSAP GHC.Base.Nothing; } in
        let {
          sat_sbSAR [Occ=Once] :: f_abRFg (GHC.Base.Maybe a_abRFh)
          [LclId] =
              [eta_sbSAO $dApplicative_sbSAP] \u []
                  case GHC.Base.$p1Applicative $dApplicative_sbSAP of sat_sbSAQ {
                    __DEFAULT -> GHC.Base.fmap sat_sbSAQ GHC.Base.Just eta_sbSAO;
                  };
        } in  GHC.Base.<|> $dAlternative_sbSAN sat_sbSAR sat_sbSAS;

Control.Applicative.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Control.Applicative.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$trModule4];

Control.Applicative.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Control.Applicative"#;

Control.Applicative.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$trModule2];

Control.Applicative.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Control.Applicative.$trModule3
                                     Control.Applicative.$trModule1];

Control.Applicative.$tcWrappedMonad1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         GHC.Types.krep$*Arr*];

Control.Applicative.$tcWrappedArrow1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         GHC.Types.krep$*->*->*];

$krep_rbSvt :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep1_rbSvu :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep2_rbSvv :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep3_rbSvw :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rbSvv GHC.Types.[]];

$krep4_rbSvx :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc[]
                                              $krep3_rbSvw];

$krep5_rbSvy :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep2_rbSvv $krep1_rbSvu];

$krep6_rbSvz :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep5_rbSvy $krep_rbSvt];

Control.Applicative.$tcWrappedMonad3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrappedMonad"#;

Control.Applicative.$tcWrappedMonad2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tcWrappedMonad3];

Control.Applicative.$tcWrappedMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12971590878300233698##
                                    12447260690856494251##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tcWrappedMonad2
                                    0#
                                    Control.Applicative.$tcWrappedMonad1];

$krep7_rbSvA :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rbSvu GHC.Types.[]];

$krep8_rbSvB :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rbSvv $krep7_rbSvA];

$krep9_rbSvC :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Applicative.$tcWrappedMonad
                                              $krep8_rbSvB];

Control.Applicative.$tc'WrapMonad1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_rbSvy $krep9_rbSvC];

Control.Applicative.$tc'WrapMonad3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'WrapMonad"#;

Control.Applicative.$tc'WrapMonad2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tc'WrapMonad3];

Control.Applicative.$tc'WrapMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10363415327661881286##
                                    6845751270384138997##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tc'WrapMonad2
                                    2#
                                    Control.Applicative.$tc'WrapMonad1];

Control.Applicative.$tcWrappedArrow3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrappedArrow"#;

Control.Applicative.$tcWrappedArrow2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tcWrappedArrow3];

Control.Applicative.$tcWrappedArrow :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17995829375472255965##
                                    6668242383287740398##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tcWrappedArrow2
                                    0#
                                    Control.Applicative.$tcWrappedArrow1];

$krep10_rbSvD :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rbSvt GHC.Types.[]];

$krep11_rbSvE :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rbSvu $krep10_rbSvD];

$krep12_rbSvF :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rbSvv $krep11_rbSvE];

$krep13_rbSvG :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Applicative.$tcWrappedArrow
                                              $krep12_rbSvF];

Control.Applicative.$tc'WrapArrow1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_rbSvz $krep13_rbSvG];

Control.Applicative.$tc'WrapArrow3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'WrapArrow"#;

Control.Applicative.$tc'WrapArrow2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tc'WrapArrow3];

Control.Applicative.$tc'WrapArrow :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4796259816778499037##
                                    13482613273239263357##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tc'WrapArrow2
                                    3#
                                    Control.Applicative.$tc'WrapArrow1];

Control.Applicative.$tcZipList1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$fReadZipList11];

Control.Applicative.$tcZipList :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11311650752326360483##
                                    5534599578149162946##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tcZipList1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep14_rbSvH :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Applicative.$tcZipList
                                              $krep3_rbSvw];

Control.Applicative.$tc'ZipList1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_rbSvx $krep14_rbSvH];

Control.Applicative.$tc'ZipList3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'ZipList"#;

Control.Applicative.$tc'ZipList2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tc'ZipList3];

Control.Applicative.$tc'ZipList :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15353069281551614305##
                                    7665927634319452478##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tc'ZipList2
                                    1#
                                    Control.Applicative.$tc'ZipList1];


==================== STG syntax: ====================
2018-03-16 16:06:45.323559671 UTC

Control.Applicative.$fFunctorWrappedMonad1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b. a -> Control.Applicative.WrappedMonad m b -> m a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbSvJ x_sbSvK eta_sbSvL]
        let {
          lvl_sbSvM [Occ=OnceL] :: m_XbS7L a_abS5L
          [LclId] =
              [$dMonad_sbSvJ x_sbSvK] \u []
                  GHC.Base.return $dMonad_sbSvJ x_sbSvK; } in
        let {
          sat_sbSvO [Occ=Once] :: b_abS5M -> m_XbS7L a_abS5L
          [LclId] =
              [lvl_sbSvM] \r [x1_sbSvN] lvl_sbSvM;
        } in  GHC.Base.>>= $dMonad_sbSvJ eta_sbSvL sat_sbSvO;

Control.Applicative.$fFunctorWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     GHC.Base.Functor (Control.Applicative.WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,C(U),A)>m] =
    [] \r [$dMonad_sbSvP]
        let {
          sat_sbSvT [Occ=Once]
            :: forall a b.
               a
               -> Control.Applicative.WrappedMonad m_XbS7K b
               -> Control.Applicative.WrappedMonad m_XbS7K a
          [LclId] =
              [$dMonad_sbSvP] \r [eta_B2 eta_B1]
                  Control.Applicative.$fFunctorWrappedMonad1
                      $dMonad_sbSvP eta_B2 eta_B1; } in
        let {
          sat_sbSvS [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Control.Applicative.WrappedMonad m_XbS7K a
               -> Control.Applicative.WrappedMonad m_XbS7K b
          [LclId] =
              [$dMonad_sbSvP] \r [f_sbSvQ ds_sbSvR]
                  GHC.Base.liftM $dMonad_sbSvP f_sbSvQ ds_sbSvR;
        } in  GHC.Base.C:Functor [sat_sbSvS sat_sbSvT];

Control.Applicative.$fApplicativeWrappedMonad3
  :: forall (m :: * -> *). GHC.Base.Monad m => forall a. a -> m a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbSvU eta_sbSvV]
        case GHC.Base.$p1Monad $dMonad_sbSvU of sat_sbSvW {
          __DEFAULT -> GHC.Base.pure sat_sbSvW eta_sbSvV;
        };

Control.Applicative.$fApplicativeWrappedMonad2
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m b -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbSvX a1_sbSvY a2_sbSvZ]
        let {
          sat_sbSw3 [Occ=Once] :: m_XbS74 (b_abS5b -> b_abS5b)
          [LclId] =
              [$dMonad_sbSvX a1_sbSvY] \u []
                  let {
                    lvl_sbSw0 [Occ=OnceL] :: m_XbS74 (b_abS5b -> b_abS5b)
                    [LclId] =
                        [$dMonad_sbSvX] \u []
                            GHC.Base.return $dMonad_sbSvX GHC.Base.breakpoint; } in
                  let {
                    sat_sbSw2 [Occ=Once] :: a_abS5a -> m_XbS74 (b_abS5b -> b_abS5b)
                    [LclId] =
                        [lvl_sbSw0] \r [x1_sbSw1] lvl_sbSw0;
                  } in  GHC.Base.>>= $dMonad_sbSvX a1_sbSvY sat_sbSw2;
        } in  GHC.Base.ap $dMonad_sbSvX sat_sbSw3 a2_sbSvZ;

Control.Applicative.$fApplicativeWrappedMonad1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m b -> m a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbSw4 ds_sbSw5 ds1_sbSw6]
        let {
          sat_sbSwb [Occ=Once] :: a_abS5k -> m_XbS9j a_abS5k
          [LclId] =
              [$dMonad_sbSw4 ds1_sbSw6] \r [x1_sbSw7]
                  let {
                    lvl_sbSw8 [Occ=OnceL] :: m_XbS9j a_abS5k
                    [LclId] =
                        [$dMonad_sbSw4 x1_sbSw7] \u []
                            GHC.Base.return $dMonad_sbSw4 x1_sbSw7; } in
                  let {
                    sat_sbSwa [Occ=Once] :: b_abS5l -> m_XbS9j a_abS5k
                    [LclId] =
                        [lvl_sbSw8] \r [x2_sbSw9] lvl_sbSw8;
                  } in  GHC.Base.>>= $dMonad_sbSw4 ds1_sbSw6 sat_sbSwa;
        } in  GHC.Base.>>= $dMonad_sbSw4 ds_sbSw5 sat_sbSwb;

Control.Applicative.$fApplicativeWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     GHC.Base.Applicative (Control.Applicative.WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A)>m] =
    [] \r [$dMonad_sbSwc]
        let {
          sat_sbSwn [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_XbS6X a
               -> Control.Applicative.WrappedMonad m_XbS6X b
               -> Control.Applicative.WrappedMonad m_XbS6X a
          [LclId] =
              [$dMonad_sbSwc] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedMonad1
                      $dMonad_sbSwc eta_B2 eta_B1; } in
        let {
          sat_sbSwm [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_XbS6X a
               -> Control.Applicative.WrappedMonad m_XbS6X b
               -> Control.Applicative.WrappedMonad m_XbS6X b
          [LclId] =
              [$dMonad_sbSwc] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedMonad2
                      $dMonad_sbSwc eta_B2 eta_B1; } in
        let {
          sat_sbSwl [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Control.Applicative.WrappedMonad m_XbS6X a
               -> Control.Applicative.WrappedMonad m_XbS6X b
               -> Control.Applicative.WrappedMonad m_XbS6X c
          [LclId] =
              [$dMonad_sbSwc] \r [f_sbSwi ds_sbSwj ds1_sbSwk]
                  GHC.Base.liftM2 $dMonad_sbSwc f_sbSwi ds_sbSwj ds1_sbSwk; } in
        let {
          sat_sbSwh [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_XbS6X (a -> b)
               -> Control.Applicative.WrappedMonad m_XbS6X a
               -> Control.Applicative.WrappedMonad m_XbS6X b
          [LclId] =
              [$dMonad_sbSwc] \r [ds_sbSwf ds1_sbSwg]
                  GHC.Base.ap $dMonad_sbSwc ds_sbSwf ds1_sbSwg; } in
        let {
          sat_sbSwe [Occ=Once]
            :: forall a. a -> Control.Applicative.WrappedMonad m_XbS6X a
          [LclId] =
              [$dMonad_sbSwc] \r [eta_B1]
                  Control.Applicative.$fApplicativeWrappedMonad3
                      $dMonad_sbSwc eta_B1; } in
        let {
          sat_sbSwd [Occ=Once]
            :: GHC.Base.Functor (Control.Applicative.WrappedMonad m_XbS6X)
          [LclId] =
              [$dMonad_sbSwc] \u []
                  Control.Applicative.$fFunctorWrappedMonad $dMonad_sbSwc;
        } in 
          GHC.Base.C:Applicative [sat_sbSwd
                                  sat_sbSwe
                                  sat_sbSwh
                                  sat_sbSwl
                                  sat_sbSwm
                                  sat_sbSwn];

Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Base.Applicative (Control.Applicative.WrappedMonad m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbSwo]
        let {
          sat_sbSwp [Occ=Once,
                     Dmd=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A)>]
            :: GHC.Base.Monad m_XbS6t
          [LclId] =
              [$dMonadPlus_sbSwo] \u [] GHC.Base.$p2MonadPlus $dMonadPlus_sbSwo;
        } in  Control.Applicative.$fApplicativeWrappedMonad sat_sbSwp;

Control.Applicative.$fAlternativeWrappedMonad_$csome
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall a.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbSwq eta_sbSwr]
        case
            GHC.Base.$p2MonadPlus $dMonadPlus_sbSwq
        of
        $dApplicative_sbSws [Dmd=<S(LC(C(S))LLL),U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A)>]
        { __DEFAULT ->
              let {
                m2_sbSwt [Occ=OnceL] :: m_XbS6w [a_abS46]
                [LclId] =
                    [$dMonadPlus_sbSwq $dApplicative_sbSws some_v_sbSwu] \u []
                        let {
                          sat_sbSww [Occ=Once] :: m_XbS6w [a_abS46]
                          [LclId] =
                              [$dApplicative_sbSws] \u []
                                  case GHC.Base.$p1Monad $dApplicative_sbSws of sat_sbSwv {
                                    __DEFAULT -> GHC.Base.pure sat_sbSwv GHC.Types.[];
                                  };
                        } in  GHC.Base.mplus $dMonadPlus_sbSwq some_v_sbSwu sat_sbSww;
                some_v_sbSwu [Occ=LoopBreaker] :: m_XbS6w [a_abS46]
                [LclId] =
                    [eta_sbSwr $dApplicative_sbSws m2_sbSwt] \u []
                        let {
                          sat_sbSwB [Occ=Once] :: a_abS46 -> m_XbS6w [a_abS46]
                          [LclId] =
                              [$dApplicative_sbSws m2_sbSwt] \r [x1_sbSwx]
                                  let {
                                    sat_sbSwA [Occ=Once] :: [a_abS46] -> m_XbS6w [a_abS46]
                                    [LclId] =
                                        [$dApplicative_sbSws x1_sbSwx] \r [x2_sbSwy]
                                            let {
                                              sat_sbSwz [Occ=Once] :: [a_abS46]
                                              [LclId] =
                                                  CCCS :! [x1_sbSwx x2_sbSwy];
                                            } in  GHC.Base.return $dApplicative_sbSws sat_sbSwz;
                                  } in  GHC.Base.>>= $dApplicative_sbSws m2_sbSwt sat_sbSwA;
                        } in  GHC.Base.>>= $dApplicative_sbSws eta_sbSwr sat_sbSwB;
              } in  some_v_sbSwu;
        };

Control.Applicative.$fAlternativeWrappedMonad_$cmany
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall a.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))),U(A,U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbSwC eta_sbSwD]
        let {
          many_v_sbSwE [Occ=LoopBreaker] :: m_XbS6v [a_abS4e]
          [LclId] =
              [$dMonadPlus_sbSwC eta_sbSwD many_v_sbSwE] \u []
                  let {
                    $dApplicative_sbSwF [Dmd=<L,U(1*U(A,1*C1(U),A,A,A,A),C(C1(U)),A,C(U),A)>]
                      :: GHC.Base.Monad m_XbS6v
                    [LclId] =
                        [$dMonadPlus_sbSwC] \u []
                            GHC.Base.$p2MonadPlus $dMonadPlus_sbSwC; } in
                  let {
                    sat_sbSwN [Occ=Once] :: m_XbS6v [a_abS4e]
                    [LclId] =
                        [$dApplicative_sbSwF] \u []
                            case GHC.Base.$p1Monad $dApplicative_sbSwF of sat_sbSwM {
                              __DEFAULT -> GHC.Base.pure sat_sbSwM GHC.Types.[];
                            }; } in
                  let {
                    sat_sbSwL [Occ=Once] :: m_XbS6v [a_abS4e]
                    [LclId] =
                        [eta_sbSwD many_v_sbSwE $dApplicative_sbSwF] \u []
                            let {
                              sat_sbSwK [Occ=Once] :: a_abS4e -> m_XbS6v [a_abS4e]
                              [LclId] =
                                  [many_v_sbSwE $dApplicative_sbSwF] \r [x1_sbSwG]
                                      let {
                                        sat_sbSwJ [Occ=Once] :: [a_abS4e] -> m_XbS6v [a_abS4e]
                                        [LclId] =
                                            [$dApplicative_sbSwF x1_sbSwG] \r [x2_sbSwH]
                                                let {
                                                  sat_sbSwI [Occ=Once] :: [a_abS4e]
                                                  [LclId] =
                                                      CCCS :! [x1_sbSwG x2_sbSwH];
                                                } in  GHC.Base.return $dApplicative_sbSwF sat_sbSwI;
                                      } in  GHC.Base.>>= $dApplicative_sbSwF many_v_sbSwE sat_sbSwJ;
                            } in  GHC.Base.>>= $dApplicative_sbSwF eta_sbSwD sat_sbSwK;
                  } in  GHC.Base.mplus $dMonadPlus_sbSwC sat_sbSwL sat_sbSwN;
        } in  many_v_sbSwE;

Control.Applicative.$fAlternativeWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Base.Alternative (Control.Applicative.WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),1*U,C(C1(U)))>m] =
    [] \r [$dMonadPlus_sbSwO]
        let {
          sat_sbSwV [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedMonad m_XbS6u a
               -> Control.Applicative.WrappedMonad m_XbS6u [a]
          [LclId] =
              [$dMonadPlus_sbSwO] \r [eta_B1]
                  Control.Applicative.$fAlternativeWrappedMonad_$cmany
                      $dMonadPlus_sbSwO eta_B1; } in
        let {
          sat_sbSwU [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedMonad m_XbS6u a
               -> Control.Applicative.WrappedMonad m_XbS6u [a]
          [LclId] =
              [$dMonadPlus_sbSwO] \r [eta_B1]
                  Control.Applicative.$fAlternativeWrappedMonad_$csome
                      $dMonadPlus_sbSwO eta_B1; } in
        let {
          sat_sbSwT [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedMonad m_XbS6u a
               -> Control.Applicative.WrappedMonad m_XbS6u a
               -> Control.Applicative.WrappedMonad m_XbS6u a
          [LclId] =
              [$dMonadPlus_sbSwO] \r [ds_sbSwR ds1_sbSwS]
                  GHC.Base.mplus $dMonadPlus_sbSwO ds_sbSwR ds1_sbSwS; } in
        let {
          sat_sbSwQ [Occ=Once]
            :: forall a. Control.Applicative.WrappedMonad m_XbS6u a
          [LclId] =
              [$dMonadPlus_sbSwO] \u [] GHC.Base.mzero $dMonadPlus_sbSwO; } in
        let {
          sat_sbSwP [Occ=Once]
            :: GHC.Base.Applicative (Control.Applicative.WrappedMonad m_XbS6u)
          [LclId] =
              [$dMonadPlus_sbSwO] \u []
                  Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative
                      $dMonadPlus_sbSwO;
        } in 
          GHC.Base.C:Alternative [sat_sbSwP
                                  sat_sbSwQ
                                  sat_sbSwT
                                  sat_sbSwU
                                  sat_sbSwV];

Control.Applicative.$fFunctorWrappedArrow2
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     (a1 -> b1) -> Control.Applicative.WrappedArrow a b a1 -> a b b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbSwW eta_sbSwX eta1_sbSwY]
        let {
          sat_sbSx0 [Occ=Once] :: a_abS32 a1_abS38 b1_abS39
          [LclId] =
              [$dArrow_sbSwW eta_sbSwX] \u []
                  Control.Arrow.arr $dArrow_sbSwW eta_sbSwX;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbSwW of sat_sbSwZ {
            __DEFAULT -> Control.Category.. sat_sbSwZ sat_sbSx0 eta1_sbSwY;
          };

Control.Applicative.$fFunctorWrappedArrow1
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     a1 -> Control.Applicative.WrappedArrow a b b1 -> a b a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbSx1 x_sbSx2 eta_sbSx3]
        let {
          sat_sbSx7 [Occ=Once] :: a_XbS5D b1_abS3t a1_abS3s
          [LclId] =
              [$dArrow_sbSx1 x_sbSx2] \u []
                  let {
                    sat_sbSx6 [Occ=Once] :: b1_abS3t -> a1_abS3s
                    [LclId] =
                        [x_sbSx2] \r [ds_sbSx5] x_sbSx2;
                  } in  Control.Arrow.arr $dArrow_sbSx1 sat_sbSx6;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbSx1 of sat_sbSx4 {
            __DEFAULT -> Control.Category.. sat_sbSx4 sat_sbSx7 eta_sbSx3;
          };

Control.Applicative.$fFunctorWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     GHC.Base.Functor (Control.Applicative.WrappedArrow a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,A)>m] =
    [] \r [$dArrow_sbSx8]
        let {
          sat_sbSxa [Occ=Once]
            :: forall a b.
               a
               -> Control.Applicative.WrappedArrow a_XbS5M b_XbS5O b
               -> Control.Applicative.WrappedArrow a_XbS5M b_XbS5O a
          [LclId] =
              [$dArrow_sbSx8] \r [eta_B2 eta_B1]
                  Control.Applicative.$fFunctorWrappedArrow1
                      $dArrow_sbSx8 eta_B2 eta_B1; } in
        let {
          sat_sbSx9 [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Control.Applicative.WrappedArrow a_XbS5M b_XbS5O a
               -> Control.Applicative.WrappedArrow a_XbS5M b_XbS5O b
          [LclId] =
              [$dArrow_sbSx8] \r [eta_B2 eta_B1]
                  Control.Applicative.$fFunctorWrappedArrow2
                      $dArrow_sbSx8 eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sbSx9 sat_sbSxa];

Control.Applicative.$fAlternativeWrappedArrow2
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1 c.
     (a1 -> b1 -> c)
     -> Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b b1
     -> a b c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,1*C1(C1(U)))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbSxb eta_sbSxc eta1_sbSxd eta2_sbSxe]
        let {
          sat_sbSxi [Occ=Once] :: a_abS1H b_abS1I (a1_abS2g, b1_abS2h)
          [LclId] =
              [$dArrow_sbSxb eta1_sbSxd eta2_sbSxe] \u []
                  Control.Arrow.&&& $dArrow_sbSxb eta1_sbSxd eta2_sbSxe; } in
        let {
          sat_sbSxh [Occ=Once] :: a_abS1H (a1_abS2g, b1_abS2h) c_abS2i
          [LclId] =
              [$dArrow_sbSxb eta_sbSxc] \u []
                  let {
                    sat_sbSxg [Occ=Once] :: (a1_abS2g, b1_abS2h) -> c_abS2i
                    [LclId] =
                        [eta_sbSxc] \r [eta_B1] Data.Tuple.uncurry eta_sbSxc eta_B1;
                  } in  Control.Arrow.arr $dArrow_sbSxb sat_sbSxg;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbSxb of sat_sbSxf {
            __DEFAULT -> Control.Category.. sat_sbSxf sat_sbSxh sat_sbSxi;
          };

Control.Applicative.$fApplicativeWrappedArrow5
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1. a1 -> a b a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbSxj x_sbSxk]
        let {
          sat_sbSxm [Occ=Once] :: b_XbS4F -> a1_abS1R
          [LclId] =
              [x_sbSxk] \r [ds_sbSxl] x_sbSxk;
        } in  Control.Arrow.arr $dArrow_sbSxj sat_sbSxm;

Control.Applicative.$fApplicativeWrappedArrow4
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     Control.Applicative.WrappedArrow a b (a1 -> b1)
     -> Control.Applicative.WrappedArrow a b a1 -> a b b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbSxn eta_B2 eta_B1]
        Control.Applicative.$fAlternativeWrappedArrow2
            $dArrow_sbSxn GHC.Base.breakpoint eta_B2 eta_B1;

Control.Applicative.$fApplicativeWrappedArrow3
  :: forall b a. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbSxo eta_sbSxp] eta_sbSxp;

Control.Applicative.$fApplicativeWrappedArrow2
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b b1 -> a b b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbSxq a2_sbSxr a3_sbSxs]
        let {
          sat_sbSxv [Occ=Once]
            :: Control.Applicative.WrappedArrow
                 a_XbS4Q b_XbS4S (b1_abS2K -> b1_abS2K)
          [LclId] =
              [$dArrow_sbSxq a2_sbSxr] \u []
                  let {
                    sat_sbSxu [Occ=Once] :: a_XbS4Q a1_abS2J (b1_abS2K -> b1_abS2K)
                    [LclId] =
                        [$dArrow_sbSxq] \u []
                            Control.Arrow.arr
                                $dArrow_sbSxq Control.Applicative.$fApplicativeWrappedArrow3;
                  } in 
                    case Control.Arrow.$p1Arrow $dArrow_sbSxq of sat_sbSxt {
                      __DEFAULT -> Control.Category.. sat_sbSxt sat_sbSxu a2_sbSxr;
                    };
        } in 
          Control.Applicative.$fAlternativeWrappedArrow2
              $dArrow_sbSxq GHC.Base.breakpoint sat_sbSxv a3_sbSxs;

Control.Applicative.$fApplicativeWrappedArrow1
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b b1 -> a b a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbSxw eta_B2 eta_B1]
        Control.Applicative.$fAlternativeWrappedArrow2
            $dArrow_sbSxw GHC.Base.const eta_B2 eta_B1;

Control.Applicative.$fApplicativeWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     GHC.Base.Applicative (Control.Applicative.WrappedArrow a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>m] =
    [] \r [$dArrow_sbSxx]
        let {
          sat_sbSxD [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
          [LclId] =
              [$dArrow_sbSxx] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedArrow1
                      $dArrow_sbSxx eta_B2 eta_B1; } in
        let {
          sat_sbSxC [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
          [LclId] =
              [$dArrow_sbSxx] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedArrow2
                      $dArrow_sbSxx eta_B2 eta_B1; } in
        let {
          sat_sbSxB [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b c
          [LclId] =
              [$dArrow_sbSxx] \r [eta_B3 eta_B2 eta_B1]
                  Control.Applicative.$fAlternativeWrappedArrow2
                      $dArrow_sbSxx eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbSxA [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedArrow a_XbS4O b_XbS8b (a -> b)
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
          [LclId] =
              [$dArrow_sbSxx] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedArrow4
                      $dArrow_sbSxx eta_B2 eta_B1; } in
        let {
          sat_sbSxz [Occ=Once]
            :: forall a.
               a -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
          [LclId] =
              [$dArrow_sbSxx] \r [eta_B1]
                  Control.Applicative.$fApplicativeWrappedArrow5
                      $dArrow_sbSxx eta_B1; } in
        let {
          sat_sbSxy [Occ=Once]
            :: GHC.Base.Functor
                 (Control.Applicative.WrappedArrow a_XbS4O b_XbS8b)
          [LclId] =
              [$dArrow_sbSxx] \u []
                  Control.Applicative.$fFunctorWrappedArrow $dArrow_sbSxx;
        } in 
          GHC.Base.C:Applicative [sat_sbSxy
                                  sat_sbSxz
                                  sat_sbSxA
                                  sat_sbSxB
                                  sat_sbSxC
                                  sat_sbSxD];

Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative
  :: forall (a :: * -> * -> *) b.
     (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
     GHC.Base.Applicative (Control.Applicative.WrappedArrow a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)><L,A>m,
 Unf=OtherCon []] =
    [] \r [$dArrowZero_sbSxE $dArrowPlus_sbSxF]
        let {
          sat_sbSxG [Occ=Once, Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
            :: Control.Arrow.Arrow a_XbS4i
          [LclId] =
              [$dArrowZero_sbSxE] \u []
                  Control.Arrow.$p1ArrowZero $dArrowZero_sbSxE;
        } in  Control.Applicative.$fApplicativeWrappedArrow sat_sbSxG;

Control.Applicative.$fAlternativeWrappedArrow1
  :: forall b a. b -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sbSxH] [] [];

Control.Applicative.$fAlternativeWrappedArrow_$csome
  :: forall (a :: * -> * -> *) b.
     (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
     forall a1.
     Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b [a1]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)><L,U(A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowZero_sbSxI $dArrowPlus_sbSxJ eta_sbSxK]
        let {
          some_v_sbSxL [Occ=LoopBreaker] :: a_XbS4l b_XbS4n [a1_abS1s]
          [LclId] =
              [$dArrowZero_sbSxI $dArrowPlus_sbSxJ eta_sbSxK some_v_sbSxL] \u []
                  case
                      Control.Arrow.$p1ArrowZero $dArrowZero_sbSxI
                  of
                  $dApplicative_sbSxM [Dmd=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
                  { __DEFAULT ->
                        let {
                          sat_sbSxO [Occ=Once]
                            :: Control.Applicative.WrappedArrow a_XbS4l b_XbS4n [a1_abS1s]
                          [LclId] =
                              [$dArrowPlus_sbSxJ some_v_sbSxL $dApplicative_sbSxM] \u []
                                  let {
                                    sat_sbSxN [Occ=Once] :: a_XbS4l b_XbS4n [a1_abS1s]
                                    [LclId] =
                                        [$dApplicative_sbSxM] \u []
                                            Control.Arrow.arr
                                                $dApplicative_sbSxM
                                                Control.Applicative.$fAlternativeWrappedArrow1;
                                  } in  Control.Arrow.<+> $dArrowPlus_sbSxJ some_v_sbSxL sat_sbSxN;
                        } in 
                          Control.Applicative.$fAlternativeWrappedArrow2
                              $dApplicative_sbSxM GHC.Types.: eta_sbSxK sat_sbSxO;
                  };
        } in  some_v_sbSxL;

Control.Applicative.$fAlternativeWrappedArrow_$cmany
  :: forall (a :: * -> * -> *) b.
     (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
     forall a1.
     Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b [a1]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)><S(LC(C(S))),U(A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowZero_sbSxP $dArrowPlus_sbSxQ eta_sbSxR]
        let {
          many_v_sbSxS [Occ=LoopBreaker] :: a_XbS4k b_XbS4m [a1_abS1A]
          [LclId] =
              [$dArrowZero_sbSxP $dArrowPlus_sbSxQ eta_sbSxR many_v_sbSxS] \u []
                  let {
                    $dApplicative_sbSxT [Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
                      :: Control.Arrow.Arrow a_XbS4k
                    [LclId] =
                        [$dArrowZero_sbSxP] \u []
                            Control.Arrow.$p1ArrowZero $dArrowZero_sbSxP; } in
                  let {
                    sat_sbSxV [Occ=Once] :: a_XbS4k b_XbS4m [a1_abS1A]
                    [LclId] =
                        [$dApplicative_sbSxT] \u []
                            Control.Arrow.arr
                                $dApplicative_sbSxT
                                Control.Applicative.$fAlternativeWrappedArrow1; } in
                  let {
                    sat_sbSxU [Occ=Once] :: a_XbS4k b_XbS4m [a1_abS1A]
                    [LclId] =
                        [eta_sbSxR many_v_sbSxS $dApplicative_sbSxT] \u []
                            Control.Applicative.$fAlternativeWrappedArrow2
                                $dApplicative_sbSxT GHC.Types.: eta_sbSxR many_v_sbSxS;
                  } in  Control.Arrow.<+> $dArrowPlus_sbSxQ sat_sbSxU sat_sbSxV;
        } in  many_v_sbSxS;

Control.Applicative.$fAlternativeWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b.
     (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
     GHC.Base.Alternative (Control.Applicative.WrappedArrow a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),1*U)><L,U(A,C(C1(U)))>m] =
    [] \r [$dArrowZero_sbSxW $dArrowPlus_sbSxX]
        let {
          sat_sbSy4 [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
               -> Control.Applicative.WrappedArrow a_XbS4j b_XbS4l [a]
          [LclId] =
              [$dArrowZero_sbSxW $dArrowPlus_sbSxX] \r [eta_B1]
                  Control.Applicative.$fAlternativeWrappedArrow_$cmany
                      $dArrowZero_sbSxW $dArrowPlus_sbSxX eta_B1; } in
        let {
          sat_sbSy3 [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
               -> Control.Applicative.WrappedArrow a_XbS4j b_XbS4l [a]
          [LclId] =
              [$dArrowZero_sbSxW $dArrowPlus_sbSxX] \r [eta_B1]
                  Control.Applicative.$fAlternativeWrappedArrow_$csome
                      $dArrowZero_sbSxW $dArrowPlus_sbSxX eta_B1; } in
        let {
          sat_sbSy2 [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
               -> Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
               -> Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
          [LclId] =
              [$dArrowPlus_sbSxX] \r [ds_sbSy0 ds1_sbSy1]
                  Control.Arrow.<+> $dArrowPlus_sbSxX ds_sbSy0 ds1_sbSy1; } in
        let {
          sat_sbSxZ [Occ=Once]
            :: forall a. Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
          [LclId] =
              [$dArrowZero_sbSxW] \u []
                  Control.Arrow.zeroArrow $dArrowZero_sbSxW; } in
        let {
          sat_sbSxY [Occ=Once]
            :: GHC.Base.Applicative
                 (Control.Applicative.WrappedArrow a_XbS4j b_XbS4l)
          [LclId] =
              [$dArrowZero_sbSxW $dArrowPlus_sbSxX] \u []
                  Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative
                      $dArrowZero_sbSxW $dArrowPlus_sbSxX;
        } in 
          GHC.Base.C:Alternative [sat_sbSxY
                                  sat_sbSxZ
                                  sat_sbSy2
                                  sat_sbSy3
                                  sat_sbSy4];

Control.Applicative.$wunsafeDrop [InlPrag=NOUSERINLINE[0],
                                  Occ=LoopBreaker]
  :: forall a1. GHC.Prim.Int# -> [a1] -> [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_sbSy5 w_sbSy6]
        case w_sbSy6 of {
          [] -> [] [];
          : _ [Occ=Dead] ipv2_sbSy9 [Occ=Once*] ->
              case ww_sbSy5 of ds3_sbSya {
                __DEFAULT ->
                    case -# [ds3_sbSya 1#] of sat_sbSyb {
                      __DEFAULT -> Control.Applicative.$wunsafeDrop sat_sbSyb ipv2_sbSy9;
                    };
                1# -> ipv2_sbSy9;
              };
        };

Control.Applicative.$fAlternativeZipList2
  :: forall a.
     Control.Applicative.ZipList a
     -> Control.Applicative.ZipList a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbSyc ds1_sbSyd]
        let {
          sat_sbSyg [Occ=Once, Dmd=<L,1*U>] :: [a_abRZs]
          [LclId] =
              [ds_sbSyc ds1_sbSyd] \s []
                  case GHC.List.$wlenAcc ds_sbSyc 0# of ww2_sbSye {
                    __DEFAULT ->
                        case <=# [ww2_sbSye 0#] of {
                          __DEFAULT -> Control.Applicative.$wunsafeDrop ww2_sbSye ds1_sbSyd;
                          1# -> ds1_sbSyd;
                        };
                  };
        } in  GHC.Base.++ ds_sbSyc sat_sbSyg;

Control.Applicative.$fGeneric1ZipList1
  :: forall a.
     GHC.Generics.Rep1 Control.Applicative.ZipList a
     -> GHC.Generics.Rep1 Control.Applicative.ZipList a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbSyh] ds_sbSyh;

Control.Applicative.$fGeneric1ZipList2
  :: forall a.
     Control.Applicative.ZipList a -> Control.Applicative.ZipList a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sbSyi] x_sbSyi;

Control.Applicative.$fGeneric1ZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Control.Applicative.ZipList
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Control.Applicative.$fGeneric1ZipList2
                                            Control.Applicative.$fGeneric1ZipList1];

Control.Applicative.$fGenericZipList1
  :: forall a x.
     GHC.Generics.Rep (Control.Applicative.ZipList a) x
     -> GHC.Generics.Rep (Control.Applicative.ZipList a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbSyj] ds_sbSyj;

Control.Applicative.$fGenericZipList2
  :: forall a x.
     Control.Applicative.ZipList a -> Control.Applicative.ZipList a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sbSyk] x1_sbSyk;

Control.Applicative.$fGenericZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Control.Applicative.ZipList a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Control.Applicative.$fGenericZipList2
                                           Control.Applicative.$fGenericZipList1];

Control.Applicative.$fFoldableZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Control.Applicative.ZipList
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableNonEmpty_$cfold1
                                             Data.Foldable.$fFoldable[]_$cfoldMap
                                             GHC.Base.foldr
                                             Data.Foldable.$fFoldable[]_$cfoldr'
                                             GHC.List.foldl
                                             GHC.List.foldl'
                                             GHC.List.foldr1
                                             GHC.List.foldl1
                                             GHC.Base.id
                                             GHC.List.null
                                             GHC.List.length
                                             GHC.List.elem
                                             GHC.List.maximum
                                             GHC.List.minimum
                                             GHC.List.sum
                                             GHC.List.product];

Control.Applicative.$fFunctorZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Control.Applicative.ZipList
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.map
                                       GHC.Base.$fFunctor[]_$c<$];

Control.Applicative.$fApplicativeZipList6 [Occ=LoopBreaker]
  :: forall a b. [a -> b] -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbSyl ds1_sbSym]
        case ds_sbSyl of {
          [] -> [] [];
          : ipv_sbSyo [Occ=Once!] ipv1_sbSyp [Occ=Once] ->
              case ds1_sbSym of {
                [] -> [] [];
                : ipv2_sbSyr [Occ=Once] ipv3_sbSys [Occ=Once] ->
                    let {
                      sat_sbSyu [Occ=Once] :: [b_abS0e]
                      [LclId] =
                          [ipv1_sbSyp ipv3_sbSys] \u []
                              Control.Applicative.$fApplicativeZipList6
                                  ipv1_sbSyp ipv3_sbSys; } in
                    let {
                      sat_sbSyt [Occ=Once] :: b_abS0e
                      [LclId] =
                          [ipv_sbSyo ipv2_sbSyr] \u [] ipv_sbSyo ipv2_sbSyr;
                    } in  : [sat_sbSyt sat_sbSyu];
              };
        };

Control.Applicative.$fApplicativeZipList5
  :: forall a b.
     Control.Applicative.ZipList (a -> b)
     -> Control.Applicative.ZipList a -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbSyv ds1_sbSyw]
        Control.Applicative.$fApplicativeZipList6 ds_sbSyv ds1_sbSyw;

Control.Applicative.$fApplicativeZipList4 [Occ=LoopBreaker]
  :: forall a b. [a] -> [b] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbSyx eta_sbSyy]
        case ds_sbSyx of {
          [] -> [] [];
          : _ [Occ=Dead] ys_sbSyB [Occ=Once] ->
              case eta_sbSyy of {
                [] -> [] [];
                : y1_sbSyD [Occ=Once] ys1_sbSyE [Occ=Once] ->
                    let {
                      sat_sbSyF [Occ=Once] :: [b_abS0z]
                      [LclId] =
                          [ys_sbSyB ys1_sbSyE] \u []
                              Control.Applicative.$fApplicativeZipList4 ys_sbSyB ys1_sbSyE;
                    } in  : [y1_sbSyD sat_sbSyF];
              };
        };

Control.Applicative.$fApplicativeZipList3
  :: forall a b.
     Control.Applicative.ZipList a
     -> Control.Applicative.ZipList b -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_sbSyG a2_sbSyH]
        Control.Applicative.$fApplicativeZipList4 a1_sbSyG a2_sbSyH;

Control.Applicative.$fApplicativeZipList2 [Occ=LoopBreaker]
  :: forall b a. [a] -> [b] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbSyI ds1_sbSyJ]
        case ds_sbSyI of {
          [] -> [] [];
          : ipv_sbSyL [Occ=Once] ipv1_sbSyM [Occ=Once] ->
              case ds1_sbSyJ of {
                [] -> [] [];
                : _ [Occ=Dead] ipv3_sbSyP [Occ=Once] ->
                    let {
                      sat_sbSyQ [Occ=Once] :: [a_abS0I]
                      [LclId] =
                          [ipv1_sbSyM ipv3_sbSyP] \u []
                              Control.Applicative.$fApplicativeZipList2 ipv1_sbSyM ipv3_sbSyP;
                    } in  : [ipv_sbSyL sat_sbSyQ];
              };
        };

Control.Applicative.$fApplicativeZipList1
  :: forall b a.
     Control.Applicative.ZipList a
     -> Control.Applicative.ZipList b -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbSyR ds1_sbSyS]
        Control.Applicative.$fApplicativeZipList2 ds_sbSyR ds1_sbSyS;

Control.Applicative.$fApplicativeZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Control.Applicative.ZipList
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Control.Applicative.$fFunctorZipList
                                           GHC.List.repeat
                                           Control.Applicative.$fApplicativeZipList5
                                           GHC.List.zipWith
                                           Control.Applicative.$fApplicativeZipList3
                                           Control.Applicative.$fApplicativeZipList1];

Control.Applicative.$fAlternativeZipList_xs [Occ=LoopBreaker]
  :: forall a. [[a]]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Types.[]
                      Control.Applicative.$fAlternativeZipList_xs];

Control.Applicative.$fAlternativeZipList1 [Occ=LoopBreaker]
  :: forall a. [a] -> [[a]] -> [[a]]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbSyT ds1_sbSyU]
        case ds_sbSyT of {
          [] -> [] [];
          : ipv_sbSyW [Occ=Once] ipv1_sbSyX [Occ=Once] ->
              case ds1_sbSyU of {
                [] -> [] [];
                : ipv2_sbSyZ [Occ=Once] ipv3_sbSz0 [Occ=Once] ->
                    let {
                      sat_sbSz2 [Occ=Once] :: [[a_abRZG]]
                      [LclId] =
                          [ipv1_sbSyX ipv3_sbSz0] \u []
                              Control.Applicative.$fAlternativeZipList1
                                  ipv1_sbSyX ipv3_sbSz0; } in
                    let {
                      sat_sbSz1 [Occ=Once] :: [a_abRZG]
                      [LclId] =
                          CCCS :! [ipv_sbSyW ipv2_sbSyZ];
                    } in  : [sat_sbSz1 sat_sbSz2];
              };
        };

Control.Applicative.$fAlternativeZipList_$csome
  :: forall a.
     Control.Applicative.ZipList a -> Control.Applicative.ZipList [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sbSz3]
        let {
          some_v_sbSz4 [Occ=LoopBreaker] :: [[a_abRZG]]
          [LclId] =
              [v_sbSz3 some_v_sbSz4] \u []
                  let {
                    sat_sbSz5 [Occ=Once, Dmd=<L,1*U>] :: [[a_abRZG]]
                    [LclId] =
                        [some_v_sbSz4] \s []
                            Control.Applicative.$fAlternativeZipList2
                                some_v_sbSz4 Control.Applicative.$fAlternativeZipList_xs;
                  } in  Control.Applicative.$fAlternativeZipList1 v_sbSz3 sat_sbSz5;
        } in  some_v_sbSz4;

Control.Applicative.$fAlternativeZipList_$cmany
  :: forall a.
     Control.Applicative.ZipList a -> Control.Applicative.ZipList [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sbSz6]
        let {
          many_v_sbSz7 [Occ=LoopBreaker] :: [[a_abRZO]]
          [LclId] =
              [v_sbSz6 many_v_sbSz7] \u []
                  case
                      Control.Applicative.$fAlternativeZipList1 v_sbSz6 many_v_sbSz7
                  of
                  sat_sbSz8
                  { __DEFAULT ->
                        Control.Applicative.$fAlternativeZipList2
                            sat_sbSz8 Control.Applicative.$fAlternativeZipList_xs;
                  };
        } in  many_v_sbSz7;

Control.Applicative.$fAlternativeZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Control.Applicative.ZipList
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Control.Applicative.$fApplicativeZipList
                                           GHC.Types.[]
                                           Control.Applicative.$fAlternativeZipList2
                                           Control.Applicative.$fAlternativeZipList_$csome
                                           Control.Applicative.$fAlternativeZipList_$cmany];

Control.Applicative.$fReadZipList11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ZipList"#;

Control.Applicative.$fReadZipList10 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Control.Applicative.$fReadZipList11;

Control.Applicative.$fReadZipList_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Control.Applicative.$fReadZipList10];

Control.Applicative.$fReadZipList9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "{"#;

Control.Applicative.$fReadZipList8 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Control.Applicative.$fReadZipList9;

Control.Applicative.$fReadZipList_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Control.Applicative.$fReadZipList8];

Control.Applicative.$fReadZipList7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getZipList"#;

Control.Applicative.$fReadZipList6 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Control.Applicative.$fReadZipList7;

Control.Applicative.$fReadZipList5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Control.Applicative.$fReadZipList4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "}"#;

Control.Applicative.$fReadZipList3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Control.Applicative.$fReadZipList4;

Control.Applicative.$fReadZipList2 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Control.Applicative.$fReadZipList3];

Control.Applicative.$fReadZipList1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Control.Applicative.ZipList a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,A,1*C1(U))>, Unf=OtherCon []] =
    [] \r [$dRead_sbSz9]
        let {
          lvl_sbSza [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP [a_abRO3]
          [LclId] =
              [$dRead_sbSz9] \u []
                  GHC.Read.readListPrec
                      $dRead_sbSz9 Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sbSzb [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP [a_abRO3]
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl_sbSza] \r [ds1_sbSzc] lvl_sbSza; } in
        let {
          sat_sbSzw [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Control.Applicative.ZipList a_abRO3)
          [LclId] =
              [ds_sbSzb] \r [c_sbSzd eta_sbSze]
                  case c_sbSzd of {
                    GHC.Types.I# x_sbSzg [Occ=Once] ->
                        case <=# [x_sbSzg 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sbSzt [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sbSzb eta_sbSze] \r [a1_sbSzi]
                                        let {
                                          sat_sbSzq [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sbSzb eta_sbSze] \r [a2_sbSzj]
                                                  let {
                                                    sat_sbSzp [Occ=Once]
                                                      :: [a_abRO3]
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sbSze] \r [a3_sbSzk]
                                                            let {
                                                              sat_sbSzm [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sbSze a3_sbSzk] \r [a4_sbSzl]
                                                                      eta_sbSze a3_sbSzk;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Control.Applicative.$fReadZipList2
                                                                      sat_sbSzm
                                                              of
                                                              { Unit# ww1_sbSzo [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sbSzo];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Control.Applicative.$fReadZipList6
                                                        ds_sbSzb
                                                        Control.Applicative.$fReadZipList5
                                                        sat_sbSzp;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Control.Applicative.$fReadZipList_lexeme sat_sbSzq
                                          of
                                          { Unit# ww1_sbSzs [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sbSzs];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Control.Applicative.$fReadZipList_lexeme1 sat_sbSzt
                                of
                                { Unit# ww1_sbSzv [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sbSzv];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sbSzw;

Control.Applicative.$fReadZipList_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Control.Applicative.ZipList a)
[GblId, Arity=1, Str=<L,1*U(A,A,A,1*C1(U))>, Unf=OtherCon []] =
    [] \r [$dRead_sbSzx]
        let {
          ds_sbSzy [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Control.Applicative.ZipList a_XbRSJ
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sbSzx] \u []
                  Control.Applicative.$fReadZipList1 $dRead_sbSzx; } in
        let {
          sat_sbSzB [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Control.Applicative.ZipList a_XbRSJ)
          [LclId] =
              [ds_sbSzy] \r [n_sbSzz]
                  let {
                    sat_sbSzA [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Control.Applicative.ZipList a_XbRSJ)
                    [LclId] =
                        [ds_sbSzy n_sbSzz] \u []
                            ds_sbSzy
                                n_sbSzz Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sbSzA;
        } in  sat_sbSzB;

Control.Applicative.$fReadZipList_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Control.Applicative.ZipList a]
[GblId, Arity=1, Str=<L,1*U(A,A,A,1*C1(U))>, Unf=OtherCon []] =
    [] \r [$dRead_sbSzC]
        let {
          sat_sbSzD [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Control.Applicative.ZipList a_XbRSH)
          [LclId] =
              [$dRead_sbSzC] \s []
                  Control.Applicative.$fReadZipList1 $dRead_sbSzC;
        } in  GHC.Read.list sat_sbSzD;

Control.Applicative.$fReadZipList_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Control.Applicative.ZipList a]
[GblId, Arity=1, Str=<L,1*U(A,A,A,1*C1(U))>, Unf=OtherCon []] =
    [] \r [$dRead_sbSzE]
        let {
          sat_sbSzG [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Control.Applicative.ZipList a_XbRSI]
          [LclId] =
              [$dRead_sbSzE] \u []
                  let {
                    sat_sbSzF [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Control.Applicative.ZipList a_XbRSI)
                    [LclId] =
                        [$dRead_sbSzE] \s []
                            Control.Applicative.$fReadZipList1 $dRead_sbSzE;
                  } in 
                    GHC.Read.list
                        sat_sbSzF
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sbSzG;

Control.Applicative.$fReadZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Control.Applicative.ZipList a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,C(U))>m] =
    [] \r [$dRead_sbSzH]
        let {
          sat_sbSzL [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Control.Applicative.ZipList a_XbRSG]
          [LclId] =
              [$dRead_sbSzH] \u []
                  Control.Applicative.$fReadZipList_$creadListPrec $dRead_sbSzH; } in
        let {
          sat_sbSzK [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Control.Applicative.ZipList a_XbRSG)
          [LclId] =
              [$dRead_sbSzH] \u []
                  Control.Applicative.$fReadZipList1 $dRead_sbSzH; } in
        let {
          sat_sbSzJ [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Control.Applicative.ZipList a_XbRSG]
          [LclId] =
              [$dRead_sbSzH] \u []
                  Control.Applicative.$fReadZipList_$creadList $dRead_sbSzH; } in
        let {
          sat_sbSzI [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Control.Applicative.ZipList a_XbRSG)
          [LclId] =
              [$dRead_sbSzH] \u []
                  Control.Applicative.$fReadZipList_$creadsPrec $dRead_sbSzH;
        } in  GHC.Read.C:Read [sat_sbSzI sat_sbSzJ sat_sbSzK sat_sbSzL];

Control.Applicative.$fEqZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Control.Applicative.ZipList a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sbSzM]
        let {
          sat_sbSzO [Occ=Once]
            :: Control.Applicative.ZipList a_abRLG
               -> Control.Applicative.ZipList a_abRLG -> GHC.Types.Bool
          [LclId] =
              [$dEq_sbSzM] \r [eta_B2 eta_B1]
                  GHC.Classes.$fEq[]_$c/= $dEq_sbSzM eta_B2 eta_B1; } in
        let {
          sat_sbSzN [Occ=Once]
            :: Control.Applicative.ZipList a_abRLG
               -> Control.Applicative.ZipList a_abRLG -> GHC.Types.Bool
          [LclId] =
              [$dEq_sbSzM] \r [eta_B2 eta_B1]
                  GHC.Classes.$fEq[]_$c== $dEq_sbSzM eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sbSzN sat_sbSzO];

Control.Applicative.$fOrdZipList_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Control.Applicative.ZipList a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sbSzP]
        let {
          sat_sbSzQ [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_abRMe
          [LclId] =
              [$dOrd_sbSzP] \u [] GHC.Classes.$p1Ord $dOrd_sbSzP;
        } in  Control.Applicative.$fEqZipList sat_sbSzQ;

Control.Applicative.$fOrdZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Control.Applicative.ZipList a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_sbSzR]
        let {
          sat_sbSzZ [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe
          [LclId] =
              [$dOrd_sbSzR] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$cmin $dOrd_sbSzR eta_B2 eta_B1; } in
        let {
          sat_sbSzY [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe
          [LclId] =
              [$dOrd_sbSzR] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$cmax $dOrd_sbSzR eta_B2 eta_B1; } in
        let {
          sat_sbSzX [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbSzR] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$c>= $dOrd_sbSzR eta_B2 eta_B1; } in
        let {
          sat_sbSzW [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbSzR] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$c> $dOrd_sbSzR eta_B2 eta_B1; } in
        let {
          sat_sbSzV [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbSzR] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$c<= $dOrd_sbSzR eta_B2 eta_B1; } in
        let {
          sat_sbSzU [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbSzR] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$c< $dOrd_sbSzR eta_B2 eta_B1; } in
        let {
          sat_sbSzT [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sbSzR] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$ccompare $dOrd_sbSzR eta_B2 eta_B1; } in
        let {
          sat_sbSzS [Occ=Once]
            :: GHC.Classes.Eq (Control.Applicative.ZipList a_abRMe)
          [LclId] =
              [$dOrd_sbSzR] \u []
                  Control.Applicative.$fOrdZipList_$cp1Ord $dOrd_sbSzR;
        } in 
          GHC.Classes.C:Ord [sat_sbSzS
                             sat_sbSzT
                             sat_sbSzU
                             sat_sbSzV
                             sat_sbSzW
                             sat_sbSzX
                             sat_sbSzY
                             sat_sbSzZ];

Control.Applicative.$fShowZipList3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ZipList {"#;

Control.Applicative.$fShowZipList2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getZipList = "#;

Control.Applicative.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Control.Applicative.ZipList a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C(U)))><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbSA0 ww_sbSA1 w1_sbSA2]
        let {
          f_sbSA3 [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sbSA0 w1_sbSA2] \u [] GHC.Show.showList w_sbSA0 w1_sbSA2;
        } in 
          case >=# [ww_sbSA1 11#] of {
            __DEFAULT ->
                let {
                  sat_sbSA9 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sbSA3] \r [x_sbSA5]
                          let {
                            sat_sbSA8 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sbSA3 x_sbSA5] \u []
                                    let {
                                      sat_sbSA7 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sbSA3 x_sbSA5] \u []
                                              let {
                                                sat_sbSA6 [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sbSA5] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Control.Applicative.$fReadZipList4
                                                            x_sbSA5;
                                              } in  f_sbSA3 sat_sbSA6;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Control.Applicative.$fShowZipList2 sat_sbSA7;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Control.Applicative.$fShowZipList3 sat_sbSA8;
                } in  sat_sbSA9;
            1# ->
                let {
                  sat_sbSAg [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sbSA3] \r [x_sbSAa]
                          let {
                            sat_sbSAf [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sbSA3 x_sbSAa] \u []
                                    let {
                                      sat_sbSAe [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sbSA3 x_sbSAa] \u []
                                              let {
                                                sat_sbSAd [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sbSA3 x_sbSAa] \u []
                                                        let {
                                                          sat_sbSAc [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sbSAa] \u []
                                                                  let {
                                                                    sat_sbSAb [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sbSAa];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Control.Applicative.$fReadZipList4
                                                                        sat_sbSAb;
                                                        } in  f_sbSA3 sat_sbSAc;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Control.Applicative.$fShowZipList2 sat_sbSAd;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Control.Applicative.$fShowZipList3 sat_sbSAe;
                          } in  : [GHC.Show.$fShow(,)4 sat_sbSAf];
                } in  sat_sbSAg;
          };

Control.Applicative.$fShowZipList_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Control.Applicative.ZipList a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C(U)))><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbSAh w1_sbSAi w2_sbSAj]
        case w1_sbSAi of {
          GHC.Types.I# ww1_sbSAl [Occ=Once] ->
              Control.Applicative.$w$cshowsPrec w_sbSAh ww1_sbSAl w2_sbSAj;
        };

Control.Applicative.$fShowZipList_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Control.Applicative.ZipList a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C1(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sbSAm x_sbSAn]
        let {
          sat_sbSAp [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sbSAm x_sbSAn] \u []
                  let {
                    sat_sbSAo [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sbSAm x_sbSAn] \u []
                            GHC.Show.showList
                                $dShow_sbSAm x_sbSAn Control.Applicative.$fReadZipList3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Control.Applicative.$fShowZipList2 sat_sbSAo;
        } in 
          GHC.CString.unpackAppendCString#
              Control.Applicative.$fShowZipList3 sat_sbSAp;

Control.Applicative.$fShowZipList1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Control.Applicative.$fShowZipList_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Control.Applicative.ZipList a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sbSAq ls_sbSAr s_sbSAs]
        let {
          sat_sbSAu [Occ=Once]
            :: Control.Applicative.ZipList a_abRLb -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbSAq] \r [w_sbSAt]
                  Control.Applicative.$w$cshowsPrec $dShow_sbSAq 0# w_sbSAt;
        } in  GHC.Show.showList__ sat_sbSAu ls_sbSAr s_sbSAs;

Control.Applicative.$fShowZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Control.Applicative.ZipList a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C(U)))>m] =
    [] \r [$dShow_sbSAv]
        let {
          sat_sbSAy [Occ=Once]
            :: [Control.Applicative.ZipList a_abRLb] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbSAv] \r [eta_B2 eta_B1]
                  Control.Applicative.$fShowZipList_$cshowList
                      $dShow_sbSAv eta_B2 eta_B1; } in
        let {
          sat_sbSAx [Occ=Once]
            :: Control.Applicative.ZipList a_abRLb -> GHC.Base.String
          [LclId] =
              [$dShow_sbSAv] \r [eta_B1]
                  Control.Applicative.$fShowZipList_$cshow $dShow_sbSAv eta_B1; } in
        let {
          sat_sbSAw [Occ=Once]
            :: GHC.Types.Int
               -> Control.Applicative.ZipList a_abRLb -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbSAv] \r [eta_B2 eta_B1]
                  Control.Applicative.$fShowZipList_$cshowsPrec
                      $dShow_sbSAv eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sbSAw sat_sbSAx sat_sbSAy];

Control.Applicative.$fGeneric1WrappedArrow1
  :: forall (a1 :: * -> * -> *) b a2.
     GHC.Generics.Rep1 (Control.Applicative.WrappedArrow a1 b) a2
     -> GHC.Generics.Rep1 (Control.Applicative.WrappedArrow a1 b) a2
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbSAz] ds_sbSAz;

Control.Applicative.$fGeneric1WrappedArrow2
  :: forall (a1 :: * -> * -> *) b a2.
     Control.Applicative.WrappedArrow a1 b a2
     -> Control.Applicative.WrappedArrow a1 b a2
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sbSAA] x_sbSAA;

Control.Applicative.$fGeneric1WrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b.
     GHC.Generics.Generic1 (Control.Applicative.WrappedArrow a b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Control.Applicative.$fGeneric1WrappedArrow2
                                            Control.Applicative.$fGeneric1WrappedArrow1];

Control.Applicative.$fGenericWrappedArrow1
  :: forall (a :: * -> * -> *) b c x.
     GHC.Generics.Rep (Control.Applicative.WrappedArrow a b c) x
     -> GHC.Generics.Rep (Control.Applicative.WrappedArrow a b c) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbSAB] ds_sbSAB;

Control.Applicative.$fGenericWrappedArrow2
  :: forall (a :: * -> * -> *) b c x.
     Control.Applicative.WrappedArrow a b c
     -> Control.Applicative.WrappedArrow a b c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sbSAC] x1_sbSAC;

Control.Applicative.$fGenericWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b c.
     GHC.Generics.Generic (Control.Applicative.WrappedArrow a b c)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Control.Applicative.$fGenericWrappedArrow2
                                           Control.Applicative.$fGenericWrappedArrow1];

Control.Applicative.$fMonadWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     GHC.Base.Monad (Control.Applicative.WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(U),A,A,A,A),U,1*U,U,1*U)>m] =
    [] \r [$dMonad_sbSAD]
        let {
          sat_sbSAI [Occ=Once]
            :: forall a.
               GHC.Base.String -> Control.Applicative.WrappedMonad m_abRHy a
          [LclId] =
              [$dMonad_sbSAD] \u [] GHC.Base.fail $dMonad_sbSAD; } in
        let {
          sat_sbSAH [Occ=Once]
            :: forall a. a -> Control.Applicative.WrappedMonad m_abRHy a
          [LclId] =
              [$dMonad_sbSAD] \u [] GHC.Base.return $dMonad_sbSAD; } in
        let {
          sat_sbSAG [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_abRHy a
               -> Control.Applicative.WrappedMonad m_abRHy b
               -> Control.Applicative.WrappedMonad m_abRHy b
          [LclId] =
              [$dMonad_sbSAD] \u [] GHC.Base.>> $dMonad_sbSAD; } in
        let {
          sat_sbSAF [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_abRHy a
               -> (a -> Control.Applicative.WrappedMonad m_abRHy b)
               -> Control.Applicative.WrappedMonad m_abRHy b
          [LclId] =
              [$dMonad_sbSAD] \u [] GHC.Base.>>= $dMonad_sbSAD; } in
        let {
          sat_sbSAE [Occ=Once]
            :: GHC.Base.Applicative (Control.Applicative.WrappedMonad m_abRHy)
          [LclId] =
              [$dMonad_sbSAD] \u []
                  Control.Applicative.$fApplicativeWrappedMonad $dMonad_sbSAD;
        } in 
          GHC.Base.C:Monad [sat_sbSAE
                            sat_sbSAF
                            sat_sbSAG
                            sat_sbSAH
                            sat_sbSAI];

Control.Applicative.$fGeneric1WrappedMonad1
  :: forall (m :: * -> *) a.
     GHC.Generics.Rep1 (Control.Applicative.WrappedMonad m) a
     -> GHC.Generics.Rep1 (Control.Applicative.WrappedMonad m) a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbSAJ] ds_sbSAJ;

Control.Applicative.$fGeneric1WrappedMonad2
  :: forall (m :: * -> *) a.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sbSAK] x_sbSAK;

Control.Applicative.$fGeneric1WrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Generics.Generic1 (Control.Applicative.WrappedMonad m)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Control.Applicative.$fGeneric1WrappedMonad2
                                            Control.Applicative.$fGeneric1WrappedMonad1];

Control.Applicative.$fGenericWrappedMonad1
  :: forall (m :: * -> *) a x.
     GHC.Generics.Rep (Control.Applicative.WrappedMonad m a) x
     -> GHC.Generics.Rep (Control.Applicative.WrappedMonad m a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbSAL] ds_sbSAL;

Control.Applicative.$fGenericWrappedMonad2
  :: forall (m :: * -> *) a x.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sbSAM] x1_sbSAM;

Control.Applicative.$fGenericWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *) a.
     GHC.Generics.Generic (Control.Applicative.WrappedMonad m a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Control.Applicative.$fGenericWrappedMonad2
                                           Control.Applicative.$fGenericWrappedMonad1];

Control.Applicative.unwrapMonad
  :: forall (m :: * -> *) a.
     Control.Applicative.WrappedMonad m a -> m a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Control.Applicative.$fGeneric1WrappedMonad2 eta_B1;

Control.Applicative.unwrapArrow
  :: forall (a :: * -> * -> *) b c.
     Control.Applicative.WrappedArrow a b c -> a b c
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Control.Applicative.$fGeneric1WrappedArrow2 eta_B1;

Control.Applicative.getZipList
  :: forall a. Control.Applicative.ZipList a -> [a]
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Control.Applicative.$fGeneric1ZipList2 eta_B1;

Control.Applicative.optional
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     f a -> f (GHC.Base.Maybe a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LL),U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,1*C1(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sbSAN eta_sbSAO]
        let {
          $dApplicative_sbSAP [Dmd=<L,U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)>]
            :: GHC.Base.Applicative f_abRFg
          [LclId] =
              [$dAlternative_sbSAN] \u []
                  GHC.Base.$p1Alternative $dAlternative_sbSAN; } in
        let {
          sat_sbSAS [Occ=Once] :: f_abRFg (GHC.Base.Maybe a_abRFh)
          [LclId] =
              [$dApplicative_sbSAP] \u []
                  GHC.Base.pure $dApplicative_sbSAP GHC.Base.Nothing; } in
        let {
          sat_sbSAR [Occ=Once] :: f_abRFg (GHC.Base.Maybe a_abRFh)
          [LclId] =
              [eta_sbSAO $dApplicative_sbSAP] \u []
                  case GHC.Base.$p1Applicative $dApplicative_sbSAP of sat_sbSAQ {
                    __DEFAULT -> GHC.Base.fmap sat_sbSAQ GHC.Base.Just eta_sbSAO;
                  };
        } in  GHC.Base.<|> $dAlternative_sbSAN sat_sbSAR sat_sbSAS;

Control.Applicative.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Control.Applicative.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$trModule4];

Control.Applicative.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Control.Applicative"#;

Control.Applicative.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$trModule2];

Control.Applicative.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Control.Applicative.$trModule3
                                     Control.Applicative.$trModule1];

Control.Applicative.$tcWrappedMonad1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         GHC.Types.krep$*Arr*];

Control.Applicative.$tcWrappedArrow1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         GHC.Types.krep$*->*->*];

$krep_rbSvt :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep1_rbSvu :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep2_rbSvv :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep3_rbSvw :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rbSvv GHC.Types.[]];

$krep4_rbSvx :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc[]
                                              $krep3_rbSvw];

$krep5_rbSvy :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep2_rbSvv $krep1_rbSvu];

$krep6_rbSvz :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep5_rbSvy $krep_rbSvt];

Control.Applicative.$tcWrappedMonad3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrappedMonad"#;

Control.Applicative.$tcWrappedMonad2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tcWrappedMonad3];

Control.Applicative.$tcWrappedMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12971590878300233698##
                                    12447260690856494251##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tcWrappedMonad2
                                    0#
                                    Control.Applicative.$tcWrappedMonad1];

$krep7_rbSvA :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rbSvu GHC.Types.[]];

$krep8_rbSvB :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rbSvv $krep7_rbSvA];

$krep9_rbSvC :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Applicative.$tcWrappedMonad
                                              $krep8_rbSvB];

Control.Applicative.$tc'WrapMonad1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_rbSvy $krep9_rbSvC];

Control.Applicative.$tc'WrapMonad3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'WrapMonad"#;

Control.Applicative.$tc'WrapMonad2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tc'WrapMonad3];

Control.Applicative.$tc'WrapMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10363415327661881286##
                                    6845751270384138997##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tc'WrapMonad2
                                    2#
                                    Control.Applicative.$tc'WrapMonad1];

Control.Applicative.$tcWrappedArrow3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrappedArrow"#;

Control.Applicative.$tcWrappedArrow2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tcWrappedArrow3];

Control.Applicative.$tcWrappedArrow :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17995829375472255965##
                                    6668242383287740398##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tcWrappedArrow2
                                    0#
                                    Control.Applicative.$tcWrappedArrow1];

$krep10_rbSvD :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rbSvt GHC.Types.[]];

$krep11_rbSvE :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rbSvu $krep10_rbSvD];

$krep12_rbSvF :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rbSvv $krep11_rbSvE];

$krep13_rbSvG :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Applicative.$tcWrappedArrow
                                              $krep12_rbSvF];

Control.Applicative.$tc'WrapArrow1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_rbSvz $krep13_rbSvG];

Control.Applicative.$tc'WrapArrow3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'WrapArrow"#;

Control.Applicative.$tc'WrapArrow2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tc'WrapArrow3];

Control.Applicative.$tc'WrapArrow :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4796259816778499037##
                                    13482613273239263357##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tc'WrapArrow2
                                    3#
                                    Control.Applicative.$tc'WrapArrow1];

Control.Applicative.$tcZipList1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$fReadZipList11];

Control.Applicative.$tcZipList :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11311650752326360483##
                                    5534599578149162946##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tcZipList1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep14_rbSvH :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Applicative.$tcZipList
                                              $krep3_rbSvw];

Control.Applicative.$tc'ZipList1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_rbSvx $krep14_rbSvH];

Control.Applicative.$tc'ZipList3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'ZipList"#;

Control.Applicative.$tc'ZipList2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tc'ZipList3];

Control.Applicative.$tc'ZipList :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15353069281551614305##
                                    7665927634319452478##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tc'ZipList2
                                    1#
                                    Control.Applicative.$tc'ZipList1];


==================== Pre unarise: ====================
2018-03-16 16:06:48.260957964 UTC

Control.Applicative.$fFunctorWrappedMonad1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b. a -> Control.Applicative.WrappedMonad m b -> m a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbUjC x_sbUjD eta_sbUjE]
        let {
          lvl_sbUjF [Occ=OnceL] :: m_XbS7L a_abS5L
          [LclId] =
              [$dMonad_sbUjC x_sbUjD] \u []
                  GHC.Base.return $dMonad_sbUjC x_sbUjD; } in
        let {
          sat_sbUjH [Occ=Once] :: b_abS5M -> m_XbS7L a_abS5L
          [LclId] =
              [lvl_sbUjF] \r [x1_sbUjG] lvl_sbUjF;
        } in  GHC.Base.>>= $dMonad_sbUjC eta_sbUjE sat_sbUjH;

Control.Applicative.$fFunctorWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     GHC.Base.Functor (Control.Applicative.WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,C(U),A)>m] =
    [] \r [$dMonad_sbUjI]
        let {
          sat_sbUjM [Occ=Once]
            :: forall a b.
               a
               -> Control.Applicative.WrappedMonad m_XbS7K b
               -> Control.Applicative.WrappedMonad m_XbS7K a
          [LclId] =
              [$dMonad_sbUjI] \r [eta_B2 eta_B1]
                  Control.Applicative.$fFunctorWrappedMonad1
                      $dMonad_sbUjI eta_B2 eta_B1; } in
        let {
          sat_sbUjL [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Control.Applicative.WrappedMonad m_XbS7K a
               -> Control.Applicative.WrappedMonad m_XbS7K b
          [LclId] =
              [$dMonad_sbUjI] \r [f_sbUjJ ds_sbUjK]
                  GHC.Base.liftM $dMonad_sbUjI f_sbUjJ ds_sbUjK;
        } in  GHC.Base.C:Functor [sat_sbUjL sat_sbUjM];

Control.Applicative.$fApplicativeWrappedMonad3
  :: forall (m :: * -> *). GHC.Base.Monad m => forall a. a -> m a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbUjN eta_sbUjO]
        case GHC.Base.$p1Monad $dMonad_sbUjN of sat_sbUjP {
          __DEFAULT -> GHC.Base.pure sat_sbUjP eta_sbUjO;
        };

Control.Applicative.$fApplicativeWrappedMonad2
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m b -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbUjQ a1_sbUjR a2_sbUjS]
        let {
          sat_sbUjW [Occ=Once] :: m_XbS74 (b_abS5b -> b_abS5b)
          [LclId] =
              [$dMonad_sbUjQ a1_sbUjR] \u []
                  let {
                    lvl_sbUjT [Occ=OnceL] :: m_XbS74 (b_abS5b -> b_abS5b)
                    [LclId] =
                        [$dMonad_sbUjQ] \u []
                            GHC.Base.return $dMonad_sbUjQ GHC.Base.breakpoint; } in
                  let {
                    sat_sbUjV [Occ=Once] :: a_abS5a -> m_XbS74 (b_abS5b -> b_abS5b)
                    [LclId] =
                        [lvl_sbUjT] \r [x1_sbUjU] lvl_sbUjT;
                  } in  GHC.Base.>>= $dMonad_sbUjQ a1_sbUjR sat_sbUjV;
        } in  GHC.Base.ap $dMonad_sbUjQ sat_sbUjW a2_sbUjS;

Control.Applicative.$fApplicativeWrappedMonad1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m b -> m a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbUjX ds_sbUjY ds1_sbUjZ]
        let {
          sat_sbUk4 [Occ=Once] :: a_abS5k -> m_XbS9j a_abS5k
          [LclId] =
              [$dMonad_sbUjX ds1_sbUjZ] \r [x1_sbUk0]
                  let {
                    lvl_sbUk1 [Occ=OnceL] :: m_XbS9j a_abS5k
                    [LclId] =
                        [$dMonad_sbUjX x1_sbUk0] \u []
                            GHC.Base.return $dMonad_sbUjX x1_sbUk0; } in
                  let {
                    sat_sbUk3 [Occ=Once] :: b_abS5l -> m_XbS9j a_abS5k
                    [LclId] =
                        [lvl_sbUk1] \r [x2_sbUk2] lvl_sbUk1;
                  } in  GHC.Base.>>= $dMonad_sbUjX ds1_sbUjZ sat_sbUk3;
        } in  GHC.Base.>>= $dMonad_sbUjX ds_sbUjY sat_sbUk4;

Control.Applicative.$fApplicativeWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     GHC.Base.Applicative (Control.Applicative.WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A)>m] =
    [] \r [$dMonad_sbUk5]
        let {
          sat_sbUkg [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_XbS6X a
               -> Control.Applicative.WrappedMonad m_XbS6X b
               -> Control.Applicative.WrappedMonad m_XbS6X a
          [LclId] =
              [$dMonad_sbUk5] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedMonad1
                      $dMonad_sbUk5 eta_B2 eta_B1; } in
        let {
          sat_sbUkf [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_XbS6X a
               -> Control.Applicative.WrappedMonad m_XbS6X b
               -> Control.Applicative.WrappedMonad m_XbS6X b
          [LclId] =
              [$dMonad_sbUk5] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedMonad2
                      $dMonad_sbUk5 eta_B2 eta_B1; } in
        let {
          sat_sbUke [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Control.Applicative.WrappedMonad m_XbS6X a
               -> Control.Applicative.WrappedMonad m_XbS6X b
               -> Control.Applicative.WrappedMonad m_XbS6X c
          [LclId] =
              [$dMonad_sbUk5] \r [f_sbUkb ds_sbUkc ds1_sbUkd]
                  GHC.Base.liftM2 $dMonad_sbUk5 f_sbUkb ds_sbUkc ds1_sbUkd; } in
        let {
          sat_sbUka [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_XbS6X (a -> b)
               -> Control.Applicative.WrappedMonad m_XbS6X a
               -> Control.Applicative.WrappedMonad m_XbS6X b
          [LclId] =
              [$dMonad_sbUk5] \r [ds_sbUk8 ds1_sbUk9]
                  GHC.Base.ap $dMonad_sbUk5 ds_sbUk8 ds1_sbUk9; } in
        let {
          sat_sbUk7 [Occ=Once]
            :: forall a. a -> Control.Applicative.WrappedMonad m_XbS6X a
          [LclId] =
              [$dMonad_sbUk5] \r [eta_B1]
                  Control.Applicative.$fApplicativeWrappedMonad3
                      $dMonad_sbUk5 eta_B1; } in
        let {
          sat_sbUk6 [Occ=Once]
            :: GHC.Base.Functor (Control.Applicative.WrappedMonad m_XbS6X)
          [LclId] =
              [$dMonad_sbUk5] \u []
                  Control.Applicative.$fFunctorWrappedMonad $dMonad_sbUk5;
        } in 
          GHC.Base.C:Applicative [sat_sbUk6
                                  sat_sbUk7
                                  sat_sbUka
                                  sat_sbUke
                                  sat_sbUkf
                                  sat_sbUkg];

Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Base.Applicative (Control.Applicative.WrappedMonad m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbUkh]
        let {
          sat_sbUki [Occ=Once,
                     Dmd=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A)>]
            :: GHC.Base.Monad m_XbS6t
          [LclId] =
              [$dMonadPlus_sbUkh] \u [] GHC.Base.$p2MonadPlus $dMonadPlus_sbUkh;
        } in  Control.Applicative.$fApplicativeWrappedMonad sat_sbUki;

Control.Applicative.$fAlternativeWrappedMonad_$csome
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall a.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbUkj eta_sbUkk]
        case
            GHC.Base.$p2MonadPlus $dMonadPlus_sbUkj
        of
        $dApplicative_sbUkl [Dmd=<S(LC(C(S))LLL),U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A)>]
        { __DEFAULT ->
              let {
                m2_sbUkm [Occ=OnceL] :: m_XbS6w [a_abS46]
                [LclId] =
                    [$dMonadPlus_sbUkj $dApplicative_sbUkl some_v_sbUkn] \u []
                        let {
                          sat_sbUkp [Occ=Once] :: m_XbS6w [a_abS46]
                          [LclId] =
                              [$dApplicative_sbUkl] \u []
                                  case GHC.Base.$p1Monad $dApplicative_sbUkl of sat_sbUko {
                                    __DEFAULT -> GHC.Base.pure sat_sbUko GHC.Types.[];
                                  };
                        } in  GHC.Base.mplus $dMonadPlus_sbUkj some_v_sbUkn sat_sbUkp;
                some_v_sbUkn [Occ=LoopBreaker] :: m_XbS6w [a_abS46]
                [LclId] =
                    [eta_sbUkk $dApplicative_sbUkl m2_sbUkm] \u []
                        let {
                          sat_sbUku [Occ=Once] :: a_abS46 -> m_XbS6w [a_abS46]
                          [LclId] =
                              [$dApplicative_sbUkl m2_sbUkm] \r [x1_sbUkq]
                                  let {
                                    sat_sbUkt [Occ=Once] :: [a_abS46] -> m_XbS6w [a_abS46]
                                    [LclId] =
                                        [$dApplicative_sbUkl x1_sbUkq] \r [x2_sbUkr]
                                            let {
                                              sat_sbUks [Occ=Once] :: [a_abS46]
                                              [LclId] =
                                                  CCCS :! [x1_sbUkq x2_sbUkr];
                                            } in  GHC.Base.return $dApplicative_sbUkl sat_sbUks;
                                  } in  GHC.Base.>>= $dApplicative_sbUkl m2_sbUkm sat_sbUkt;
                        } in  GHC.Base.>>= $dApplicative_sbUkl eta_sbUkk sat_sbUku;
              } in  some_v_sbUkn;
        };

Control.Applicative.$fAlternativeWrappedMonad_$cmany
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall a.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))),U(A,U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbUkv eta_sbUkw]
        let {
          many_v_sbUkx [Occ=LoopBreaker] :: m_XbS6v [a_abS4e]
          [LclId] =
              [$dMonadPlus_sbUkv eta_sbUkw many_v_sbUkx] \u []
                  let {
                    $dApplicative_sbUky [Dmd=<L,U(1*U(A,1*C1(U),A,A,A,A),C(C1(U)),A,C(U),A)>]
                      :: GHC.Base.Monad m_XbS6v
                    [LclId] =
                        [$dMonadPlus_sbUkv] \u []
                            GHC.Base.$p2MonadPlus $dMonadPlus_sbUkv; } in
                  let {
                    sat_sbUkG [Occ=Once] :: m_XbS6v [a_abS4e]
                    [LclId] =
                        [$dApplicative_sbUky] \u []
                            case GHC.Base.$p1Monad $dApplicative_sbUky of sat_sbUkF {
                              __DEFAULT -> GHC.Base.pure sat_sbUkF GHC.Types.[];
                            }; } in
                  let {
                    sat_sbUkE [Occ=Once] :: m_XbS6v [a_abS4e]
                    [LclId] =
                        [eta_sbUkw many_v_sbUkx $dApplicative_sbUky] \u []
                            let {
                              sat_sbUkD [Occ=Once] :: a_abS4e -> m_XbS6v [a_abS4e]
                              [LclId] =
                                  [many_v_sbUkx $dApplicative_sbUky] \r [x1_sbUkz]
                                      let {
                                        sat_sbUkC [Occ=Once] :: [a_abS4e] -> m_XbS6v [a_abS4e]
                                        [LclId] =
                                            [$dApplicative_sbUky x1_sbUkz] \r [x2_sbUkA]
                                                let {
                                                  sat_sbUkB [Occ=Once] :: [a_abS4e]
                                                  [LclId] =
                                                      CCCS :! [x1_sbUkz x2_sbUkA];
                                                } in  GHC.Base.return $dApplicative_sbUky sat_sbUkB;
                                      } in  GHC.Base.>>= $dApplicative_sbUky many_v_sbUkx sat_sbUkC;
                            } in  GHC.Base.>>= $dApplicative_sbUky eta_sbUkw sat_sbUkD;
                  } in  GHC.Base.mplus $dMonadPlus_sbUkv sat_sbUkE sat_sbUkG;
        } in  many_v_sbUkx;

Control.Applicative.$fAlternativeWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Base.Alternative (Control.Applicative.WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),1*U,C(C1(U)))>m] =
    [] \r [$dMonadPlus_sbUkH]
        let {
          sat_sbUkO [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedMonad m_XbS6u a
               -> Control.Applicative.WrappedMonad m_XbS6u [a]
          [LclId] =
              [$dMonadPlus_sbUkH] \r [eta_B1]
                  Control.Applicative.$fAlternativeWrappedMonad_$cmany
                      $dMonadPlus_sbUkH eta_B1; } in
        let {
          sat_sbUkN [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedMonad m_XbS6u a
               -> Control.Applicative.WrappedMonad m_XbS6u [a]
          [LclId] =
              [$dMonadPlus_sbUkH] \r [eta_B1]
                  Control.Applicative.$fAlternativeWrappedMonad_$csome
                      $dMonadPlus_sbUkH eta_B1; } in
        let {
          sat_sbUkM [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedMonad m_XbS6u a
               -> Control.Applicative.WrappedMonad m_XbS6u a
               -> Control.Applicative.WrappedMonad m_XbS6u a
          [LclId] =
              [$dMonadPlus_sbUkH] \r [ds_sbUkK ds1_sbUkL]
                  GHC.Base.mplus $dMonadPlus_sbUkH ds_sbUkK ds1_sbUkL; } in
        let {
          sat_sbUkJ [Occ=Once]
            :: forall a. Control.Applicative.WrappedMonad m_XbS6u a
          [LclId] =
              [$dMonadPlus_sbUkH] \u [] GHC.Base.mzero $dMonadPlus_sbUkH; } in
        let {
          sat_sbUkI [Occ=Once]
            :: GHC.Base.Applicative (Control.Applicative.WrappedMonad m_XbS6u)
          [LclId] =
              [$dMonadPlus_sbUkH] \u []
                  Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative
                      $dMonadPlus_sbUkH;
        } in 
          GHC.Base.C:Alternative [sat_sbUkI
                                  sat_sbUkJ
                                  sat_sbUkM
                                  sat_sbUkN
                                  sat_sbUkO];

Control.Applicative.$fFunctorWrappedArrow2
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     (a1 -> b1) -> Control.Applicative.WrappedArrow a b a1 -> a b b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbUkP eta_sbUkQ eta1_sbUkR]
        let {
          sat_sbUkT [Occ=Once] :: a_abS32 a1_abS38 b1_abS39
          [LclId] =
              [$dArrow_sbUkP eta_sbUkQ] \u []
                  Control.Arrow.arr $dArrow_sbUkP eta_sbUkQ;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbUkP of sat_sbUkS {
            __DEFAULT -> Control.Category.. sat_sbUkS sat_sbUkT eta1_sbUkR;
          };

Control.Applicative.$fFunctorWrappedArrow1
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     a1 -> Control.Applicative.WrappedArrow a b b1 -> a b a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbUkU x_sbUkV eta_sbUkW]
        let {
          sat_sbUl0 [Occ=Once] :: a_XbS5D b1_abS3t a1_abS3s
          [LclId] =
              [$dArrow_sbUkU x_sbUkV] \u []
                  let {
                    sat_sbUkZ [Occ=Once] :: b1_abS3t -> a1_abS3s
                    [LclId] =
                        [x_sbUkV] \r [ds_sbUkY] x_sbUkV;
                  } in  Control.Arrow.arr $dArrow_sbUkU sat_sbUkZ;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbUkU of sat_sbUkX {
            __DEFAULT -> Control.Category.. sat_sbUkX sat_sbUl0 eta_sbUkW;
          };

Control.Applicative.$fFunctorWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     GHC.Base.Functor (Control.Applicative.WrappedArrow a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,A)>m] =
    [] \r [$dArrow_sbUl1]
        let {
          sat_sbUl3 [Occ=Once]
            :: forall a b.
               a
               -> Control.Applicative.WrappedArrow a_XbS5M b_XbS5O b
               -> Control.Applicative.WrappedArrow a_XbS5M b_XbS5O a
          [LclId] =
              [$dArrow_sbUl1] \r [eta_B2 eta_B1]
                  Control.Applicative.$fFunctorWrappedArrow1
                      $dArrow_sbUl1 eta_B2 eta_B1; } in
        let {
          sat_sbUl2 [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Control.Applicative.WrappedArrow a_XbS5M b_XbS5O a
               -> Control.Applicative.WrappedArrow a_XbS5M b_XbS5O b
          [LclId] =
              [$dArrow_sbUl1] \r [eta_B2 eta_B1]
                  Control.Applicative.$fFunctorWrappedArrow2
                      $dArrow_sbUl1 eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sbUl2 sat_sbUl3];

Control.Applicative.$fAlternativeWrappedArrow2
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1 c.
     (a1 -> b1 -> c)
     -> Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b b1
     -> a b c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,1*C1(C1(U)))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbUl4 eta_sbUl5 eta1_sbUl6 eta2_sbUl7]
        let {
          sat_sbUlb [Occ=Once] :: a_abS1H b_abS1I (a1_abS2g, b1_abS2h)
          [LclId] =
              [$dArrow_sbUl4 eta1_sbUl6 eta2_sbUl7] \u []
                  Control.Arrow.&&& $dArrow_sbUl4 eta1_sbUl6 eta2_sbUl7; } in
        let {
          sat_sbUla [Occ=Once] :: a_abS1H (a1_abS2g, b1_abS2h) c_abS2i
          [LclId] =
              [$dArrow_sbUl4 eta_sbUl5] \u []
                  let {
                    sat_sbUl9 [Occ=Once] :: (a1_abS2g, b1_abS2h) -> c_abS2i
                    [LclId] =
                        [eta_sbUl5] \r [eta_B1] Data.Tuple.uncurry eta_sbUl5 eta_B1;
                  } in  Control.Arrow.arr $dArrow_sbUl4 sat_sbUl9;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbUl4 of sat_sbUl8 {
            __DEFAULT -> Control.Category.. sat_sbUl8 sat_sbUla sat_sbUlb;
          };

Control.Applicative.$fApplicativeWrappedArrow5
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1. a1 -> a b a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbUlc x_sbUld]
        let {
          sat_sbUlf [Occ=Once] :: b_XbS4F -> a1_abS1R
          [LclId] =
              [x_sbUld] \r [ds_sbUle] x_sbUld;
        } in  Control.Arrow.arr $dArrow_sbUlc sat_sbUlf;

Control.Applicative.$fApplicativeWrappedArrow4
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     Control.Applicative.WrappedArrow a b (a1 -> b1)
     -> Control.Applicative.WrappedArrow a b a1 -> a b b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbUlg eta_B2 eta_B1]
        Control.Applicative.$fAlternativeWrappedArrow2
            $dArrow_sbUlg GHC.Base.breakpoint eta_B2 eta_B1;

Control.Applicative.$fApplicativeWrappedArrow3
  :: forall b a. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbUlh eta_sbUli] eta_sbUli;

Control.Applicative.$fApplicativeWrappedArrow2
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b b1 -> a b b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbUlj a2_sbUlk a3_sbUll]
        let {
          sat_sbUlo [Occ=Once]
            :: Control.Applicative.WrappedArrow
                 a_XbS4Q b_XbS4S (b1_abS2K -> b1_abS2K)
          [LclId] =
              [$dArrow_sbUlj a2_sbUlk] \u []
                  let {
                    sat_sbUln [Occ=Once] :: a_XbS4Q a1_abS2J (b1_abS2K -> b1_abS2K)
                    [LclId] =
                        [$dArrow_sbUlj] \u []
                            Control.Arrow.arr
                                $dArrow_sbUlj Control.Applicative.$fApplicativeWrappedArrow3;
                  } in 
                    case Control.Arrow.$p1Arrow $dArrow_sbUlj of sat_sbUlm {
                      __DEFAULT -> Control.Category.. sat_sbUlm sat_sbUln a2_sbUlk;
                    };
        } in 
          Control.Applicative.$fAlternativeWrappedArrow2
              $dArrow_sbUlj GHC.Base.breakpoint sat_sbUlo a3_sbUll;

Control.Applicative.$fApplicativeWrappedArrow1
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b b1 -> a b a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbUlp eta_B2 eta_B1]
        Control.Applicative.$fAlternativeWrappedArrow2
            $dArrow_sbUlp GHC.Base.const eta_B2 eta_B1;

Control.Applicative.$fApplicativeWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     GHC.Base.Applicative (Control.Applicative.WrappedArrow a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>m] =
    [] \r [$dArrow_sbUlq]
        let {
          sat_sbUlw [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
          [LclId] =
              [$dArrow_sbUlq] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedArrow1
                      $dArrow_sbUlq eta_B2 eta_B1; } in
        let {
          sat_sbUlv [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
          [LclId] =
              [$dArrow_sbUlq] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedArrow2
                      $dArrow_sbUlq eta_B2 eta_B1; } in
        let {
          sat_sbUlu [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b c
          [LclId] =
              [$dArrow_sbUlq] \r [eta_B3 eta_B2 eta_B1]
                  Control.Applicative.$fAlternativeWrappedArrow2
                      $dArrow_sbUlq eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbUlt [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedArrow a_XbS4O b_XbS8b (a -> b)
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
          [LclId] =
              [$dArrow_sbUlq] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedArrow4
                      $dArrow_sbUlq eta_B2 eta_B1; } in
        let {
          sat_sbUls [Occ=Once]
            :: forall a.
               a -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
          [LclId] =
              [$dArrow_sbUlq] \r [eta_B1]
                  Control.Applicative.$fApplicativeWrappedArrow5
                      $dArrow_sbUlq eta_B1; } in
        let {
          sat_sbUlr [Occ=Once]
            :: GHC.Base.Functor
                 (Control.Applicative.WrappedArrow a_XbS4O b_XbS8b)
          [LclId] =
              [$dArrow_sbUlq] \u []
                  Control.Applicative.$fFunctorWrappedArrow $dArrow_sbUlq;
        } in 
          GHC.Base.C:Applicative [sat_sbUlr
                                  sat_sbUls
                                  sat_sbUlt
                                  sat_sbUlu
                                  sat_sbUlv
                                  sat_sbUlw];

Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative
  :: forall (a :: * -> * -> *) b.
     (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
     GHC.Base.Applicative (Control.Applicative.WrappedArrow a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)><L,A>m,
 Unf=OtherCon []] =
    [] \r [$dArrowZero_sbUlx $dArrowPlus_sbUly]
        let {
          sat_sbUlz [Occ=Once, Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
            :: Control.Arrow.Arrow a_XbS4i
          [LclId] =
              [$dArrowZero_sbUlx] \u []
                  Control.Arrow.$p1ArrowZero $dArrowZero_sbUlx;
        } in  Control.Applicative.$fApplicativeWrappedArrow sat_sbUlz;

Control.Applicative.$fAlternativeWrappedArrow1
  :: forall b a. b -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sbUlA] [] [];

Control.Applicative.$fAlternativeWrappedArrow_$csome
  :: forall (a :: * -> * -> *) b.
     (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
     forall a1.
     Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b [a1]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)><L,U(A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowZero_sbUlB $dArrowPlus_sbUlC eta_sbUlD]
        let {
          some_v_sbUlE [Occ=LoopBreaker] :: a_XbS4l b_XbS4n [a1_abS1s]
          [LclId] =
              [$dArrowZero_sbUlB $dArrowPlus_sbUlC eta_sbUlD some_v_sbUlE] \u []
                  case
                      Control.Arrow.$p1ArrowZero $dArrowZero_sbUlB
                  of
                  $dApplicative_sbUlF [Dmd=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
                  { __DEFAULT ->
                        let {
                          sat_sbUlH [Occ=Once]
                            :: Control.Applicative.WrappedArrow a_XbS4l b_XbS4n [a1_abS1s]
                          [LclId] =
                              [$dArrowPlus_sbUlC some_v_sbUlE $dApplicative_sbUlF] \u []
                                  let {
                                    sat_sbUlG [Occ=Once] :: a_XbS4l b_XbS4n [a1_abS1s]
                                    [LclId] =
                                        [$dApplicative_sbUlF] \u []
                                            Control.Arrow.arr
                                                $dApplicative_sbUlF
                                                Control.Applicative.$fAlternativeWrappedArrow1;
                                  } in  Control.Arrow.<+> $dArrowPlus_sbUlC some_v_sbUlE sat_sbUlG;
                        } in 
                          Control.Applicative.$fAlternativeWrappedArrow2
                              $dApplicative_sbUlF GHC.Types.: eta_sbUlD sat_sbUlH;
                  };
        } in  some_v_sbUlE;

Control.Applicative.$fAlternativeWrappedArrow_$cmany
  :: forall (a :: * -> * -> *) b.
     (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
     forall a1.
     Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b [a1]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)><S(LC(C(S))),U(A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowZero_sbUlI $dArrowPlus_sbUlJ eta_sbUlK]
        let {
          many_v_sbUlL [Occ=LoopBreaker] :: a_XbS4k b_XbS4m [a1_abS1A]
          [LclId] =
              [$dArrowZero_sbUlI $dArrowPlus_sbUlJ eta_sbUlK many_v_sbUlL] \u []
                  let {
                    $dApplicative_sbUlM [Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
                      :: Control.Arrow.Arrow a_XbS4k
                    [LclId] =
                        [$dArrowZero_sbUlI] \u []
                            Control.Arrow.$p1ArrowZero $dArrowZero_sbUlI; } in
                  let {
                    sat_sbUlO [Occ=Once] :: a_XbS4k b_XbS4m [a1_abS1A]
                    [LclId] =
                        [$dApplicative_sbUlM] \u []
                            Control.Arrow.arr
                                $dApplicative_sbUlM
                                Control.Applicative.$fAlternativeWrappedArrow1; } in
                  let {
                    sat_sbUlN [Occ=Once] :: a_XbS4k b_XbS4m [a1_abS1A]
                    [LclId] =
                        [eta_sbUlK many_v_sbUlL $dApplicative_sbUlM] \u []
                            Control.Applicative.$fAlternativeWrappedArrow2
                                $dApplicative_sbUlM GHC.Types.: eta_sbUlK many_v_sbUlL;
                  } in  Control.Arrow.<+> $dArrowPlus_sbUlJ sat_sbUlN sat_sbUlO;
        } in  many_v_sbUlL;

Control.Applicative.$fAlternativeWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b.
     (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
     GHC.Base.Alternative (Control.Applicative.WrappedArrow a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),1*U)><L,U(A,C(C1(U)))>m] =
    [] \r [$dArrowZero_sbUlP $dArrowPlus_sbUlQ]
        let {
          sat_sbUlX [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
               -> Control.Applicative.WrappedArrow a_XbS4j b_XbS4l [a]
          [LclId] =
              [$dArrowZero_sbUlP $dArrowPlus_sbUlQ] \r [eta_B1]
                  Control.Applicative.$fAlternativeWrappedArrow_$cmany
                      $dArrowZero_sbUlP $dArrowPlus_sbUlQ eta_B1; } in
        let {
          sat_sbUlW [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
               -> Control.Applicative.WrappedArrow a_XbS4j b_XbS4l [a]
          [LclId] =
              [$dArrowZero_sbUlP $dArrowPlus_sbUlQ] \r [eta_B1]
                  Control.Applicative.$fAlternativeWrappedArrow_$csome
                      $dArrowZero_sbUlP $dArrowPlus_sbUlQ eta_B1; } in
        let {
          sat_sbUlV [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
               -> Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
               -> Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
          [LclId] =
              [$dArrowPlus_sbUlQ] \r [ds_sbUlT ds1_sbUlU]
                  Control.Arrow.<+> $dArrowPlus_sbUlQ ds_sbUlT ds1_sbUlU; } in
        let {
          sat_sbUlS [Occ=Once]
            :: forall a. Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
          [LclId] =
              [$dArrowZero_sbUlP] \u []
                  Control.Arrow.zeroArrow $dArrowZero_sbUlP; } in
        let {
          sat_sbUlR [Occ=Once]
            :: GHC.Base.Applicative
                 (Control.Applicative.WrappedArrow a_XbS4j b_XbS4l)
          [LclId] =
              [$dArrowZero_sbUlP $dArrowPlus_sbUlQ] \u []
                  Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative
                      $dArrowZero_sbUlP $dArrowPlus_sbUlQ;
        } in 
          GHC.Base.C:Alternative [sat_sbUlR
                                  sat_sbUlS
                                  sat_sbUlV
                                  sat_sbUlW
                                  sat_sbUlX];

Control.Applicative.$wunsafeDrop [InlPrag=NOUSERINLINE[0],
                                  Occ=LoopBreaker]
  :: forall a1. GHC.Prim.Int# -> [a1] -> [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_sbUlY w_sbUlZ]
        case w_sbUlZ of {
          [] -> [] [];
          : _ [Occ=Dead] ipv2_sbUm2 [Occ=Once*] ->
              case ww_sbUlY of ds3_sbUm3 {
                __DEFAULT ->
                    case -# [ds3_sbUm3 1#] of sat_sbUm4 {
                      __DEFAULT -> Control.Applicative.$wunsafeDrop sat_sbUm4 ipv2_sbUm2;
                    };
                1# -> ipv2_sbUm2;
              };
        };

Control.Applicative.$fAlternativeZipList2
  :: forall a.
     Control.Applicative.ZipList a
     -> Control.Applicative.ZipList a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbUm5 ds1_sbUm6]
        let {
          sat_sbUm9 [Occ=Once, Dmd=<L,1*U>] :: [a_abRZs]
          [LclId] =
              [ds_sbUm5 ds1_sbUm6] \s []
                  case GHC.List.$wlenAcc ds_sbUm5 0# of ww2_sbUm7 {
                    __DEFAULT ->
                        case <=# [ww2_sbUm7 0#] of {
                          __DEFAULT -> Control.Applicative.$wunsafeDrop ww2_sbUm7 ds1_sbUm6;
                          1# -> ds1_sbUm6;
                        };
                  };
        } in  GHC.Base.++ ds_sbUm5 sat_sbUm9;

Control.Applicative.$fGeneric1ZipList1
  :: forall a.
     GHC.Generics.Rep1 Control.Applicative.ZipList a
     -> GHC.Generics.Rep1 Control.Applicative.ZipList a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbUma] ds_sbUma;

Control.Applicative.$fGeneric1ZipList2
  :: forall a.
     Control.Applicative.ZipList a -> Control.Applicative.ZipList a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sbUmb] x_sbUmb;

Control.Applicative.$fGeneric1ZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Control.Applicative.ZipList
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Control.Applicative.$fGeneric1ZipList2
                                            Control.Applicative.$fGeneric1ZipList1];

Control.Applicative.$fGenericZipList1
  :: forall a x.
     GHC.Generics.Rep (Control.Applicative.ZipList a) x
     -> GHC.Generics.Rep (Control.Applicative.ZipList a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbUmc] ds_sbUmc;

Control.Applicative.$fGenericZipList2
  :: forall a x.
     Control.Applicative.ZipList a -> Control.Applicative.ZipList a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sbUmd] x1_sbUmd;

Control.Applicative.$fGenericZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Control.Applicative.ZipList a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Control.Applicative.$fGenericZipList2
                                           Control.Applicative.$fGenericZipList1];

Control.Applicative.$fFoldableZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Control.Applicative.ZipList
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableNonEmpty_$cfold1
                                             Data.Foldable.$fFoldable[]_$cfoldMap
                                             GHC.Base.foldr
                                             Data.Foldable.$fFoldable[]_$cfoldr'
                                             GHC.List.foldl
                                             GHC.List.foldl'
                                             GHC.List.foldr1
                                             GHC.List.foldl1
                                             GHC.Base.id
                                             GHC.List.null
                                             GHC.List.length
                                             GHC.List.elem
                                             GHC.List.maximum
                                             GHC.List.minimum
                                             GHC.List.sum
                                             GHC.List.product];

Control.Applicative.$fFunctorZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Control.Applicative.ZipList
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.map
                                       GHC.Base.$fFunctor[]_$c<$];

Control.Applicative.$fApplicativeZipList6 [Occ=LoopBreaker]
  :: forall a b. [a -> b] -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbUme ds1_sbUmf]
        case ds_sbUme of {
          [] -> [] [];
          : ipv_sbUmh [Occ=Once!] ipv1_sbUmi [Occ=Once] ->
              case ds1_sbUmf of {
                [] -> [] [];
                : ipv2_sbUmk [Occ=Once] ipv3_sbUml [Occ=Once] ->
                    let {
                      sat_sbUmn [Occ=Once] :: [b_abS0e]
                      [LclId] =
                          [ipv1_sbUmi ipv3_sbUml] \u []
                              Control.Applicative.$fApplicativeZipList6
                                  ipv1_sbUmi ipv3_sbUml; } in
                    let {
                      sat_sbUmm [Occ=Once] :: b_abS0e
                      [LclId] =
                          [ipv_sbUmh ipv2_sbUmk] \u [] ipv_sbUmh ipv2_sbUmk;
                    } in  : [sat_sbUmm sat_sbUmn];
              };
        };

Control.Applicative.$fApplicativeZipList5
  :: forall a b.
     Control.Applicative.ZipList (a -> b)
     -> Control.Applicative.ZipList a -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbUmo ds1_sbUmp]
        Control.Applicative.$fApplicativeZipList6 ds_sbUmo ds1_sbUmp;

Control.Applicative.$fApplicativeZipList4 [Occ=LoopBreaker]
  :: forall a b. [a] -> [b] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbUmq eta_sbUmr]
        case ds_sbUmq of {
          [] -> [] [];
          : _ [Occ=Dead] ys_sbUmu [Occ=Once] ->
              case eta_sbUmr of {
                [] -> [] [];
                : y1_sbUmw [Occ=Once] ys1_sbUmx [Occ=Once] ->
                    let {
                      sat_sbUmy [Occ=Once] :: [b_abS0z]
                      [LclId] =
                          [ys_sbUmu ys1_sbUmx] \u []
                              Control.Applicative.$fApplicativeZipList4 ys_sbUmu ys1_sbUmx;
                    } in  : [y1_sbUmw sat_sbUmy];
              };
        };

Control.Applicative.$fApplicativeZipList3
  :: forall a b.
     Control.Applicative.ZipList a
     -> Control.Applicative.ZipList b -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_sbUmz a2_sbUmA]
        Control.Applicative.$fApplicativeZipList4 a1_sbUmz a2_sbUmA;

Control.Applicative.$fApplicativeZipList2 [Occ=LoopBreaker]
  :: forall b a. [a] -> [b] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbUmB ds1_sbUmC]
        case ds_sbUmB of {
          [] -> [] [];
          : ipv_sbUmE [Occ=Once] ipv1_sbUmF [Occ=Once] ->
              case ds1_sbUmC of {
                [] -> [] [];
                : _ [Occ=Dead] ipv3_sbUmI [Occ=Once] ->
                    let {
                      sat_sbUmJ [Occ=Once] :: [a_abS0I]
                      [LclId] =
                          [ipv1_sbUmF ipv3_sbUmI] \u []
                              Control.Applicative.$fApplicativeZipList2 ipv1_sbUmF ipv3_sbUmI;
                    } in  : [ipv_sbUmE sat_sbUmJ];
              };
        };

Control.Applicative.$fApplicativeZipList1
  :: forall b a.
     Control.Applicative.ZipList a
     -> Control.Applicative.ZipList b -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbUmK ds1_sbUmL]
        Control.Applicative.$fApplicativeZipList2 ds_sbUmK ds1_sbUmL;

Control.Applicative.$fApplicativeZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Control.Applicative.ZipList
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Control.Applicative.$fFunctorZipList
                                           GHC.List.repeat
                                           Control.Applicative.$fApplicativeZipList5
                                           GHC.List.zipWith
                                           Control.Applicative.$fApplicativeZipList3
                                           Control.Applicative.$fApplicativeZipList1];

Control.Applicative.$fAlternativeZipList_xs [Occ=LoopBreaker]
  :: forall a. [[a]]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Types.[]
                      Control.Applicative.$fAlternativeZipList_xs];

Control.Applicative.$fAlternativeZipList1 [Occ=LoopBreaker]
  :: forall a. [a] -> [[a]] -> [[a]]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbUmM ds1_sbUmN]
        case ds_sbUmM of {
          [] -> [] [];
          : ipv_sbUmP [Occ=Once] ipv1_sbUmQ [Occ=Once] ->
              case ds1_sbUmN of {
                [] -> [] [];
                : ipv2_sbUmS [Occ=Once] ipv3_sbUmT [Occ=Once] ->
                    let {
                      sat_sbUmV [Occ=Once] :: [[a_abRZG]]
                      [LclId] =
                          [ipv1_sbUmQ ipv3_sbUmT] \u []
                              Control.Applicative.$fAlternativeZipList1
                                  ipv1_sbUmQ ipv3_sbUmT; } in
                    let {
                      sat_sbUmU [Occ=Once] :: [a_abRZG]
                      [LclId] =
                          CCCS :! [ipv_sbUmP ipv2_sbUmS];
                    } in  : [sat_sbUmU sat_sbUmV];
              };
        };

Control.Applicative.$fAlternativeZipList_$csome
  :: forall a.
     Control.Applicative.ZipList a -> Control.Applicative.ZipList [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sbUmW]
        let {
          some_v_sbUmX [Occ=LoopBreaker] :: [[a_abRZG]]
          [LclId] =
              [v_sbUmW some_v_sbUmX] \u []
                  let {
                    sat_sbUmY [Occ=Once, Dmd=<L,1*U>] :: [[a_abRZG]]
                    [LclId] =
                        [some_v_sbUmX] \s []
                            Control.Applicative.$fAlternativeZipList2
                                some_v_sbUmX Control.Applicative.$fAlternativeZipList_xs;
                  } in  Control.Applicative.$fAlternativeZipList1 v_sbUmW sat_sbUmY;
        } in  some_v_sbUmX;

Control.Applicative.$fAlternativeZipList_$cmany
  :: forall a.
     Control.Applicative.ZipList a -> Control.Applicative.ZipList [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sbUmZ]
        let {
          many_v_sbUn0 [Occ=LoopBreaker] :: [[a_abRZO]]
          [LclId] =
              [v_sbUmZ many_v_sbUn0] \u []
                  case
                      Control.Applicative.$fAlternativeZipList1 v_sbUmZ many_v_sbUn0
                  of
                  sat_sbUn1
                  { __DEFAULT ->
                        Control.Applicative.$fAlternativeZipList2
                            sat_sbUn1 Control.Applicative.$fAlternativeZipList_xs;
                  };
        } in  many_v_sbUn0;

Control.Applicative.$fAlternativeZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Control.Applicative.ZipList
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Control.Applicative.$fApplicativeZipList
                                           GHC.Types.[]
                                           Control.Applicative.$fAlternativeZipList2
                                           Control.Applicative.$fAlternativeZipList_$csome
                                           Control.Applicative.$fAlternativeZipList_$cmany];

Control.Applicative.$fReadZipList11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ZipList"#;

Control.Applicative.$fReadZipList10 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Control.Applicative.$fReadZipList11;

Control.Applicative.$fReadZipList_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Control.Applicative.$fReadZipList10];

Control.Applicative.$fReadZipList9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "{"#;

Control.Applicative.$fReadZipList8 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Control.Applicative.$fReadZipList9;

Control.Applicative.$fReadZipList_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Control.Applicative.$fReadZipList8];

Control.Applicative.$fReadZipList7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getZipList"#;

Control.Applicative.$fReadZipList6 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Control.Applicative.$fReadZipList7;

Control.Applicative.$fReadZipList5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Control.Applicative.$fReadZipList4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "}"#;

Control.Applicative.$fReadZipList3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Control.Applicative.$fReadZipList4;

Control.Applicative.$fReadZipList2 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Control.Applicative.$fReadZipList3];

Control.Applicative.$fReadZipList1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Control.Applicative.ZipList a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,A,1*C1(U))>, Unf=OtherCon []] =
    [] \r [$dRead_sbUn2]
        let {
          lvl_sbUn3 [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP [a_abRO3]
          [LclId] =
              [$dRead_sbUn2] \u []
                  GHC.Read.readListPrec
                      $dRead_sbUn2 Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sbUn4 [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP [a_abRO3]
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl_sbUn3] \r [ds1_sbUn5] lvl_sbUn3; } in
        let {
          sat_sbUnp [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Control.Applicative.ZipList a_abRO3)
          [LclId] =
              [ds_sbUn4] \r [c_sbUn6 eta_sbUn7]
                  case c_sbUn6 of {
                    GHC.Types.I# x_sbUn9 [Occ=Once] ->
                        case <=# [x_sbUn9 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sbUnm [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sbUn4 eta_sbUn7] \r [a1_sbUnb]
                                        let {
                                          sat_sbUnj [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sbUn4 eta_sbUn7] \r [a2_sbUnc]
                                                  let {
                                                    sat_sbUni [Occ=Once]
                                                      :: [a_abRO3]
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sbUn7] \r [a3_sbUnd]
                                                            let {
                                                              sat_sbUnf [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sbUn7 a3_sbUnd] \r [a4_sbUne]
                                                                      eta_sbUn7 a3_sbUnd;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Control.Applicative.$fReadZipList2
                                                                      sat_sbUnf
                                                              of
                                                              { Unit# ww1_sbUnh [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sbUnh];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Control.Applicative.$fReadZipList6
                                                        ds_sbUn4
                                                        Control.Applicative.$fReadZipList5
                                                        sat_sbUni;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Control.Applicative.$fReadZipList_lexeme sat_sbUnj
                                          of
                                          { Unit# ww1_sbUnl [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sbUnl];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Control.Applicative.$fReadZipList_lexeme1 sat_sbUnm
                                of
                                { Unit# ww1_sbUno [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sbUno];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sbUnp;

Control.Applicative.$fReadZipList_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Control.Applicative.ZipList a)
[GblId, Arity=1, Str=<L,1*U(A,A,A,1*C1(U))>, Unf=OtherCon []] =
    [] \r [$dRead_sbUnq]
        let {
          ds_sbUnr [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Control.Applicative.ZipList a_XbRSJ
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sbUnq] \u []
                  Control.Applicative.$fReadZipList1 $dRead_sbUnq; } in
        let {
          sat_sbUnu [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Control.Applicative.ZipList a_XbRSJ)
          [LclId] =
              [ds_sbUnr] \r [n_sbUns]
                  let {
                    sat_sbUnt [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Control.Applicative.ZipList a_XbRSJ)
                    [LclId] =
                        [ds_sbUnr n_sbUns] \u []
                            ds_sbUnr
                                n_sbUns Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sbUnt;
        } in  sat_sbUnu;

Control.Applicative.$fReadZipList_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Control.Applicative.ZipList a]
[GblId, Arity=1, Str=<L,1*U(A,A,A,1*C1(U))>, Unf=OtherCon []] =
    [] \r [$dRead_sbUnv]
        let {
          sat_sbUnw [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Control.Applicative.ZipList a_XbRSH)
          [LclId] =
              [$dRead_sbUnv] \s []
                  Control.Applicative.$fReadZipList1 $dRead_sbUnv;
        } in  GHC.Read.list sat_sbUnw;

Control.Applicative.$fReadZipList_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Control.Applicative.ZipList a]
[GblId, Arity=1, Str=<L,1*U(A,A,A,1*C1(U))>, Unf=OtherCon []] =
    [] \r [$dRead_sbUnx]
        let {
          sat_sbUnz [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Control.Applicative.ZipList a_XbRSI]
          [LclId] =
              [$dRead_sbUnx] \u []
                  let {
                    sat_sbUny [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Control.Applicative.ZipList a_XbRSI)
                    [LclId] =
                        [$dRead_sbUnx] \s []
                            Control.Applicative.$fReadZipList1 $dRead_sbUnx;
                  } in 
                    GHC.Read.list
                        sat_sbUny
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sbUnz;

Control.Applicative.$fReadZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Control.Applicative.ZipList a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,C(U))>m] =
    [] \r [$dRead_sbUnA]
        let {
          sat_sbUnE [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Control.Applicative.ZipList a_XbRSG]
          [LclId] =
              [$dRead_sbUnA] \u []
                  Control.Applicative.$fReadZipList_$creadListPrec $dRead_sbUnA; } in
        let {
          sat_sbUnD [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Control.Applicative.ZipList a_XbRSG)
          [LclId] =
              [$dRead_sbUnA] \u []
                  Control.Applicative.$fReadZipList1 $dRead_sbUnA; } in
        let {
          sat_sbUnC [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Control.Applicative.ZipList a_XbRSG]
          [LclId] =
              [$dRead_sbUnA] \u []
                  Control.Applicative.$fReadZipList_$creadList $dRead_sbUnA; } in
        let {
          sat_sbUnB [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Control.Applicative.ZipList a_XbRSG)
          [LclId] =
              [$dRead_sbUnA] \u []
                  Control.Applicative.$fReadZipList_$creadsPrec $dRead_sbUnA;
        } in  GHC.Read.C:Read [sat_sbUnB sat_sbUnC sat_sbUnD sat_sbUnE];

Control.Applicative.$fEqZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Control.Applicative.ZipList a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sbUnF]
        let {
          sat_sbUnH [Occ=Once]
            :: Control.Applicative.ZipList a_abRLG
               -> Control.Applicative.ZipList a_abRLG -> GHC.Types.Bool
          [LclId] =
              [$dEq_sbUnF] \r [eta_B2 eta_B1]
                  GHC.Classes.$fEq[]_$c/= $dEq_sbUnF eta_B2 eta_B1; } in
        let {
          sat_sbUnG [Occ=Once]
            :: Control.Applicative.ZipList a_abRLG
               -> Control.Applicative.ZipList a_abRLG -> GHC.Types.Bool
          [LclId] =
              [$dEq_sbUnF] \r [eta_B2 eta_B1]
                  GHC.Classes.$fEq[]_$c== $dEq_sbUnF eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sbUnG sat_sbUnH];

Control.Applicative.$fOrdZipList_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Control.Applicative.ZipList a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sbUnI]
        let {
          sat_sbUnJ [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_abRMe
          [LclId] =
              [$dOrd_sbUnI] \u [] GHC.Classes.$p1Ord $dOrd_sbUnI;
        } in  Control.Applicative.$fEqZipList sat_sbUnJ;

Control.Applicative.$fOrdZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Control.Applicative.ZipList a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_sbUnK]
        let {
          sat_sbUnS [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe
          [LclId] =
              [$dOrd_sbUnK] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$cmin $dOrd_sbUnK eta_B2 eta_B1; } in
        let {
          sat_sbUnR [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe
          [LclId] =
              [$dOrd_sbUnK] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$cmax $dOrd_sbUnK eta_B2 eta_B1; } in
        let {
          sat_sbUnQ [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbUnK] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$c>= $dOrd_sbUnK eta_B2 eta_B1; } in
        let {
          sat_sbUnP [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbUnK] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$c> $dOrd_sbUnK eta_B2 eta_B1; } in
        let {
          sat_sbUnO [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbUnK] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$c<= $dOrd_sbUnK eta_B2 eta_B1; } in
        let {
          sat_sbUnN [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbUnK] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$c< $dOrd_sbUnK eta_B2 eta_B1; } in
        let {
          sat_sbUnM [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sbUnK] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$ccompare $dOrd_sbUnK eta_B2 eta_B1; } in
        let {
          sat_sbUnL [Occ=Once]
            :: GHC.Classes.Eq (Control.Applicative.ZipList a_abRMe)
          [LclId] =
              [$dOrd_sbUnK] \u []
                  Control.Applicative.$fOrdZipList_$cp1Ord $dOrd_sbUnK;
        } in 
          GHC.Classes.C:Ord [sat_sbUnL
                             sat_sbUnM
                             sat_sbUnN
                             sat_sbUnO
                             sat_sbUnP
                             sat_sbUnQ
                             sat_sbUnR
                             sat_sbUnS];

Control.Applicative.$fShowZipList3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ZipList {"#;

Control.Applicative.$fShowZipList2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getZipList = "#;

Control.Applicative.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Control.Applicative.ZipList a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C(U)))><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbUnT ww_sbUnU w1_sbUnV]
        let {
          f_sbUnW [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sbUnT w1_sbUnV] \u [] GHC.Show.showList w_sbUnT w1_sbUnV;
        } in 
          case >=# [ww_sbUnU 11#] of {
            __DEFAULT ->
                let {
                  sat_sbUo2 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sbUnW] \r [x_sbUnY]
                          let {
                            sat_sbUo1 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sbUnW x_sbUnY] \u []
                                    let {
                                      sat_sbUo0 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sbUnW x_sbUnY] \u []
                                              let {
                                                sat_sbUnZ [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sbUnY] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Control.Applicative.$fReadZipList4
                                                            x_sbUnY;
                                              } in  f_sbUnW sat_sbUnZ;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Control.Applicative.$fShowZipList2 sat_sbUo0;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Control.Applicative.$fShowZipList3 sat_sbUo1;
                } in  sat_sbUo2;
            1# ->
                let {
                  sat_sbUo9 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sbUnW] \r [x_sbUo3]
                          let {
                            sat_sbUo8 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sbUnW x_sbUo3] \u []
                                    let {
                                      sat_sbUo7 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sbUnW x_sbUo3] \u []
                                              let {
                                                sat_sbUo6 [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sbUnW x_sbUo3] \u []
                                                        let {
                                                          sat_sbUo5 [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sbUo3] \u []
                                                                  let {
                                                                    sat_sbUo4 [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sbUo3];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Control.Applicative.$fReadZipList4
                                                                        sat_sbUo4;
                                                        } in  f_sbUnW sat_sbUo5;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Control.Applicative.$fShowZipList2 sat_sbUo6;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Control.Applicative.$fShowZipList3 sat_sbUo7;
                          } in  : [GHC.Show.$fShow(,)4 sat_sbUo8];
                } in  sat_sbUo9;
          };

Control.Applicative.$fShowZipList_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Control.Applicative.ZipList a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C(U)))><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbUoa w1_sbUob w2_sbUoc]
        case w1_sbUob of {
          GHC.Types.I# ww1_sbUoe [Occ=Once] ->
              Control.Applicative.$w$cshowsPrec w_sbUoa ww1_sbUoe w2_sbUoc;
        };

Control.Applicative.$fShowZipList_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Control.Applicative.ZipList a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C1(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sbUof x_sbUog]
        let {
          sat_sbUoi [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sbUof x_sbUog] \u []
                  let {
                    sat_sbUoh [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sbUof x_sbUog] \u []
                            GHC.Show.showList
                                $dShow_sbUof x_sbUog Control.Applicative.$fReadZipList3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Control.Applicative.$fShowZipList2 sat_sbUoh;
        } in 
          GHC.CString.unpackAppendCString#
              Control.Applicative.$fShowZipList3 sat_sbUoi;

Control.Applicative.$fShowZipList1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Control.Applicative.$fShowZipList_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Control.Applicative.ZipList a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sbUoj ls_sbUok s_sbUol]
        let {
          sat_sbUon [Occ=Once]
            :: Control.Applicative.ZipList a_abRLb -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbUoj] \r [w_sbUom]
                  Control.Applicative.$w$cshowsPrec $dShow_sbUoj 0# w_sbUom;
        } in  GHC.Show.showList__ sat_sbUon ls_sbUok s_sbUol;

Control.Applicative.$fShowZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Control.Applicative.ZipList a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C(U)))>m] =
    [] \r [$dShow_sbUoo]
        let {
          sat_sbUor [Occ=Once]
            :: [Control.Applicative.ZipList a_abRLb] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbUoo] \r [eta_B2 eta_B1]
                  Control.Applicative.$fShowZipList_$cshowList
                      $dShow_sbUoo eta_B2 eta_B1; } in
        let {
          sat_sbUoq [Occ=Once]
            :: Control.Applicative.ZipList a_abRLb -> GHC.Base.String
          [LclId] =
              [$dShow_sbUoo] \r [eta_B1]
                  Control.Applicative.$fShowZipList_$cshow $dShow_sbUoo eta_B1; } in
        let {
          sat_sbUop [Occ=Once]
            :: GHC.Types.Int
               -> Control.Applicative.ZipList a_abRLb -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbUoo] \r [eta_B2 eta_B1]
                  Control.Applicative.$fShowZipList_$cshowsPrec
                      $dShow_sbUoo eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sbUop sat_sbUoq sat_sbUor];

Control.Applicative.$fGeneric1WrappedArrow1
  :: forall (a1 :: * -> * -> *) b a2.
     GHC.Generics.Rep1 (Control.Applicative.WrappedArrow a1 b) a2
     -> GHC.Generics.Rep1 (Control.Applicative.WrappedArrow a1 b) a2
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbUos] ds_sbUos;

Control.Applicative.$fGeneric1WrappedArrow2
  :: forall (a1 :: * -> * -> *) b a2.
     Control.Applicative.WrappedArrow a1 b a2
     -> Control.Applicative.WrappedArrow a1 b a2
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sbUot] x_sbUot;

Control.Applicative.$fGeneric1WrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b.
     GHC.Generics.Generic1 (Control.Applicative.WrappedArrow a b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Control.Applicative.$fGeneric1WrappedArrow2
                                            Control.Applicative.$fGeneric1WrappedArrow1];

Control.Applicative.$fGenericWrappedArrow1
  :: forall (a :: * -> * -> *) b c x.
     GHC.Generics.Rep (Control.Applicative.WrappedArrow a b c) x
     -> GHC.Generics.Rep (Control.Applicative.WrappedArrow a b c) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbUou] ds_sbUou;

Control.Applicative.$fGenericWrappedArrow2
  :: forall (a :: * -> * -> *) b c x.
     Control.Applicative.WrappedArrow a b c
     -> Control.Applicative.WrappedArrow a b c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sbUov] x1_sbUov;

Control.Applicative.$fGenericWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b c.
     GHC.Generics.Generic (Control.Applicative.WrappedArrow a b c)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Control.Applicative.$fGenericWrappedArrow2
                                           Control.Applicative.$fGenericWrappedArrow1];

Control.Applicative.$fMonadWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     GHC.Base.Monad (Control.Applicative.WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(U),A,A,A,A),U,1*U,U,1*U)>m] =
    [] \r [$dMonad_sbUow]
        let {
          sat_sbUoB [Occ=Once]
            :: forall a.
               GHC.Base.String -> Control.Applicative.WrappedMonad m_abRHy a
          [LclId] =
              [$dMonad_sbUow] \u [] GHC.Base.fail $dMonad_sbUow; } in
        let {
          sat_sbUoA [Occ=Once]
            :: forall a. a -> Control.Applicative.WrappedMonad m_abRHy a
          [LclId] =
              [$dMonad_sbUow] \u [] GHC.Base.return $dMonad_sbUow; } in
        let {
          sat_sbUoz [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_abRHy a
               -> Control.Applicative.WrappedMonad m_abRHy b
               -> Control.Applicative.WrappedMonad m_abRHy b
          [LclId] =
              [$dMonad_sbUow] \u [] GHC.Base.>> $dMonad_sbUow; } in
        let {
          sat_sbUoy [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_abRHy a
               -> (a -> Control.Applicative.WrappedMonad m_abRHy b)
               -> Control.Applicative.WrappedMonad m_abRHy b
          [LclId] =
              [$dMonad_sbUow] \u [] GHC.Base.>>= $dMonad_sbUow; } in
        let {
          sat_sbUox [Occ=Once]
            :: GHC.Base.Applicative (Control.Applicative.WrappedMonad m_abRHy)
          [LclId] =
              [$dMonad_sbUow] \u []
                  Control.Applicative.$fApplicativeWrappedMonad $dMonad_sbUow;
        } in 
          GHC.Base.C:Monad [sat_sbUox
                            sat_sbUoy
                            sat_sbUoz
                            sat_sbUoA
                            sat_sbUoB];

Control.Applicative.$fGeneric1WrappedMonad1
  :: forall (m :: * -> *) a.
     GHC.Generics.Rep1 (Control.Applicative.WrappedMonad m) a
     -> GHC.Generics.Rep1 (Control.Applicative.WrappedMonad m) a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbUoC] ds_sbUoC;

Control.Applicative.$fGeneric1WrappedMonad2
  :: forall (m :: * -> *) a.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sbUoD] x_sbUoD;

Control.Applicative.$fGeneric1WrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Generics.Generic1 (Control.Applicative.WrappedMonad m)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Control.Applicative.$fGeneric1WrappedMonad2
                                            Control.Applicative.$fGeneric1WrappedMonad1];

Control.Applicative.$fGenericWrappedMonad1
  :: forall (m :: * -> *) a x.
     GHC.Generics.Rep (Control.Applicative.WrappedMonad m a) x
     -> GHC.Generics.Rep (Control.Applicative.WrappedMonad m a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbUoE] ds_sbUoE;

Control.Applicative.$fGenericWrappedMonad2
  :: forall (m :: * -> *) a x.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sbUoF] x1_sbUoF;

Control.Applicative.$fGenericWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *) a.
     GHC.Generics.Generic (Control.Applicative.WrappedMonad m a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Control.Applicative.$fGenericWrappedMonad2
                                           Control.Applicative.$fGenericWrappedMonad1];

Control.Applicative.unwrapMonad
  :: forall (m :: * -> *) a.
     Control.Applicative.WrappedMonad m a -> m a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Control.Applicative.$fGeneric1WrappedMonad2 eta_B1;

Control.Applicative.unwrapArrow
  :: forall (a :: * -> * -> *) b c.
     Control.Applicative.WrappedArrow a b c -> a b c
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Control.Applicative.$fGeneric1WrappedArrow2 eta_B1;

Control.Applicative.getZipList
  :: forall a. Control.Applicative.ZipList a -> [a]
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Control.Applicative.$fGeneric1ZipList2 eta_B1;

Control.Applicative.optional
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     f a -> f (GHC.Base.Maybe a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LL),U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,1*C1(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sbUoG eta_sbUoH]
        let {
          $dApplicative_sbUoI [Dmd=<L,U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)>]
            :: GHC.Base.Applicative f_abRFg
          [LclId] =
              [$dAlternative_sbUoG] \u []
                  GHC.Base.$p1Alternative $dAlternative_sbUoG; } in
        let {
          sat_sbUoL [Occ=Once] :: f_abRFg (GHC.Base.Maybe a_abRFh)
          [LclId] =
              [$dApplicative_sbUoI] \u []
                  GHC.Base.pure $dApplicative_sbUoI GHC.Base.Nothing; } in
        let {
          sat_sbUoK [Occ=Once] :: f_abRFg (GHC.Base.Maybe a_abRFh)
          [LclId] =
              [eta_sbUoH $dApplicative_sbUoI] \u []
                  case GHC.Base.$p1Applicative $dApplicative_sbUoI of sat_sbUoJ {
                    __DEFAULT -> GHC.Base.fmap sat_sbUoJ GHC.Base.Just eta_sbUoH;
                  };
        } in  GHC.Base.<|> $dAlternative_sbUoG sat_sbUoK sat_sbUoL;

Control.Applicative.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Control.Applicative.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$trModule4];

Control.Applicative.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Control.Applicative"#;

Control.Applicative.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$trModule2];

Control.Applicative.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Control.Applicative.$trModule3
                                     Control.Applicative.$trModule1];

Control.Applicative.$tcWrappedMonad1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         GHC.Types.krep$*Arr*];

Control.Applicative.$tcWrappedArrow1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         GHC.Types.krep$*->*->*];

$krep_rbSvt :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep1_rbSvu :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep2_rbSvv :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep3_rbSvw :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rbSvv GHC.Types.[]];

$krep4_rbSvx :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc[]
                                              $krep3_rbSvw];

$krep5_rbSvy :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep2_rbSvv $krep1_rbSvu];

$krep6_rbSvz :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep5_rbSvy $krep_rbSvt];

Control.Applicative.$tcWrappedMonad3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrappedMonad"#;

Control.Applicative.$tcWrappedMonad2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tcWrappedMonad3];

Control.Applicative.$tcWrappedMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12971590878300233698##
                                    12447260690856494251##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tcWrappedMonad2
                                    0#
                                    Control.Applicative.$tcWrappedMonad1];

$krep7_rbSvA :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rbSvu GHC.Types.[]];

$krep8_rbSvB :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rbSvv $krep7_rbSvA];

$krep9_rbSvC :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Applicative.$tcWrappedMonad
                                              $krep8_rbSvB];

Control.Applicative.$tc'WrapMonad1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_rbSvy $krep9_rbSvC];

Control.Applicative.$tc'WrapMonad3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'WrapMonad"#;

Control.Applicative.$tc'WrapMonad2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tc'WrapMonad3];

Control.Applicative.$tc'WrapMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10363415327661881286##
                                    6845751270384138997##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tc'WrapMonad2
                                    2#
                                    Control.Applicative.$tc'WrapMonad1];

Control.Applicative.$tcWrappedArrow3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrappedArrow"#;

Control.Applicative.$tcWrappedArrow2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tcWrappedArrow3];

Control.Applicative.$tcWrappedArrow :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17995829375472255965##
                                    6668242383287740398##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tcWrappedArrow2
                                    0#
                                    Control.Applicative.$tcWrappedArrow1];

$krep10_rbSvD :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rbSvt GHC.Types.[]];

$krep11_rbSvE :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rbSvu $krep10_rbSvD];

$krep12_rbSvF :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rbSvv $krep11_rbSvE];

$krep13_rbSvG :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Applicative.$tcWrappedArrow
                                              $krep12_rbSvF];

Control.Applicative.$tc'WrapArrow1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_rbSvz $krep13_rbSvG];

Control.Applicative.$tc'WrapArrow3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'WrapArrow"#;

Control.Applicative.$tc'WrapArrow2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tc'WrapArrow3];

Control.Applicative.$tc'WrapArrow :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4796259816778499037##
                                    13482613273239263357##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tc'WrapArrow2
                                    3#
                                    Control.Applicative.$tc'WrapArrow1];

Control.Applicative.$tcZipList1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$fReadZipList11];

Control.Applicative.$tcZipList :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11311650752326360483##
                                    5534599578149162946##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tcZipList1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep14_rbSvH :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Applicative.$tcZipList
                                              $krep3_rbSvw];

Control.Applicative.$tc'ZipList1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_rbSvx $krep14_rbSvH];

Control.Applicative.$tc'ZipList3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'ZipList"#;

Control.Applicative.$tc'ZipList2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tc'ZipList3];

Control.Applicative.$tc'ZipList :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15353069281551614305##
                                    7665927634319452478##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tc'ZipList2
                                    1#
                                    Control.Applicative.$tc'ZipList1];


==================== STG syntax: ====================
2018-03-16 16:06:48.292445213 UTC

Control.Applicative.$fFunctorWrappedMonad1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b. a -> Control.Applicative.WrappedMonad m b -> m a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbUjC x_sbUjD eta_sbUjE]
        let {
          lvl_sbUjF [Occ=OnceL] :: m_XbS7L a_abS5L
          [LclId] =
              [$dMonad_sbUjC x_sbUjD] \u []
                  GHC.Base.return $dMonad_sbUjC x_sbUjD; } in
        let {
          sat_sbUjH [Occ=Once] :: b_abS5M -> m_XbS7L a_abS5L
          [LclId] =
              [lvl_sbUjF] \r [x1_sbUjG] lvl_sbUjF;
        } in  GHC.Base.>>= $dMonad_sbUjC eta_sbUjE sat_sbUjH;

Control.Applicative.$fFunctorWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     GHC.Base.Functor (Control.Applicative.WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,C(U),A)>m] =
    [] \r [$dMonad_sbUjI]
        let {
          sat_sbUjM [Occ=Once]
            :: forall a b.
               a
               -> Control.Applicative.WrappedMonad m_XbS7K b
               -> Control.Applicative.WrappedMonad m_XbS7K a
          [LclId] =
              [$dMonad_sbUjI] \r [eta_B2 eta_B1]
                  Control.Applicative.$fFunctorWrappedMonad1
                      $dMonad_sbUjI eta_B2 eta_B1; } in
        let {
          sat_sbUjL [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Control.Applicative.WrappedMonad m_XbS7K a
               -> Control.Applicative.WrappedMonad m_XbS7K b
          [LclId] =
              [$dMonad_sbUjI] \r [f_sbUjJ ds_sbUjK]
                  GHC.Base.liftM $dMonad_sbUjI f_sbUjJ ds_sbUjK;
        } in  GHC.Base.C:Functor [sat_sbUjL sat_sbUjM];

Control.Applicative.$fApplicativeWrappedMonad3
  :: forall (m :: * -> *). GHC.Base.Monad m => forall a. a -> m a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbUjN eta_sbUjO]
        case GHC.Base.$p1Monad $dMonad_sbUjN of sat_sbUjP {
          __DEFAULT -> GHC.Base.pure sat_sbUjP eta_sbUjO;
        };

Control.Applicative.$fApplicativeWrappedMonad2
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m b -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbUjQ a1_sbUjR a2_sbUjS]
        let {
          sat_sbUjW [Occ=Once] :: m_XbS74 (b_abS5b -> b_abS5b)
          [LclId] =
              [$dMonad_sbUjQ a1_sbUjR] \u []
                  let {
                    lvl_sbUjT [Occ=OnceL] :: m_XbS74 (b_abS5b -> b_abS5b)
                    [LclId] =
                        [$dMonad_sbUjQ] \u []
                            GHC.Base.return $dMonad_sbUjQ GHC.Base.breakpoint; } in
                  let {
                    sat_sbUjV [Occ=Once] :: a_abS5a -> m_XbS74 (b_abS5b -> b_abS5b)
                    [LclId] =
                        [lvl_sbUjT] \r [x1_sbUjU] lvl_sbUjT;
                  } in  GHC.Base.>>= $dMonad_sbUjQ a1_sbUjR sat_sbUjV;
        } in  GHC.Base.ap $dMonad_sbUjQ sat_sbUjW a2_sbUjS;

Control.Applicative.$fApplicativeWrappedMonad1
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m b -> m a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbUjX ds_sbUjY ds1_sbUjZ]
        let {
          sat_sbUk4 [Occ=Once] :: a_abS5k -> m_XbS9j a_abS5k
          [LclId] =
              [$dMonad_sbUjX ds1_sbUjZ] \r [x1_sbUk0]
                  let {
                    lvl_sbUk1 [Occ=OnceL] :: m_XbS9j a_abS5k
                    [LclId] =
                        [$dMonad_sbUjX x1_sbUk0] \u []
                            GHC.Base.return $dMonad_sbUjX x1_sbUk0; } in
                  let {
                    sat_sbUk3 [Occ=Once] :: b_abS5l -> m_XbS9j a_abS5k
                    [LclId] =
                        [lvl_sbUk1] \r [x2_sbUk2] lvl_sbUk1;
                  } in  GHC.Base.>>= $dMonad_sbUjX ds1_sbUjZ sat_sbUk3;
        } in  GHC.Base.>>= $dMonad_sbUjX ds_sbUjY sat_sbUk4;

Control.Applicative.$fApplicativeWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     GHC.Base.Applicative (Control.Applicative.WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A)>m] =
    [] \r [$dMonad_sbUk5]
        let {
          sat_sbUkg [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_XbS6X a
               -> Control.Applicative.WrappedMonad m_XbS6X b
               -> Control.Applicative.WrappedMonad m_XbS6X a
          [LclId] =
              [$dMonad_sbUk5] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedMonad1
                      $dMonad_sbUk5 eta_B2 eta_B1; } in
        let {
          sat_sbUkf [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_XbS6X a
               -> Control.Applicative.WrappedMonad m_XbS6X b
               -> Control.Applicative.WrappedMonad m_XbS6X b
          [LclId] =
              [$dMonad_sbUk5] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedMonad2
                      $dMonad_sbUk5 eta_B2 eta_B1; } in
        let {
          sat_sbUke [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Control.Applicative.WrappedMonad m_XbS6X a
               -> Control.Applicative.WrappedMonad m_XbS6X b
               -> Control.Applicative.WrappedMonad m_XbS6X c
          [LclId] =
              [$dMonad_sbUk5] \r [f_sbUkb ds_sbUkc ds1_sbUkd]
                  GHC.Base.liftM2 $dMonad_sbUk5 f_sbUkb ds_sbUkc ds1_sbUkd; } in
        let {
          sat_sbUka [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_XbS6X (a -> b)
               -> Control.Applicative.WrappedMonad m_XbS6X a
               -> Control.Applicative.WrappedMonad m_XbS6X b
          [LclId] =
              [$dMonad_sbUk5] \r [ds_sbUk8 ds1_sbUk9]
                  GHC.Base.ap $dMonad_sbUk5 ds_sbUk8 ds1_sbUk9; } in
        let {
          sat_sbUk7 [Occ=Once]
            :: forall a. a -> Control.Applicative.WrappedMonad m_XbS6X a
          [LclId] =
              [$dMonad_sbUk5] \r [eta_B1]
                  Control.Applicative.$fApplicativeWrappedMonad3
                      $dMonad_sbUk5 eta_B1; } in
        let {
          sat_sbUk6 [Occ=Once]
            :: GHC.Base.Functor (Control.Applicative.WrappedMonad m_XbS6X)
          [LclId] =
              [$dMonad_sbUk5] \u []
                  Control.Applicative.$fFunctorWrappedMonad $dMonad_sbUk5;
        } in 
          GHC.Base.C:Applicative [sat_sbUk6
                                  sat_sbUk7
                                  sat_sbUka
                                  sat_sbUke
                                  sat_sbUkf
                                  sat_sbUkg];

Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Base.Applicative (Control.Applicative.WrappedMonad m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbUkh]
        let {
          sat_sbUki [Occ=Once,
                     Dmd=<L,U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A)>]
            :: GHC.Base.Monad m_XbS6t
          [LclId] =
              [$dMonadPlus_sbUkh] \u [] GHC.Base.$p2MonadPlus $dMonadPlus_sbUkh;
        } in  Control.Applicative.$fApplicativeWrappedMonad sat_sbUki;

Control.Applicative.$fAlternativeWrappedMonad_$csome
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall a.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbUkj eta_sbUkk]
        case
            GHC.Base.$p2MonadPlus $dMonadPlus_sbUkj
        of
        $dApplicative_sbUkl [Dmd=<S(LC(C(S))LLL),U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A)>]
        { __DEFAULT ->
              let {
                m2_sbUkm [Occ=OnceL] :: m_XbS6w [a_abS46]
                [LclId] =
                    [$dMonadPlus_sbUkj $dApplicative_sbUkl some_v_sbUkn] \u []
                        let {
                          sat_sbUkp [Occ=Once] :: m_XbS6w [a_abS46]
                          [LclId] =
                              [$dApplicative_sbUkl] \u []
                                  case GHC.Base.$p1Monad $dApplicative_sbUkl of sat_sbUko {
                                    __DEFAULT -> GHC.Base.pure sat_sbUko GHC.Types.[];
                                  };
                        } in  GHC.Base.mplus $dMonadPlus_sbUkj some_v_sbUkn sat_sbUkp;
                some_v_sbUkn [Occ=LoopBreaker] :: m_XbS6w [a_abS46]
                [LclId] =
                    [eta_sbUkk $dApplicative_sbUkl m2_sbUkm] \u []
                        let {
                          sat_sbUku [Occ=Once] :: a_abS46 -> m_XbS6w [a_abS46]
                          [LclId] =
                              [$dApplicative_sbUkl m2_sbUkm] \r [x1_sbUkq]
                                  let {
                                    sat_sbUkt [Occ=Once] :: [a_abS46] -> m_XbS6w [a_abS46]
                                    [LclId] =
                                        [$dApplicative_sbUkl x1_sbUkq] \r [x2_sbUkr]
                                            let {
                                              sat_sbUks [Occ=Once] :: [a_abS46]
                                              [LclId] =
                                                  CCCS :! [x1_sbUkq x2_sbUkr];
                                            } in  GHC.Base.return $dApplicative_sbUkl sat_sbUks;
                                  } in  GHC.Base.>>= $dApplicative_sbUkl m2_sbUkm sat_sbUkt;
                        } in  GHC.Base.>>= $dApplicative_sbUkl eta_sbUkk sat_sbUku;
              } in  some_v_sbUkn;
        };

Control.Applicative.$fAlternativeWrappedMonad_$cmany
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall a.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))),U(A,U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sbUkv eta_sbUkw]
        let {
          many_v_sbUkx [Occ=LoopBreaker] :: m_XbS6v [a_abS4e]
          [LclId] =
              [$dMonadPlus_sbUkv eta_sbUkw many_v_sbUkx] \u []
                  let {
                    $dApplicative_sbUky [Dmd=<L,U(1*U(A,1*C1(U),A,A,A,A),C(C1(U)),A,C(U),A)>]
                      :: GHC.Base.Monad m_XbS6v
                    [LclId] =
                        [$dMonadPlus_sbUkv] \u []
                            GHC.Base.$p2MonadPlus $dMonadPlus_sbUkv; } in
                  let {
                    sat_sbUkG [Occ=Once] :: m_XbS6v [a_abS4e]
                    [LclId] =
                        [$dApplicative_sbUky] \u []
                            case GHC.Base.$p1Monad $dApplicative_sbUky of sat_sbUkF {
                              __DEFAULT -> GHC.Base.pure sat_sbUkF GHC.Types.[];
                            }; } in
                  let {
                    sat_sbUkE [Occ=Once] :: m_XbS6v [a_abS4e]
                    [LclId] =
                        [eta_sbUkw many_v_sbUkx $dApplicative_sbUky] \u []
                            let {
                              sat_sbUkD [Occ=Once] :: a_abS4e -> m_XbS6v [a_abS4e]
                              [LclId] =
                                  [many_v_sbUkx $dApplicative_sbUky] \r [x1_sbUkz]
                                      let {
                                        sat_sbUkC [Occ=Once] :: [a_abS4e] -> m_XbS6v [a_abS4e]
                                        [LclId] =
                                            [$dApplicative_sbUky x1_sbUkz] \r [x2_sbUkA]
                                                let {
                                                  sat_sbUkB [Occ=Once] :: [a_abS4e]
                                                  [LclId] =
                                                      CCCS :! [x1_sbUkz x2_sbUkA];
                                                } in  GHC.Base.return $dApplicative_sbUky sat_sbUkB;
                                      } in  GHC.Base.>>= $dApplicative_sbUky many_v_sbUkx sat_sbUkC;
                            } in  GHC.Base.>>= $dApplicative_sbUky eta_sbUkw sat_sbUkD;
                  } in  GHC.Base.mplus $dMonadPlus_sbUkv sat_sbUkE sat_sbUkG;
        } in  many_v_sbUkx;

Control.Applicative.$fAlternativeWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Base.Alternative (Control.Applicative.WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),1*U,C(C1(U)))>m] =
    [] \r [$dMonadPlus_sbUkH]
        let {
          sat_sbUkO [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedMonad m_XbS6u a
               -> Control.Applicative.WrappedMonad m_XbS6u [a]
          [LclId] =
              [$dMonadPlus_sbUkH] \r [eta_B1]
                  Control.Applicative.$fAlternativeWrappedMonad_$cmany
                      $dMonadPlus_sbUkH eta_B1; } in
        let {
          sat_sbUkN [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedMonad m_XbS6u a
               -> Control.Applicative.WrappedMonad m_XbS6u [a]
          [LclId] =
              [$dMonadPlus_sbUkH] \r [eta_B1]
                  Control.Applicative.$fAlternativeWrappedMonad_$csome
                      $dMonadPlus_sbUkH eta_B1; } in
        let {
          sat_sbUkM [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedMonad m_XbS6u a
               -> Control.Applicative.WrappedMonad m_XbS6u a
               -> Control.Applicative.WrappedMonad m_XbS6u a
          [LclId] =
              [$dMonadPlus_sbUkH] \r [ds_sbUkK ds1_sbUkL]
                  GHC.Base.mplus $dMonadPlus_sbUkH ds_sbUkK ds1_sbUkL; } in
        let {
          sat_sbUkJ [Occ=Once]
            :: forall a. Control.Applicative.WrappedMonad m_XbS6u a
          [LclId] =
              [$dMonadPlus_sbUkH] \u [] GHC.Base.mzero $dMonadPlus_sbUkH; } in
        let {
          sat_sbUkI [Occ=Once]
            :: GHC.Base.Applicative (Control.Applicative.WrappedMonad m_XbS6u)
          [LclId] =
              [$dMonadPlus_sbUkH] \u []
                  Control.Applicative.$fAlternativeWrappedMonad_$cp1Alternative
                      $dMonadPlus_sbUkH;
        } in 
          GHC.Base.C:Alternative [sat_sbUkI
                                  sat_sbUkJ
                                  sat_sbUkM
                                  sat_sbUkN
                                  sat_sbUkO];

Control.Applicative.$fFunctorWrappedArrow2
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     (a1 -> b1) -> Control.Applicative.WrappedArrow a b a1 -> a b b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbUkP eta_sbUkQ eta1_sbUkR]
        let {
          sat_sbUkT [Occ=Once] :: a_abS32 a1_abS38 b1_abS39
          [LclId] =
              [$dArrow_sbUkP eta_sbUkQ] \u []
                  Control.Arrow.arr $dArrow_sbUkP eta_sbUkQ;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbUkP of sat_sbUkS {
            __DEFAULT -> Control.Category.. sat_sbUkS sat_sbUkT eta1_sbUkR;
          };

Control.Applicative.$fFunctorWrappedArrow1
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     a1 -> Control.Applicative.WrappedArrow a b b1 -> a b a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbUkU x_sbUkV eta_sbUkW]
        let {
          sat_sbUl0 [Occ=Once] :: a_XbS5D b1_abS3t a1_abS3s
          [LclId] =
              [$dArrow_sbUkU x_sbUkV] \u []
                  let {
                    sat_sbUkZ [Occ=Once] :: b1_abS3t -> a1_abS3s
                    [LclId] =
                        [x_sbUkV] \r [ds_sbUkY] x_sbUkV;
                  } in  Control.Arrow.arr $dArrow_sbUkU sat_sbUkZ;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbUkU of sat_sbUkX {
            __DEFAULT -> Control.Category.. sat_sbUkX sat_sbUl0 eta_sbUkW;
          };

Control.Applicative.$fFunctorWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     GHC.Base.Functor (Control.Applicative.WrappedArrow a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,A)>m] =
    [] \r [$dArrow_sbUl1]
        let {
          sat_sbUl3 [Occ=Once]
            :: forall a b.
               a
               -> Control.Applicative.WrappedArrow a_XbS5M b_XbS5O b
               -> Control.Applicative.WrappedArrow a_XbS5M b_XbS5O a
          [LclId] =
              [$dArrow_sbUl1] \r [eta_B2 eta_B1]
                  Control.Applicative.$fFunctorWrappedArrow1
                      $dArrow_sbUl1 eta_B2 eta_B1; } in
        let {
          sat_sbUl2 [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Control.Applicative.WrappedArrow a_XbS5M b_XbS5O a
               -> Control.Applicative.WrappedArrow a_XbS5M b_XbS5O b
          [LclId] =
              [$dArrow_sbUl1] \r [eta_B2 eta_B1]
                  Control.Applicative.$fFunctorWrappedArrow2
                      $dArrow_sbUl1 eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sbUl2 sat_sbUl3];

Control.Applicative.$fAlternativeWrappedArrow2
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1 c.
     (a1 -> b1 -> c)
     -> Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b b1
     -> a b c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(1*U(A,1*C1(C1(U))),1*C1(U),A,A,A,1*C1(C1(U)))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbUl4 eta_sbUl5 eta1_sbUl6 eta2_sbUl7]
        let {
          sat_sbUlb [Occ=Once] :: a_abS1H b_abS1I (a1_abS2g, b1_abS2h)
          [LclId] =
              [$dArrow_sbUl4 eta1_sbUl6 eta2_sbUl7] \u []
                  Control.Arrow.&&& $dArrow_sbUl4 eta1_sbUl6 eta2_sbUl7; } in
        let {
          sat_sbUla [Occ=Once] :: a_abS1H (a1_abS2g, b1_abS2h) c_abS2i
          [LclId] =
              [$dArrow_sbUl4 eta_sbUl5] \u []
                  let {
                    sat_sbUl9 [Occ=Once] :: (a1_abS2g, b1_abS2h) -> c_abS2i
                    [LclId] =
                        [eta_sbUl5] \r [eta_B1] Data.Tuple.uncurry eta_sbUl5 eta_B1;
                  } in  Control.Arrow.arr $dArrow_sbUl4 sat_sbUl9;
        } in 
          case Control.Arrow.$p1Arrow $dArrow_sbUl4 of sat_sbUl8 {
            __DEFAULT -> Control.Category.. sat_sbUl8 sat_sbUla sat_sbUlb;
          };

Control.Applicative.$fApplicativeWrappedArrow5
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1. a1 -> a b a1
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbUlc x_sbUld]
        let {
          sat_sbUlf [Occ=Once] :: b_XbS4F -> a1_abS1R
          [LclId] =
              [x_sbUld] \r [ds_sbUle] x_sbUld;
        } in  Control.Arrow.arr $dArrow_sbUlc sat_sbUlf;

Control.Applicative.$fApplicativeWrappedArrow4
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     Control.Applicative.WrappedArrow a b (a1 -> b1)
     -> Control.Applicative.WrappedArrow a b a1 -> a b b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbUlg eta_B2 eta_B1]
        Control.Applicative.$fAlternativeWrappedArrow2
            $dArrow_sbUlg GHC.Base.breakpoint eta_B2 eta_B1;

Control.Applicative.$fApplicativeWrappedArrow3
  :: forall b a. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbUlh eta_sbUli] eta_sbUli;

Control.Applicative.$fApplicativeWrappedArrow2
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b b1 -> a b b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbUlj a2_sbUlk a3_sbUll]
        let {
          sat_sbUlo [Occ=Once]
            :: Control.Applicative.WrappedArrow
                 a_XbS4Q b_XbS4S (b1_abS2K -> b1_abS2K)
          [LclId] =
              [$dArrow_sbUlj a2_sbUlk] \u []
                  let {
                    sat_sbUln [Occ=Once] :: a_XbS4Q a1_abS2J (b1_abS2K -> b1_abS2K)
                    [LclId] =
                        [$dArrow_sbUlj] \u []
                            Control.Arrow.arr
                                $dArrow_sbUlj Control.Applicative.$fApplicativeWrappedArrow3;
                  } in 
                    case Control.Arrow.$p1Arrow $dArrow_sbUlj of sat_sbUlm {
                      __DEFAULT -> Control.Category.. sat_sbUlm sat_sbUln a2_sbUlk;
                    };
        } in 
          Control.Applicative.$fAlternativeWrappedArrow2
              $dArrow_sbUlj GHC.Base.breakpoint sat_sbUlo a3_sbUll;

Control.Applicative.$fApplicativeWrappedArrow1
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     forall a1 b1.
     Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b b1 -> a b a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>,
 Unf=OtherCon []] =
    [] \r [$dArrow_sbUlp eta_B2 eta_B1]
        Control.Applicative.$fAlternativeWrappedArrow2
            $dArrow_sbUlp GHC.Base.const eta_B2 eta_B1;

Control.Applicative.$fApplicativeWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b.
     Control.Arrow.Arrow a =>
     GHC.Base.Applicative (Control.Applicative.WrappedArrow a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>m] =
    [] \r [$dArrow_sbUlq]
        let {
          sat_sbUlw [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
          [LclId] =
              [$dArrow_sbUlq] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedArrow1
                      $dArrow_sbUlq eta_B2 eta_B1; } in
        let {
          sat_sbUlv [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
          [LclId] =
              [$dArrow_sbUlq] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedArrow2
                      $dArrow_sbUlq eta_B2 eta_B1; } in
        let {
          sat_sbUlu [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b c
          [LclId] =
              [$dArrow_sbUlq] \r [eta_B3 eta_B2 eta_B1]
                  Control.Applicative.$fAlternativeWrappedArrow2
                      $dArrow_sbUlq eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbUlt [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedArrow a_XbS4O b_XbS8b (a -> b)
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
               -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b b
          [LclId] =
              [$dArrow_sbUlq] \r [eta_B2 eta_B1]
                  Control.Applicative.$fApplicativeWrappedArrow4
                      $dArrow_sbUlq eta_B2 eta_B1; } in
        let {
          sat_sbUls [Occ=Once]
            :: forall a.
               a -> Control.Applicative.WrappedArrow a_XbS4O b_XbS8b a
          [LclId] =
              [$dArrow_sbUlq] \r [eta_B1]
                  Control.Applicative.$fApplicativeWrappedArrow5
                      $dArrow_sbUlq eta_B1; } in
        let {
          sat_sbUlr [Occ=Once]
            :: GHC.Base.Functor
                 (Control.Applicative.WrappedArrow a_XbS4O b_XbS8b)
          [LclId] =
              [$dArrow_sbUlq] \u []
                  Control.Applicative.$fFunctorWrappedArrow $dArrow_sbUlq;
        } in 
          GHC.Base.C:Applicative [sat_sbUlr
                                  sat_sbUls
                                  sat_sbUlt
                                  sat_sbUlu
                                  sat_sbUlv
                                  sat_sbUlw];

Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative
  :: forall (a :: * -> * -> *) b.
     (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
     GHC.Base.Applicative (Control.Applicative.WrappedArrow a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)><L,A>m,
 Unf=OtherCon []] =
    [] \r [$dArrowZero_sbUlx $dArrowPlus_sbUly]
        let {
          sat_sbUlz [Occ=Once, Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
            :: Control.Arrow.Arrow a_XbS4i
          [LclId] =
              [$dArrowZero_sbUlx] \u []
                  Control.Arrow.$p1ArrowZero $dArrowZero_sbUlx;
        } in  Control.Applicative.$fApplicativeWrappedArrow sat_sbUlz;

Control.Applicative.$fAlternativeWrappedArrow1
  :: forall b a. b -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sbUlA] [] [];

Control.Applicative.$fAlternativeWrappedArrow_$csome
  :: forall (a :: * -> * -> *) b.
     (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
     forall a1.
     Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b [a1]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LC(C(S)))LLLLL)L),U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)><L,U(A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowZero_sbUlB $dArrowPlus_sbUlC eta_sbUlD]
        let {
          some_v_sbUlE [Occ=LoopBreaker] :: a_XbS4l b_XbS4n [a1_abS1s]
          [LclId] =
              [$dArrowZero_sbUlB $dArrowPlus_sbUlC eta_sbUlD some_v_sbUlE] \u []
                  case
                      Control.Arrow.$p1ArrowZero $dArrowZero_sbUlB
                  of
                  $dApplicative_sbUlF [Dmd=<S(S(LC(C(S)))LLLLL),U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
                  { __DEFAULT ->
                        let {
                          sat_sbUlH [Occ=Once]
                            :: Control.Applicative.WrappedArrow a_XbS4l b_XbS4n [a1_abS1s]
                          [LclId] =
                              [$dArrowPlus_sbUlC some_v_sbUlE $dApplicative_sbUlF] \u []
                                  let {
                                    sat_sbUlG [Occ=Once] :: a_XbS4l b_XbS4n [a1_abS1s]
                                    [LclId] =
                                        [$dApplicative_sbUlF] \u []
                                            Control.Arrow.arr
                                                $dApplicative_sbUlF
                                                Control.Applicative.$fAlternativeWrappedArrow1;
                                  } in  Control.Arrow.<+> $dArrowPlus_sbUlC some_v_sbUlE sat_sbUlG;
                        } in 
                          Control.Applicative.$fAlternativeWrappedArrow2
                              $dApplicative_sbUlF GHC.Types.: eta_sbUlD sat_sbUlH;
                  };
        } in  some_v_sbUlE;

Control.Applicative.$fAlternativeWrappedArrow_$cmany
  :: forall (a :: * -> * -> *) b.
     (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
     forall a1.
     Control.Applicative.WrappedArrow a b a1
     -> Control.Applicative.WrappedArrow a b [a1]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),A)><S(LC(C(S))),U(A,C(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dArrowZero_sbUlI $dArrowPlus_sbUlJ eta_sbUlK]
        let {
          many_v_sbUlL [Occ=LoopBreaker] :: a_XbS4k b_XbS4m [a1_abS1A]
          [LclId] =
              [$dArrowZero_sbUlI $dArrowPlus_sbUlJ eta_sbUlK many_v_sbUlL] \u []
                  let {
                    $dApplicative_sbUlM [Dmd=<L,U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U)))>]
                      :: Control.Arrow.Arrow a_XbS4k
                    [LclId] =
                        [$dArrowZero_sbUlI] \u []
                            Control.Arrow.$p1ArrowZero $dArrowZero_sbUlI; } in
                  let {
                    sat_sbUlO [Occ=Once] :: a_XbS4k b_XbS4m [a1_abS1A]
                    [LclId] =
                        [$dApplicative_sbUlM] \u []
                            Control.Arrow.arr
                                $dApplicative_sbUlM
                                Control.Applicative.$fAlternativeWrappedArrow1; } in
                  let {
                    sat_sbUlN [Occ=Once] :: a_XbS4k b_XbS4m [a1_abS1A]
                    [LclId] =
                        [eta_sbUlK many_v_sbUlL $dApplicative_sbUlM] \u []
                            Control.Applicative.$fAlternativeWrappedArrow2
                                $dApplicative_sbUlM GHC.Types.: eta_sbUlK many_v_sbUlL;
                  } in  Control.Arrow.<+> $dArrowPlus_sbUlJ sat_sbUlN sat_sbUlO;
        } in  many_v_sbUlL;

Control.Applicative.$fAlternativeWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b.
     (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
     GHC.Base.Alternative (Control.Applicative.WrappedArrow a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(U(A,C(C1(U))),C(U),A,A,A,C(C1(U))),1*U)><L,U(A,C(C1(U)))>m] =
    [] \r [$dArrowZero_sbUlP $dArrowPlus_sbUlQ]
        let {
          sat_sbUlX [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
               -> Control.Applicative.WrappedArrow a_XbS4j b_XbS4l [a]
          [LclId] =
              [$dArrowZero_sbUlP $dArrowPlus_sbUlQ] \r [eta_B1]
                  Control.Applicative.$fAlternativeWrappedArrow_$cmany
                      $dArrowZero_sbUlP $dArrowPlus_sbUlQ eta_B1; } in
        let {
          sat_sbUlW [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
               -> Control.Applicative.WrappedArrow a_XbS4j b_XbS4l [a]
          [LclId] =
              [$dArrowZero_sbUlP $dArrowPlus_sbUlQ] \r [eta_B1]
                  Control.Applicative.$fAlternativeWrappedArrow_$csome
                      $dArrowZero_sbUlP $dArrowPlus_sbUlQ eta_B1; } in
        let {
          sat_sbUlV [Occ=Once]
            :: forall a.
               Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
               -> Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
               -> Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
          [LclId] =
              [$dArrowPlus_sbUlQ] \r [ds_sbUlT ds1_sbUlU]
                  Control.Arrow.<+> $dArrowPlus_sbUlQ ds_sbUlT ds1_sbUlU; } in
        let {
          sat_sbUlS [Occ=Once]
            :: forall a. Control.Applicative.WrappedArrow a_XbS4j b_XbS4l a
          [LclId] =
              [$dArrowZero_sbUlP] \u []
                  Control.Arrow.zeroArrow $dArrowZero_sbUlP; } in
        let {
          sat_sbUlR [Occ=Once]
            :: GHC.Base.Applicative
                 (Control.Applicative.WrappedArrow a_XbS4j b_XbS4l)
          [LclId] =
              [$dArrowZero_sbUlP $dArrowPlus_sbUlQ] \u []
                  Control.Applicative.$fAlternativeWrappedArrow_$cp1Alternative
                      $dArrowZero_sbUlP $dArrowPlus_sbUlQ;
        } in 
          GHC.Base.C:Alternative [sat_sbUlR
                                  sat_sbUlS
                                  sat_sbUlV
                                  sat_sbUlW
                                  sat_sbUlX];

Control.Applicative.$wunsafeDrop [InlPrag=NOUSERINLINE[0],
                                  Occ=LoopBreaker]
  :: forall a1. GHC.Prim.Int# -> [a1] -> [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_sbUlY w_sbUlZ]
        case w_sbUlZ of {
          [] -> [] [];
          : _ [Occ=Dead] ipv2_sbUm2 [Occ=Once*] ->
              case ww_sbUlY of ds3_sbUm3 {
                __DEFAULT ->
                    case -# [ds3_sbUm3 1#] of sat_sbUm4 {
                      __DEFAULT -> Control.Applicative.$wunsafeDrop sat_sbUm4 ipv2_sbUm2;
                    };
                1# -> ipv2_sbUm2;
              };
        };

Control.Applicative.$fAlternativeZipList2
  :: forall a.
     Control.Applicative.ZipList a
     -> Control.Applicative.ZipList a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbUm5 ds1_sbUm6]
        let {
          sat_sbUm9 [Occ=Once, Dmd=<L,1*U>] :: [a_abRZs]
          [LclId] =
              [ds_sbUm5 ds1_sbUm6] \s []
                  case GHC.List.$wlenAcc ds_sbUm5 0# of ww2_sbUm7 {
                    __DEFAULT ->
                        case <=# [ww2_sbUm7 0#] of {
                          __DEFAULT -> Control.Applicative.$wunsafeDrop ww2_sbUm7 ds1_sbUm6;
                          1# -> ds1_sbUm6;
                        };
                  };
        } in  GHC.Base.++ ds_sbUm5 sat_sbUm9;

Control.Applicative.$fGeneric1ZipList1
  :: forall a.
     GHC.Generics.Rep1 Control.Applicative.ZipList a
     -> GHC.Generics.Rep1 Control.Applicative.ZipList a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbUma] ds_sbUma;

Control.Applicative.$fGeneric1ZipList2
  :: forall a.
     Control.Applicative.ZipList a -> Control.Applicative.ZipList a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sbUmb] x_sbUmb;

Control.Applicative.$fGeneric1ZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Control.Applicative.ZipList
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Control.Applicative.$fGeneric1ZipList2
                                            Control.Applicative.$fGeneric1ZipList1];

Control.Applicative.$fGenericZipList1
  :: forall a x.
     GHC.Generics.Rep (Control.Applicative.ZipList a) x
     -> GHC.Generics.Rep (Control.Applicative.ZipList a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbUmc] ds_sbUmc;

Control.Applicative.$fGenericZipList2
  :: forall a x.
     Control.Applicative.ZipList a -> Control.Applicative.ZipList a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sbUmd] x1_sbUmd;

Control.Applicative.$fGenericZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Control.Applicative.ZipList a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Control.Applicative.$fGenericZipList2
                                           Control.Applicative.$fGenericZipList1];

Control.Applicative.$fFoldableZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Control.Applicative.ZipList
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableNonEmpty_$cfold1
                                             Data.Foldable.$fFoldable[]_$cfoldMap
                                             GHC.Base.foldr
                                             Data.Foldable.$fFoldable[]_$cfoldr'
                                             GHC.List.foldl
                                             GHC.List.foldl'
                                             GHC.List.foldr1
                                             GHC.List.foldl1
                                             GHC.Base.id
                                             GHC.List.null
                                             GHC.List.length
                                             GHC.List.elem
                                             GHC.List.maximum
                                             GHC.List.minimum
                                             GHC.List.sum
                                             GHC.List.product];

Control.Applicative.$fFunctorZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Control.Applicative.ZipList
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.map
                                       GHC.Base.$fFunctor[]_$c<$];

Control.Applicative.$fApplicativeZipList6 [Occ=LoopBreaker]
  :: forall a b. [a -> b] -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbUme ds1_sbUmf]
        case ds_sbUme of {
          [] -> [] [];
          : ipv_sbUmh [Occ=Once!] ipv1_sbUmi [Occ=Once] ->
              case ds1_sbUmf of {
                [] -> [] [];
                : ipv2_sbUmk [Occ=Once] ipv3_sbUml [Occ=Once] ->
                    let {
                      sat_sbUmn [Occ=Once] :: [b_abS0e]
                      [LclId] =
                          [ipv1_sbUmi ipv3_sbUml] \u []
                              Control.Applicative.$fApplicativeZipList6
                                  ipv1_sbUmi ipv3_sbUml; } in
                    let {
                      sat_sbUmm [Occ=Once] :: b_abS0e
                      [LclId] =
                          [ipv_sbUmh ipv2_sbUmk] \u [] ipv_sbUmh ipv2_sbUmk;
                    } in  : [sat_sbUmm sat_sbUmn];
              };
        };

Control.Applicative.$fApplicativeZipList5
  :: forall a b.
     Control.Applicative.ZipList (a -> b)
     -> Control.Applicative.ZipList a -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbUmo ds1_sbUmp]
        Control.Applicative.$fApplicativeZipList6 ds_sbUmo ds1_sbUmp;

Control.Applicative.$fApplicativeZipList4 [Occ=LoopBreaker]
  :: forall a b. [a] -> [b] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbUmq eta_sbUmr]
        case ds_sbUmq of {
          [] -> [] [];
          : _ [Occ=Dead] ys_sbUmu [Occ=Once] ->
              case eta_sbUmr of {
                [] -> [] [];
                : y1_sbUmw [Occ=Once] ys1_sbUmx [Occ=Once] ->
                    let {
                      sat_sbUmy [Occ=Once] :: [b_abS0z]
                      [LclId] =
                          [ys_sbUmu ys1_sbUmx] \u []
                              Control.Applicative.$fApplicativeZipList4 ys_sbUmu ys1_sbUmx;
                    } in  : [y1_sbUmw sat_sbUmy];
              };
        };

Control.Applicative.$fApplicativeZipList3
  :: forall a b.
     Control.Applicative.ZipList a
     -> Control.Applicative.ZipList b -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_sbUmz a2_sbUmA]
        Control.Applicative.$fApplicativeZipList4 a1_sbUmz a2_sbUmA;

Control.Applicative.$fApplicativeZipList2 [Occ=LoopBreaker]
  :: forall b a. [a] -> [b] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbUmB ds1_sbUmC]
        case ds_sbUmB of {
          [] -> [] [];
          : ipv_sbUmE [Occ=Once] ipv1_sbUmF [Occ=Once] ->
              case ds1_sbUmC of {
                [] -> [] [];
                : _ [Occ=Dead] ipv3_sbUmI [Occ=Once] ->
                    let {
                      sat_sbUmJ [Occ=Once] :: [a_abS0I]
                      [LclId] =
                          [ipv1_sbUmF ipv3_sbUmI] \u []
                              Control.Applicative.$fApplicativeZipList2 ipv1_sbUmF ipv3_sbUmI;
                    } in  : [ipv_sbUmE sat_sbUmJ];
              };
        };

Control.Applicative.$fApplicativeZipList1
  :: forall b a.
     Control.Applicative.ZipList a
     -> Control.Applicative.ZipList b -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbUmK ds1_sbUmL]
        Control.Applicative.$fApplicativeZipList2 ds_sbUmK ds1_sbUmL;

Control.Applicative.$fApplicativeZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Control.Applicative.ZipList
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Control.Applicative.$fFunctorZipList
                                           GHC.List.repeat
                                           Control.Applicative.$fApplicativeZipList5
                                           GHC.List.zipWith
                                           Control.Applicative.$fApplicativeZipList3
                                           Control.Applicative.$fApplicativeZipList1];

Control.Applicative.$fAlternativeZipList_xs [Occ=LoopBreaker]
  :: forall a. [[a]]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Types.[]
                      Control.Applicative.$fAlternativeZipList_xs];

Control.Applicative.$fAlternativeZipList1 [Occ=LoopBreaker]
  :: forall a. [a] -> [[a]] -> [[a]]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sbUmM ds1_sbUmN]
        case ds_sbUmM of {
          [] -> [] [];
          : ipv_sbUmP [Occ=Once] ipv1_sbUmQ [Occ=Once] ->
              case ds1_sbUmN of {
                [] -> [] [];
                : ipv2_sbUmS [Occ=Once] ipv3_sbUmT [Occ=Once] ->
                    let {
                      sat_sbUmV [Occ=Once] :: [[a_abRZG]]
                      [LclId] =
                          [ipv1_sbUmQ ipv3_sbUmT] \u []
                              Control.Applicative.$fAlternativeZipList1
                                  ipv1_sbUmQ ipv3_sbUmT; } in
                    let {
                      sat_sbUmU [Occ=Once] :: [a_abRZG]
                      [LclId] =
                          CCCS :! [ipv_sbUmP ipv2_sbUmS];
                    } in  : [sat_sbUmU sat_sbUmV];
              };
        };

Control.Applicative.$fAlternativeZipList_$csome
  :: forall a.
     Control.Applicative.ZipList a -> Control.Applicative.ZipList [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sbUmW]
        let {
          some_v_sbUmX [Occ=LoopBreaker] :: [[a_abRZG]]
          [LclId] =
              [v_sbUmW some_v_sbUmX] \u []
                  let {
                    sat_sbUmY [Occ=Once, Dmd=<L,1*U>] :: [[a_abRZG]]
                    [LclId] =
                        [some_v_sbUmX] \s []
                            Control.Applicative.$fAlternativeZipList2
                                some_v_sbUmX Control.Applicative.$fAlternativeZipList_xs;
                  } in  Control.Applicative.$fAlternativeZipList1 v_sbUmW sat_sbUmY;
        } in  some_v_sbUmX;

Control.Applicative.$fAlternativeZipList_$cmany
  :: forall a.
     Control.Applicative.ZipList a -> Control.Applicative.ZipList [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sbUmZ]
        let {
          many_v_sbUn0 [Occ=LoopBreaker] :: [[a_abRZO]]
          [LclId] =
              [v_sbUmZ many_v_sbUn0] \u []
                  case
                      Control.Applicative.$fAlternativeZipList1 v_sbUmZ many_v_sbUn0
                  of
                  sat_sbUn1
                  { __DEFAULT ->
                        Control.Applicative.$fAlternativeZipList2
                            sat_sbUn1 Control.Applicative.$fAlternativeZipList_xs;
                  };
        } in  many_v_sbUn0;

Control.Applicative.$fAlternativeZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Control.Applicative.ZipList
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Control.Applicative.$fApplicativeZipList
                                           GHC.Types.[]
                                           Control.Applicative.$fAlternativeZipList2
                                           Control.Applicative.$fAlternativeZipList_$csome
                                           Control.Applicative.$fAlternativeZipList_$cmany];

Control.Applicative.$fReadZipList11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ZipList"#;

Control.Applicative.$fReadZipList10 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Control.Applicative.$fReadZipList11;

Control.Applicative.$fReadZipList_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Control.Applicative.$fReadZipList10];

Control.Applicative.$fReadZipList9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "{"#;

Control.Applicative.$fReadZipList8 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Control.Applicative.$fReadZipList9;

Control.Applicative.$fReadZipList_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Control.Applicative.$fReadZipList8];

Control.Applicative.$fReadZipList7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getZipList"#;

Control.Applicative.$fReadZipList6 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Control.Applicative.$fReadZipList7;

Control.Applicative.$fReadZipList5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Control.Applicative.$fReadZipList4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "}"#;

Control.Applicative.$fReadZipList3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Control.Applicative.$fReadZipList4;

Control.Applicative.$fReadZipList2 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Control.Applicative.$fReadZipList3];

Control.Applicative.$fReadZipList1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Control.Applicative.ZipList a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,A,1*C1(U))>, Unf=OtherCon []] =
    [] \r [$dRead_sbUn2]
        let {
          lvl_sbUn3 [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP [a_abRO3]
          [LclId] =
              [$dRead_sbUn2] \u []
                  GHC.Read.readListPrec
                      $dRead_sbUn2 Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sbUn4 [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP [a_abRO3]
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl_sbUn3] \r [ds1_sbUn5] lvl_sbUn3; } in
        let {
          sat_sbUnp [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Control.Applicative.ZipList a_abRO3)
          [LclId] =
              [ds_sbUn4] \r [c_sbUn6 eta_sbUn7]
                  case c_sbUn6 of {
                    GHC.Types.I# x_sbUn9 [Occ=Once] ->
                        case <=# [x_sbUn9 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sbUnm [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sbUn4 eta_sbUn7] \r [a1_sbUnb]
                                        let {
                                          sat_sbUnj [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sbUn4 eta_sbUn7] \r [a2_sbUnc]
                                                  let {
                                                    sat_sbUni [Occ=Once]
                                                      :: [a_abRO3]
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sbUn7] \r [a3_sbUnd]
                                                            let {
                                                              sat_sbUnf [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sbUn7 a3_sbUnd] \r [a4_sbUne]
                                                                      eta_sbUn7 a3_sbUnd;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Control.Applicative.$fReadZipList2
                                                                      sat_sbUnf
                                                              of
                                                              { Unit# ww1_sbUnh [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sbUnh];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Control.Applicative.$fReadZipList6
                                                        ds_sbUn4
                                                        Control.Applicative.$fReadZipList5
                                                        sat_sbUni;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Control.Applicative.$fReadZipList_lexeme sat_sbUnj
                                          of
                                          { Unit# ww1_sbUnl [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sbUnl];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Control.Applicative.$fReadZipList_lexeme1 sat_sbUnm
                                of
                                { Unit# ww1_sbUno [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sbUno];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sbUnp;

Control.Applicative.$fReadZipList_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Control.Applicative.ZipList a)
[GblId, Arity=1, Str=<L,1*U(A,A,A,1*C1(U))>, Unf=OtherCon []] =
    [] \r [$dRead_sbUnq]
        let {
          ds_sbUnr [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Control.Applicative.ZipList a_XbRSJ
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sbUnq] \u []
                  Control.Applicative.$fReadZipList1 $dRead_sbUnq; } in
        let {
          sat_sbUnu [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Control.Applicative.ZipList a_XbRSJ)
          [LclId] =
              [ds_sbUnr] \r [n_sbUns]
                  let {
                    sat_sbUnt [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Control.Applicative.ZipList a_XbRSJ)
                    [LclId] =
                        [ds_sbUnr n_sbUns] \u []
                            ds_sbUnr
                                n_sbUns Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sbUnt;
        } in  sat_sbUnu;

Control.Applicative.$fReadZipList_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Control.Applicative.ZipList a]
[GblId, Arity=1, Str=<L,1*U(A,A,A,1*C1(U))>, Unf=OtherCon []] =
    [] \r [$dRead_sbUnv]
        let {
          sat_sbUnw [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Control.Applicative.ZipList a_XbRSH)
          [LclId] =
              [$dRead_sbUnv] \s []
                  Control.Applicative.$fReadZipList1 $dRead_sbUnv;
        } in  GHC.Read.list sat_sbUnw;

Control.Applicative.$fReadZipList_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Control.Applicative.ZipList a]
[GblId, Arity=1, Str=<L,1*U(A,A,A,1*C1(U))>, Unf=OtherCon []] =
    [] \r [$dRead_sbUnx]
        let {
          sat_sbUnz [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Control.Applicative.ZipList a_XbRSI]
          [LclId] =
              [$dRead_sbUnx] \u []
                  let {
                    sat_sbUny [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Control.Applicative.ZipList a_XbRSI)
                    [LclId] =
                        [$dRead_sbUnx] \s []
                            Control.Applicative.$fReadZipList1 $dRead_sbUnx;
                  } in 
                    GHC.Read.list
                        sat_sbUny
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sbUnz;

Control.Applicative.$fReadZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Control.Applicative.ZipList a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,C(U))>m] =
    [] \r [$dRead_sbUnA]
        let {
          sat_sbUnE [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Control.Applicative.ZipList a_XbRSG]
          [LclId] =
              [$dRead_sbUnA] \u []
                  Control.Applicative.$fReadZipList_$creadListPrec $dRead_sbUnA; } in
        let {
          sat_sbUnD [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Control.Applicative.ZipList a_XbRSG)
          [LclId] =
              [$dRead_sbUnA] \u []
                  Control.Applicative.$fReadZipList1 $dRead_sbUnA; } in
        let {
          sat_sbUnC [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Control.Applicative.ZipList a_XbRSG]
          [LclId] =
              [$dRead_sbUnA] \u []
                  Control.Applicative.$fReadZipList_$creadList $dRead_sbUnA; } in
        let {
          sat_sbUnB [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Control.Applicative.ZipList a_XbRSG)
          [LclId] =
              [$dRead_sbUnA] \u []
                  Control.Applicative.$fReadZipList_$creadsPrec $dRead_sbUnA;
        } in  GHC.Read.C:Read [sat_sbUnB sat_sbUnC sat_sbUnD sat_sbUnE];

Control.Applicative.$fEqZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Control.Applicative.ZipList a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sbUnF]
        let {
          sat_sbUnH [Occ=Once]
            :: Control.Applicative.ZipList a_abRLG
               -> Control.Applicative.ZipList a_abRLG -> GHC.Types.Bool
          [LclId] =
              [$dEq_sbUnF] \r [eta_B2 eta_B1]
                  GHC.Classes.$fEq[]_$c/= $dEq_sbUnF eta_B2 eta_B1; } in
        let {
          sat_sbUnG [Occ=Once]
            :: Control.Applicative.ZipList a_abRLG
               -> Control.Applicative.ZipList a_abRLG -> GHC.Types.Bool
          [LclId] =
              [$dEq_sbUnF] \r [eta_B2 eta_B1]
                  GHC.Classes.$fEq[]_$c== $dEq_sbUnF eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sbUnG sat_sbUnH];

Control.Applicative.$fOrdZipList_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Control.Applicative.ZipList a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sbUnI]
        let {
          sat_sbUnJ [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_abRMe
          [LclId] =
              [$dOrd_sbUnI] \u [] GHC.Classes.$p1Ord $dOrd_sbUnI;
        } in  Control.Applicative.$fEqZipList sat_sbUnJ;

Control.Applicative.$fOrdZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Control.Applicative.ZipList a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_sbUnK]
        let {
          sat_sbUnS [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe
          [LclId] =
              [$dOrd_sbUnK] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$cmin $dOrd_sbUnK eta_B2 eta_B1; } in
        let {
          sat_sbUnR [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe
          [LclId] =
              [$dOrd_sbUnK] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$cmax $dOrd_sbUnK eta_B2 eta_B1; } in
        let {
          sat_sbUnQ [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbUnK] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$c>= $dOrd_sbUnK eta_B2 eta_B1; } in
        let {
          sat_sbUnP [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbUnK] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$c> $dOrd_sbUnK eta_B2 eta_B1; } in
        let {
          sat_sbUnO [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbUnK] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$c<= $dOrd_sbUnK eta_B2 eta_B1; } in
        let {
          sat_sbUnN [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbUnK] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$c< $dOrd_sbUnK eta_B2 eta_B1; } in
        let {
          sat_sbUnM [Occ=Once]
            :: Control.Applicative.ZipList a_abRMe
               -> Control.Applicative.ZipList a_abRMe -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sbUnK] \r [eta_B2 eta_B1]
                  GHC.Classes.$fOrd[]_$ccompare $dOrd_sbUnK eta_B2 eta_B1; } in
        let {
          sat_sbUnL [Occ=Once]
            :: GHC.Classes.Eq (Control.Applicative.ZipList a_abRMe)
          [LclId] =
              [$dOrd_sbUnK] \u []
                  Control.Applicative.$fOrdZipList_$cp1Ord $dOrd_sbUnK;
        } in 
          GHC.Classes.C:Ord [sat_sbUnL
                             sat_sbUnM
                             sat_sbUnN
                             sat_sbUnO
                             sat_sbUnP
                             sat_sbUnQ
                             sat_sbUnR
                             sat_sbUnS];

Control.Applicative.$fShowZipList3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ZipList {"#;

Control.Applicative.$fShowZipList2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getZipList = "#;

Control.Applicative.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Control.Applicative.ZipList a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C(U)))><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbUnT ww_sbUnU w1_sbUnV]
        let {
          f_sbUnW [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sbUnT w1_sbUnV] \u [] GHC.Show.showList w_sbUnT w1_sbUnV;
        } in 
          case >=# [ww_sbUnU 11#] of {
            __DEFAULT ->
                let {
                  sat_sbUo2 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sbUnW] \r [x_sbUnY]
                          let {
                            sat_sbUo1 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sbUnW x_sbUnY] \u []
                                    let {
                                      sat_sbUo0 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sbUnW x_sbUnY] \u []
                                              let {
                                                sat_sbUnZ [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sbUnY] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Control.Applicative.$fReadZipList4
                                                            x_sbUnY;
                                              } in  f_sbUnW sat_sbUnZ;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Control.Applicative.$fShowZipList2 sat_sbUo0;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Control.Applicative.$fShowZipList3 sat_sbUo1;
                } in  sat_sbUo2;
            1# ->
                let {
                  sat_sbUo9 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sbUnW] \r [x_sbUo3]
                          let {
                            sat_sbUo8 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sbUnW x_sbUo3] \u []
                                    let {
                                      sat_sbUo7 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sbUnW x_sbUo3] \u []
                                              let {
                                                sat_sbUo6 [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sbUnW x_sbUo3] \u []
                                                        let {
                                                          sat_sbUo5 [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sbUo3] \u []
                                                                  let {
                                                                    sat_sbUo4 [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sbUo3];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Control.Applicative.$fReadZipList4
                                                                        sat_sbUo4;
                                                        } in  f_sbUnW sat_sbUo5;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Control.Applicative.$fShowZipList2 sat_sbUo6;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Control.Applicative.$fShowZipList3 sat_sbUo7;
                          } in  : [GHC.Show.$fShow(,)4 sat_sbUo8];
                } in  sat_sbUo9;
          };

Control.Applicative.$fShowZipList_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Control.Applicative.ZipList a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C(U)))><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbUoa w1_sbUob w2_sbUoc]
        case w1_sbUob of {
          GHC.Types.I# ww1_sbUoe [Occ=Once] ->
              Control.Applicative.$w$cshowsPrec w_sbUoa ww1_sbUoe w2_sbUoc;
        };

Control.Applicative.$fShowZipList_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Control.Applicative.ZipList a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C1(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sbUof x_sbUog]
        let {
          sat_sbUoi [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sbUof x_sbUog] \u []
                  let {
                    sat_sbUoh [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sbUof x_sbUog] \u []
                            GHC.Show.showList
                                $dShow_sbUof x_sbUog Control.Applicative.$fReadZipList3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Control.Applicative.$fShowZipList2 sat_sbUoh;
        } in 
          GHC.CString.unpackAppendCString#
              Control.Applicative.$fShowZipList3 sat_sbUoi;

Control.Applicative.$fShowZipList1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Control.Applicative.$fShowZipList_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Control.Applicative.ZipList a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sbUoj ls_sbUok s_sbUol]
        let {
          sat_sbUon [Occ=Once]
            :: Control.Applicative.ZipList a_abRLb -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbUoj] \r [w_sbUom]
                  Control.Applicative.$w$cshowsPrec $dShow_sbUoj 0# w_sbUom;
        } in  GHC.Show.showList__ sat_sbUon ls_sbUok s_sbUol;

Control.Applicative.$fShowZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Control.Applicative.ZipList a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C(U)))>m] =
    [] \r [$dShow_sbUoo]
        let {
          sat_sbUor [Occ=Once]
            :: [Control.Applicative.ZipList a_abRLb] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbUoo] \r [eta_B2 eta_B1]
                  Control.Applicative.$fShowZipList_$cshowList
                      $dShow_sbUoo eta_B2 eta_B1; } in
        let {
          sat_sbUoq [Occ=Once]
            :: Control.Applicative.ZipList a_abRLb -> GHC.Base.String
          [LclId] =
              [$dShow_sbUoo] \r [eta_B1]
                  Control.Applicative.$fShowZipList_$cshow $dShow_sbUoo eta_B1; } in
        let {
          sat_sbUop [Occ=Once]
            :: GHC.Types.Int
               -> Control.Applicative.ZipList a_abRLb -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbUoo] \r [eta_B2 eta_B1]
                  Control.Applicative.$fShowZipList_$cshowsPrec
                      $dShow_sbUoo eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sbUop sat_sbUoq sat_sbUor];

Control.Applicative.$fGeneric1WrappedArrow1
  :: forall (a1 :: * -> * -> *) b a2.
     GHC.Generics.Rep1 (Control.Applicative.WrappedArrow a1 b) a2
     -> GHC.Generics.Rep1 (Control.Applicative.WrappedArrow a1 b) a2
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbUos] ds_sbUos;

Control.Applicative.$fGeneric1WrappedArrow2
  :: forall (a1 :: * -> * -> *) b a2.
     Control.Applicative.WrappedArrow a1 b a2
     -> Control.Applicative.WrappedArrow a1 b a2
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sbUot] x_sbUot;

Control.Applicative.$fGeneric1WrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b.
     GHC.Generics.Generic1 (Control.Applicative.WrappedArrow a b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Control.Applicative.$fGeneric1WrappedArrow2
                                            Control.Applicative.$fGeneric1WrappedArrow1];

Control.Applicative.$fGenericWrappedArrow1
  :: forall (a :: * -> * -> *) b c x.
     GHC.Generics.Rep (Control.Applicative.WrappedArrow a b c) x
     -> GHC.Generics.Rep (Control.Applicative.WrappedArrow a b c) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbUou] ds_sbUou;

Control.Applicative.$fGenericWrappedArrow2
  :: forall (a :: * -> * -> *) b c x.
     Control.Applicative.WrappedArrow a b c
     -> Control.Applicative.WrappedArrow a b c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sbUov] x1_sbUov;

Control.Applicative.$fGenericWrappedArrow [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (a :: * -> * -> *) b c.
     GHC.Generics.Generic (Control.Applicative.WrappedArrow a b c)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Control.Applicative.$fGenericWrappedArrow2
                                           Control.Applicative.$fGenericWrappedArrow1];

Control.Applicative.$fMonadWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     GHC.Base.Monad (Control.Applicative.WrappedMonad m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(A,C(U),A,A,A,A),U,1*U,U,1*U)>m] =
    [] \r [$dMonad_sbUow]
        let {
          sat_sbUoB [Occ=Once]
            :: forall a.
               GHC.Base.String -> Control.Applicative.WrappedMonad m_abRHy a
          [LclId] =
              [$dMonad_sbUow] \u [] GHC.Base.fail $dMonad_sbUow; } in
        let {
          sat_sbUoA [Occ=Once]
            :: forall a. a -> Control.Applicative.WrappedMonad m_abRHy a
          [LclId] =
              [$dMonad_sbUow] \u [] GHC.Base.return $dMonad_sbUow; } in
        let {
          sat_sbUoz [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_abRHy a
               -> Control.Applicative.WrappedMonad m_abRHy b
               -> Control.Applicative.WrappedMonad m_abRHy b
          [LclId] =
              [$dMonad_sbUow] \u [] GHC.Base.>> $dMonad_sbUow; } in
        let {
          sat_sbUoy [Occ=Once]
            :: forall a b.
               Control.Applicative.WrappedMonad m_abRHy a
               -> (a -> Control.Applicative.WrappedMonad m_abRHy b)
               -> Control.Applicative.WrappedMonad m_abRHy b
          [LclId] =
              [$dMonad_sbUow] \u [] GHC.Base.>>= $dMonad_sbUow; } in
        let {
          sat_sbUox [Occ=Once]
            :: GHC.Base.Applicative (Control.Applicative.WrappedMonad m_abRHy)
          [LclId] =
              [$dMonad_sbUow] \u []
                  Control.Applicative.$fApplicativeWrappedMonad $dMonad_sbUow;
        } in 
          GHC.Base.C:Monad [sat_sbUox
                            sat_sbUoy
                            sat_sbUoz
                            sat_sbUoA
                            sat_sbUoB];

Control.Applicative.$fGeneric1WrappedMonad1
  :: forall (m :: * -> *) a.
     GHC.Generics.Rep1 (Control.Applicative.WrappedMonad m) a
     -> GHC.Generics.Rep1 (Control.Applicative.WrappedMonad m) a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbUoC] ds_sbUoC;

Control.Applicative.$fGeneric1WrappedMonad2
  :: forall (m :: * -> *) a.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sbUoD] x_sbUoD;

Control.Applicative.$fGeneric1WrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *).
     GHC.Generics.Generic1 (Control.Applicative.WrappedMonad m)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Control.Applicative.$fGeneric1WrappedMonad2
                                            Control.Applicative.$fGeneric1WrappedMonad1];

Control.Applicative.$fGenericWrappedMonad1
  :: forall (m :: * -> *) a x.
     GHC.Generics.Rep (Control.Applicative.WrappedMonad m a) x
     -> GHC.Generics.Rep (Control.Applicative.WrappedMonad m a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbUoE] ds_sbUoE;

Control.Applicative.$fGenericWrappedMonad2
  :: forall (m :: * -> *) a x.
     Control.Applicative.WrappedMonad m a
     -> Control.Applicative.WrappedMonad m a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sbUoF] x1_sbUoF;

Control.Applicative.$fGenericWrappedMonad [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (m :: * -> *) a.
     GHC.Generics.Generic (Control.Applicative.WrappedMonad m a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Control.Applicative.$fGenericWrappedMonad2
                                           Control.Applicative.$fGenericWrappedMonad1];

Control.Applicative.unwrapMonad
  :: forall (m :: * -> *) a.
     Control.Applicative.WrappedMonad m a -> m a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Control.Applicative.$fGeneric1WrappedMonad2 eta_B1;

Control.Applicative.unwrapArrow
  :: forall (a :: * -> * -> *) b c.
     Control.Applicative.WrappedArrow a b c -> a b c
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Control.Applicative.$fGeneric1WrappedArrow2 eta_B1;

Control.Applicative.getZipList
  :: forall a. Control.Applicative.ZipList a -> [a]
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Control.Applicative.$fGeneric1ZipList2 eta_B1;

Control.Applicative.optional
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     f a -> f (GHC.Base.Maybe a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LL),U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,1*C1(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sbUoG eta_sbUoH]
        let {
          $dApplicative_sbUoI [Dmd=<L,U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)>]
            :: GHC.Base.Applicative f_abRFg
          [LclId] =
              [$dAlternative_sbUoG] \u []
                  GHC.Base.$p1Alternative $dAlternative_sbUoG; } in
        let {
          sat_sbUoL [Occ=Once] :: f_abRFg (GHC.Base.Maybe a_abRFh)
          [LclId] =
              [$dApplicative_sbUoI] \u []
                  GHC.Base.pure $dApplicative_sbUoI GHC.Base.Nothing; } in
        let {
          sat_sbUoK [Occ=Once] :: f_abRFg (GHC.Base.Maybe a_abRFh)
          [LclId] =
              [eta_sbUoH $dApplicative_sbUoI] \u []
                  case GHC.Base.$p1Applicative $dApplicative_sbUoI of sat_sbUoJ {
                    __DEFAULT -> GHC.Base.fmap sat_sbUoJ GHC.Base.Just eta_sbUoH;
                  };
        } in  GHC.Base.<|> $dAlternative_sbUoG sat_sbUoK sat_sbUoL;

Control.Applicative.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Control.Applicative.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$trModule4];

Control.Applicative.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Control.Applicative"#;

Control.Applicative.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$trModule2];

Control.Applicative.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Control.Applicative.$trModule3
                                     Control.Applicative.$trModule1];

Control.Applicative.$tcWrappedMonad1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         GHC.Types.krep$*Arr*];

Control.Applicative.$tcWrappedArrow1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         GHC.Types.krep$*->*->*];

$krep_rbSvt :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep1_rbSvu :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep2_rbSvv :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep3_rbSvw :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rbSvv GHC.Types.[]];

$krep4_rbSvx :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc[]
                                              $krep3_rbSvw];

$krep5_rbSvy :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep2_rbSvv $krep1_rbSvu];

$krep6_rbSvz :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep5_rbSvy $krep_rbSvt];

Control.Applicative.$tcWrappedMonad3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrappedMonad"#;

Control.Applicative.$tcWrappedMonad2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tcWrappedMonad3];

Control.Applicative.$tcWrappedMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12971590878300233698##
                                    12447260690856494251##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tcWrappedMonad2
                                    0#
                                    Control.Applicative.$tcWrappedMonad1];

$krep7_rbSvA :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rbSvu GHC.Types.[]];

$krep8_rbSvB :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rbSvv $krep7_rbSvA];

$krep9_rbSvC :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Applicative.$tcWrappedMonad
                                              $krep8_rbSvB];

Control.Applicative.$tc'WrapMonad1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_rbSvy $krep9_rbSvC];

Control.Applicative.$tc'WrapMonad3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'WrapMonad"#;

Control.Applicative.$tc'WrapMonad2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tc'WrapMonad3];

Control.Applicative.$tc'WrapMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10363415327661881286##
                                    6845751270384138997##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tc'WrapMonad2
                                    2#
                                    Control.Applicative.$tc'WrapMonad1];

Control.Applicative.$tcWrappedArrow3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrappedArrow"#;

Control.Applicative.$tcWrappedArrow2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tcWrappedArrow3];

Control.Applicative.$tcWrappedArrow :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17995829375472255965##
                                    6668242383287740398##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tcWrappedArrow2
                                    0#
                                    Control.Applicative.$tcWrappedArrow1];

$krep10_rbSvD :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rbSvt GHC.Types.[]];

$krep11_rbSvE :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rbSvu $krep10_rbSvD];

$krep12_rbSvF :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rbSvv $krep11_rbSvE];

$krep13_rbSvG :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Applicative.$tcWrappedArrow
                                              $krep12_rbSvF];

Control.Applicative.$tc'WrapArrow1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_rbSvz $krep13_rbSvG];

Control.Applicative.$tc'WrapArrow3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'WrapArrow"#;

Control.Applicative.$tc'WrapArrow2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tc'WrapArrow3];

Control.Applicative.$tc'WrapArrow :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4796259816778499037##
                                    13482613273239263357##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tc'WrapArrow2
                                    3#
                                    Control.Applicative.$tc'WrapArrow1];

Control.Applicative.$tcZipList1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$fReadZipList11];

Control.Applicative.$tcZipList :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11311650752326360483##
                                    5534599578149162946##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tcZipList1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep14_rbSvH :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Control.Applicative.$tcZipList
                                              $krep3_rbSvw];

Control.Applicative.$tc'ZipList1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_rbSvx $krep14_rbSvH];

Control.Applicative.$tc'ZipList3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'ZipList"#;

Control.Applicative.$tc'ZipList2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Control.Applicative.$tc'ZipList3];

Control.Applicative.$tc'ZipList :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15353069281551614305##
                                    7665927634319452478##
                                    Control.Applicative.$trModule
                                    Control.Applicative.$tc'ZipList2
                                    1#
                                    Control.Applicative.$tc'ZipList1];

