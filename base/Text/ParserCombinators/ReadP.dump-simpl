
==================== Tidy Core ====================
2018-03-16 15:58:00.418011306 UTC

Result size of Tidy Core
  = {terms: 1,795, types: 2,975, coercions: 667, joins: 2/48}

-- RHS size: {terms: 5, types: 5, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
  :: forall a. a -> P a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m4,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a3nO7) (x_a3nhm [Occ=Once] :: a_a3nO7) ->
                 Text.ParserCombinators.ReadP.Result
                   @ a_a3nO7 x_a3nhm (Text.ParserCombinators.ReadP.Fail @ a_a3nO7)}]
Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
  = \ (@ a_a3nO7) (x_a3nhm :: a_a3nO7) ->
      Text.ParserCombinators.ReadP.Result
        @ a_a3nO7 x_a3nhm (Text.ParserCombinators.ReadP.Fail @ a_a3nO7)

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$fMonadFailP_$cfail
  :: forall a. String -> P a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a3nNv) _ [Occ=Dead] ->
                 Text.ParserCombinators.ReadP.Fail @ a_a3nNv}]
Text.ParserCombinators.ReadP.$fMonadFailP_$cfail
  = \ (@ a_a3nNv) _ [Occ=Dead] ->
      Text.ParserCombinators.ReadP.Fail @ a_a3nNv

-- RHS size: {terms: 10, types: 18, coercions: 2, joins: 0/0}
Text.ParserCombinators.ReadP.$fFunctorReadP2
  :: forall a b.
     (a -> b) -> ReadP a -> forall b1. (b -> P b1) -> P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><C(S),1*C1(U)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a3nKO)
                 (@ b_a3nKP)
                 (h_a3ngx [Occ=Once] :: a_a3nKO -> b_a3nKP)
                 (ds_d3nUo [Occ=Once] :: ReadP a_a3nKO)
                 (@ b1_a3nKT)
                 (k_a3ngz [Occ=Once] :: b_a3nKP -> P b1_a3nKT) ->
                 (ds_d3nUo
                  `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nKO>_R
                          :: (ReadP a_a3nKO :: *)
                             ~R# (forall b. (a_a3nKO -> P b) -> P b :: *)))
                   @ b1_a3nKT (. @ b_a3nKP @ (P b1_a3nKT) @ a_a3nKO k_a3ngz h_a3ngx)}]
Text.ParserCombinators.ReadP.$fFunctorReadP2
  = \ (@ a_a3nKO)
      (@ b_a3nKP)
      (h_a3ngx :: a_a3nKO -> b_a3nKP)
      (ds_d3nUo :: ReadP a_a3nKO)
      (@ b1_a3nKT)
      (k_a3ngz :: b_a3nKP -> P b1_a3nKT) ->
      (ds_d3nUo
       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nKO>_R
               :: (ReadP a_a3nKO :: *)
                  ~R# (forall b. (a_a3nKO -> P b) -> P b :: *)))
        @ b1_a3nKT (. @ b_a3nKP @ (P b1_a3nKT) @ a_a3nKO k_a3ngz h_a3ngx)

-- RHS size: {terms: 12, types: 16, coercions: 2, joins: 0/1}
Text.ParserCombinators.ReadP.$fFunctorReadP1
  :: forall a b. a -> ReadP b -> forall b1. (a -> P b1) -> P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)><L,1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a3nL4)
                 (@ b_a3nL5)
                 (x_i1xYg [Occ=Once] :: a_a3nL4)
                 (eta_B2 [Occ=Once] :: ReadP b_a3nL5)
                 (@ b1_a3ngn)
                 (eta1_B1 [Occ=Once!] :: a_a3nL4 -> P b1_a3ngn) ->
                 let {
                   lvl4_s3o1T [Occ=OnceL] :: P b1_a3ngn
                   [LclId]
                   lvl4_s3o1T = eta1_B1 x_i1xYg } in
                 (eta_B2
                  `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <b_a3nL5>_R
                          :: (ReadP b_a3nL5 :: *)
                             ~R# (forall b. (b_a3nL5 -> P b) -> P b :: *)))
                   @ b1_a3ngn (\ _ [Occ=Dead] -> lvl4_s3o1T)}]
Text.ParserCombinators.ReadP.$fFunctorReadP1
  = \ (@ a_a3nL4)
      (@ b_a3nL5)
      (x_i1xYg :: a_a3nL4)
      (eta_B2 :: ReadP b_a3nL5)
      (@ b1_a3ngn)
      (eta1_B1 :: a_a3nL4 -> P b1_a3ngn) ->
      let {
        lvl4_s3o1T :: P b1_a3ngn
        [LclId]
        lvl4_s3o1T = eta1_B1 x_i1xYg } in
      (eta_B2
       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <b_a3nL5>_R
               :: (ReadP b_a3nL5 :: *)
                  ~R# (forall b. (b_a3nL5 -> P b) -> P b :: *)))
        @ b1_a3ngn (\ _ [Occ=Dead] -> lvl4_s3o1T)

-- RHS size: {terms: 3, types: 1, coercions: 29, joins: 0/0}
Text.ParserCombinators.ReadP.$fFunctorReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: Functor ReadP
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: ReadP
                          Text.ParserCombinators.ReadP.$fFunctorReadP2
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a -> b>_R
                                  ->_R <ReadP a>_R
                                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <b>_R)
                                  :: (forall a b.
                                      (a -> b) -> ReadP a -> forall b. (b -> P b) -> P b :: *)
                                     ~R# (forall a b. (a -> b) -> ReadP a -> ReadP b :: *))
                          Text.ParserCombinators.ReadP.$fFunctorReadP1
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a>_R
                                  ->_R <ReadP b>_R
                                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                                  :: (forall a b. a -> ReadP b -> forall b. (a -> P b) -> P b :: *)
                                     ~R# (forall a b. a -> ReadP b -> ReadP a :: *))]
Text.ParserCombinators.ReadP.$fFunctorReadP
  = GHC.Base.C:Functor
      @ ReadP
      (Text.ParserCombinators.ReadP.$fFunctorReadP2
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a -> b>_R
               ->_R <ReadP a>_R
               ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <b>_R)
               :: (forall a b.
                   (a -> b) -> ReadP a -> forall b. (b -> P b) -> P b :: *)
                  ~R# (forall a b. (a -> b) -> ReadP a -> ReadP b :: *)))
      (Text.ParserCombinators.ReadP.$fFunctorReadP1
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a>_R
               ->_R <ReadP b>_R
               ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
               :: (forall a b. a -> ReadP b -> forall b. (a -> P b) -> P b :: *)
                  ~R# (forall a b. a -> ReadP b -> ReadP a :: *)))

-- RHS size: {terms: 6, types: 8, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$fApplicativeReadP5
  :: forall a. a -> forall b. (a -> P b) -> P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a3nJP)
                 (x_a3ngv [Occ=Once] :: a_a3nJP)
                 (@ b_a3nJT)
                 (k_a3ngw [Occ=Once!] :: a_a3nJP -> P b_a3nJT) ->
                 k_a3ngw x_a3ngv}]
Text.ParserCombinators.ReadP.$fApplicativeReadP5
  = \ (@ a_a3nJP)
      (x_a3ngv :: a_a3nJP)
      (@ b_a3nJT)
      (k_a3ngw :: a_a3nJP -> P b_a3nJT) ->
      k_a3ngw x_a3ngv

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$fMonadFailReadP1
  :: forall a. String -> forall b. (a -> P b) -> P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a3nJA) _ [Occ=Dead] (@ b_a3nJE) _ [Occ=Dead] ->
                 Text.ParserCombinators.ReadP.Fail @ b_a3nJE}]
Text.ParserCombinators.ReadP.$fMonadFailReadP1
  = \ (@ a_a3nJA) _ [Occ=Dead] (@ b_a3nJE) _ [Occ=Dead] ->
      Text.ParserCombinators.ReadP.Fail @ b_a3nJE

-- RHS size: {terms: 11, types: 17, coercions: 4, joins: 0/0}
Text.ParserCombinators.ReadP.$fMonadReadP1
  :: forall a b.
     ReadP a -> (a -> ReadP b) -> forall b1. (b -> P b1) -> P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a3nIP)
                 (@ b_a3nIQ)
                 (ds_d3nTP [Occ=Once] :: ReadP a_a3nIP)
                 (f_a3ngr [Occ=OnceL!] :: a_a3nIP -> ReadP b_a3nIQ)
                 (@ b1_a3nIU)
                 (k_a3ngs [Occ=OnceL] :: b_a3nIQ -> P b1_a3nIU) ->
                 (ds_d3nTP
                  `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nIP>_R
                          :: (ReadP a_a3nIP :: *)
                             ~R# (forall b. (a_a3nIP -> P b) -> P b :: *)))
                   @ b1_a3nIU
                   (\ (a1_a3ngt [Occ=Once] :: a_a3nIP) ->
                      ((f_a3ngr a1_a3ngt)
                       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <b_a3nIQ>_R
                               :: (ReadP b_a3nIQ :: *)
                                  ~R# (forall b. (b_a3nIQ -> P b) -> P b :: *)))
                        @ b1_a3nIU k_a3ngs)}]
Text.ParserCombinators.ReadP.$fMonadReadP1
  = \ (@ a_a3nIP)
      (@ b_a3nIQ)
      (ds_d3nTP :: ReadP a_a3nIP)
      (f_a3ngr :: a_a3nIP -> ReadP b_a3nIQ)
      (@ b1_a3nIU)
      (k_a3ngs :: b_a3nIQ -> P b1_a3nIU) ->
      (ds_d3nTP
       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nIP>_R
               :: (ReadP a_a3nIP :: *)
                  ~R# (forall b. (a_a3nIP -> P b) -> P b :: *)))
        @ b1_a3nIU
        (\ (a1_a3ngt :: a_a3nIP) ->
           ((f_a3ngr a1_a3ngt)
            `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <b_a3nIQ>_R
                    :: (ReadP b_a3nIQ :: *)
                       ~R# (forall b. (b_a3nIQ -> P b) -> P b :: *)))
             @ b1_a3nIU k_a3ngs)

Rec {
-- RHS size: {terms: 41, types: 52, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap [Occ=LoopBreaker]
  :: forall a b. (a -> b) -> P a -> P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []]
Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
  = \ (@ a_a3nEl)
      (@ b_a3nEm)
      (f_a3nmS :: a_a3nEl -> b_a3nEm)
      (ds_d3nTl :: P a_a3nEl) ->
      case ds_d3nTl of {
        Get a1_a3nmT ->
          Text.ParserCombinators.ReadP.Get
            @ b_a3nEm
            (\ (b3_a3nmV :: Char) ->
               Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                 @ a_a3nEl @ b_a3nEm f_a3nmS (a1_a3nmT b3_a3nmV));
        Look a1_a3nmY ->
          Text.ParserCombinators.ReadP.Look
            @ b_a3nEm
            (\ (b3_a3nn0 :: String) ->
               Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                 @ a_a3nEl @ b_a3nEm f_a3nmS (a1_a3nmY b3_a3nn0));
        Fail -> Text.ParserCombinators.ReadP.Fail @ b_a3nEm;
        Result a1_a3nn4 a2_a3nn5 ->
          Text.ParserCombinators.ReadP.Result
            @ b_a3nEm
            (f_a3nmS a1_a3nn4)
            (Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
               @ a_a3nEl @ b_a3nEm f_a3nmS a2_a3nn5);
        Final a1_a3nn7 ->
          Text.ParserCombinators.ReadP.Final
            @ b_a3nEm
            (map
               @ (a_a3nEl, String)
               @ (b_a3nEm, String)
               (\ (b2_a3nn8 :: (a_a3nEl, String)) ->
                  case b2_a3nn8 of { (a2_a3nn9, a3_a3nna) ->
                  (f_a3nmS a2_a3nn9, a3_a3nna)
                  })
               a1_a3nn7)
      }
end Rec }

Rec {
-- RHS size: {terms: 39, types: 51, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$fApplicativeP_$c<$ [Occ=LoopBreaker]
  :: forall a b. a -> P b -> P a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,1*U>, Unf=OtherCon []]
Text.ParserCombinators.ReadP.$fApplicativeP_$c<$
  = \ (@ a_a3nFG)
      (@ b_a3nFH)
      (z_a3nnc :: a_a3nFG)
      (ds_d3nTn :: P b_a3nFH) ->
      case ds_d3nTn of {
        Get a1_a3nnd ->
          Text.ParserCombinators.ReadP.Get
            @ a_a3nFG
            (\ (b4_a3nnf :: Char) ->
               Text.ParserCombinators.ReadP.$fApplicativeP_$c<$
                 @ a_a3nFG @ b_a3nFH z_a3nnc (a1_a3nnd b4_a3nnf));
        Look a1_a3nni ->
          Text.ParserCombinators.ReadP.Look
            @ a_a3nFG
            (\ (b4_a3nnk :: String) ->
               Text.ParserCombinators.ReadP.$fApplicativeP_$c<$
                 @ a_a3nFG @ b_a3nFH z_a3nnc (a1_a3nni b4_a3nnk));
        Fail -> Text.ParserCombinators.ReadP.Fail @ a_a3nFG;
        Result a1_a3nno a2_a3nnp ->
          Text.ParserCombinators.ReadP.Result
            @ a_a3nFG
            z_a3nnc
            (Text.ParserCombinators.ReadP.$fApplicativeP_$c<$
               @ a_a3nFG @ b_a3nFH z_a3nnc a2_a3nnp);
        Final a1_a3nns ->
          Text.ParserCombinators.ReadP.Final
            @ a_a3nFG
            (map
               @ (b_a3nFH, String)
               @ (a_a3nFG, String)
               (\ (b3_a3nnt :: (b_a3nFH, String)) ->
                  case b3_a3nnt of { (a2_a3nnu, a3_a3nnv) -> (z_a3nnc, a3_a3nnv) })
               a1_a3nns)
      }
end Rec }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$fFunctorP [InlPrag=NOUSERINLINE CONLIKE]
  :: Functor P
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: P
                          Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                          Text.ParserCombinators.ReadP.$fApplicativeP_$c<$]
Text.ParserCombinators.ReadP.$fFunctorP
  = GHC.Base.C:Functor
      @ P
      Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
      Text.ParserCombinators.ReadP.$fApplicativeP_$c<$

Rec {
-- RHS size: {terms: 32, types: 40, coercions: 0, joins: 0/0}
run [Occ=LoopBreaker] :: forall a. P a -> ReadS a
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,1*U><L,U>, Unf=OtherCon []]
run
  = \ (@ a_a3nDL) (ds_d3nSx :: P a_a3nDL) (ds1_d3nSy :: [Char]) ->
      case ds_d3nSx of {
        Get f_a3nhV ->
          case ds1_d3nSy of {
            [] -> GHC.Types.[] @ (a_a3nDL, String);
            : c_a3nhW s_a3nhX -> run @ a_a3nDL (f_a3nhV c_a3nhW) s_a3nhX
          };
        Look f_a3nhY -> run @ a_a3nDL (f_a3nhY ds1_d3nSy) ds1_d3nSy;
        Fail -> GHC.Types.[] @ (a_a3nDL, String);
        Result x_a3ni0 p_a3ni1 ->
          GHC.Types.:
            @ (a_a3nDL, String)
            (x_a3ni0, ds1_d3nSy)
            (run @ a_a3nDL p_a3ni1 ds1_d3nSy);
        Final r_a3ni3 -> r_a3ni3
      }
end Rec }

-- RHS size: {terms: 32, types: 62, coercions: 0, joins: 0/1}
Text.ParserCombinators.ReadP.$wreadS_to_P [InlPrag=NOUSERINLINE[0]]
  :: forall a. ReadS a -> forall b. (a -> P b) -> (# String -> P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60] 230 20}]
Text.ParserCombinators.ReadP.$wreadS_to_P
  = \ (@ a_s3ofE)
      (w_s3ofF :: ReadS a_s3ofE)
      (@ b_s3ofG)
      (w1_s3ofH :: a_s3ofE -> P b_s3ofG) ->
      letrec {
        go_s3omv [Occ=LoopBreaker]
          :: [(a_s3ofE, String)] -> [(b_s3ofG, String)]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_s3omv
          = \ (ds_i1y1c :: [(a_s3ofE, String)]) ->
              case ds_i1y1c of {
                [] -> GHC.Types.[] @ (b_s3ofG, String);
                : y_i1y1h ys_i1y1i ->
                  case y_i1y1h of { (a1_a3njQ, s'_a3njR) ->
                  ++
                    @ (b_s3ofG, String)
                    (run @ b_s3ofG (w1_s3ofH a1_a3njQ) s'_a3njR)
                    (go_s3omv ys_i1y1i)
                  }
              }; } in
      (# \ (s_a3njP :: String) ->
           case go_s3omv (w_s3ofF s_a3njP) of wild_X2e {
             [] -> Text.ParserCombinators.ReadP.Fail @ b_s3ofG;
             : ipv_s3nWE ipv1_s3nWF ->
               Text.ParserCombinators.ReadP.Final @ b_s3ofG wild_X2e
           } #)

-- RHS size: {terms: 11, types: 20, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.readS_to_P1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. ReadS a -> forall b. (a -> P b) -> P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s3ofE)
                 (w_s3ofF [Occ=Once] :: ReadS a_s3ofE)
                 (@ b_s3ofG)
                 (w1_s3ofH [Occ=Once] :: a_s3ofE -> P b_s3ofG) ->
                 case Text.ParserCombinators.ReadP.$wreadS_to_P
                        @ a_s3ofE w_s3ofF @ b_s3ofG w1_s3ofH
                 of
                 { (# ww1_s3oiG [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
                 }}]
Text.ParserCombinators.ReadP.readS_to_P1
  = \ (@ a_s3ofE)
      (w_s3ofF :: ReadS a_s3ofE)
      (@ b_s3ofG)
      (w1_s3ofH :: a_s3ofE -> P b_s3ofG) ->
      case Text.ParserCombinators.ReadP.$wreadS_to_P
             @ a_s3ofE w_s3ofF @ b_s3ofG w1_s3ofH
      of
      { (# ww1_s3oiG #) ->
      Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
      }

-- RHS size: {terms: 1, types: 0, coercions: 9, joins: 0/0}
readS_to_P :: forall a. ReadS a -> ReadP a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.readS_to_P1
               `cast` (forall (a :: <*>_N).
                       <ReadS a>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                       :: (forall a. ReadS a -> forall b. (a -> P b) -> P b :: *)
                          ~R# (forall a. ReadS a -> ReadP a :: *))}]
readS_to_P
  = Text.ParserCombinators.ReadP.readS_to_P1
    `cast` (forall (a :: <*>_N).
            <ReadS a>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
            :: (forall a. ReadS a -> forall b. (a -> P b) -> P b :: *)
               ~R# (forall a. ReadS a -> ReadP a :: *))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_r3oqE :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl_r3oqE
  = "Text/ParserCombinators/ReadP.hs:(134,3)-(157,52)|function <|>"#

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl1_r3oqF :: forall a. P a
[GblId, Str=x]
lvl1_r3oqF
  = \ (@ a_a3nLq) ->
      Control.Exception.Base.patError
        @ 'LiftedRep @ (P a_a3nLq) lvl_r3oqE

Rec {
-- RHS size: {terms: 143, types: 139, coercions: 0, joins: 2/2}
Text.ParserCombinators.ReadP.$fAlternativeP_$c<|> [Occ=LoopBreaker]
  :: forall a. P a -> P a -> P a
[GblId, Arity=2, Str=<S,U><L,U>, Unf=OtherCon []]
Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
  = \ (@ a_a3nLq) (ds_d3nUu :: P a_a3nLq) (ds1_d3nUv :: P a_a3nLq) ->
      join {
        fail_s3o1P [Dmd=<L,1*C1(U)>] :: Void# -> P a_a3nLq
        [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
        fail_s3o1P _ [Occ=Dead, OS=OneShot]
          = case ds1_d3nUv of wild_X2t {
              __DEFAULT ->
                case ds_d3nUu of wild1_XB {
                  __DEFAULT ->
                    case wild_X2t of wild2_XC {
                      __DEFAULT ->
                        join {
                          fail1_s3o1R [Dmd=<L,1*C1(U)>] :: Void# -> P a_a3nLq
                          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
                          fail1_s3o1R _ [Occ=Dead, OS=OneShot]
                            = case wild2_XC of wild3_XE {
                                __DEFAULT ->
                                  case wild1_XB of wild4_XF {
                                    __DEFAULT ->
                                      case wild3_XE of {
                                        Get ipv_s3nWU -> lvl1_r3oqF @ a_a3nLq;
                                        Look f_a3nh6 ->
                                          Text.ParserCombinators.ReadP.Look
                                            @ a_a3nLq
                                            (\ (s_a3nh7 :: String) ->
                                               Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                                 @ a_a3nLq wild4_XF (f_a3nh6 s_a3nh7))
                                      };
                                    Look f_a3ngZ ->
                                      case wild3_XE of wild5_XH {
                                        Get ipv_s3nWX ->
                                          Text.ParserCombinators.ReadP.Look
                                            @ a_a3nLq
                                            (\ (s_a3nh4 :: String) ->
                                               Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                                 @ a_a3nLq (f_a3ngZ s_a3nh4) wild5_XH);
                                        Look g_a3nh0 ->
                                          Text.ParserCombinators.ReadP.Look
                                            @ a_a3nLq
                                            (\ (s_a3nh1 :: String) ->
                                               Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                                 @ a_a3nLq (f_a3ngZ s_a3nh1) (g_a3nh0 s_a3nh1))
                                      }
                                  };
                                Final r_a3ngX ->
                                  Text.ParserCombinators.ReadP.Look
                                    @ a_a3nLq
                                    (\ (s_a3ngY :: String) ->
                                       Text.ParserCombinators.ReadP.Final
                                         @ a_a3nLq
                                         (++
                                            @ (a_a3nLq, String)
                                            (run @ a_a3nLq wild1_XB s_a3ngY)
                                            r_a3ngX))
                              } } in
                        case wild1_XB of {
                          __DEFAULT -> jump fail1_s3o1R void#;
                          Look f_a3ngT ->
                            case wild2_XC of {
                              __DEFAULT -> jump fail1_s3o1R void#;
                              Final r_a3ngU ->
                                Text.ParserCombinators.ReadP.Look
                                  @ a_a3nLq
                                  (\ (s_a3ngV :: String) ->
                                     Text.ParserCombinators.ReadP.Final
                                       @ a_a3nLq
                                       (++
                                          @ (a_a3nLq, String)
                                          (run @ a_a3nLq (f_a3ngT s_a3ngV) s_a3ngV)
                                          r_a3ngU))
                            };
                          Final r_a3ngL ->
                            case wild2_XC of wild4_XG {
                              Get ipv_s3nX2 ->
                                Text.ParserCombinators.ReadP.Look
                                  @ a_a3nLq
                                  (\ (s_a3ngS :: String) ->
                                     Text.ParserCombinators.ReadP.Final
                                       @ a_a3nLq
                                       (++
                                          @ (a_a3nLq, String)
                                          r_a3ngL
                                          (run @ a_a3nLq wild4_XG s_a3ngS)));
                              Look f_a3ngO ->
                                Text.ParserCombinators.ReadP.Look
                                  @ a_a3nLq
                                  (\ (s_a3ngP :: String) ->
                                     Text.ParserCombinators.ReadP.Final
                                       @ a_a3nLq
                                       (++
                                          @ (a_a3nLq, String)
                                          r_a3ngL
                                          (run @ a_a3nLq (f_a3ngO s_a3ngP) s_a3ngP)));
                              Final t_a3ngM ->
                                Text.ParserCombinators.ReadP.Final
                                  @ a_a3nLq (++ @ (a_a3nLq, String) r_a3ngL t_a3ngM)
                            }
                        };
                      Fail -> wild1_XB
                    };
                  Fail -> wild_X2t
                };
              Result x_a3ngH q_a3ngI ->
                Text.ParserCombinators.ReadP.Result
                  @ a_a3nLq
                  x_a3ngH
                  (Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                     @ a_a3nLq ds_d3nUu q_a3ngI)
            } } in
      case ds_d3nUu of {
        __DEFAULT -> jump fail_s3o1P void#;
        Get f1_a3ngA ->
          case ds1_d3nUv of {
            __DEFAULT -> jump fail_s3o1P void#;
            Get f2_a3ngB ->
              Text.ParserCombinators.ReadP.Get
                @ a_a3nLq
                (\ (c_a3ngC :: Char) ->
                   Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                     @ a_a3nLq (f1_a3ngA c_a3ngC) (f2_a3ngB c_a3ngC))
          };
        Result x_a3ngD p_a3ngE ->
          Text.ParserCombinators.ReadP.Result
            @ a_a3nLq
            x_a3ngD
            (Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
               @ a_a3nLq p_a3ngE ds1_d3nUv)
      }
end Rec }

Rec {
-- RHS size: {terms: 55, types: 84, coercions: 0, joins: 0/1}
Text.ParserCombinators.ReadP.$fAlternativeP_$c>>= [Occ=LoopBreaker]
  :: forall a b. P a -> (a -> P b) -> P b
[GblId, Arity=2, Str=<S,1*U><L,C(U)>, Unf=OtherCon []]
Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
  = \ (@ a_a3nMK)
      (@ b_a3nML)
      (ds_d3nVQ :: P a_a3nMK)
      (k_a3nh9 :: a_a3nMK -> P b_a3nML) ->
      case ds_d3nVQ of {
        Get f_a3nh8 ->
          Text.ParserCombinators.ReadP.Get
            @ b_a3nML
            (\ (c_a3nha :: Char) ->
               Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                 @ a_a3nMK @ b_a3nML (f_a3nh8 c_a3nha) k_a3nh9);
        Look f_a3nhb ->
          Text.ParserCombinators.ReadP.Look
            @ b_a3nML
            (\ (s_a3nhd :: String) ->
               Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                 @ a_a3nMK @ b_a3nML (f_a3nhb s_a3nhd) k_a3nh9);
        Fail -> Text.ParserCombinators.ReadP.Fail @ b_a3nML;
        Result x_a3nhe p_a3nhf ->
          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
            @ b_a3nML
            (k_a3nh9 x_a3nhe)
            (Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
               @ a_a3nMK @ b_a3nML p_a3nhf k_a3nh9);
        Final r_a3nhh ->
          letrec {
            go_i1y1b [Occ=LoopBreaker]
              :: [(a_a3nMK, String)] -> [(b_a3nML, String)]
            [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
            go_i1y1b
              = \ (ds1_i1y1c :: [(a_a3nMK, String)]) ->
                  case ds1_i1y1c of {
                    [] -> GHC.Types.[] @ (b_a3nML, String);
                    : y_i1y1h ys_i1y1i ->
                      case y_i1y1h of { (x_a3nhj, s_a3nhk) ->
                      ++
                        @ (b_a3nML, String)
                        (run @ b_a3nML (k_a3nh9 x_a3nhj) s_a3nhk)
                        (go_i1y1b ys_i1y1i)
                      }
                  }; } in
          case go_i1y1b r_a3nhh of wild1_X2e {
            [] -> Text.ParserCombinators.ReadP.Fail @ b_a3nML;
            : ipv_s3nWE ipv1_s3nWF ->
              Text.ParserCombinators.ReadP.Final @ b_a3nML wild1_X2e
          }
      }
end Rec }

-- RHS size: {terms: 14, types: 19, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
  :: forall a b. P (a -> b) -> P a -> P b
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 110 0}]
Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
  = \ (@ a_a3nOe)
      (@ b_a3nOf)
      (m1_i1JjZ :: P (a_a3nOe -> b_a3nOf))
      (m2_i1Jk0 :: P a_a3nOe) ->
      Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
        @ (a_a3nOe -> b_a3nOf)
        @ b_a3nOf
        m1_i1JjZ
        (\ (x1_i1Jk1 :: a_a3nOe -> b_a3nOf) ->
           Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
             @ a_a3nOe
             @ b_a3nOf
             m2_i1Jk0
             (\ (x2_i1Jk2 :: a_a3nOe) ->
                Text.ParserCombinators.ReadP.Result
                  @ b_a3nOf
                  (x1_i1Jk1 x2_i1Jk2)
                  (Text.ParserCombinators.ReadP.Fail @ b_a3nOf)))

-- RHS size: {terms: 9, types: 16, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$fApplicativeP_$cliftA2
  :: forall a b c. (a -> b -> c) -> P a -> P b -> P c
[GblId,
 Arity=2,
 Str=<L,C(U)><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a3nOp)
                 (@ b_a3nOq)
                 (@ c_a3nOr)
                 (f1_i3nUm [Occ=Once] :: a_a3nOp -> b_a3nOq -> c_a3nOr)
                 (x_i3nUn [Occ=Once] :: P a_a3nOp) ->
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
                   @ b_a3nOq
                   @ c_a3nOr
                   (Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                      @ a_a3nOp @ (b_a3nOq -> c_a3nOr) f1_i3nUm x_i3nUn)}]
Text.ParserCombinators.ReadP.$fApplicativeP_$cliftA2
  = \ (@ a_a3nOp)
      (@ b_a3nOq)
      (@ c_a3nOr)
      (f1_i3nUm :: a_a3nOp -> b_a3nOq -> c_a3nOr)
      (x_i3nUn :: P a_a3nOp) ->
      Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
        @ b_a3nOq
        @ c_a3nOr
        (Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
           @ a_a3nOp @ (b_a3nOq -> c_a3nOr) f1_i3nUm x_i3nUn)

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$fAlternativeP1 :: forall a. P [a]
[GblId,
 Caf=NoCafRefs,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Text.ParserCombinators.ReadP.$fAlternativeP1
  = \ (@ a_a3nMc) ->
      Text.ParserCombinators.ReadP.Result
        @ [a_a3nMc]
        (GHC.Types.[] @ a_a3nMc)
        (Text.ParserCombinators.ReadP.Fail @ [a_a3nMc])

-- RHS size: {terms: 20, types: 39, coercions: 0, joins: 0/2}
Text.ParserCombinators.ReadP.$fAlternativeP_$csome
  :: forall a. P a -> P [a]
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 190 0}]
Text.ParserCombinators.ReadP.$fAlternativeP_$csome
  = \ (@ a_a3nMc) (v_i3nTB :: P a_a3nMc) ->
      letrec {
        some_v_s3o1L [Occ=LoopBreaker] :: P [a_a3nMc]
        [LclId]
        some_v_s3o1L
          = let {
              m2_s3o1N :: P [a_a3nMc]
              [LclId]
              m2_s3o1N
                = Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    @ [a_a3nMc]
                    some_v_s3o1L
                    (Text.ParserCombinators.ReadP.$fAlternativeP1 @ a_a3nMc) } in
            Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
              @ ([a_a3nMc] -> [a_a3nMc])
              @ [a_a3nMc]
              (Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                 @ a_a3nMc
                 @ ([a_a3nMc] -> [a_a3nMc])
                 (GHC.Types.: @ a_a3nMc)
                 v_i3nTB)
              (\ (x1_i1Jk1 :: [a_a3nMc] -> [a_a3nMc]) ->
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                   @ [a_a3nMc]
                   @ [a_a3nMc]
                   m2_s3o1N
                   (\ (x2_i1Jk2 :: [a_a3nMc]) ->
                      Text.ParserCombinators.ReadP.Result
                        @ [a_a3nMc]
                        (x1_i1Jk1 x2_i1Jk2)
                        (Text.ParserCombinators.ReadP.Fail @ [a_a3nMc]))); } in
      some_v_s3o1L

-- RHS size: {terms: 7, types: 13, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$fApplicativeP_$c<*
  :: forall a b. P a -> P b -> P a
[GblId,
 Arity=1,
 Str=<L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a3nOL)
                 (@ b_a3nOM)
                 (x_i3nUn [Occ=Once] :: P a_a3nOL) ->
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
                   @ b_a3nOM
                   @ a_a3nOL
                   (Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                      @ a_a3nOL
                      @ (b_a3nOM -> a_a3nOL)
                      (const @ a_a3nOL @ b_a3nOM)
                      x_i3nUn)}]
Text.ParserCombinators.ReadP.$fApplicativeP_$c<*
  = \ (@ a_a3nOL) (@ b_a3nOM) (x_i3nUn :: P a_a3nOL) ->
      Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
        @ b_a3nOM
        @ a_a3nOL
        (Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
           @ a_a3nOL
           @ (b_a3nOM -> a_a3nOL)
           (const @ a_a3nOL @ b_a3nOM)
           x_i3nUn)

-- RHS size: {terms: 9, types: 14, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$fApplicativeP_$c*>
  :: forall a b. P a -> P b -> P b
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a3nOB)
                 (@ b_a3nOC)
                 (a1_i1xXL [Occ=Once] :: P a_a3nOB)
                 (a2_i1xXM [Occ=Once] :: P b_a3nOC) ->
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
                   @ b_a3nOC
                   @ b_a3nOC
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$c<$
                      @ (b_a3nOC -> b_a3nOC) @ a_a3nOB (breakpoint @ b_a3nOC) a1_i1xXL)
                   a2_i1xXM}]
Text.ParserCombinators.ReadP.$fApplicativeP_$c*>
  = \ (@ a_a3nOB)
      (@ b_a3nOC)
      (a1_i1xXL :: P a_a3nOB)
      (a2_i1xXM :: P b_a3nOC) ->
      Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
        @ b_a3nOC
        @ b_a3nOC
        (Text.ParserCombinators.ReadP.$fApplicativeP_$c<$
           @ (b_a3nOC -> b_a3nOC) @ a_a3nOB (breakpoint @ b_a3nOC) a1_i1xXL)
        a2_i1xXM

-- RHS size: {terms: 11, types: 20, coercions: 0, joins: 0/1}
Text.ParserCombinators.ReadP.$fAlternativeP_$cmany
  :: forall a. P a -> P [a]
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 100 0}]
Text.ParserCombinators.ReadP.$fAlternativeP_$cmany
  = \ (@ a_a3nMk) (v_i3nTH :: P a_a3nMk) ->
      letrec {
        many_v_s3o1J [Occ=LoopBreaker] :: P [a_a3nMk]
        [LclId]
        many_v_s3o1J
          = Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
              @ [a_a3nMk]
              (Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
                 @ [a_a3nMk]
                 @ [a_a3nMk]
                 (Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                    @ a_a3nMk
                    @ ([a_a3nMk] -> [a_a3nMk])
                    (GHC.Types.: @ a_a3nMk)
                    v_i3nTH)
                 many_v_s3o1J)
              (Text.ParserCombinators.ReadP.$fAlternativeP1 @ a_a3nMk); } in
      many_v_s3o1J

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$fMonadP_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b. P a -> P b -> P b
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a3nNd)
                 (@ b_a3nNe)
                 (m1_i3nU4 [Occ=Once] :: P a_a3nNd)
                 (k_i3nU5 [Occ=OnceL] :: P b_a3nNe) ->
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                   @ a_a3nNd @ b_a3nNe m1_i3nU4 (\ _ [Occ=Dead] -> k_i3nU5)}]
Text.ParserCombinators.ReadP.$fMonadP_$c>>
  = \ (@ a_a3nNd)
      (@ b_a3nNe)
      (eta_X2L :: P a_a3nNd)
      (eta1_B1 :: P b_a3nNe) ->
      Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
        @ a_a3nNd @ b_a3nNe eta_X2L (\ _ [Occ=Dead] -> eta1_B1)

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$fApplicativeP [InlPrag=NOUSERINLINE CONLIKE]
  :: Applicative P
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Applicative TYPE: P
                              Text.ParserCombinators.ReadP.$fFunctorP
                              Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                              Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
                              Text.ParserCombinators.ReadP.$fApplicativeP_$cliftA2
                              Text.ParserCombinators.ReadP.$fApplicativeP_$c*>
                              Text.ParserCombinators.ReadP.$fApplicativeP_$c<*]
Text.ParserCombinators.ReadP.$fApplicativeP
  = GHC.Base.C:Applicative
      @ P
      Text.ParserCombinators.ReadP.$fFunctorP
      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
      Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
      Text.ParserCombinators.ReadP.$fApplicativeP_$cliftA2
      Text.ParserCombinators.ReadP.$fApplicativeP_$c*>
      Text.ParserCombinators.ReadP.$fApplicativeP_$c<*

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$fMonadP [InlPrag=NOUSERINLINE CONLIKE]
  :: Monad P
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Monad TYPE: P
                        Text.ParserCombinators.ReadP.$fApplicativeP
                        Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                        Text.ParserCombinators.ReadP.$fMonadP_$c>>
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                        Text.ParserCombinators.ReadP.$fMonadFailP_$cfail]
Text.ParserCombinators.ReadP.$fMonadP
  = GHC.Base.C:Monad
      @ P
      Text.ParserCombinators.ReadP.$fApplicativeP
      Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
      Text.ParserCombinators.ReadP.$fMonadP_$c>>
      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
      Text.ParserCombinators.ReadP.$fMonadFailP_$cfail

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$fAlternativeP [InlPrag=NOUSERINLINE CONLIKE]
  :: Alternative P
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Alternative TYPE: P
                              Text.ParserCombinators.ReadP.$fApplicativeP
                              Text.ParserCombinators.ReadP.Fail
                              Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                              Text.ParserCombinators.ReadP.$fAlternativeP_$csome
                              Text.ParserCombinators.ReadP.$fAlternativeP_$cmany]
Text.ParserCombinators.ReadP.$fAlternativeP
  = GHC.Base.C:Alternative
      @ P
      Text.ParserCombinators.ReadP.$fApplicativeP
      Text.ParserCombinators.ReadP.Fail
      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
      Text.ParserCombinators.ReadP.$fAlternativeP_$csome
      Text.ParserCombinators.ReadP.$fAlternativeP_$cmany

-- RHS size: {terms: 5, types: 7, coercions: 2, joins: 0/0}
readP_to_S :: forall a. ReadP a -> ReadS a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a3nDT) (ds_d3nST [Occ=Once] :: ReadP a_a3nDT) ->
                 run
                   @ a_a3nDT
                   ((ds_d3nST
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nDT>_R
                             :: (ReadP a_a3nDT :: *)
                                ~R# (forall b. (a_a3nDT -> P b) -> P b :: *)))
                      @ a_a3nDT
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ a_a3nDT))}]
readP_to_S
  = \ (@ a_a3nDT) (ds_d3nST :: ReadP a_a3nDT) ->
      run
        @ a_a3nDT
        ((ds_d3nST
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nDT>_R
                  :: (ReadP a_a3nDT :: *)
                     ~R# (forall b. (a_a3nDT -> P b) -> P b :: *)))
           @ a_a3nDT
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ a_a3nDT))

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$fMonadFailP [InlPrag=NOUSERINLINE CONLIKE]
  :: MonadFail P
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Control.Monad.Fail.C:MonadFail TYPE: P
                                      Text.ParserCombinators.ReadP.$fMonadP
                                      Text.ParserCombinators.ReadP.$fMonadFailP_$cfail]
Text.ParserCombinators.ReadP.$fMonadFailP
  = Control.Monad.Fail.C:MonadFail
      @ P
      Text.ParserCombinators.ReadP.$fMonadP
      Text.ParserCombinators.ReadP.$fMonadFailP_$cfail

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$fMonadPlusP [InlPrag=NOUSERINLINE CONLIKE]
  :: MonadPlus P
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:MonadPlus TYPE: P
                            Text.ParserCombinators.ReadP.$fAlternativeP
                            Text.ParserCombinators.ReadP.$fMonadP
                            Text.ParserCombinators.ReadP.Fail
                            Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>]
Text.ParserCombinators.ReadP.$fMonadPlusP
  = GHC.Base.C:MonadPlus
      @ P
      Text.ParserCombinators.ReadP.$fAlternativeP
      Text.ParserCombinators.ReadP.$fMonadP
      Text.ParserCombinators.ReadP.Fail
      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
get :: ReadP Char
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m1,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.Get
               `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <Char>_R)
                       :: (forall b. (Char -> P b) -> P b :: *) ~R# (ReadP Char :: *))}]
get
  = Text.ParserCombinators.ReadP.Get
    `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <Char>_R)
            :: (forall b. (Char -> P b) -> P b :: *) ~R# (ReadP Char :: *))

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
look :: ReadP String
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.Look
               `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <String>_R)
                       :: (forall b. (String -> P b) -> P b :: *)
                          ~R# (ReadP String :: *))}]
look
  = Text.ParserCombinators.ReadP.Look
    `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <String>_R)
            :: (forall b. (String -> P b) -> P b :: *) ~R# (ReadP String :: *))

-- RHS size: {terms: 4, types: 8, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$fAlternativeReadP4
  :: forall a b. (a -> P b) -> P b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a3nz6) (@ b_X3nBR) _ [Occ=Dead] ->
                 Text.ParserCombinators.ReadP.Fail @ b_X3nBR}]
Text.ParserCombinators.ReadP.$fAlternativeReadP4
  = \ (@ a_a3nz6) (@ b_X3nBR) _ [Occ=Dead] ->
      Text.ParserCombinators.ReadP.Fail @ b_X3nBR

-- RHS size: {terms: 1, types: 0, coercions: 6, joins: 0/0}
pfail :: forall a. ReadP a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.$fAlternativeReadP4
               `cast` (forall (a :: <*>_N).
                       Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                       :: (forall a b. (a -> P b) -> P b :: *)
                          ~R# (forall a. ReadP a :: *))}]
pfail
  = Text.ParserCombinators.ReadP.$fAlternativeReadP4
    `cast` (forall (a :: <*>_N).
            Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
            :: (forall a b. (a -> P b) -> P b :: *)
               ~R# (forall a. ReadP a :: *))

-- RHS size: {terms: 10, types: 14, coercions: 4, joins: 0/0}
Text.ParserCombinators.ReadP.$fAlternativeReadP3
  :: forall a. ReadP a -> ReadP a -> forall b. (a -> P b) -> P b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a3nvF)
                 (ds_d3nQ2 [Occ=Once] :: ReadP a_a3nvF)
                 (ds1_d3nQ3 [Occ=Once] :: ReadP a_a3nvF)
                 (@ b_a3nvJ)
                 (k_a3ni6 :: a_a3nvF -> P b_a3nvJ) ->
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b_a3nvJ
                   ((ds_d3nQ2
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nvF>_R
                             :: (ReadP a_a3nvF :: *)
                                ~R# (forall b. (a_a3nvF -> P b) -> P b :: *)))
                      @ b_a3nvJ k_a3ni6)
                   ((ds1_d3nQ3
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nvF>_R
                             :: (ReadP a_a3nvF :: *)
                                ~R# (forall b. (a_a3nvF -> P b) -> P b :: *)))
                      @ b_a3nvJ k_a3ni6)}]
Text.ParserCombinators.ReadP.$fAlternativeReadP3
  = \ (@ a_a3nvF)
      (ds_d3nQ2 :: ReadP a_a3nvF)
      (ds1_d3nQ3 :: ReadP a_a3nvF)
      (@ b_a3nvJ)
      (k_a3ni6 :: a_a3nvF -> P b_a3nvJ) ->
      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
        @ b_a3nvJ
        ((ds_d3nQ2
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nvF>_R
                  :: (ReadP a_a3nvF :: *)
                     ~R# (forall b. (a_a3nvF -> P b) -> P b :: *)))
           @ b_a3nvJ k_a3ni6)
        ((ds1_d3nQ3
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nvF>_R
                  :: (ReadP a_a3nvF :: *)
                     ~R# (forall b. (a_a3nvF -> P b) -> P b :: *)))
           @ b_a3nvJ k_a3ni6)

-- RHS size: {terms: 1, types: 0, coercions: 12, joins: 0/0}
+++ :: forall a. ReadP a -> ReadP a -> ReadP a
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.$fAlternativeReadP3
               `cast` (forall (a :: <*>_N).
                       <ReadP a>_R
                       ->_R <ReadP a>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                       :: (forall a.
                           ReadP a -> ReadP a -> forall b. (a -> P b) -> P b :: *)
                          ~R# (forall a. ReadP a -> ReadP a -> ReadP a :: *))}]
+++
  = Text.ParserCombinators.ReadP.$fAlternativeReadP3
    `cast` (forall (a :: <*>_N).
            <ReadP a>_R
            ->_R <ReadP a>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
            :: (forall a.
                ReadP a -> ReadP a -> forall b. (a -> P b) -> P b :: *)
               ~R# (forall a. ReadP a -> ReadP a -> ReadP a :: *))

Rec {
-- RHS size: {terms: 22, types: 33, coercions: 10, joins: 0/1}
choice [Occ=LoopBreaker] :: forall a. [ReadP a] -> ReadP a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
choice
  = \ (@ a_a3nzc) (ds_d3nQH :: [ReadP a_a3nzc]) ->
      case ds_d3nQH of {
        [] ->
          (Text.ParserCombinators.ReadP.$fAlternativeReadP4 @ a_a3nzc)
          `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nzc>_R)
                  :: (forall b. (a_a3nzc -> P b) -> P b :: *)
                     ~R# (ReadP a_a3nzc :: *));
        : p_a3niW ds1_d3nQR ->
          case ds1_d3nQR of wild1_XL {
            [] -> p_a3niW;
            : ipv_s3nXe ipv1_s3nXf ->
              let {
                ds2_s3o1H [Dmd=<L,C(U)>] :: ReadP a_a3nzc
                [LclId]
                ds2_s3o1H = choice @ a_a3nzc wild1_XL } in
              (\ (@ b_a3nvJ) (k_a3ni6 :: a_a3nzc -> P b_a3nvJ) ->
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b_a3nvJ
                   ((p_a3niW
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nzc>_R
                             :: (ReadP a_a3nzc :: *)
                                ~R# (forall b. (a_a3nzc -> P b) -> P b :: *)))
                      @ b_a3nvJ k_a3ni6)
                   ((ds2_s3o1H
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nzc>_R
                             :: (ReadP a_a3nzc :: *)
                                ~R# (forall b. (a_a3nzc -> P b) -> P b :: *)))
                      @ b_a3nvJ k_a3ni6))
              `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nzc>_R)
                      :: (forall b. (a_a3nzc -> P b) -> P b :: *)
                         ~R# (ReadP a_a3nzc :: *))
          }
      }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl2_r3oqG :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl2_r3oqG = "do not use readS_to_P in gather!"#

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
lvl3_r3oqH :: forall b. P b
[GblId, Str=x]
lvl3_r3oqH
  = \ (@ b_a3nv3) ->
      errorWithoutStackTrace
        @ 'LiftedRep @ (P b_a3nv3) (unpackCString# lvl2_r3oqG)

Rec {
-- RHS size: {terms: 35, types: 49, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.gather_gath [Occ=LoopBreaker]
  :: forall b. (String -> String) -> P (String -> P b) -> P b
[GblId, Arity=2, Str=<L,C(U)><S,1*U>, Unf=OtherCon []]
Text.ParserCombinators.ReadP.gather_gath
  = \ (@ b_a3nv3)
      (l_a3niq :: String -> String)
      (ds_d3nPK :: P (String -> P b_a3nv3)) ->
      case ds_d3nPK of {
        Get f_a3nir ->
          Text.ParserCombinators.ReadP.Get
            @ b_a3nv3
            (\ (c_a3nis :: Char) ->
               Text.ParserCombinators.ReadP.gather_gath
                 @ b_a3nv3
                 (\ (x_i1Mhr :: [Char]) ->
                    l_a3niq (GHC.Types.: @ Char c_a3nis x_i1Mhr))
                 (f_a3nir c_a3nis));
        Look f_a3niu ->
          Text.ParserCombinators.ReadP.Look
            @ b_a3nv3
            (\ (s_a3niv :: String) ->
               Text.ParserCombinators.ReadP.gather_gath
                 @ b_a3nv3 l_a3niq (f_a3niu s_a3niv));
        Fail -> Text.ParserCombinators.ReadP.Fail @ b_a3nv3;
        Result k_a3nix p_a3niy ->
          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
            @ b_a3nv3
            (k_a3nix (l_a3niq (GHC.Types.[] @ Char)))
            (Text.ParserCombinators.ReadP.gather_gath
               @ b_a3nv3 l_a3niq p_a3niy);
        Final ds1_d3nQ1 -> lvl3_r3oqH @ b_a3nv3
      }
end Rec }

-- RHS size: {terms: 15, types: 26, coercions: 2, joins: 0/0}
Text.ParserCombinators.ReadP.gather1
  :: forall a. ReadP a -> forall b. ((String, a) -> P b) -> P b
[GblId,
 Arity=2,
 Str=<C(S),1*C1(U)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60] 110 0}]
Text.ParserCombinators.ReadP.gather1
  = \ (@ a_a3nuK)
      (ds_d3nPD :: ReadP a_a3nuK)
      (@ b_a3ngn)
      (eta_B1 :: (String, a_a3nuK) -> P b_a3ngn) ->
      Text.ParserCombinators.ReadP.gather_gath
        @ b_a3ngn
        (id @ String)
        ((ds_d3nPD
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nuK>_R
                  :: (ReadP a_a3nuK :: *)
                     ~R# (forall b. (a_a3nuK -> P b) -> P b :: *)))
           @ (String -> P b_a3ngn)
           (\ (a1_a3niA :: a_a3nuK) ->
              Text.ParserCombinators.ReadP.Result
                @ (String -> P b_a3ngn)
                (\ (s_a3niB :: String) -> eta_B1 (s_a3niB, a1_a3niA))
                (Text.ParserCombinators.ReadP.Fail @ (String -> P b_a3ngn))))

-- RHS size: {terms: 1, types: 0, coercions: 11, joins: 0/0}
gather :: forall a. ReadP a -> ReadP (String, a)
[GblId,
 Arity=2,
 Str=<C(S),1*C1(U)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.gather1
               `cast` (forall (a :: <*>_N).
                       <ReadP a>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <(String, a)>_R)
                       :: (forall a.
                           ReadP a -> forall b. ((String, a) -> P b) -> P b :: *)
                          ~R# (forall a. ReadP a -> ReadP (String, a) :: *))}]
gather
  = Text.ParserCombinators.ReadP.gather1
    `cast` (forall (a :: <*>_N).
            <ReadP a>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <(String, a)>_R)
            :: (forall a.
                ReadP a -> forall b. ((String, a) -> P b) -> P b :: *)
               ~R# (forall a. ReadP a -> ReadP (String, a) :: *))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Text.ParserCombinators.ReadP.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Text.ParserCombinators.ReadP.$trModule3
  = GHC.Types.TrNameS Text.ParserCombinators.ReadP.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 80 0}]
Text.ParserCombinators.ReadP.$trModule2
  = "Text.ParserCombinators.ReadP"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Text.ParserCombinators.ReadP.$trModule1
  = GHC.Types.TrNameS Text.ParserCombinators.ReadP.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Text.ParserCombinators.ReadP.$trModule
  = GHC.Types.Module
      Text.ParserCombinators.ReadP.$trModule3
      Text.ParserCombinators.ReadP.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_r3oqI :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_r3oqI
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcChar (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep1_r3oqJ :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep1_r3oqJ
  = GHC.Types.: @ KindRep $krep_r3oqI (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep2_r3oqK :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep2_r3oqK
  = GHC.Types.KindRepTyConApp GHC.Types.$tc[] $krep1_r3oqJ

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep3_r3oqL :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep3_r3oqL = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep4_r3oqM :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep4_r3oqM
  = GHC.Types.: @ KindRep $krep2_r3oqK (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep5_r3oqN :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep5_r3oqN = GHC.Types.: @ KindRep $krep3_r3oqL $krep4_r3oqM

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep6_r3oqO :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep6_r3oqO
  = GHC.Types.KindRepTyConApp GHC.Tuple.$tc(,) $krep5_r3oqN

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep7_r3oqP :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep7_r3oqP
  = GHC.Types.: @ KindRep $krep6_r3oqO (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep8_r3oqQ :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep8_r3oqQ
  = GHC.Types.KindRepTyConApp GHC.Types.$tc[] $krep7_r3oqP

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tcP2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Text.ParserCombinators.ReadP.$tcP2 = "P"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tcP1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Text.ParserCombinators.ReadP.$tcP1
  = GHC.Types.TrNameS Text.ParserCombinators.ReadP.$tcP2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tcP :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Text.ParserCombinators.ReadP.$tcP
  = GHC.Types.TyCon
      4287589432649596960##
      9029773818181158220##
      Text.ParserCombinators.ReadP.$trModule
      Text.ParserCombinators.ReadP.$tcP1
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep9_r3oqR :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep9_r3oqR
  = GHC.Types.: @ KindRep $krep3_r3oqL (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Fail1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
Text.ParserCombinators.ReadP.$tc'Fail1
  = GHC.Types.KindRepTyConApp
      Text.ParserCombinators.ReadP.$tcP $krep9_r3oqR

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Fail3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Text.ParserCombinators.ReadP.$tc'Fail3 = "'Fail"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Fail2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Text.ParserCombinators.ReadP.$tc'Fail2
  = GHC.Types.TrNameS Text.ParserCombinators.ReadP.$tc'Fail3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Fail :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Text.ParserCombinators.ReadP.$tc'Fail
  = GHC.Types.TyCon
      16564457091671581868##
      4540703186775139959##
      Text.ParserCombinators.ReadP.$trModule
      Text.ParserCombinators.ReadP.$tc'Fail2
      1#
      Text.ParserCombinators.ReadP.$tc'Fail1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep10_r3oqS :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep10_r3oqS
  = GHC.Types.KindRepFun
      Text.ParserCombinators.ReadP.$tc'Fail1
      Text.ParserCombinators.ReadP.$tc'Fail1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Result1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Text.ParserCombinators.ReadP.$tc'Result1
  = GHC.Types.KindRepFun $krep3_r3oqL $krep10_r3oqS

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Result3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Text.ParserCombinators.ReadP.$tc'Result3 = "'Result"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Result2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Text.ParserCombinators.ReadP.$tc'Result2
  = GHC.Types.TrNameS Text.ParserCombinators.ReadP.$tc'Result3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Result :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Text.ParserCombinators.ReadP.$tc'Result
  = GHC.Types.TyCon
      14629176799732153257##
      2029199220309899277##
      Text.ParserCombinators.ReadP.$trModule
      Text.ParserCombinators.ReadP.$tc'Result2
      1#
      Text.ParserCombinators.ReadP.$tc'Result1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Final1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Text.ParserCombinators.ReadP.$tc'Final1
  = GHC.Types.KindRepFun
      $krep8_r3oqQ Text.ParserCombinators.ReadP.$tc'Fail1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Final3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Text.ParserCombinators.ReadP.$tc'Final3 = "'Final"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Final2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Text.ParserCombinators.ReadP.$tc'Final2
  = GHC.Types.TrNameS Text.ParserCombinators.ReadP.$tc'Final3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Final :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Text.ParserCombinators.ReadP.$tc'Final
  = GHC.Types.TyCon
      9825883373667767852##
      1277540149077833820##
      Text.ParserCombinators.ReadP.$trModule
      Text.ParserCombinators.ReadP.$tc'Final2
      1#
      Text.ParserCombinators.ReadP.$tc'Final1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep11_r3oqT :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep11_r3oqT
  = GHC.Types.KindRepFun
      $krep2_r3oqK Text.ParserCombinators.ReadP.$tc'Fail1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Look1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Text.ParserCombinators.ReadP.$tc'Look1
  = GHC.Types.KindRepFun
      $krep11_r3oqT Text.ParserCombinators.ReadP.$tc'Fail1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Look3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Text.ParserCombinators.ReadP.$tc'Look3 = "'Look"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Look2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Text.ParserCombinators.ReadP.$tc'Look2
  = GHC.Types.TrNameS Text.ParserCombinators.ReadP.$tc'Look3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Look :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Text.ParserCombinators.ReadP.$tc'Look
  = GHC.Types.TyCon
      11302519862508684236##
      969530656846011597##
      Text.ParserCombinators.ReadP.$trModule
      Text.ParserCombinators.ReadP.$tc'Look2
      1#
      Text.ParserCombinators.ReadP.$tc'Look1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep12_r3oqU :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep12_r3oqU
  = GHC.Types.KindRepFun
      $krep_r3oqI Text.ParserCombinators.ReadP.$tc'Fail1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Get1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Text.ParserCombinators.ReadP.$tc'Get1
  = GHC.Types.KindRepFun
      $krep12_r3oqU Text.ParserCombinators.ReadP.$tc'Fail1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Get3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Text.ParserCombinators.ReadP.$tc'Get3 = "'Get"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Get2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Text.ParserCombinators.ReadP.$tc'Get2
  = GHC.Types.TrNameS Text.ParserCombinators.ReadP.$tc'Get3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tc'Get :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Text.ParserCombinators.ReadP.$tc'Get
  = GHC.Types.TyCon
      10806119809527641225##
      14618661019746688366##
      Text.ParserCombinators.ReadP.$trModule
      Text.ParserCombinators.ReadP.$tc'Get2
      1#
      Text.ParserCombinators.ReadP.$tc'Get1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tcReadP2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Text.ParserCombinators.ReadP.$tcReadP2 = "ReadP"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tcReadP1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Text.ParserCombinators.ReadP.$tcReadP1
  = GHC.Types.TrNameS Text.ParserCombinators.ReadP.$tcReadP2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$tcReadP :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Text.ParserCombinators.ReadP.$tcReadP
  = GHC.Types.TyCon
      15640243629783811470##
      8988027559298507146##
      Text.ParserCombinators.ReadP.$trModule
      Text.ParserCombinators.ReadP.$tcReadP1
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 13, types: 19, coercions: 5, joins: 0/0}
Text.ParserCombinators.ReadP.$fApplicativeReadP4
  :: forall b a.
     ReadP (a -> b) -> ReadP a -> forall b1. (b -> P b1) -> P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a3nK1)
                 (@ a_a3nK0)
                 (m1_X1JnJ [Occ=Once] :: ReadP (a_a3nK0 -> b_a3nK1))
                 (m2_X1JnL [Occ=OnceL] :: ReadP a_a3nK0)
                 (@ b1_a3nIU)
                 (k_a3ngs [Occ=OnceL!] :: b_a3nK1 -> P b1_a3nIU) ->
                 (m1_X1JnJ
                  `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <a_a3nK0 -> b_a3nK1>_R
                          :: (ReadP (a_a3nK0 -> b_a3nK1) :: *)
                             ~R# (forall b. ((a_a3nK0 -> b_a3nK1) -> P b) -> P b :: *)))
                   @ b1_a3nIU
                   (\ (a1_a3ngt [Occ=OnceL!] :: a_a3nK0 -> b_a3nK1) ->
                      (m2_X1JnL
                       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nK0>_R
                               :: (ReadP a_a3nK0 :: *)
                                  ~R# (forall b. (a_a3nK0 -> P b) -> P b :: *)))
                        @ b1_a3nIU
                        (\ (a2_X3nki [Occ=Once] :: a_a3nK0) ->
                           k_a3ngs (a1_a3ngt a2_X3nki)))}]
Text.ParserCombinators.ReadP.$fApplicativeReadP4
  = \ (@ b_a3nK1)
      (@ a_a3nK0)
      (m1_X1JnJ :: ReadP (a_a3nK0 -> b_a3nK1))
      (m2_X1JnL :: ReadP a_a3nK0)
      (@ b1_a3nIU)
      (k_a3ngs :: b_a3nK1 -> P b1_a3nIU) ->
      (m1_X1JnJ
       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                   <a_a3nK0 -> b_a3nK1>_R
               :: (ReadP (a_a3nK0 -> b_a3nK1) :: *)
                  ~R# (forall b. ((a_a3nK0 -> b_a3nK1) -> P b) -> P b :: *)))
        @ b1_a3nIU
        (\ (a1_a3ngt :: a_a3nK0 -> b_a3nK1) ->
           (m2_X1JnL
            `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nK0>_R
                    :: (ReadP a_a3nK0 :: *)
                       ~R# (forall b. (a_a3nK0 -> P b) -> P b :: *)))
             @ b1_a3nIU
             (\ (a2_X3nki :: a_a3nK0) -> k_a3ngs (a1_a3ngt a2_X3nki)))

-- RHS size: {terms: 14, types: 19, coercions: 4, joins: 0/1}
Text.ParserCombinators.ReadP.$fApplicativeReadP2
  :: forall a b. ReadP a -> ReadP b -> forall b1. (b -> P b1) -> P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a3nKs)
                 (@ b_a3nKt)
                 (a1_i1xXL [Occ=Once] :: ReadP a_a3nKs)
                 (a2_i1xXM :: ReadP b_a3nKt)
                 (@ b1_a3ngn)
                 (eta_B1 [Occ=OnceL!] :: b_a3nKt -> P b1_a3ngn) ->
                 let {
                   lvl4_s3o28 [Occ=OnceL] :: P b1_a3ngn
                   [LclId]
                   lvl4_s3o28
                     = (a2_i1xXM
                        `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <b_a3nKt>_R
                                :: (ReadP b_a3nKt :: *)
                                   ~R# (forall b. (b_a3nKt -> P b) -> P b :: *)))
                         @ b1_a3ngn
                         (\ (a4_X3nki [Occ=Once] :: b_a3nKt) -> eta_B1 a4_X3nki) } in
                 (a1_i1xXL
                  `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nKs>_R
                          :: (ReadP a_a3nKs :: *)
                             ~R# (forall b. (a_a3nKs -> P b) -> P b :: *)))
                   @ b1_a3ngn (\ _ [Occ=Dead] -> lvl4_s3o28)}]
Text.ParserCombinators.ReadP.$fApplicativeReadP2
  = \ (@ a_a3nKs)
      (@ b_a3nKt)
      (a1_i1xXL :: ReadP a_a3nKs)
      (a2_i1xXM :: ReadP b_a3nKt)
      (@ b1_a3ngn)
      (eta_B1 :: b_a3nKt -> P b1_a3ngn) ->
      let {
        lvl4_s3o28 :: P b1_a3ngn
        [LclId]
        lvl4_s3o28
          = (a2_i1xXM
             `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <b_a3nKt>_R
                     :: (ReadP b_a3nKt :: *)
                        ~R# (forall b. (b_a3nKt -> P b) -> P b :: *)))
              @ b1_a3ngn (\ (a4_X3nki :: b_a3nKt) -> eta_B1 a4_X3nki) } in
      (a1_i1xXL
       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nKs>_R
               :: (ReadP a_a3nKs :: *)
                  ~R# (forall b. (a_a3nKs -> P b) -> P b :: *)))
        @ b1_a3ngn (\ _ [Occ=Dead] -> lvl4_s3o28)

-- RHS size: {terms: 18, types: 24, coercions: 4, joins: 0/1}
Text.ParserCombinators.ReadP.$fApplicativeReadP3
  :: forall a b c.
     (a -> b -> c)
     -> ReadP a -> ReadP b -> forall b1. (c -> P b1) -> P b1
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C(U))><C(S),1*C1(U)><L,C(U)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 60 60] 130 0}]
Text.ParserCombinators.ReadP.$fApplicativeReadP3
  = \ (@ a_a3nKg)
      (@ b_a3nKh)
      (@ c_a3nKi)
      (f1_i3nUm :: a_a3nKg -> b_a3nKh -> c_a3nKi)
      (x_i3nUn :: ReadP a_a3nKg)
      (eta_B2 :: ReadP b_a3nKh)
      (@ b1_a3ngn)
      (eta1_B1 :: c_a3nKi -> P b1_a3ngn) ->
      (x_i3nUn
       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nKg>_R
               :: (ReadP a_a3nKg :: *)
                  ~R# (forall b. (a_a3nKg -> P b) -> P b :: *)))
        @ b1_a3ngn
        (\ (x1_i1Mhr :: a_a3nKg) ->
           let {
             a1_s3o1D [Dmd=<L,C(U)>] :: b_a3nKh -> c_a3nKi
             [LclId]
             a1_s3o1D = f1_i3nUm x1_i1Mhr } in
           (eta_B2
            `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <b_a3nKh>_R
                    :: (ReadP b_a3nKh :: *)
                       ~R# (forall b. (b_a3nKh -> P b) -> P b :: *)))
             @ b1_a3ngn
             (\ (a2_X3nki :: b_a3nKh) -> eta1_B1 (a1_s3o1D a2_X3nki)))

-- RHS size: {terms: 14, types: 19, coercions: 4, joins: 0/1}
Text.ParserCombinators.ReadP.$fApplicativeReadP1
  :: forall b a. ReadP a -> ReadP b -> forall b1. (a -> P b1) -> P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a3nKD)
                 (@ a_a3nKC)
                 (x_X3o2i [Occ=Once] :: ReadP a_a3nKC)
                 (eta_X7Z [Occ=OnceL] :: ReadP b_a3nKD)
                 (@ b1_X3nkp)
                 (eta1_X44 [Occ=OnceL!] :: a_a3nKC -> P b1_X3nkp) ->
                 (x_X3o2i
                  `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nKC>_R
                          :: (ReadP a_a3nKC :: *)
                             ~R# (forall b. (a_a3nKC -> P b) -> P b :: *)))
                   @ b1_X3nkp
                   (\ (x1_i1Mhr [Occ=Once] :: a_a3nKC) ->
                      let {
                        lvl4_s3o29 [Occ=OnceL] :: P b1_X3nkp
                        [LclId]
                        lvl4_s3o29 = eta1_X44 x1_i1Mhr } in
                      (eta_X7Z
                       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <b_a3nKD>_R
                               :: (ReadP b_a3nKD :: *)
                                  ~R# (forall b. (b_a3nKD -> P b) -> P b :: *)))
                        @ b1_X3nkp (\ _ [Occ=Dead] -> lvl4_s3o29))}]
Text.ParserCombinators.ReadP.$fApplicativeReadP1
  = \ (@ b_a3nKD)
      (@ a_a3nKC)
      (x_X3o2i :: ReadP a_a3nKC)
      (eta_X7Z :: ReadP b_a3nKD)
      (@ b1_X3nkp)
      (eta1_X44 :: a_a3nKC -> P b1_X3nkp) ->
      (x_X3o2i
       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nKC>_R
               :: (ReadP a_a3nKC :: *)
                  ~R# (forall b. (a_a3nKC -> P b) -> P b :: *)))
        @ b1_X3nkp
        (\ (x1_i1Mhr :: a_a3nKC) ->
           let {
             lvl4_s3o29 :: P b1_X3nkp
             [LclId]
             lvl4_s3o29 = eta1_X44 x1_i1Mhr } in
           (eta_X7Z
            `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <b_a3nKD>_R
                    :: (ReadP b_a3nKD :: *)
                       ~R# (forall b. (b_a3nKD -> P b) -> P b :: *)))
             @ b1_X3nkp (\ _ [Occ=Dead] -> lvl4_s3o29))

-- RHS size: {terms: 12, types: 18, coercions: 4, joins: 0/1}
$c>>_r3oqV
  :: forall a b. ReadP a -> ReadP b -> forall b1. (b -> P b1) -> P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []]
$c>>_r3oqV
  = \ (@ a_a3nJi)
      (@ b_a3nJj)
      (eta_X3Y :: ReadP a_a3nJi)
      (eta1_B1 :: ReadP b_a3nJj)
      (@ b1_a3nIU)
      (k_a3ngs :: b_a3nJj -> P b1_a3nIU) ->
      let {
        lvl4_s3o2a :: P b1_a3nIU
        [LclId]
        lvl4_s3o2a
          = (eta1_B1
             `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <b_a3nJj>_R
                     :: (ReadP b_a3nJj :: *)
                        ~R# (forall b. (b_a3nJj -> P b) -> P b :: *)))
              @ b1_a3nIU k_a3ngs } in
      (eta_X3Y
       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nJi>_R
               :: (ReadP a_a3nJi :: *)
                  ~R# (forall b. (a_a3nJi -> P b) -> P b :: *)))
        @ b1_a3nIU (\ _ [Occ=Dead] -> lvl4_s3o2a)

-- RHS size: {terms: 1, types: 0, coercions: 15, joins: 0/0}
Text.ParserCombinators.ReadP.$fMonadReadP_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b. ReadP a -> ReadP b -> ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= (\ (@ a_X3nMU)
                  (@ b_X3nMW)
                  (m1_i3nU4 [Occ=Once] :: ReadP a_X3nMU)
                  (k_i3nU5 [Occ=OnceL] :: ReadP b_X3nMW)
                  (@ b1_a3nIU)
                  (k1_a3ngs [Occ=OnceL] :: b_X3nMW -> P b1_a3nIU) ->
                  (m1_i3nU4
                   `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_X3nMU>_R
                           :: (ReadP a_X3nMU :: *)
                              ~R# (forall b. (a_X3nMU -> P b) -> P b :: *)))
                    @ b1_a3nIU
                    (\ _ [Occ=Dead] ->
                       (k_i3nU5
                        `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <b_X3nMW>_R
                                :: (ReadP b_X3nMW :: *)
                                   ~R# (forall b. (b_X3nMW -> P b) -> P b :: *)))
                         @ b1_a3nIU k1_a3ngs))
               `cast` (forall (a :: <*>_N) (b :: <*>_N).
                       <ReadP a>_R
                       ->_R <ReadP b>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <b>_R)
                       :: (forall a b.
                           ReadP a -> ReadP b -> forall b. (b -> P b) -> P b :: *)
                          ~R# (forall a b. ReadP a -> ReadP b -> ReadP b :: *))}]
Text.ParserCombinators.ReadP.$fMonadReadP_$c>>
  = $c>>_r3oqV
    `cast` (forall (a :: <*>_N) (b :: <*>_N).
            <ReadP a>_R
            ->_R <ReadP b>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <b>_R)
            :: (forall a b.
                ReadP a -> ReadP b -> forall b. (b -> P b) -> P b :: *)
               ~R# (forall a b. ReadP a -> ReadP b -> ReadP b :: *))

-- RHS size: {terms: 11, types: 13, coercions: 76, joins: 0/0}
Text.ParserCombinators.ReadP.$fApplicativeReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: Applicative ReadP
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Applicative TYPE: ReadP
                              Text.ParserCombinators.ReadP.$fFunctorReadP
                              Text.ParserCombinators.ReadP.$fApplicativeReadP5
                              `cast` (forall (a :: <*>_N).
                                      <a>_R ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                                      :: (forall a. a -> forall b. (a -> P b) -> P b :: *)
                                         ~R# (forall a. a -> ReadP a :: *))
                              (\ (@ a_a3nK0) (@ b_a3nK1) ->
                                 Text.ParserCombinators.ReadP.$fApplicativeReadP4
                                   @ b_a3nK1 @ a_a3nK0)
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <ReadP (a -> b)>_R
                                      ->_R <ReadP a>_R
                                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <b>_R)
                                      :: (forall a b.
                                          ReadP (a -> b)
                                          -> ReadP a -> forall b. (b -> P b) -> P b :: *)
                                         ~R# (forall a b.
                                              ReadP (a -> b) -> ReadP a -> ReadP b :: *))
                              Text.ParserCombinators.ReadP.$fApplicativeReadP3
                              `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                                      <a -> b -> c>_R
                                      ->_R <ReadP a>_R
                                      ->_R <ReadP b>_R
                                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <c>_R)
                                      :: (forall a b c.
                                          (a -> b -> c)
                                          -> ReadP a -> ReadP b -> forall b. (c -> P b) -> P b :: *)
                                         ~R# (forall a b c.
                                              (a -> b -> c) -> ReadP a -> ReadP b -> ReadP c :: *))
                              Text.ParserCombinators.ReadP.$fApplicativeReadP2
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <ReadP a>_R
                                      ->_R <ReadP b>_R
                                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <b>_R)
                                      :: (forall a b.
                                          ReadP a -> ReadP b -> forall b. (b -> P b) -> P b :: *)
                                         ~R# (forall a b. ReadP a -> ReadP b -> ReadP b :: *))
                              (\ (@ a_a3nKC) (@ b_a3nKD) ->
                                 Text.ParserCombinators.ReadP.$fApplicativeReadP1
                                   @ b_a3nKD @ a_a3nKC)
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <ReadP a>_R
                                      ->_R <ReadP b>_R
                                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                                      :: (forall a b.
                                          ReadP a -> ReadP b -> forall b. (a -> P b) -> P b :: *)
                                         ~R# (forall a b. ReadP a -> ReadP b -> ReadP a :: *))]
Text.ParserCombinators.ReadP.$fApplicativeReadP
  = GHC.Base.C:Applicative
      @ ReadP
      Text.ParserCombinators.ReadP.$fFunctorReadP
      (Text.ParserCombinators.ReadP.$fApplicativeReadP5
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
               :: (forall a. a -> forall b. (a -> P b) -> P b :: *)
                  ~R# (forall a. a -> ReadP a :: *)))
      ((\ (@ a_a3nK0) (@ b_a3nK1) ->
          Text.ParserCombinators.ReadP.$fApplicativeReadP4
            @ b_a3nK1 @ a_a3nK0)
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <ReadP (a -> b)>_R
               ->_R <ReadP a>_R
               ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <b>_R)
               :: (forall a b.
                   ReadP (a -> b) -> ReadP a -> forall b. (b -> P b) -> P b :: *)
                  ~R# (forall a b. ReadP (a -> b) -> ReadP a -> ReadP b :: *)))
      (Text.ParserCombinators.ReadP.$fApplicativeReadP3
       `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
               <a -> b -> c>_R
               ->_R <ReadP a>_R
               ->_R <ReadP b>_R
               ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <c>_R)
               :: (forall a b c.
                   (a -> b -> c)
                   -> ReadP a -> ReadP b -> forall b. (c -> P b) -> P b :: *)
                  ~R# (forall a b c.
                       (a -> b -> c) -> ReadP a -> ReadP b -> ReadP c :: *)))
      (Text.ParserCombinators.ReadP.$fApplicativeReadP2
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <ReadP a>_R
               ->_R <ReadP b>_R
               ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <b>_R)
               :: (forall a b.
                   ReadP a -> ReadP b -> forall b. (b -> P b) -> P b :: *)
                  ~R# (forall a b. ReadP a -> ReadP b -> ReadP b :: *)))
      ((\ (@ a_a3nKC) (@ b_a3nKD) ->
          Text.ParserCombinators.ReadP.$fApplicativeReadP1
            @ b_a3nKD @ a_a3nKC)
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <ReadP a>_R
               ->_R <ReadP b>_R
               ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
               :: (forall a b.
                   ReadP a -> ReadP b -> forall b. (a -> P b) -> P b :: *)
                  ~R# (forall a b. ReadP a -> ReadP b -> ReadP a :: *)))

-- RHS size: {terms: 6, types: 1, coercions: 32, joins: 0/0}
Text.ParserCombinators.ReadP.$fMonadReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: Monad ReadP
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Monad TYPE: ReadP
                        Text.ParserCombinators.ReadP.$fApplicativeReadP
                        Text.ParserCombinators.ReadP.$fMonadReadP1
                        `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                <ReadP a>_R
                                ->_R <a -> ReadP b>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <b>_R)
                                :: (forall a b.
                                    ReadP a -> (a -> ReadP b) -> forall b. (b -> P b) -> P b :: *)
                                   ~R# (forall a b. ReadP a -> (a -> ReadP b) -> ReadP b :: *))
                        Text.ParserCombinators.ReadP.$fMonadReadP_$c>>
                        Text.ParserCombinators.ReadP.$fApplicativeReadP5
                        `cast` (forall (a :: <*>_N).
                                <a>_R ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                                :: (forall a. a -> forall b. (a -> P b) -> P b :: *)
                                   ~R# (forall a. a -> ReadP a :: *))
                        Text.ParserCombinators.ReadP.$fMonadFailReadP1
                        `cast` (forall (a :: <*>_N).
                                <String>_R ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                                :: (forall a. String -> forall b. (a -> P b) -> P b :: *)
                                   ~R# (forall a. String -> ReadP a :: *))]
Text.ParserCombinators.ReadP.$fMonadReadP
  = GHC.Base.C:Monad
      @ ReadP
      Text.ParserCombinators.ReadP.$fApplicativeReadP
      (Text.ParserCombinators.ReadP.$fMonadReadP1
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <ReadP a>_R
               ->_R <a -> ReadP b>_R
               ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <b>_R)
               :: (forall a b.
                   ReadP a -> (a -> ReadP b) -> forall b. (b -> P b) -> P b :: *)
                  ~R# (forall a b. ReadP a -> (a -> ReadP b) -> ReadP b :: *)))
      Text.ParserCombinators.ReadP.$fMonadReadP_$c>>
      (Text.ParserCombinators.ReadP.$fApplicativeReadP5
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
               :: (forall a. a -> forall b. (a -> P b) -> P b :: *)
                  ~R# (forall a. a -> ReadP a :: *)))
      (Text.ParserCombinators.ReadP.$fMonadFailReadP1
       `cast` (forall (a :: <*>_N).
               <String>_R ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
               :: (forall a. String -> forall b. (a -> P b) -> P b :: *)
                  ~R# (forall a. String -> ReadP a :: *)))

-- RHS size: {terms: 20, types: 27, coercions: 6, joins: 0/2}
Text.ParserCombinators.ReadP.between1
  :: forall open close a.
     ReadP open -> ReadP close -> ReadP a -> forall b. (a -> P b) -> P b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,1*C1(U)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 60 60] 130 0}]
Text.ParserCombinators.ReadP.between1
  = \ (@ open_a3nug)
      (@ close_a3nuh)
      (@ a_a3nui)
      (open1_a3nj5 :: ReadP open_a3nug)
      (close1_a3nj6 :: ReadP close_a3nuh)
      (p_a3nj7 :: ReadP a_a3nui)
      (@ b_a3nIU)
      (k_a3ngs :: a_a3nui -> P b_a3nIU) ->
      let {
        lvl4_s3o2e :: P b_a3nIU
        [LclId]
        lvl4_s3o2e
          = (p_a3nj7
             `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nui>_R
                     :: (ReadP a_a3nui :: *)
                        ~R# (forall b. (a_a3nui -> P b) -> P b :: *)))
              @ b_a3nIU
              (\ (a1_X3nkn :: a_a3nui) ->
                 let {
                   lvl5_s3o2d :: P b_a3nIU
                   [LclId]
                   lvl5_s3o2d = k_a3ngs a1_X3nkn } in
                 (close1_a3nj6
                  `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <close_a3nuh>_R
                          :: (ReadP close_a3nuh :: *)
                             ~R# (forall b. (close_a3nuh -> P b) -> P b :: *)))
                   @ b_a3nIU (\ _ [Occ=Dead] -> lvl5_s3o2d)) } in
      (open1_a3nj5
       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <open_a3nug>_R
               :: (ReadP open_a3nug :: *)
                  ~R# (forall b. (open_a3nug -> P b) -> P b :: *)))
        @ b_a3nIU (\ _ [Occ=Dead] -> lvl4_s3o2e)

-- RHS size: {terms: 1, types: 0, coercions: 21, joins: 0/0}
between
  :: forall open close a.
     ReadP open -> ReadP close -> ReadP a -> ReadP a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,1*C1(U)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.between1
               `cast` (forall (open :: <*>_N) (close :: <*>_N) (a :: <*>_N).
                       <ReadP open>_R
                       ->_R <ReadP close>_R
                       ->_R <ReadP a>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                       :: (forall open close a.
                           ReadP open
                           -> ReadP close -> ReadP a -> forall b. (a -> P b) -> P b :: *)
                          ~R# (forall open close a.
                               ReadP open -> ReadP close -> ReadP a -> ReadP a :: *))}]
between
  = Text.ParserCombinators.ReadP.between1
    `cast` (forall (open :: <*>_N) (close :: <*>_N) (a :: <*>_N).
            <ReadP open>_R
            ->_R <ReadP close>_R
            ->_R <ReadP a>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
            :: (forall open close a.
                ReadP open
                -> ReadP close -> ReadP a -> forall b. (a -> P b) -> P b :: *)
               ~R# (forall open close a.
                    ReadP open -> ReadP close -> ReadP a -> ReadP a :: *))

-- RHS size: {terms: 43, types: 42, coercions: 4, joins: 0/2}
Text.ParserCombinators.ReadP.$wcount [InlPrag=NOUSERINLINE[0]]
  :: forall a. Int# -> ReadP a -> forall b. ([a] -> P b) -> P b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,U><L,C(U)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 120 60] 282 0}]
Text.ParserCombinators.ReadP.$wcount
  = \ (@ a_s3ogB)
      (ww_s3ogI :: Int#)
      (w_s3ogD :: ReadP a_s3ogB)
      (@ b_s3ogE)
      (w1_s3ogF :: [a_s3ogB] -> P b_s3ogE) ->
      case <# 0# ww_s3ogI of {
        __DEFAULT -> w1_s3ogF (GHC.Types.[] @ a_s3ogB);
        1# ->
          letrec {
            $wxs_s3ogA [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
              :: Int# -> forall b1. ([a_s3ogB] -> P b1) -> P b1
            [LclId, Arity=2, Str=<S,1*U><L,C(U)>, Unf=OtherCon []]
            $wxs_s3ogA
              = \ (ww1_s3ogy :: Int#)
                  (@ b1_s3ogu)
                  (w2_s3ogv :: [a_s3ogB] -> P b1_s3ogu) ->
                  case ww1_s3ogy of ds1_i2KC9 {
                    __DEFAULT ->
                      let {
                        r_s3o9o :: Int#
                        [LclId]
                        r_s3o9o = -# ds1_i2KC9 1# } in
                      (w_s3ogD
                       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_s3ogB>_R
                               :: (ReadP a_s3ogB :: *)
                                  ~R# (forall b. (a_s3ogB -> P b) -> P b :: *)))
                        @ b1_s3ogu
                        (\ (a1_a3ngt :: a_s3ogB) ->
                           $wxs_s3ogA
                             r_s3o9o
                             @ b1_s3ogu
                             (\ (a2_X3nkx :: [a_s3ogB]) ->
                                w2_s3ogv (GHC.Types.: @ a_s3ogB a1_a3ngt a2_X3nkx)));
                    1# ->
                      (w_s3ogD
                       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_s3ogB>_R
                               :: (ReadP a_s3ogB :: *)
                                  ~R# (forall b. (a_s3ogB -> P b) -> P b :: *)))
                        @ b1_s3ogu
                        (\ (a1_a3ngt :: a_s3ogB) ->
                           w2_s3ogv (GHC.Types.: @ a_s3ogB a1_a3ngt (GHC.Types.[] @ a_s3ogB)))
                  }; } in
          $wxs_s3ogA ww_s3ogI @ b_s3ogE w1_s3ogF
      }

-- RHS size: {terms: 12, types: 15, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.count1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. Int -> ReadP a -> forall b. ([a] -> P b) -> P b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,C(U)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s3ogB)
                 (w_s3ogC [Occ=Once!] :: Int)
                 (w1_s3ogD [Occ=Once] :: ReadP a_s3ogB)
                 (@ b_s3ogE)
                 (w2_s3ogF [Occ=Once] :: [a_s3ogB] -> P b_s3ogE) ->
                 case w_s3ogC of { I# ww1_s3ogI [Occ=Once] ->
                 Text.ParserCombinators.ReadP.$wcount
                   @ a_s3ogB ww1_s3ogI w1_s3ogD @ b_s3ogE w2_s3ogF
                 }}]
Text.ParserCombinators.ReadP.count1
  = \ (@ a_s3ogB)
      (w_s3ogC :: Int)
      (w1_s3ogD :: ReadP a_s3ogB)
      (@ b_s3ogE)
      (w2_s3ogF :: [a_s3ogB] -> P b_s3ogE) ->
      case w_s3ogC of { I# ww1_s3ogI ->
      Text.ParserCombinators.ReadP.$wcount
        @ a_s3ogB ww1_s3ogI w1_s3ogD @ b_s3ogE w2_s3ogF
      }

-- RHS size: {terms: 1, types: 0, coercions: 12, joins: 0/0}
count :: forall a. Int -> ReadP a -> ReadP [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,C(U)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.count1
               `cast` (forall (a :: <*>_N).
                       <Int>_R
                       ->_R <ReadP a>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
                       :: (forall a. Int -> ReadP a -> forall b. ([a] -> P b) -> P b :: *)
                          ~R# (forall a. Int -> ReadP a -> ReadP [a] :: *))}]
count
  = Text.ParserCombinators.ReadP.count1
    `cast` (forall (a :: <*>_N).
            <Int>_R
            ->_R <ReadP a>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
            :: (forall a. Int -> ReadP a -> forall b. ([a] -> P b) -> P b :: *)
               ~R# (forall a. Int -> ReadP a -> ReadP [a] :: *))

-- RHS size: {terms: 10, types: 12, coercions: 2, joins: 0/0}
Text.ParserCombinators.ReadP.option1
  :: forall a. a -> ReadP a -> forall b. (a -> P b) -> P b
[GblId,
 Arity=3,
 Str=<L,U><C(S),1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a3nvT)
                 (x_a3nj9 [Occ=Once] :: a_a3nvT)
                 (p_a3nja [Occ=Once] :: ReadP a_a3nvT)
                 (@ b_a3ngn)
                 (eta_B1 :: a_a3nvT -> P b_a3ngn) ->
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b_a3ngn
                   ((p_a3nja
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nvT>_R
                             :: (ReadP a_a3nvT :: *)
                                ~R# (forall b. (a_a3nvT -> P b) -> P b :: *)))
                      @ b_a3ngn eta_B1)
                   (eta_B1 x_a3nj9)}]
Text.ParserCombinators.ReadP.option1
  = \ (@ a_a3nvT)
      (x_a3nj9 :: a_a3nvT)
      (p_a3nja :: ReadP a_a3nvT)
      (@ b_a3ngn)
      (eta_B1 :: a_a3nvT -> P b_a3ngn) ->
      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
        @ b_a3ngn
        ((p_a3nja
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nvT>_R
                  :: (ReadP a_a3nvT :: *)
                     ~R# (forall b. (a_a3nvT -> P b) -> P b :: *)))
           @ b_a3ngn eta_B1)
        (eta_B1 x_a3nj9)

-- RHS size: {terms: 1, types: 0, coercions: 11, joins: 0/0}
option :: forall a. a -> ReadP a -> ReadP a
[GblId,
 Arity=3,
 Str=<L,U><C(S),1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.option1
               `cast` (forall (a :: <*>_N).
                       <a>_R
                       ->_R <ReadP a>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                       :: (forall a. a -> ReadP a -> forall b. (a -> P b) -> P b :: *)
                          ~R# (forall a. a -> ReadP a -> ReadP a :: *))}]
option
  = Text.ParserCombinators.ReadP.option1
    `cast` (forall (a :: <*>_N).
            <a>_R
            ->_R <ReadP a>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
            :: (forall a. a -> ReadP a -> forall b. (a -> P b) -> P b :: *)
               ~R# (forall a. a -> ReadP a -> ReadP a :: *))

-- RHS size: {terms: 12, types: 14, coercions: 2, joins: 0/1}
Text.ParserCombinators.ReadP.optional1
  :: forall a. ReadP a -> forall b. (() -> P b) -> P b
[GblId,
 Arity=2,
 Str=<C(S),1*C1(U)><L,1*C1(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60] 90 0}]
Text.ParserCombinators.ReadP.optional1
  = \ (@ a_a3nw0)
      (p_a3njb :: ReadP a_a3nw0)
      (@ b_a3ngn)
      (eta_B1 :: () -> P b_a3ngn) ->
      let {
        lvl4_s3o2k :: P b_a3ngn
        [LclId]
        lvl4_s3o2k = eta_B1 GHC.Tuple.() } in
      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
        @ b_a3ngn
        ((p_a3njb
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nw0>_R
                  :: (ReadP a_a3nw0 :: *)
                     ~R# (forall b. (a_a3nw0 -> P b) -> P b :: *)))
           @ b_a3ngn (\ _ [Occ=Dead] -> lvl4_s3o2k))
        lvl4_s3o2k

-- RHS size: {terms: 1, types: 0, coercions: 9, joins: 0/0}
optional :: forall a. ReadP a -> ReadP ()
[GblId,
 Arity=2,
 Str=<C(S),1*C1(U)><L,1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.optional1
               `cast` (forall (a :: <*>_N).
                       <ReadP a>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                       :: (forall a. ReadP a -> forall b. (() -> P b) -> P b :: *)
                          ~R# (forall a. ReadP a -> ReadP () :: *))}]
optional
  = Text.ParserCombinators.ReadP.optional1
    `cast` (forall (a :: <*>_N).
            <ReadP a>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
            :: (forall a. ReadP a -> forall b. (() -> P b) -> P b :: *)
               ~R# (forall a. ReadP a -> ReadP () :: *))

Rec {
-- RHS size: {terms: 16, types: 19, coercions: 2, joins: 0/0}
Text.ParserCombinators.ReadP.endBy3 [Occ=LoopBreaker]
  :: forall a. ReadP a -> forall b. ([a] -> P b) -> P b
[GblId, Arity=2, Str=<L,C(U)><C(S),C(U)>, Unf=OtherCon []]
Text.ParserCombinators.ReadP.endBy3
  = \ (@ a_a3nwo)
      (p_a3njc :: ReadP a_a3nwo)
      (@ b_a3ngn)
      (eta_B1 :: [a_a3nwo] -> P b_a3ngn) ->
      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
        @ b_a3ngn
        (eta_B1 (GHC.Types.[] @ a_a3nwo))
        ((p_a3njc
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nwo>_R
                  :: (ReadP a_a3nwo :: *)
                     ~R# (forall b. (a_a3nwo -> P b) -> P b :: *)))
           @ b_a3ngn
           (\ (a1_a3ngt :: a_a3nwo) ->
              Text.ParserCombinators.ReadP.endBy3
                @ a_a3nwo
                p_a3njc
                @ b_a3ngn
                (\ (a2_X3nkz :: [a_a3nwo]) ->
                   eta_B1 (GHC.Types.: @ a_a3nwo a1_a3ngt a2_X3nkz))))
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
many :: forall a. ReadP a -> ReadP [a]
[GblId,
 Arity=2,
 Str=<L,C(U)><C(S),C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.endBy3
               `cast` (forall (a :: <*>_N).
                       <ReadP a>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
                       :: (forall a. ReadP a -> forall b. ([a] -> P b) -> P b :: *)
                          ~R# (forall a. ReadP a -> ReadP [a] :: *))}]
many
  = Text.ParserCombinators.ReadP.endBy3
    `cast` (forall (a :: <*>_N).
            <ReadP a>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
            :: (forall a. ReadP a -> forall b. ([a] -> P b) -> P b :: *)
               ~R# (forall a. ReadP a -> ReadP [a] :: *))

-- RHS size: {terms: 13, types: 17, coercions: 2, joins: 0/0}
Text.ParserCombinators.ReadP.many2
  :: forall a. ReadP a -> forall b. ([a] -> P b) -> P b
[GblId,
 Arity=2,
 Str=<C(S),C(U)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60] 100 0}]
Text.ParserCombinators.ReadP.many2
  = \ (@ a_a3nwe)
      (p_a3njd :: ReadP a_a3nwe)
      (@ b_a3ngn)
      (eta_B1 :: [a_a3nwe] -> P b_a3ngn) ->
      (p_a3njd
       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nwe>_R
               :: (ReadP a_a3nwe :: *)
                  ~R# (forall b. (a_a3nwe -> P b) -> P b :: *)))
        @ b_a3ngn
        (\ (a1_a3ngt :: a_a3nwe) ->
           Text.ParserCombinators.ReadP.endBy3
             @ a_a3nwe
             p_a3njd
             @ b_a3ngn
             (\ (a2_X3nkz :: [a_a3nwe]) ->
                eta_B1 (GHC.Types.: @ a_a3nwe a1_a3ngt a2_X3nkz)))

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
many1 :: forall a. ReadP a -> ReadP [a]
[GblId,
 Arity=2,
 Str=<C(S),C(U)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.many2
               `cast` (forall (a :: <*>_N).
                       <ReadP a>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
                       :: (forall a. ReadP a -> forall b. ([a] -> P b) -> P b :: *)
                          ~R# (forall a. ReadP a -> ReadP [a] :: *))}]
many1
  = Text.ParserCombinators.ReadP.many2
    `cast` (forall (a :: <*>_N).
            <ReadP a>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
            :: (forall a. ReadP a -> forall b. ([a] -> P b) -> P b :: *)
               ~R# (forall a. ReadP a -> ReadP [a] :: *))

-- RHS size: {terms: 30, types: 43, coercions: 11, joins: 0/3}
Text.ParserCombinators.ReadP.endBy4
  :: forall a sep.
     ReadP a -> ReadP sep -> forall b. ([a] -> P b) -> P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [120 120 60] 250 0}]
Text.ParserCombinators.ReadP.endBy4
  = \ (@ a_a3nwx)
      (@ sep_a3nwy)
      (p_a3njn :: ReadP a_a3nwx)
      (sep1_a3njo :: ReadP sep_a3nwy)
      (@ b_a3ngn)
      (eta_B1 :: [a_a3nwx] -> P b_a3ngn) ->
      let {
        p1_s3o1B [Dmd=<L,C(U)>] :: forall b1. (a_a3nwx -> P b1) -> P b1
        [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []]
        p1_s3o1B
          = \ (@ b1_a3nIU) (k_a3ngs :: a_a3nwx -> P b1_a3nIU) ->
              (p_a3njn
               `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nwx>_R
                       :: (ReadP a_a3nwx :: *)
                          ~R# (forall b. (a_a3nwx -> P b) -> P b :: *)))
                @ b1_a3nIU
                (\ (a1_a3ngt :: a_a3nwx) ->
                   let {
                     lvl4_s3o2l :: P b1_a3nIU
                     [LclId]
                     lvl4_s3o2l = k_a3ngs a1_a3ngt } in
                   (sep1_a3njo
                    `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <sep_a3nwy>_R
                            :: (ReadP sep_a3nwy :: *)
                               ~R# (forall b. (sep_a3nwy -> P b) -> P b :: *)))
                     @ b1_a3nIU (\ _ [Occ=Dead] -> lvl4_s3o2l)) } in
      (p_a3njn
       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nwx>_R
               :: (ReadP a_a3nwx :: *)
                  ~R# (forall b. (a_a3nwx -> P b) -> P b :: *)))
        @ b_a3ngn
        (\ (a1_a3ngt :: a_a3nwx) ->
           let {
             lvl4_s3o2m :: P b_a3ngn
             [LclId]
             lvl4_s3o2m
               = Text.ParserCombinators.ReadP.endBy3
                   @ a_a3nwx
                   (p1_s3o1B
                    `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nwx>_R)
                            :: (forall b. (a_a3nwx -> P b) -> P b :: *)
                               ~R# (ReadP a_a3nwx :: *)))
                   @ b_a3ngn
                   (\ (a2_X3np2 :: [a_a3nwx]) ->
                      eta_B1 (GHC.Types.: @ a_a3nwx a1_a3ngt a2_X3np2)) } in
           (sep1_a3njo
            `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <sep_a3nwy>_R
                    :: (ReadP sep_a3nwy :: *)
                       ~R# (forall b. (sep_a3nwy -> P b) -> P b :: *)))
             @ b_a3ngn (\ _ [Occ=Dead] -> lvl4_s3o2m))

-- RHS size: {terms: 1, types: 0, coercions: 16, joins: 0/0}
endBy1 :: forall a sep. ReadP a -> ReadP sep -> ReadP [a]
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.endBy4
               `cast` (forall (a :: <*>_N) (sep :: <*>_N).
                       <ReadP a>_R
                       ->_R <ReadP sep>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
                       :: (forall a sep.
                           ReadP a -> ReadP sep -> forall b. ([a] -> P b) -> P b :: *)
                          ~R# (forall a sep. ReadP a -> ReadP sep -> ReadP [a] :: *))}]
endBy1
  = Text.ParserCombinators.ReadP.endBy4
    `cast` (forall (a :: <*>_N) (sep :: <*>_N).
            <ReadP a>_R
            ->_R <ReadP sep>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
            :: (forall a sep.
                ReadP a -> ReadP sep -> forall b. ([a] -> P b) -> P b :: *)
               ~R# (forall a sep. ReadP a -> ReadP sep -> ReadP [a] :: *))

-- RHS size: {terms: 11, types: 15, coercions: 0, joins: 0/1}
Text.ParserCombinators.ReadP.skipMany2
  :: forall a. ReadP a -> forall b. (() -> P b) -> P b
[GblId,
 Arity=2,
 Str=<L,C(U)><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a3nwN)
                 (p_a3nje [Occ=Once] :: ReadP a_a3nwN)
                 (@ b_a3ngn)
                 (eta_B1 [Occ=Once!] :: () -> P b_a3ngn) ->
                 let {
                   lvl4_s3o2n [Occ=OnceL] :: P b_a3ngn
                   [LclId]
                   lvl4_s3o2n = eta_B1 GHC.Tuple.() } in
                 Text.ParserCombinators.ReadP.endBy3
                   @ a_a3nwN p_a3nje @ b_a3ngn (\ _ [Occ=Dead] -> lvl4_s3o2n)}]
Text.ParserCombinators.ReadP.skipMany2
  = \ (@ a_a3nwN)
      (p_a3nje :: ReadP a_a3nwN)
      (@ b_a3ngn)
      (eta_B1 :: () -> P b_a3ngn) ->
      let {
        lvl4_s3o2n [Dmd=<S,U>] :: P b_a3ngn
        [LclId]
        lvl4_s3o2n = eta_B1 GHC.Tuple.() } in
      Text.ParserCombinators.ReadP.endBy3
        @ a_a3nwN p_a3nje @ b_a3ngn (\ _ [Occ=Dead] -> lvl4_s3o2n)

-- RHS size: {terms: 1, types: 0, coercions: 9, joins: 0/0}
skipMany :: forall a. ReadP a -> ReadP ()
[GblId,
 Arity=2,
 Str=<L,C(U)><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.skipMany2
               `cast` (forall (a :: <*>_N).
                       <ReadP a>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                       :: (forall a. ReadP a -> forall b. (() -> P b) -> P b :: *)
                          ~R# (forall a. ReadP a -> ReadP () :: *))}]
skipMany
  = Text.ParserCombinators.ReadP.skipMany2
    `cast` (forall (a :: <*>_N).
            <ReadP a>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
            :: (forall a. ReadP a -> forall b. (() -> P b) -> P b :: *)
               ~R# (forall a. ReadP a -> ReadP () :: *))

-- RHS size: {terms: 15, types: 19, coercions: 2, joins: 0/2}
Text.ParserCombinators.ReadP.skipMany3
  :: forall a. ReadP a -> forall b. (() -> P b) -> P b
[GblId,
 Arity=2,
 Str=<C(S),C(U)><L,1*C1(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60] 110 0}]
Text.ParserCombinators.ReadP.skipMany3
  = \ (@ a_a3nwY)
      (p_a3njf :: ReadP a_a3nwY)
      (@ b_a3ngn)
      (eta_B1 :: () -> P b_a3ngn) ->
      let {
        lvl4_s3o2o :: P b_a3ngn
        [LclId]
        lvl4_s3o2o
          = let {
              lvl5_s3o2n [Dmd=<S,U>] :: P b_a3ngn
              [LclId]
              lvl5_s3o2n = eta_B1 GHC.Tuple.() } in
            Text.ParserCombinators.ReadP.endBy3
              @ a_a3nwY p_a3njf @ b_a3ngn (\ _ [Occ=Dead] -> lvl5_s3o2n) } in
      (p_a3njf
       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nwY>_R
               :: (ReadP a_a3nwY :: *)
                  ~R# (forall b. (a_a3nwY -> P b) -> P b :: *)))
        @ b_a3ngn (\ _ [Occ=Dead] -> lvl4_s3o2o)

-- RHS size: {terms: 1, types: 0, coercions: 9, joins: 0/0}
skipMany1 :: forall a. ReadP a -> ReadP ()
[GblId,
 Arity=2,
 Str=<C(S),C(U)><L,1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.skipMany3
               `cast` (forall (a :: <*>_N).
                       <ReadP a>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                       :: (forall a. ReadP a -> forall b. (() -> P b) -> P b :: *)
                          ~R# (forall a. ReadP a -> ReadP () :: *))}]
skipMany1
  = Text.ParserCombinators.ReadP.skipMany3
    `cast` (forall (a :: <*>_N).
            <ReadP a>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
            :: (forall a. ReadP a -> forall b. (() -> P b) -> P b :: *)
               ~R# (forall a. ReadP a -> ReadP () :: *))

-- RHS size: {terms: 24, types: 38, coercions: 9, joins: 0/2}
Text.ParserCombinators.ReadP.sepBy3
  :: forall a sep.
     ReadP a -> ReadP sep -> forall b. ([a] -> P b) -> P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [120 60 60] 180 0}]
Text.ParserCombinators.ReadP.sepBy3
  = \ (@ a_a3nx6)
      (@ sep_a3nx7)
      (p_a3nji :: ReadP a_a3nx6)
      (sep1_a3njj :: ReadP sep_a3nx7)
      (@ b_a3ngn)
      (eta_B1 :: [a_a3nx6] -> P b_a3ngn) ->
      let {
        m2_s3o1z [Dmd=<L,C(U)>] :: forall b1. (a_a3nx6 -> P b1) -> P b1
        [LclId,
         Arity=1,
         Str=<L,U>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
                 Tmpl= \ (@ b1_a3nIU)
                         (k_a3ngs [Occ=Once] :: a_a3nx6 -> P b1_a3nIU) ->
                         let {
                           lvl4_s3o2p [Occ=OnceL] :: P b1_a3nIU
                           [LclId]
                           lvl4_s3o2p
                             = (p_a3nji
                                `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nx6>_R
                                        :: (ReadP a_a3nx6 :: *)
                                           ~R# (forall b. (a_a3nx6 -> P b) -> P b :: *)))
                                 @ b1_a3nIU k_a3ngs } in
                         (sep1_a3njj
                          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <sep_a3nx7>_R
                                  :: (ReadP sep_a3nx7 :: *)
                                     ~R# (forall b. (sep_a3nx7 -> P b) -> P b :: *)))
                           @ b1_a3nIU (\ _ [Occ=Dead] -> lvl4_s3o2p)}]
        m2_s3o1z
          = \ (@ b1_a3nIU) (k_a3ngs :: a_a3nx6 -> P b1_a3nIU) ->
              let {
                lvl4_s3o2p :: P b1_a3nIU
                [LclId]
                lvl4_s3o2p
                  = (p_a3nji
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nx6>_R
                             :: (ReadP a_a3nx6 :: *)
                                ~R# (forall b. (a_a3nx6 -> P b) -> P b :: *)))
                      @ b1_a3nIU k_a3ngs } in
              (sep1_a3njj
               `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <sep_a3nx7>_R
                       :: (ReadP sep_a3nx7 :: *)
                          ~R# (forall b. (sep_a3nx7 -> P b) -> P b :: *)))
                @ b1_a3nIU (\ _ [Occ=Dead] -> lvl4_s3o2p) } in
      (p_a3nji
       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nx6>_R
               :: (ReadP a_a3nx6 :: *)
                  ~R# (forall b. (a_a3nx6 -> P b) -> P b :: *)))
        @ b_a3ngn
        (\ (a1_a3ngt :: a_a3nx6) ->
           Text.ParserCombinators.ReadP.endBy3
             @ a_a3nx6
             (m2_s3o1z
              `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nx6>_R)
                      :: (forall b. (a_a3nx6 -> P b) -> P b :: *)
                         ~R# (ReadP a_a3nx6 :: *)))
             @ b_a3ngn
             (\ (a2_X3nkH :: [a_a3nx6]) ->
                eta_B1 (GHC.Types.: @ a_a3nx6 a1_a3ngt a2_X3nkH)))

-- RHS size: {terms: 1, types: 0, coercions: 16, joins: 0/0}
sepBy1 :: forall a sep. ReadP a -> ReadP sep -> ReadP [a]
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.sepBy3
               `cast` (forall (a :: <*>_N) (sep :: <*>_N).
                       <ReadP a>_R
                       ->_R <ReadP sep>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
                       :: (forall a sep.
                           ReadP a -> ReadP sep -> forall b. ([a] -> P b) -> P b :: *)
                          ~R# (forall a sep. ReadP a -> ReadP sep -> ReadP [a] :: *))}]
sepBy1
  = Text.ParserCombinators.ReadP.sepBy3
    `cast` (forall (a :: <*>_N) (sep :: <*>_N).
            <ReadP a>_R
            ->_R <ReadP sep>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
            :: (forall a sep.
                ReadP a -> ReadP sep -> forall b. ([a] -> P b) -> P b :: *)
               ~R# (forall a sep. ReadP a -> ReadP sep -> ReadP [a] :: *))

-- RHS size: {terms: 18, types: 27, coercions: 7, joins: 0/1}
Text.ParserCombinators.ReadP.endBy2
  :: forall a sep.
     ReadP a -> ReadP sep -> forall b. ([a] -> P b) -> P b
[GblId,
 Arity=3,
 Str=<L,C(U)><L,C(U)><C(S),C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60 0] 130 0}]
Text.ParserCombinators.ReadP.endBy2
  = \ (@ a_a3nxl)
      (@ sep_a3nxm)
      (p_a3njk :: ReadP a_a3nxl)
      (sep1_a3njl :: ReadP sep_a3nxm)
      (@ b_a3ngn)
      (eta_B1 :: [a_a3nxl] -> P b_a3ngn) ->
      Text.ParserCombinators.ReadP.endBy3
        @ a_a3nxl
        ((\ (@ b1_a3nIU) (k_a3ngs :: a_a3nxl -> P b1_a3nIU) ->
            (p_a3njk
             `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nxl>_R
                     :: (ReadP a_a3nxl :: *)
                        ~R# (forall b. (a_a3nxl -> P b) -> P b :: *)))
              @ b1_a3nIU
              (\ (a1_a3ngt :: a_a3nxl) ->
                 let {
                   lvl4_s3o2q :: P b1_a3nIU
                   [LclId]
                   lvl4_s3o2q = k_a3ngs a1_a3ngt } in
                 (sep1_a3njl
                  `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <sep_a3nxm>_R
                          :: (ReadP sep_a3nxm :: *)
                             ~R# (forall b. (sep_a3nxm -> P b) -> P b :: *)))
                   @ b1_a3nIU (\ _ [Occ=Dead] -> lvl4_s3o2q)))
         `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nxl>_R)
                 :: (forall b. (a_a3nxl -> P b) -> P b :: *)
                    ~R# (ReadP a_a3nxl :: *)))
        @ b_a3ngn
        eta_B1

-- RHS size: {terms: 1, types: 0, coercions: 16, joins: 0/0}
endBy :: forall a sep. ReadP a -> ReadP sep -> ReadP [a]
[GblId,
 Arity=3,
 Str=<L,C(U)><L,C(U)><C(S),C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.endBy2
               `cast` (forall (a :: <*>_N) (sep :: <*>_N).
                       <ReadP a>_R
                       ->_R <ReadP sep>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
                       :: (forall a sep.
                           ReadP a -> ReadP sep -> forall b. ([a] -> P b) -> P b :: *)
                          ~R# (forall a sep. ReadP a -> ReadP sep -> ReadP [a] :: *))}]
endBy
  = Text.ParserCombinators.ReadP.endBy2
    `cast` (forall (a :: <*>_N) (sep :: <*>_N).
            <ReadP a>_R
            ->_R <ReadP sep>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
            :: (forall a sep.
                ReadP a -> ReadP sep -> forall b. ([a] -> P b) -> P b :: *)
               ~R# (forall a sep. ReadP a -> ReadP sep -> ReadP [a] :: *))

-- RHS size: {terms: 13, types: 19, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.sepBy2
  :: forall a sep.
     ReadP a -> ReadP sep -> forall b. ([a] -> P b) -> P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a3nxB)
                 (@ sep_a3nxC)
                 (p_a3njg [Occ=Once] :: ReadP a_a3nxB)
                 (sep1_a3njh [Occ=Once] :: ReadP sep_a3nxC)
                 (@ b_a3ngn)
                 (eta_B1 :: [a_a3nxB] -> P b_a3ngn) ->
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b_a3ngn
                   (Text.ParserCombinators.ReadP.sepBy3
                      @ a_a3nxB @ sep_a3nxC p_a3njg sep1_a3njh @ b_a3ngn eta_B1)
                   (eta_B1 (GHC.Types.[] @ a_a3nxB))}]
Text.ParserCombinators.ReadP.sepBy2
  = \ (@ a_a3nxB)
      (@ sep_a3nxC)
      (p_a3njg :: ReadP a_a3nxB)
      (sep1_a3njh :: ReadP sep_a3nxC)
      (@ b_a3ngn)
      (eta_B1 :: [a_a3nxB] -> P b_a3ngn) ->
      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
        @ b_a3ngn
        (Text.ParserCombinators.ReadP.sepBy3
           @ a_a3nxB @ sep_a3nxC p_a3njg sep1_a3njh @ b_a3ngn eta_B1)
        (eta_B1 (GHC.Types.[] @ a_a3nxB))

-- RHS size: {terms: 1, types: 0, coercions: 16, joins: 0/0}
sepBy :: forall a sep. ReadP a -> ReadP sep -> ReadP [a]
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.sepBy2
               `cast` (forall (a :: <*>_N) (sep :: <*>_N).
                       <ReadP a>_R
                       ->_R <ReadP sep>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
                       :: (forall a sep.
                           ReadP a -> ReadP sep -> forall b. ([a] -> P b) -> P b :: *)
                          ~R# (forall a sep. ReadP a -> ReadP sep -> ReadP [a] :: *))}]
sepBy
  = Text.ParserCombinators.ReadP.sepBy2
    `cast` (forall (a :: <*>_N) (sep :: <*>_N).
            <ReadP a>_R
            ->_R <ReadP sep>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
            :: (forall a sep.
                ReadP a -> ReadP sep -> forall b. ([a] -> P b) -> P b :: *)
               ~R# (forall a sep. ReadP a -> ReadP sep -> ReadP [a] :: *))

-- RHS size: {terms: 3, types: 1, coercions: 8, joins: 0/0}
Text.ParserCombinators.ReadP.$fMonadFailReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: MonadFail ReadP
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Control.Monad.Fail.C:MonadFail TYPE: ReadP
                                      Text.ParserCombinators.ReadP.$fMonadReadP
                                      Text.ParserCombinators.ReadP.$fMonadFailReadP1
                                      `cast` (forall (a :: <*>_N).
                                              <String>_R
                                              ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                            <a>_R)
                                              :: (forall a.
                                                  String -> forall b. (a -> P b) -> P b :: *)
                                                 ~R# (forall a. String -> ReadP a :: *))]
Text.ParserCombinators.ReadP.$fMonadFailReadP
  = Control.Monad.Fail.C:MonadFail
      @ ReadP
      Text.ParserCombinators.ReadP.$fMonadReadP
      (Text.ParserCombinators.ReadP.$fMonadFailReadP1
       `cast` (forall (a :: <*>_N).
               <String>_R ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
               :: (forall a. String -> forall b. (a -> P b) -> P b :: *)
                  ~R# (forall a. String -> ReadP a :: *)))

-- RHS size: {terms: 22, types: 34, coercions: 2, joins: 0/1}
Text.ParserCombinators.ReadP.$fAlternativeReadP2
  :: forall a. ReadP a -> forall b. ([a] -> P b) -> P b
[GblId,
 Arity=2,
 Str=<C(S),C(U)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 190 0}]
Text.ParserCombinators.ReadP.$fAlternativeReadP2
  = \ (@ a_a3nIa)
      (v_i3nTB :: ReadP a_a3nIa)
      (@ b_a3ngn)
      (eta_B1 :: [a_a3nIa] -> P b_a3ngn) ->
      letrec {
        some_v_s3o1x [Occ=LoopBreaker]
          :: forall b1. ([a_a3nIa] -> P b1) -> P b1
        [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []]
        some_v_s3o1x
          = \ (@ b1_X3nkZ) (eta1_X4E :: [a_a3nIa] -> P b1_X3nkZ) ->
              (v_i3nTB
               `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nIa>_R
                       :: (ReadP a_a3nIa :: *)
                          ~R# (forall b. (a_a3nIa -> P b) -> P b :: *)))
                @ b1_X3nkZ
                (\ (x_i1Mhr :: a_a3nIa) ->
                   Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                     @ b1_X3nkZ
                     (some_v_s3o1x
                        @ b1_X3nkZ
                        (\ (a1_X3nki :: [a_a3nIa]) ->
                           eta1_X4E (GHC.Types.: @ a_a3nIa x_i1Mhr a1_X3nki)))
                     (eta1_X4E
                        (GHC.Types.: @ a_a3nIa x_i1Mhr (GHC.Types.[] @ a_a3nIa)))); } in
      some_v_s3o1x @ b_a3ngn eta_B1

-- RHS size: {terms: 20, types: 33, coercions: 2, joins: 0/1}
Text.ParserCombinators.ReadP.$fAlternativeReadP1
  :: forall a. ReadP a -> forall b. ([a] -> P b) -> P b
[GblId,
 Arity=2,
 Str=<C(S),C(U)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 180 0}]
Text.ParserCombinators.ReadP.$fAlternativeReadP1
  = \ (@ a_a3nIm)
      (v_i3nTH :: ReadP a_a3nIm)
      (@ b_a3ngn)
      (eta_B1 :: [a_a3nIm] -> P b_a3ngn) ->
      letrec {
        many_v_s3o1v [Occ=LoopBreaker]
          :: forall b1. ([a_a3nIm] -> P b1) -> P b1
        [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []]
        many_v_s3o1v
          = \ (@ b1_a3nvJ) (k_a3ni6 :: [a_a3nIm] -> P b1_a3nvJ) ->
              Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                @ b1_a3nvJ
                ((v_i3nTH
                  `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nIm>_R
                          :: (ReadP a_a3nIm :: *)
                             ~R# (forall b. (a_a3nIm -> P b) -> P b :: *)))
                   @ b1_a3nvJ
                   (\ (x_i1Mhr :: a_a3nIm) ->
                      many_v_s3o1v
                        @ b1_a3nvJ
                        (\ (a1_X3nki :: [a_a3nIm]) ->
                           k_a3ni6 (GHC.Types.: @ a_a3nIm x_i1Mhr a1_X3nki))))
                (k_a3ni6 (GHC.Types.[] @ a_a3nIm)); } in
      many_v_s3o1v @ b_a3ngn eta_B1

-- RHS size: {terms: 6, types: 1, coercions: 38, joins: 0/0}
Text.ParserCombinators.ReadP.$fAlternativeReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: Alternative ReadP
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Alternative TYPE: ReadP
                              Text.ParserCombinators.ReadP.$fApplicativeReadP
                              Text.ParserCombinators.ReadP.$fAlternativeReadP4
                              `cast` (forall (a :: <*>_N).
                                      Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                                      :: (forall a b. (a -> P b) -> P b :: *)
                                         ~R# (forall a. ReadP a :: *))
                              Text.ParserCombinators.ReadP.$fAlternativeReadP3
                              `cast` (forall (a :: <*>_N).
                                      <ReadP a>_R
                                      ->_R <ReadP a>_R
                                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                                      :: (forall a.
                                          ReadP a -> ReadP a -> forall b. (a -> P b) -> P b :: *)
                                         ~R# (forall a. ReadP a -> ReadP a -> ReadP a :: *))
                              Text.ParserCombinators.ReadP.$fAlternativeReadP2
                              `cast` (forall (a :: <*>_N).
                                      <ReadP a>_R
                                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
                                      :: (forall a. ReadP a -> forall b. ([a] -> P b) -> P b :: *)
                                         ~R# (forall a. ReadP a -> ReadP [a] :: *))
                              Text.ParserCombinators.ReadP.$fAlternativeReadP1
                              `cast` (forall (a :: <*>_N).
                                      <ReadP a>_R
                                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
                                      :: (forall a. ReadP a -> forall b. ([a] -> P b) -> P b :: *)
                                         ~R# (forall a. ReadP a -> ReadP [a] :: *))]
Text.ParserCombinators.ReadP.$fAlternativeReadP
  = GHC.Base.C:Alternative
      @ ReadP
      Text.ParserCombinators.ReadP.$fApplicativeReadP
      (Text.ParserCombinators.ReadP.$fAlternativeReadP4
       `cast` (forall (a :: <*>_N).
               Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
               :: (forall a b. (a -> P b) -> P b :: *)
                  ~R# (forall a. ReadP a :: *)))
      (Text.ParserCombinators.ReadP.$fAlternativeReadP3
       `cast` (forall (a :: <*>_N).
               <ReadP a>_R
               ->_R <ReadP a>_R
               ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
               :: (forall a.
                   ReadP a -> ReadP a -> forall b. (a -> P b) -> P b :: *)
                  ~R# (forall a. ReadP a -> ReadP a -> ReadP a :: *)))
      (Text.ParserCombinators.ReadP.$fAlternativeReadP2
       `cast` (forall (a :: <*>_N).
               <ReadP a>_R
               ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
               :: (forall a. ReadP a -> forall b. ([a] -> P b) -> P b :: *)
                  ~R# (forall a. ReadP a -> ReadP [a] :: *)))
      (Text.ParserCombinators.ReadP.$fAlternativeReadP1
       `cast` (forall (a :: <*>_N).
               <ReadP a>_R
               ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
               :: (forall a. ReadP a -> forall b. ([a] -> P b) -> P b :: *)
                  ~R# (forall a. ReadP a -> ReadP [a] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 18, joins: 0/0}
Text.ParserCombinators.ReadP.$fMonadPlusReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: MonadPlus ReadP
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:MonadPlus TYPE: ReadP
                            Text.ParserCombinators.ReadP.$fAlternativeReadP
                            Text.ParserCombinators.ReadP.$fMonadReadP
                            Text.ParserCombinators.ReadP.$fAlternativeReadP4
                            `cast` (forall (a :: <*>_N).
                                    Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                                    :: (forall a b. (a -> P b) -> P b :: *)
                                       ~R# (forall a. ReadP a :: *))
                            Text.ParserCombinators.ReadP.$fAlternativeReadP3
                            `cast` (forall (a :: <*>_N).
                                    <ReadP a>_R
                                    ->_R <ReadP a>_R
                                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                                    :: (forall a.
                                        ReadP a -> ReadP a -> forall b. (a -> P b) -> P b :: *)
                                       ~R# (forall a. ReadP a -> ReadP a -> ReadP a :: *))]
Text.ParserCombinators.ReadP.$fMonadPlusReadP
  = GHC.Base.C:MonadPlus
      @ ReadP
      Text.ParserCombinators.ReadP.$fAlternativeReadP
      Text.ParserCombinators.ReadP.$fMonadReadP
      (Text.ParserCombinators.ReadP.$fAlternativeReadP4
       `cast` (forall (a :: <*>_N).
               Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
               :: (forall a b. (a -> P b) -> P b :: *)
                  ~R# (forall a. ReadP a :: *)))
      (Text.ParserCombinators.ReadP.$fAlternativeReadP3
       `cast` (forall (a :: <*>_N).
               <ReadP a>_R
               ->_R <ReadP a>_R
               ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
               :: (forall a.
                   ReadP a -> ReadP a -> forall b. (a -> P b) -> P b :: *)
                  ~R# (forall a. ReadP a -> ReadP a -> ReadP a :: *)))

-- RHS size: {terms: 23, types: 35, coercions: 6, joins: 0/1}
Text.ParserCombinators.ReadP.chainr3
  :: forall a.
     ReadP a -> ReadP (a -> a -> a) -> forall b. (a -> P b) -> P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60 0] 230 0}]
Text.ParserCombinators.ReadP.chainr3
  = \ (@ a_a3nxM)
      (p_a3njw :: ReadP a_a3nxM)
      (op_a3njx :: ReadP (a_a3nxM -> a_a3nxM -> a_a3nxM))
      (@ b_a3ngn)
      (eta_B1 :: a_a3nxM -> P b_a3ngn) ->
      letrec {
        scan_s3o1t [Occ=LoopBreaker]
          :: forall b1. (a_a3nxM -> P b1) -> P b1
        [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []]
        scan_s3o1t
          = \ (@ b1_a3nIU) (k_a3ngs :: a_a3nxM -> P b1_a3nIU) ->
              (p_a3njw
               `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nxM>_R
                       :: (ReadP a_a3nxM :: *)
                          ~R# (forall b. (a_a3nxM -> P b) -> P b :: *)))
                @ b1_a3nIU
                (\ (a1_a3ngt :: a_a3nxM) ->
                   Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                     @ b1_a3nIU
                     ((op_a3njx
                       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <a_a3nxM -> a_a3nxM -> a_a3nxM>_R
                               :: (ReadP (a_a3nxM -> a_a3nxM -> a_a3nxM) :: *)
                                  ~R# (forall b.
                                       ((a_a3nxM -> a_a3nxM -> a_a3nxM) -> P b) -> P b :: *)))
                        @ b1_a3nIU
                        (\ (a2_X3nkN :: a_a3nxM -> a_a3nxM -> a_a3nxM) ->
                           scan_s3o1t
                             @ b1_a3nIU
                             (\ (a3_X3nkQ :: a_a3nxM) -> k_a3ngs (a2_X3nkN a1_a3ngt a3_X3nkQ))))
                     (k_a3ngs a1_a3ngt)); } in
      scan_s3o1t @ b_a3ngn eta_B1

-- RHS size: {terms: 1, types: 0, coercions: 14, joins: 0/0}
chainr1 :: forall a. ReadP a -> ReadP (a -> a -> a) -> ReadP a
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.chainr3
               `cast` (forall (a :: <*>_N).
                       <ReadP a>_R
                       ->_R <ReadP (a -> a -> a)>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                       :: (forall a.
                           ReadP a -> ReadP (a -> a -> a) -> forall b. (a -> P b) -> P b :: *)
                          ~R# (forall a. ReadP a -> ReadP (a -> a -> a) -> ReadP a :: *))}]
chainr1
  = Text.ParserCombinators.ReadP.chainr3
    `cast` (forall (a :: <*>_N).
            <ReadP a>_R
            ->_R <ReadP (a -> a -> a)>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
            :: (forall a.
                ReadP a -> ReadP (a -> a -> a) -> forall b. (a -> P b) -> P b :: *)
               ~R# (forall a. ReadP a -> ReadP (a -> a -> a) -> ReadP a :: *))

-- RHS size: {terms: 13, types: 17, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.chainr2
  :: forall a.
     ReadP a -> ReadP (a -> a -> a) -> a -> forall b. (a -> P b) -> P b
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a3nyi)
                 (p_a3njq [Occ=Once] :: ReadP a_a3nyi)
                 (op_a3njr [Occ=Once] :: ReadP (a_a3nyi -> a_a3nyi -> a_a3nyi))
                 (x_a3njs [Occ=Once] :: a_a3nyi)
                 (@ b_a3ngn)
                 (eta_B1 :: a_a3nyi -> P b_a3ngn) ->
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b_a3ngn
                   (Text.ParserCombinators.ReadP.chainr3
                      @ a_a3nyi p_a3njq op_a3njr @ b_a3ngn eta_B1)
                   (eta_B1 x_a3njs)}]
Text.ParserCombinators.ReadP.chainr2
  = \ (@ a_a3nyi)
      (p_a3njq :: ReadP a_a3nyi)
      (op_a3njr :: ReadP (a_a3nyi -> a_a3nyi -> a_a3nyi))
      (x_a3njs :: a_a3nyi)
      (@ b_a3ngn)
      (eta_B1 :: a_a3nyi -> P b_a3ngn) ->
      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
        @ b_a3ngn
        (Text.ParserCombinators.ReadP.chainr3
           @ a_a3nyi p_a3njq op_a3njr @ b_a3ngn eta_B1)
        (eta_B1 x_a3njs)

-- RHS size: {terms: 1, types: 0, coercions: 16, joins: 0/0}
chainr :: forall a. ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.chainr2
               `cast` (forall (a :: <*>_N).
                       <ReadP a>_R
                       ->_R <ReadP (a -> a -> a)>_R
                       ->_R <a>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                       :: (forall a.
                           ReadP a
                           -> ReadP (a -> a -> a) -> a -> forall b. (a -> P b) -> P b :: *)
                          ~R# (forall a.
                               ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a :: *))}]
chainr
  = Text.ParserCombinators.ReadP.chainr2
    `cast` (forall (a :: <*>_N).
            <ReadP a>_R
            ->_R <ReadP (a -> a -> a)>_R
            ->_R <a>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
            :: (forall a.
                ReadP a
                -> ReadP (a -> a -> a) -> a -> forall b. (a -> P b) -> P b :: *)
               ~R# (forall a.
                    ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a :: *))

-- RHS size: {terms: 26, types: 38, coercions: 8, joins: 0/1}
Text.ParserCombinators.ReadP.chainl3
  :: forall a.
     ReadP a -> ReadP (a -> a -> a) -> forall b. (a -> P b) -> P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [120 60 0] 260 0}]
Text.ParserCombinators.ReadP.chainl3
  = \ (@ a_a3nyq)
      (p_a3njD :: ReadP a_a3nyq)
      (op_a3njE :: ReadP (a_a3nyq -> a_a3nyq -> a_a3nyq))
      (@ b_a3ngn)
      (eta_B1 :: a_a3nyq -> P b_a3ngn) ->
      letrec {
        rest_s3o1r [Occ=LoopBreaker]
          :: a_a3nyq -> forall b1. (a_a3nyq -> P b1) -> P b1
        [LclId, Arity=2, Str=<L,U><L,C(U)>, Unf=OtherCon []]
        rest_s3o1r
          = \ (x_a3njG :: a_a3nyq)
              (@ b1_X3nls)
              (eta1_X57 :: a_a3nyq -> P b1_X3nls) ->
              Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                @ b1_X3nls
                ((op_a3njE
                  `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <a_a3nyq -> a_a3nyq -> a_a3nyq>_R
                          :: (ReadP (a_a3nyq -> a_a3nyq -> a_a3nyq) :: *)
                             ~R# (forall b.
                                  ((a_a3nyq -> a_a3nyq -> a_a3nyq) -> P b) -> P b :: *)))
                   @ b1_X3nls
                   (\ (a1_a3ngt :: a_a3nyq -> a_a3nyq -> a_a3nyq) ->
                      (p_a3njD
                       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nyq>_R
                               :: (ReadP a_a3nyq :: *)
                                  ~R# (forall b. (a_a3nyq -> P b) -> P b :: *)))
                        @ b1_X3nls
                        (\ (a2_X3nkS :: a_a3nyq) ->
                           rest_s3o1r (a1_a3ngt x_a3njG a2_X3nkS) @ b1_X3nls eta1_X57)))
                (eta1_X57 x_a3njG); } in
      (p_a3njD
       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nyq>_R
               :: (ReadP a_a3nyq :: *)
                  ~R# (forall b. (a_a3nyq -> P b) -> P b :: *)))
        @ b_a3ngn
        (\ (a1_a3ngt :: a_a3nyq) -> rest_s3o1r a1_a3ngt @ b_a3ngn eta_B1)

-- RHS size: {terms: 1, types: 0, coercions: 14, joins: 0/0}
chainl1 :: forall a. ReadP a -> ReadP (a -> a -> a) -> ReadP a
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.chainl3
               `cast` (forall (a :: <*>_N).
                       <ReadP a>_R
                       ->_R <ReadP (a -> a -> a)>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                       :: (forall a.
                           ReadP a -> ReadP (a -> a -> a) -> forall b. (a -> P b) -> P b :: *)
                          ~R# (forall a. ReadP a -> ReadP (a -> a -> a) -> ReadP a :: *))}]
chainl1
  = Text.ParserCombinators.ReadP.chainl3
    `cast` (forall (a :: <*>_N).
            <ReadP a>_R
            ->_R <ReadP (a -> a -> a)>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
            :: (forall a.
                ReadP a -> ReadP (a -> a -> a) -> forall b. (a -> P b) -> P b :: *)
               ~R# (forall a. ReadP a -> ReadP (a -> a -> a) -> ReadP a :: *))

-- RHS size: {terms: 13, types: 17, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.chainl2
  :: forall a.
     ReadP a -> ReadP (a -> a -> a) -> a -> forall b. (a -> P b) -> P b
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a3nyY)
                 (p_a3njt [Occ=Once] :: ReadP a_a3nyY)
                 (op_a3nju [Occ=Once] :: ReadP (a_a3nyY -> a_a3nyY -> a_a3nyY))
                 (x_a3njv [Occ=Once] :: a_a3nyY)
                 (@ b_a3ngn)
                 (eta_B1 :: a_a3nyY -> P b_a3ngn) ->
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b_a3ngn
                   (Text.ParserCombinators.ReadP.chainl3
                      @ a_a3nyY p_a3njt op_a3nju @ b_a3ngn eta_B1)
                   (eta_B1 x_a3njv)}]
Text.ParserCombinators.ReadP.chainl2
  = \ (@ a_a3nyY)
      (p_a3njt :: ReadP a_a3nyY)
      (op_a3nju :: ReadP (a_a3nyY -> a_a3nyY -> a_a3nyY))
      (x_a3njv :: a_a3nyY)
      (@ b_a3ngn)
      (eta_B1 :: a_a3nyY -> P b_a3ngn) ->
      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
        @ b_a3ngn
        (Text.ParserCombinators.ReadP.chainl3
           @ a_a3nyY p_a3njt op_a3nju @ b_a3ngn eta_B1)
        (eta_B1 x_a3njv)

-- RHS size: {terms: 1, types: 0, coercions: 16, joins: 0/0}
chainl :: forall a. ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.chainl2
               `cast` (forall (a :: <*>_N).
                       <ReadP a>_R
                       ->_R <ReadP (a -> a -> a)>_R
                       ->_R <a>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                       :: (forall a.
                           ReadP a
                           -> ReadP (a -> a -> a) -> a -> forall b. (a -> P b) -> P b :: *)
                          ~R# (forall a.
                               ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a :: *))}]
chainl
  = Text.ParserCombinators.ReadP.chainl2
    `cast` (forall (a :: <*>_N).
            <ReadP a>_R
            ->_R <ReadP (a -> a -> a)>_R
            ->_R <a>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
            :: (forall a.
                ReadP a
                -> ReadP (a -> a -> a) -> a -> forall b. (a -> P b) -> P b :: *)
               ~R# (forall a.
                    ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a :: *))

Rec {
-- RHS size: {terms: 18, types: 12, coercions: 0, joins: 0/1}
Text.ParserCombinators.ReadP.<++2 [Occ=LoopBreaker]
  :: Int# -> forall b. (() -> P b) -> P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []]
Text.ParserCombinators.ReadP.<++2
  = \ (ds_d3nRx :: Int#) (@ b_X3nlD) (eta_X5i :: () -> P b_X3nlD) ->
      case ds_d3nRx of ds1_X3nTb {
        __DEFAULT ->
          let {
            lvl4_s3o2t :: P b_X3nlD
            [LclId]
            lvl4_s3o2t
              = Text.ParserCombinators.ReadP.<++2
                  (-# ds1_X3nTb 1#) @ b_X3nlD eta_X5i } in
          Text.ParserCombinators.ReadP.Get
            @ b_X3nlD (\ _ [Occ=Dead] -> lvl4_s3o2t);
        0# -> eta_X5i GHC.Tuple.()
      }
end Rec }

-- RHS size: {terms: 59, types: 73, coercions: 6, joins: 0/2}
Text.ParserCombinators.ReadP.$w<++ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     ReadP a -> ReadP a -> forall b. (a -> P b) -> (# String -> P b #)
[GblId,
 Arity=3,
 Str=<L,1*C1(U)><L,C(U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 120 0] 491 20}]
Text.ParserCombinators.ReadP.$w<++
  = \ (@ a_s3ohU)
      (w_s3ohV :: ReadP a_s3ohU)
      (w1_s3ohW :: ReadP a_s3ohU)
      (@ b_s3ohX)
      (w2_s3ohY :: a_s3ohU -> P b_s3ohX) ->
      let {
        lvl4_s3o2v :: P a_s3ohU
        [LclId]
        lvl4_s3o2v
          = (w_s3ohV
             `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_s3ohU>_R
                     :: (ReadP a_s3ohU :: *)
                        ~R# (forall b. (a_s3ohU -> P b) -> P b :: *)))
              @ a_s3ohU
              (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ a_s3ohU) } in
      letrec {
        probe_s3odd [Occ=LoopBreaker]
          :: P a_s3ohU
             -> [Char] -> Int# -> forall b1. (a_s3ohU -> P b1) -> P b1
        [LclId, Arity=4, Str=<S,1*U><L,U><L,U><L,U>, Unf=OtherCon []]
        probe_s3odd
          = \ (ds_d3nR3 :: P a_s3ohU)
              (ds1_d3nR4 :: [Char])
              (n_a3nie :: Int#)
              (@ b1_X3nlg)
              (eta_X4V :: a_s3ohU -> P b1_X3nlg) ->
              case ds_d3nR3 of wild_X4q {
                Get f_a3nib ->
                  case ds1_d3nR4 of {
                    [] ->
                      (w1_s3ohW
                       `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_s3ohU>_R
                               :: (ReadP a_s3ohU :: *)
                                  ~R# (forall b. (a_s3ohU -> P b) -> P b :: *)))
                        @ b1_X3nlg eta_X4V;
                    : c_a3nic s_a3nid ->
                      probe_s3odd
                        (f_a3nib c_a3nic) s_a3nid (+# n_a3nie 1#) @ b1_X3nlg eta_X4V
                  };
                Look f_a3nif ->
                  probe_s3odd
                    (f_a3nif ds1_d3nR4) ds1_d3nR4 n_a3nie @ b1_X3nlg eta_X4V;
                Fail ->
                  (w1_s3ohW
                   `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_s3ohU>_R
                           :: (ReadP a_s3ohU :: *)
                              ~R# (forall b. (a_s3ohU -> P b) -> P b :: *)))
                    @ b1_X3nlg eta_X4V;
                Result ds2_d3nRt ds3_d3nRu ->
                  Text.ParserCombinators.ReadP.<++2
                    n_a3nie
                    @ b1_X3nlg
                    (\ _ [Occ=Dead, OS=OneShot] ->
                       Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                         @ a_s3ohU @ b1_X3nlg wild_X4q eta_X4V);
                Final r_a3nik ->
                  Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                    @ a_s3ohU @ b1_X3nlg wild_X4q eta_X4V
              }; } in
      (# \ (a1_a3ngt :: String) ->
           probe_s3odd lvl4_s3o2v a1_a3ngt 0# @ b_s3ohX w2_s3ohY #)

-- RHS size: {terms: 13, types: 22, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.<++1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. ReadP a -> ReadP a -> forall b. (a -> P b) -> P b
[GblId,
 Arity=3,
 Str=<L,1*C1(U)><L,C(U)><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s3ohU)
                 (w_s3ohV [Occ=Once] :: ReadP a_s3ohU)
                 (w1_s3ohW [Occ=Once] :: ReadP a_s3ohU)
                 (@ b_s3ohX)
                 (w2_s3ohY [Occ=Once] :: a_s3ohU -> P b_s3ohX) ->
                 case Text.ParserCombinators.ReadP.$w<++
                        @ a_s3ohU w_s3ohV w1_s3ohW @ b_s3ohX w2_s3ohY
                 of
                 { (# ww1_s3oiI [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Look @ b_s3ohX ww1_s3oiI
                 }}]
Text.ParserCombinators.ReadP.<++1
  = \ (@ a_s3ohU)
      (w_s3ohV :: ReadP a_s3ohU)
      (w1_s3ohW :: ReadP a_s3ohU)
      (@ b_s3ohX)
      (w2_s3ohY :: a_s3ohU -> P b_s3ohX) ->
      case Text.ParserCombinators.ReadP.$w<++
             @ a_s3ohU w_s3ohV w1_s3ohW @ b_s3ohX w2_s3ohY
      of
      { (# ww1_s3oiI #) ->
      Text.ParserCombinators.ReadP.Look @ b_s3ohX ww1_s3oiI
      }

-- RHS size: {terms: 1, types: 0, coercions: 12, joins: 0/0}
<++ :: forall a. ReadP a -> ReadP a -> ReadP a
[GblId,
 Arity=3,
 Str=<L,1*C1(U)><L,C(U)><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.<++1
               `cast` (forall (a :: <*>_N).
                       <ReadP a>_R
                       ->_R <ReadP a>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                       :: (forall a.
                           ReadP a -> ReadP a -> forall b. (a -> P b) -> P b :: *)
                          ~R# (forall a. ReadP a -> ReadP a -> ReadP a :: *))}]
<++
  = Text.ParserCombinators.ReadP.<++1
    `cast` (forall (a :: <*>_N).
            <ReadP a>_R
            ->_R <ReadP a>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
            :: (forall a.
                ReadP a -> ReadP a -> forall b. (a -> P b) -> P b :: *)
               ~R# (forall a. ReadP a -> ReadP a -> ReadP a :: *))

-- RHS size: {terms: 39, types: 80, coercions: 12, joins: 0/4}
Text.ParserCombinators.ReadP.manyTill1
  :: forall a end.
     ReadP a -> ReadP end -> forall b. ([a] -> P b) -> P b
[GblId,
 Arity=3,
 Str=<L,C(U)><L,C(U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60 0] 290 0}]
Text.ParserCombinators.ReadP.manyTill1
  = \ (@ a_a3nB6)
      (@ end_a3nB7)
      (p_a3njJ :: ReadP a_a3nB6)
      (end1_a3njK :: ReadP end_a3nB7)
      (@ b_a3ngn)
      (eta_B1 :: [a_a3nB6] -> P b_a3ngn) ->
      let {
        scan_s3o1j [Dmd=<L,C(U)>] :: forall b1. ([a_a3nB6] -> P b1) -> P b1
        [LclId,
         Arity=1,
         Str=<L,1*C1(U)>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
                 Tmpl= \ (@ b1_a3nIU)
                         (k_a3ngs [Occ=Once!] :: [a_a3nB6] -> P b1_a3nIU) ->
                         let {
                           lvl4_s3o2w [Occ=OnceL] :: P b1_a3nIU
                           [LclId]
                           lvl4_s3o2w = k_a3ngs (GHC.Types.[] @ a_a3nB6) } in
                         (end1_a3njK
                          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <end_a3nB7>_R
                                  :: (ReadP end_a3nB7 :: *)
                                     ~R# (forall b. (end_a3nB7 -> P b) -> P b :: *)))
                           @ b1_a3nIU (\ _ [Occ=Dead] -> lvl4_s3o2w)}]
        scan_s3o1j
          = \ (@ b1_a3nIU) (k_a3ngs :: [a_a3nB6] -> P b1_a3nIU) ->
              let {
                lvl4_s3o2w :: P b1_a3nIU
                [LclId]
                lvl4_s3o2w = k_a3ngs (GHC.Types.[] @ a_a3nB6) } in
              (end1_a3njK
               `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <end_a3nB7>_R
                       :: (ReadP end_a3nB7 :: *)
                          ~R# (forall b. (end_a3nB7 -> P b) -> P b :: *)))
                @ b1_a3nIU (\ _ [Occ=Dead] -> lvl4_s3o2w) } in
      letrec {
        scan1_s3o1h :: forall b1. ([a_a3nB6] -> P b1) -> P b1
        [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []]
        scan1_s3o1h
          = \ (@ b1_X3nOr) (k_X3nm0 :: [a_a3nB6] -> P b1_X3nOr) ->
              (p_a3njJ
               `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a3nB6>_R
                       :: (ReadP a_a3nB6 :: *)
                          ~R# (forall b. (a_a3nB6 -> P b) -> P b :: *)))
                @ b1_X3nOr
                (\ (a1_a3ngt :: a_a3nB6) ->
                   scan2_s3o1i
                     @ b1_X3nOr
                     (\ (a2_X3nkV :: [a_a3nB6]) ->
                        k_X3nm0 (GHC.Types.: @ a_a3nB6 a1_a3ngt a2_X3nkV)));
        scan2_s3o1i [Occ=LoopBreaker]
          :: forall b1. ([a_a3nB6] -> P b1) -> P b1
        [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
        scan2_s3o1i
          = \ (@ b1_s3ohX) (w_s3ohY :: [a_a3nB6] -> P b1_s3ohX) ->
              case Text.ParserCombinators.ReadP.$w<++
                     @ [a_a3nB6]
                     (scan_s3o1j
                      `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a_a3nB6]>_R)
                              :: (forall b. ([a_a3nB6] -> P b) -> P b :: *)
                                 ~R# (ReadP [a_a3nB6] :: *)))
                     (scan1_s3o1h
                      `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a_a3nB6]>_R)
                              :: (forall b. ([a_a3nB6] -> P b) -> P b :: *)
                                 ~R# (ReadP [a_a3nB6] :: *)))
                     @ b1_s3ohX
                     w_s3ohY
              of
              { (# ww1_s3oiI #) ->
              Text.ParserCombinators.ReadP.Look @ b1_s3ohX ww1_s3oiI
              }; } in
      scan2_s3o1i @ b_a3ngn eta_B1

-- RHS size: {terms: 1, types: 0, coercions: 16, joins: 0/0}
manyTill :: forall a end. ReadP a -> ReadP end -> ReadP [a]
[GblId,
 Arity=3,
 Str=<L,C(U)><L,C(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.manyTill1
               `cast` (forall (a :: <*>_N) (end :: <*>_N).
                       <ReadP a>_R
                       ->_R <ReadP end>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
                       :: (forall a end.
                           ReadP a -> ReadP end -> forall b. ([a] -> P b) -> P b :: *)
                          ~R# (forall a end. ReadP a -> ReadP end -> ReadP [a] :: *))}]
manyTill
  = Text.ParserCombinators.ReadP.manyTill1
    `cast` (forall (a :: <*>_N) (end :: <*>_N).
            <ReadP a>_R
            ->_R <ReadP end>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <[a]>_R)
            :: (forall a end.
                ReadP a -> ReadP end -> forall b. ([a] -> P b) -> P b :: *)
               ~R# (forall a end. ReadP a -> ReadP end -> ReadP [a] :: *))

-- RHS size: {terms: 13, types: 15, coercions: 0, joins: 0/1}
Text.ParserCombinators.ReadP.eof1 :: forall b. (() -> P b) -> P b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a3nIU) (k_a3ngs [Occ=OnceL!] :: () -> P b_a3nIU) ->
                 Text.ParserCombinators.ReadP.Look
                   @ b_a3nIU
                   (\ (a_a3ngt [Occ=Once!] :: String) ->
                      case a_a3ngt of {
                        [] -> k_a3ngs GHC.Tuple.();
                        : _ [Occ=Dead] _ [Occ=Dead] ->
                          Text.ParserCombinators.ReadP.Fail @ b_a3nIU
                      })}]
Text.ParserCombinators.ReadP.eof1
  = \ (@ b_a3nIU) (k_a3ngs :: () -> P b_a3nIU) ->
      let {
        lvl4_s3omA :: P b_a3nIU
        [LclId]
        lvl4_s3omA = k_a3ngs GHC.Tuple.() } in
      Text.ParserCombinators.ReadP.Look
        @ b_a3nIU
        (\ (a_a3ngt :: String) ->
           case a_a3ngt of {
             [] -> lvl4_s3omA;
             : ds1_i2Mqv ds2_i2Mqw ->
               Text.ParserCombinators.ReadP.Fail @ b_a3nIU
           })

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
eof :: ReadP ()
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.eof1
               `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                       :: (forall b. (() -> P b) -> P b :: *) ~R# (ReadP () :: *))}]
eof
  = Text.ParserCombinators.ReadP.eof1
    `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
            :: (forall b. (() -> P b) -> P b :: *) ~R# (ReadP () :: *))

-- RHS size: {terms: 13, types: 11, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.satisfy1
  :: (Char -> Bool) -> forall b. (Char -> P b) -> P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_a3niC [Occ=OnceL!] :: Char -> Bool)
                 (@ b_X3nNg)
                 (k_X3nkP [Occ=OnceL!] :: Char -> P b_X3nNg) ->
                 Text.ParserCombinators.ReadP.Get
                   @ b_X3nNg
                   (\ (a_a3ngt :: Char) ->
                      case p_a3niC a_a3ngt of {
                        False -> Text.ParserCombinators.ReadP.Fail @ b_X3nNg;
                        True -> k_X3nkP a_a3ngt
                      })}]
Text.ParserCombinators.ReadP.satisfy1
  = \ (p_a3niC :: Char -> Bool)
      (@ b_X3nNg)
      (k_X3nkP :: Char -> P b_X3nNg) ->
      Text.ParserCombinators.ReadP.Get
        @ b_X3nNg
        (\ (a_a3ngt :: Char) ->
           case p_a3niC a_a3ngt of {
             False -> Text.ParserCombinators.ReadP.Fail @ b_X3nNg;
             True -> k_X3nkP a_a3ngt
           })

-- RHS size: {terms: 1, types: 0, coercions: 6, joins: 0/0}
satisfy :: (Char -> Bool) -> ReadP Char
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.satisfy1
               `cast` (<Char -> Bool>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <Char>_R)
                       :: ((Char -> Bool) -> forall b. (Char -> P b) -> P b :: *)
                          ~R# ((Char -> Bool) -> ReadP Char :: *))}]
satisfy
  = Text.ParserCombinators.ReadP.satisfy1
    `cast` (<Char -> Bool>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <Char>_R)
            :: ((Char -> Bool) -> forall b. (Char -> P b) -> P b :: *)
               ~R# ((Char -> Bool) -> ReadP Char :: *))

-- RHS size: {terms: 20, types: 14, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.char1
  :: Char -> forall b. (Char -> P b) -> P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U)><L,C(U)>m1,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (c_a3niE [Occ=OnceL!] :: Char)
                 (@ b_X3nNg)
                 (eta_B1 [Occ=OnceL!] :: Char -> P b_X3nNg) ->
                 Text.ParserCombinators.ReadP.Get
                   @ b_X3nNg
                   (\ (a_a3ngt [Occ=Once!] :: Char) ->
                      case c_a3niE of { C# x_a5ih [Occ=Once] ->
                      case a_a3ngt of wild1_a5ij { C# y_a5il [Occ=Once] ->
                      case eqChar# x_a5ih y_a5il of {
                        __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b_X3nNg;
                        1# -> eta_B1 wild1_a5ij
                      }
                      }
                      })}]
Text.ParserCombinators.ReadP.char1
  = \ (c_a3niE :: Char) (@ b_X3nNg) (eta_B1 :: Char -> P b_X3nNg) ->
      Text.ParserCombinators.ReadP.Get
        @ b_X3nNg
        (\ (a_a3ngt :: Char) ->
           case c_a3niE of { C# x_a5ih ->
           case a_a3ngt of wild1_a5ij { C# y_a5il ->
           case eqChar# x_a5ih y_a5il of {
             __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b_X3nNg;
             1# -> eta_B1 wild1_a5ij
           }
           }
           })

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
char :: Char -> ReadP Char
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U)><L,C(U)>m1,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.char1
               `cast` (<Char>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <Char>_R)
                       :: (Char -> forall b. (Char -> P b) -> P b :: *)
                          ~R# (Char -> ReadP Char :: *))}]
char
  = Text.ParserCombinators.ReadP.char1
    `cast` (<Char>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <Char>_R)
            :: (Char -> forall b. (Char -> P b) -> P b :: *)
               ~R# (Char -> ReadP Char :: *))

-- RHS size: {terms: 46, types: 54, coercions: 0, joins: 0/2}
Text.ParserCombinators.ReadP.$wstring [InlPrag=NOUSERINLINE[0]]
  :: String -> forall b. (String -> P b) -> (# String -> P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 261 20}]
Text.ParserCombinators.ReadP.$wstring
  = \ (w_s3oif :: String)
      (@ b_s3oig)
      (w1_s3oih :: String -> P b_s3oig) ->
      letrec {
        scan_s3o6i [Occ=LoopBreaker]
          :: [Char] -> [Char] -> forall b1. (String -> P b1) -> P b1
        [LclId, Arity=3, Str=<S,1*U><L,1*U><L,1*C1(U)>, Unf=OtherCon []]
        scan_s3o6i
          = \ (ds_d3nRI :: [Char])
              (ds1_d3nRJ :: [Char])
              (@ b1_a3ngn)
              (eta_B1 :: String -> P b1_a3ngn) ->
              case ds_d3nRI of {
                [] -> eta_B1 w_s3oif;
                : x_a3niI xs_a3niJ ->
                  case ds1_d3nRJ of {
                    [] -> Text.ParserCombinators.ReadP.Fail @ b1_a3ngn;
                    : y_a3niK ys_a3niL ->
                      case x_a3niI of { C# x1_a5ih ->
                      case y_a3niK of { C# y1_a5il ->
                      case eqChar# x1_a5ih y1_a5il of {
                        __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1_a3ngn;
                        1# ->
                          let {
                            lvl4_s3o2B :: P b1_a3ngn
                            [LclId]
                            lvl4_s3o2B = scan_s3o6i xs_a3niJ ys_a3niL @ b1_a3ngn eta_B1 } in
                          Text.ParserCombinators.ReadP.Get
                            @ b1_a3ngn (\ _ [Occ=Dead] -> lvl4_s3o2B)
                      }
                      }
                      }
                  }
              }; } in
      (# \ (a_a3ngt :: String) ->
           scan_s3o6i w_s3oif a_a3ngt @ b_s3oig w1_s3oih #)

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.string1 [InlPrag=NOUSERINLINE[0]]
  :: String -> forall b. (String -> P b) -> P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s3oif [Occ=Once] :: String)
                 (@ b_s3oig)
                 (w1_s3oih [Occ=Once] :: String -> P b_s3oig) ->
                 case Text.ParserCombinators.ReadP.$wstring
                        w_s3oif @ b_s3oig w1_s3oih
                 of
                 { (# ww1_s3oiK [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Look @ b_s3oig ww1_s3oiK
                 }}]
Text.ParserCombinators.ReadP.string1
  = \ (w_s3oif :: String)
      (@ b_s3oig)
      (w1_s3oih :: String -> P b_s3oig) ->
      case Text.ParserCombinators.ReadP.$wstring
             w_s3oif @ b_s3oig w1_s3oih
      of
      { (# ww1_s3oiK #) ->
      Text.ParserCombinators.ReadP.Look @ b_s3oig ww1_s3oiK
      }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
string :: String -> ReadP String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.string1
               `cast` (<String>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <String>_R)
                       :: (String -> forall b. (String -> P b) -> P b :: *)
                          ~R# (String -> ReadP String :: *))}]
string
  = Text.ParserCombinators.ReadP.string1
    `cast` (<String>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <String>_R)
            :: (String -> forall b. (String -> P b) -> P b :: *)
               ~R# (String -> ReadP String :: *))

-- RHS size: {terms: 36, types: 47, coercions: 0, joins: 0/2}
Text.ParserCombinators.ReadP.$wmunch [InlPrag=NOUSERINLINE[0]]
  :: (Char -> Bool)
     -> forall b. (String -> P b) -> (# String -> P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 270 20}]
Text.ParserCombinators.ReadP.$wmunch
  = \ (w_s3oip :: Char -> Bool)
      (@ b_s3oiq)
      (w1_s3oir :: String -> P b_s3oiq) ->
      letrec {
        scan_s3odq [Occ=LoopBreaker]
          :: [Char] -> forall b1. ([Char] -> P b1) -> P b1
        [LclId, Arity=2, Str=<S,1*U><L,1*C1(U)>, Unf=OtherCon []]
        scan_s3odq
          = \ (ds_d3nS3 :: [Char])
              (@ b1_X3nlq)
              (eta_X55 :: [Char] -> P b1_X3nlq) ->
              case ds_d3nS3 of {
                [] -> eta_X55 (GHC.Types.[] @ Char);
                : c_a3niP cs_a3niQ ->
                  case w_s3oip c_a3niP of {
                    False -> eta_X55 (GHC.Types.[] @ Char);
                    True ->
                      let {
                        lvl4_s3o2E :: P b1_X3nlq
                        [LclId]
                        lvl4_s3o2E
                          = scan_s3odq
                              cs_a3niQ
                              @ b1_X3nlq
                              (\ (a_X3nlg [OS=OneShot] :: [Char]) ->
                                 eta_X55 (GHC.Types.: @ Char c_a3niP a_X3nlg)) } in
                      Text.ParserCombinators.ReadP.Get
                        @ b1_X3nlq (\ _ [Occ=Dead] -> lvl4_s3o2E)
                  }
              }; } in
      (# \ (a_a3ngt :: String) ->
           scan_s3odq a_a3ngt @ b_s3oiq w1_s3oir #)

-- RHS size: {terms: 10, types: 17, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.munch2 [InlPrag=NOUSERINLINE[0]]
  :: (Char -> Bool) -> forall b. (String -> P b) -> P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s3oip [Occ=Once] :: Char -> Bool)
                 (@ b_s3oiq)
                 (w1_s3oir [Occ=Once] :: String -> P b_s3oiq) ->
                 case Text.ParserCombinators.ReadP.$wmunch
                        w_s3oip @ b_s3oiq w1_s3oir
                 of
                 { (# ww1_s3oiM [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Look @ b_s3oiq ww1_s3oiM
                 }}]
Text.ParserCombinators.ReadP.munch2
  = \ (w_s3oip :: Char -> Bool)
      (@ b_s3oiq)
      (w1_s3oir :: String -> P b_s3oiq) ->
      case Text.ParserCombinators.ReadP.$wmunch
             w_s3oip @ b_s3oiq w1_s3oir
      of
      { (# ww1_s3oiM #) ->
      Text.ParserCombinators.ReadP.Look @ b_s3oiq ww1_s3oiM
      }

-- RHS size: {terms: 1, types: 0, coercions: 6, joins: 0/0}
munch :: (Char -> Bool) -> ReadP String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.munch2
               `cast` (<Char -> Bool>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <String>_R)
                       :: ((Char -> Bool) -> forall b. (String -> P b) -> P b :: *)
                          ~R# ((Char -> Bool) -> ReadP String :: *))}]
munch
  = Text.ParserCombinators.ReadP.munch2
    `cast` (<Char -> Bool>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <String>_R)
            :: ((Char -> Bool) -> forall b. (String -> P b) -> P b :: *)
               ~R# ((Char -> Bool) -> ReadP String :: *))

-- RHS size: {terms: 22, types: 26, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.$wmunch1 [InlPrag=NOUSERINLINE[0]]
  :: (Char -> Bool) -> forall b. (String -> P b) -> (# Char -> P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60] 140 20}]
Text.ParserCombinators.ReadP.$wmunch1
  = \ (w_s3oiw :: Char -> Bool)
      (@ b_s3oix)
      (w1_s3oiy :: String -> P b_s3oix) ->
      (# \ (a_a3ngt :: Char) ->
           case w_s3oiw a_a3ngt of {
             False -> Text.ParserCombinators.ReadP.Fail @ b_s3oix;
             True ->
               case Text.ParserCombinators.ReadP.$wmunch
                      w_s3oiw
                      @ b_s3oix
                      (\ (a1_X3nla :: String) ->
                         w1_s3oiy (GHC.Types.: @ Char a_a3ngt a1_X3nla))
               of
               { (# ww1_s3oiM #) ->
               Text.ParserCombinators.ReadP.Look @ b_s3oix ww1_s3oiM
               }
           } #)

-- RHS size: {terms: 10, types: 17, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.munch3 [InlPrag=NOUSERINLINE[0]]
  :: (Char -> Bool) -> forall b. (String -> P b) -> P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s3oiw [Occ=Once] :: Char -> Bool)
                 (@ b_s3oix)
                 (w1_s3oiy [Occ=Once] :: String -> P b_s3oix) ->
                 case Text.ParserCombinators.ReadP.$wmunch1
                        w_s3oiw @ b_s3oix w1_s3oiy
                 of
                 { (# ww1_s3oiO [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Get @ b_s3oix ww1_s3oiO
                 }}]
Text.ParserCombinators.ReadP.munch3
  = \ (w_s3oiw :: Char -> Bool)
      (@ b_s3oix)
      (w1_s3oiy :: String -> P b_s3oix) ->
      case Text.ParserCombinators.ReadP.$wmunch1
             w_s3oiw @ b_s3oix w1_s3oiy
      of
      { (# ww1_s3oiO #) ->
      Text.ParserCombinators.ReadP.Get @ b_s3oix ww1_s3oiO
      }

-- RHS size: {terms: 1, types: 0, coercions: 6, joins: 0/0}
munch1 :: (Char -> Bool) -> ReadP String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.munch3
               `cast` (<Char -> Bool>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <String>_R)
                       :: ((Char -> Bool) -> forall b. (String -> P b) -> P b :: *)
                          ~R# ((Char -> Bool) -> ReadP String :: *))}]
munch1
  = Text.ParserCombinators.ReadP.munch3
    `cast` (<Char -> Bool>_R
            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <String>_R)
            :: ((Char -> Bool) -> forall b. (String -> P b) -> P b :: *)
               ~R# ((Char -> Bool) -> ReadP String :: *))

Rec {
-- RHS size: {terms: 80, types: 51, coercions: 0, joins: 0/5}
Text.ParserCombinators.ReadP.skipSpaces2 [Occ=LoopBreaker]
  :: [Char] -> forall b. (() -> P b) -> P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []]
Text.ParserCombinators.ReadP.skipSpaces2
  = \ (ds_d3nSl :: [Char]) (@ b_a3ngn) (eta_B1 :: () -> P b_a3ngn) ->
      case ds_d3nSl of {
        [] -> eta_B1 GHC.Tuple.();
        : c_a3nj0 s_a3nj1 ->
          case c_a3nj0 of { C# ww1_s2iEf ->
          let {
            x_aRFM [Dmd=<S,U>] :: Word#
            [LclId]
            x_aRFM = int2Word# (ord# ww1_s2iEf) } in
          case leWord# x_aRFM 887## of {
            __DEFAULT ->
              case {__pkg_ccall base-4.11.0.0 Int#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_d2hP4
                     (ord# ww1_s2iEf) realWorld#
              of
              { (# ds1_d2hP3, ds2_d2hP2 #) ->
              case ds2_d2hP2 of {
                __DEFAULT ->
                  let {
                    lvl4_s3o2H :: P b_a3ngn
                    [LclId]
                    lvl4_s3o2H
                      = Text.ParserCombinators.ReadP.skipSpaces2
                          s_a3nj1 @ b_a3ngn eta_B1 } in
                  Text.ParserCombinators.ReadP.Get
                    @ b_a3ngn (\ _ [Occ=Dead] -> lvl4_s3o2H);
                0# -> eta_B1 GHC.Tuple.()
              }
              };
            1# ->
              case x_aRFM of wild1_X7V {
                __DEFAULT ->
                  case leWord# (minusWord# wild1_X7V 9##) 4## of {
                    __DEFAULT ->
                      case wild1_X7V of {
                        __DEFAULT -> eta_B1 GHC.Tuple.();
                        160## ->
                          let {
                            lvl4_s3o2H :: P b_a3ngn
                            [LclId]
                            lvl4_s3o2H
                              = Text.ParserCombinators.ReadP.skipSpaces2
                                  s_a3nj1 @ b_a3ngn eta_B1 } in
                          Text.ParserCombinators.ReadP.Get
                            @ b_a3ngn (\ _ [Occ=Dead] -> lvl4_s3o2H)
                      };
                    1# ->
                      let {
                        lvl4_s3o2H :: P b_a3ngn
                        [LclId]
                        lvl4_s3o2H
                          = Text.ParserCombinators.ReadP.skipSpaces2
                              s_a3nj1 @ b_a3ngn eta_B1 } in
                      Text.ParserCombinators.ReadP.Get
                        @ b_a3ngn (\ _ [Occ=Dead] -> lvl4_s3o2H)
                  };
                32## ->
                  let {
                    lvl4_s3o2H :: P b_a3ngn
                    [LclId]
                    lvl4_s3o2H
                      = Text.ParserCombinators.ReadP.skipSpaces2
                          s_a3nj1 @ b_a3ngn eta_B1 } in
                  Text.ParserCombinators.ReadP.Get
                    @ b_a3ngn (\ _ [Occ=Dead] -> lvl4_s3o2H)
              }
          }
          }
      }
end Rec }

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
Text.ParserCombinators.ReadP.skipSpaces1
  :: forall b. (() -> P b) -> P b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_X3nNv) (k_X3nl4 [Occ=OnceL] :: () -> P b_X3nNv) ->
                 Text.ParserCombinators.ReadP.Look
                   @ b_X3nNv
                   (\ (a_a3ngt [Occ=Once] :: String) ->
                      Text.ParserCombinators.ReadP.skipSpaces2
                        a_a3ngt @ b_X3nNv k_X3nl4)}]
Text.ParserCombinators.ReadP.skipSpaces1
  = \ (@ b_X3nNv) (k_X3nl4 :: () -> P b_X3nNv) ->
      Text.ParserCombinators.ReadP.Look
        @ b_X3nNv
        (\ (a_a3ngt :: String) ->
           Text.ParserCombinators.ReadP.skipSpaces2 a_a3ngt @ b_X3nNv k_X3nl4)

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
skipSpaces :: ReadP ()
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Text.ParserCombinators.ReadP.skipSpaces1
               `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                       :: (forall b. (() -> P b) -> P b :: *) ~R# (ReadP () :: *))}]
skipSpaces
  = Text.ParserCombinators.ReadP.skipSpaces1
    `cast` (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
            :: (forall b. (() -> P b) -> P b :: *) ~R# (ReadP () :: *))


