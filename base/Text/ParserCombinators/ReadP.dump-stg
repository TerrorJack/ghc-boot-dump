
==================== Pre unarise: ====================
2018-03-16 15:58:00.547819814 UTC

Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
  :: forall a. a -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m4, Unf=OtherCon []] =
    [] \r [x_s3oqX]
        Text.ParserCombinators.ReadP.Result [x_s3oqX
                                             Text.ParserCombinators.ReadP.Fail];

Text.ParserCombinators.ReadP.$fMonadFailP_$cfail
  :: forall a. GHC.Base.String -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s3oqY] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadP.$fFunctorReadP2
  :: forall a b.
     (a -> b)
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><C(S),1*C1(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [h_s3oqZ ds_s3or0 k_s3or1]
        let {
          sat_s3or2 [Occ=Once]
            :: a_a3nKO -> Text.ParserCombinators.ReadP.P b1_a3nKT
          [LclId] =
              [h_s3oqZ k_s3or1] \r [eta_B1] GHC.Base.. k_s3or1 h_s3oqZ eta_B1;
        } in  ds_s3or0 sat_s3or2;

Text.ParserCombinators.ReadP.$fFunctorReadP1
  :: forall a b.
     a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (a -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [x_s3or3 eta_s3or4 eta1_s3or5]
        let {
          lvl4_s3or6 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [x_s3or3 eta1_s3or5] \u [] eta1_s3or5 x_s3or3; } in
        let {
          sat_s3or8 [Occ=Once]
            :: b_a3nL5 -> Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [lvl4_s3or6] \r [x1_s3or7] lvl4_s3or6;
        } in  eta_s3or4 sat_s3or8;

Text.ParserCombinators.ReadP.$fFunctorReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Text.ParserCombinators.ReadP.$fFunctorReadP2
                                       Text.ParserCombinators.ReadP.$fFunctorReadP1];

Text.ParserCombinators.ReadP.$fApplicativeReadP5
  :: forall a.
     a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [x_s3or9 k_s3ora] k_s3ora x_s3or9;

Text.ParserCombinators.ReadP.$fMonadFailReadP1
  :: forall a.
     GHC.Base.String
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_s3orb ds1_s3orc] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadP.$fMonadReadP1
  :: forall a b.
     Text.ParserCombinators.ReadP.ReadP a
     -> (a -> Text.ParserCombinators.ReadP.ReadP b)
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3ord f_s3ore k_s3orf]
        let {
          sat_s3orh [Occ=Once]
            :: a_a3nIP -> Text.ParserCombinators.ReadP.P b1_a3nIU
          [LclId] =
              [f_s3ore k_s3orf] \r [a1_s3org] f_s3ore a1_s3org k_s3orf;
        } in  ds_s3ord sat_s3orh;

Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap [Occ=LoopBreaker]
  :: forall a b.
     (a -> b)
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s3ori ds_s3orj]
        case ds_s3orj of {
          Text.ParserCombinators.ReadP.Get a1_s3orl [Occ=OnceL!] ->
              let {
                sat_s3oro [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_a3nEm
                [LclId] =
                    [f_s3ori a1_s3orl] \r [b3_s3orm]
                        case a1_s3orl b3_s3orm of sat_s3orn {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                                  f_s3ori sat_s3orn;
                        };
              } in  Text.ParserCombinators.ReadP.Get [sat_s3oro];
          Text.ParserCombinators.ReadP.Look a1_s3orp [Occ=OnceL!] ->
              let {
                sat_s3ors [Occ=Once]
                  :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3nEm
                [LclId] =
                    [f_s3ori a1_s3orp] \r [b3_s3orq]
                        case a1_s3orp b3_s3orq of sat_s3orr {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                                  f_s3ori sat_s3orr;
                        };
              } in  Text.ParserCombinators.ReadP.Look [sat_s3ors];
          Text.ParserCombinators.ReadP.Fail ->
              Text.ParserCombinators.ReadP.Fail [];
          Text.ParserCombinators.ReadP.Result a1_s3ort [Occ=Once]
                                              a2_s3oru [Occ=Once] ->
              let {
                sat_s3orw [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nEm
                [LclId] =
                    [f_s3ori a2_s3oru] \u []
                        Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                            f_s3ori a2_s3oru; } in
              let {
                sat_s3orv [Occ=Once] :: b_a3nEm
                [LclId] =
                    [f_s3ori a1_s3ort] \u [] f_s3ori a1_s3ort;
              } in  Text.ParserCombinators.ReadP.Result [sat_s3orv sat_s3orw];
          Text.ParserCombinators.ReadP.Final a1_s3orx [Occ=Once] ->
              let {
                sat_s3orE [Occ=Once] :: [(b_a3nEm, GHC.Base.String)]
                [LclId] =
                    [f_s3ori a1_s3orx] \u []
                        let {
                          sat_s3orD [Occ=Once]
                            :: (a_a3nEl, GHC.Base.String) -> (b_a3nEm, GHC.Base.String)
                          [LclId] =
                              [f_s3ori] \r [b2_s3ory]
                                  case b2_s3ory of {
                                    (,) a2_s3orA [Occ=Once] a3_s3orB [Occ=Once] ->
                                        let {
                                          sat_s3orC [Occ=Once] :: b_a3nEm
                                          [LclId] =
                                              [f_s3ori a2_s3orA] \u [] f_s3ori a2_s3orA;
                                        } in  (,) [sat_s3orC a3_s3orB];
                                  };
                        } in  GHC.Base.map sat_s3orD a1_s3orx;
              } in  Text.ParserCombinators.ReadP.Final [sat_s3orE];
        };

Text.ParserCombinators.ReadP.$fApplicativeP_$c<$ [Occ=LoopBreaker]
  :: forall a b.
     a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [z_s3orF ds_s3orG]
        case ds_s3orG of {
          Text.ParserCombinators.ReadP.Get a1_s3orI [Occ=OnceL!] ->
              let {
                sat_s3orL [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P a_a3nFG
                [LclId] =
                    [z_s3orF a1_s3orI] \r [b4_s3orJ]
                        case a1_s3orI b4_s3orJ of sat_s3orK {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fApplicativeP_$c<$ z_s3orF sat_s3orK;
                        };
              } in  Text.ParserCombinators.ReadP.Get [sat_s3orL];
          Text.ParserCombinators.ReadP.Look a1_s3orM [Occ=OnceL!] ->
              let {
                sat_s3orP [Occ=Once]
                  :: GHC.Base.String -> Text.ParserCombinators.ReadP.P a_a3nFG
                [LclId] =
                    [z_s3orF a1_s3orM] \r [b4_s3orN]
                        case a1_s3orM b4_s3orN of sat_s3orO {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fApplicativeP_$c<$ z_s3orF sat_s3orO;
                        };
              } in  Text.ParserCombinators.ReadP.Look [sat_s3orP];
          Text.ParserCombinators.ReadP.Fail ->
              Text.ParserCombinators.ReadP.Fail [];
          Text.ParserCombinators.ReadP.Result _ [Occ=Dead]
                                              a2_s3orR [Occ=Once] ->
              let {
                sat_s3orS [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nFG
                [LclId] =
                    [z_s3orF a2_s3orR] \u []
                        Text.ParserCombinators.ReadP.$fApplicativeP_$c<$ z_s3orF a2_s3orR;
              } in  Text.ParserCombinators.ReadP.Result [z_s3orF sat_s3orS];
          Text.ParserCombinators.ReadP.Final a1_s3orT [Occ=Once] ->
              let {
                sat_s3orZ [Occ=Once] :: [(a_a3nFG, GHC.Base.String)]
                [LclId] =
                    [z_s3orF a1_s3orT] \u []
                        let {
                          sat_s3orY [Occ=Once]
                            :: (b_a3nFH, GHC.Base.String) -> (a_a3nFG, GHC.Base.String)
                          [LclId] =
                              [z_s3orF] \r [b3_s3orU]
                                  case b3_s3orU of {
                                    (,) _ [Occ=Dead] a3_s3orX [Occ=Once] -> (,) [z_s3orF a3_s3orX];
                                  };
                        } in  GHC.Base.map sat_s3orY a1_s3orT;
              } in  Text.ParserCombinators.ReadP.Final [sat_s3orZ];
        };

Text.ParserCombinators.ReadP.$fFunctorP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Text.ParserCombinators.ReadP.P
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                                       Text.ParserCombinators.ReadP.$fApplicativeP_$c<$];

Text.ParserCombinators.ReadP.run [Occ=LoopBreaker]
  :: forall a.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3os0 ds1_s3os1]
        case ds_s3os0 of {
          Text.ParserCombinators.ReadP.Get f_s3os3 [Occ=Once!] ->
              case ds1_s3os1 of {
                [] -> [] [];
                : c_s3os5 [Occ=Once] s_s3os6 [Occ=Once] ->
                    case f_s3os3 c_s3os5 of sat_s3os7 {
                      __DEFAULT -> Text.ParserCombinators.ReadP.run sat_s3os7 s_s3os6;
                    };
              };
          Text.ParserCombinators.ReadP.Look f_s3os8 [Occ=Once!] ->
              case f_s3os8 ds1_s3os1 of sat_s3os9 {
                __DEFAULT -> Text.ParserCombinators.ReadP.run sat_s3os9 ds1_s3os1;
              };
          Text.ParserCombinators.ReadP.Fail -> [] [];
          Text.ParserCombinators.ReadP.Result x_s3osa [Occ=Once]
                                              p_s3osb [Occ=Once] ->
              let {
                sat_s3osd [Occ=Once] :: [(a_a3nDL, GHC.Base.String)]
                [LclId] =
                    [ds1_s3os1 p_s3osb] \u []
                        Text.ParserCombinators.ReadP.run p_s3osb ds1_s3os1; } in
              let {
                sat_s3osc [Occ=Once] :: (a_a3nDL, GHC.Base.String)
                [LclId] =
                    CCCS (,)! [x_s3osa ds1_s3os1];
              } in  : [sat_s3osc sat_s3osd];
          Text.ParserCombinators.ReadP.Final r_s3ose [Occ=Once] -> r_s3ose;
        };

Text.ParserCombinators.ReadP.$wreadS_to_P [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3osf w1_s3osg]
        let {
          go_s3osh [Occ=LoopBreaker]
            :: [(a_s3ofE, GHC.Base.String)] -> [(b_s3ofG, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w1_s3osg go_s3osh] \r [ds_s3osi]
                  case ds_s3osi of {
                    [] -> [] [];
                    : y_s3osk [Occ=Once!] ys_s3osl [Occ=Once] ->
                        case y_s3osk of {
                          (,) a1_s3osn [Occ=Once] s'_s3oso [Occ=Once] ->
                              let {
                                sat_s3osr [Occ=Once, Dmd=<L,1*U>] :: [(b_s3ofG, GHC.Base.String)]
                                [LclId] =
                                    [go_s3osh ys_s3osl] \s [] go_s3osh ys_s3osl;
                              } in 
                                case w1_s3osg a1_s3osn of sat_s3osp {
                                  __DEFAULT ->
                                      case
                                          Text.ParserCombinators.ReadP.run sat_s3osp s'_s3oso
                                      of
                                      sat_s3osq
                                      { __DEFAULT -> GHC.Base.++ sat_s3osq sat_s3osr;
                                      };
                                };
                        };
                  }; } in
        let {
          sat_s3osx [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3ofG
          [LclId] =
              [w_s3osf go_s3osh] \r [s_s3oss]
                  case w_s3osf s_s3oss of sat_s3ost {
                    __DEFAULT ->
                        case go_s3osh sat_s3ost of wild_s3osu {
                          [] -> Text.ParserCombinators.ReadP.Fail [];
                          : _ [Occ=Dead] _ [Occ=Dead] ->
                              Text.ParserCombinators.ReadP.Final [wild_s3osu];
                        };
                  };
        } in  Unit# [sat_s3osx];

Text.ParserCombinators.ReadP.readS_to_P1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_s3osy w1_s3osz]
        case
            Text.ParserCombinators.ReadP.$wreadS_to_P w_s3osy w1_s3osz
        of
        { Unit# ww1_s3osB [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_s3osB];
        };

Text.ParserCombinators.ReadP.readS_to_P
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.readS_to_P1 eta_B2 eta_B1;

lvl_r3oqE :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Text/ParserCombinators/ReadP.hs:(134,3)-(157,52)|function <|>"#;

lvl1_r3oqF :: forall a. Text.ParserCombinators.ReadP.P a
[GblId, Str=x] =
    [] \u [] Control.Exception.Base.patError lvl_r3oqE;

Text.ParserCombinators.ReadP.$fAlternativeP_$c<|> [Occ=LoopBreaker]
  :: forall a.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=2, Str=<S,U><L,U>, Unf=OtherCon []] =
    [] \r [ds_s3osC ds1_s3osD]
        let-no-escape {
          fail_s3osE [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
            :: GHC.Prim.Void# -> Text.ParserCombinators.ReadP.P a_a3nLq
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [ds_s3osC ds1_s3osD] \r [ds2_s3osF]
                  case ds1_s3osD of wild_s3osG {
                    __DEFAULT ->
                        case ds_s3osC of wild1_s3osH {
                          __DEFAULT ->
                              case wild_s3osG of wild2_s3osI {
                                __DEFAULT ->
                                    let-no-escape {
                                      fail1_s3osJ [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
                                        :: GHC.Prim.Void# -> Text.ParserCombinators.ReadP.P a_a3nLq
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [wild1_s3osH wild2_s3osI] \r [ds3_s3osK]
                                              case wild2_s3osI of wild3_s3osL {
                                                __DEFAULT ->
                                                    case wild1_s3osH of wild4_s3osM {
                                                      __DEFAULT ->
                                                          case wild3_s3osL of {
                                                            Text.ParserCombinators.ReadP.Get _ [Occ=Dead] ->
                                                                lvl1_r3oqF;
                                                            Text.ParserCombinators.ReadP.Look f_s3osP [Occ=OnceL!] ->
                                                                let {
                                                                  sat_s3osS [Occ=Once]
                                                                    :: GHC.Base.String
                                                                       -> Text.ParserCombinators.ReadP.P
                                                                            a_a3nLq
                                                                  [LclId] =
                                                                      [wild4_s3osM
                                                                       f_s3osP] \r [s_s3osQ]
                                                                          let {
                                                                            sat_s3osR [Occ=Once]
                                                                              :: Text.ParserCombinators.ReadP.P
                                                                                   a_a3nLq
                                                                            [LclId] =
                                                                                [f_s3osP
                                                                                 s_s3osQ] \u []
                                                                                    f_s3osP s_s3osQ;
                                                                          } in 
                                                                            Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                                                                wild4_s3osM
                                                                                sat_s3osR;
                                                                } in 
                                                                  Text.ParserCombinators.ReadP.Look [sat_s3osS];
                                                          };
                                                      Text.ParserCombinators.ReadP.Look f_s3osT [Occ=OnceL*!] ->
                                                          case wild3_s3osL of wild5_s3osU {
                                                            Text.ParserCombinators.ReadP.Get _ [Occ=Dead] ->
                                                                let {
                                                                  sat_s3osY [Occ=Once]
                                                                    :: GHC.Base.String
                                                                       -> Text.ParserCombinators.ReadP.P
                                                                            a_a3nLq
                                                                  [LclId] =
                                                                      [f_s3osT
                                                                       wild5_s3osU] \r [s_s3osW]
                                                                          case
                                                                              f_s3osT s_s3osW
                                                                          of
                                                                          sat_s3osX
                                                                          { __DEFAULT ->
                                                                                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                                                                    sat_s3osX
                                                                                    wild5_s3osU;
                                                                          };
                                                                } in 
                                                                  Text.ParserCombinators.ReadP.Look [sat_s3osY];
                                                            Text.ParserCombinators.ReadP.Look g_s3osZ [Occ=OnceL!] ->
                                                                let {
                                                                  sat_s3ot3 [Occ=Once]
                                                                    :: GHC.Base.String
                                                                       -> Text.ParserCombinators.ReadP.P
                                                                            a_a3nLq
                                                                  [LclId] =
                                                                      [f_s3osT g_s3osZ] \r [s_s3ot0]
                                                                          let {
                                                                            sat_s3ot2 [Occ=Once]
                                                                              :: Text.ParserCombinators.ReadP.P
                                                                                   a_a3nLq
                                                                            [LclId] =
                                                                                [g_s3osZ
                                                                                 s_s3ot0] \u []
                                                                                    g_s3osZ s_s3ot0;
                                                                          } in 
                                                                            case
                                                                                f_s3osT s_s3ot0
                                                                            of
                                                                            sat_s3ot1
                                                                            { __DEFAULT ->
                                                                                  Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                                                                      sat_s3ot1
                                                                                      sat_s3ot2;
                                                                            };
                                                                } in 
                                                                  Text.ParserCombinators.ReadP.Look [sat_s3ot3];
                                                          };
                                                    };
                                                Text.ParserCombinators.ReadP.Final r_s3ot4 [Occ=OnceL] ->
                                                    let {
                                                      sat_s3ot8 [Occ=Once]
                                                        :: GHC.Base.String
                                                           -> Text.ParserCombinators.ReadP.P a_a3nLq
                                                      [LclId] =
                                                          [wild1_s3osH r_s3ot4] \r [s_s3ot5]
                                                              let {
                                                                sat_s3ot7 [Occ=Once]
                                                                  :: [(a_a3nLq, GHC.Base.String)]
                                                                [LclId] =
                                                                    [wild1_s3osH
                                                                     r_s3ot4
                                                                     s_s3ot5] \u []
                                                                        case
                                                                            Text.ParserCombinators.ReadP.run
                                                                                wild1_s3osH s_s3ot5
                                                                        of
                                                                        sat_s3ot6
                                                                        { __DEFAULT ->
                                                                              GHC.Base.++
                                                                                  sat_s3ot6 r_s3ot4;
                                                                        };
                                                              } in 
                                                                Text.ParserCombinators.ReadP.Final [sat_s3ot7];
                                                    } in 
                                                      Text.ParserCombinators.ReadP.Look [sat_s3ot8];
                                              };
                                    } in 
                                      case wild1_s3osH of {
                                        __DEFAULT -> fail1_s3osJ GHC.Prim.void#;
                                        Text.ParserCombinators.ReadP.Look f_s3ota [Occ=OnceL!] ->
                                            case wild2_s3osI of {
                                              __DEFAULT -> fail1_s3osJ GHC.Prim.void#;
                                              Text.ParserCombinators.ReadP.Final r_s3otc [Occ=OnceL] ->
                                                  let {
                                                    sat_s3oth [Occ=Once]
                                                      :: GHC.Base.String
                                                         -> Text.ParserCombinators.ReadP.P a_a3nLq
                                                    [LclId] =
                                                        [f_s3ota r_s3otc] \r [s_s3otd]
                                                            let {
                                                              sat_s3otg [Occ=Once]
                                                                :: [(a_a3nLq, GHC.Base.String)]
                                                              [LclId] =
                                                                  [f_s3ota r_s3otc s_s3otd] \u []
                                                                      case
                                                                          f_s3ota s_s3otd
                                                                      of
                                                                      sat_s3ote
                                                                      { __DEFAULT ->
                                                                            case
                                                                                Text.ParserCombinators.ReadP.run
                                                                                    sat_s3ote
                                                                                    s_s3otd
                                                                            of
                                                                            sat_s3otf
                                                                            { __DEFAULT ->
                                                                                  GHC.Base.++
                                                                                      sat_s3otf
                                                                                      r_s3otc;
                                                                            };
                                                                      };
                                                            } in 
                                                              Text.ParserCombinators.ReadP.Final [sat_s3otg];
                                                  } in 
                                                    Text.ParserCombinators.ReadP.Look [sat_s3oth];
                                            };
                                        Text.ParserCombinators.ReadP.Final r_s3oti [Occ=OnceL*] ->
                                            case wild2_s3osI of wild4_s3otj {
                                              Text.ParserCombinators.ReadP.Get _ [Occ=Dead] ->
                                                  let {
                                                    sat_s3oto [Occ=Once]
                                                      :: GHC.Base.String
                                                         -> Text.ParserCombinators.ReadP.P a_a3nLq
                                                    [LclId] =
                                                        [r_s3oti wild4_s3otj] \r [s_s3otl]
                                                            let {
                                                              sat_s3otn [Occ=Once]
                                                                :: [(a_a3nLq, GHC.Base.String)]
                                                              [LclId] =
                                                                  [r_s3oti
                                                                   wild4_s3otj
                                                                   s_s3otl] \u []
                                                                      let {
                                                                        sat_s3otm [Occ=Once,
                                                                                   Dmd=<L,1*U>]
                                                                          :: [(a_a3nLq,
                                                                               GHC.Base.String)]
                                                                        [LclId] =
                                                                            [wild4_s3otj
                                                                             s_s3otl] \s []
                                                                                Text.ParserCombinators.ReadP.run
                                                                                    wild4_s3otj
                                                                                    s_s3otl;
                                                                      } in 
                                                                        GHC.Base.++
                                                                            r_s3oti sat_s3otm;
                                                            } in 
                                                              Text.ParserCombinators.ReadP.Final [sat_s3otn];
                                                  } in 
                                                    Text.ParserCombinators.ReadP.Look [sat_s3oto];
                                              Text.ParserCombinators.ReadP.Look f_s3otp [Occ=OnceL!] ->
                                                  let {
                                                    sat_s3otu [Occ=Once]
                                                      :: GHC.Base.String
                                                         -> Text.ParserCombinators.ReadP.P a_a3nLq
                                                    [LclId] =
                                                        [r_s3oti f_s3otp] \r [s_s3otq]
                                                            let {
                                                              sat_s3ott [Occ=Once]
                                                                :: [(a_a3nLq, GHC.Base.String)]
                                                              [LclId] =
                                                                  [r_s3oti f_s3otp s_s3otq] \u []
                                                                      let {
                                                                        sat_s3ots [Occ=Once,
                                                                                   Dmd=<L,1*U>]
                                                                          :: [(a_a3nLq,
                                                                               GHC.Base.String)]
                                                                        [LclId] =
                                                                            [f_s3otp s_s3otq] \s []
                                                                                case
                                                                                    f_s3otp s_s3otq
                                                                                of
                                                                                sat_s3otr
                                                                                { __DEFAULT ->
                                                                                      Text.ParserCombinators.ReadP.run
                                                                                          sat_s3otr
                                                                                          s_s3otq;
                                                                                };
                                                                      } in 
                                                                        GHC.Base.++
                                                                            r_s3oti sat_s3ots;
                                                            } in 
                                                              Text.ParserCombinators.ReadP.Final [sat_s3ott];
                                                  } in 
                                                    Text.ParserCombinators.ReadP.Look [sat_s3otu];
                                              Text.ParserCombinators.ReadP.Final t_s3otv [Occ=Once] ->
                                                  let {
                                                    sat_s3otw [Occ=Once]
                                                      :: [(a_a3nLq, GHC.Base.String)]
                                                    [LclId] =
                                                        [r_s3oti t_s3otv] \u []
                                                            GHC.Base.++ r_s3oti t_s3otv;
                                                  } in 
                                                    Text.ParserCombinators.ReadP.Final [sat_s3otw];
                                            };
                                      };
                                Text.ParserCombinators.ReadP.Fail -> wild1_s3osH;
                              };
                          Text.ParserCombinators.ReadP.Fail -> wild_s3osG;
                        };
                    Text.ParserCombinators.ReadP.Result x_s3otx [Occ=Once]
                                                        q_s3oty [Occ=Once] ->
                        let {
                          sat_s3otz [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nLq
                          [LclId] =
                              [ds_s3osC q_s3oty] \u []
                                  Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                      ds_s3osC q_s3oty;
                        } in  Text.ParserCombinators.ReadP.Result [x_s3otx sat_s3otz];
                  };
        } in 
          case ds_s3osC of {
            __DEFAULT -> fail_s3osE GHC.Prim.void#;
            Text.ParserCombinators.ReadP.Get f1_s3otB [Occ=OnceL!] ->
                case ds1_s3osD of {
                  __DEFAULT -> fail_s3osE GHC.Prim.void#;
                  Text.ParserCombinators.ReadP.Get f2_s3otD [Occ=OnceL!] ->
                      let {
                        sat_s3otH [Occ=Once]
                          :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P a_a3nLq
                        [LclId] =
                            [f1_s3otB f2_s3otD] \r [c_s3otE]
                                let {
                                  sat_s3otG [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nLq
                                  [LclId] =
                                      [f2_s3otD c_s3otE] \u [] f2_s3otD c_s3otE;
                                } in 
                                  case f1_s3otB c_s3otE of sat_s3otF {
                                    __DEFAULT ->
                                        Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                            sat_s3otF sat_s3otG;
                                  };
                      } in  Text.ParserCombinators.ReadP.Get [sat_s3otH];
                };
            Text.ParserCombinators.ReadP.Result x_s3otI [Occ=Once]
                                                p_s3otJ [Occ=Once] ->
                let {
                  sat_s3otK [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nLq
                  [LclId] =
                      [ds1_s3osD p_s3otJ] \u []
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                              p_s3otJ ds1_s3osD;
                } in  Text.ParserCombinators.ReadP.Result [x_s3otI sat_s3otK];
          };

Text.ParserCombinators.ReadP.$fAlternativeP_$c>>= [Occ=LoopBreaker]
  :: forall a b.
     Text.ParserCombinators.ReadP.P a
     -> (a -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,1*U><L,C(U)>, Unf=OtherCon []] =
    [] \r [ds_s3otL k_s3otM]
        case ds_s3otL of {
          Text.ParserCombinators.ReadP.Get f_s3otO [Occ=OnceL!] ->
              let {
                sat_s3otR [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_a3nML
                [LclId] =
                    [k_s3otM f_s3otO] \r [c_s3otP]
                        case f_s3otO c_s3otP of sat_s3otQ {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                  sat_s3otQ k_s3otM;
                        };
              } in  Text.ParserCombinators.ReadP.Get [sat_s3otR];
          Text.ParserCombinators.ReadP.Look f_s3otS [Occ=OnceL!] ->
              let {
                sat_s3otV [Occ=Once]
                  :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3nML
                [LclId] =
                    [k_s3otM f_s3otS] \r [s_s3otT]
                        case f_s3otS s_s3otT of sat_s3otU {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                  sat_s3otU k_s3otM;
                        };
              } in  Text.ParserCombinators.ReadP.Look [sat_s3otV];
          Text.ParserCombinators.ReadP.Fail ->
              Text.ParserCombinators.ReadP.Fail [];
          Text.ParserCombinators.ReadP.Result x_s3otW [Occ=Once]
                                              p_s3otX [Occ=Once] ->
              let {
                sat_s3otZ [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nML
                [LclId] =
                    [k_s3otM p_s3otX] \u []
                        Text.ParserCombinators.ReadP.$fAlternativeP_$c>>= p_s3otX k_s3otM;
              } in 
                case k_s3otM x_s3otW of sat_s3otY {
                  __DEFAULT ->
                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                          sat_s3otY sat_s3otZ;
                };
          Text.ParserCombinators.ReadP.Final r_s3ou0 [Occ=Once] ->
              let {
                go_s3ou1 [Occ=LoopBreaker]
                  :: [(a_a3nMK, GHC.Base.String)] -> [(b_a3nML, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [k_s3otM go_s3ou1] \r [ds1_s3ou2]
                        case ds1_s3ou2 of {
                          [] -> [] [];
                          : y_s3ou4 [Occ=Once!] ys_s3ou5 [Occ=Once] ->
                              case y_s3ou4 of {
                                (,) x_s3ou7 [Occ=Once] s_s3ou8 [Occ=Once] ->
                                    let {
                                      sat_s3oub [Occ=Once, Dmd=<L,1*U>]
                                        :: [(b_a3nML, GHC.Base.String)]
                                      [LclId] =
                                          [go_s3ou1 ys_s3ou5] \s [] go_s3ou1 ys_s3ou5;
                                    } in 
                                      case k_s3otM x_s3ou7 of sat_s3ou9 {
                                        __DEFAULT ->
                                            case
                                                Text.ParserCombinators.ReadP.run sat_s3ou9 s_s3ou8
                                            of
                                            sat_s3oua
                                            { __DEFAULT -> GHC.Base.++ sat_s3oua sat_s3oub;
                                            };
                                      };
                              };
                        };
              } in 
                case go_s3ou1 r_s3ou0 of wild1_s3ouc {
                  [] -> Text.ParserCombinators.ReadP.Fail [];
                  : _ [Occ=Dead] _ [Occ=Dead] ->
                      Text.ParserCombinators.ReadP.Final [wild1_s3ouc];
                };
        };

Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
  :: forall a b.
     Text.ParserCombinators.ReadP.P (a -> b)
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [m1_s3ouf m2_s3oug]
        let {
          sat_s3oul [Occ=Once]
            :: (a_a3nOe -> b_a3nOf) -> Text.ParserCombinators.ReadP.P b_a3nOf
          [LclId] =
              [m2_s3oug] \r [x1_s3ouh]
                  let {
                    sat_s3ouk [Occ=Once]
                      :: a_a3nOe -> Text.ParserCombinators.ReadP.P b_a3nOf
                    [LclId] =
                        [x1_s3ouh] \r [x2_s3oui]
                            let {
                              sat_s3ouj [Occ=Once] :: b_a3nOf
                              [LclId] =
                                  [x1_s3ouh x2_s3oui] \u [] x1_s3ouh x2_s3oui;
                            } in 
                              Text.ParserCombinators.ReadP.Result [sat_s3ouj
                                                                   Text.ParserCombinators.ReadP.Fail];
                  } in 
                    Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                        m2_s3oug sat_s3ouk;
        } in 
          Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
              m1_s3ouf sat_s3oul;

Text.ParserCombinators.ReadP.$fApplicativeP_$cliftA2
  :: forall a b c.
     (a -> b -> c)
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P c
[GblId, Arity=2, Str=<L,C(U)><L,1*U>, Unf=OtherCon []] =
    [] \r [f1_s3oum x_s3oun]
        let {
          sat_s3ouo [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (b_a3nOq -> c_a3nOr)
          [LclId] =
              [f1_s3oum x_s3oun] \u []
                  Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                      f1_s3oum x_s3oun;
        } in  Text.ParserCombinators.ReadP.$fAlternativeP_$c<*> sat_s3ouo;

Text.ParserCombinators.ReadP.$fAlternativeP1
  :: forall a. Text.ParserCombinators.ReadP.P [a]
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.ParserCombinators.ReadP.Result! [GHC.Types.[]
                                                        Text.ParserCombinators.ReadP.Fail];

Text.ParserCombinators.ReadP.$fAlternativeP_$csome
  :: forall a.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P [a]
[GblId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_s3oup]
        let {
          some_v_s3ouq [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadP.P [a_a3nMc]
          [LclId] =
              [v_s3oup some_v_s3ouq] \u []
                  let {
                    m2_s3our [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_a3nMc]
                    [LclId] =
                        [some_v_s3ouq] \u []
                            Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                some_v_s3ouq Text.ParserCombinators.ReadP.$fAlternativeP1; } in
                  let {
                    sat_s3oux [Occ=Once]
                      :: ([a_a3nMc] -> [a_a3nMc])
                         -> Text.ParserCombinators.ReadP.P [a_a3nMc]
                    [LclId] =
                        [m2_s3our] \r [x1_s3out]
                            let {
                              sat_s3ouw [Occ=Once]
                                :: [a_a3nMc] -> Text.ParserCombinators.ReadP.P [a_a3nMc]
                              [LclId] =
                                  [x1_s3out] \r [x2_s3ouu]
                                      let {
                                        sat_s3ouv [Occ=Once] :: [a_a3nMc]
                                        [LclId] =
                                            [x1_s3out x2_s3ouu] \u [] x1_s3out x2_s3ouu;
                                      } in 
                                        Text.ParserCombinators.ReadP.Result [sat_s3ouv
                                                                             Text.ParserCombinators.ReadP.Fail];
                            } in 
                              Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                  m2_s3our sat_s3ouw;
                  } in 
                    case
                        Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                            GHC.Types.: v_s3oup
                    of
                    sat_s3ous
                    { __DEFAULT ->
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                              sat_s3ous sat_s3oux;
                    };
        } in  some_v_s3ouq;

Text.ParserCombinators.ReadP.$fApplicativeP_$c<*
  :: forall a b.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=1, Str=<L,1*U>, Unf=OtherCon []] =
    [] \r [x_s3ouy]
        let {
          sat_s3ouz [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (b_a3nOM -> a_a3nOL)
          [LclId] =
              [x_s3ouy] \u []
                  Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                      GHC.Base.const x_s3ouy;
        } in  Text.ParserCombinators.ReadP.$fAlternativeP_$c<*> sat_s3ouz;

Text.ParserCombinators.ReadP.$fApplicativeP_$c*>
  :: forall a b.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [a1_s3ouA a2_s3ouB]
        case
            Text.ParserCombinators.ReadP.$fApplicativeP_$c<$
                GHC.Base.breakpoint a1_s3ouA
        of
        sat_s3ouC
        { __DEFAULT ->
              Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
                  sat_s3ouC a2_s3ouB;
        };

Text.ParserCombinators.ReadP.$fAlternativeP_$cmany
  :: forall a.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P [a]
[GblId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_s3ouD]
        let {
          many_v_s3ouE [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadP.P [a_a3nMk]
          [LclId] =
              [v_s3ouD many_v_s3ouE] \u []
                  case
                      Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                          GHC.Types.: v_s3ouD
                  of
                  sat_s3ouF
                  { __DEFAULT ->
                        case
                            Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
                                sat_s3ouF many_v_s3ouE
                        of
                        sat_s3ouG
                        { __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                  sat_s3ouG Text.ParserCombinators.ReadP.$fAlternativeP1;
                        };
                  };
        } in  many_v_s3ouE;

Text.ParserCombinators.ReadP.$fMonadP_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [eta_s3ouH eta1_s3ouI]
        let {
          sat_s3ouK [Occ=Once]
            :: a_a3nNd -> Text.ParserCombinators.ReadP.P b_a3nNe
          [LclId] =
              [eta1_s3ouI] \r [ds_s3ouJ] eta1_s3ouI;
        } in 
          Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
              eta_s3ouH sat_s3ouK;

Text.ParserCombinators.ReadP.$fApplicativeP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Text.ParserCombinators.ReadP.$fFunctorP
                                           Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                                           Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
                                           Text.ParserCombinators.ReadP.$fApplicativeP_$cliftA2
                                           Text.ParserCombinators.ReadP.$fApplicativeP_$c*>
                                           Text.ParserCombinators.ReadP.$fApplicativeP_$c<*];

Text.ParserCombinators.ReadP.$fMonadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Text.ParserCombinators.ReadP.$fApplicativeP
                                     Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                     Text.ParserCombinators.ReadP.$fMonadP_$c>>
                                     Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                                     Text.ParserCombinators.ReadP.$fMonadFailP_$cfail];

Text.ParserCombinators.ReadP.$fAlternativeP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Text.ParserCombinators.ReadP.$fApplicativeP
                                           Text.ParserCombinators.ReadP.Fail
                                           Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                           Text.ParserCombinators.ReadP.$fAlternativeP_$csome
                                           Text.ParserCombinators.ReadP.$fAlternativeP_$cmany];

Text.ParserCombinators.ReadP.readP_to_S
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadS a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [ds_s3ouL]
        let {
          sat_s3ouM [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nDT
          [LclId] =
              [ds_s3ouL] \u []
                  ds_s3ouL Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s3ouM;

Text.ParserCombinators.ReadP.$fMonadFailP [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fail.C:MonadFail! [Text.ParserCombinators.ReadP.$fMonadP
                                                   Text.ParserCombinators.ReadP.$fMonadFailP_$cfail];

Text.ParserCombinators.ReadP.$fMonadPlusP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [Text.ParserCombinators.ReadP.$fAlternativeP
                                         Text.ParserCombinators.ReadP.$fMonadP
                                         Text.ParserCombinators.ReadP.Fail
                                         Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>];

Text.ParserCombinators.ReadP.get
  :: Text.ParserCombinators.ReadP.ReadP GHC.Types.Char
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m1, Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Get [eta_B1];

Text.ParserCombinators.ReadP.look
  :: Text.ParserCombinators.ReadP.ReadP GHC.Base.String
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Look [eta_B1];

Text.ParserCombinators.ReadP.$fAlternativeReadP4
  :: forall a b.
     (a -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s3ouN] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadP.pfail
  :: forall a. Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.$fAlternativeReadP4 eta_B1;

Text.ParserCombinators.ReadP.$fAlternativeReadP3
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3ouO ds1_s3ouP k_s3ouQ]
        let {
          sat_s3ouS [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
          [LclId] =
              [ds1_s3ouP k_s3ouQ] \u [] ds1_s3ouP k_s3ouQ;
        } in 
          case ds_s3ouO k_s3ouQ of sat_s3ouR {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3ouR sat_s3ouS;
          };

Text.ParserCombinators.ReadP.+++
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.$fAlternativeReadP3
            eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.choice [Occ=LoopBreaker]
  :: forall a.
     [Text.ParserCombinators.ReadP.ReadP a]
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s3ouT]
        case ds_s3ouT of {
          [] -> Text.ParserCombinators.ReadP.$fAlternativeReadP4;
          : p_s3ouV [Occ=OnceL*] ds1_s3ouW [Occ=Once!] ->
              case ds1_s3ouW of wild1_s3ouX {
                [] -> p_s3ouV;
                : _ [Occ=Dead] _ [Occ=Dead] ->
                    let {
                      ds2_s3ov0 [Occ=OnceL, Dmd=<L,C(U)>]
                        :: Text.ParserCombinators.ReadP.ReadP a_a3nzc
                      [LclId] =
                          [wild1_s3ouX] \u []
                              Text.ParserCombinators.ReadP.choice wild1_s3ouX; } in
                    let {
                      sat_s3ov4 [Occ=Once]
                        :: forall b.
                           (a_a3nzc -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b
                      [LclId] =
                          [p_s3ouV ds2_s3ov0] \r [k_s3ov1]
                              let {
                                sat_s3ov3 [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
                                [LclId] =
                                    [ds2_s3ov0 k_s3ov1] \u [] ds2_s3ov0 k_s3ov1;
                              } in 
                                case p_s3ouV k_s3ov1 of sat_s3ov2 {
                                  __DEFAULT ->
                                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                          sat_s3ov2 sat_s3ov3;
                                };
                    } in  sat_s3ov4;
              };
        };

lvl2_r3oqG :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "do not use readS_to_P in gather!"#;

lvl3_r3oqH :: forall b. Text.ParserCombinators.ReadP.P b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_r3oqG of sat_s3ov5 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s3ov5;
        };

Text.ParserCombinators.ReadP.gather_gath [Occ=LoopBreaker]
  :: forall b.
     (GHC.Base.String -> GHC.Base.String)
     -> Text.ParserCombinators.ReadP.P
          (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,C(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [l_s3ov6 ds_s3ov7]
        case ds_s3ov7 of {
          Text.ParserCombinators.ReadP.Get f_s3ov9 [Occ=OnceL!] ->
              let {
                sat_s3ovf [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_a3nv3
                [LclId] =
                    [l_s3ov6 f_s3ov9] \r [c_s3ova]
                        case f_s3ov9 c_s3ova of sat_s3ove {
                          __DEFAULT ->
                              let {
                                sat_s3ovd [Occ=Once] :: GHC.Base.String -> GHC.Base.String
                                [LclId] =
                                    [l_s3ov6 c_s3ova] \r [x_s3ovb]
                                        let {
                                          sat_s3ovc [Occ=Once] :: GHC.Base.String
                                          [LclId] =
                                              CCCS :! [c_s3ova x_s3ovb];
                                        } in  l_s3ov6 sat_s3ovc;
                              } in  Text.ParserCombinators.ReadP.gather_gath sat_s3ovd sat_s3ove;
                        };
              } in  Text.ParserCombinators.ReadP.Get [sat_s3ovf];
          Text.ParserCombinators.ReadP.Look f_s3ovg [Occ=OnceL!] ->
              let {
                sat_s3ovj [Occ=Once]
                  :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3nv3
                [LclId] =
                    [l_s3ov6 f_s3ovg] \r [s_s3ovh]
                        case f_s3ovg s_s3ovh of sat_s3ovi {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.gather_gath l_s3ov6 sat_s3ovi;
                        };
              } in  Text.ParserCombinators.ReadP.Look [sat_s3ovj];
          Text.ParserCombinators.ReadP.Fail ->
              Text.ParserCombinators.ReadP.Fail [];
          Text.ParserCombinators.ReadP.Result k_s3ovk [Occ=Once!]
                                              p_s3ovl [Occ=Once] ->
              let {
                sat_s3ovo [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nv3
                [LclId] =
                    [l_s3ov6 p_s3ovl] \u []
                        Text.ParserCombinators.ReadP.gather_gath l_s3ov6 p_s3ovl; } in
              let {
                sat_s3ovm [Occ=Once] :: GHC.Base.String
                [LclId] =
                    [l_s3ov6] \u [] l_s3ov6 GHC.Types.[];
              } in 
                case k_s3ovk sat_s3ovm of sat_s3ovn {
                  __DEFAULT ->
                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                          sat_s3ovn sat_s3ovo;
                };
          Text.ParserCombinators.ReadP.Final _ [Occ=Dead] -> lvl3_r3oqH;
        };

Text.ParserCombinators.ReadP.gather1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ((GHC.Base.String, a) -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),1*C1(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [ds_s3ovq eta_s3ovr]
        let {
          sat_s3ovw [Occ=Once]
            :: a_a3nuK
               -> Text.ParserCombinators.ReadP.P
                    (GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3ngn)
          [LclId] =
              [eta_s3ovr] \r [a1_s3ovs]
                  let {
                    sat_s3ovv [Occ=Once]
                      :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [eta_s3ovr a1_s3ovs] \r [s_s3ovt]
                            let {
                              sat_s3ovu [Occ=Once] :: (GHC.Base.String, a_a3nuK)
                              [LclId] =
                                  CCCS (,)! [s_s3ovt a1_s3ovs];
                            } in  eta_s3ovr sat_s3ovu;
                  } in 
                    Text.ParserCombinators.ReadP.Result [sat_s3ovv
                                                         Text.ParserCombinators.ReadP.Fail];
        } in 
          case ds_s3ovq sat_s3ovw of sat_s3ovx {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.gather_gath GHC.Base.id sat_s3ovx;
          };

Text.ParserCombinators.ReadP.gather
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (GHC.Base.String, a)
[GblId, Arity=2, Str=<C(S),1*C1(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.gather1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Text.ParserCombinators.ReadP.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$trModule4];

Text.ParserCombinators.ReadP.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Text.ParserCombinators.ReadP"#;

Text.ParserCombinators.ReadP.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$trModule2];

Text.ParserCombinators.ReadP.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Text.ParserCombinators.ReadP.$trModule3
                                     Text.ParserCombinators.ReadP.$trModule1];

$krep_r3oqI :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcChar
                                              GHC.Types.[]];

$krep1_r3oqJ :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r3oqI GHC.Types.[]];

$krep2_r3oqK :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc[]
                                              $krep1_r3oqJ];

$krep3_r3oqL :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep4_r3oqM :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_r3oqK GHC.Types.[]];

$krep5_r3oqN :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r3oqL $krep4_r3oqM];

$krep6_r3oqO :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Tuple.$tc(,)
                                              $krep5_r3oqN];

$krep7_r3oqP :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep6_r3oqO GHC.Types.[]];

$krep8_r3oqQ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc[]
                                              $krep7_r3oqP];

Text.ParserCombinators.ReadP.$tcP2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "P"#;

Text.ParserCombinators.ReadP.$tcP1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tcP2];

Text.ParserCombinators.ReadP.$tcP :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4287589432649596960##
                                    9029773818181158220##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tcP1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep9_r3oqR :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r3oqL GHC.Types.[]];

Text.ParserCombinators.ReadP.$tc'Fail1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Text.ParserCombinators.ReadP.$tcP
                                              $krep9_r3oqR];

Text.ParserCombinators.ReadP.$tc'Fail3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Fail"#;

Text.ParserCombinators.ReadP.$tc'Fail2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Fail3];

Text.ParserCombinators.ReadP.$tc'Fail :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16564457091671581868##
                                    4540703186775139959##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Fail2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Fail1];

$krep10_r3oqS :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [Text.ParserCombinators.ReadP.$tc'Fail1
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Result1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r3oqL $krep10_r3oqS];

Text.ParserCombinators.ReadP.$tc'Result3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Result"#;

Text.ParserCombinators.ReadP.$tc'Result2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Result3];

Text.ParserCombinators.ReadP.$tc'Result :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14629176799732153257##
                                    2029199220309899277##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Result2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Result1];

Text.ParserCombinators.ReadP.$tc'Final1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r3oqQ
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Final3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Final"#;

Text.ParserCombinators.ReadP.$tc'Final2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Final3];

Text.ParserCombinators.ReadP.$tc'Final :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9825883373667767852##
                                    1277540149077833820##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Final2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Final1];

$krep11_r3oqT :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r3oqK
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Look1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r3oqT
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Look3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Look"#;

Text.ParserCombinators.ReadP.$tc'Look2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Look3];

Text.ParserCombinators.ReadP.$tc'Look :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11302519862508684236##
                                    969530656846011597##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Look2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Look1];

$krep12_r3oqU :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r3oqI
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Get1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep12_r3oqU
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Get3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Get"#;

Text.ParserCombinators.ReadP.$tc'Get2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Get3];

Text.ParserCombinators.ReadP.$tc'Get :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10806119809527641225##
                                    14618661019746688366##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Get2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Get1];

Text.ParserCombinators.ReadP.$tcReadP2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ReadP"#;

Text.ParserCombinators.ReadP.$tcReadP1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tcReadP2];

Text.ParserCombinators.ReadP.$tcReadP :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15640243629783811470##
                                    8988027559298507146##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tcReadP1
                                    0#
                                    GHC.Types.krep$*Arr*];

Text.ParserCombinators.ReadP.$fApplicativeReadP4
  :: forall b a.
     Text.ParserCombinators.ReadP.ReadP (a -> b)
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [m1_s3ovy m2_s3ovz k_s3ovA]
        let {
          sat_s3ovF [Occ=Once]
            :: (a_a3nK0 -> b_a3nK1) -> Text.ParserCombinators.ReadP.P b1_a3nIU
          [LclId] =
              [m2_s3ovz k_s3ovA] \r [a1_s3ovB]
                  let {
                    sat_s3ovE [Occ=Once]
                      :: a_a3nK0 -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [k_s3ovA a1_s3ovB] \r [a2_s3ovC]
                            let {
                              sat_s3ovD [Occ=Once] :: b_a3nK1
                              [LclId] =
                                  [a1_s3ovB a2_s3ovC] \u [] a1_s3ovB a2_s3ovC;
                            } in  k_s3ovA sat_s3ovD;
                  } in  m2_s3ovz sat_s3ovE;
        } in  m1_s3ovy sat_s3ovF;

Text.ParserCombinators.ReadP.$fApplicativeReadP2
  :: forall a b.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [a1_s3ovG a2_s3ovH eta_s3ovI]
        let {
          lvl4_s3ovJ [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [a2_s3ovH eta_s3ovI] \u []
                  let {
                    sat_s3ovL [Occ=Once]
                      :: b_a3nKt -> Text.ParserCombinators.ReadP.P b1_a3ngn
                    [LclId] =
                        [eta_s3ovI] \r [a4_s3ovK] eta_s3ovI a4_s3ovK;
                  } in  a2_s3ovH sat_s3ovL; } in
        let {
          sat_s3ovN [Occ=Once]
            :: a_a3nKs -> Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [lvl4_s3ovJ] \r [x_s3ovM] lvl4_s3ovJ;
        } in  a1_s3ovG sat_s3ovN;

Text.ParserCombinators.ReadP.$fApplicativeReadP3
  :: forall a b c.
     (a -> b -> c)
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (c -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C(U))><C(S),1*C1(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [f1_s3ovO x_s3ovP eta_s3ovQ eta1_s3ovR]
        let {
          sat_s3ovX [Occ=Once]
            :: a_a3nKg -> Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [f1_s3ovO eta_s3ovQ eta1_s3ovR] \r [x1_s3ovS]
                  let {
                    a1_s3ovT [Occ=OnceL!, Dmd=<L,C(U)>] :: b_a3nKh -> c_a3nKi
                    [LclId] =
                        [f1_s3ovO x1_s3ovS] \u [] f1_s3ovO x1_s3ovS; } in
                  let {
                    sat_s3ovW [Occ=Once]
                      :: b_a3nKh -> Text.ParserCombinators.ReadP.P b1_a3ngn
                    [LclId] =
                        [eta1_s3ovR a1_s3ovT] \r [a2_s3ovU]
                            let {
                              sat_s3ovV [Occ=Once] :: c_a3nKi
                              [LclId] =
                                  [a1_s3ovT a2_s3ovU] \u [] a1_s3ovT a2_s3ovU;
                            } in  eta1_s3ovR sat_s3ovV;
                  } in  eta_s3ovQ sat_s3ovW;
        } in  x_s3ovP sat_s3ovX;

Text.ParserCombinators.ReadP.$fApplicativeReadP1
  :: forall b a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (a -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [x_s3ovY eta_s3ovZ eta1_s3ow0]
        let {
          sat_s3ow5 [Occ=Once]
            :: a_a3nKC -> Text.ParserCombinators.ReadP.P b1_X3nkp
          [LclId] =
              [eta_s3ovZ eta1_s3ow0] \r [x1_s3ow1]
                  let {
                    lvl4_s3ow2 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_X3nkp
                    [LclId] =
                        [eta1_s3ow0 x1_s3ow1] \u [] eta1_s3ow0 x1_s3ow1; } in
                  let {
                    sat_s3ow4 [Occ=Once]
                      :: b_a3nKD -> Text.ParserCombinators.ReadP.P b1_X3nkp
                    [LclId] =
                        [lvl4_s3ow2] \r [a1_s3ow3] lvl4_s3ow2;
                  } in  eta_s3ovZ sat_s3ow4;
        } in  x_s3ovY sat_s3ow5;

$c>>_r3oqV
  :: forall a b.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [eta_s3ow6 eta1_s3ow7 k_s3ow8]
        let {
          lvl4_s3ow9 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
          [LclId] =
              [eta1_s3ow7 k_s3ow8] \u [] eta1_s3ow7 k_s3ow8; } in
        let {
          sat_s3owb [Occ=Once]
            :: a_a3nJi -> Text.ParserCombinators.ReadP.P b1_a3nIU
          [LclId] =
              [lvl4_s3ow9] \r [a1_s3owa] lvl4_s3ow9;
        } in  eta_s3ow6 sat_s3owb;

Text.ParserCombinators.ReadP.$fMonadReadP_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] $c>>_r3oqV eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$fApplicativeReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Text.ParserCombinators.ReadP.$fFunctorReadP
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP5
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP4
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP3
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP2
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP1];

Text.ParserCombinators.ReadP.$fMonadReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Text.ParserCombinators.ReadP.$fApplicativeReadP
                                     Text.ParserCombinators.ReadP.$fMonadReadP1
                                     Text.ParserCombinators.ReadP.$fMonadReadP_$c>>
                                     Text.ParserCombinators.ReadP.$fApplicativeReadP5
                                     Text.ParserCombinators.ReadP.$fMonadFailReadP1];

Text.ParserCombinators.ReadP.between1
  :: forall open close a.
     Text.ParserCombinators.ReadP.ReadP open
     -> Text.ParserCombinators.ReadP.ReadP close
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,1*C1(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [open1_s3owc close1_s3owd p_s3owe k_s3owf]
        let {
          lvl4_s3owg [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3nIU
          [LclId] =
              [close1_s3owd p_s3owe k_s3owf] \u []
                  let {
                    sat_s3owl [Occ=Once]
                      :: a_a3nui -> Text.ParserCombinators.ReadP.P b_a3nIU
                    [LclId] =
                        [close1_s3owd k_s3owf] \r [a1_s3owh]
                            let {
                              lvl5_s3owi [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3nIU
                              [LclId] =
                                  [k_s3owf a1_s3owh] \u [] k_s3owf a1_s3owh; } in
                            let {
                              sat_s3owk [Occ=Once]
                                :: close_a3nuh -> Text.ParserCombinators.ReadP.P b_a3nIU
                              [LclId] =
                                  [lvl5_s3owi] \r [a2_s3owj] lvl5_s3owi;
                            } in  close1_s3owd sat_s3owk;
                  } in  p_s3owe sat_s3owl; } in
        let {
          sat_s3own [Occ=Once]
            :: open_a3nug -> Text.ParserCombinators.ReadP.P b_a3nIU
          [LclId] =
              [lvl4_s3owg] \r [a1_s3owm] lvl4_s3owg;
        } in  open1_s3owc sat_s3own;

Text.ParserCombinators.ReadP.between
  :: forall open close a.
     Text.ParserCombinators.ReadP.ReadP open
     -> Text.ParserCombinators.ReadP.ReadP close
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,1*C1(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.between1 eta_B4 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$wcount [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Prim.Int#
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,U><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [ww_s3owo w_s3owp w1_s3owq]
        case <# [0# ww_s3owo] of {
          __DEFAULT -> w1_s3owq GHC.Types.[];
          1# ->
              let {
                $wxs_s3ows [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                  :: GHC.Prim.Int#
                     -> forall b1.
                        ([a_s3ogB] -> Text.ParserCombinators.ReadP.P b1)
                        -> Text.ParserCombinators.ReadP.P b1
                [LclId, Arity=2, Str=<S,1*U><L,C(U)>, Unf=OtherCon []] =
                    sat-only [w_s3owp $wxs_s3ows] \r [ww1_s3owt w2_s3owu]
                        case ww1_s3owt of ds1_s3owv {
                          __DEFAULT ->
                              case -# [ds1_s3owv 1#] of r_s3oww {
                                __DEFAULT ->
                                    let {
                                      sat_s3owB [Occ=Once]
                                        :: a_s3ogB -> Text.ParserCombinators.ReadP.P b1_s3ogu
                                      [LclId] =
                                          [$wxs_s3ows w2_s3owu r_s3oww] \r [a1_s3owx]
                                              let {
                                                sat_s3owA [Occ=Once]
                                                  :: [a_s3ogB]
                                                     -> Text.ParserCombinators.ReadP.P b1_s3ogu
                                                [LclId] =
                                                    [w2_s3owu a1_s3owx] \r [a2_s3owy]
                                                        let {
                                                          sat_s3owz [Occ=Once] :: [a_s3ogB]
                                                          [LclId] =
                                                              CCCS :! [a1_s3owx a2_s3owy];
                                                        } in  w2_s3owu sat_s3owz;
                                              } in  $wxs_s3ows r_s3oww sat_s3owA;
                                    } in  w_s3owp sat_s3owB;
                              };
                          1# ->
                              let {
                                sat_s3owE [Occ=Once]
                                  :: a_s3ogB -> Text.ParserCombinators.ReadP.P b1_s3ogu
                                [LclId] =
                                    [w2_s3owu] \r [a1_s3owC]
                                        let {
                                          sat_s3owD [Occ=Once] :: [a_s3ogB]
                                          [LclId] =
                                              CCCS :! [a1_s3owC GHC.Types.[]];
                                        } in  w2_s3owu sat_s3owD;
                              } in  w_s3owp sat_s3owE;
                        };
              } in  $wxs_s3ows ww_s3owo w1_s3owq;
        };

Text.ParserCombinators.ReadP.count1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3owF w1_s3owG w2_s3owH]
        case w_s3owF of {
          GHC.Types.I# ww1_s3owJ [Occ=Once] ->
              Text.ParserCombinators.ReadP.$wcount ww1_s3owJ w1_s3owG w2_s3owH;
        };

Text.ParserCombinators.ReadP.count
  :: forall a.
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.count1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.option1
  :: forall a.
     a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
    [] \r [x_s3owK p_s3owL eta_s3owM]
        let {
          sat_s3owO [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [x_s3owK eta_s3owM] \u [] eta_s3owM x_s3owK;
        } in 
          case p_s3owL eta_s3owM of sat_s3owN {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3owN sat_s3owO;
          };

Text.ParserCombinators.ReadP.option
  :: forall a.
     a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.option1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.optional1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),1*C1(U)><L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [p_s3owP eta_s3owQ]
        let {
          lvl4_s3owR :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [eta_s3owQ] \u [] eta_s3owQ GHC.Tuple.(); } in
        let {
          sat_s3owT [Occ=Once]
            :: a_a3nw0 -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [lvl4_s3owR] \r [a1_s3owS] lvl4_s3owR;
        } in 
          case p_s3owP sat_s3owT of sat_s3owU {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3owU lvl4_s3owR;
          };

Text.ParserCombinators.ReadP.optional
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP ()
[GblId, Arity=2, Str=<C(S),1*C1(U)><L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.optional1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.endBy3 [Occ=LoopBreaker]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,C(U)><C(S),C(U)>, Unf=OtherCon []] =
    [] \r [p_s3owV eta_s3owW]
        let {
          sat_s3ox3 [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [p_s3owV eta_s3owW] \u []
                  let {
                    sat_s3ox2 [Occ=Once]
                      :: a_a3nwo -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [p_s3owV eta_s3owW] \r [a1_s3owY]
                            let {
                              sat_s3ox1 [Occ=Once]
                                :: [a_a3nwo] -> Text.ParserCombinators.ReadP.P b_a3ngn
                              [LclId] =
                                  [eta_s3owW a1_s3owY] \r [a2_s3owZ]
                                      let {
                                        sat_s3ox0 [Occ=Once] :: [a_a3nwo]
                                        [LclId] =
                                            CCCS :! [a1_s3owY a2_s3owZ];
                                      } in  eta_s3owW sat_s3ox0;
                            } in  Text.ParserCombinators.ReadP.endBy3 p_s3owV sat_s3ox1;
                  } in  p_s3owV sat_s3ox2;
        } in 
          case eta_s3owW GHC.Types.[] of sat_s3owX {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3owX sat_s3ox3;
          };

Text.ParserCombinators.ReadP.many
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=2, Str=<L,C(U)><C(S),C(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.endBy3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.many2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),C(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [p_s3ox4 eta_s3ox5]
        let {
          sat_s3oxa [Occ=Once]
            :: a_a3nwe -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [p_s3ox4 eta_s3ox5] \r [a1_s3ox6]
                  let {
                    sat_s3ox9 [Occ=Once]
                      :: [a_a3nwe] -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [eta_s3ox5 a1_s3ox6] \r [a2_s3ox7]
                            let {
                              sat_s3ox8 [Occ=Once] :: [a_a3nwe]
                              [LclId] =
                                  CCCS :! [a1_s3ox6 a2_s3ox7];
                            } in  eta_s3ox5 sat_s3ox8;
                  } in  Text.ParserCombinators.ReadP.endBy3 p_s3ox4 sat_s3ox9;
        } in  p_s3ox4 sat_s3oxa;

Text.ParserCombinators.ReadP.many1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=2, Str=<C(S),C(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.many2 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.endBy4
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3oxb sep1_s3oxc eta_s3oxd]
        let {
          p1_s3oxe [Occ=OnceL, Dmd=<L,C(U)>]
            :: forall b1.
               (a_a3nwx -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              [p_s3oxb sep1_s3oxc] \r [k_s3oxf]
                  let {
                    sat_s3oxk [Occ=Once]
                      :: a_a3nwx -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [sep1_s3oxc k_s3oxf] \r [a1_s3oxg]
                            let {
                              lvl4_s3oxh [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3oxf a1_s3oxg] \u [] k_s3oxf a1_s3oxg; } in
                            let {
                              sat_s3oxj [Occ=Once]
                                :: sep_a3nwy -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [lvl4_s3oxh] \r [a2_s3oxi] lvl4_s3oxh;
                            } in  sep1_s3oxc sat_s3oxj;
                  } in  p_s3oxb sat_s3oxk; } in
        let {
          sat_s3oxs [Occ=Once]
            :: a_a3nwx -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [sep1_s3oxc eta_s3oxd p1_s3oxe] \r [a1_s3oxl]
                  let {
                    lvl4_s3oxm [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [eta_s3oxd p1_s3oxe a1_s3oxl] \u []
                            let {
                              sat_s3oxp [Occ=Once]
                                :: [a_a3nwx] -> Text.ParserCombinators.ReadP.P b_a3ngn
                              [LclId] =
                                  [eta_s3oxd a1_s3oxl] \r [a2_s3oxn]
                                      let {
                                        sat_s3oxo [Occ=Once] :: [a_a3nwx]
                                        [LclId] =
                                            CCCS :! [a1_s3oxl a2_s3oxn];
                                      } in  eta_s3oxd sat_s3oxo;
                            } in  Text.ParserCombinators.ReadP.endBy3 p1_s3oxe sat_s3oxp; } in
                  let {
                    sat_s3oxr [Occ=Once]
                      :: sep_a3nwy -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [lvl4_s3oxm] \r [a2_s3oxq] lvl4_s3oxm;
                  } in  sep1_s3oxc sat_s3oxr;
        } in  p_s3oxb sat_s3oxs;

Text.ParserCombinators.ReadP.endBy1
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.endBy4 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.skipMany2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,C(U)><C(S),1*C1(U)>, Unf=OtherCon []] =
    [] \r [p_s3oxt eta_s3oxu]
        case eta_s3oxu GHC.Tuple.() of lvl4_s3oxv [Dmd=<S,U>] {
          __DEFAULT ->
              let {
                sat_s3oxx [Occ=Once]
                  :: [a_a3nwN] -> Text.ParserCombinators.ReadP.P b_a3ngn
                [LclId] =
                    [lvl4_s3oxv] \r [a1_s3oxw] lvl4_s3oxv;
              } in  Text.ParserCombinators.ReadP.endBy3 p_s3oxt sat_s3oxx;
        };

Text.ParserCombinators.ReadP.skipMany
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP ()
[GblId, Arity=2, Str=<L,C(U)><C(S),1*C1(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.skipMany2 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.skipMany3
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),C(U)><L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [p_s3oxy eta_s3oxz]
        let {
          lvl4_s3oxA [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [p_s3oxy eta_s3oxz] \u []
                  case eta_s3oxz GHC.Tuple.() of lvl5_s3oxB [Dmd=<S,U>] {
                    __DEFAULT ->
                        let {
                          sat_s3oxD [Occ=Once]
                            :: [a_a3nwY] -> Text.ParserCombinators.ReadP.P b_a3ngn
                          [LclId] =
                              [lvl5_s3oxB] \r [a1_s3oxC] lvl5_s3oxB;
                        } in  Text.ParserCombinators.ReadP.endBy3 p_s3oxy sat_s3oxD;
                  }; } in
        let {
          sat_s3oxF [Occ=Once]
            :: a_a3nwY -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [lvl4_s3oxA] \r [a1_s3oxE] lvl4_s3oxA;
        } in  p_s3oxy sat_s3oxF;

Text.ParserCombinators.ReadP.skipMany1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP ()
[GblId, Arity=2, Str=<C(S),C(U)><L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.skipMany3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.sepBy3
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3oxG sep1_s3oxH eta_s3oxI]
        let {
          m2_s3oxJ [Occ=OnceL, Dmd=<L,C(U)>]
            :: forall b1.
               (a_a3nx6 -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              [p_s3oxG sep1_s3oxH] \r [k_s3oxK]
                  let {
                    lvl4_s3oxL [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [p_s3oxG k_s3oxK] \u [] p_s3oxG k_s3oxK; } in
                  let {
                    sat_s3oxN [Occ=Once]
                      :: sep_a3nx7 -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [lvl4_s3oxL] \r [a1_s3oxM] lvl4_s3oxL;
                  } in  sep1_s3oxH sat_s3oxN; } in
        let {
          sat_s3oxS [Occ=Once]
            :: a_a3nx6 -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [eta_s3oxI m2_s3oxJ] \r [a1_s3oxO]
                  let {
                    sat_s3oxR [Occ=Once]
                      :: [a_a3nx6] -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [eta_s3oxI a1_s3oxO] \r [a2_s3oxP]
                            let {
                              sat_s3oxQ [Occ=Once] :: [a_a3nx6]
                              [LclId] =
                                  CCCS :! [a1_s3oxO a2_s3oxP];
                            } in  eta_s3oxI sat_s3oxQ;
                  } in  Text.ParserCombinators.ReadP.endBy3 m2_s3oxJ sat_s3oxR;
        } in  p_s3oxG sat_s3oxS;

Text.ParserCombinators.ReadP.sepBy1
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.sepBy3 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.endBy2
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,C(U)><L,C(U)><C(S),C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3oxT sep1_s3oxU eta_s3oxV]
        let {
          sat_s3oy2 [Occ=Once] :: Text.ParserCombinators.ReadP.ReadP a_a3nxl
          [LclId] =
              [p_s3oxT sep1_s3oxU] \r [k_s3oxW]
                  let {
                    sat_s3oy1 [Occ=Once]
                      :: a_a3nxl -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [sep1_s3oxU k_s3oxW] \r [a1_s3oxX]
                            let {
                              lvl4_s3oxY [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3oxW a1_s3oxX] \u [] k_s3oxW a1_s3oxX; } in
                            let {
                              sat_s3oy0 [Occ=Once]
                                :: sep_a3nxm -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [lvl4_s3oxY] \r [a2_s3oxZ] lvl4_s3oxY;
                            } in  sep1_s3oxU sat_s3oy0;
                  } in  p_s3oxT sat_s3oy1;
        } in  Text.ParserCombinators.ReadP.endBy3 sat_s3oy2 eta_s3oxV;

Text.ParserCombinators.ReadP.endBy
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Str=<L,C(U)><L,C(U)><C(S),C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.endBy2 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.sepBy2
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3oy3 sep1_s3oy4 eta_s3oy5]
        let {
          sat_s3oy7 [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [eta_s3oy5] \u [] eta_s3oy5 GHC.Types.[];
        } in 
          case
              Text.ParserCombinators.ReadP.sepBy3 p_s3oy3 sep1_s3oy4 eta_s3oy5
          of
          sat_s3oy6
          { __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3oy6 sat_s3oy7;
          };

Text.ParserCombinators.ReadP.sepBy
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.sepBy2 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$fMonadFailReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fail.C:MonadFail! [Text.ParserCombinators.ReadP.$fMonadReadP
                                                   Text.ParserCombinators.ReadP.$fMonadFailReadP1];

Text.ParserCombinators.ReadP.$fAlternativeReadP2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),C(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [v_s3oy8 eta_s3oy9]
        let {
          some_v_s3oya [Occ=LoopBreaker]
            :: forall b1.
               ([a_a3nIa] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              sat-only [v_s3oy8 some_v_s3oya] \r [eta1_s3oyb]
                  let {
                    sat_s3oyj [Occ=Once]
                      :: a_a3nIa -> Text.ParserCombinators.ReadP.P b1_X3nkZ
                    [LclId] =
                        [some_v_s3oya eta1_s3oyb] \r [x_s3oyc]
                            let {
                              sat_s3oyi [Occ=Once] :: Text.ParserCombinators.ReadP.P b1_X3nkZ
                              [LclId] =
                                  [eta1_s3oyb x_s3oyc] \u []
                                      let {
                                        sat_s3oyh [Occ=Once] :: [a_a3nIa]
                                        [LclId] =
                                            CCCS :! [x_s3oyc GHC.Types.[]];
                                      } in  eta1_s3oyb sat_s3oyh; } in
                            let {
                              sat_s3oyf [Occ=Once]
                                :: [a_a3nIa] -> Text.ParserCombinators.ReadP.P b1_X3nkZ
                              [LclId] =
                                  [eta1_s3oyb x_s3oyc] \r [a1_s3oyd]
                                      let {
                                        sat_s3oye [Occ=Once] :: [a_a3nIa]
                                        [LclId] =
                                            CCCS :! [x_s3oyc a1_s3oyd];
                                      } in  eta1_s3oyb sat_s3oye;
                            } in 
                              case some_v_s3oya sat_s3oyf of sat_s3oyg {
                                __DEFAULT ->
                                    Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                        sat_s3oyg sat_s3oyi;
                              };
                  } in  v_s3oy8 sat_s3oyj;
        } in  some_v_s3oya eta_s3oy9;

Text.ParserCombinators.ReadP.$fAlternativeReadP1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),C(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [v_s3oyk eta_s3oyl]
        let {
          many_v_s3oym [Occ=LoopBreaker]
            :: forall b1.
               ([a_a3nIm] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              sat-only [v_s3oyk many_v_s3oym] \r [k_s3oyn]
                  let {
                    sat_s3oyu [Occ=Once] :: Text.ParserCombinators.ReadP.P b1_a3nvJ
                    [LclId] =
                        [k_s3oyn] \u [] k_s3oyn GHC.Types.[]; } in
                  let {
                    sat_s3oys [Occ=Once]
                      :: a_a3nIm -> Text.ParserCombinators.ReadP.P b1_a3nvJ
                    [LclId] =
                        [many_v_s3oym k_s3oyn] \r [x_s3oyo]
                            let {
                              sat_s3oyr [Occ=Once]
                                :: [a_a3nIm] -> Text.ParserCombinators.ReadP.P b1_a3nvJ
                              [LclId] =
                                  [k_s3oyn x_s3oyo] \r [a1_s3oyp]
                                      let {
                                        sat_s3oyq [Occ=Once] :: [a_a3nIm]
                                        [LclId] =
                                            CCCS :! [x_s3oyo a1_s3oyp];
                                      } in  k_s3oyn sat_s3oyq;
                            } in  many_v_s3oym sat_s3oyr;
                  } in 
                    case v_s3oyk sat_s3oys of sat_s3oyt {
                      __DEFAULT ->
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                              sat_s3oyt sat_s3oyu;
                    };
        } in  many_v_s3oym eta_s3oyl;

Text.ParserCombinators.ReadP.$fAlternativeReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Text.ParserCombinators.ReadP.$fApplicativeReadP
                                           Text.ParserCombinators.ReadP.$fAlternativeReadP4
                                           Text.ParserCombinators.ReadP.$fAlternativeReadP3
                                           Text.ParserCombinators.ReadP.$fAlternativeReadP2
                                           Text.ParserCombinators.ReadP.$fAlternativeReadP1];

Text.ParserCombinators.ReadP.$fMonadPlusReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [Text.ParserCombinators.ReadP.$fAlternativeReadP
                                         Text.ParserCombinators.ReadP.$fMonadReadP
                                         Text.ParserCombinators.ReadP.$fAlternativeReadP4
                                         Text.ParserCombinators.ReadP.$fAlternativeReadP3];

Text.ParserCombinators.ReadP.chainr3
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3oyv op_s3oyw eta_s3oyx]
        let {
          scan_s3oyy [Occ=LoopBreaker]
            :: forall b1.
               (a_a3nxM -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              sat-only [p_s3oyv op_s3oyw scan_s3oyy] \r [k_s3oyz]
                  let {
                    sat_s3oyI [Occ=Once]
                      :: a_a3nxM -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [op_s3oyw scan_s3oyy k_s3oyz] \r [a1_s3oyA]
                            let {
                              sat_s3oyH [Occ=Once] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3oyz a1_s3oyA] \u [] k_s3oyz a1_s3oyA; } in
                            let {
                              sat_s3oyF [Occ=Once]
                                :: (a_a3nxM -> a_a3nxM -> a_a3nxM)
                                   -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [scan_s3oyy k_s3oyz a1_s3oyA] \r [a2_s3oyB]
                                      let {
                                        sat_s3oyE [Occ=Once]
                                          :: a_a3nxM -> Text.ParserCombinators.ReadP.P b1_a3nIU
                                        [LclId] =
                                            [k_s3oyz a1_s3oyA a2_s3oyB] \r [a3_s3oyC]
                                                let {
                                                  sat_s3oyD [Occ=Once] :: a_a3nxM
                                                  [LclId] =
                                                      [a1_s3oyA a2_s3oyB a3_s3oyC] \u []
                                                          a2_s3oyB a1_s3oyA a3_s3oyC;
                                                } in  k_s3oyz sat_s3oyD;
                                      } in  scan_s3oyy sat_s3oyE;
                            } in 
                              case op_s3oyw sat_s3oyF of sat_s3oyG {
                                __DEFAULT ->
                                    Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                        sat_s3oyG sat_s3oyH;
                              };
                  } in  p_s3oyv sat_s3oyI;
        } in  scan_s3oyy eta_s3oyx;

Text.ParserCombinators.ReadP.chainr1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.chainr3 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.chainr2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3oyJ op_s3oyK x_s3oyL eta_s3oyM]
        let {
          sat_s3oyO [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [x_s3oyL eta_s3oyM] \u [] eta_s3oyM x_s3oyL;
        } in 
          case
              Text.ParserCombinators.ReadP.chainr3 p_s3oyJ op_s3oyK eta_s3oyM
          of
          sat_s3oyN
          { __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3oyN sat_s3oyO;
          };

Text.ParserCombinators.ReadP.chainr
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.chainr2 eta_B4 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.chainl3
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3oyP op_s3oyQ eta_s3oyR]
        let {
          rest_s3oyS [Occ=LoopBreaker]
            :: a_a3nyq
               -> forall b1.
                  (a_a3nyq -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<L,U><L,C(U)>, Unf=OtherCon []] =
              sat-only [p_s3oyP op_s3oyQ rest_s3oyS] \r [x_s3oyT eta1_s3oyU]
                  let {
                    sat_s3oz1 [Occ=Once] :: Text.ParserCombinators.ReadP.P b1_X3nls
                    [LclId] =
                        [x_s3oyT eta1_s3oyU] \u [] eta1_s3oyU x_s3oyT; } in
                  let {
                    sat_s3oyZ [Occ=Once]
                      :: (a_a3nyq -> a_a3nyq -> a_a3nyq)
                         -> Text.ParserCombinators.ReadP.P b1_X3nls
                    [LclId] =
                        [p_s3oyP rest_s3oyS x_s3oyT eta1_s3oyU] \r [a1_s3oyV]
                            let {
                              sat_s3oyY [Occ=Once]
                                :: a_a3nyq -> Text.ParserCombinators.ReadP.P b1_X3nls
                              [LclId] =
                                  [rest_s3oyS x_s3oyT eta1_s3oyU a1_s3oyV] \r [a2_s3oyW]
                                      let {
                                        sat_s3oyX [Occ=Once] :: a_a3nyq
                                        [LclId] =
                                            [x_s3oyT a1_s3oyV a2_s3oyW] \u []
                                                a1_s3oyV x_s3oyT a2_s3oyW;
                                      } in  rest_s3oyS sat_s3oyX eta1_s3oyU;
                            } in  p_s3oyP sat_s3oyY;
                  } in 
                    case op_s3oyQ sat_s3oyZ of sat_s3oz0 {
                      __DEFAULT ->
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                              sat_s3oz0 sat_s3oz1;
                    }; } in
        let {
          sat_s3oz3 [Occ=Once]
            :: a_a3nyq -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [eta_s3oyR rest_s3oyS] \r [a1_s3oz2] rest_s3oyS a1_s3oz2 eta_s3oyR;
        } in  p_s3oyP sat_s3oz3;

Text.ParserCombinators.ReadP.chainl1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.chainl3 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.chainl2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3oz4 op_s3oz5 x_s3oz6 eta_s3oz7]
        let {
          sat_s3oz9 [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [x_s3oz6 eta_s3oz7] \u [] eta_s3oz7 x_s3oz6;
        } in 
          case
              Text.ParserCombinators.ReadP.chainl3 p_s3oz4 op_s3oz5 eta_s3oz7
          of
          sat_s3oz8
          { __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3oz8 sat_s3oz9;
          };

Text.ParserCombinators.ReadP.chainl
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.chainl2 eta_B4 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.<++2 [Occ=LoopBreaker]
  :: GHC.Prim.Int#
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s3oza eta_s3ozb]
        case ds_s3oza of ds1_s3ozc {
          __DEFAULT ->
              let {
                lvl4_s3ozd [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_X3nlD
                [LclId] =
                    [eta_s3ozb ds1_s3ozc] \u []
                        case -# [ds1_s3ozc 1#] of sat_s3oze {
                          __DEFAULT -> Text.ParserCombinators.ReadP.<++2 sat_s3oze eta_s3ozb;
                        }; } in
              let {
                sat_s3ozg [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_X3nlD
                [LclId] =
                    [lvl4_s3ozd] \r [a_s3ozf] lvl4_s3ozd;
              } in  Text.ParserCombinators.ReadP.Get [sat_s3ozg];
          0# -> eta_s3ozb GHC.Tuple.();
        };

Text.ParserCombinators.ReadP.$w<++ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId, Arity=3, Str=<L,1*C1(U)><L,C(U)><L,U>, Unf=OtherCon []] =
    [] \r [w_s3ozh w1_s3ozi w2_s3ozj]
        let {
          lvl4_s3ozk [Occ=OnceL] :: Text.ParserCombinators.ReadP.P a_s3ohU
          [LclId] =
              [w_s3ozh] \u []
                  w_s3ozh Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
        let {
          probe_s3ozl [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadP.P a_s3ohU
               -> [GHC.Types.Char]
               -> GHC.Prim.Int#
               -> forall b1.
                  (a_s3ohU -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=4, Str=<S,1*U><L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w1_s3ozi probe_s3ozl] \r [ds_s3ozm
                                                  ds1_s3ozn
                                                  n_s3ozo
                                                  eta_s3ozp]
                  case ds_s3ozm of wild_s3ozq {
                    Text.ParserCombinators.ReadP.Get f_s3ozr [Occ=Once!] ->
                        case ds1_s3ozn of {
                          [] -> w1_s3ozi eta_s3ozp;
                          : c_s3ozt [Occ=Once] s_s3ozu [Occ=Once] ->
                              case +# [n_s3ozo 1#] of sat_s3ozw {
                                __DEFAULT ->
                                    case f_s3ozr c_s3ozt of sat_s3ozv {
                                      __DEFAULT ->
                                          probe_s3ozl sat_s3ozv s_s3ozu sat_s3ozw eta_s3ozp;
                                    };
                              };
                        };
                    Text.ParserCombinators.ReadP.Look f_s3ozx [Occ=Once!] ->
                        case f_s3ozx ds1_s3ozn of sat_s3ozy {
                          __DEFAULT -> probe_s3ozl sat_s3ozy ds1_s3ozn n_s3ozo eta_s3ozp;
                        };
                    Text.ParserCombinators.ReadP.Fail -> w1_s3ozi eta_s3ozp;
                    Text.ParserCombinators.ReadP.Result _ [Occ=Dead] _ [Occ=Dead] ->
                        let {
                          sat_s3ozC [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b1_X3nlg
                          [LclId] =
                              [eta_s3ozp wild_s3ozq] \r [a1_s3ozB]
                                  Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                      wild_s3ozq eta_s3ozp;
                        } in  Text.ParserCombinators.ReadP.<++2 n_s3ozo sat_s3ozC;
                    Text.ParserCombinators.ReadP.Final _ [Occ=Dead] ->
                        Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                            wild_s3ozq eta_s3ozp;
                  }; } in
        let {
          sat_s3ozF [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3ohX
          [LclId] =
              [w2_s3ozj lvl4_s3ozk probe_s3ozl] \r [a1_s3ozE]
                  probe_s3ozl lvl4_s3ozk a1_s3ozE 0# w2_s3ozj;
        } in  Unit# [sat_s3ozF];

Text.ParserCombinators.ReadP.<++1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,1*C1(U)><L,C(U)><L,U>m2, Unf=OtherCon []] =
    [] \r [w_s3ozG w1_s3ozH w2_s3ozI]
        case
            Text.ParserCombinators.ReadP.$w<++ w_s3ozG w1_s3ozH w2_s3ozI
        of
        { Unit# ww1_s3ozK [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_s3ozK];
        };

Text.ParserCombinators.ReadP.<++
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=3, Str=<L,1*C1(U)><L,C(U)><L,U>m2, Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.<++1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.manyTill1
  :: forall a end.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP end
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,C(U)><L,C(U)><L,U>, Unf=OtherCon []] =
    [] \r [p_s3ozL end1_s3ozM eta_s3ozN]
        let {
          scan_s3ozO [Occ=OnceL, Dmd=<L,C(U)>]
            :: forall b1.
               ([a_a3nB6] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,1*C1(U)>, Unf=OtherCon []] =
              [end1_s3ozM] \r [k_s3ozP]
                  let {
                    lvl4_s3ozQ [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [k_s3ozP] \u [] k_s3ozP GHC.Types.[]; } in
                  let {
                    sat_s3ozS [Occ=Once]
                      :: end_a3nB7 -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [lvl4_s3ozQ] \r [a1_s3ozR] lvl4_s3ozQ;
                  } in  end1_s3ozM sat_s3ozS; } in
        let {
          scan1_s3ozT [Occ=OnceL]
            :: forall b1.
               ([a_a3nB6] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              [p_s3ozL scan2_s3ozU] \r [k_s3ozV]
                  let {
                    sat_s3oA0 [Occ=Once]
                      :: a_a3nB6 -> Text.ParserCombinators.ReadP.P b1_X3nOr
                    [LclId] =
                        [scan2_s3ozU k_s3ozV] \r [a1_s3ozW]
                            let {
                              sat_s3ozZ [Occ=Once]
                                :: [a_a3nB6] -> Text.ParserCombinators.ReadP.P b1_X3nOr
                              [LclId] =
                                  [k_s3ozV a1_s3ozW] \r [a2_s3ozX]
                                      let {
                                        sat_s3ozY [Occ=Once] :: [a_a3nB6]
                                        [LclId] =
                                            CCCS :! [a1_s3ozW a2_s3ozX];
                                      } in  k_s3ozV sat_s3ozY;
                            } in  scan2_s3ozU sat_s3ozZ;
                  } in  p_s3ozL sat_s3oA0;
          scan2_s3ozU [Occ=LoopBreaker]
            :: forall b1.
               ([a_a3nB6] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [scan_s3ozO scan1_s3ozT] \r [w_s3oA1]
                  case
                      Text.ParserCombinators.ReadP.$w<++ scan_s3ozO scan1_s3ozT w_s3oA1
                  of
                  { Unit# ww1_s3oA3 [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_s3oA3];
                  };
        } in  scan2_s3ozU eta_s3ozN;

Text.ParserCombinators.ReadP.manyTill
  :: forall a end.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP end
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=3, Str=<L,C(U)><L,C(U)><L,U>, Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.manyTill1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.eof1
  :: forall b.
     (() -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)>m2,
 Unf=OtherCon []] =
    [] \r [k_s3oA4]
        let {
          lvl4_s3oA5 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3nIU
          [LclId] =
              [k_s3oA4] \u [] k_s3oA4 GHC.Tuple.(); } in
        let {
          sat_s3oAa [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3nIU
          [LclId] =
              [lvl4_s3oA5] \r [a_s3oA6]
                  case a_s3oA6 of {
                    [] -> lvl4_s3oA5;
                    : _ [Occ=Dead] _ [Occ=Dead] ->
                        Text.ParserCombinators.ReadP.Fail [];
                  };
        } in  Text.ParserCombinators.ReadP.Look [sat_s3oAa];

Text.ParserCombinators.ReadP.eof
  :: Text.ParserCombinators.ReadP.ReadP ()
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.eof1 eta_B1;

Text.ParserCombinators.ReadP.satisfy1
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Types.Char -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [p_s3oAb k_s3oAc]
        let {
          sat_s3oAf [Occ=Once]
            :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_X3nNg
          [LclId] =
              [p_s3oAb k_s3oAc] \r [a_s3oAd]
                  case p_s3oAb a_s3oAd of {
                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail [];
                    GHC.Types.True -> k_s3oAc a_s3oAd;
                  };
        } in  Text.ParserCombinators.ReadP.Get [sat_s3oAf];

Text.ParserCombinators.ReadP.satisfy
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> Text.ParserCombinators.ReadP.ReadP GHC.Types.Char
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.satisfy1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.char1
  :: GHC.Types.Char
     -> forall b.
        (GHC.Types.Char -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [c_s3oAg eta_s3oAh]
        let {
          sat_s3oAo [Occ=Once]
            :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_X3nNg
          [LclId] =
              [c_s3oAg eta_s3oAh] \r [a_s3oAi]
                  case c_s3oAg of {
                    GHC.Types.C# x_s3oAk [Occ=Once] ->
                        case a_s3oAi of wild1_s3oAl {
                          GHC.Types.C# y_s3oAm [Occ=Once] ->
                              case eqChar# [x_s3oAk y_s3oAm] of {
                                __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                1# -> eta_s3oAh wild1_s3oAl;
                              };
                        };
                  };
        } in  Text.ParserCombinators.ReadP.Get [sat_s3oAo];

Text.ParserCombinators.ReadP.char
  :: GHC.Types.Char
     -> Text.ParserCombinators.ReadP.ReadP GHC.Types.Char
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.char1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$wstring [InlPrag=NOUSERINLINE[0]]
  :: GHC.Base.String
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3oAp w1_s3oAq]
        let {
          scan_s3oAr [Occ=LoopBreaker]
            :: [GHC.Types.Char]
               -> [GHC.Types.Char]
               -> forall b1.
                  (GHC.Base.String -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=3, Str=<S,1*U><L,1*U><L,1*C1(U)>, Unf=OtherCon []] =
              sat-only [w_s3oAp scan_s3oAr] \r [ds_s3oAs ds1_s3oAt eta_s3oAu]
                  case ds_s3oAs of {
                    [] -> eta_s3oAu w_s3oAp;
                    : x_s3oAw [Occ=Once!] xs_s3oAx [Occ=Once] ->
                        case ds1_s3oAt of {
                          [] -> Text.ParserCombinators.ReadP.Fail [];
                          : y_s3oAz [Occ=Once!] ys_s3oAA [Occ=Once] ->
                              case x_s3oAw of {
                                GHC.Types.C# x1_s3oAC [Occ=Once] ->
                                    case y_s3oAz of {
                                      GHC.Types.C# y1_s3oAE [Occ=Once] ->
                                          case eqChar# [x1_s3oAC y1_s3oAE] of {
                                            __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                            1# ->
                                                let {
                                                  lvl4_s3oAG [Occ=OnceL]
                                                    :: Text.ParserCombinators.ReadP.P b1_a3ngn
                                                  [LclId] =
                                                      [scan_s3oAr eta_s3oAu xs_s3oAx ys_s3oAA] \u []
                                                          scan_s3oAr
                                                              xs_s3oAx ys_s3oAA eta_s3oAu; } in
                                                let {
                                                  sat_s3oAI [Occ=Once]
                                                    :: GHC.Types.Char
                                                       -> Text.ParserCombinators.ReadP.P b1_a3ngn
                                                  [LclId] =
                                                      [lvl4_s3oAG] \r [a_s3oAH] lvl4_s3oAG;
                                                } in  Text.ParserCombinators.ReadP.Get [sat_s3oAI];
                                          };
                                    };
                              };
                        };
                  }; } in
        let {
          sat_s3oAK [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3oig
          [LclId] =
              [w_s3oAp w1_s3oAq scan_s3oAr] \r [a_s3oAJ]
                  scan_s3oAr w_s3oAp a_s3oAJ w1_s3oAq;
        } in  Unit# [sat_s3oAK];

Text.ParserCombinators.ReadP.string1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Base.String
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_s3oAL w1_s3oAM]
        case Text.ParserCombinators.ReadP.$wstring w_s3oAL w1_s3oAM of {
          Unit# ww1_s3oAO [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_s3oAO];
        };

Text.ParserCombinators.ReadP.string
  :: GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadP GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.string1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$wmunch [InlPrag=NOUSERINLINE[0]]
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3oAP w1_s3oAQ]
        let {
          scan_s3oAR [Occ=LoopBreaker]
            :: [GHC.Types.Char]
               -> forall b1.
                  ([GHC.Types.Char] -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<S,1*U><L,1*C1(U)>, Unf=OtherCon []] =
              sat-only [w_s3oAP scan_s3oAR] \r [ds_s3oAS eta_s3oAT]
                  case ds_s3oAS of {
                    [] -> eta_s3oAT GHC.Types.[];
                    : c_s3oAV cs_s3oAW [Occ=Once] ->
                        case w_s3oAP c_s3oAV of {
                          GHC.Types.False -> eta_s3oAT GHC.Types.[];
                          GHC.Types.True ->
                              let {
                                lvl4_s3oAY [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_X3nlq
                                [LclId] =
                                    [scan_s3oAR eta_s3oAT c_s3oAV cs_s3oAW] \u []
                                        let {
                                          sat_s3oB1 [Occ=Once]
                                            :: [GHC.Types.Char]
                                               -> Text.ParserCombinators.ReadP.P b1_X3nlq
                                          [LclId] =
                                              [eta_s3oAT c_s3oAV] \r [a_s3oAZ]
                                                  let {
                                                    sat_s3oB0 [Occ=Once] :: [GHC.Types.Char]
                                                    [LclId] =
                                                        CCCS :! [c_s3oAV a_s3oAZ];
                                                  } in  eta_s3oAT sat_s3oB0;
                                        } in  scan_s3oAR cs_s3oAW sat_s3oB1; } in
                              let {
                                sat_s3oB3 [Occ=Once]
                                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b1_X3nlq
                                [LclId] =
                                    [lvl4_s3oAY] \r [a_s3oB2] lvl4_s3oAY;
                              } in  Text.ParserCombinators.ReadP.Get [sat_s3oB3];
                        };
                  }; } in
        let {
          sat_s3oB5 [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3oiq
          [LclId] =
              [w1_s3oAQ scan_s3oAR] \r [a_s3oB4] scan_s3oAR a_s3oB4 w1_s3oAQ;
        } in  Unit# [sat_s3oB5];

Text.ParserCombinators.ReadP.munch2 [InlPrag=NOUSERINLINE[0]]
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_s3oB6 w1_s3oB7]
        case Text.ParserCombinators.ReadP.$wmunch w_s3oB6 w1_s3oB7 of {
          Unit# ww1_s3oB9 [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_s3oB9];
        };

Text.ParserCombinators.ReadP.munch
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> Text.ParserCombinators.ReadP.ReadP GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.munch2 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$wmunch1 [InlPrag=NOUSERINLINE[0]]
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Types.Char -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3oBa w1_s3oBb]
        let {
          sat_s3oBj [Occ=Once]
            :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_s3oix
          [LclId] =
              [w_s3oBa w1_s3oBb] \r [a_s3oBc]
                  case w_s3oBa a_s3oBc of {
                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail [];
                    GHC.Types.True ->
                        let {
                          sat_s3oBg [Occ=Once]
                            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3oix
                          [LclId] =
                              [w1_s3oBb a_s3oBc] \r [a1_s3oBe]
                                  let {
                                    sat_s3oBf [Occ=Once] :: GHC.Base.String
                                    [LclId] =
                                        CCCS :! [a_s3oBc a1_s3oBe];
                                  } in  w1_s3oBb sat_s3oBf;
                        } in 
                          case Text.ParserCombinators.ReadP.$wmunch w_s3oBa sat_s3oBg of {
                            Unit# ww1_s3oBi [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww1_s3oBi];
                          };
                  };
        } in  Unit# [sat_s3oBj];

Text.ParserCombinators.ReadP.munch3 [InlPrag=NOUSERINLINE[0]]
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [w_s3oBk w1_s3oBl]
        case Text.ParserCombinators.ReadP.$wmunch1 w_s3oBk w1_s3oBl of {
          Unit# ww1_s3oBn [Occ=Once] ->
              Text.ParserCombinators.ReadP.Get [ww1_s3oBn];
        };

Text.ParserCombinators.ReadP.munch1
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> Text.ParserCombinators.ReadP.ReadP GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.munch3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.skipSpaces2 [Occ=LoopBreaker]
  :: [GHC.Types.Char]
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s3oBo eta_s3oBp]
        case ds_s3oBo of {
          [] -> eta_s3oBp GHC.Tuple.();
          : c_s3oBr [Occ=Once!] s_s3oBs [Occ=Once*] ->
              case c_s3oBr of {
                GHC.Types.C# ww1_s3oBu ->
                    case ord# [ww1_s3oBu] of sat_s3oBw {
                      __DEFAULT ->
                          case int2Word# [sat_s3oBw] of x_s3oBv [Dmd=<S,U>] {
                            __DEFAULT ->
                                case leWord# [x_s3oBv 887##] of {
                                  __DEFAULT ->
                                      case ord# [ww1_s3oBu] of sat_s3oBz {
                                        __DEFAULT ->
                                            case
                                                __pkg_ccall base-4.11.0.0 [sat_s3oBz
                                                                           GHC.Prim.realWorld#]
                                            of
                                            { (#,#) _ [Occ=Dead] ds2_s3oBC [Occ=Once!] ->
                                                  case ds2_s3oBC of {
                                                    __DEFAULT ->
                                                        let {
                                                          lvl4_s3oBE [Occ=OnceL]
                                                            :: Text.ParserCombinators.ReadP.P
                                                                 b_a3ngn
                                                          [LclId] =
                                                              [eta_s3oBp s_s3oBs] \u []
                                                                  Text.ParserCombinators.ReadP.skipSpaces2
                                                                      s_s3oBs eta_s3oBp; } in
                                                        let {
                                                          sat_s3oBG [Occ=Once]
                                                            :: GHC.Types.Char
                                                               -> Text.ParserCombinators.ReadP.P
                                                                    b_a3ngn
                                                          [LclId] =
                                                              [lvl4_s3oBE] \r [a_s3oBF] lvl4_s3oBE;
                                                        } in 
                                                          Text.ParserCombinators.ReadP.Get [sat_s3oBG];
                                                    0# -> eta_s3oBp GHC.Tuple.();
                                                  };
                                            };
                                      };
                                  1# ->
                                      case x_s3oBv of wild1_s3oBH {
                                        __DEFAULT ->
                                            case minusWord# [wild1_s3oBH 9##] of sat_s3oBI {
                                              __DEFAULT ->
                                                  case leWord# [sat_s3oBI 4##] of {
                                                    __DEFAULT ->
                                                        case wild1_s3oBH of {
                                                          __DEFAULT -> eta_s3oBp GHC.Tuple.();
                                                          160## ->
                                                              let {
                                                                lvl4_s3oBL [Occ=OnceL]
                                                                  :: Text.ParserCombinators.ReadP.P
                                                                       b_a3ngn
                                                                [LclId] =
                                                                    [eta_s3oBp s_s3oBs] \u []
                                                                        Text.ParserCombinators.ReadP.skipSpaces2
                                                                            s_s3oBs eta_s3oBp; } in
                                                              let {
                                                                sat_s3oBN [Occ=Once]
                                                                  :: GHC.Types.Char
                                                                     -> Text.ParserCombinators.ReadP.P
                                                                          b_a3ngn
                                                                [LclId] =
                                                                    [lvl4_s3oBL] \r [a_s3oBM]
                                                                        lvl4_s3oBL;
                                                              } in 
                                                                Text.ParserCombinators.ReadP.Get [sat_s3oBN];
                                                        };
                                                    1# ->
                                                        let {
                                                          lvl4_s3oBO [Occ=OnceL]
                                                            :: Text.ParserCombinators.ReadP.P
                                                                 b_a3ngn
                                                          [LclId] =
                                                              [eta_s3oBp s_s3oBs] \u []
                                                                  Text.ParserCombinators.ReadP.skipSpaces2
                                                                      s_s3oBs eta_s3oBp; } in
                                                        let {
                                                          sat_s3oBQ [Occ=Once]
                                                            :: GHC.Types.Char
                                                               -> Text.ParserCombinators.ReadP.P
                                                                    b_a3ngn
                                                          [LclId] =
                                                              [lvl4_s3oBO] \r [a_s3oBP] lvl4_s3oBO;
                                                        } in 
                                                          Text.ParserCombinators.ReadP.Get [sat_s3oBQ];
                                                  };
                                            };
                                        32## ->
                                            let {
                                              lvl4_s3oBR [Occ=OnceL]
                                                :: Text.ParserCombinators.ReadP.P b_a3ngn
                                              [LclId] =
                                                  [eta_s3oBp s_s3oBs] \u []
                                                      Text.ParserCombinators.ReadP.skipSpaces2
                                                          s_s3oBs eta_s3oBp; } in
                                            let {
                                              sat_s3oBT [Occ=Once]
                                                :: GHC.Types.Char
                                                   -> Text.ParserCombinators.ReadP.P b_a3ngn
                                              [LclId] =
                                                  [lvl4_s3oBR] \r [a_s3oBS] lvl4_s3oBR;
                                            } in  Text.ParserCombinators.ReadP.Get [sat_s3oBT];
                                      };
                                };
                          };
                    };
              };
        };

Text.ParserCombinators.ReadP.skipSpaces1
  :: forall b.
     (() -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,C(U)>m2, Unf=OtherCon []] =
    [] \r [k_s3oBU]
        let {
          sat_s3oBW [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_X3nNv
          [LclId] =
              [k_s3oBU] \r [a_s3oBV]
                  Text.ParserCombinators.ReadP.skipSpaces2 a_s3oBV k_s3oBU;
        } in  Text.ParserCombinators.ReadP.Look [sat_s3oBW];

Text.ParserCombinators.ReadP.skipSpaces
  :: Text.ParserCombinators.ReadP.ReadP ()
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,C(U)>m2, Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.skipSpaces1 eta_B1;

Text.ParserCombinators.ReadP.Get
  :: forall a.
     (GHC.Types.Char -> Text.ParserCombinators.ReadP.P a)
     -> Text.ParserCombinators.ReadP.P a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m1,
 Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Get [eta_B1];

Text.ParserCombinators.ReadP.Look
  :: forall a.
     (GHC.Base.String -> Text.ParserCombinators.ReadP.P a)
     -> Text.ParserCombinators.ReadP.P a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Look [eta_B1];

Text.ParserCombinators.ReadP.Fail
  :: forall a. Text.ParserCombinators.ReadP.P a
[GblId[DataCon], Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE Text.ParserCombinators.ReadP.Fail! [];

Text.ParserCombinators.ReadP.Result
  :: forall a.
     a
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m4,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.Result [eta_B2 eta_B1];

Text.ParserCombinators.ReadP.Final
  :: forall a.
     [(a, GHC.Base.String)] -> Text.ParserCombinators.ReadP.P a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m5,
 Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Final [eta_B1];


==================== STG syntax: ====================
2018-03-16 15:58:00.606604342 UTC

Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
  :: forall a. a -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m4, Unf=OtherCon []] =
    [] \r [x_s3oqX]
        Text.ParserCombinators.ReadP.Result [x_s3oqX
                                             Text.ParserCombinators.ReadP.Fail];

Text.ParserCombinators.ReadP.$fMonadFailP_$cfail
  :: forall a. GHC.Base.String -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s3oqY] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadP.$fFunctorReadP2
  :: forall a b.
     (a -> b)
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><C(S),1*C1(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [h_s3oqZ ds_s3or0 k_s3or1]
        let {
          sat_s3or2 [Occ=Once]
            :: a_a3nKO -> Text.ParserCombinators.ReadP.P b1_a3nKT
          [LclId] =
              [h_s3oqZ k_s3or1] \r [eta_B1] GHC.Base.. k_s3or1 h_s3oqZ eta_B1;
        } in  ds_s3or0 sat_s3or2;

Text.ParserCombinators.ReadP.$fFunctorReadP1
  :: forall a b.
     a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (a -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [x_s3or3 eta_s3or4 eta1_s3or5]
        let {
          lvl4_s3or6 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [x_s3or3 eta1_s3or5] \u [] eta1_s3or5 x_s3or3; } in
        let {
          sat_s3or8 [Occ=Once]
            :: b_a3nL5 -> Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [lvl4_s3or6] \r [x1_s3or7] lvl4_s3or6;
        } in  eta_s3or4 sat_s3or8;

Text.ParserCombinators.ReadP.$fFunctorReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Text.ParserCombinators.ReadP.$fFunctorReadP2
                                       Text.ParserCombinators.ReadP.$fFunctorReadP1];

Text.ParserCombinators.ReadP.$fApplicativeReadP5
  :: forall a.
     a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [x_s3or9 k_s3ora] k_s3ora x_s3or9;

Text.ParserCombinators.ReadP.$fMonadFailReadP1
  :: forall a.
     GHC.Base.String
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_s3orb ds1_s3orc] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadP.$fMonadReadP1
  :: forall a b.
     Text.ParserCombinators.ReadP.ReadP a
     -> (a -> Text.ParserCombinators.ReadP.ReadP b)
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3ord f_s3ore k_s3orf]
        let {
          sat_s3orh [Occ=Once]
            :: a_a3nIP -> Text.ParserCombinators.ReadP.P b1_a3nIU
          [LclId] =
              [f_s3ore k_s3orf] \r [a1_s3org] f_s3ore a1_s3org k_s3orf;
        } in  ds_s3ord sat_s3orh;

Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap [Occ=LoopBreaker]
  :: forall a b.
     (a -> b)
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s3ori ds_s3orj]
        case ds_s3orj of {
          Text.ParserCombinators.ReadP.Get a1_s3orl [Occ=OnceL!] ->
              let {
                sat_s3oro [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_a3nEm
                [LclId] =
                    [f_s3ori a1_s3orl] \r [b3_s3orm]
                        case a1_s3orl b3_s3orm of sat_s3orn {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                                  f_s3ori sat_s3orn;
                        };
              } in  Text.ParserCombinators.ReadP.Get [sat_s3oro];
          Text.ParserCombinators.ReadP.Look a1_s3orp [Occ=OnceL!] ->
              let {
                sat_s3ors [Occ=Once]
                  :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3nEm
                [LclId] =
                    [f_s3ori a1_s3orp] \r [b3_s3orq]
                        case a1_s3orp b3_s3orq of sat_s3orr {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                                  f_s3ori sat_s3orr;
                        };
              } in  Text.ParserCombinators.ReadP.Look [sat_s3ors];
          Text.ParserCombinators.ReadP.Fail ->
              Text.ParserCombinators.ReadP.Fail [];
          Text.ParserCombinators.ReadP.Result a1_s3ort [Occ=Once]
                                              a2_s3oru [Occ=Once] ->
              let {
                sat_s3orw [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nEm
                [LclId] =
                    [f_s3ori a2_s3oru] \u []
                        Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                            f_s3ori a2_s3oru; } in
              let {
                sat_s3orv [Occ=Once] :: b_a3nEm
                [LclId] =
                    [f_s3ori a1_s3ort] \u [] f_s3ori a1_s3ort;
              } in  Text.ParserCombinators.ReadP.Result [sat_s3orv sat_s3orw];
          Text.ParserCombinators.ReadP.Final a1_s3orx [Occ=Once] ->
              let {
                sat_s3orE [Occ=Once] :: [(b_a3nEm, GHC.Base.String)]
                [LclId] =
                    [f_s3ori a1_s3orx] \u []
                        let {
                          sat_s3orD [Occ=Once]
                            :: (a_a3nEl, GHC.Base.String) -> (b_a3nEm, GHC.Base.String)
                          [LclId] =
                              [f_s3ori] \r [b2_s3ory]
                                  case b2_s3ory of {
                                    (,) a2_s3orA [Occ=Once] a3_s3orB [Occ=Once] ->
                                        let {
                                          sat_s3orC [Occ=Once] :: b_a3nEm
                                          [LclId] =
                                              [f_s3ori a2_s3orA] \u [] f_s3ori a2_s3orA;
                                        } in  (,) [sat_s3orC a3_s3orB];
                                  };
                        } in  GHC.Base.map sat_s3orD a1_s3orx;
              } in  Text.ParserCombinators.ReadP.Final [sat_s3orE];
        };

Text.ParserCombinators.ReadP.$fApplicativeP_$c<$ [Occ=LoopBreaker]
  :: forall a b.
     a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [z_s3orF ds_s3orG]
        case ds_s3orG of {
          Text.ParserCombinators.ReadP.Get a1_s3orI [Occ=OnceL!] ->
              let {
                sat_s3orL [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P a_a3nFG
                [LclId] =
                    [z_s3orF a1_s3orI] \r [b4_s3orJ]
                        case a1_s3orI b4_s3orJ of sat_s3orK {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fApplicativeP_$c<$ z_s3orF sat_s3orK;
                        };
              } in  Text.ParserCombinators.ReadP.Get [sat_s3orL];
          Text.ParserCombinators.ReadP.Look a1_s3orM [Occ=OnceL!] ->
              let {
                sat_s3orP [Occ=Once]
                  :: GHC.Base.String -> Text.ParserCombinators.ReadP.P a_a3nFG
                [LclId] =
                    [z_s3orF a1_s3orM] \r [b4_s3orN]
                        case a1_s3orM b4_s3orN of sat_s3orO {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fApplicativeP_$c<$ z_s3orF sat_s3orO;
                        };
              } in  Text.ParserCombinators.ReadP.Look [sat_s3orP];
          Text.ParserCombinators.ReadP.Fail ->
              Text.ParserCombinators.ReadP.Fail [];
          Text.ParserCombinators.ReadP.Result _ [Occ=Dead]
                                              a2_s3orR [Occ=Once] ->
              let {
                sat_s3orS [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nFG
                [LclId] =
                    [z_s3orF a2_s3orR] \u []
                        Text.ParserCombinators.ReadP.$fApplicativeP_$c<$ z_s3orF a2_s3orR;
              } in  Text.ParserCombinators.ReadP.Result [z_s3orF sat_s3orS];
          Text.ParserCombinators.ReadP.Final a1_s3orT [Occ=Once] ->
              let {
                sat_s3orZ [Occ=Once] :: [(a_a3nFG, GHC.Base.String)]
                [LclId] =
                    [z_s3orF a1_s3orT] \u []
                        let {
                          sat_s3orY [Occ=Once]
                            :: (b_a3nFH, GHC.Base.String) -> (a_a3nFG, GHC.Base.String)
                          [LclId] =
                              [z_s3orF] \r [b3_s3orU]
                                  case b3_s3orU of {
                                    (,) _ [Occ=Dead] a3_s3orX [Occ=Once] -> (,) [z_s3orF a3_s3orX];
                                  };
                        } in  GHC.Base.map sat_s3orY a1_s3orT;
              } in  Text.ParserCombinators.ReadP.Final [sat_s3orZ];
        };

Text.ParserCombinators.ReadP.$fFunctorP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Text.ParserCombinators.ReadP.P
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                                       Text.ParserCombinators.ReadP.$fApplicativeP_$c<$];

Text.ParserCombinators.ReadP.run [Occ=LoopBreaker]
  :: forall a.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3os0 ds1_s3os1]
        case ds_s3os0 of {
          Text.ParserCombinators.ReadP.Get f_s3os3 [Occ=Once!] ->
              case ds1_s3os1 of {
                [] -> [] [];
                : c_s3os5 [Occ=Once] s_s3os6 [Occ=Once] ->
                    case f_s3os3 c_s3os5 of sat_s3os7 {
                      __DEFAULT -> Text.ParserCombinators.ReadP.run sat_s3os7 s_s3os6;
                    };
              };
          Text.ParserCombinators.ReadP.Look f_s3os8 [Occ=Once!] ->
              case f_s3os8 ds1_s3os1 of sat_s3os9 {
                __DEFAULT -> Text.ParserCombinators.ReadP.run sat_s3os9 ds1_s3os1;
              };
          Text.ParserCombinators.ReadP.Fail -> [] [];
          Text.ParserCombinators.ReadP.Result x_s3osa [Occ=Once]
                                              p_s3osb [Occ=Once] ->
              let {
                sat_s3osd [Occ=Once] :: [(a_a3nDL, GHC.Base.String)]
                [LclId] =
                    [ds1_s3os1 p_s3osb] \u []
                        Text.ParserCombinators.ReadP.run p_s3osb ds1_s3os1; } in
              let {
                sat_s3osc [Occ=Once] :: (a_a3nDL, GHC.Base.String)
                [LclId] =
                    CCCS (,)! [x_s3osa ds1_s3os1];
              } in  : [sat_s3osc sat_s3osd];
          Text.ParserCombinators.ReadP.Final r_s3ose [Occ=Once] -> r_s3ose;
        };

Text.ParserCombinators.ReadP.$wreadS_to_P [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3osf w1_s3osg]
        let {
          go_s3osh [Occ=LoopBreaker]
            :: [(a_s3ofE, GHC.Base.String)] -> [(b_s3ofG, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w1_s3osg go_s3osh] \r [ds_s3osi]
                  case ds_s3osi of {
                    [] -> [] [];
                    : y_s3osk [Occ=Once!] ys_s3osl [Occ=Once] ->
                        case y_s3osk of {
                          (,) a1_s3osn [Occ=Once] s'_s3oso [Occ=Once] ->
                              let {
                                sat_s3osr [Occ=Once, Dmd=<L,1*U>] :: [(b_s3ofG, GHC.Base.String)]
                                [LclId] =
                                    [go_s3osh ys_s3osl] \s [] go_s3osh ys_s3osl;
                              } in 
                                case w1_s3osg a1_s3osn of sat_s3osp {
                                  __DEFAULT ->
                                      case
                                          Text.ParserCombinators.ReadP.run sat_s3osp s'_s3oso
                                      of
                                      sat_s3osq
                                      { __DEFAULT -> GHC.Base.++ sat_s3osq sat_s3osr;
                                      };
                                };
                        };
                  }; } in
        let {
          sat_s3osx [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3ofG
          [LclId] =
              [w_s3osf go_s3osh] \r [s_s3oss]
                  case w_s3osf s_s3oss of sat_s3ost {
                    __DEFAULT ->
                        case go_s3osh sat_s3ost of wild_s3osu {
                          [] -> Text.ParserCombinators.ReadP.Fail [];
                          : _ [Occ=Dead] _ [Occ=Dead] ->
                              Text.ParserCombinators.ReadP.Final [wild_s3osu];
                        };
                  };
        } in  Unit# [sat_s3osx];

Text.ParserCombinators.ReadP.readS_to_P1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_s3osy w1_s3osz]
        case
            Text.ParserCombinators.ReadP.$wreadS_to_P w_s3osy w1_s3osz
        of
        { Unit# ww1_s3osB [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_s3osB];
        };

Text.ParserCombinators.ReadP.readS_to_P
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.readS_to_P1 eta_B2 eta_B1;

lvl_r3oqE :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Text/ParserCombinators/ReadP.hs:(134,3)-(157,52)|function <|>"#;

lvl1_r3oqF :: forall a. Text.ParserCombinators.ReadP.P a
[GblId, Str=x] =
    [] \u [] Control.Exception.Base.patError lvl_r3oqE;

Text.ParserCombinators.ReadP.$fAlternativeP_$c<|> [Occ=LoopBreaker]
  :: forall a.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=2, Str=<S,U><L,U>, Unf=OtherCon []] =
    [] \r [ds_s3osC ds1_s3osD]
        let-no-escape {
          fail_s3osE [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
            :: GHC.Prim.Void# -> Text.ParserCombinators.ReadP.P a_a3nLq
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [ds_s3osC ds1_s3osD] \r [void_0E]
                  case ds1_s3osD of wild_s3osG {
                    __DEFAULT ->
                        case ds_s3osC of wild1_s3osH {
                          __DEFAULT ->
                              case wild_s3osG of wild2_s3osI {
                                __DEFAULT ->
                                    let-no-escape {
                                      fail1_s3osJ [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
                                        :: GHC.Prim.Void# -> Text.ParserCombinators.ReadP.P a_a3nLq
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [wild1_s3osH wild2_s3osI] \r [void_0E]
                                              case wild2_s3osI of wild3_s3osL {
                                                __DEFAULT ->
                                                    case wild1_s3osH of wild4_s3osM {
                                                      __DEFAULT ->
                                                          case wild3_s3osL of {
                                                            Text.ParserCombinators.ReadP.Get _ [Occ=Dead] ->
                                                                lvl1_r3oqF;
                                                            Text.ParserCombinators.ReadP.Look f_s3osP [Occ=OnceL!] ->
                                                                let {
                                                                  sat_s3osS [Occ=Once]
                                                                    :: GHC.Base.String
                                                                       -> Text.ParserCombinators.ReadP.P
                                                                            a_a3nLq
                                                                  [LclId] =
                                                                      [wild4_s3osM
                                                                       f_s3osP] \r [s_s3osQ]
                                                                          let {
                                                                            sat_s3osR [Occ=Once]
                                                                              :: Text.ParserCombinators.ReadP.P
                                                                                   a_a3nLq
                                                                            [LclId] =
                                                                                [f_s3osP
                                                                                 s_s3osQ] \u []
                                                                                    f_s3osP s_s3osQ;
                                                                          } in 
                                                                            Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                                                                wild4_s3osM
                                                                                sat_s3osR;
                                                                } in 
                                                                  Text.ParserCombinators.ReadP.Look [sat_s3osS];
                                                          };
                                                      Text.ParserCombinators.ReadP.Look f_s3osT [Occ=OnceL*!] ->
                                                          case wild3_s3osL of wild5_s3osU {
                                                            Text.ParserCombinators.ReadP.Get _ [Occ=Dead] ->
                                                                let {
                                                                  sat_s3osY [Occ=Once]
                                                                    :: GHC.Base.String
                                                                       -> Text.ParserCombinators.ReadP.P
                                                                            a_a3nLq
                                                                  [LclId] =
                                                                      [f_s3osT
                                                                       wild5_s3osU] \r [s_s3osW]
                                                                          case
                                                                              f_s3osT s_s3osW
                                                                          of
                                                                          sat_s3osX
                                                                          { __DEFAULT ->
                                                                                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                                                                    sat_s3osX
                                                                                    wild5_s3osU;
                                                                          };
                                                                } in 
                                                                  Text.ParserCombinators.ReadP.Look [sat_s3osY];
                                                            Text.ParserCombinators.ReadP.Look g_s3osZ [Occ=OnceL!] ->
                                                                let {
                                                                  sat_s3ot3 [Occ=Once]
                                                                    :: GHC.Base.String
                                                                       -> Text.ParserCombinators.ReadP.P
                                                                            a_a3nLq
                                                                  [LclId] =
                                                                      [f_s3osT g_s3osZ] \r [s_s3ot0]
                                                                          let {
                                                                            sat_s3ot2 [Occ=Once]
                                                                              :: Text.ParserCombinators.ReadP.P
                                                                                   a_a3nLq
                                                                            [LclId] =
                                                                                [g_s3osZ
                                                                                 s_s3ot0] \u []
                                                                                    g_s3osZ s_s3ot0;
                                                                          } in 
                                                                            case
                                                                                f_s3osT s_s3ot0
                                                                            of
                                                                            sat_s3ot1
                                                                            { __DEFAULT ->
                                                                                  Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                                                                      sat_s3ot1
                                                                                      sat_s3ot2;
                                                                            };
                                                                } in 
                                                                  Text.ParserCombinators.ReadP.Look [sat_s3ot3];
                                                          };
                                                    };
                                                Text.ParserCombinators.ReadP.Final r_s3ot4 [Occ=OnceL] ->
                                                    let {
                                                      sat_s3ot8 [Occ=Once]
                                                        :: GHC.Base.String
                                                           -> Text.ParserCombinators.ReadP.P a_a3nLq
                                                      [LclId] =
                                                          [wild1_s3osH r_s3ot4] \r [s_s3ot5]
                                                              let {
                                                                sat_s3ot7 [Occ=Once]
                                                                  :: [(a_a3nLq, GHC.Base.String)]
                                                                [LclId] =
                                                                    [wild1_s3osH
                                                                     r_s3ot4
                                                                     s_s3ot5] \u []
                                                                        case
                                                                            Text.ParserCombinators.ReadP.run
                                                                                wild1_s3osH s_s3ot5
                                                                        of
                                                                        sat_s3ot6
                                                                        { __DEFAULT ->
                                                                              GHC.Base.++
                                                                                  sat_s3ot6 r_s3ot4;
                                                                        };
                                                              } in 
                                                                Text.ParserCombinators.ReadP.Final [sat_s3ot7];
                                                    } in 
                                                      Text.ParserCombinators.ReadP.Look [sat_s3ot8];
                                              };
                                    } in 
                                      case wild1_s3osH of {
                                        __DEFAULT -> fail1_s3osJ GHC.Prim.void#;
                                        Text.ParserCombinators.ReadP.Look f_s3ota [Occ=OnceL!] ->
                                            case wild2_s3osI of {
                                              __DEFAULT -> fail1_s3osJ GHC.Prim.void#;
                                              Text.ParserCombinators.ReadP.Final r_s3otc [Occ=OnceL] ->
                                                  let {
                                                    sat_s3oth [Occ=Once]
                                                      :: GHC.Base.String
                                                         -> Text.ParserCombinators.ReadP.P a_a3nLq
                                                    [LclId] =
                                                        [f_s3ota r_s3otc] \r [s_s3otd]
                                                            let {
                                                              sat_s3otg [Occ=Once]
                                                                :: [(a_a3nLq, GHC.Base.String)]
                                                              [LclId] =
                                                                  [f_s3ota r_s3otc s_s3otd] \u []
                                                                      case
                                                                          f_s3ota s_s3otd
                                                                      of
                                                                      sat_s3ote
                                                                      { __DEFAULT ->
                                                                            case
                                                                                Text.ParserCombinators.ReadP.run
                                                                                    sat_s3ote
                                                                                    s_s3otd
                                                                            of
                                                                            sat_s3otf
                                                                            { __DEFAULT ->
                                                                                  GHC.Base.++
                                                                                      sat_s3otf
                                                                                      r_s3otc;
                                                                            };
                                                                      };
                                                            } in 
                                                              Text.ParserCombinators.ReadP.Final [sat_s3otg];
                                                  } in 
                                                    Text.ParserCombinators.ReadP.Look [sat_s3oth];
                                            };
                                        Text.ParserCombinators.ReadP.Final r_s3oti [Occ=OnceL*] ->
                                            case wild2_s3osI of wild4_s3otj {
                                              Text.ParserCombinators.ReadP.Get _ [Occ=Dead] ->
                                                  let {
                                                    sat_s3oto [Occ=Once]
                                                      :: GHC.Base.String
                                                         -> Text.ParserCombinators.ReadP.P a_a3nLq
                                                    [LclId] =
                                                        [r_s3oti wild4_s3otj] \r [s_s3otl]
                                                            let {
                                                              sat_s3otn [Occ=Once]
                                                                :: [(a_a3nLq, GHC.Base.String)]
                                                              [LclId] =
                                                                  [r_s3oti
                                                                   wild4_s3otj
                                                                   s_s3otl] \u []
                                                                      let {
                                                                        sat_s3otm [Occ=Once,
                                                                                   Dmd=<L,1*U>]
                                                                          :: [(a_a3nLq,
                                                                               GHC.Base.String)]
                                                                        [LclId] =
                                                                            [wild4_s3otj
                                                                             s_s3otl] \s []
                                                                                Text.ParserCombinators.ReadP.run
                                                                                    wild4_s3otj
                                                                                    s_s3otl;
                                                                      } in 
                                                                        GHC.Base.++
                                                                            r_s3oti sat_s3otm;
                                                            } in 
                                                              Text.ParserCombinators.ReadP.Final [sat_s3otn];
                                                  } in 
                                                    Text.ParserCombinators.ReadP.Look [sat_s3oto];
                                              Text.ParserCombinators.ReadP.Look f_s3otp [Occ=OnceL!] ->
                                                  let {
                                                    sat_s3otu [Occ=Once]
                                                      :: GHC.Base.String
                                                         -> Text.ParserCombinators.ReadP.P a_a3nLq
                                                    [LclId] =
                                                        [r_s3oti f_s3otp] \r [s_s3otq]
                                                            let {
                                                              sat_s3ott [Occ=Once]
                                                                :: [(a_a3nLq, GHC.Base.String)]
                                                              [LclId] =
                                                                  [r_s3oti f_s3otp s_s3otq] \u []
                                                                      let {
                                                                        sat_s3ots [Occ=Once,
                                                                                   Dmd=<L,1*U>]
                                                                          :: [(a_a3nLq,
                                                                               GHC.Base.String)]
                                                                        [LclId] =
                                                                            [f_s3otp s_s3otq] \s []
                                                                                case
                                                                                    f_s3otp s_s3otq
                                                                                of
                                                                                sat_s3otr
                                                                                { __DEFAULT ->
                                                                                      Text.ParserCombinators.ReadP.run
                                                                                          sat_s3otr
                                                                                          s_s3otq;
                                                                                };
                                                                      } in 
                                                                        GHC.Base.++
                                                                            r_s3oti sat_s3ots;
                                                            } in 
                                                              Text.ParserCombinators.ReadP.Final [sat_s3ott];
                                                  } in 
                                                    Text.ParserCombinators.ReadP.Look [sat_s3otu];
                                              Text.ParserCombinators.ReadP.Final t_s3otv [Occ=Once] ->
                                                  let {
                                                    sat_s3otw [Occ=Once]
                                                      :: [(a_a3nLq, GHC.Base.String)]
                                                    [LclId] =
                                                        [r_s3oti t_s3otv] \u []
                                                            GHC.Base.++ r_s3oti t_s3otv;
                                                  } in 
                                                    Text.ParserCombinators.ReadP.Final [sat_s3otw];
                                            };
                                      };
                                Text.ParserCombinators.ReadP.Fail -> wild1_s3osH;
                              };
                          Text.ParserCombinators.ReadP.Fail -> wild_s3osG;
                        };
                    Text.ParserCombinators.ReadP.Result x_s3otx [Occ=Once]
                                                        q_s3oty [Occ=Once] ->
                        let {
                          sat_s3otz [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nLq
                          [LclId] =
                              [ds_s3osC q_s3oty] \u []
                                  Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                      ds_s3osC q_s3oty;
                        } in  Text.ParserCombinators.ReadP.Result [x_s3otx sat_s3otz];
                  };
        } in 
          case ds_s3osC of {
            __DEFAULT -> fail_s3osE GHC.Prim.void#;
            Text.ParserCombinators.ReadP.Get f1_s3otB [Occ=OnceL!] ->
                case ds1_s3osD of {
                  __DEFAULT -> fail_s3osE GHC.Prim.void#;
                  Text.ParserCombinators.ReadP.Get f2_s3otD [Occ=OnceL!] ->
                      let {
                        sat_s3otH [Occ=Once]
                          :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P a_a3nLq
                        [LclId] =
                            [f1_s3otB f2_s3otD] \r [c_s3otE]
                                let {
                                  sat_s3otG [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nLq
                                  [LclId] =
                                      [f2_s3otD c_s3otE] \u [] f2_s3otD c_s3otE;
                                } in 
                                  case f1_s3otB c_s3otE of sat_s3otF {
                                    __DEFAULT ->
                                        Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                            sat_s3otF sat_s3otG;
                                  };
                      } in  Text.ParserCombinators.ReadP.Get [sat_s3otH];
                };
            Text.ParserCombinators.ReadP.Result x_s3otI [Occ=Once]
                                                p_s3otJ [Occ=Once] ->
                let {
                  sat_s3otK [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nLq
                  [LclId] =
                      [ds1_s3osD p_s3otJ] \u []
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                              p_s3otJ ds1_s3osD;
                } in  Text.ParserCombinators.ReadP.Result [x_s3otI sat_s3otK];
          };

Text.ParserCombinators.ReadP.$fAlternativeP_$c>>= [Occ=LoopBreaker]
  :: forall a b.
     Text.ParserCombinators.ReadP.P a
     -> (a -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,1*U><L,C(U)>, Unf=OtherCon []] =
    [] \r [ds_s3otL k_s3otM]
        case ds_s3otL of {
          Text.ParserCombinators.ReadP.Get f_s3otO [Occ=OnceL!] ->
              let {
                sat_s3otR [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_a3nML
                [LclId] =
                    [k_s3otM f_s3otO] \r [c_s3otP]
                        case f_s3otO c_s3otP of sat_s3otQ {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                  sat_s3otQ k_s3otM;
                        };
              } in  Text.ParserCombinators.ReadP.Get [sat_s3otR];
          Text.ParserCombinators.ReadP.Look f_s3otS [Occ=OnceL!] ->
              let {
                sat_s3otV [Occ=Once]
                  :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3nML
                [LclId] =
                    [k_s3otM f_s3otS] \r [s_s3otT]
                        case f_s3otS s_s3otT of sat_s3otU {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                  sat_s3otU k_s3otM;
                        };
              } in  Text.ParserCombinators.ReadP.Look [sat_s3otV];
          Text.ParserCombinators.ReadP.Fail ->
              Text.ParserCombinators.ReadP.Fail [];
          Text.ParserCombinators.ReadP.Result x_s3otW [Occ=Once]
                                              p_s3otX [Occ=Once] ->
              let {
                sat_s3otZ [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nML
                [LclId] =
                    [k_s3otM p_s3otX] \u []
                        Text.ParserCombinators.ReadP.$fAlternativeP_$c>>= p_s3otX k_s3otM;
              } in 
                case k_s3otM x_s3otW of sat_s3otY {
                  __DEFAULT ->
                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                          sat_s3otY sat_s3otZ;
                };
          Text.ParserCombinators.ReadP.Final r_s3ou0 [Occ=Once] ->
              let {
                go_s3ou1 [Occ=LoopBreaker]
                  :: [(a_a3nMK, GHC.Base.String)] -> [(b_a3nML, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [k_s3otM go_s3ou1] \r [ds1_s3ou2]
                        case ds1_s3ou2 of {
                          [] -> [] [];
                          : y_s3ou4 [Occ=Once!] ys_s3ou5 [Occ=Once] ->
                              case y_s3ou4 of {
                                (,) x_s3ou7 [Occ=Once] s_s3ou8 [Occ=Once] ->
                                    let {
                                      sat_s3oub [Occ=Once, Dmd=<L,1*U>]
                                        :: [(b_a3nML, GHC.Base.String)]
                                      [LclId] =
                                          [go_s3ou1 ys_s3ou5] \s [] go_s3ou1 ys_s3ou5;
                                    } in 
                                      case k_s3otM x_s3ou7 of sat_s3ou9 {
                                        __DEFAULT ->
                                            case
                                                Text.ParserCombinators.ReadP.run sat_s3ou9 s_s3ou8
                                            of
                                            sat_s3oua
                                            { __DEFAULT -> GHC.Base.++ sat_s3oua sat_s3oub;
                                            };
                                      };
                              };
                        };
              } in 
                case go_s3ou1 r_s3ou0 of wild1_s3ouc {
                  [] -> Text.ParserCombinators.ReadP.Fail [];
                  : _ [Occ=Dead] _ [Occ=Dead] ->
                      Text.ParserCombinators.ReadP.Final [wild1_s3ouc];
                };
        };

Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
  :: forall a b.
     Text.ParserCombinators.ReadP.P (a -> b)
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [m1_s3ouf m2_s3oug]
        let {
          sat_s3oul [Occ=Once]
            :: (a_a3nOe -> b_a3nOf) -> Text.ParserCombinators.ReadP.P b_a3nOf
          [LclId] =
              [m2_s3oug] \r [x1_s3ouh]
                  let {
                    sat_s3ouk [Occ=Once]
                      :: a_a3nOe -> Text.ParserCombinators.ReadP.P b_a3nOf
                    [LclId] =
                        [x1_s3ouh] \r [x2_s3oui]
                            let {
                              sat_s3ouj [Occ=Once] :: b_a3nOf
                              [LclId] =
                                  [x1_s3ouh x2_s3oui] \u [] x1_s3ouh x2_s3oui;
                            } in 
                              Text.ParserCombinators.ReadP.Result [sat_s3ouj
                                                                   Text.ParserCombinators.ReadP.Fail];
                  } in 
                    Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                        m2_s3oug sat_s3ouk;
        } in 
          Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
              m1_s3ouf sat_s3oul;

Text.ParserCombinators.ReadP.$fApplicativeP_$cliftA2
  :: forall a b c.
     (a -> b -> c)
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P c
[GblId, Arity=2, Str=<L,C(U)><L,1*U>, Unf=OtherCon []] =
    [] \r [f1_s3oum x_s3oun]
        let {
          sat_s3ouo [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (b_a3nOq -> c_a3nOr)
          [LclId] =
              [f1_s3oum x_s3oun] \u []
                  Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                      f1_s3oum x_s3oun;
        } in  Text.ParserCombinators.ReadP.$fAlternativeP_$c<*> sat_s3ouo;

Text.ParserCombinators.ReadP.$fAlternativeP1
  :: forall a. Text.ParserCombinators.ReadP.P [a]
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.ParserCombinators.ReadP.Result! [GHC.Types.[]
                                                        Text.ParserCombinators.ReadP.Fail];

Text.ParserCombinators.ReadP.$fAlternativeP_$csome
  :: forall a.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P [a]
[GblId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_s3oup]
        let {
          some_v_s3ouq [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadP.P [a_a3nMc]
          [LclId] =
              [v_s3oup some_v_s3ouq] \u []
                  let {
                    m2_s3our [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_a3nMc]
                    [LclId] =
                        [some_v_s3ouq] \u []
                            Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                some_v_s3ouq Text.ParserCombinators.ReadP.$fAlternativeP1; } in
                  let {
                    sat_s3oux [Occ=Once]
                      :: ([a_a3nMc] -> [a_a3nMc])
                         -> Text.ParserCombinators.ReadP.P [a_a3nMc]
                    [LclId] =
                        [m2_s3our] \r [x1_s3out]
                            let {
                              sat_s3ouw [Occ=Once]
                                :: [a_a3nMc] -> Text.ParserCombinators.ReadP.P [a_a3nMc]
                              [LclId] =
                                  [x1_s3out] \r [x2_s3ouu]
                                      let {
                                        sat_s3ouv [Occ=Once] :: [a_a3nMc]
                                        [LclId] =
                                            [x1_s3out x2_s3ouu] \u [] x1_s3out x2_s3ouu;
                                      } in 
                                        Text.ParserCombinators.ReadP.Result [sat_s3ouv
                                                                             Text.ParserCombinators.ReadP.Fail];
                            } in 
                              Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                  m2_s3our sat_s3ouw;
                  } in 
                    case
                        Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                            GHC.Types.: v_s3oup
                    of
                    sat_s3ous
                    { __DEFAULT ->
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                              sat_s3ous sat_s3oux;
                    };
        } in  some_v_s3ouq;

Text.ParserCombinators.ReadP.$fApplicativeP_$c<*
  :: forall a b.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=1, Str=<L,1*U>, Unf=OtherCon []] =
    [] \r [x_s3ouy]
        let {
          sat_s3ouz [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (b_a3nOM -> a_a3nOL)
          [LclId] =
              [x_s3ouy] \u []
                  Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                      GHC.Base.const x_s3ouy;
        } in  Text.ParserCombinators.ReadP.$fAlternativeP_$c<*> sat_s3ouz;

Text.ParserCombinators.ReadP.$fApplicativeP_$c*>
  :: forall a b.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [a1_s3ouA a2_s3ouB]
        case
            Text.ParserCombinators.ReadP.$fApplicativeP_$c<$
                GHC.Base.breakpoint a1_s3ouA
        of
        sat_s3ouC
        { __DEFAULT ->
              Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
                  sat_s3ouC a2_s3ouB;
        };

Text.ParserCombinators.ReadP.$fAlternativeP_$cmany
  :: forall a.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P [a]
[GblId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_s3ouD]
        let {
          many_v_s3ouE [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadP.P [a_a3nMk]
          [LclId] =
              [v_s3ouD many_v_s3ouE] \u []
                  case
                      Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                          GHC.Types.: v_s3ouD
                  of
                  sat_s3ouF
                  { __DEFAULT ->
                        case
                            Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
                                sat_s3ouF many_v_s3ouE
                        of
                        sat_s3ouG
                        { __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                  sat_s3ouG Text.ParserCombinators.ReadP.$fAlternativeP1;
                        };
                  };
        } in  many_v_s3ouE;

Text.ParserCombinators.ReadP.$fMonadP_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [eta_s3ouH eta1_s3ouI]
        let {
          sat_s3ouK [Occ=Once]
            :: a_a3nNd -> Text.ParserCombinators.ReadP.P b_a3nNe
          [LclId] =
              [eta1_s3ouI] \r [ds_s3ouJ] eta1_s3ouI;
        } in 
          Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
              eta_s3ouH sat_s3ouK;

Text.ParserCombinators.ReadP.$fApplicativeP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Text.ParserCombinators.ReadP.$fFunctorP
                                           Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                                           Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
                                           Text.ParserCombinators.ReadP.$fApplicativeP_$cliftA2
                                           Text.ParserCombinators.ReadP.$fApplicativeP_$c*>
                                           Text.ParserCombinators.ReadP.$fApplicativeP_$c<*];

Text.ParserCombinators.ReadP.$fMonadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Text.ParserCombinators.ReadP.$fApplicativeP
                                     Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                     Text.ParserCombinators.ReadP.$fMonadP_$c>>
                                     Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                                     Text.ParserCombinators.ReadP.$fMonadFailP_$cfail];

Text.ParserCombinators.ReadP.$fAlternativeP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Text.ParserCombinators.ReadP.$fApplicativeP
                                           Text.ParserCombinators.ReadP.Fail
                                           Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                           Text.ParserCombinators.ReadP.$fAlternativeP_$csome
                                           Text.ParserCombinators.ReadP.$fAlternativeP_$cmany];

Text.ParserCombinators.ReadP.readP_to_S
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadS a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [ds_s3ouL]
        let {
          sat_s3ouM [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nDT
          [LclId] =
              [ds_s3ouL] \u []
                  ds_s3ouL Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s3ouM;

Text.ParserCombinators.ReadP.$fMonadFailP [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fail.C:MonadFail! [Text.ParserCombinators.ReadP.$fMonadP
                                                   Text.ParserCombinators.ReadP.$fMonadFailP_$cfail];

Text.ParserCombinators.ReadP.$fMonadPlusP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [Text.ParserCombinators.ReadP.$fAlternativeP
                                         Text.ParserCombinators.ReadP.$fMonadP
                                         Text.ParserCombinators.ReadP.Fail
                                         Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>];

Text.ParserCombinators.ReadP.get
  :: Text.ParserCombinators.ReadP.ReadP GHC.Types.Char
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m1, Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Get [eta_B1];

Text.ParserCombinators.ReadP.look
  :: Text.ParserCombinators.ReadP.ReadP GHC.Base.String
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Look [eta_B1];

Text.ParserCombinators.ReadP.$fAlternativeReadP4
  :: forall a b.
     (a -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s3ouN] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadP.pfail
  :: forall a. Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.$fAlternativeReadP4 eta_B1;

Text.ParserCombinators.ReadP.$fAlternativeReadP3
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3ouO ds1_s3ouP k_s3ouQ]
        let {
          sat_s3ouS [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
          [LclId] =
              [ds1_s3ouP k_s3ouQ] \u [] ds1_s3ouP k_s3ouQ;
        } in 
          case ds_s3ouO k_s3ouQ of sat_s3ouR {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3ouR sat_s3ouS;
          };

Text.ParserCombinators.ReadP.+++
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.$fAlternativeReadP3
            eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.choice [Occ=LoopBreaker]
  :: forall a.
     [Text.ParserCombinators.ReadP.ReadP a]
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s3ouT]
        case ds_s3ouT of {
          [] -> Text.ParserCombinators.ReadP.$fAlternativeReadP4;
          : p_s3ouV [Occ=OnceL*] ds1_s3ouW [Occ=Once!] ->
              case ds1_s3ouW of wild1_s3ouX {
                [] -> p_s3ouV;
                : _ [Occ=Dead] _ [Occ=Dead] ->
                    let {
                      ds2_s3ov0 [Occ=OnceL, Dmd=<L,C(U)>]
                        :: Text.ParserCombinators.ReadP.ReadP a_a3nzc
                      [LclId] =
                          [wild1_s3ouX] \u []
                              Text.ParserCombinators.ReadP.choice wild1_s3ouX; } in
                    let {
                      sat_s3ov4 [Occ=Once]
                        :: forall b.
                           (a_a3nzc -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b
                      [LclId] =
                          [p_s3ouV ds2_s3ov0] \r [k_s3ov1]
                              let {
                                sat_s3ov3 [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
                                [LclId] =
                                    [ds2_s3ov0 k_s3ov1] \u [] ds2_s3ov0 k_s3ov1;
                              } in 
                                case p_s3ouV k_s3ov1 of sat_s3ov2 {
                                  __DEFAULT ->
                                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                          sat_s3ov2 sat_s3ov3;
                                };
                    } in  sat_s3ov4;
              };
        };

lvl2_r3oqG :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "do not use readS_to_P in gather!"#;

lvl3_r3oqH :: forall b. Text.ParserCombinators.ReadP.P b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_r3oqG of sat_s3ov5 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s3ov5;
        };

Text.ParserCombinators.ReadP.gather_gath [Occ=LoopBreaker]
  :: forall b.
     (GHC.Base.String -> GHC.Base.String)
     -> Text.ParserCombinators.ReadP.P
          (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,C(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [l_s3ov6 ds_s3ov7]
        case ds_s3ov7 of {
          Text.ParserCombinators.ReadP.Get f_s3ov9 [Occ=OnceL!] ->
              let {
                sat_s3ovf [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_a3nv3
                [LclId] =
                    [l_s3ov6 f_s3ov9] \r [c_s3ova]
                        case f_s3ov9 c_s3ova of sat_s3ove {
                          __DEFAULT ->
                              let {
                                sat_s3ovd [Occ=Once] :: GHC.Base.String -> GHC.Base.String
                                [LclId] =
                                    [l_s3ov6 c_s3ova] \r [x_s3ovb]
                                        let {
                                          sat_s3ovc [Occ=Once] :: GHC.Base.String
                                          [LclId] =
                                              CCCS :! [c_s3ova x_s3ovb];
                                        } in  l_s3ov6 sat_s3ovc;
                              } in  Text.ParserCombinators.ReadP.gather_gath sat_s3ovd sat_s3ove;
                        };
              } in  Text.ParserCombinators.ReadP.Get [sat_s3ovf];
          Text.ParserCombinators.ReadP.Look f_s3ovg [Occ=OnceL!] ->
              let {
                sat_s3ovj [Occ=Once]
                  :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3nv3
                [LclId] =
                    [l_s3ov6 f_s3ovg] \r [s_s3ovh]
                        case f_s3ovg s_s3ovh of sat_s3ovi {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.gather_gath l_s3ov6 sat_s3ovi;
                        };
              } in  Text.ParserCombinators.ReadP.Look [sat_s3ovj];
          Text.ParserCombinators.ReadP.Fail ->
              Text.ParserCombinators.ReadP.Fail [];
          Text.ParserCombinators.ReadP.Result k_s3ovk [Occ=Once!]
                                              p_s3ovl [Occ=Once] ->
              let {
                sat_s3ovo [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nv3
                [LclId] =
                    [l_s3ov6 p_s3ovl] \u []
                        Text.ParserCombinators.ReadP.gather_gath l_s3ov6 p_s3ovl; } in
              let {
                sat_s3ovm [Occ=Once] :: GHC.Base.String
                [LclId] =
                    [l_s3ov6] \u [] l_s3ov6 GHC.Types.[];
              } in 
                case k_s3ovk sat_s3ovm of sat_s3ovn {
                  __DEFAULT ->
                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                          sat_s3ovn sat_s3ovo;
                };
          Text.ParserCombinators.ReadP.Final _ [Occ=Dead] -> lvl3_r3oqH;
        };

Text.ParserCombinators.ReadP.gather1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ((GHC.Base.String, a) -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),1*C1(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [ds_s3ovq eta_s3ovr]
        let {
          sat_s3ovw [Occ=Once]
            :: a_a3nuK
               -> Text.ParserCombinators.ReadP.P
                    (GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3ngn)
          [LclId] =
              [eta_s3ovr] \r [a1_s3ovs]
                  let {
                    sat_s3ovv [Occ=Once]
                      :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [eta_s3ovr a1_s3ovs] \r [s_s3ovt]
                            let {
                              sat_s3ovu [Occ=Once] :: (GHC.Base.String, a_a3nuK)
                              [LclId] =
                                  CCCS (,)! [s_s3ovt a1_s3ovs];
                            } in  eta_s3ovr sat_s3ovu;
                  } in 
                    Text.ParserCombinators.ReadP.Result [sat_s3ovv
                                                         Text.ParserCombinators.ReadP.Fail];
        } in 
          case ds_s3ovq sat_s3ovw of sat_s3ovx {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.gather_gath GHC.Base.id sat_s3ovx;
          };

Text.ParserCombinators.ReadP.gather
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (GHC.Base.String, a)
[GblId, Arity=2, Str=<C(S),1*C1(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.gather1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Text.ParserCombinators.ReadP.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$trModule4];

Text.ParserCombinators.ReadP.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Text.ParserCombinators.ReadP"#;

Text.ParserCombinators.ReadP.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$trModule2];

Text.ParserCombinators.ReadP.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Text.ParserCombinators.ReadP.$trModule3
                                     Text.ParserCombinators.ReadP.$trModule1];

$krep_r3oqI :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcChar
                                              GHC.Types.[]];

$krep1_r3oqJ :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r3oqI GHC.Types.[]];

$krep2_r3oqK :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc[]
                                              $krep1_r3oqJ];

$krep3_r3oqL :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep4_r3oqM :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_r3oqK GHC.Types.[]];

$krep5_r3oqN :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r3oqL $krep4_r3oqM];

$krep6_r3oqO :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Tuple.$tc(,)
                                              $krep5_r3oqN];

$krep7_r3oqP :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep6_r3oqO GHC.Types.[]];

$krep8_r3oqQ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc[]
                                              $krep7_r3oqP];

Text.ParserCombinators.ReadP.$tcP2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "P"#;

Text.ParserCombinators.ReadP.$tcP1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tcP2];

Text.ParserCombinators.ReadP.$tcP :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4287589432649596960##
                                    9029773818181158220##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tcP1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep9_r3oqR :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r3oqL GHC.Types.[]];

Text.ParserCombinators.ReadP.$tc'Fail1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Text.ParserCombinators.ReadP.$tcP
                                              $krep9_r3oqR];

Text.ParserCombinators.ReadP.$tc'Fail3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Fail"#;

Text.ParserCombinators.ReadP.$tc'Fail2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Fail3];

Text.ParserCombinators.ReadP.$tc'Fail :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16564457091671581868##
                                    4540703186775139959##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Fail2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Fail1];

$krep10_r3oqS :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [Text.ParserCombinators.ReadP.$tc'Fail1
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Result1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r3oqL $krep10_r3oqS];

Text.ParserCombinators.ReadP.$tc'Result3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Result"#;

Text.ParserCombinators.ReadP.$tc'Result2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Result3];

Text.ParserCombinators.ReadP.$tc'Result :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14629176799732153257##
                                    2029199220309899277##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Result2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Result1];

Text.ParserCombinators.ReadP.$tc'Final1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r3oqQ
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Final3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Final"#;

Text.ParserCombinators.ReadP.$tc'Final2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Final3];

Text.ParserCombinators.ReadP.$tc'Final :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9825883373667767852##
                                    1277540149077833820##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Final2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Final1];

$krep11_r3oqT :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r3oqK
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Look1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r3oqT
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Look3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Look"#;

Text.ParserCombinators.ReadP.$tc'Look2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Look3];

Text.ParserCombinators.ReadP.$tc'Look :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11302519862508684236##
                                    969530656846011597##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Look2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Look1];

$krep12_r3oqU :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r3oqI
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Get1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep12_r3oqU
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Get3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Get"#;

Text.ParserCombinators.ReadP.$tc'Get2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Get3];

Text.ParserCombinators.ReadP.$tc'Get :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10806119809527641225##
                                    14618661019746688366##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Get2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Get1];

Text.ParserCombinators.ReadP.$tcReadP2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ReadP"#;

Text.ParserCombinators.ReadP.$tcReadP1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tcReadP2];

Text.ParserCombinators.ReadP.$tcReadP :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15640243629783811470##
                                    8988027559298507146##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tcReadP1
                                    0#
                                    GHC.Types.krep$*Arr*];

Text.ParserCombinators.ReadP.$fApplicativeReadP4
  :: forall b a.
     Text.ParserCombinators.ReadP.ReadP (a -> b)
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [m1_s3ovy m2_s3ovz k_s3ovA]
        let {
          sat_s3ovF [Occ=Once]
            :: (a_a3nK0 -> b_a3nK1) -> Text.ParserCombinators.ReadP.P b1_a3nIU
          [LclId] =
              [m2_s3ovz k_s3ovA] \r [a1_s3ovB]
                  let {
                    sat_s3ovE [Occ=Once]
                      :: a_a3nK0 -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [k_s3ovA a1_s3ovB] \r [a2_s3ovC]
                            let {
                              sat_s3ovD [Occ=Once] :: b_a3nK1
                              [LclId] =
                                  [a1_s3ovB a2_s3ovC] \u [] a1_s3ovB a2_s3ovC;
                            } in  k_s3ovA sat_s3ovD;
                  } in  m2_s3ovz sat_s3ovE;
        } in  m1_s3ovy sat_s3ovF;

Text.ParserCombinators.ReadP.$fApplicativeReadP2
  :: forall a b.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [a1_s3ovG a2_s3ovH eta_s3ovI]
        let {
          lvl4_s3ovJ [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [a2_s3ovH eta_s3ovI] \u []
                  let {
                    sat_s3ovL [Occ=Once]
                      :: b_a3nKt -> Text.ParserCombinators.ReadP.P b1_a3ngn
                    [LclId] =
                        [eta_s3ovI] \r [a4_s3ovK] eta_s3ovI a4_s3ovK;
                  } in  a2_s3ovH sat_s3ovL; } in
        let {
          sat_s3ovN [Occ=Once]
            :: a_a3nKs -> Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [lvl4_s3ovJ] \r [x_s3ovM] lvl4_s3ovJ;
        } in  a1_s3ovG sat_s3ovN;

Text.ParserCombinators.ReadP.$fApplicativeReadP3
  :: forall a b c.
     (a -> b -> c)
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (c -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C(U))><C(S),1*C1(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [f1_s3ovO x_s3ovP eta_s3ovQ eta1_s3ovR]
        let {
          sat_s3ovX [Occ=Once]
            :: a_a3nKg -> Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [f1_s3ovO eta_s3ovQ eta1_s3ovR] \r [x1_s3ovS]
                  let {
                    a1_s3ovT [Occ=OnceL!, Dmd=<L,C(U)>] :: b_a3nKh -> c_a3nKi
                    [LclId] =
                        [f1_s3ovO x1_s3ovS] \u [] f1_s3ovO x1_s3ovS; } in
                  let {
                    sat_s3ovW [Occ=Once]
                      :: b_a3nKh -> Text.ParserCombinators.ReadP.P b1_a3ngn
                    [LclId] =
                        [eta1_s3ovR a1_s3ovT] \r [a2_s3ovU]
                            let {
                              sat_s3ovV [Occ=Once] :: c_a3nKi
                              [LclId] =
                                  [a1_s3ovT a2_s3ovU] \u [] a1_s3ovT a2_s3ovU;
                            } in  eta1_s3ovR sat_s3ovV;
                  } in  eta_s3ovQ sat_s3ovW;
        } in  x_s3ovP sat_s3ovX;

Text.ParserCombinators.ReadP.$fApplicativeReadP1
  :: forall b a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (a -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [x_s3ovY eta_s3ovZ eta1_s3ow0]
        let {
          sat_s3ow5 [Occ=Once]
            :: a_a3nKC -> Text.ParserCombinators.ReadP.P b1_X3nkp
          [LclId] =
              [eta_s3ovZ eta1_s3ow0] \r [x1_s3ow1]
                  let {
                    lvl4_s3ow2 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_X3nkp
                    [LclId] =
                        [eta1_s3ow0 x1_s3ow1] \u [] eta1_s3ow0 x1_s3ow1; } in
                  let {
                    sat_s3ow4 [Occ=Once]
                      :: b_a3nKD -> Text.ParserCombinators.ReadP.P b1_X3nkp
                    [LclId] =
                        [lvl4_s3ow2] \r [a1_s3ow3] lvl4_s3ow2;
                  } in  eta_s3ovZ sat_s3ow4;
        } in  x_s3ovY sat_s3ow5;

$c>>_r3oqV
  :: forall a b.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [eta_s3ow6 eta1_s3ow7 k_s3ow8]
        let {
          lvl4_s3ow9 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
          [LclId] =
              [eta1_s3ow7 k_s3ow8] \u [] eta1_s3ow7 k_s3ow8; } in
        let {
          sat_s3owb [Occ=Once]
            :: a_a3nJi -> Text.ParserCombinators.ReadP.P b1_a3nIU
          [LclId] =
              [lvl4_s3ow9] \r [a1_s3owa] lvl4_s3ow9;
        } in  eta_s3ow6 sat_s3owb;

Text.ParserCombinators.ReadP.$fMonadReadP_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] $c>>_r3oqV eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$fApplicativeReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Text.ParserCombinators.ReadP.$fFunctorReadP
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP5
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP4
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP3
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP2
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP1];

Text.ParserCombinators.ReadP.$fMonadReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Text.ParserCombinators.ReadP.$fApplicativeReadP
                                     Text.ParserCombinators.ReadP.$fMonadReadP1
                                     Text.ParserCombinators.ReadP.$fMonadReadP_$c>>
                                     Text.ParserCombinators.ReadP.$fApplicativeReadP5
                                     Text.ParserCombinators.ReadP.$fMonadFailReadP1];

Text.ParserCombinators.ReadP.between1
  :: forall open close a.
     Text.ParserCombinators.ReadP.ReadP open
     -> Text.ParserCombinators.ReadP.ReadP close
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,1*C1(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [open1_s3owc close1_s3owd p_s3owe k_s3owf]
        let {
          lvl4_s3owg [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3nIU
          [LclId] =
              [close1_s3owd p_s3owe k_s3owf] \u []
                  let {
                    sat_s3owl [Occ=Once]
                      :: a_a3nui -> Text.ParserCombinators.ReadP.P b_a3nIU
                    [LclId] =
                        [close1_s3owd k_s3owf] \r [a1_s3owh]
                            let {
                              lvl5_s3owi [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3nIU
                              [LclId] =
                                  [k_s3owf a1_s3owh] \u [] k_s3owf a1_s3owh; } in
                            let {
                              sat_s3owk [Occ=Once]
                                :: close_a3nuh -> Text.ParserCombinators.ReadP.P b_a3nIU
                              [LclId] =
                                  [lvl5_s3owi] \r [a2_s3owj] lvl5_s3owi;
                            } in  close1_s3owd sat_s3owk;
                  } in  p_s3owe sat_s3owl; } in
        let {
          sat_s3own [Occ=Once]
            :: open_a3nug -> Text.ParserCombinators.ReadP.P b_a3nIU
          [LclId] =
              [lvl4_s3owg] \r [a1_s3owm] lvl4_s3owg;
        } in  open1_s3owc sat_s3own;

Text.ParserCombinators.ReadP.between
  :: forall open close a.
     Text.ParserCombinators.ReadP.ReadP open
     -> Text.ParserCombinators.ReadP.ReadP close
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,1*C1(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.between1 eta_B4 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$wcount [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Prim.Int#
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,U><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [ww_s3owo w_s3owp w1_s3owq]
        case <# [0# ww_s3owo] of {
          __DEFAULT -> w1_s3owq GHC.Types.[];
          1# ->
              let {
                $wxs_s3ows [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                  :: GHC.Prim.Int#
                     -> forall b1.
                        ([a_s3ogB] -> Text.ParserCombinators.ReadP.P b1)
                        -> Text.ParserCombinators.ReadP.P b1
                [LclId, Arity=2, Str=<S,1*U><L,C(U)>, Unf=OtherCon []] =
                    sat-only [w_s3owp $wxs_s3ows] \r [ww1_s3owt w2_s3owu]
                        case ww1_s3owt of ds1_s3owv {
                          __DEFAULT ->
                              case -# [ds1_s3owv 1#] of r_s3oww {
                                __DEFAULT ->
                                    let {
                                      sat_s3owB [Occ=Once]
                                        :: a_s3ogB -> Text.ParserCombinators.ReadP.P b1_s3ogu
                                      [LclId] =
                                          [$wxs_s3ows w2_s3owu r_s3oww] \r [a1_s3owx]
                                              let {
                                                sat_s3owA [Occ=Once]
                                                  :: [a_s3ogB]
                                                     -> Text.ParserCombinators.ReadP.P b1_s3ogu
                                                [LclId] =
                                                    [w2_s3owu a1_s3owx] \r [a2_s3owy]
                                                        let {
                                                          sat_s3owz [Occ=Once] :: [a_s3ogB]
                                                          [LclId] =
                                                              CCCS :! [a1_s3owx a2_s3owy];
                                                        } in  w2_s3owu sat_s3owz;
                                              } in  $wxs_s3ows r_s3oww sat_s3owA;
                                    } in  w_s3owp sat_s3owB;
                              };
                          1# ->
                              let {
                                sat_s3owE [Occ=Once]
                                  :: a_s3ogB -> Text.ParserCombinators.ReadP.P b1_s3ogu
                                [LclId] =
                                    [w2_s3owu] \r [a1_s3owC]
                                        let {
                                          sat_s3owD [Occ=Once] :: [a_s3ogB]
                                          [LclId] =
                                              CCCS :! [a1_s3owC GHC.Types.[]];
                                        } in  w2_s3owu sat_s3owD;
                              } in  w_s3owp sat_s3owE;
                        };
              } in  $wxs_s3ows ww_s3owo w1_s3owq;
        };

Text.ParserCombinators.ReadP.count1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3owF w1_s3owG w2_s3owH]
        case w_s3owF of {
          GHC.Types.I# ww1_s3owJ [Occ=Once] ->
              Text.ParserCombinators.ReadP.$wcount ww1_s3owJ w1_s3owG w2_s3owH;
        };

Text.ParserCombinators.ReadP.count
  :: forall a.
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.count1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.option1
  :: forall a.
     a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
    [] \r [x_s3owK p_s3owL eta_s3owM]
        let {
          sat_s3owO [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [x_s3owK eta_s3owM] \u [] eta_s3owM x_s3owK;
        } in 
          case p_s3owL eta_s3owM of sat_s3owN {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3owN sat_s3owO;
          };

Text.ParserCombinators.ReadP.option
  :: forall a.
     a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.option1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.optional1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),1*C1(U)><L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [p_s3owP eta_s3owQ]
        let {
          lvl4_s3owR :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [eta_s3owQ] \u [] eta_s3owQ GHC.Tuple.(); } in
        let {
          sat_s3owT [Occ=Once]
            :: a_a3nw0 -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [lvl4_s3owR] \r [a1_s3owS] lvl4_s3owR;
        } in 
          case p_s3owP sat_s3owT of sat_s3owU {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3owU lvl4_s3owR;
          };

Text.ParserCombinators.ReadP.optional
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP ()
[GblId, Arity=2, Str=<C(S),1*C1(U)><L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.optional1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.endBy3 [Occ=LoopBreaker]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,C(U)><C(S),C(U)>, Unf=OtherCon []] =
    [] \r [p_s3owV eta_s3owW]
        let {
          sat_s3ox3 [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [p_s3owV eta_s3owW] \u []
                  let {
                    sat_s3ox2 [Occ=Once]
                      :: a_a3nwo -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [p_s3owV eta_s3owW] \r [a1_s3owY]
                            let {
                              sat_s3ox1 [Occ=Once]
                                :: [a_a3nwo] -> Text.ParserCombinators.ReadP.P b_a3ngn
                              [LclId] =
                                  [eta_s3owW a1_s3owY] \r [a2_s3owZ]
                                      let {
                                        sat_s3ox0 [Occ=Once] :: [a_a3nwo]
                                        [LclId] =
                                            CCCS :! [a1_s3owY a2_s3owZ];
                                      } in  eta_s3owW sat_s3ox0;
                            } in  Text.ParserCombinators.ReadP.endBy3 p_s3owV sat_s3ox1;
                  } in  p_s3owV sat_s3ox2;
        } in 
          case eta_s3owW GHC.Types.[] of sat_s3owX {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3owX sat_s3ox3;
          };

Text.ParserCombinators.ReadP.many
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=2, Str=<L,C(U)><C(S),C(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.endBy3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.many2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),C(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [p_s3ox4 eta_s3ox5]
        let {
          sat_s3oxa [Occ=Once]
            :: a_a3nwe -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [p_s3ox4 eta_s3ox5] \r [a1_s3ox6]
                  let {
                    sat_s3ox9 [Occ=Once]
                      :: [a_a3nwe] -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [eta_s3ox5 a1_s3ox6] \r [a2_s3ox7]
                            let {
                              sat_s3ox8 [Occ=Once] :: [a_a3nwe]
                              [LclId] =
                                  CCCS :! [a1_s3ox6 a2_s3ox7];
                            } in  eta_s3ox5 sat_s3ox8;
                  } in  Text.ParserCombinators.ReadP.endBy3 p_s3ox4 sat_s3ox9;
        } in  p_s3ox4 sat_s3oxa;

Text.ParserCombinators.ReadP.many1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=2, Str=<C(S),C(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.many2 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.endBy4
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3oxb sep1_s3oxc eta_s3oxd]
        let {
          p1_s3oxe [Occ=OnceL, Dmd=<L,C(U)>]
            :: forall b1.
               (a_a3nwx -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              [p_s3oxb sep1_s3oxc] \r [k_s3oxf]
                  let {
                    sat_s3oxk [Occ=Once]
                      :: a_a3nwx -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [sep1_s3oxc k_s3oxf] \r [a1_s3oxg]
                            let {
                              lvl4_s3oxh [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3oxf a1_s3oxg] \u [] k_s3oxf a1_s3oxg; } in
                            let {
                              sat_s3oxj [Occ=Once]
                                :: sep_a3nwy -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [lvl4_s3oxh] \r [a2_s3oxi] lvl4_s3oxh;
                            } in  sep1_s3oxc sat_s3oxj;
                  } in  p_s3oxb sat_s3oxk; } in
        let {
          sat_s3oxs [Occ=Once]
            :: a_a3nwx -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [sep1_s3oxc eta_s3oxd p1_s3oxe] \r [a1_s3oxl]
                  let {
                    lvl4_s3oxm [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [eta_s3oxd p1_s3oxe a1_s3oxl] \u []
                            let {
                              sat_s3oxp [Occ=Once]
                                :: [a_a3nwx] -> Text.ParserCombinators.ReadP.P b_a3ngn
                              [LclId] =
                                  [eta_s3oxd a1_s3oxl] \r [a2_s3oxn]
                                      let {
                                        sat_s3oxo [Occ=Once] :: [a_a3nwx]
                                        [LclId] =
                                            CCCS :! [a1_s3oxl a2_s3oxn];
                                      } in  eta_s3oxd sat_s3oxo;
                            } in  Text.ParserCombinators.ReadP.endBy3 p1_s3oxe sat_s3oxp; } in
                  let {
                    sat_s3oxr [Occ=Once]
                      :: sep_a3nwy -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [lvl4_s3oxm] \r [a2_s3oxq] lvl4_s3oxm;
                  } in  sep1_s3oxc sat_s3oxr;
        } in  p_s3oxb sat_s3oxs;

Text.ParserCombinators.ReadP.endBy1
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.endBy4 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.skipMany2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,C(U)><C(S),1*C1(U)>, Unf=OtherCon []] =
    [] \r [p_s3oxt eta_s3oxu]
        case eta_s3oxu GHC.Tuple.() of lvl4_s3oxv [Dmd=<S,U>] {
          __DEFAULT ->
              let {
                sat_s3oxx [Occ=Once]
                  :: [a_a3nwN] -> Text.ParserCombinators.ReadP.P b_a3ngn
                [LclId] =
                    [lvl4_s3oxv] \r [a1_s3oxw] lvl4_s3oxv;
              } in  Text.ParserCombinators.ReadP.endBy3 p_s3oxt sat_s3oxx;
        };

Text.ParserCombinators.ReadP.skipMany
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP ()
[GblId, Arity=2, Str=<L,C(U)><C(S),1*C1(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.skipMany2 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.skipMany3
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),C(U)><L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [p_s3oxy eta_s3oxz]
        let {
          lvl4_s3oxA [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [p_s3oxy eta_s3oxz] \u []
                  case eta_s3oxz GHC.Tuple.() of lvl5_s3oxB [Dmd=<S,U>] {
                    __DEFAULT ->
                        let {
                          sat_s3oxD [Occ=Once]
                            :: [a_a3nwY] -> Text.ParserCombinators.ReadP.P b_a3ngn
                          [LclId] =
                              [lvl5_s3oxB] \r [a1_s3oxC] lvl5_s3oxB;
                        } in  Text.ParserCombinators.ReadP.endBy3 p_s3oxy sat_s3oxD;
                  }; } in
        let {
          sat_s3oxF [Occ=Once]
            :: a_a3nwY -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [lvl4_s3oxA] \r [a1_s3oxE] lvl4_s3oxA;
        } in  p_s3oxy sat_s3oxF;

Text.ParserCombinators.ReadP.skipMany1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP ()
[GblId, Arity=2, Str=<C(S),C(U)><L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.skipMany3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.sepBy3
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3oxG sep1_s3oxH eta_s3oxI]
        let {
          m2_s3oxJ [Occ=OnceL, Dmd=<L,C(U)>]
            :: forall b1.
               (a_a3nx6 -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              [p_s3oxG sep1_s3oxH] \r [k_s3oxK]
                  let {
                    lvl4_s3oxL [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [p_s3oxG k_s3oxK] \u [] p_s3oxG k_s3oxK; } in
                  let {
                    sat_s3oxN [Occ=Once]
                      :: sep_a3nx7 -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [lvl4_s3oxL] \r [a1_s3oxM] lvl4_s3oxL;
                  } in  sep1_s3oxH sat_s3oxN; } in
        let {
          sat_s3oxS [Occ=Once]
            :: a_a3nx6 -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [eta_s3oxI m2_s3oxJ] \r [a1_s3oxO]
                  let {
                    sat_s3oxR [Occ=Once]
                      :: [a_a3nx6] -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [eta_s3oxI a1_s3oxO] \r [a2_s3oxP]
                            let {
                              sat_s3oxQ [Occ=Once] :: [a_a3nx6]
                              [LclId] =
                                  CCCS :! [a1_s3oxO a2_s3oxP];
                            } in  eta_s3oxI sat_s3oxQ;
                  } in  Text.ParserCombinators.ReadP.endBy3 m2_s3oxJ sat_s3oxR;
        } in  p_s3oxG sat_s3oxS;

Text.ParserCombinators.ReadP.sepBy1
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.sepBy3 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.endBy2
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,C(U)><L,C(U)><C(S),C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3oxT sep1_s3oxU eta_s3oxV]
        let {
          sat_s3oy2 [Occ=Once] :: Text.ParserCombinators.ReadP.ReadP a_a3nxl
          [LclId] =
              [p_s3oxT sep1_s3oxU] \r [k_s3oxW]
                  let {
                    sat_s3oy1 [Occ=Once]
                      :: a_a3nxl -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [sep1_s3oxU k_s3oxW] \r [a1_s3oxX]
                            let {
                              lvl4_s3oxY [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3oxW a1_s3oxX] \u [] k_s3oxW a1_s3oxX; } in
                            let {
                              sat_s3oy0 [Occ=Once]
                                :: sep_a3nxm -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [lvl4_s3oxY] \r [a2_s3oxZ] lvl4_s3oxY;
                            } in  sep1_s3oxU sat_s3oy0;
                  } in  p_s3oxT sat_s3oy1;
        } in  Text.ParserCombinators.ReadP.endBy3 sat_s3oy2 eta_s3oxV;

Text.ParserCombinators.ReadP.endBy
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Str=<L,C(U)><L,C(U)><C(S),C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.endBy2 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.sepBy2
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3oy3 sep1_s3oy4 eta_s3oy5]
        let {
          sat_s3oy7 [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [eta_s3oy5] \u [] eta_s3oy5 GHC.Types.[];
        } in 
          case
              Text.ParserCombinators.ReadP.sepBy3 p_s3oy3 sep1_s3oy4 eta_s3oy5
          of
          sat_s3oy6
          { __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3oy6 sat_s3oy7;
          };

Text.ParserCombinators.ReadP.sepBy
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.sepBy2 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$fMonadFailReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fail.C:MonadFail! [Text.ParserCombinators.ReadP.$fMonadReadP
                                                   Text.ParserCombinators.ReadP.$fMonadFailReadP1];

Text.ParserCombinators.ReadP.$fAlternativeReadP2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),C(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [v_s3oy8 eta_s3oy9]
        let {
          some_v_s3oya [Occ=LoopBreaker]
            :: forall b1.
               ([a_a3nIa] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              sat-only [v_s3oy8 some_v_s3oya] \r [eta1_s3oyb]
                  let {
                    sat_s3oyj [Occ=Once]
                      :: a_a3nIa -> Text.ParserCombinators.ReadP.P b1_X3nkZ
                    [LclId] =
                        [some_v_s3oya eta1_s3oyb] \r [x_s3oyc]
                            let {
                              sat_s3oyi [Occ=Once] :: Text.ParserCombinators.ReadP.P b1_X3nkZ
                              [LclId] =
                                  [eta1_s3oyb x_s3oyc] \u []
                                      let {
                                        sat_s3oyh [Occ=Once] :: [a_a3nIa]
                                        [LclId] =
                                            CCCS :! [x_s3oyc GHC.Types.[]];
                                      } in  eta1_s3oyb sat_s3oyh; } in
                            let {
                              sat_s3oyf [Occ=Once]
                                :: [a_a3nIa] -> Text.ParserCombinators.ReadP.P b1_X3nkZ
                              [LclId] =
                                  [eta1_s3oyb x_s3oyc] \r [a1_s3oyd]
                                      let {
                                        sat_s3oye [Occ=Once] :: [a_a3nIa]
                                        [LclId] =
                                            CCCS :! [x_s3oyc a1_s3oyd];
                                      } in  eta1_s3oyb sat_s3oye;
                            } in 
                              case some_v_s3oya sat_s3oyf of sat_s3oyg {
                                __DEFAULT ->
                                    Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                        sat_s3oyg sat_s3oyi;
                              };
                  } in  v_s3oy8 sat_s3oyj;
        } in  some_v_s3oya eta_s3oy9;

Text.ParserCombinators.ReadP.$fAlternativeReadP1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),C(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [v_s3oyk eta_s3oyl]
        let {
          many_v_s3oym [Occ=LoopBreaker]
            :: forall b1.
               ([a_a3nIm] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              sat-only [v_s3oyk many_v_s3oym] \r [k_s3oyn]
                  let {
                    sat_s3oyu [Occ=Once] :: Text.ParserCombinators.ReadP.P b1_a3nvJ
                    [LclId] =
                        [k_s3oyn] \u [] k_s3oyn GHC.Types.[]; } in
                  let {
                    sat_s3oys [Occ=Once]
                      :: a_a3nIm -> Text.ParserCombinators.ReadP.P b1_a3nvJ
                    [LclId] =
                        [many_v_s3oym k_s3oyn] \r [x_s3oyo]
                            let {
                              sat_s3oyr [Occ=Once]
                                :: [a_a3nIm] -> Text.ParserCombinators.ReadP.P b1_a3nvJ
                              [LclId] =
                                  [k_s3oyn x_s3oyo] \r [a1_s3oyp]
                                      let {
                                        sat_s3oyq [Occ=Once] :: [a_a3nIm]
                                        [LclId] =
                                            CCCS :! [x_s3oyo a1_s3oyp];
                                      } in  k_s3oyn sat_s3oyq;
                            } in  many_v_s3oym sat_s3oyr;
                  } in 
                    case v_s3oyk sat_s3oys of sat_s3oyt {
                      __DEFAULT ->
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                              sat_s3oyt sat_s3oyu;
                    };
        } in  many_v_s3oym eta_s3oyl;

Text.ParserCombinators.ReadP.$fAlternativeReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Text.ParserCombinators.ReadP.$fApplicativeReadP
                                           Text.ParserCombinators.ReadP.$fAlternativeReadP4
                                           Text.ParserCombinators.ReadP.$fAlternativeReadP3
                                           Text.ParserCombinators.ReadP.$fAlternativeReadP2
                                           Text.ParserCombinators.ReadP.$fAlternativeReadP1];

Text.ParserCombinators.ReadP.$fMonadPlusReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [Text.ParserCombinators.ReadP.$fAlternativeReadP
                                         Text.ParserCombinators.ReadP.$fMonadReadP
                                         Text.ParserCombinators.ReadP.$fAlternativeReadP4
                                         Text.ParserCombinators.ReadP.$fAlternativeReadP3];

Text.ParserCombinators.ReadP.chainr3
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3oyv op_s3oyw eta_s3oyx]
        let {
          scan_s3oyy [Occ=LoopBreaker]
            :: forall b1.
               (a_a3nxM -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              sat-only [p_s3oyv op_s3oyw scan_s3oyy] \r [k_s3oyz]
                  let {
                    sat_s3oyI [Occ=Once]
                      :: a_a3nxM -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [op_s3oyw scan_s3oyy k_s3oyz] \r [a1_s3oyA]
                            let {
                              sat_s3oyH [Occ=Once] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3oyz a1_s3oyA] \u [] k_s3oyz a1_s3oyA; } in
                            let {
                              sat_s3oyF [Occ=Once]
                                :: (a_a3nxM -> a_a3nxM -> a_a3nxM)
                                   -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [scan_s3oyy k_s3oyz a1_s3oyA] \r [a2_s3oyB]
                                      let {
                                        sat_s3oyE [Occ=Once]
                                          :: a_a3nxM -> Text.ParserCombinators.ReadP.P b1_a3nIU
                                        [LclId] =
                                            [k_s3oyz a1_s3oyA a2_s3oyB] \r [a3_s3oyC]
                                                let {
                                                  sat_s3oyD [Occ=Once] :: a_a3nxM
                                                  [LclId] =
                                                      [a1_s3oyA a2_s3oyB a3_s3oyC] \u []
                                                          a2_s3oyB a1_s3oyA a3_s3oyC;
                                                } in  k_s3oyz sat_s3oyD;
                                      } in  scan_s3oyy sat_s3oyE;
                            } in 
                              case op_s3oyw sat_s3oyF of sat_s3oyG {
                                __DEFAULT ->
                                    Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                        sat_s3oyG sat_s3oyH;
                              };
                  } in  p_s3oyv sat_s3oyI;
        } in  scan_s3oyy eta_s3oyx;

Text.ParserCombinators.ReadP.chainr1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.chainr3 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.chainr2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3oyJ op_s3oyK x_s3oyL eta_s3oyM]
        let {
          sat_s3oyO [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [x_s3oyL eta_s3oyM] \u [] eta_s3oyM x_s3oyL;
        } in 
          case
              Text.ParserCombinators.ReadP.chainr3 p_s3oyJ op_s3oyK eta_s3oyM
          of
          sat_s3oyN
          { __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3oyN sat_s3oyO;
          };

Text.ParserCombinators.ReadP.chainr
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.chainr2 eta_B4 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.chainl3
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3oyP op_s3oyQ eta_s3oyR]
        let {
          rest_s3oyS [Occ=LoopBreaker]
            :: a_a3nyq
               -> forall b1.
                  (a_a3nyq -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<L,U><L,C(U)>, Unf=OtherCon []] =
              sat-only [p_s3oyP op_s3oyQ rest_s3oyS] \r [x_s3oyT eta1_s3oyU]
                  let {
                    sat_s3oz1 [Occ=Once] :: Text.ParserCombinators.ReadP.P b1_X3nls
                    [LclId] =
                        [x_s3oyT eta1_s3oyU] \u [] eta1_s3oyU x_s3oyT; } in
                  let {
                    sat_s3oyZ [Occ=Once]
                      :: (a_a3nyq -> a_a3nyq -> a_a3nyq)
                         -> Text.ParserCombinators.ReadP.P b1_X3nls
                    [LclId] =
                        [p_s3oyP rest_s3oyS x_s3oyT eta1_s3oyU] \r [a1_s3oyV]
                            let {
                              sat_s3oyY [Occ=Once]
                                :: a_a3nyq -> Text.ParserCombinators.ReadP.P b1_X3nls
                              [LclId] =
                                  [rest_s3oyS x_s3oyT eta1_s3oyU a1_s3oyV] \r [a2_s3oyW]
                                      let {
                                        sat_s3oyX [Occ=Once] :: a_a3nyq
                                        [LclId] =
                                            [x_s3oyT a1_s3oyV a2_s3oyW] \u []
                                                a1_s3oyV x_s3oyT a2_s3oyW;
                                      } in  rest_s3oyS sat_s3oyX eta1_s3oyU;
                            } in  p_s3oyP sat_s3oyY;
                  } in 
                    case op_s3oyQ sat_s3oyZ of sat_s3oz0 {
                      __DEFAULT ->
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                              sat_s3oz0 sat_s3oz1;
                    }; } in
        let {
          sat_s3oz3 [Occ=Once]
            :: a_a3nyq -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [eta_s3oyR rest_s3oyS] \r [a1_s3oz2] rest_s3oyS a1_s3oz2 eta_s3oyR;
        } in  p_s3oyP sat_s3oz3;

Text.ParserCombinators.ReadP.chainl1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.chainl3 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.chainl2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3oz4 op_s3oz5 x_s3oz6 eta_s3oz7]
        let {
          sat_s3oz9 [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [x_s3oz6 eta_s3oz7] \u [] eta_s3oz7 x_s3oz6;
        } in 
          case
              Text.ParserCombinators.ReadP.chainl3 p_s3oz4 op_s3oz5 eta_s3oz7
          of
          sat_s3oz8
          { __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3oz8 sat_s3oz9;
          };

Text.ParserCombinators.ReadP.chainl
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.chainl2 eta_B4 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.<++2 [Occ=LoopBreaker]
  :: GHC.Prim.Int#
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s3oza eta_s3ozb]
        case ds_s3oza of ds1_s3ozc {
          __DEFAULT ->
              let {
                lvl4_s3ozd [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_X3nlD
                [LclId] =
                    [eta_s3ozb ds1_s3ozc] \u []
                        case -# [ds1_s3ozc 1#] of sat_s3oze {
                          __DEFAULT -> Text.ParserCombinators.ReadP.<++2 sat_s3oze eta_s3ozb;
                        }; } in
              let {
                sat_s3ozg [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_X3nlD
                [LclId] =
                    [lvl4_s3ozd] \r [a_s3ozf] lvl4_s3ozd;
              } in  Text.ParserCombinators.ReadP.Get [sat_s3ozg];
          0# -> eta_s3ozb GHC.Tuple.();
        };

Text.ParserCombinators.ReadP.$w<++ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId, Arity=3, Str=<L,1*C1(U)><L,C(U)><L,U>, Unf=OtherCon []] =
    [] \r [w_s3ozh w1_s3ozi w2_s3ozj]
        let {
          lvl4_s3ozk [Occ=OnceL] :: Text.ParserCombinators.ReadP.P a_s3ohU
          [LclId] =
              [w_s3ozh] \u []
                  w_s3ozh Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
        let {
          probe_s3ozl [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadP.P a_s3ohU
               -> [GHC.Types.Char]
               -> GHC.Prim.Int#
               -> forall b1.
                  (a_s3ohU -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=4, Str=<S,1*U><L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w1_s3ozi probe_s3ozl] \r [ds_s3ozm
                                                  ds1_s3ozn
                                                  n_s3ozo
                                                  eta_s3ozp]
                  case ds_s3ozm of wild_s3ozq {
                    Text.ParserCombinators.ReadP.Get f_s3ozr [Occ=Once!] ->
                        case ds1_s3ozn of {
                          [] -> w1_s3ozi eta_s3ozp;
                          : c_s3ozt [Occ=Once] s_s3ozu [Occ=Once] ->
                              case +# [n_s3ozo 1#] of sat_s3ozw {
                                __DEFAULT ->
                                    case f_s3ozr c_s3ozt of sat_s3ozv {
                                      __DEFAULT ->
                                          probe_s3ozl sat_s3ozv s_s3ozu sat_s3ozw eta_s3ozp;
                                    };
                              };
                        };
                    Text.ParserCombinators.ReadP.Look f_s3ozx [Occ=Once!] ->
                        case f_s3ozx ds1_s3ozn of sat_s3ozy {
                          __DEFAULT -> probe_s3ozl sat_s3ozy ds1_s3ozn n_s3ozo eta_s3ozp;
                        };
                    Text.ParserCombinators.ReadP.Fail -> w1_s3ozi eta_s3ozp;
                    Text.ParserCombinators.ReadP.Result _ [Occ=Dead] _ [Occ=Dead] ->
                        let {
                          sat_s3ozC [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b1_X3nlg
                          [LclId] =
                              [eta_s3ozp wild_s3ozq] \r [a1_s3ozB]
                                  Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                      wild_s3ozq eta_s3ozp;
                        } in  Text.ParserCombinators.ReadP.<++2 n_s3ozo sat_s3ozC;
                    Text.ParserCombinators.ReadP.Final _ [Occ=Dead] ->
                        Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                            wild_s3ozq eta_s3ozp;
                  }; } in
        let {
          sat_s3ozF [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3ohX
          [LclId] =
              [w2_s3ozj lvl4_s3ozk probe_s3ozl] \r [a1_s3ozE]
                  probe_s3ozl lvl4_s3ozk a1_s3ozE 0# w2_s3ozj;
        } in  Unit# [sat_s3ozF];

Text.ParserCombinators.ReadP.<++1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,1*C1(U)><L,C(U)><L,U>m2, Unf=OtherCon []] =
    [] \r [w_s3ozG w1_s3ozH w2_s3ozI]
        case
            Text.ParserCombinators.ReadP.$w<++ w_s3ozG w1_s3ozH w2_s3ozI
        of
        { Unit# ww1_s3ozK [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_s3ozK];
        };

Text.ParserCombinators.ReadP.<++
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=3, Str=<L,1*C1(U)><L,C(U)><L,U>m2, Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.<++1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.manyTill1
  :: forall a end.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP end
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,C(U)><L,C(U)><L,U>, Unf=OtherCon []] =
    [] \r [p_s3ozL end1_s3ozM eta_s3ozN]
        let {
          scan_s3ozO [Occ=OnceL, Dmd=<L,C(U)>]
            :: forall b1.
               ([a_a3nB6] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,1*C1(U)>, Unf=OtherCon []] =
              [end1_s3ozM] \r [k_s3ozP]
                  let {
                    lvl4_s3ozQ [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [k_s3ozP] \u [] k_s3ozP GHC.Types.[]; } in
                  let {
                    sat_s3ozS [Occ=Once]
                      :: end_a3nB7 -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [lvl4_s3ozQ] \r [a1_s3ozR] lvl4_s3ozQ;
                  } in  end1_s3ozM sat_s3ozS; } in
        let {
          scan1_s3ozT [Occ=OnceL]
            :: forall b1.
               ([a_a3nB6] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              [p_s3ozL scan2_s3ozU] \r [k_s3ozV]
                  let {
                    sat_s3oA0 [Occ=Once]
                      :: a_a3nB6 -> Text.ParserCombinators.ReadP.P b1_X3nOr
                    [LclId] =
                        [scan2_s3ozU k_s3ozV] \r [a1_s3ozW]
                            let {
                              sat_s3ozZ [Occ=Once]
                                :: [a_a3nB6] -> Text.ParserCombinators.ReadP.P b1_X3nOr
                              [LclId] =
                                  [k_s3ozV a1_s3ozW] \r [a2_s3ozX]
                                      let {
                                        sat_s3ozY [Occ=Once] :: [a_a3nB6]
                                        [LclId] =
                                            CCCS :! [a1_s3ozW a2_s3ozX];
                                      } in  k_s3ozV sat_s3ozY;
                            } in  scan2_s3ozU sat_s3ozZ;
                  } in  p_s3ozL sat_s3oA0;
          scan2_s3ozU [Occ=LoopBreaker]
            :: forall b1.
               ([a_a3nB6] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [scan_s3ozO scan1_s3ozT] \r [w_s3oA1]
                  case
                      Text.ParserCombinators.ReadP.$w<++ scan_s3ozO scan1_s3ozT w_s3oA1
                  of
                  { Unit# ww1_s3oA3 [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_s3oA3];
                  };
        } in  scan2_s3ozU eta_s3ozN;

Text.ParserCombinators.ReadP.manyTill
  :: forall a end.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP end
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=3, Str=<L,C(U)><L,C(U)><L,U>, Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.manyTill1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.eof1
  :: forall b.
     (() -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)>m2,
 Unf=OtherCon []] =
    [] \r [k_s3oA4]
        let {
          lvl4_s3oA5 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3nIU
          [LclId] =
              [k_s3oA4] \u [] k_s3oA4 GHC.Tuple.(); } in
        let {
          sat_s3oAa [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3nIU
          [LclId] =
              [lvl4_s3oA5] \r [a_s3oA6]
                  case a_s3oA6 of {
                    [] -> lvl4_s3oA5;
                    : _ [Occ=Dead] _ [Occ=Dead] ->
                        Text.ParserCombinators.ReadP.Fail [];
                  };
        } in  Text.ParserCombinators.ReadP.Look [sat_s3oAa];

Text.ParserCombinators.ReadP.eof
  :: Text.ParserCombinators.ReadP.ReadP ()
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.eof1 eta_B1;

Text.ParserCombinators.ReadP.satisfy1
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Types.Char -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [p_s3oAb k_s3oAc]
        let {
          sat_s3oAf [Occ=Once]
            :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_X3nNg
          [LclId] =
              [p_s3oAb k_s3oAc] \r [a_s3oAd]
                  case p_s3oAb a_s3oAd of {
                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail [];
                    GHC.Types.True -> k_s3oAc a_s3oAd;
                  };
        } in  Text.ParserCombinators.ReadP.Get [sat_s3oAf];

Text.ParserCombinators.ReadP.satisfy
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> Text.ParserCombinators.ReadP.ReadP GHC.Types.Char
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.satisfy1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.char1
  :: GHC.Types.Char
     -> forall b.
        (GHC.Types.Char -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [c_s3oAg eta_s3oAh]
        let {
          sat_s3oAo [Occ=Once]
            :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_X3nNg
          [LclId] =
              [c_s3oAg eta_s3oAh] \r [a_s3oAi]
                  case c_s3oAg of {
                    GHC.Types.C# x_s3oAk [Occ=Once] ->
                        case a_s3oAi of wild1_s3oAl {
                          GHC.Types.C# y_s3oAm [Occ=Once] ->
                              case eqChar# [x_s3oAk y_s3oAm] of {
                                __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                1# -> eta_s3oAh wild1_s3oAl;
                              };
                        };
                  };
        } in  Text.ParserCombinators.ReadP.Get [sat_s3oAo];

Text.ParserCombinators.ReadP.char
  :: GHC.Types.Char
     -> Text.ParserCombinators.ReadP.ReadP GHC.Types.Char
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.char1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$wstring [InlPrag=NOUSERINLINE[0]]
  :: GHC.Base.String
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3oAp w1_s3oAq]
        let {
          scan_s3oAr [Occ=LoopBreaker]
            :: [GHC.Types.Char]
               -> [GHC.Types.Char]
               -> forall b1.
                  (GHC.Base.String -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=3, Str=<S,1*U><L,1*U><L,1*C1(U)>, Unf=OtherCon []] =
              sat-only [w_s3oAp scan_s3oAr] \r [ds_s3oAs ds1_s3oAt eta_s3oAu]
                  case ds_s3oAs of {
                    [] -> eta_s3oAu w_s3oAp;
                    : x_s3oAw [Occ=Once!] xs_s3oAx [Occ=Once] ->
                        case ds1_s3oAt of {
                          [] -> Text.ParserCombinators.ReadP.Fail [];
                          : y_s3oAz [Occ=Once!] ys_s3oAA [Occ=Once] ->
                              case x_s3oAw of {
                                GHC.Types.C# x1_s3oAC [Occ=Once] ->
                                    case y_s3oAz of {
                                      GHC.Types.C# y1_s3oAE [Occ=Once] ->
                                          case eqChar# [x1_s3oAC y1_s3oAE] of {
                                            __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                            1# ->
                                                let {
                                                  lvl4_s3oAG [Occ=OnceL]
                                                    :: Text.ParserCombinators.ReadP.P b1_a3ngn
                                                  [LclId] =
                                                      [scan_s3oAr eta_s3oAu xs_s3oAx ys_s3oAA] \u []
                                                          scan_s3oAr
                                                              xs_s3oAx ys_s3oAA eta_s3oAu; } in
                                                let {
                                                  sat_s3oAI [Occ=Once]
                                                    :: GHC.Types.Char
                                                       -> Text.ParserCombinators.ReadP.P b1_a3ngn
                                                  [LclId] =
                                                      [lvl4_s3oAG] \r [a_s3oAH] lvl4_s3oAG;
                                                } in  Text.ParserCombinators.ReadP.Get [sat_s3oAI];
                                          };
                                    };
                              };
                        };
                  }; } in
        let {
          sat_s3oAK [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3oig
          [LclId] =
              [w_s3oAp w1_s3oAq scan_s3oAr] \r [a_s3oAJ]
                  scan_s3oAr w_s3oAp a_s3oAJ w1_s3oAq;
        } in  Unit# [sat_s3oAK];

Text.ParserCombinators.ReadP.string1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Base.String
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_s3oAL w1_s3oAM]
        case Text.ParserCombinators.ReadP.$wstring w_s3oAL w1_s3oAM of {
          Unit# ww1_s3oAO [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_s3oAO];
        };

Text.ParserCombinators.ReadP.string
  :: GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadP GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.string1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$wmunch [InlPrag=NOUSERINLINE[0]]
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3oAP w1_s3oAQ]
        let {
          scan_s3oAR [Occ=LoopBreaker]
            :: [GHC.Types.Char]
               -> forall b1.
                  ([GHC.Types.Char] -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<S,1*U><L,1*C1(U)>, Unf=OtherCon []] =
              sat-only [w_s3oAP scan_s3oAR] \r [ds_s3oAS eta_s3oAT]
                  case ds_s3oAS of {
                    [] -> eta_s3oAT GHC.Types.[];
                    : c_s3oAV cs_s3oAW [Occ=Once] ->
                        case w_s3oAP c_s3oAV of {
                          GHC.Types.False -> eta_s3oAT GHC.Types.[];
                          GHC.Types.True ->
                              let {
                                lvl4_s3oAY [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_X3nlq
                                [LclId] =
                                    [scan_s3oAR eta_s3oAT c_s3oAV cs_s3oAW] \u []
                                        let {
                                          sat_s3oB1 [Occ=Once]
                                            :: [GHC.Types.Char]
                                               -> Text.ParserCombinators.ReadP.P b1_X3nlq
                                          [LclId] =
                                              [eta_s3oAT c_s3oAV] \r [a_s3oAZ]
                                                  let {
                                                    sat_s3oB0 [Occ=Once] :: [GHC.Types.Char]
                                                    [LclId] =
                                                        CCCS :! [c_s3oAV a_s3oAZ];
                                                  } in  eta_s3oAT sat_s3oB0;
                                        } in  scan_s3oAR cs_s3oAW sat_s3oB1; } in
                              let {
                                sat_s3oB3 [Occ=Once]
                                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b1_X3nlq
                                [LclId] =
                                    [lvl4_s3oAY] \r [a_s3oB2] lvl4_s3oAY;
                              } in  Text.ParserCombinators.ReadP.Get [sat_s3oB3];
                        };
                  }; } in
        let {
          sat_s3oB5 [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3oiq
          [LclId] =
              [w1_s3oAQ scan_s3oAR] \r [a_s3oB4] scan_s3oAR a_s3oB4 w1_s3oAQ;
        } in  Unit# [sat_s3oB5];

Text.ParserCombinators.ReadP.munch2 [InlPrag=NOUSERINLINE[0]]
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_s3oB6 w1_s3oB7]
        case Text.ParserCombinators.ReadP.$wmunch w_s3oB6 w1_s3oB7 of {
          Unit# ww1_s3oB9 [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_s3oB9];
        };

Text.ParserCombinators.ReadP.munch
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> Text.ParserCombinators.ReadP.ReadP GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.munch2 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$wmunch1 [InlPrag=NOUSERINLINE[0]]
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Types.Char -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3oBa w1_s3oBb]
        let {
          sat_s3oBj [Occ=Once]
            :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_s3oix
          [LclId] =
              [w_s3oBa w1_s3oBb] \r [a_s3oBc]
                  case w_s3oBa a_s3oBc of {
                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail [];
                    GHC.Types.True ->
                        let {
                          sat_s3oBg [Occ=Once]
                            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3oix
                          [LclId] =
                              [w1_s3oBb a_s3oBc] \r [a1_s3oBe]
                                  let {
                                    sat_s3oBf [Occ=Once] :: GHC.Base.String
                                    [LclId] =
                                        CCCS :! [a_s3oBc a1_s3oBe];
                                  } in  w1_s3oBb sat_s3oBf;
                        } in 
                          case Text.ParserCombinators.ReadP.$wmunch w_s3oBa sat_s3oBg of {
                            Unit# ww1_s3oBi [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww1_s3oBi];
                          };
                  };
        } in  Unit# [sat_s3oBj];

Text.ParserCombinators.ReadP.munch3 [InlPrag=NOUSERINLINE[0]]
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [w_s3oBk w1_s3oBl]
        case Text.ParserCombinators.ReadP.$wmunch1 w_s3oBk w1_s3oBl of {
          Unit# ww1_s3oBn [Occ=Once] ->
              Text.ParserCombinators.ReadP.Get [ww1_s3oBn];
        };

Text.ParserCombinators.ReadP.munch1
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> Text.ParserCombinators.ReadP.ReadP GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.munch3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.skipSpaces2 [Occ=LoopBreaker]
  :: [GHC.Types.Char]
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s3oBo eta_s3oBp]
        case ds_s3oBo of {
          [] -> eta_s3oBp GHC.Tuple.();
          : c_s3oBr [Occ=Once!] s_s3oBs [Occ=Once*] ->
              case c_s3oBr of {
                GHC.Types.C# ww1_s3oBu ->
                    case ord# [ww1_s3oBu] of sat_s3oBw {
                      __DEFAULT ->
                          case int2Word# [sat_s3oBw] of x_s3oBv [Dmd=<S,U>] {
                            __DEFAULT ->
                                case leWord# [x_s3oBv 887##] of {
                                  __DEFAULT ->
                                      case ord# [ww1_s3oBu] of sat_s3oBz {
                                        __DEFAULT ->
                                            case
                                                __pkg_ccall base-4.11.0.0 [sat_s3oBz
                                                                           GHC.Prim.realWorld#]
                                            of
                                            { Unit# ds2_s3oBC [Occ=Once!] ->
                                                  case ds2_s3oBC of {
                                                    __DEFAULT ->
                                                        let {
                                                          lvl4_s3oBE [Occ=OnceL]
                                                            :: Text.ParserCombinators.ReadP.P
                                                                 b_a3ngn
                                                          [LclId] =
                                                              [eta_s3oBp s_s3oBs] \u []
                                                                  Text.ParserCombinators.ReadP.skipSpaces2
                                                                      s_s3oBs eta_s3oBp; } in
                                                        let {
                                                          sat_s3oBG [Occ=Once]
                                                            :: GHC.Types.Char
                                                               -> Text.ParserCombinators.ReadP.P
                                                                    b_a3ngn
                                                          [LclId] =
                                                              [lvl4_s3oBE] \r [a_s3oBF] lvl4_s3oBE;
                                                        } in 
                                                          Text.ParserCombinators.ReadP.Get [sat_s3oBG];
                                                    0# -> eta_s3oBp GHC.Tuple.();
                                                  };
                                            };
                                      };
                                  1# ->
                                      case x_s3oBv of wild1_s3oBH {
                                        __DEFAULT ->
                                            case minusWord# [wild1_s3oBH 9##] of sat_s3oBI {
                                              __DEFAULT ->
                                                  case leWord# [sat_s3oBI 4##] of {
                                                    __DEFAULT ->
                                                        case wild1_s3oBH of {
                                                          __DEFAULT -> eta_s3oBp GHC.Tuple.();
                                                          160## ->
                                                              let {
                                                                lvl4_s3oBL [Occ=OnceL]
                                                                  :: Text.ParserCombinators.ReadP.P
                                                                       b_a3ngn
                                                                [LclId] =
                                                                    [eta_s3oBp s_s3oBs] \u []
                                                                        Text.ParserCombinators.ReadP.skipSpaces2
                                                                            s_s3oBs eta_s3oBp; } in
                                                              let {
                                                                sat_s3oBN [Occ=Once]
                                                                  :: GHC.Types.Char
                                                                     -> Text.ParserCombinators.ReadP.P
                                                                          b_a3ngn
                                                                [LclId] =
                                                                    [lvl4_s3oBL] \r [a_s3oBM]
                                                                        lvl4_s3oBL;
                                                              } in 
                                                                Text.ParserCombinators.ReadP.Get [sat_s3oBN];
                                                        };
                                                    1# ->
                                                        let {
                                                          lvl4_s3oBO [Occ=OnceL]
                                                            :: Text.ParserCombinators.ReadP.P
                                                                 b_a3ngn
                                                          [LclId] =
                                                              [eta_s3oBp s_s3oBs] \u []
                                                                  Text.ParserCombinators.ReadP.skipSpaces2
                                                                      s_s3oBs eta_s3oBp; } in
                                                        let {
                                                          sat_s3oBQ [Occ=Once]
                                                            :: GHC.Types.Char
                                                               -> Text.ParserCombinators.ReadP.P
                                                                    b_a3ngn
                                                          [LclId] =
                                                              [lvl4_s3oBO] \r [a_s3oBP] lvl4_s3oBO;
                                                        } in 
                                                          Text.ParserCombinators.ReadP.Get [sat_s3oBQ];
                                                  };
                                            };
                                        32## ->
                                            let {
                                              lvl4_s3oBR [Occ=OnceL]
                                                :: Text.ParserCombinators.ReadP.P b_a3ngn
                                              [LclId] =
                                                  [eta_s3oBp s_s3oBs] \u []
                                                      Text.ParserCombinators.ReadP.skipSpaces2
                                                          s_s3oBs eta_s3oBp; } in
                                            let {
                                              sat_s3oBT [Occ=Once]
                                                :: GHC.Types.Char
                                                   -> Text.ParserCombinators.ReadP.P b_a3ngn
                                              [LclId] =
                                                  [lvl4_s3oBR] \r [a_s3oBS] lvl4_s3oBR;
                                            } in  Text.ParserCombinators.ReadP.Get [sat_s3oBT];
                                      };
                                };
                          };
                    };
              };
        };

Text.ParserCombinators.ReadP.skipSpaces1
  :: forall b.
     (() -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,C(U)>m2, Unf=OtherCon []] =
    [] \r [k_s3oBU]
        let {
          sat_s3oBW [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_X3nNv
          [LclId] =
              [k_s3oBU] \r [a_s3oBV]
                  Text.ParserCombinators.ReadP.skipSpaces2 a_s3oBV k_s3oBU;
        } in  Text.ParserCombinators.ReadP.Look [sat_s3oBW];

Text.ParserCombinators.ReadP.skipSpaces
  :: Text.ParserCombinators.ReadP.ReadP ()
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,C(U)>m2, Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.skipSpaces1 eta_B1;

Text.ParserCombinators.ReadP.Get
  :: forall a.
     (GHC.Types.Char -> Text.ParserCombinators.ReadP.P a)
     -> Text.ParserCombinators.ReadP.P a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m1,
 Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Get [eta_B1];

Text.ParserCombinators.ReadP.Look
  :: forall a.
     (GHC.Base.String -> Text.ParserCombinators.ReadP.P a)
     -> Text.ParserCombinators.ReadP.P a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Look [eta_B1];

Text.ParserCombinators.ReadP.Fail
  :: forall a. Text.ParserCombinators.ReadP.P a
[GblId[DataCon], Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE Text.ParserCombinators.ReadP.Fail! [];

Text.ParserCombinators.ReadP.Result
  :: forall a.
     a
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m4,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.Result [eta_B2 eta_B1];

Text.ParserCombinators.ReadP.Final
  :: forall a.
     [(a, GHC.Base.String)] -> Text.ParserCombinators.ReadP.P a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m5,
 Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Final [eta_B1];


==================== Pre unarise: ====================
2018-03-16 15:58:05.516001232 UTC

Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
  :: forall a. a -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m4, Unf=OtherCon []] =
    [] \r [x_s3rIG]
        Text.ParserCombinators.ReadP.Result [x_s3rIG
                                             Text.ParserCombinators.ReadP.Fail];

Text.ParserCombinators.ReadP.$fMonadFailP_$cfail
  :: forall a. GHC.Base.String -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s3rIH] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadP.$fFunctorReadP2
  :: forall a b.
     (a -> b)
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><C(S),1*C1(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [h_s3rII ds_s3rIJ k_s3rIK]
        let {
          sat_s3rIL [Occ=Once]
            :: a_a3nKO -> Text.ParserCombinators.ReadP.P b1_a3nKT
          [LclId] =
              [h_s3rII k_s3rIK] \r [eta_B1] GHC.Base.. k_s3rIK h_s3rII eta_B1;
        } in  ds_s3rIJ sat_s3rIL;

Text.ParserCombinators.ReadP.$fFunctorReadP1
  :: forall a b.
     a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (a -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [x_s3rIM eta_s3rIN eta1_s3rIO]
        let {
          lvl4_s3rIP [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [x_s3rIM eta1_s3rIO] \u [] eta1_s3rIO x_s3rIM; } in
        let {
          sat_s3rIR [Occ=Once]
            :: b_a3nL5 -> Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [lvl4_s3rIP] \r [x1_s3rIQ] lvl4_s3rIP;
        } in  eta_s3rIN sat_s3rIR;

Text.ParserCombinators.ReadP.$fFunctorReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Text.ParserCombinators.ReadP.$fFunctorReadP2
                                       Text.ParserCombinators.ReadP.$fFunctorReadP1];

Text.ParserCombinators.ReadP.$fApplicativeReadP5
  :: forall a.
     a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [x_s3rIS k_s3rIT] k_s3rIT x_s3rIS;

Text.ParserCombinators.ReadP.$fMonadFailReadP1
  :: forall a.
     GHC.Base.String
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_s3rIU ds1_s3rIV] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadP.$fMonadReadP1
  :: forall a b.
     Text.ParserCombinators.ReadP.ReadP a
     -> (a -> Text.ParserCombinators.ReadP.ReadP b)
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3rIW f_s3rIX k_s3rIY]
        let {
          sat_s3rJ0 [Occ=Once]
            :: a_a3nIP -> Text.ParserCombinators.ReadP.P b1_a3nIU
          [LclId] =
              [f_s3rIX k_s3rIY] \r [a1_s3rIZ] f_s3rIX a1_s3rIZ k_s3rIY;
        } in  ds_s3rIW sat_s3rJ0;

Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap [Occ=LoopBreaker]
  :: forall a b.
     (a -> b)
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s3rJ1 ds_s3rJ2]
        case ds_s3rJ2 of {
          Text.ParserCombinators.ReadP.Get a1_s3rJ4 [Occ=OnceL!] ->
              let {
                sat_s3rJ7 [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_a3nEm
                [LclId] =
                    [f_s3rJ1 a1_s3rJ4] \r [b3_s3rJ5]
                        case a1_s3rJ4 b3_s3rJ5 of sat_s3rJ6 {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                                  f_s3rJ1 sat_s3rJ6;
                        };
              } in  Text.ParserCombinators.ReadP.Get [sat_s3rJ7];
          Text.ParserCombinators.ReadP.Look a1_s3rJ8 [Occ=OnceL!] ->
              let {
                sat_s3rJb [Occ=Once]
                  :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3nEm
                [LclId] =
                    [f_s3rJ1 a1_s3rJ8] \r [b3_s3rJ9]
                        case a1_s3rJ8 b3_s3rJ9 of sat_s3rJa {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                                  f_s3rJ1 sat_s3rJa;
                        };
              } in  Text.ParserCombinators.ReadP.Look [sat_s3rJb];
          Text.ParserCombinators.ReadP.Fail ->
              Text.ParserCombinators.ReadP.Fail [];
          Text.ParserCombinators.ReadP.Result a1_s3rJc [Occ=Once]
                                              a2_s3rJd [Occ=Once] ->
              let {
                sat_s3rJf [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nEm
                [LclId] =
                    [f_s3rJ1 a2_s3rJd] \u []
                        Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                            f_s3rJ1 a2_s3rJd; } in
              let {
                sat_s3rJe [Occ=Once] :: b_a3nEm
                [LclId] =
                    [f_s3rJ1 a1_s3rJc] \u [] f_s3rJ1 a1_s3rJc;
              } in  Text.ParserCombinators.ReadP.Result [sat_s3rJe sat_s3rJf];
          Text.ParserCombinators.ReadP.Final a1_s3rJg [Occ=Once] ->
              let {
                sat_s3rJn [Occ=Once] :: [(b_a3nEm, GHC.Base.String)]
                [LclId] =
                    [f_s3rJ1 a1_s3rJg] \u []
                        let {
                          sat_s3rJm [Occ=Once]
                            :: (a_a3nEl, GHC.Base.String) -> (b_a3nEm, GHC.Base.String)
                          [LclId] =
                              [f_s3rJ1] \r [b2_s3rJh]
                                  case b2_s3rJh of {
                                    (,) a2_s3rJj [Occ=Once] a3_s3rJk [Occ=Once] ->
                                        let {
                                          sat_s3rJl [Occ=Once] :: b_a3nEm
                                          [LclId] =
                                              [f_s3rJ1 a2_s3rJj] \u [] f_s3rJ1 a2_s3rJj;
                                        } in  (,) [sat_s3rJl a3_s3rJk];
                                  };
                        } in  GHC.Base.map sat_s3rJm a1_s3rJg;
              } in  Text.ParserCombinators.ReadP.Final [sat_s3rJn];
        };

Text.ParserCombinators.ReadP.$fApplicativeP_$c<$ [Occ=LoopBreaker]
  :: forall a b.
     a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [z_s3rJo ds_s3rJp]
        case ds_s3rJp of {
          Text.ParserCombinators.ReadP.Get a1_s3rJr [Occ=OnceL!] ->
              let {
                sat_s3rJu [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P a_a3nFG
                [LclId] =
                    [z_s3rJo a1_s3rJr] \r [b4_s3rJs]
                        case a1_s3rJr b4_s3rJs of sat_s3rJt {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fApplicativeP_$c<$ z_s3rJo sat_s3rJt;
                        };
              } in  Text.ParserCombinators.ReadP.Get [sat_s3rJu];
          Text.ParserCombinators.ReadP.Look a1_s3rJv [Occ=OnceL!] ->
              let {
                sat_s3rJy [Occ=Once]
                  :: GHC.Base.String -> Text.ParserCombinators.ReadP.P a_a3nFG
                [LclId] =
                    [z_s3rJo a1_s3rJv] \r [b4_s3rJw]
                        case a1_s3rJv b4_s3rJw of sat_s3rJx {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fApplicativeP_$c<$ z_s3rJo sat_s3rJx;
                        };
              } in  Text.ParserCombinators.ReadP.Look [sat_s3rJy];
          Text.ParserCombinators.ReadP.Fail ->
              Text.ParserCombinators.ReadP.Fail [];
          Text.ParserCombinators.ReadP.Result _ [Occ=Dead]
                                              a2_s3rJA [Occ=Once] ->
              let {
                sat_s3rJB [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nFG
                [LclId] =
                    [z_s3rJo a2_s3rJA] \u []
                        Text.ParserCombinators.ReadP.$fApplicativeP_$c<$ z_s3rJo a2_s3rJA;
              } in  Text.ParserCombinators.ReadP.Result [z_s3rJo sat_s3rJB];
          Text.ParserCombinators.ReadP.Final a1_s3rJC [Occ=Once] ->
              let {
                sat_s3rJI [Occ=Once] :: [(a_a3nFG, GHC.Base.String)]
                [LclId] =
                    [z_s3rJo a1_s3rJC] \u []
                        let {
                          sat_s3rJH [Occ=Once]
                            :: (b_a3nFH, GHC.Base.String) -> (a_a3nFG, GHC.Base.String)
                          [LclId] =
                              [z_s3rJo] \r [b3_s3rJD]
                                  case b3_s3rJD of {
                                    (,) _ [Occ=Dead] a3_s3rJG [Occ=Once] -> (,) [z_s3rJo a3_s3rJG];
                                  };
                        } in  GHC.Base.map sat_s3rJH a1_s3rJC;
              } in  Text.ParserCombinators.ReadP.Final [sat_s3rJI];
        };

Text.ParserCombinators.ReadP.$fFunctorP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Text.ParserCombinators.ReadP.P
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                                       Text.ParserCombinators.ReadP.$fApplicativeP_$c<$];

Text.ParserCombinators.ReadP.run [Occ=LoopBreaker]
  :: forall a.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3rJJ ds1_s3rJK]
        case ds_s3rJJ of {
          Text.ParserCombinators.ReadP.Get f_s3rJM [Occ=Once!] ->
              case ds1_s3rJK of {
                [] -> [] [];
                : c_s3rJO [Occ=Once] s_s3rJP [Occ=Once] ->
                    case f_s3rJM c_s3rJO of sat_s3rJQ {
                      __DEFAULT -> Text.ParserCombinators.ReadP.run sat_s3rJQ s_s3rJP;
                    };
              };
          Text.ParserCombinators.ReadP.Look f_s3rJR [Occ=Once!] ->
              case f_s3rJR ds1_s3rJK of sat_s3rJS {
                __DEFAULT -> Text.ParserCombinators.ReadP.run sat_s3rJS ds1_s3rJK;
              };
          Text.ParserCombinators.ReadP.Fail -> [] [];
          Text.ParserCombinators.ReadP.Result x_s3rJT [Occ=Once]
                                              p_s3rJU [Occ=Once] ->
              let {
                sat_s3rJW [Occ=Once] :: [(a_a3nDL, GHC.Base.String)]
                [LclId] =
                    [ds1_s3rJK p_s3rJU] \u []
                        Text.ParserCombinators.ReadP.run p_s3rJU ds1_s3rJK; } in
              let {
                sat_s3rJV [Occ=Once] :: (a_a3nDL, GHC.Base.String)
                [LclId] =
                    CCCS (,)! [x_s3rJT ds1_s3rJK];
              } in  : [sat_s3rJV sat_s3rJW];
          Text.ParserCombinators.ReadP.Final r_s3rJX [Occ=Once] -> r_s3rJX;
        };

Text.ParserCombinators.ReadP.$wreadS_to_P [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3rJY w1_s3rJZ]
        let {
          go_s3rK0 [Occ=LoopBreaker]
            :: [(a_s3ofE, GHC.Base.String)] -> [(b_s3ofG, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w1_s3rJZ go_s3rK0] \r [ds_s3rK1]
                  case ds_s3rK1 of {
                    [] -> [] [];
                    : y_s3rK3 [Occ=Once!] ys_s3rK4 [Occ=Once] ->
                        case y_s3rK3 of {
                          (,) a1_s3rK6 [Occ=Once] s'_s3rK7 [Occ=Once] ->
                              let {
                                sat_s3rKa [Occ=Once, Dmd=<L,1*U>] :: [(b_s3ofG, GHC.Base.String)]
                                [LclId] =
                                    [go_s3rK0 ys_s3rK4] \s [] go_s3rK0 ys_s3rK4;
                              } in 
                                case w1_s3rJZ a1_s3rK6 of sat_s3rK8 {
                                  __DEFAULT ->
                                      case
                                          Text.ParserCombinators.ReadP.run sat_s3rK8 s'_s3rK7
                                      of
                                      sat_s3rK9
                                      { __DEFAULT -> GHC.Base.++ sat_s3rK9 sat_s3rKa;
                                      };
                                };
                        };
                  }; } in
        let {
          sat_s3rKg [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3ofG
          [LclId] =
              [w_s3rJY go_s3rK0] \r [s_s3rKb]
                  case w_s3rJY s_s3rKb of sat_s3rKc {
                    __DEFAULT ->
                        case go_s3rK0 sat_s3rKc of wild_s3rKd {
                          [] -> Text.ParserCombinators.ReadP.Fail [];
                          : _ [Occ=Dead] _ [Occ=Dead] ->
                              Text.ParserCombinators.ReadP.Final [wild_s3rKd];
                        };
                  };
        } in  Unit# [sat_s3rKg];

Text.ParserCombinators.ReadP.readS_to_P1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_s3rKh w1_s3rKi]
        case
            Text.ParserCombinators.ReadP.$wreadS_to_P w_s3rKh w1_s3rKi
        of
        { Unit# ww1_s3rKk [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_s3rKk];
        };

Text.ParserCombinators.ReadP.readS_to_P
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.readS_to_P1 eta_B2 eta_B1;

lvl_r3oqE :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Text/ParserCombinators/ReadP.hs:(134,3)-(157,52)|function <|>"#;

lvl1_r3oqF :: forall a. Text.ParserCombinators.ReadP.P a
[GblId, Str=x] =
    [] \u [] Control.Exception.Base.patError lvl_r3oqE;

Text.ParserCombinators.ReadP.$fAlternativeP_$c<|> [Occ=LoopBreaker]
  :: forall a.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=2, Str=<S,U><L,U>, Unf=OtherCon []] =
    [] \r [ds_s3rKl ds1_s3rKm]
        let-no-escape {
          fail_s3rKn [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
            :: GHC.Prim.Void# -> Text.ParserCombinators.ReadP.P a_a3nLq
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [ds_s3rKl ds1_s3rKm] \r [ds2_s3rKo]
                  case ds1_s3rKm of wild_s3rKp {
                    __DEFAULT ->
                        case ds_s3rKl of wild1_s3rKq {
                          __DEFAULT ->
                              case wild_s3rKp of wild2_s3rKr {
                                __DEFAULT ->
                                    let-no-escape {
                                      fail1_s3rKs [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
                                        :: GHC.Prim.Void# -> Text.ParserCombinators.ReadP.P a_a3nLq
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [wild1_s3rKq wild2_s3rKr] \r [ds3_s3rKt]
                                              case wild2_s3rKr of wild3_s3rKu {
                                                __DEFAULT ->
                                                    case wild1_s3rKq of wild4_s3rKv {
                                                      __DEFAULT ->
                                                          case wild3_s3rKu of {
                                                            Text.ParserCombinators.ReadP.Get _ [Occ=Dead] ->
                                                                lvl1_r3oqF;
                                                            Text.ParserCombinators.ReadP.Look f_s3rKy [Occ=OnceL!] ->
                                                                let {
                                                                  sat_s3rKB [Occ=Once]
                                                                    :: GHC.Base.String
                                                                       -> Text.ParserCombinators.ReadP.P
                                                                            a_a3nLq
                                                                  [LclId] =
                                                                      [wild4_s3rKv
                                                                       f_s3rKy] \r [s_s3rKz]
                                                                          let {
                                                                            sat_s3rKA [Occ=Once]
                                                                              :: Text.ParserCombinators.ReadP.P
                                                                                   a_a3nLq
                                                                            [LclId] =
                                                                                [f_s3rKy
                                                                                 s_s3rKz] \u []
                                                                                    f_s3rKy s_s3rKz;
                                                                          } in 
                                                                            Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                                                                wild4_s3rKv
                                                                                sat_s3rKA;
                                                                } in 
                                                                  Text.ParserCombinators.ReadP.Look [sat_s3rKB];
                                                          };
                                                      Text.ParserCombinators.ReadP.Look f_s3rKC [Occ=OnceL*!] ->
                                                          case wild3_s3rKu of wild5_s3rKD {
                                                            Text.ParserCombinators.ReadP.Get _ [Occ=Dead] ->
                                                                let {
                                                                  sat_s3rKH [Occ=Once]
                                                                    :: GHC.Base.String
                                                                       -> Text.ParserCombinators.ReadP.P
                                                                            a_a3nLq
                                                                  [LclId] =
                                                                      [f_s3rKC
                                                                       wild5_s3rKD] \r [s_s3rKF]
                                                                          case
                                                                              f_s3rKC s_s3rKF
                                                                          of
                                                                          sat_s3rKG
                                                                          { __DEFAULT ->
                                                                                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                                                                    sat_s3rKG
                                                                                    wild5_s3rKD;
                                                                          };
                                                                } in 
                                                                  Text.ParserCombinators.ReadP.Look [sat_s3rKH];
                                                            Text.ParserCombinators.ReadP.Look g_s3rKI [Occ=OnceL!] ->
                                                                let {
                                                                  sat_s3rKM [Occ=Once]
                                                                    :: GHC.Base.String
                                                                       -> Text.ParserCombinators.ReadP.P
                                                                            a_a3nLq
                                                                  [LclId] =
                                                                      [f_s3rKC g_s3rKI] \r [s_s3rKJ]
                                                                          let {
                                                                            sat_s3rKL [Occ=Once]
                                                                              :: Text.ParserCombinators.ReadP.P
                                                                                   a_a3nLq
                                                                            [LclId] =
                                                                                [g_s3rKI
                                                                                 s_s3rKJ] \u []
                                                                                    g_s3rKI s_s3rKJ;
                                                                          } in 
                                                                            case
                                                                                f_s3rKC s_s3rKJ
                                                                            of
                                                                            sat_s3rKK
                                                                            { __DEFAULT ->
                                                                                  Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                                                                      sat_s3rKK
                                                                                      sat_s3rKL;
                                                                            };
                                                                } in 
                                                                  Text.ParserCombinators.ReadP.Look [sat_s3rKM];
                                                          };
                                                    };
                                                Text.ParserCombinators.ReadP.Final r_s3rKN [Occ=OnceL] ->
                                                    let {
                                                      sat_s3rKR [Occ=Once]
                                                        :: GHC.Base.String
                                                           -> Text.ParserCombinators.ReadP.P a_a3nLq
                                                      [LclId] =
                                                          [wild1_s3rKq r_s3rKN] \r [s_s3rKO]
                                                              let {
                                                                sat_s3rKQ [Occ=Once]
                                                                  :: [(a_a3nLq, GHC.Base.String)]
                                                                [LclId] =
                                                                    [wild1_s3rKq
                                                                     r_s3rKN
                                                                     s_s3rKO] \u []
                                                                        case
                                                                            Text.ParserCombinators.ReadP.run
                                                                                wild1_s3rKq s_s3rKO
                                                                        of
                                                                        sat_s3rKP
                                                                        { __DEFAULT ->
                                                                              GHC.Base.++
                                                                                  sat_s3rKP r_s3rKN;
                                                                        };
                                                              } in 
                                                                Text.ParserCombinators.ReadP.Final [sat_s3rKQ];
                                                    } in 
                                                      Text.ParserCombinators.ReadP.Look [sat_s3rKR];
                                              };
                                    } in 
                                      case wild1_s3rKq of {
                                        __DEFAULT -> fail1_s3rKs GHC.Prim.void#;
                                        Text.ParserCombinators.ReadP.Look f_s3rKT [Occ=OnceL!] ->
                                            case wild2_s3rKr of {
                                              __DEFAULT -> fail1_s3rKs GHC.Prim.void#;
                                              Text.ParserCombinators.ReadP.Final r_s3rKV [Occ=OnceL] ->
                                                  let {
                                                    sat_s3rL0 [Occ=Once]
                                                      :: GHC.Base.String
                                                         -> Text.ParserCombinators.ReadP.P a_a3nLq
                                                    [LclId] =
                                                        [f_s3rKT r_s3rKV] \r [s_s3rKW]
                                                            let {
                                                              sat_s3rKZ [Occ=Once]
                                                                :: [(a_a3nLq, GHC.Base.String)]
                                                              [LclId] =
                                                                  [f_s3rKT r_s3rKV s_s3rKW] \u []
                                                                      case
                                                                          f_s3rKT s_s3rKW
                                                                      of
                                                                      sat_s3rKX
                                                                      { __DEFAULT ->
                                                                            case
                                                                                Text.ParserCombinators.ReadP.run
                                                                                    sat_s3rKX
                                                                                    s_s3rKW
                                                                            of
                                                                            sat_s3rKY
                                                                            { __DEFAULT ->
                                                                                  GHC.Base.++
                                                                                      sat_s3rKY
                                                                                      r_s3rKV;
                                                                            };
                                                                      };
                                                            } in 
                                                              Text.ParserCombinators.ReadP.Final [sat_s3rKZ];
                                                  } in 
                                                    Text.ParserCombinators.ReadP.Look [sat_s3rL0];
                                            };
                                        Text.ParserCombinators.ReadP.Final r_s3rL1 [Occ=OnceL*] ->
                                            case wild2_s3rKr of wild4_s3rL2 {
                                              Text.ParserCombinators.ReadP.Get _ [Occ=Dead] ->
                                                  let {
                                                    sat_s3rL7 [Occ=Once]
                                                      :: GHC.Base.String
                                                         -> Text.ParserCombinators.ReadP.P a_a3nLq
                                                    [LclId] =
                                                        [r_s3rL1 wild4_s3rL2] \r [s_s3rL4]
                                                            let {
                                                              sat_s3rL6 [Occ=Once]
                                                                :: [(a_a3nLq, GHC.Base.String)]
                                                              [LclId] =
                                                                  [r_s3rL1
                                                                   wild4_s3rL2
                                                                   s_s3rL4] \u []
                                                                      let {
                                                                        sat_s3rL5 [Occ=Once,
                                                                                   Dmd=<L,1*U>]
                                                                          :: [(a_a3nLq,
                                                                               GHC.Base.String)]
                                                                        [LclId] =
                                                                            [wild4_s3rL2
                                                                             s_s3rL4] \s []
                                                                                Text.ParserCombinators.ReadP.run
                                                                                    wild4_s3rL2
                                                                                    s_s3rL4;
                                                                      } in 
                                                                        GHC.Base.++
                                                                            r_s3rL1 sat_s3rL5;
                                                            } in 
                                                              Text.ParserCombinators.ReadP.Final [sat_s3rL6];
                                                  } in 
                                                    Text.ParserCombinators.ReadP.Look [sat_s3rL7];
                                              Text.ParserCombinators.ReadP.Look f_s3rL8 [Occ=OnceL!] ->
                                                  let {
                                                    sat_s3rLd [Occ=Once]
                                                      :: GHC.Base.String
                                                         -> Text.ParserCombinators.ReadP.P a_a3nLq
                                                    [LclId] =
                                                        [r_s3rL1 f_s3rL8] \r [s_s3rL9]
                                                            let {
                                                              sat_s3rLc [Occ=Once]
                                                                :: [(a_a3nLq, GHC.Base.String)]
                                                              [LclId] =
                                                                  [r_s3rL1 f_s3rL8 s_s3rL9] \u []
                                                                      let {
                                                                        sat_s3rLb [Occ=Once,
                                                                                   Dmd=<L,1*U>]
                                                                          :: [(a_a3nLq,
                                                                               GHC.Base.String)]
                                                                        [LclId] =
                                                                            [f_s3rL8 s_s3rL9] \s []
                                                                                case
                                                                                    f_s3rL8 s_s3rL9
                                                                                of
                                                                                sat_s3rLa
                                                                                { __DEFAULT ->
                                                                                      Text.ParserCombinators.ReadP.run
                                                                                          sat_s3rLa
                                                                                          s_s3rL9;
                                                                                };
                                                                      } in 
                                                                        GHC.Base.++
                                                                            r_s3rL1 sat_s3rLb;
                                                            } in 
                                                              Text.ParserCombinators.ReadP.Final [sat_s3rLc];
                                                  } in 
                                                    Text.ParserCombinators.ReadP.Look [sat_s3rLd];
                                              Text.ParserCombinators.ReadP.Final t_s3rLe [Occ=Once] ->
                                                  let {
                                                    sat_s3rLf [Occ=Once]
                                                      :: [(a_a3nLq, GHC.Base.String)]
                                                    [LclId] =
                                                        [r_s3rL1 t_s3rLe] \u []
                                                            GHC.Base.++ r_s3rL1 t_s3rLe;
                                                  } in 
                                                    Text.ParserCombinators.ReadP.Final [sat_s3rLf];
                                            };
                                      };
                                Text.ParserCombinators.ReadP.Fail -> wild1_s3rKq;
                              };
                          Text.ParserCombinators.ReadP.Fail -> wild_s3rKp;
                        };
                    Text.ParserCombinators.ReadP.Result x_s3rLg [Occ=Once]
                                                        q_s3rLh [Occ=Once] ->
                        let {
                          sat_s3rLi [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nLq
                          [LclId] =
                              [ds_s3rKl q_s3rLh] \u []
                                  Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                      ds_s3rKl q_s3rLh;
                        } in  Text.ParserCombinators.ReadP.Result [x_s3rLg sat_s3rLi];
                  };
        } in 
          case ds_s3rKl of {
            __DEFAULT -> fail_s3rKn GHC.Prim.void#;
            Text.ParserCombinators.ReadP.Get f1_s3rLk [Occ=OnceL!] ->
                case ds1_s3rKm of {
                  __DEFAULT -> fail_s3rKn GHC.Prim.void#;
                  Text.ParserCombinators.ReadP.Get f2_s3rLm [Occ=OnceL!] ->
                      let {
                        sat_s3rLq [Occ=Once]
                          :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P a_a3nLq
                        [LclId] =
                            [f1_s3rLk f2_s3rLm] \r [c_s3rLn]
                                let {
                                  sat_s3rLp [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nLq
                                  [LclId] =
                                      [f2_s3rLm c_s3rLn] \u [] f2_s3rLm c_s3rLn;
                                } in 
                                  case f1_s3rLk c_s3rLn of sat_s3rLo {
                                    __DEFAULT ->
                                        Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                            sat_s3rLo sat_s3rLp;
                                  };
                      } in  Text.ParserCombinators.ReadP.Get [sat_s3rLq];
                };
            Text.ParserCombinators.ReadP.Result x_s3rLr [Occ=Once]
                                                p_s3rLs [Occ=Once] ->
                let {
                  sat_s3rLt [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nLq
                  [LclId] =
                      [ds1_s3rKm p_s3rLs] \u []
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                              p_s3rLs ds1_s3rKm;
                } in  Text.ParserCombinators.ReadP.Result [x_s3rLr sat_s3rLt];
          };

Text.ParserCombinators.ReadP.$fAlternativeP_$c>>= [Occ=LoopBreaker]
  :: forall a b.
     Text.ParserCombinators.ReadP.P a
     -> (a -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,1*U><L,C(U)>, Unf=OtherCon []] =
    [] \r [ds_s3rLu k_s3rLv]
        case ds_s3rLu of {
          Text.ParserCombinators.ReadP.Get f_s3rLx [Occ=OnceL!] ->
              let {
                sat_s3rLA [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_a3nML
                [LclId] =
                    [k_s3rLv f_s3rLx] \r [c_s3rLy]
                        case f_s3rLx c_s3rLy of sat_s3rLz {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                  sat_s3rLz k_s3rLv;
                        };
              } in  Text.ParserCombinators.ReadP.Get [sat_s3rLA];
          Text.ParserCombinators.ReadP.Look f_s3rLB [Occ=OnceL!] ->
              let {
                sat_s3rLE [Occ=Once]
                  :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3nML
                [LclId] =
                    [k_s3rLv f_s3rLB] \r [s_s3rLC]
                        case f_s3rLB s_s3rLC of sat_s3rLD {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                  sat_s3rLD k_s3rLv;
                        };
              } in  Text.ParserCombinators.ReadP.Look [sat_s3rLE];
          Text.ParserCombinators.ReadP.Fail ->
              Text.ParserCombinators.ReadP.Fail [];
          Text.ParserCombinators.ReadP.Result x_s3rLF [Occ=Once]
                                              p_s3rLG [Occ=Once] ->
              let {
                sat_s3rLI [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nML
                [LclId] =
                    [k_s3rLv p_s3rLG] \u []
                        Text.ParserCombinators.ReadP.$fAlternativeP_$c>>= p_s3rLG k_s3rLv;
              } in 
                case k_s3rLv x_s3rLF of sat_s3rLH {
                  __DEFAULT ->
                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                          sat_s3rLH sat_s3rLI;
                };
          Text.ParserCombinators.ReadP.Final r_s3rLJ [Occ=Once] ->
              let {
                go_s3rLK [Occ=LoopBreaker]
                  :: [(a_a3nMK, GHC.Base.String)] -> [(b_a3nML, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [k_s3rLv go_s3rLK] \r [ds1_s3rLL]
                        case ds1_s3rLL of {
                          [] -> [] [];
                          : y_s3rLN [Occ=Once!] ys_s3rLO [Occ=Once] ->
                              case y_s3rLN of {
                                (,) x_s3rLQ [Occ=Once] s_s3rLR [Occ=Once] ->
                                    let {
                                      sat_s3rLU [Occ=Once, Dmd=<L,1*U>]
                                        :: [(b_a3nML, GHC.Base.String)]
                                      [LclId] =
                                          [go_s3rLK ys_s3rLO] \s [] go_s3rLK ys_s3rLO;
                                    } in 
                                      case k_s3rLv x_s3rLQ of sat_s3rLS {
                                        __DEFAULT ->
                                            case
                                                Text.ParserCombinators.ReadP.run sat_s3rLS s_s3rLR
                                            of
                                            sat_s3rLT
                                            { __DEFAULT -> GHC.Base.++ sat_s3rLT sat_s3rLU;
                                            };
                                      };
                              };
                        };
              } in 
                case go_s3rLK r_s3rLJ of wild1_s3rLV {
                  [] -> Text.ParserCombinators.ReadP.Fail [];
                  : _ [Occ=Dead] _ [Occ=Dead] ->
                      Text.ParserCombinators.ReadP.Final [wild1_s3rLV];
                };
        };

Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
  :: forall a b.
     Text.ParserCombinators.ReadP.P (a -> b)
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [m1_s3rLY m2_s3rLZ]
        let {
          sat_s3rM4 [Occ=Once]
            :: (a_a3nOe -> b_a3nOf) -> Text.ParserCombinators.ReadP.P b_a3nOf
          [LclId] =
              [m2_s3rLZ] \r [x1_s3rM0]
                  let {
                    sat_s3rM3 [Occ=Once]
                      :: a_a3nOe -> Text.ParserCombinators.ReadP.P b_a3nOf
                    [LclId] =
                        [x1_s3rM0] \r [x2_s3rM1]
                            let {
                              sat_s3rM2 [Occ=Once] :: b_a3nOf
                              [LclId] =
                                  [x1_s3rM0 x2_s3rM1] \u [] x1_s3rM0 x2_s3rM1;
                            } in 
                              Text.ParserCombinators.ReadP.Result [sat_s3rM2
                                                                   Text.ParserCombinators.ReadP.Fail];
                  } in 
                    Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                        m2_s3rLZ sat_s3rM3;
        } in 
          Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
              m1_s3rLY sat_s3rM4;

Text.ParserCombinators.ReadP.$fApplicativeP_$cliftA2
  :: forall a b c.
     (a -> b -> c)
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P c
[GblId, Arity=2, Str=<L,C(U)><L,1*U>, Unf=OtherCon []] =
    [] \r [f1_s3rM5 x_s3rM6]
        let {
          sat_s3rM7 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (b_a3nOq -> c_a3nOr)
          [LclId] =
              [f1_s3rM5 x_s3rM6] \u []
                  Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                      f1_s3rM5 x_s3rM6;
        } in  Text.ParserCombinators.ReadP.$fAlternativeP_$c<*> sat_s3rM7;

Text.ParserCombinators.ReadP.$fAlternativeP1
  :: forall a. Text.ParserCombinators.ReadP.P [a]
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.ParserCombinators.ReadP.Result! [GHC.Types.[]
                                                        Text.ParserCombinators.ReadP.Fail];

Text.ParserCombinators.ReadP.$fAlternativeP_$csome
  :: forall a.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P [a]
[GblId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_s3rM8]
        let {
          some_v_s3rM9 [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadP.P [a_a3nMc]
          [LclId] =
              [v_s3rM8 some_v_s3rM9] \u []
                  let {
                    m2_s3rMa [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_a3nMc]
                    [LclId] =
                        [some_v_s3rM9] \u []
                            Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                some_v_s3rM9 Text.ParserCombinators.ReadP.$fAlternativeP1; } in
                  let {
                    sat_s3rMg [Occ=Once]
                      :: ([a_a3nMc] -> [a_a3nMc])
                         -> Text.ParserCombinators.ReadP.P [a_a3nMc]
                    [LclId] =
                        [m2_s3rMa] \r [x1_s3rMc]
                            let {
                              sat_s3rMf [Occ=Once]
                                :: [a_a3nMc] -> Text.ParserCombinators.ReadP.P [a_a3nMc]
                              [LclId] =
                                  [x1_s3rMc] \r [x2_s3rMd]
                                      let {
                                        sat_s3rMe [Occ=Once] :: [a_a3nMc]
                                        [LclId] =
                                            [x1_s3rMc x2_s3rMd] \u [] x1_s3rMc x2_s3rMd;
                                      } in 
                                        Text.ParserCombinators.ReadP.Result [sat_s3rMe
                                                                             Text.ParserCombinators.ReadP.Fail];
                            } in 
                              Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                  m2_s3rMa sat_s3rMf;
                  } in 
                    case
                        Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                            GHC.Types.: v_s3rM8
                    of
                    sat_s3rMb
                    { __DEFAULT ->
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                              sat_s3rMb sat_s3rMg;
                    };
        } in  some_v_s3rM9;

Text.ParserCombinators.ReadP.$fApplicativeP_$c<*
  :: forall a b.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=1, Str=<L,1*U>, Unf=OtherCon []] =
    [] \r [x_s3rMh]
        let {
          sat_s3rMi [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (b_a3nOM -> a_a3nOL)
          [LclId] =
              [x_s3rMh] \u []
                  Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                      GHC.Base.const x_s3rMh;
        } in  Text.ParserCombinators.ReadP.$fAlternativeP_$c<*> sat_s3rMi;

Text.ParserCombinators.ReadP.$fApplicativeP_$c*>
  :: forall a b.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [a1_s3rMj a2_s3rMk]
        case
            Text.ParserCombinators.ReadP.$fApplicativeP_$c<$
                GHC.Base.breakpoint a1_s3rMj
        of
        sat_s3rMl
        { __DEFAULT ->
              Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
                  sat_s3rMl a2_s3rMk;
        };

Text.ParserCombinators.ReadP.$fAlternativeP_$cmany
  :: forall a.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P [a]
[GblId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_s3rMm]
        let {
          many_v_s3rMn [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadP.P [a_a3nMk]
          [LclId] =
              [v_s3rMm many_v_s3rMn] \u []
                  case
                      Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                          GHC.Types.: v_s3rMm
                  of
                  sat_s3rMo
                  { __DEFAULT ->
                        case
                            Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
                                sat_s3rMo many_v_s3rMn
                        of
                        sat_s3rMp
                        { __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                  sat_s3rMp Text.ParserCombinators.ReadP.$fAlternativeP1;
                        };
                  };
        } in  many_v_s3rMn;

Text.ParserCombinators.ReadP.$fMonadP_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [eta_s3rMq eta1_s3rMr]
        let {
          sat_s3rMt [Occ=Once]
            :: a_a3nNd -> Text.ParserCombinators.ReadP.P b_a3nNe
          [LclId] =
              [eta1_s3rMr] \r [ds_s3rMs] eta1_s3rMr;
        } in 
          Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
              eta_s3rMq sat_s3rMt;

Text.ParserCombinators.ReadP.$fApplicativeP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Text.ParserCombinators.ReadP.$fFunctorP
                                           Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                                           Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
                                           Text.ParserCombinators.ReadP.$fApplicativeP_$cliftA2
                                           Text.ParserCombinators.ReadP.$fApplicativeP_$c*>
                                           Text.ParserCombinators.ReadP.$fApplicativeP_$c<*];

Text.ParserCombinators.ReadP.$fMonadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Text.ParserCombinators.ReadP.$fApplicativeP
                                     Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                     Text.ParserCombinators.ReadP.$fMonadP_$c>>
                                     Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                                     Text.ParserCombinators.ReadP.$fMonadFailP_$cfail];

Text.ParserCombinators.ReadP.$fAlternativeP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Text.ParserCombinators.ReadP.$fApplicativeP
                                           Text.ParserCombinators.ReadP.Fail
                                           Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                           Text.ParserCombinators.ReadP.$fAlternativeP_$csome
                                           Text.ParserCombinators.ReadP.$fAlternativeP_$cmany];

Text.ParserCombinators.ReadP.readP_to_S
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadS a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [ds_s3rMu]
        let {
          sat_s3rMv [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nDT
          [LclId] =
              [ds_s3rMu] \u []
                  ds_s3rMu Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s3rMv;

Text.ParserCombinators.ReadP.$fMonadFailP [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fail.C:MonadFail! [Text.ParserCombinators.ReadP.$fMonadP
                                                   Text.ParserCombinators.ReadP.$fMonadFailP_$cfail];

Text.ParserCombinators.ReadP.$fMonadPlusP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [Text.ParserCombinators.ReadP.$fAlternativeP
                                         Text.ParserCombinators.ReadP.$fMonadP
                                         Text.ParserCombinators.ReadP.Fail
                                         Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>];

Text.ParserCombinators.ReadP.get
  :: Text.ParserCombinators.ReadP.ReadP GHC.Types.Char
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m1, Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Get [eta_B1];

Text.ParserCombinators.ReadP.look
  :: Text.ParserCombinators.ReadP.ReadP GHC.Base.String
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Look [eta_B1];

Text.ParserCombinators.ReadP.$fAlternativeReadP4
  :: forall a b.
     (a -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s3rMw] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadP.pfail
  :: forall a. Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.$fAlternativeReadP4 eta_B1;

Text.ParserCombinators.ReadP.$fAlternativeReadP3
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3rMx ds1_s3rMy k_s3rMz]
        let {
          sat_s3rMB [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
          [LclId] =
              [ds1_s3rMy k_s3rMz] \u [] ds1_s3rMy k_s3rMz;
        } in 
          case ds_s3rMx k_s3rMz of sat_s3rMA {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3rMA sat_s3rMB;
          };

Text.ParserCombinators.ReadP.+++
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.$fAlternativeReadP3
            eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.choice [Occ=LoopBreaker]
  :: forall a.
     [Text.ParserCombinators.ReadP.ReadP a]
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s3rMC]
        case ds_s3rMC of {
          [] -> Text.ParserCombinators.ReadP.$fAlternativeReadP4;
          : p_s3rME [Occ=OnceL*] ds1_s3rMF [Occ=Once!] ->
              case ds1_s3rMF of wild1_s3rMG {
                [] -> p_s3rME;
                : _ [Occ=Dead] _ [Occ=Dead] ->
                    let {
                      ds2_s3rMJ [Occ=OnceL, Dmd=<L,C(U)>]
                        :: Text.ParserCombinators.ReadP.ReadP a_a3nzc
                      [LclId] =
                          [wild1_s3rMG] \u []
                              Text.ParserCombinators.ReadP.choice wild1_s3rMG; } in
                    let {
                      sat_s3rMN [Occ=Once]
                        :: forall b.
                           (a_a3nzc -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b
                      [LclId] =
                          [p_s3rME ds2_s3rMJ] \r [k_s3rMK]
                              let {
                                sat_s3rMM [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
                                [LclId] =
                                    [ds2_s3rMJ k_s3rMK] \u [] ds2_s3rMJ k_s3rMK;
                              } in 
                                case p_s3rME k_s3rMK of sat_s3rML {
                                  __DEFAULT ->
                                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                          sat_s3rML sat_s3rMM;
                                };
                    } in  sat_s3rMN;
              };
        };

lvl2_r3oqG :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "do not use readS_to_P in gather!"#;

lvl3_r3oqH :: forall b. Text.ParserCombinators.ReadP.P b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_r3oqG of sat_s3rMO {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s3rMO;
        };

Text.ParserCombinators.ReadP.gather_gath [Occ=LoopBreaker]
  :: forall b.
     (GHC.Base.String -> GHC.Base.String)
     -> Text.ParserCombinators.ReadP.P
          (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,C(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [l_s3rMP ds_s3rMQ]
        case ds_s3rMQ of {
          Text.ParserCombinators.ReadP.Get f_s3rMS [Occ=OnceL!] ->
              let {
                sat_s3rMY [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_a3nv3
                [LclId] =
                    [l_s3rMP f_s3rMS] \r [c_s3rMT]
                        case f_s3rMS c_s3rMT of sat_s3rMX {
                          __DEFAULT ->
                              let {
                                sat_s3rMW [Occ=Once] :: GHC.Base.String -> GHC.Base.String
                                [LclId] =
                                    [l_s3rMP c_s3rMT] \r [x_s3rMU]
                                        let {
                                          sat_s3rMV [Occ=Once] :: GHC.Base.String
                                          [LclId] =
                                              CCCS :! [c_s3rMT x_s3rMU];
                                        } in  l_s3rMP sat_s3rMV;
                              } in  Text.ParserCombinators.ReadP.gather_gath sat_s3rMW sat_s3rMX;
                        };
              } in  Text.ParserCombinators.ReadP.Get [sat_s3rMY];
          Text.ParserCombinators.ReadP.Look f_s3rMZ [Occ=OnceL!] ->
              let {
                sat_s3rN2 [Occ=Once]
                  :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3nv3
                [LclId] =
                    [l_s3rMP f_s3rMZ] \r [s_s3rN0]
                        case f_s3rMZ s_s3rN0 of sat_s3rN1 {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.gather_gath l_s3rMP sat_s3rN1;
                        };
              } in  Text.ParserCombinators.ReadP.Look [sat_s3rN2];
          Text.ParserCombinators.ReadP.Fail ->
              Text.ParserCombinators.ReadP.Fail [];
          Text.ParserCombinators.ReadP.Result k_s3rN3 [Occ=Once!]
                                              p_s3rN4 [Occ=Once] ->
              let {
                sat_s3rN7 [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nv3
                [LclId] =
                    [l_s3rMP p_s3rN4] \u []
                        Text.ParserCombinators.ReadP.gather_gath l_s3rMP p_s3rN4; } in
              let {
                sat_s3rN5 [Occ=Once] :: GHC.Base.String
                [LclId] =
                    [l_s3rMP] \u [] l_s3rMP GHC.Types.[];
              } in 
                case k_s3rN3 sat_s3rN5 of sat_s3rN6 {
                  __DEFAULT ->
                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                          sat_s3rN6 sat_s3rN7;
                };
          Text.ParserCombinators.ReadP.Final _ [Occ=Dead] -> lvl3_r3oqH;
        };

Text.ParserCombinators.ReadP.gather1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ((GHC.Base.String, a) -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),1*C1(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [ds_s3rN9 eta_s3rNa]
        let {
          sat_s3rNf [Occ=Once]
            :: a_a3nuK
               -> Text.ParserCombinators.ReadP.P
                    (GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3ngn)
          [LclId] =
              [eta_s3rNa] \r [a1_s3rNb]
                  let {
                    sat_s3rNe [Occ=Once]
                      :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [eta_s3rNa a1_s3rNb] \r [s_s3rNc]
                            let {
                              sat_s3rNd [Occ=Once] :: (GHC.Base.String, a_a3nuK)
                              [LclId] =
                                  CCCS (,)! [s_s3rNc a1_s3rNb];
                            } in  eta_s3rNa sat_s3rNd;
                  } in 
                    Text.ParserCombinators.ReadP.Result [sat_s3rNe
                                                         Text.ParserCombinators.ReadP.Fail];
        } in 
          case ds_s3rN9 sat_s3rNf of sat_s3rNg {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.gather_gath GHC.Base.id sat_s3rNg;
          };

Text.ParserCombinators.ReadP.gather
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (GHC.Base.String, a)
[GblId, Arity=2, Str=<C(S),1*C1(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.gather1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Text.ParserCombinators.ReadP.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$trModule4];

Text.ParserCombinators.ReadP.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Text.ParserCombinators.ReadP"#;

Text.ParserCombinators.ReadP.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$trModule2];

Text.ParserCombinators.ReadP.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Text.ParserCombinators.ReadP.$trModule3
                                     Text.ParserCombinators.ReadP.$trModule1];

$krep_r3oqI :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcChar
                                              GHC.Types.[]];

$krep1_r3oqJ :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r3oqI GHC.Types.[]];

$krep2_r3oqK :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc[]
                                              $krep1_r3oqJ];

$krep3_r3oqL :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep4_r3oqM :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_r3oqK GHC.Types.[]];

$krep5_r3oqN :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r3oqL $krep4_r3oqM];

$krep6_r3oqO :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Tuple.$tc(,)
                                              $krep5_r3oqN];

$krep7_r3oqP :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep6_r3oqO GHC.Types.[]];

$krep8_r3oqQ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc[]
                                              $krep7_r3oqP];

Text.ParserCombinators.ReadP.$tcP2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "P"#;

Text.ParserCombinators.ReadP.$tcP1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tcP2];

Text.ParserCombinators.ReadP.$tcP :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4287589432649596960##
                                    9029773818181158220##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tcP1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep9_r3oqR :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r3oqL GHC.Types.[]];

Text.ParserCombinators.ReadP.$tc'Fail1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Text.ParserCombinators.ReadP.$tcP
                                              $krep9_r3oqR];

Text.ParserCombinators.ReadP.$tc'Fail3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Fail"#;

Text.ParserCombinators.ReadP.$tc'Fail2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Fail3];

Text.ParserCombinators.ReadP.$tc'Fail :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16564457091671581868##
                                    4540703186775139959##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Fail2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Fail1];

$krep10_r3oqS :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [Text.ParserCombinators.ReadP.$tc'Fail1
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Result1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r3oqL $krep10_r3oqS];

Text.ParserCombinators.ReadP.$tc'Result3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Result"#;

Text.ParserCombinators.ReadP.$tc'Result2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Result3];

Text.ParserCombinators.ReadP.$tc'Result :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14629176799732153257##
                                    2029199220309899277##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Result2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Result1];

Text.ParserCombinators.ReadP.$tc'Final1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r3oqQ
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Final3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Final"#;

Text.ParserCombinators.ReadP.$tc'Final2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Final3];

Text.ParserCombinators.ReadP.$tc'Final :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9825883373667767852##
                                    1277540149077833820##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Final2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Final1];

$krep11_r3oqT :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r3oqK
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Look1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r3oqT
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Look3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Look"#;

Text.ParserCombinators.ReadP.$tc'Look2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Look3];

Text.ParserCombinators.ReadP.$tc'Look :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11302519862508684236##
                                    969530656846011597##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Look2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Look1];

$krep12_r3oqU :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r3oqI
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Get1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep12_r3oqU
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Get3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Get"#;

Text.ParserCombinators.ReadP.$tc'Get2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Get3];

Text.ParserCombinators.ReadP.$tc'Get :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10806119809527641225##
                                    14618661019746688366##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Get2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Get1];

Text.ParserCombinators.ReadP.$tcReadP2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ReadP"#;

Text.ParserCombinators.ReadP.$tcReadP1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tcReadP2];

Text.ParserCombinators.ReadP.$tcReadP :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15640243629783811470##
                                    8988027559298507146##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tcReadP1
                                    0#
                                    GHC.Types.krep$*Arr*];

Text.ParserCombinators.ReadP.$fApplicativeReadP4
  :: forall b a.
     Text.ParserCombinators.ReadP.ReadP (a -> b)
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [m1_s3rNh m2_s3rNi k_s3rNj]
        let {
          sat_s3rNo [Occ=Once]
            :: (a_a3nK0 -> b_a3nK1) -> Text.ParserCombinators.ReadP.P b1_a3nIU
          [LclId] =
              [m2_s3rNi k_s3rNj] \r [a1_s3rNk]
                  let {
                    sat_s3rNn [Occ=Once]
                      :: a_a3nK0 -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [k_s3rNj a1_s3rNk] \r [a2_s3rNl]
                            let {
                              sat_s3rNm [Occ=Once] :: b_a3nK1
                              [LclId] =
                                  [a1_s3rNk a2_s3rNl] \u [] a1_s3rNk a2_s3rNl;
                            } in  k_s3rNj sat_s3rNm;
                  } in  m2_s3rNi sat_s3rNn;
        } in  m1_s3rNh sat_s3rNo;

Text.ParserCombinators.ReadP.$fApplicativeReadP2
  :: forall a b.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [a1_s3rNp a2_s3rNq eta_s3rNr]
        let {
          lvl4_s3rNs [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [a2_s3rNq eta_s3rNr] \u []
                  let {
                    sat_s3rNu [Occ=Once]
                      :: b_a3nKt -> Text.ParserCombinators.ReadP.P b1_a3ngn
                    [LclId] =
                        [eta_s3rNr] \r [a4_s3rNt] eta_s3rNr a4_s3rNt;
                  } in  a2_s3rNq sat_s3rNu; } in
        let {
          sat_s3rNw [Occ=Once]
            :: a_a3nKs -> Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [lvl4_s3rNs] \r [x_s3rNv] lvl4_s3rNs;
        } in  a1_s3rNp sat_s3rNw;

Text.ParserCombinators.ReadP.$fApplicativeReadP3
  :: forall a b c.
     (a -> b -> c)
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (c -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C(U))><C(S),1*C1(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [f1_s3rNx x_s3rNy eta_s3rNz eta1_s3rNA]
        let {
          sat_s3rNG [Occ=Once]
            :: a_a3nKg -> Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [f1_s3rNx eta_s3rNz eta1_s3rNA] \r [x1_s3rNB]
                  let {
                    a1_s3rNC [Occ=OnceL!, Dmd=<L,C(U)>] :: b_a3nKh -> c_a3nKi
                    [LclId] =
                        [f1_s3rNx x1_s3rNB] \u [] f1_s3rNx x1_s3rNB; } in
                  let {
                    sat_s3rNF [Occ=Once]
                      :: b_a3nKh -> Text.ParserCombinators.ReadP.P b1_a3ngn
                    [LclId] =
                        [eta1_s3rNA a1_s3rNC] \r [a2_s3rND]
                            let {
                              sat_s3rNE [Occ=Once] :: c_a3nKi
                              [LclId] =
                                  [a1_s3rNC a2_s3rND] \u [] a1_s3rNC a2_s3rND;
                            } in  eta1_s3rNA sat_s3rNE;
                  } in  eta_s3rNz sat_s3rNF;
        } in  x_s3rNy sat_s3rNG;

Text.ParserCombinators.ReadP.$fApplicativeReadP1
  :: forall b a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (a -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [x_s3rNH eta_s3rNI eta1_s3rNJ]
        let {
          sat_s3rNO [Occ=Once]
            :: a_a3nKC -> Text.ParserCombinators.ReadP.P b1_X3nkp
          [LclId] =
              [eta_s3rNI eta1_s3rNJ] \r [x1_s3rNK]
                  let {
                    lvl4_s3rNL [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_X3nkp
                    [LclId] =
                        [eta1_s3rNJ x1_s3rNK] \u [] eta1_s3rNJ x1_s3rNK; } in
                  let {
                    sat_s3rNN [Occ=Once]
                      :: b_a3nKD -> Text.ParserCombinators.ReadP.P b1_X3nkp
                    [LclId] =
                        [lvl4_s3rNL] \r [a1_s3rNM] lvl4_s3rNL;
                  } in  eta_s3rNI sat_s3rNN;
        } in  x_s3rNH sat_s3rNO;

$c>>_r3oqV
  :: forall a b.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [eta_s3rNP eta1_s3rNQ k_s3rNR]
        let {
          lvl4_s3rNS [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
          [LclId] =
              [eta1_s3rNQ k_s3rNR] \u [] eta1_s3rNQ k_s3rNR; } in
        let {
          sat_s3rNU [Occ=Once]
            :: a_a3nJi -> Text.ParserCombinators.ReadP.P b1_a3nIU
          [LclId] =
              [lvl4_s3rNS] \r [a1_s3rNT] lvl4_s3rNS;
        } in  eta_s3rNP sat_s3rNU;

Text.ParserCombinators.ReadP.$fMonadReadP_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] $c>>_r3oqV eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$fApplicativeReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Text.ParserCombinators.ReadP.$fFunctorReadP
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP5
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP4
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP3
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP2
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP1];

Text.ParserCombinators.ReadP.$fMonadReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Text.ParserCombinators.ReadP.$fApplicativeReadP
                                     Text.ParserCombinators.ReadP.$fMonadReadP1
                                     Text.ParserCombinators.ReadP.$fMonadReadP_$c>>
                                     Text.ParserCombinators.ReadP.$fApplicativeReadP5
                                     Text.ParserCombinators.ReadP.$fMonadFailReadP1];

Text.ParserCombinators.ReadP.between1
  :: forall open close a.
     Text.ParserCombinators.ReadP.ReadP open
     -> Text.ParserCombinators.ReadP.ReadP close
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,1*C1(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [open1_s3rNV close1_s3rNW p_s3rNX k_s3rNY]
        let {
          lvl4_s3rNZ [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3nIU
          [LclId] =
              [close1_s3rNW p_s3rNX k_s3rNY] \u []
                  let {
                    sat_s3rO4 [Occ=Once]
                      :: a_a3nui -> Text.ParserCombinators.ReadP.P b_a3nIU
                    [LclId] =
                        [close1_s3rNW k_s3rNY] \r [a1_s3rO0]
                            let {
                              lvl5_s3rO1 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3nIU
                              [LclId] =
                                  [k_s3rNY a1_s3rO0] \u [] k_s3rNY a1_s3rO0; } in
                            let {
                              sat_s3rO3 [Occ=Once]
                                :: close_a3nuh -> Text.ParserCombinators.ReadP.P b_a3nIU
                              [LclId] =
                                  [lvl5_s3rO1] \r [a2_s3rO2] lvl5_s3rO1;
                            } in  close1_s3rNW sat_s3rO3;
                  } in  p_s3rNX sat_s3rO4; } in
        let {
          sat_s3rO6 [Occ=Once]
            :: open_a3nug -> Text.ParserCombinators.ReadP.P b_a3nIU
          [LclId] =
              [lvl4_s3rNZ] \r [a1_s3rO5] lvl4_s3rNZ;
        } in  open1_s3rNV sat_s3rO6;

Text.ParserCombinators.ReadP.between
  :: forall open close a.
     Text.ParserCombinators.ReadP.ReadP open
     -> Text.ParserCombinators.ReadP.ReadP close
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,1*C1(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.between1 eta_B4 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$wcount [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Prim.Int#
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,U><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [ww_s3rO7 w_s3rO8 w1_s3rO9]
        case <# [0# ww_s3rO7] of {
          __DEFAULT -> w1_s3rO9 GHC.Types.[];
          1# ->
              let {
                $wxs_s3rOb [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                  :: GHC.Prim.Int#
                     -> forall b1.
                        ([a_s3ogB] -> Text.ParserCombinators.ReadP.P b1)
                        -> Text.ParserCombinators.ReadP.P b1
                [LclId, Arity=2, Str=<S,1*U><L,C(U)>, Unf=OtherCon []] =
                    sat-only [w_s3rO8 $wxs_s3rOb] \r [ww1_s3rOc w2_s3rOd]
                        case ww1_s3rOc of ds1_s3rOe {
                          __DEFAULT ->
                              case -# [ds1_s3rOe 1#] of r_s3rOf {
                                __DEFAULT ->
                                    let {
                                      sat_s3rOk [Occ=Once]
                                        :: a_s3ogB -> Text.ParserCombinators.ReadP.P b1_s3ogu
                                      [LclId] =
                                          [$wxs_s3rOb w2_s3rOd r_s3rOf] \r [a1_s3rOg]
                                              let {
                                                sat_s3rOj [Occ=Once]
                                                  :: [a_s3ogB]
                                                     -> Text.ParserCombinators.ReadP.P b1_s3ogu
                                                [LclId] =
                                                    [w2_s3rOd a1_s3rOg] \r [a2_s3rOh]
                                                        let {
                                                          sat_s3rOi [Occ=Once] :: [a_s3ogB]
                                                          [LclId] =
                                                              CCCS :! [a1_s3rOg a2_s3rOh];
                                                        } in  w2_s3rOd sat_s3rOi;
                                              } in  $wxs_s3rOb r_s3rOf sat_s3rOj;
                                    } in  w_s3rO8 sat_s3rOk;
                              };
                          1# ->
                              let {
                                sat_s3rOn [Occ=Once]
                                  :: a_s3ogB -> Text.ParserCombinators.ReadP.P b1_s3ogu
                                [LclId] =
                                    [w2_s3rOd] \r [a1_s3rOl]
                                        let {
                                          sat_s3rOm [Occ=Once] :: [a_s3ogB]
                                          [LclId] =
                                              CCCS :! [a1_s3rOl GHC.Types.[]];
                                        } in  w2_s3rOd sat_s3rOm;
                              } in  w_s3rO8 sat_s3rOn;
                        };
              } in  $wxs_s3rOb ww_s3rO7 w1_s3rO9;
        };

Text.ParserCombinators.ReadP.count1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3rOo w1_s3rOp w2_s3rOq]
        case w_s3rOo of {
          GHC.Types.I# ww1_s3rOs [Occ=Once] ->
              Text.ParserCombinators.ReadP.$wcount ww1_s3rOs w1_s3rOp w2_s3rOq;
        };

Text.ParserCombinators.ReadP.count
  :: forall a.
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.count1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.option1
  :: forall a.
     a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
    [] \r [x_s3rOt p_s3rOu eta_s3rOv]
        let {
          sat_s3rOx [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [x_s3rOt eta_s3rOv] \u [] eta_s3rOv x_s3rOt;
        } in 
          case p_s3rOu eta_s3rOv of sat_s3rOw {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3rOw sat_s3rOx;
          };

Text.ParserCombinators.ReadP.option
  :: forall a.
     a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.option1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.optional1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),1*C1(U)><L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [p_s3rOy eta_s3rOz]
        let {
          lvl4_s3rOA :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [eta_s3rOz] \u [] eta_s3rOz GHC.Tuple.(); } in
        let {
          sat_s3rOC [Occ=Once]
            :: a_a3nw0 -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [lvl4_s3rOA] \r [a1_s3rOB] lvl4_s3rOA;
        } in 
          case p_s3rOy sat_s3rOC of sat_s3rOD {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3rOD lvl4_s3rOA;
          };

Text.ParserCombinators.ReadP.optional
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP ()
[GblId, Arity=2, Str=<C(S),1*C1(U)><L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.optional1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.endBy3 [Occ=LoopBreaker]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,C(U)><C(S),C(U)>, Unf=OtherCon []] =
    [] \r [p_s3rOE eta_s3rOF]
        let {
          sat_s3rOM [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [p_s3rOE eta_s3rOF] \u []
                  let {
                    sat_s3rOL [Occ=Once]
                      :: a_a3nwo -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [p_s3rOE eta_s3rOF] \r [a1_s3rOH]
                            let {
                              sat_s3rOK [Occ=Once]
                                :: [a_a3nwo] -> Text.ParserCombinators.ReadP.P b_a3ngn
                              [LclId] =
                                  [eta_s3rOF a1_s3rOH] \r [a2_s3rOI]
                                      let {
                                        sat_s3rOJ [Occ=Once] :: [a_a3nwo]
                                        [LclId] =
                                            CCCS :! [a1_s3rOH a2_s3rOI];
                                      } in  eta_s3rOF sat_s3rOJ;
                            } in  Text.ParserCombinators.ReadP.endBy3 p_s3rOE sat_s3rOK;
                  } in  p_s3rOE sat_s3rOL;
        } in 
          case eta_s3rOF GHC.Types.[] of sat_s3rOG {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3rOG sat_s3rOM;
          };

Text.ParserCombinators.ReadP.many
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=2, Str=<L,C(U)><C(S),C(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.endBy3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.many2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),C(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [p_s3rON eta_s3rOO]
        let {
          sat_s3rOT [Occ=Once]
            :: a_a3nwe -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [p_s3rON eta_s3rOO] \r [a1_s3rOP]
                  let {
                    sat_s3rOS [Occ=Once]
                      :: [a_a3nwe] -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [eta_s3rOO a1_s3rOP] \r [a2_s3rOQ]
                            let {
                              sat_s3rOR [Occ=Once] :: [a_a3nwe]
                              [LclId] =
                                  CCCS :! [a1_s3rOP a2_s3rOQ];
                            } in  eta_s3rOO sat_s3rOR;
                  } in  Text.ParserCombinators.ReadP.endBy3 p_s3rON sat_s3rOS;
        } in  p_s3rON sat_s3rOT;

Text.ParserCombinators.ReadP.many1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=2, Str=<C(S),C(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.many2 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.endBy4
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3rOU sep1_s3rOV eta_s3rOW]
        let {
          p1_s3rOX [Occ=OnceL, Dmd=<L,C(U)>]
            :: forall b1.
               (a_a3nwx -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              [p_s3rOU sep1_s3rOV] \r [k_s3rOY]
                  let {
                    sat_s3rP3 [Occ=Once]
                      :: a_a3nwx -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [sep1_s3rOV k_s3rOY] \r [a1_s3rOZ]
                            let {
                              lvl4_s3rP0 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3rOY a1_s3rOZ] \u [] k_s3rOY a1_s3rOZ; } in
                            let {
                              sat_s3rP2 [Occ=Once]
                                :: sep_a3nwy -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [lvl4_s3rP0] \r [a2_s3rP1] lvl4_s3rP0;
                            } in  sep1_s3rOV sat_s3rP2;
                  } in  p_s3rOU sat_s3rP3; } in
        let {
          sat_s3rPb [Occ=Once]
            :: a_a3nwx -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [sep1_s3rOV eta_s3rOW p1_s3rOX] \r [a1_s3rP4]
                  let {
                    lvl4_s3rP5 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [eta_s3rOW p1_s3rOX a1_s3rP4] \u []
                            let {
                              sat_s3rP8 [Occ=Once]
                                :: [a_a3nwx] -> Text.ParserCombinators.ReadP.P b_a3ngn
                              [LclId] =
                                  [eta_s3rOW a1_s3rP4] \r [a2_s3rP6]
                                      let {
                                        sat_s3rP7 [Occ=Once] :: [a_a3nwx]
                                        [LclId] =
                                            CCCS :! [a1_s3rP4 a2_s3rP6];
                                      } in  eta_s3rOW sat_s3rP7;
                            } in  Text.ParserCombinators.ReadP.endBy3 p1_s3rOX sat_s3rP8; } in
                  let {
                    sat_s3rPa [Occ=Once]
                      :: sep_a3nwy -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [lvl4_s3rP5] \r [a2_s3rP9] lvl4_s3rP5;
                  } in  sep1_s3rOV sat_s3rPa;
        } in  p_s3rOU sat_s3rPb;

Text.ParserCombinators.ReadP.endBy1
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.endBy4 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.skipMany2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,C(U)><C(S),1*C1(U)>, Unf=OtherCon []] =
    [] \r [p_s3rPc eta_s3rPd]
        case eta_s3rPd GHC.Tuple.() of lvl4_s3rPe [Dmd=<S,U>] {
          __DEFAULT ->
              let {
                sat_s3rPg [Occ=Once]
                  :: [a_a3nwN] -> Text.ParserCombinators.ReadP.P b_a3ngn
                [LclId] =
                    [lvl4_s3rPe] \r [a1_s3rPf] lvl4_s3rPe;
              } in  Text.ParserCombinators.ReadP.endBy3 p_s3rPc sat_s3rPg;
        };

Text.ParserCombinators.ReadP.skipMany
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP ()
[GblId, Arity=2, Str=<L,C(U)><C(S),1*C1(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.skipMany2 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.skipMany3
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),C(U)><L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [p_s3rPh eta_s3rPi]
        let {
          lvl4_s3rPj [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [p_s3rPh eta_s3rPi] \u []
                  case eta_s3rPi GHC.Tuple.() of lvl5_s3rPk [Dmd=<S,U>] {
                    __DEFAULT ->
                        let {
                          sat_s3rPm [Occ=Once]
                            :: [a_a3nwY] -> Text.ParserCombinators.ReadP.P b_a3ngn
                          [LclId] =
                              [lvl5_s3rPk] \r [a1_s3rPl] lvl5_s3rPk;
                        } in  Text.ParserCombinators.ReadP.endBy3 p_s3rPh sat_s3rPm;
                  }; } in
        let {
          sat_s3rPo [Occ=Once]
            :: a_a3nwY -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [lvl4_s3rPj] \r [a1_s3rPn] lvl4_s3rPj;
        } in  p_s3rPh sat_s3rPo;

Text.ParserCombinators.ReadP.skipMany1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP ()
[GblId, Arity=2, Str=<C(S),C(U)><L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.skipMany3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.sepBy3
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3rPp sep1_s3rPq eta_s3rPr]
        let {
          m2_s3rPs [Occ=OnceL, Dmd=<L,C(U)>]
            :: forall b1.
               (a_a3nx6 -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              [p_s3rPp sep1_s3rPq] \r [k_s3rPt]
                  let {
                    lvl4_s3rPu [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [p_s3rPp k_s3rPt] \u [] p_s3rPp k_s3rPt; } in
                  let {
                    sat_s3rPw [Occ=Once]
                      :: sep_a3nx7 -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [lvl4_s3rPu] \r [a1_s3rPv] lvl4_s3rPu;
                  } in  sep1_s3rPq sat_s3rPw; } in
        let {
          sat_s3rPB [Occ=Once]
            :: a_a3nx6 -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [eta_s3rPr m2_s3rPs] \r [a1_s3rPx]
                  let {
                    sat_s3rPA [Occ=Once]
                      :: [a_a3nx6] -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [eta_s3rPr a1_s3rPx] \r [a2_s3rPy]
                            let {
                              sat_s3rPz [Occ=Once] :: [a_a3nx6]
                              [LclId] =
                                  CCCS :! [a1_s3rPx a2_s3rPy];
                            } in  eta_s3rPr sat_s3rPz;
                  } in  Text.ParserCombinators.ReadP.endBy3 m2_s3rPs sat_s3rPA;
        } in  p_s3rPp sat_s3rPB;

Text.ParserCombinators.ReadP.sepBy1
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.sepBy3 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.endBy2
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,C(U)><L,C(U)><C(S),C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3rPC sep1_s3rPD eta_s3rPE]
        let {
          sat_s3rPL [Occ=Once] :: Text.ParserCombinators.ReadP.ReadP a_a3nxl
          [LclId] =
              [p_s3rPC sep1_s3rPD] \r [k_s3rPF]
                  let {
                    sat_s3rPK [Occ=Once]
                      :: a_a3nxl -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [sep1_s3rPD k_s3rPF] \r [a1_s3rPG]
                            let {
                              lvl4_s3rPH [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3rPF a1_s3rPG] \u [] k_s3rPF a1_s3rPG; } in
                            let {
                              sat_s3rPJ [Occ=Once]
                                :: sep_a3nxm -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [lvl4_s3rPH] \r [a2_s3rPI] lvl4_s3rPH;
                            } in  sep1_s3rPD sat_s3rPJ;
                  } in  p_s3rPC sat_s3rPK;
        } in  Text.ParserCombinators.ReadP.endBy3 sat_s3rPL eta_s3rPE;

Text.ParserCombinators.ReadP.endBy
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Str=<L,C(U)><L,C(U)><C(S),C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.endBy2 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.sepBy2
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3rPM sep1_s3rPN eta_s3rPO]
        let {
          sat_s3rPQ [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [eta_s3rPO] \u [] eta_s3rPO GHC.Types.[];
        } in 
          case
              Text.ParserCombinators.ReadP.sepBy3 p_s3rPM sep1_s3rPN eta_s3rPO
          of
          sat_s3rPP
          { __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3rPP sat_s3rPQ;
          };

Text.ParserCombinators.ReadP.sepBy
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.sepBy2 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$fMonadFailReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fail.C:MonadFail! [Text.ParserCombinators.ReadP.$fMonadReadP
                                                   Text.ParserCombinators.ReadP.$fMonadFailReadP1];

Text.ParserCombinators.ReadP.$fAlternativeReadP2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),C(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [v_s3rPR eta_s3rPS]
        let {
          some_v_s3rPT [Occ=LoopBreaker]
            :: forall b1.
               ([a_a3nIa] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              sat-only [v_s3rPR some_v_s3rPT] \r [eta1_s3rPU]
                  let {
                    sat_s3rQ2 [Occ=Once]
                      :: a_a3nIa -> Text.ParserCombinators.ReadP.P b1_X3nkZ
                    [LclId] =
                        [some_v_s3rPT eta1_s3rPU] \r [x_s3rPV]
                            let {
                              sat_s3rQ1 [Occ=Once] :: Text.ParserCombinators.ReadP.P b1_X3nkZ
                              [LclId] =
                                  [eta1_s3rPU x_s3rPV] \u []
                                      let {
                                        sat_s3rQ0 [Occ=Once] :: [a_a3nIa]
                                        [LclId] =
                                            CCCS :! [x_s3rPV GHC.Types.[]];
                                      } in  eta1_s3rPU sat_s3rQ0; } in
                            let {
                              sat_s3rPY [Occ=Once]
                                :: [a_a3nIa] -> Text.ParserCombinators.ReadP.P b1_X3nkZ
                              [LclId] =
                                  [eta1_s3rPU x_s3rPV] \r [a1_s3rPW]
                                      let {
                                        sat_s3rPX [Occ=Once] :: [a_a3nIa]
                                        [LclId] =
                                            CCCS :! [x_s3rPV a1_s3rPW];
                                      } in  eta1_s3rPU sat_s3rPX;
                            } in 
                              case some_v_s3rPT sat_s3rPY of sat_s3rPZ {
                                __DEFAULT ->
                                    Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                        sat_s3rPZ sat_s3rQ1;
                              };
                  } in  v_s3rPR sat_s3rQ2;
        } in  some_v_s3rPT eta_s3rPS;

Text.ParserCombinators.ReadP.$fAlternativeReadP1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),C(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [v_s3rQ3 eta_s3rQ4]
        let {
          many_v_s3rQ5 [Occ=LoopBreaker]
            :: forall b1.
               ([a_a3nIm] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              sat-only [v_s3rQ3 many_v_s3rQ5] \r [k_s3rQ6]
                  let {
                    sat_s3rQd [Occ=Once] :: Text.ParserCombinators.ReadP.P b1_a3nvJ
                    [LclId] =
                        [k_s3rQ6] \u [] k_s3rQ6 GHC.Types.[]; } in
                  let {
                    sat_s3rQb [Occ=Once]
                      :: a_a3nIm -> Text.ParserCombinators.ReadP.P b1_a3nvJ
                    [LclId] =
                        [many_v_s3rQ5 k_s3rQ6] \r [x_s3rQ7]
                            let {
                              sat_s3rQa [Occ=Once]
                                :: [a_a3nIm] -> Text.ParserCombinators.ReadP.P b1_a3nvJ
                              [LclId] =
                                  [k_s3rQ6 x_s3rQ7] \r [a1_s3rQ8]
                                      let {
                                        sat_s3rQ9 [Occ=Once] :: [a_a3nIm]
                                        [LclId] =
                                            CCCS :! [x_s3rQ7 a1_s3rQ8];
                                      } in  k_s3rQ6 sat_s3rQ9;
                            } in  many_v_s3rQ5 sat_s3rQa;
                  } in 
                    case v_s3rQ3 sat_s3rQb of sat_s3rQc {
                      __DEFAULT ->
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                              sat_s3rQc sat_s3rQd;
                    };
        } in  many_v_s3rQ5 eta_s3rQ4;

Text.ParserCombinators.ReadP.$fAlternativeReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Text.ParserCombinators.ReadP.$fApplicativeReadP
                                           Text.ParserCombinators.ReadP.$fAlternativeReadP4
                                           Text.ParserCombinators.ReadP.$fAlternativeReadP3
                                           Text.ParserCombinators.ReadP.$fAlternativeReadP2
                                           Text.ParserCombinators.ReadP.$fAlternativeReadP1];

Text.ParserCombinators.ReadP.$fMonadPlusReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [Text.ParserCombinators.ReadP.$fAlternativeReadP
                                         Text.ParserCombinators.ReadP.$fMonadReadP
                                         Text.ParserCombinators.ReadP.$fAlternativeReadP4
                                         Text.ParserCombinators.ReadP.$fAlternativeReadP3];

Text.ParserCombinators.ReadP.chainr3
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3rQe op_s3rQf eta_s3rQg]
        let {
          scan_s3rQh [Occ=LoopBreaker]
            :: forall b1.
               (a_a3nxM -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              sat-only [p_s3rQe op_s3rQf scan_s3rQh] \r [k_s3rQi]
                  let {
                    sat_s3rQr [Occ=Once]
                      :: a_a3nxM -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [op_s3rQf scan_s3rQh k_s3rQi] \r [a1_s3rQj]
                            let {
                              sat_s3rQq [Occ=Once] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3rQi a1_s3rQj] \u [] k_s3rQi a1_s3rQj; } in
                            let {
                              sat_s3rQo [Occ=Once]
                                :: (a_a3nxM -> a_a3nxM -> a_a3nxM)
                                   -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [scan_s3rQh k_s3rQi a1_s3rQj] \r [a2_s3rQk]
                                      let {
                                        sat_s3rQn [Occ=Once]
                                          :: a_a3nxM -> Text.ParserCombinators.ReadP.P b1_a3nIU
                                        [LclId] =
                                            [k_s3rQi a1_s3rQj a2_s3rQk] \r [a3_s3rQl]
                                                let {
                                                  sat_s3rQm [Occ=Once] :: a_a3nxM
                                                  [LclId] =
                                                      [a1_s3rQj a2_s3rQk a3_s3rQl] \u []
                                                          a2_s3rQk a1_s3rQj a3_s3rQl;
                                                } in  k_s3rQi sat_s3rQm;
                                      } in  scan_s3rQh sat_s3rQn;
                            } in 
                              case op_s3rQf sat_s3rQo of sat_s3rQp {
                                __DEFAULT ->
                                    Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                        sat_s3rQp sat_s3rQq;
                              };
                  } in  p_s3rQe sat_s3rQr;
        } in  scan_s3rQh eta_s3rQg;

Text.ParserCombinators.ReadP.chainr1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.chainr3 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.chainr2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3rQs op_s3rQt x_s3rQu eta_s3rQv]
        let {
          sat_s3rQx [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [x_s3rQu eta_s3rQv] \u [] eta_s3rQv x_s3rQu;
        } in 
          case
              Text.ParserCombinators.ReadP.chainr3 p_s3rQs op_s3rQt eta_s3rQv
          of
          sat_s3rQw
          { __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3rQw sat_s3rQx;
          };

Text.ParserCombinators.ReadP.chainr
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.chainr2 eta_B4 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.chainl3
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3rQy op_s3rQz eta_s3rQA]
        let {
          rest_s3rQB [Occ=LoopBreaker]
            :: a_a3nyq
               -> forall b1.
                  (a_a3nyq -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<L,U><L,C(U)>, Unf=OtherCon []] =
              sat-only [p_s3rQy op_s3rQz rest_s3rQB] \r [x_s3rQC eta1_s3rQD]
                  let {
                    sat_s3rQK [Occ=Once] :: Text.ParserCombinators.ReadP.P b1_X3nls
                    [LclId] =
                        [x_s3rQC eta1_s3rQD] \u [] eta1_s3rQD x_s3rQC; } in
                  let {
                    sat_s3rQI [Occ=Once]
                      :: (a_a3nyq -> a_a3nyq -> a_a3nyq)
                         -> Text.ParserCombinators.ReadP.P b1_X3nls
                    [LclId] =
                        [p_s3rQy rest_s3rQB x_s3rQC eta1_s3rQD] \r [a1_s3rQE]
                            let {
                              sat_s3rQH [Occ=Once]
                                :: a_a3nyq -> Text.ParserCombinators.ReadP.P b1_X3nls
                              [LclId] =
                                  [rest_s3rQB x_s3rQC eta1_s3rQD a1_s3rQE] \r [a2_s3rQF]
                                      let {
                                        sat_s3rQG [Occ=Once] :: a_a3nyq
                                        [LclId] =
                                            [x_s3rQC a1_s3rQE a2_s3rQF] \u []
                                                a1_s3rQE x_s3rQC a2_s3rQF;
                                      } in  rest_s3rQB sat_s3rQG eta1_s3rQD;
                            } in  p_s3rQy sat_s3rQH;
                  } in 
                    case op_s3rQz sat_s3rQI of sat_s3rQJ {
                      __DEFAULT ->
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                              sat_s3rQJ sat_s3rQK;
                    }; } in
        let {
          sat_s3rQM [Occ=Once]
            :: a_a3nyq -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [eta_s3rQA rest_s3rQB] \r [a1_s3rQL] rest_s3rQB a1_s3rQL eta_s3rQA;
        } in  p_s3rQy sat_s3rQM;

Text.ParserCombinators.ReadP.chainl1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.chainl3 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.chainl2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3rQN op_s3rQO x_s3rQP eta_s3rQQ]
        let {
          sat_s3rQS [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [x_s3rQP eta_s3rQQ] \u [] eta_s3rQQ x_s3rQP;
        } in 
          case
              Text.ParserCombinators.ReadP.chainl3 p_s3rQN op_s3rQO eta_s3rQQ
          of
          sat_s3rQR
          { __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3rQR sat_s3rQS;
          };

Text.ParserCombinators.ReadP.chainl
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.chainl2 eta_B4 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.<++2 [Occ=LoopBreaker]
  :: GHC.Prim.Int#
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s3rQT eta_s3rQU]
        case ds_s3rQT of ds1_s3rQV {
          __DEFAULT ->
              let {
                lvl4_s3rQW [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_X3nlD
                [LclId] =
                    [eta_s3rQU ds1_s3rQV] \u []
                        case -# [ds1_s3rQV 1#] of sat_s3rQX {
                          __DEFAULT -> Text.ParserCombinators.ReadP.<++2 sat_s3rQX eta_s3rQU;
                        }; } in
              let {
                sat_s3rQZ [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_X3nlD
                [LclId] =
                    [lvl4_s3rQW] \r [a_s3rQY] lvl4_s3rQW;
              } in  Text.ParserCombinators.ReadP.Get [sat_s3rQZ];
          0# -> eta_s3rQU GHC.Tuple.();
        };

Text.ParserCombinators.ReadP.$w<++ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId, Arity=3, Str=<L,1*C1(U)><L,C(U)><L,U>, Unf=OtherCon []] =
    [] \r [w_s3rR0 w1_s3rR1 w2_s3rR2]
        let {
          lvl4_s3rR3 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P a_s3ohU
          [LclId] =
              [w_s3rR0] \u []
                  w_s3rR0 Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
        let {
          probe_s3rR4 [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadP.P a_s3ohU
               -> [GHC.Types.Char]
               -> GHC.Prim.Int#
               -> forall b1.
                  (a_s3ohU -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=4, Str=<S,1*U><L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w1_s3rR1 probe_s3rR4] \r [ds_s3rR5
                                                  ds1_s3rR6
                                                  n_s3rR7
                                                  eta_s3rR8]
                  case ds_s3rR5 of wild_s3rR9 {
                    Text.ParserCombinators.ReadP.Get f_s3rRa [Occ=Once!] ->
                        case ds1_s3rR6 of {
                          [] -> w1_s3rR1 eta_s3rR8;
                          : c_s3rRc [Occ=Once] s_s3rRd [Occ=Once] ->
                              case +# [n_s3rR7 1#] of sat_s3rRf {
                                __DEFAULT ->
                                    case f_s3rRa c_s3rRc of sat_s3rRe {
                                      __DEFAULT ->
                                          probe_s3rR4 sat_s3rRe s_s3rRd sat_s3rRf eta_s3rR8;
                                    };
                              };
                        };
                    Text.ParserCombinators.ReadP.Look f_s3rRg [Occ=Once!] ->
                        case f_s3rRg ds1_s3rR6 of sat_s3rRh {
                          __DEFAULT -> probe_s3rR4 sat_s3rRh ds1_s3rR6 n_s3rR7 eta_s3rR8;
                        };
                    Text.ParserCombinators.ReadP.Fail -> w1_s3rR1 eta_s3rR8;
                    Text.ParserCombinators.ReadP.Result _ [Occ=Dead] _ [Occ=Dead] ->
                        let {
                          sat_s3rRl [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b1_X3nlg
                          [LclId] =
                              [eta_s3rR8 wild_s3rR9] \r [a1_s3rRk]
                                  Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                      wild_s3rR9 eta_s3rR8;
                        } in  Text.ParserCombinators.ReadP.<++2 n_s3rR7 sat_s3rRl;
                    Text.ParserCombinators.ReadP.Final _ [Occ=Dead] ->
                        Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                            wild_s3rR9 eta_s3rR8;
                  }; } in
        let {
          sat_s3rRo [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3ohX
          [LclId] =
              [w2_s3rR2 lvl4_s3rR3 probe_s3rR4] \r [a1_s3rRn]
                  probe_s3rR4 lvl4_s3rR3 a1_s3rRn 0# w2_s3rR2;
        } in  Unit# [sat_s3rRo];

Text.ParserCombinators.ReadP.<++1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,1*C1(U)><L,C(U)><L,U>m2, Unf=OtherCon []] =
    [] \r [w_s3rRp w1_s3rRq w2_s3rRr]
        case
            Text.ParserCombinators.ReadP.$w<++ w_s3rRp w1_s3rRq w2_s3rRr
        of
        { Unit# ww1_s3rRt [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_s3rRt];
        };

Text.ParserCombinators.ReadP.<++
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=3, Str=<L,1*C1(U)><L,C(U)><L,U>m2, Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.<++1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.manyTill1
  :: forall a end.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP end
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,C(U)><L,C(U)><L,U>, Unf=OtherCon []] =
    [] \r [p_s3rRu end1_s3rRv eta_s3rRw]
        let {
          scan_s3rRx [Occ=OnceL, Dmd=<L,C(U)>]
            :: forall b1.
               ([a_a3nB6] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,1*C1(U)>, Unf=OtherCon []] =
              [end1_s3rRv] \r [k_s3rRy]
                  let {
                    lvl4_s3rRz [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [k_s3rRy] \u [] k_s3rRy GHC.Types.[]; } in
                  let {
                    sat_s3rRB [Occ=Once]
                      :: end_a3nB7 -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [lvl4_s3rRz] \r [a1_s3rRA] lvl4_s3rRz;
                  } in  end1_s3rRv sat_s3rRB; } in
        let {
          scan1_s3rRC [Occ=OnceL]
            :: forall b1.
               ([a_a3nB6] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              [p_s3rRu scan2_s3rRD] \r [k_s3rRE]
                  let {
                    sat_s3rRJ [Occ=Once]
                      :: a_a3nB6 -> Text.ParserCombinators.ReadP.P b1_X3nOr
                    [LclId] =
                        [scan2_s3rRD k_s3rRE] \r [a1_s3rRF]
                            let {
                              sat_s3rRI [Occ=Once]
                                :: [a_a3nB6] -> Text.ParserCombinators.ReadP.P b1_X3nOr
                              [LclId] =
                                  [k_s3rRE a1_s3rRF] \r [a2_s3rRG]
                                      let {
                                        sat_s3rRH [Occ=Once] :: [a_a3nB6]
                                        [LclId] =
                                            CCCS :! [a1_s3rRF a2_s3rRG];
                                      } in  k_s3rRE sat_s3rRH;
                            } in  scan2_s3rRD sat_s3rRI;
                  } in  p_s3rRu sat_s3rRJ;
          scan2_s3rRD [Occ=LoopBreaker]
            :: forall b1.
               ([a_a3nB6] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [scan_s3rRx scan1_s3rRC] \r [w_s3rRK]
                  case
                      Text.ParserCombinators.ReadP.$w<++ scan_s3rRx scan1_s3rRC w_s3rRK
                  of
                  { Unit# ww1_s3rRM [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_s3rRM];
                  };
        } in  scan2_s3rRD eta_s3rRw;

Text.ParserCombinators.ReadP.manyTill
  :: forall a end.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP end
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=3, Str=<L,C(U)><L,C(U)><L,U>, Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.manyTill1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.eof1
  :: forall b.
     (() -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)>m2,
 Unf=OtherCon []] =
    [] \r [k_s3rRN]
        let {
          lvl4_s3rRO [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3nIU
          [LclId] =
              [k_s3rRN] \u [] k_s3rRN GHC.Tuple.(); } in
        let {
          sat_s3rRT [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3nIU
          [LclId] =
              [lvl4_s3rRO] \r [a_s3rRP]
                  case a_s3rRP of {
                    [] -> lvl4_s3rRO;
                    : _ [Occ=Dead] _ [Occ=Dead] ->
                        Text.ParserCombinators.ReadP.Fail [];
                  };
        } in  Text.ParserCombinators.ReadP.Look [sat_s3rRT];

Text.ParserCombinators.ReadP.eof
  :: Text.ParserCombinators.ReadP.ReadP ()
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.eof1 eta_B1;

Text.ParserCombinators.ReadP.satisfy1
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Types.Char -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [p_s3rRU k_s3rRV]
        let {
          sat_s3rRY [Occ=Once]
            :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_X3nNg
          [LclId] =
              [p_s3rRU k_s3rRV] \r [a_s3rRW]
                  case p_s3rRU a_s3rRW of {
                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail [];
                    GHC.Types.True -> k_s3rRV a_s3rRW;
                  };
        } in  Text.ParserCombinators.ReadP.Get [sat_s3rRY];

Text.ParserCombinators.ReadP.satisfy
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> Text.ParserCombinators.ReadP.ReadP GHC.Types.Char
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.satisfy1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.char1
  :: GHC.Types.Char
     -> forall b.
        (GHC.Types.Char -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [c_s3rRZ eta_s3rS0]
        let {
          sat_s3rS7 [Occ=Once]
            :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_X3nNg
          [LclId] =
              [c_s3rRZ eta_s3rS0] \r [a_s3rS1]
                  case c_s3rRZ of {
                    GHC.Types.C# x_s3rS3 [Occ=Once] ->
                        case a_s3rS1 of wild1_s3rS4 {
                          GHC.Types.C# y_s3rS5 [Occ=Once] ->
                              case eqChar# [x_s3rS3 y_s3rS5] of {
                                __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                1# -> eta_s3rS0 wild1_s3rS4;
                              };
                        };
                  };
        } in  Text.ParserCombinators.ReadP.Get [sat_s3rS7];

Text.ParserCombinators.ReadP.char
  :: GHC.Types.Char
     -> Text.ParserCombinators.ReadP.ReadP GHC.Types.Char
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.char1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$wstring [InlPrag=NOUSERINLINE[0]]
  :: GHC.Base.String
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3rS8 w1_s3rS9]
        let {
          scan_s3rSa [Occ=LoopBreaker]
            :: [GHC.Types.Char]
               -> [GHC.Types.Char]
               -> forall b1.
                  (GHC.Base.String -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=3, Str=<S,1*U><L,1*U><L,1*C1(U)>, Unf=OtherCon []] =
              sat-only [w_s3rS8 scan_s3rSa] \r [ds_s3rSb ds1_s3rSc eta_s3rSd]
                  case ds_s3rSb of {
                    [] -> eta_s3rSd w_s3rS8;
                    : x_s3rSf [Occ=Once!] xs_s3rSg [Occ=Once] ->
                        case ds1_s3rSc of {
                          [] -> Text.ParserCombinators.ReadP.Fail [];
                          : y_s3rSi [Occ=Once!] ys_s3rSj [Occ=Once] ->
                              case x_s3rSf of {
                                GHC.Types.C# x1_s3rSl [Occ=Once] ->
                                    case y_s3rSi of {
                                      GHC.Types.C# y1_s3rSn [Occ=Once] ->
                                          case eqChar# [x1_s3rSl y1_s3rSn] of {
                                            __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                            1# ->
                                                let {
                                                  lvl4_s3rSp [Occ=OnceL]
                                                    :: Text.ParserCombinators.ReadP.P b1_a3ngn
                                                  [LclId] =
                                                      [scan_s3rSa eta_s3rSd xs_s3rSg ys_s3rSj] \u []
                                                          scan_s3rSa
                                                              xs_s3rSg ys_s3rSj eta_s3rSd; } in
                                                let {
                                                  sat_s3rSr [Occ=Once]
                                                    :: GHC.Types.Char
                                                       -> Text.ParserCombinators.ReadP.P b1_a3ngn
                                                  [LclId] =
                                                      [lvl4_s3rSp] \r [a_s3rSq] lvl4_s3rSp;
                                                } in  Text.ParserCombinators.ReadP.Get [sat_s3rSr];
                                          };
                                    };
                              };
                        };
                  }; } in
        let {
          sat_s3rSt [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3oig
          [LclId] =
              [w_s3rS8 w1_s3rS9 scan_s3rSa] \r [a_s3rSs]
                  scan_s3rSa w_s3rS8 a_s3rSs w1_s3rS9;
        } in  Unit# [sat_s3rSt];

Text.ParserCombinators.ReadP.string1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Base.String
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_s3rSu w1_s3rSv]
        case Text.ParserCombinators.ReadP.$wstring w_s3rSu w1_s3rSv of {
          Unit# ww1_s3rSx [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_s3rSx];
        };

Text.ParserCombinators.ReadP.string
  :: GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadP GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.string1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$wmunch [InlPrag=NOUSERINLINE[0]]
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3rSy w1_s3rSz]
        let {
          scan_s3rSA [Occ=LoopBreaker]
            :: [GHC.Types.Char]
               -> forall b1.
                  ([GHC.Types.Char] -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<S,1*U><L,1*C1(U)>, Unf=OtherCon []] =
              sat-only [w_s3rSy scan_s3rSA] \r [ds_s3rSB eta_s3rSC]
                  case ds_s3rSB of {
                    [] -> eta_s3rSC GHC.Types.[];
                    : c_s3rSE cs_s3rSF [Occ=Once] ->
                        case w_s3rSy c_s3rSE of {
                          GHC.Types.False -> eta_s3rSC GHC.Types.[];
                          GHC.Types.True ->
                              let {
                                lvl4_s3rSH [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_X3nlq
                                [LclId] =
                                    [scan_s3rSA eta_s3rSC c_s3rSE cs_s3rSF] \u []
                                        let {
                                          sat_s3rSK [Occ=Once]
                                            :: [GHC.Types.Char]
                                               -> Text.ParserCombinators.ReadP.P b1_X3nlq
                                          [LclId] =
                                              [eta_s3rSC c_s3rSE] \r [a_s3rSI]
                                                  let {
                                                    sat_s3rSJ [Occ=Once] :: [GHC.Types.Char]
                                                    [LclId] =
                                                        CCCS :! [c_s3rSE a_s3rSI];
                                                  } in  eta_s3rSC sat_s3rSJ;
                                        } in  scan_s3rSA cs_s3rSF sat_s3rSK; } in
                              let {
                                sat_s3rSM [Occ=Once]
                                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b1_X3nlq
                                [LclId] =
                                    [lvl4_s3rSH] \r [a_s3rSL] lvl4_s3rSH;
                              } in  Text.ParserCombinators.ReadP.Get [sat_s3rSM];
                        };
                  }; } in
        let {
          sat_s3rSO [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3oiq
          [LclId] =
              [w1_s3rSz scan_s3rSA] \r [a_s3rSN] scan_s3rSA a_s3rSN w1_s3rSz;
        } in  Unit# [sat_s3rSO];

Text.ParserCombinators.ReadP.munch2 [InlPrag=NOUSERINLINE[0]]
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_s3rSP w1_s3rSQ]
        case Text.ParserCombinators.ReadP.$wmunch w_s3rSP w1_s3rSQ of {
          Unit# ww1_s3rSS [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_s3rSS];
        };

Text.ParserCombinators.ReadP.munch
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> Text.ParserCombinators.ReadP.ReadP GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.munch2 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$wmunch1 [InlPrag=NOUSERINLINE[0]]
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Types.Char -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3rST w1_s3rSU]
        let {
          sat_s3rT2 [Occ=Once]
            :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_s3oix
          [LclId] =
              [w_s3rST w1_s3rSU] \r [a_s3rSV]
                  case w_s3rST a_s3rSV of {
                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail [];
                    GHC.Types.True ->
                        let {
                          sat_s3rSZ [Occ=Once]
                            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3oix
                          [LclId] =
                              [w1_s3rSU a_s3rSV] \r [a1_s3rSX]
                                  let {
                                    sat_s3rSY [Occ=Once] :: GHC.Base.String
                                    [LclId] =
                                        CCCS :! [a_s3rSV a1_s3rSX];
                                  } in  w1_s3rSU sat_s3rSY;
                        } in 
                          case Text.ParserCombinators.ReadP.$wmunch w_s3rST sat_s3rSZ of {
                            Unit# ww1_s3rT1 [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww1_s3rT1];
                          };
                  };
        } in  Unit# [sat_s3rT2];

Text.ParserCombinators.ReadP.munch3 [InlPrag=NOUSERINLINE[0]]
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [w_s3rT3 w1_s3rT4]
        case Text.ParserCombinators.ReadP.$wmunch1 w_s3rT3 w1_s3rT4 of {
          Unit# ww1_s3rT6 [Occ=Once] ->
              Text.ParserCombinators.ReadP.Get [ww1_s3rT6];
        };

Text.ParserCombinators.ReadP.munch1
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> Text.ParserCombinators.ReadP.ReadP GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.munch3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.skipSpaces2 [Occ=LoopBreaker]
  :: [GHC.Types.Char]
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s3rT7 eta_s3rT8]
        case ds_s3rT7 of {
          [] -> eta_s3rT8 GHC.Tuple.();
          : c_s3rTa [Occ=Once!] s_s3rTb [Occ=Once*] ->
              case c_s3rTa of {
                GHC.Types.C# ww1_s3rTd ->
                    case ord# [ww1_s3rTd] of sat_s3rTf {
                      __DEFAULT ->
                          case int2Word# [sat_s3rTf] of x_s3rTe [Dmd=<S,U>] {
                            __DEFAULT ->
                                case leWord# [x_s3rTe 887##] of {
                                  __DEFAULT ->
                                      case ord# [ww1_s3rTd] of sat_s3rTi {
                                        __DEFAULT ->
                                            case
                                                __pkg_ccall base-4.11.0.0 [sat_s3rTi
                                                                           GHC.Prim.realWorld#]
                                            of
                                            { (#,#) _ [Occ=Dead] ds2_s3rTl [Occ=Once!] ->
                                                  case ds2_s3rTl of {
                                                    __DEFAULT ->
                                                        let {
                                                          lvl4_s3rTn [Occ=OnceL]
                                                            :: Text.ParserCombinators.ReadP.P
                                                                 b_a3ngn
                                                          [LclId] =
                                                              [eta_s3rT8 s_s3rTb] \u []
                                                                  Text.ParserCombinators.ReadP.skipSpaces2
                                                                      s_s3rTb eta_s3rT8; } in
                                                        let {
                                                          sat_s3rTp [Occ=Once]
                                                            :: GHC.Types.Char
                                                               -> Text.ParserCombinators.ReadP.P
                                                                    b_a3ngn
                                                          [LclId] =
                                                              [lvl4_s3rTn] \r [a_s3rTo] lvl4_s3rTn;
                                                        } in 
                                                          Text.ParserCombinators.ReadP.Get [sat_s3rTp];
                                                    0# -> eta_s3rT8 GHC.Tuple.();
                                                  };
                                            };
                                      };
                                  1# ->
                                      case x_s3rTe of wild1_s3rTq {
                                        __DEFAULT ->
                                            case minusWord# [wild1_s3rTq 9##] of sat_s3rTr {
                                              __DEFAULT ->
                                                  case leWord# [sat_s3rTr 4##] of {
                                                    __DEFAULT ->
                                                        case wild1_s3rTq of {
                                                          __DEFAULT -> eta_s3rT8 GHC.Tuple.();
                                                          160## ->
                                                              let {
                                                                lvl4_s3rTu [Occ=OnceL]
                                                                  :: Text.ParserCombinators.ReadP.P
                                                                       b_a3ngn
                                                                [LclId] =
                                                                    [eta_s3rT8 s_s3rTb] \u []
                                                                        Text.ParserCombinators.ReadP.skipSpaces2
                                                                            s_s3rTb eta_s3rT8; } in
                                                              let {
                                                                sat_s3rTw [Occ=Once]
                                                                  :: GHC.Types.Char
                                                                     -> Text.ParserCombinators.ReadP.P
                                                                          b_a3ngn
                                                                [LclId] =
                                                                    [lvl4_s3rTu] \r [a_s3rTv]
                                                                        lvl4_s3rTu;
                                                              } in 
                                                                Text.ParserCombinators.ReadP.Get [sat_s3rTw];
                                                        };
                                                    1# ->
                                                        let {
                                                          lvl4_s3rTx [Occ=OnceL]
                                                            :: Text.ParserCombinators.ReadP.P
                                                                 b_a3ngn
                                                          [LclId] =
                                                              [eta_s3rT8 s_s3rTb] \u []
                                                                  Text.ParserCombinators.ReadP.skipSpaces2
                                                                      s_s3rTb eta_s3rT8; } in
                                                        let {
                                                          sat_s3rTz [Occ=Once]
                                                            :: GHC.Types.Char
                                                               -> Text.ParserCombinators.ReadP.P
                                                                    b_a3ngn
                                                          [LclId] =
                                                              [lvl4_s3rTx] \r [a_s3rTy] lvl4_s3rTx;
                                                        } in 
                                                          Text.ParserCombinators.ReadP.Get [sat_s3rTz];
                                                  };
                                            };
                                        32## ->
                                            let {
                                              lvl4_s3rTA [Occ=OnceL]
                                                :: Text.ParserCombinators.ReadP.P b_a3ngn
                                              [LclId] =
                                                  [eta_s3rT8 s_s3rTb] \u []
                                                      Text.ParserCombinators.ReadP.skipSpaces2
                                                          s_s3rTb eta_s3rT8; } in
                                            let {
                                              sat_s3rTC [Occ=Once]
                                                :: GHC.Types.Char
                                                   -> Text.ParserCombinators.ReadP.P b_a3ngn
                                              [LclId] =
                                                  [lvl4_s3rTA] \r [a_s3rTB] lvl4_s3rTA;
                                            } in  Text.ParserCombinators.ReadP.Get [sat_s3rTC];
                                      };
                                };
                          };
                    };
              };
        };

Text.ParserCombinators.ReadP.skipSpaces1
  :: forall b.
     (() -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,C(U)>m2, Unf=OtherCon []] =
    [] \r [k_s3rTD]
        let {
          sat_s3rTF [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_X3nNv
          [LclId] =
              [k_s3rTD] \r [a_s3rTE]
                  Text.ParserCombinators.ReadP.skipSpaces2 a_s3rTE k_s3rTD;
        } in  Text.ParserCombinators.ReadP.Look [sat_s3rTF];

Text.ParserCombinators.ReadP.skipSpaces
  :: Text.ParserCombinators.ReadP.ReadP ()
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,C(U)>m2, Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.skipSpaces1 eta_B1;

Text.ParserCombinators.ReadP.Get
  :: forall a.
     (GHC.Types.Char -> Text.ParserCombinators.ReadP.P a)
     -> Text.ParserCombinators.ReadP.P a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m1,
 Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Get [eta_B1];

Text.ParserCombinators.ReadP.Look
  :: forall a.
     (GHC.Base.String -> Text.ParserCombinators.ReadP.P a)
     -> Text.ParserCombinators.ReadP.P a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Look [eta_B1];

Text.ParserCombinators.ReadP.Fail
  :: forall a. Text.ParserCombinators.ReadP.P a
[GblId[DataCon], Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE Text.ParserCombinators.ReadP.Fail! [];

Text.ParserCombinators.ReadP.Result
  :: forall a.
     a
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m4,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.Result [eta_B2 eta_B1];

Text.ParserCombinators.ReadP.Final
  :: forall a.
     [(a, GHC.Base.String)] -> Text.ParserCombinators.ReadP.P a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m5,
 Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Final [eta_B1];


==================== STG syntax: ====================
2018-03-16 15:58:05.604525614 UTC

Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
  :: forall a. a -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m4, Unf=OtherCon []] =
    [] \r [x_s3rIG]
        Text.ParserCombinators.ReadP.Result [x_s3rIG
                                             Text.ParserCombinators.ReadP.Fail];

Text.ParserCombinators.ReadP.$fMonadFailP_$cfail
  :: forall a. GHC.Base.String -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s3rIH] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadP.$fFunctorReadP2
  :: forall a b.
     (a -> b)
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><C(S),1*C1(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [h_s3rII ds_s3rIJ k_s3rIK]
        let {
          sat_s3rIL [Occ=Once]
            :: a_a3nKO -> Text.ParserCombinators.ReadP.P b1_a3nKT
          [LclId] =
              [h_s3rII k_s3rIK] \r [eta_B1] GHC.Base.. k_s3rIK h_s3rII eta_B1;
        } in  ds_s3rIJ sat_s3rIL;

Text.ParserCombinators.ReadP.$fFunctorReadP1
  :: forall a b.
     a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (a -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [x_s3rIM eta_s3rIN eta1_s3rIO]
        let {
          lvl4_s3rIP [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [x_s3rIM eta1_s3rIO] \u [] eta1_s3rIO x_s3rIM; } in
        let {
          sat_s3rIR [Occ=Once]
            :: b_a3nL5 -> Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [lvl4_s3rIP] \r [x1_s3rIQ] lvl4_s3rIP;
        } in  eta_s3rIN sat_s3rIR;

Text.ParserCombinators.ReadP.$fFunctorReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Text.ParserCombinators.ReadP.$fFunctorReadP2
                                       Text.ParserCombinators.ReadP.$fFunctorReadP1];

Text.ParserCombinators.ReadP.$fApplicativeReadP5
  :: forall a.
     a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [x_s3rIS k_s3rIT] k_s3rIT x_s3rIS;

Text.ParserCombinators.ReadP.$fMonadFailReadP1
  :: forall a.
     GHC.Base.String
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_s3rIU ds1_s3rIV] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadP.$fMonadReadP1
  :: forall a b.
     Text.ParserCombinators.ReadP.ReadP a
     -> (a -> Text.ParserCombinators.ReadP.ReadP b)
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3rIW f_s3rIX k_s3rIY]
        let {
          sat_s3rJ0 [Occ=Once]
            :: a_a3nIP -> Text.ParserCombinators.ReadP.P b1_a3nIU
          [LclId] =
              [f_s3rIX k_s3rIY] \r [a1_s3rIZ] f_s3rIX a1_s3rIZ k_s3rIY;
        } in  ds_s3rIW sat_s3rJ0;

Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap [Occ=LoopBreaker]
  :: forall a b.
     (a -> b)
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s3rJ1 ds_s3rJ2]
        case ds_s3rJ2 of {
          Text.ParserCombinators.ReadP.Get a1_s3rJ4 [Occ=OnceL!] ->
              let {
                sat_s3rJ7 [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_a3nEm
                [LclId] =
                    [f_s3rJ1 a1_s3rJ4] \r [b3_s3rJ5]
                        case a1_s3rJ4 b3_s3rJ5 of sat_s3rJ6 {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                                  f_s3rJ1 sat_s3rJ6;
                        };
              } in  Text.ParserCombinators.ReadP.Get [sat_s3rJ7];
          Text.ParserCombinators.ReadP.Look a1_s3rJ8 [Occ=OnceL!] ->
              let {
                sat_s3rJb [Occ=Once]
                  :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3nEm
                [LclId] =
                    [f_s3rJ1 a1_s3rJ8] \r [b3_s3rJ9]
                        case a1_s3rJ8 b3_s3rJ9 of sat_s3rJa {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                                  f_s3rJ1 sat_s3rJa;
                        };
              } in  Text.ParserCombinators.ReadP.Look [sat_s3rJb];
          Text.ParserCombinators.ReadP.Fail ->
              Text.ParserCombinators.ReadP.Fail [];
          Text.ParserCombinators.ReadP.Result a1_s3rJc [Occ=Once]
                                              a2_s3rJd [Occ=Once] ->
              let {
                sat_s3rJf [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nEm
                [LclId] =
                    [f_s3rJ1 a2_s3rJd] \u []
                        Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                            f_s3rJ1 a2_s3rJd; } in
              let {
                sat_s3rJe [Occ=Once] :: b_a3nEm
                [LclId] =
                    [f_s3rJ1 a1_s3rJc] \u [] f_s3rJ1 a1_s3rJc;
              } in  Text.ParserCombinators.ReadP.Result [sat_s3rJe sat_s3rJf];
          Text.ParserCombinators.ReadP.Final a1_s3rJg [Occ=Once] ->
              let {
                sat_s3rJn [Occ=Once] :: [(b_a3nEm, GHC.Base.String)]
                [LclId] =
                    [f_s3rJ1 a1_s3rJg] \u []
                        let {
                          sat_s3rJm [Occ=Once]
                            :: (a_a3nEl, GHC.Base.String) -> (b_a3nEm, GHC.Base.String)
                          [LclId] =
                              [f_s3rJ1] \r [b2_s3rJh]
                                  case b2_s3rJh of {
                                    (,) a2_s3rJj [Occ=Once] a3_s3rJk [Occ=Once] ->
                                        let {
                                          sat_s3rJl [Occ=Once] :: b_a3nEm
                                          [LclId] =
                                              [f_s3rJ1 a2_s3rJj] \u [] f_s3rJ1 a2_s3rJj;
                                        } in  (,) [sat_s3rJl a3_s3rJk];
                                  };
                        } in  GHC.Base.map sat_s3rJm a1_s3rJg;
              } in  Text.ParserCombinators.ReadP.Final [sat_s3rJn];
        };

Text.ParserCombinators.ReadP.$fApplicativeP_$c<$ [Occ=LoopBreaker]
  :: forall a b.
     a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [z_s3rJo ds_s3rJp]
        case ds_s3rJp of {
          Text.ParserCombinators.ReadP.Get a1_s3rJr [Occ=OnceL!] ->
              let {
                sat_s3rJu [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P a_a3nFG
                [LclId] =
                    [z_s3rJo a1_s3rJr] \r [b4_s3rJs]
                        case a1_s3rJr b4_s3rJs of sat_s3rJt {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fApplicativeP_$c<$ z_s3rJo sat_s3rJt;
                        };
              } in  Text.ParserCombinators.ReadP.Get [sat_s3rJu];
          Text.ParserCombinators.ReadP.Look a1_s3rJv [Occ=OnceL!] ->
              let {
                sat_s3rJy [Occ=Once]
                  :: GHC.Base.String -> Text.ParserCombinators.ReadP.P a_a3nFG
                [LclId] =
                    [z_s3rJo a1_s3rJv] \r [b4_s3rJw]
                        case a1_s3rJv b4_s3rJw of sat_s3rJx {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fApplicativeP_$c<$ z_s3rJo sat_s3rJx;
                        };
              } in  Text.ParserCombinators.ReadP.Look [sat_s3rJy];
          Text.ParserCombinators.ReadP.Fail ->
              Text.ParserCombinators.ReadP.Fail [];
          Text.ParserCombinators.ReadP.Result _ [Occ=Dead]
                                              a2_s3rJA [Occ=Once] ->
              let {
                sat_s3rJB [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nFG
                [LclId] =
                    [z_s3rJo a2_s3rJA] \u []
                        Text.ParserCombinators.ReadP.$fApplicativeP_$c<$ z_s3rJo a2_s3rJA;
              } in  Text.ParserCombinators.ReadP.Result [z_s3rJo sat_s3rJB];
          Text.ParserCombinators.ReadP.Final a1_s3rJC [Occ=Once] ->
              let {
                sat_s3rJI [Occ=Once] :: [(a_a3nFG, GHC.Base.String)]
                [LclId] =
                    [z_s3rJo a1_s3rJC] \u []
                        let {
                          sat_s3rJH [Occ=Once]
                            :: (b_a3nFH, GHC.Base.String) -> (a_a3nFG, GHC.Base.String)
                          [LclId] =
                              [z_s3rJo] \r [b3_s3rJD]
                                  case b3_s3rJD of {
                                    (,) _ [Occ=Dead] a3_s3rJG [Occ=Once] -> (,) [z_s3rJo a3_s3rJG];
                                  };
                        } in  GHC.Base.map sat_s3rJH a1_s3rJC;
              } in  Text.ParserCombinators.ReadP.Final [sat_s3rJI];
        };

Text.ParserCombinators.ReadP.$fFunctorP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Text.ParserCombinators.ReadP.P
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                                       Text.ParserCombinators.ReadP.$fApplicativeP_$c<$];

Text.ParserCombinators.ReadP.run [Occ=LoopBreaker]
  :: forall a.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3rJJ ds1_s3rJK]
        case ds_s3rJJ of {
          Text.ParserCombinators.ReadP.Get f_s3rJM [Occ=Once!] ->
              case ds1_s3rJK of {
                [] -> [] [];
                : c_s3rJO [Occ=Once] s_s3rJP [Occ=Once] ->
                    case f_s3rJM c_s3rJO of sat_s3rJQ {
                      __DEFAULT -> Text.ParserCombinators.ReadP.run sat_s3rJQ s_s3rJP;
                    };
              };
          Text.ParserCombinators.ReadP.Look f_s3rJR [Occ=Once!] ->
              case f_s3rJR ds1_s3rJK of sat_s3rJS {
                __DEFAULT -> Text.ParserCombinators.ReadP.run sat_s3rJS ds1_s3rJK;
              };
          Text.ParserCombinators.ReadP.Fail -> [] [];
          Text.ParserCombinators.ReadP.Result x_s3rJT [Occ=Once]
                                              p_s3rJU [Occ=Once] ->
              let {
                sat_s3rJW [Occ=Once] :: [(a_a3nDL, GHC.Base.String)]
                [LclId] =
                    [ds1_s3rJK p_s3rJU] \u []
                        Text.ParserCombinators.ReadP.run p_s3rJU ds1_s3rJK; } in
              let {
                sat_s3rJV [Occ=Once] :: (a_a3nDL, GHC.Base.String)
                [LclId] =
                    CCCS (,)! [x_s3rJT ds1_s3rJK];
              } in  : [sat_s3rJV sat_s3rJW];
          Text.ParserCombinators.ReadP.Final r_s3rJX [Occ=Once] -> r_s3rJX;
        };

Text.ParserCombinators.ReadP.$wreadS_to_P [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3rJY w1_s3rJZ]
        let {
          go_s3rK0 [Occ=LoopBreaker]
            :: [(a_s3ofE, GHC.Base.String)] -> [(b_s3ofG, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w1_s3rJZ go_s3rK0] \r [ds_s3rK1]
                  case ds_s3rK1 of {
                    [] -> [] [];
                    : y_s3rK3 [Occ=Once!] ys_s3rK4 [Occ=Once] ->
                        case y_s3rK3 of {
                          (,) a1_s3rK6 [Occ=Once] s'_s3rK7 [Occ=Once] ->
                              let {
                                sat_s3rKa [Occ=Once, Dmd=<L,1*U>] :: [(b_s3ofG, GHC.Base.String)]
                                [LclId] =
                                    [go_s3rK0 ys_s3rK4] \s [] go_s3rK0 ys_s3rK4;
                              } in 
                                case w1_s3rJZ a1_s3rK6 of sat_s3rK8 {
                                  __DEFAULT ->
                                      case
                                          Text.ParserCombinators.ReadP.run sat_s3rK8 s'_s3rK7
                                      of
                                      sat_s3rK9
                                      { __DEFAULT -> GHC.Base.++ sat_s3rK9 sat_s3rKa;
                                      };
                                };
                        };
                  }; } in
        let {
          sat_s3rKg [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3ofG
          [LclId] =
              [w_s3rJY go_s3rK0] \r [s_s3rKb]
                  case w_s3rJY s_s3rKb of sat_s3rKc {
                    __DEFAULT ->
                        case go_s3rK0 sat_s3rKc of wild_s3rKd {
                          [] -> Text.ParserCombinators.ReadP.Fail [];
                          : _ [Occ=Dead] _ [Occ=Dead] ->
                              Text.ParserCombinators.ReadP.Final [wild_s3rKd];
                        };
                  };
        } in  Unit# [sat_s3rKg];

Text.ParserCombinators.ReadP.readS_to_P1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_s3rKh w1_s3rKi]
        case
            Text.ParserCombinators.ReadP.$wreadS_to_P w_s3rKh w1_s3rKi
        of
        { Unit# ww1_s3rKk [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_s3rKk];
        };

Text.ParserCombinators.ReadP.readS_to_P
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.readS_to_P1 eta_B2 eta_B1;

lvl_r3oqE :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Text/ParserCombinators/ReadP.hs:(134,3)-(157,52)|function <|>"#;

lvl1_r3oqF :: forall a. Text.ParserCombinators.ReadP.P a
[GblId, Str=x] =
    [] \u [] Control.Exception.Base.patError lvl_r3oqE;

Text.ParserCombinators.ReadP.$fAlternativeP_$c<|> [Occ=LoopBreaker]
  :: forall a.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=2, Str=<S,U><L,U>, Unf=OtherCon []] =
    [] \r [ds_s3rKl ds1_s3rKm]
        let-no-escape {
          fail_s3rKn [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
            :: GHC.Prim.Void# -> Text.ParserCombinators.ReadP.P a_a3nLq
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [ds_s3rKl ds1_s3rKm] \r [void_0E]
                  case ds1_s3rKm of wild_s3rKp {
                    __DEFAULT ->
                        case ds_s3rKl of wild1_s3rKq {
                          __DEFAULT ->
                              case wild_s3rKp of wild2_s3rKr {
                                __DEFAULT ->
                                    let-no-escape {
                                      fail1_s3rKs [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
                                        :: GHC.Prim.Void# -> Text.ParserCombinators.ReadP.P a_a3nLq
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [wild1_s3rKq wild2_s3rKr] \r [void_0E]
                                              case wild2_s3rKr of wild3_s3rKu {
                                                __DEFAULT ->
                                                    case wild1_s3rKq of wild4_s3rKv {
                                                      __DEFAULT ->
                                                          case wild3_s3rKu of {
                                                            Text.ParserCombinators.ReadP.Get _ [Occ=Dead] ->
                                                                lvl1_r3oqF;
                                                            Text.ParserCombinators.ReadP.Look f_s3rKy [Occ=OnceL!] ->
                                                                let {
                                                                  sat_s3rKB [Occ=Once]
                                                                    :: GHC.Base.String
                                                                       -> Text.ParserCombinators.ReadP.P
                                                                            a_a3nLq
                                                                  [LclId] =
                                                                      [wild4_s3rKv
                                                                       f_s3rKy] \r [s_s3rKz]
                                                                          let {
                                                                            sat_s3rKA [Occ=Once]
                                                                              :: Text.ParserCombinators.ReadP.P
                                                                                   a_a3nLq
                                                                            [LclId] =
                                                                                [f_s3rKy
                                                                                 s_s3rKz] \u []
                                                                                    f_s3rKy s_s3rKz;
                                                                          } in 
                                                                            Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                                                                wild4_s3rKv
                                                                                sat_s3rKA;
                                                                } in 
                                                                  Text.ParserCombinators.ReadP.Look [sat_s3rKB];
                                                          };
                                                      Text.ParserCombinators.ReadP.Look f_s3rKC [Occ=OnceL*!] ->
                                                          case wild3_s3rKu of wild5_s3rKD {
                                                            Text.ParserCombinators.ReadP.Get _ [Occ=Dead] ->
                                                                let {
                                                                  sat_s3rKH [Occ=Once]
                                                                    :: GHC.Base.String
                                                                       -> Text.ParserCombinators.ReadP.P
                                                                            a_a3nLq
                                                                  [LclId] =
                                                                      [f_s3rKC
                                                                       wild5_s3rKD] \r [s_s3rKF]
                                                                          case
                                                                              f_s3rKC s_s3rKF
                                                                          of
                                                                          sat_s3rKG
                                                                          { __DEFAULT ->
                                                                                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                                                                    sat_s3rKG
                                                                                    wild5_s3rKD;
                                                                          };
                                                                } in 
                                                                  Text.ParserCombinators.ReadP.Look [sat_s3rKH];
                                                            Text.ParserCombinators.ReadP.Look g_s3rKI [Occ=OnceL!] ->
                                                                let {
                                                                  sat_s3rKM [Occ=Once]
                                                                    :: GHC.Base.String
                                                                       -> Text.ParserCombinators.ReadP.P
                                                                            a_a3nLq
                                                                  [LclId] =
                                                                      [f_s3rKC g_s3rKI] \r [s_s3rKJ]
                                                                          let {
                                                                            sat_s3rKL [Occ=Once]
                                                                              :: Text.ParserCombinators.ReadP.P
                                                                                   a_a3nLq
                                                                            [LclId] =
                                                                                [g_s3rKI
                                                                                 s_s3rKJ] \u []
                                                                                    g_s3rKI s_s3rKJ;
                                                                          } in 
                                                                            case
                                                                                f_s3rKC s_s3rKJ
                                                                            of
                                                                            sat_s3rKK
                                                                            { __DEFAULT ->
                                                                                  Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                                                                      sat_s3rKK
                                                                                      sat_s3rKL;
                                                                            };
                                                                } in 
                                                                  Text.ParserCombinators.ReadP.Look [sat_s3rKM];
                                                          };
                                                    };
                                                Text.ParserCombinators.ReadP.Final r_s3rKN [Occ=OnceL] ->
                                                    let {
                                                      sat_s3rKR [Occ=Once]
                                                        :: GHC.Base.String
                                                           -> Text.ParserCombinators.ReadP.P a_a3nLq
                                                      [LclId] =
                                                          [wild1_s3rKq r_s3rKN] \r [s_s3rKO]
                                                              let {
                                                                sat_s3rKQ [Occ=Once]
                                                                  :: [(a_a3nLq, GHC.Base.String)]
                                                                [LclId] =
                                                                    [wild1_s3rKq
                                                                     r_s3rKN
                                                                     s_s3rKO] \u []
                                                                        case
                                                                            Text.ParserCombinators.ReadP.run
                                                                                wild1_s3rKq s_s3rKO
                                                                        of
                                                                        sat_s3rKP
                                                                        { __DEFAULT ->
                                                                              GHC.Base.++
                                                                                  sat_s3rKP r_s3rKN;
                                                                        };
                                                              } in 
                                                                Text.ParserCombinators.ReadP.Final [sat_s3rKQ];
                                                    } in 
                                                      Text.ParserCombinators.ReadP.Look [sat_s3rKR];
                                              };
                                    } in 
                                      case wild1_s3rKq of {
                                        __DEFAULT -> fail1_s3rKs GHC.Prim.void#;
                                        Text.ParserCombinators.ReadP.Look f_s3rKT [Occ=OnceL!] ->
                                            case wild2_s3rKr of {
                                              __DEFAULT -> fail1_s3rKs GHC.Prim.void#;
                                              Text.ParserCombinators.ReadP.Final r_s3rKV [Occ=OnceL] ->
                                                  let {
                                                    sat_s3rL0 [Occ=Once]
                                                      :: GHC.Base.String
                                                         -> Text.ParserCombinators.ReadP.P a_a3nLq
                                                    [LclId] =
                                                        [f_s3rKT r_s3rKV] \r [s_s3rKW]
                                                            let {
                                                              sat_s3rKZ [Occ=Once]
                                                                :: [(a_a3nLq, GHC.Base.String)]
                                                              [LclId] =
                                                                  [f_s3rKT r_s3rKV s_s3rKW] \u []
                                                                      case
                                                                          f_s3rKT s_s3rKW
                                                                      of
                                                                      sat_s3rKX
                                                                      { __DEFAULT ->
                                                                            case
                                                                                Text.ParserCombinators.ReadP.run
                                                                                    sat_s3rKX
                                                                                    s_s3rKW
                                                                            of
                                                                            sat_s3rKY
                                                                            { __DEFAULT ->
                                                                                  GHC.Base.++
                                                                                      sat_s3rKY
                                                                                      r_s3rKV;
                                                                            };
                                                                      };
                                                            } in 
                                                              Text.ParserCombinators.ReadP.Final [sat_s3rKZ];
                                                  } in 
                                                    Text.ParserCombinators.ReadP.Look [sat_s3rL0];
                                            };
                                        Text.ParserCombinators.ReadP.Final r_s3rL1 [Occ=OnceL*] ->
                                            case wild2_s3rKr of wild4_s3rL2 {
                                              Text.ParserCombinators.ReadP.Get _ [Occ=Dead] ->
                                                  let {
                                                    sat_s3rL7 [Occ=Once]
                                                      :: GHC.Base.String
                                                         -> Text.ParserCombinators.ReadP.P a_a3nLq
                                                    [LclId] =
                                                        [r_s3rL1 wild4_s3rL2] \r [s_s3rL4]
                                                            let {
                                                              sat_s3rL6 [Occ=Once]
                                                                :: [(a_a3nLq, GHC.Base.String)]
                                                              [LclId] =
                                                                  [r_s3rL1
                                                                   wild4_s3rL2
                                                                   s_s3rL4] \u []
                                                                      let {
                                                                        sat_s3rL5 [Occ=Once,
                                                                                   Dmd=<L,1*U>]
                                                                          :: [(a_a3nLq,
                                                                               GHC.Base.String)]
                                                                        [LclId] =
                                                                            [wild4_s3rL2
                                                                             s_s3rL4] \s []
                                                                                Text.ParserCombinators.ReadP.run
                                                                                    wild4_s3rL2
                                                                                    s_s3rL4;
                                                                      } in 
                                                                        GHC.Base.++
                                                                            r_s3rL1 sat_s3rL5;
                                                            } in 
                                                              Text.ParserCombinators.ReadP.Final [sat_s3rL6];
                                                  } in 
                                                    Text.ParserCombinators.ReadP.Look [sat_s3rL7];
                                              Text.ParserCombinators.ReadP.Look f_s3rL8 [Occ=OnceL!] ->
                                                  let {
                                                    sat_s3rLd [Occ=Once]
                                                      :: GHC.Base.String
                                                         -> Text.ParserCombinators.ReadP.P a_a3nLq
                                                    [LclId] =
                                                        [r_s3rL1 f_s3rL8] \r [s_s3rL9]
                                                            let {
                                                              sat_s3rLc [Occ=Once]
                                                                :: [(a_a3nLq, GHC.Base.String)]
                                                              [LclId] =
                                                                  [r_s3rL1 f_s3rL8 s_s3rL9] \u []
                                                                      let {
                                                                        sat_s3rLb [Occ=Once,
                                                                                   Dmd=<L,1*U>]
                                                                          :: [(a_a3nLq,
                                                                               GHC.Base.String)]
                                                                        [LclId] =
                                                                            [f_s3rL8 s_s3rL9] \s []
                                                                                case
                                                                                    f_s3rL8 s_s3rL9
                                                                                of
                                                                                sat_s3rLa
                                                                                { __DEFAULT ->
                                                                                      Text.ParserCombinators.ReadP.run
                                                                                          sat_s3rLa
                                                                                          s_s3rL9;
                                                                                };
                                                                      } in 
                                                                        GHC.Base.++
                                                                            r_s3rL1 sat_s3rLb;
                                                            } in 
                                                              Text.ParserCombinators.ReadP.Final [sat_s3rLc];
                                                  } in 
                                                    Text.ParserCombinators.ReadP.Look [sat_s3rLd];
                                              Text.ParserCombinators.ReadP.Final t_s3rLe [Occ=Once] ->
                                                  let {
                                                    sat_s3rLf [Occ=Once]
                                                      :: [(a_a3nLq, GHC.Base.String)]
                                                    [LclId] =
                                                        [r_s3rL1 t_s3rLe] \u []
                                                            GHC.Base.++ r_s3rL1 t_s3rLe;
                                                  } in 
                                                    Text.ParserCombinators.ReadP.Final [sat_s3rLf];
                                            };
                                      };
                                Text.ParserCombinators.ReadP.Fail -> wild1_s3rKq;
                              };
                          Text.ParserCombinators.ReadP.Fail -> wild_s3rKp;
                        };
                    Text.ParserCombinators.ReadP.Result x_s3rLg [Occ=Once]
                                                        q_s3rLh [Occ=Once] ->
                        let {
                          sat_s3rLi [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nLq
                          [LclId] =
                              [ds_s3rKl q_s3rLh] \u []
                                  Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                      ds_s3rKl q_s3rLh;
                        } in  Text.ParserCombinators.ReadP.Result [x_s3rLg sat_s3rLi];
                  };
        } in 
          case ds_s3rKl of {
            __DEFAULT -> fail_s3rKn GHC.Prim.void#;
            Text.ParserCombinators.ReadP.Get f1_s3rLk [Occ=OnceL!] ->
                case ds1_s3rKm of {
                  __DEFAULT -> fail_s3rKn GHC.Prim.void#;
                  Text.ParserCombinators.ReadP.Get f2_s3rLm [Occ=OnceL!] ->
                      let {
                        sat_s3rLq [Occ=Once]
                          :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P a_a3nLq
                        [LclId] =
                            [f1_s3rLk f2_s3rLm] \r [c_s3rLn]
                                let {
                                  sat_s3rLp [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nLq
                                  [LclId] =
                                      [f2_s3rLm c_s3rLn] \u [] f2_s3rLm c_s3rLn;
                                } in 
                                  case f1_s3rLk c_s3rLn of sat_s3rLo {
                                    __DEFAULT ->
                                        Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                            sat_s3rLo sat_s3rLp;
                                  };
                      } in  Text.ParserCombinators.ReadP.Get [sat_s3rLq];
                };
            Text.ParserCombinators.ReadP.Result x_s3rLr [Occ=Once]
                                                p_s3rLs [Occ=Once] ->
                let {
                  sat_s3rLt [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nLq
                  [LclId] =
                      [ds1_s3rKm p_s3rLs] \u []
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                              p_s3rLs ds1_s3rKm;
                } in  Text.ParserCombinators.ReadP.Result [x_s3rLr sat_s3rLt];
          };

Text.ParserCombinators.ReadP.$fAlternativeP_$c>>= [Occ=LoopBreaker]
  :: forall a b.
     Text.ParserCombinators.ReadP.P a
     -> (a -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,1*U><L,C(U)>, Unf=OtherCon []] =
    [] \r [ds_s3rLu k_s3rLv]
        case ds_s3rLu of {
          Text.ParserCombinators.ReadP.Get f_s3rLx [Occ=OnceL!] ->
              let {
                sat_s3rLA [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_a3nML
                [LclId] =
                    [k_s3rLv f_s3rLx] \r [c_s3rLy]
                        case f_s3rLx c_s3rLy of sat_s3rLz {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                  sat_s3rLz k_s3rLv;
                        };
              } in  Text.ParserCombinators.ReadP.Get [sat_s3rLA];
          Text.ParserCombinators.ReadP.Look f_s3rLB [Occ=OnceL!] ->
              let {
                sat_s3rLE [Occ=Once]
                  :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3nML
                [LclId] =
                    [k_s3rLv f_s3rLB] \r [s_s3rLC]
                        case f_s3rLB s_s3rLC of sat_s3rLD {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                  sat_s3rLD k_s3rLv;
                        };
              } in  Text.ParserCombinators.ReadP.Look [sat_s3rLE];
          Text.ParserCombinators.ReadP.Fail ->
              Text.ParserCombinators.ReadP.Fail [];
          Text.ParserCombinators.ReadP.Result x_s3rLF [Occ=Once]
                                              p_s3rLG [Occ=Once] ->
              let {
                sat_s3rLI [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nML
                [LclId] =
                    [k_s3rLv p_s3rLG] \u []
                        Text.ParserCombinators.ReadP.$fAlternativeP_$c>>= p_s3rLG k_s3rLv;
              } in 
                case k_s3rLv x_s3rLF of sat_s3rLH {
                  __DEFAULT ->
                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                          sat_s3rLH sat_s3rLI;
                };
          Text.ParserCombinators.ReadP.Final r_s3rLJ [Occ=Once] ->
              let {
                go_s3rLK [Occ=LoopBreaker]
                  :: [(a_a3nMK, GHC.Base.String)] -> [(b_a3nML, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [k_s3rLv go_s3rLK] \r [ds1_s3rLL]
                        case ds1_s3rLL of {
                          [] -> [] [];
                          : y_s3rLN [Occ=Once!] ys_s3rLO [Occ=Once] ->
                              case y_s3rLN of {
                                (,) x_s3rLQ [Occ=Once] s_s3rLR [Occ=Once] ->
                                    let {
                                      sat_s3rLU [Occ=Once, Dmd=<L,1*U>]
                                        :: [(b_a3nML, GHC.Base.String)]
                                      [LclId] =
                                          [go_s3rLK ys_s3rLO] \s [] go_s3rLK ys_s3rLO;
                                    } in 
                                      case k_s3rLv x_s3rLQ of sat_s3rLS {
                                        __DEFAULT ->
                                            case
                                                Text.ParserCombinators.ReadP.run sat_s3rLS s_s3rLR
                                            of
                                            sat_s3rLT
                                            { __DEFAULT -> GHC.Base.++ sat_s3rLT sat_s3rLU;
                                            };
                                      };
                              };
                        };
              } in 
                case go_s3rLK r_s3rLJ of wild1_s3rLV {
                  [] -> Text.ParserCombinators.ReadP.Fail [];
                  : _ [Occ=Dead] _ [Occ=Dead] ->
                      Text.ParserCombinators.ReadP.Final [wild1_s3rLV];
                };
        };

Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
  :: forall a b.
     Text.ParserCombinators.ReadP.P (a -> b)
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [m1_s3rLY m2_s3rLZ]
        let {
          sat_s3rM4 [Occ=Once]
            :: (a_a3nOe -> b_a3nOf) -> Text.ParserCombinators.ReadP.P b_a3nOf
          [LclId] =
              [m2_s3rLZ] \r [x1_s3rM0]
                  let {
                    sat_s3rM3 [Occ=Once]
                      :: a_a3nOe -> Text.ParserCombinators.ReadP.P b_a3nOf
                    [LclId] =
                        [x1_s3rM0] \r [x2_s3rM1]
                            let {
                              sat_s3rM2 [Occ=Once] :: b_a3nOf
                              [LclId] =
                                  [x1_s3rM0 x2_s3rM1] \u [] x1_s3rM0 x2_s3rM1;
                            } in 
                              Text.ParserCombinators.ReadP.Result [sat_s3rM2
                                                                   Text.ParserCombinators.ReadP.Fail];
                  } in 
                    Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                        m2_s3rLZ sat_s3rM3;
        } in 
          Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
              m1_s3rLY sat_s3rM4;

Text.ParserCombinators.ReadP.$fApplicativeP_$cliftA2
  :: forall a b c.
     (a -> b -> c)
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P c
[GblId, Arity=2, Str=<L,C(U)><L,1*U>, Unf=OtherCon []] =
    [] \r [f1_s3rM5 x_s3rM6]
        let {
          sat_s3rM7 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (b_a3nOq -> c_a3nOr)
          [LclId] =
              [f1_s3rM5 x_s3rM6] \u []
                  Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                      f1_s3rM5 x_s3rM6;
        } in  Text.ParserCombinators.ReadP.$fAlternativeP_$c<*> sat_s3rM7;

Text.ParserCombinators.ReadP.$fAlternativeP1
  :: forall a. Text.ParserCombinators.ReadP.P [a]
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.ParserCombinators.ReadP.Result! [GHC.Types.[]
                                                        Text.ParserCombinators.ReadP.Fail];

Text.ParserCombinators.ReadP.$fAlternativeP_$csome
  :: forall a.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P [a]
[GblId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_s3rM8]
        let {
          some_v_s3rM9 [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadP.P [a_a3nMc]
          [LclId] =
              [v_s3rM8 some_v_s3rM9] \u []
                  let {
                    m2_s3rMa [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_a3nMc]
                    [LclId] =
                        [some_v_s3rM9] \u []
                            Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                some_v_s3rM9 Text.ParserCombinators.ReadP.$fAlternativeP1; } in
                  let {
                    sat_s3rMg [Occ=Once]
                      :: ([a_a3nMc] -> [a_a3nMc])
                         -> Text.ParserCombinators.ReadP.P [a_a3nMc]
                    [LclId] =
                        [m2_s3rMa] \r [x1_s3rMc]
                            let {
                              sat_s3rMf [Occ=Once]
                                :: [a_a3nMc] -> Text.ParserCombinators.ReadP.P [a_a3nMc]
                              [LclId] =
                                  [x1_s3rMc] \r [x2_s3rMd]
                                      let {
                                        sat_s3rMe [Occ=Once] :: [a_a3nMc]
                                        [LclId] =
                                            [x1_s3rMc x2_s3rMd] \u [] x1_s3rMc x2_s3rMd;
                                      } in 
                                        Text.ParserCombinators.ReadP.Result [sat_s3rMe
                                                                             Text.ParserCombinators.ReadP.Fail];
                            } in 
                              Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                  m2_s3rMa sat_s3rMf;
                  } in 
                    case
                        Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                            GHC.Types.: v_s3rM8
                    of
                    sat_s3rMb
                    { __DEFAULT ->
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                              sat_s3rMb sat_s3rMg;
                    };
        } in  some_v_s3rM9;

Text.ParserCombinators.ReadP.$fApplicativeP_$c<*
  :: forall a b.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=1, Str=<L,1*U>, Unf=OtherCon []] =
    [] \r [x_s3rMh]
        let {
          sat_s3rMi [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (b_a3nOM -> a_a3nOL)
          [LclId] =
              [x_s3rMh] \u []
                  Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                      GHC.Base.const x_s3rMh;
        } in  Text.ParserCombinators.ReadP.$fAlternativeP_$c<*> sat_s3rMi;

Text.ParserCombinators.ReadP.$fApplicativeP_$c*>
  :: forall a b.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [a1_s3rMj a2_s3rMk]
        case
            Text.ParserCombinators.ReadP.$fApplicativeP_$c<$
                GHC.Base.breakpoint a1_s3rMj
        of
        sat_s3rMl
        { __DEFAULT ->
              Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
                  sat_s3rMl a2_s3rMk;
        };

Text.ParserCombinators.ReadP.$fAlternativeP_$cmany
  :: forall a.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P [a]
[GblId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_s3rMm]
        let {
          many_v_s3rMn [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadP.P [a_a3nMk]
          [LclId] =
              [v_s3rMm many_v_s3rMn] \u []
                  case
                      Text.ParserCombinators.ReadP.$fAlternativeP_$cfmap
                          GHC.Types.: v_s3rMm
                  of
                  sat_s3rMo
                  { __DEFAULT ->
                        case
                            Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
                                sat_s3rMo many_v_s3rMn
                        of
                        sat_s3rMp
                        { __DEFAULT ->
                              Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                  sat_s3rMp Text.ParserCombinators.ReadP.$fAlternativeP1;
                        };
                  };
        } in  many_v_s3rMn;

Text.ParserCombinators.ReadP.$fMonadP_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P b
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [eta_s3rMq eta1_s3rMr]
        let {
          sat_s3rMt [Occ=Once]
            :: a_a3nNd -> Text.ParserCombinators.ReadP.P b_a3nNe
          [LclId] =
              [eta1_s3rMr] \r [ds_s3rMs] eta1_s3rMr;
        } in 
          Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
              eta_s3rMq sat_s3rMt;

Text.ParserCombinators.ReadP.$fApplicativeP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Text.ParserCombinators.ReadP.$fFunctorP
                                           Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                                           Text.ParserCombinators.ReadP.$fAlternativeP_$c<*>
                                           Text.ParserCombinators.ReadP.$fApplicativeP_$cliftA2
                                           Text.ParserCombinators.ReadP.$fApplicativeP_$c*>
                                           Text.ParserCombinators.ReadP.$fApplicativeP_$c<*];

Text.ParserCombinators.ReadP.$fMonadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Text.ParserCombinators.ReadP.$fApplicativeP
                                     Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                     Text.ParserCombinators.ReadP.$fMonadP_$c>>
                                     Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                                     Text.ParserCombinators.ReadP.$fMonadFailP_$cfail];

Text.ParserCombinators.ReadP.$fAlternativeP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Text.ParserCombinators.ReadP.$fApplicativeP
                                           Text.ParserCombinators.ReadP.Fail
                                           Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                           Text.ParserCombinators.ReadP.$fAlternativeP_$csome
                                           Text.ParserCombinators.ReadP.$fAlternativeP_$cmany];

Text.ParserCombinators.ReadP.readP_to_S
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadS a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [ds_s3rMu]
        let {
          sat_s3rMv [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3nDT
          [LclId] =
              [ds_s3rMu] \u []
                  ds_s3rMu Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s3rMv;

Text.ParserCombinators.ReadP.$fMonadFailP [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fail.C:MonadFail! [Text.ParserCombinators.ReadP.$fMonadP
                                                   Text.ParserCombinators.ReadP.$fMonadFailP_$cfail];

Text.ParserCombinators.ReadP.$fMonadPlusP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus Text.ParserCombinators.ReadP.P
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [Text.ParserCombinators.ReadP.$fAlternativeP
                                         Text.ParserCombinators.ReadP.$fMonadP
                                         Text.ParserCombinators.ReadP.Fail
                                         Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>];

Text.ParserCombinators.ReadP.get
  :: Text.ParserCombinators.ReadP.ReadP GHC.Types.Char
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m1, Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Get [eta_B1];

Text.ParserCombinators.ReadP.look
  :: Text.ParserCombinators.ReadP.ReadP GHC.Base.String
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Look [eta_B1];

Text.ParserCombinators.ReadP.$fAlternativeReadP4
  :: forall a b.
     (a -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s3rMw] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadP.pfail
  :: forall a. Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.$fAlternativeReadP4 eta_B1;

Text.ParserCombinators.ReadP.$fAlternativeReadP3
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3rMx ds1_s3rMy k_s3rMz]
        let {
          sat_s3rMB [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
          [LclId] =
              [ds1_s3rMy k_s3rMz] \u [] ds1_s3rMy k_s3rMz;
        } in 
          case ds_s3rMx k_s3rMz of sat_s3rMA {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3rMA sat_s3rMB;
          };

Text.ParserCombinators.ReadP.+++
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.$fAlternativeReadP3
            eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.choice [Occ=LoopBreaker]
  :: forall a.
     [Text.ParserCombinators.ReadP.ReadP a]
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s3rMC]
        case ds_s3rMC of {
          [] -> Text.ParserCombinators.ReadP.$fAlternativeReadP4;
          : p_s3rME [Occ=OnceL*] ds1_s3rMF [Occ=Once!] ->
              case ds1_s3rMF of wild1_s3rMG {
                [] -> p_s3rME;
                : _ [Occ=Dead] _ [Occ=Dead] ->
                    let {
                      ds2_s3rMJ [Occ=OnceL, Dmd=<L,C(U)>]
                        :: Text.ParserCombinators.ReadP.ReadP a_a3nzc
                      [LclId] =
                          [wild1_s3rMG] \u []
                              Text.ParserCombinators.ReadP.choice wild1_s3rMG; } in
                    let {
                      sat_s3rMN [Occ=Once]
                        :: forall b.
                           (a_a3nzc -> Text.ParserCombinators.ReadP.P b)
                           -> Text.ParserCombinators.ReadP.P b
                      [LclId] =
                          [p_s3rME ds2_s3rMJ] \r [k_s3rMK]
                              let {
                                sat_s3rMM [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
                                [LclId] =
                                    [ds2_s3rMJ k_s3rMK] \u [] ds2_s3rMJ k_s3rMK;
                              } in 
                                case p_s3rME k_s3rMK of sat_s3rML {
                                  __DEFAULT ->
                                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                          sat_s3rML sat_s3rMM;
                                };
                    } in  sat_s3rMN;
              };
        };

lvl2_r3oqG :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "do not use readS_to_P in gather!"#;

lvl3_r3oqH :: forall b. Text.ParserCombinators.ReadP.P b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_r3oqG of sat_s3rMO {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s3rMO;
        };

Text.ParserCombinators.ReadP.gather_gath [Occ=LoopBreaker]
  :: forall b.
     (GHC.Base.String -> GHC.Base.String)
     -> Text.ParserCombinators.ReadP.P
          (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,C(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [l_s3rMP ds_s3rMQ]
        case ds_s3rMQ of {
          Text.ParserCombinators.ReadP.Get f_s3rMS [Occ=OnceL!] ->
              let {
                sat_s3rMY [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_a3nv3
                [LclId] =
                    [l_s3rMP f_s3rMS] \r [c_s3rMT]
                        case f_s3rMS c_s3rMT of sat_s3rMX {
                          __DEFAULT ->
                              let {
                                sat_s3rMW [Occ=Once] :: GHC.Base.String -> GHC.Base.String
                                [LclId] =
                                    [l_s3rMP c_s3rMT] \r [x_s3rMU]
                                        let {
                                          sat_s3rMV [Occ=Once] :: GHC.Base.String
                                          [LclId] =
                                              CCCS :! [c_s3rMT x_s3rMU];
                                        } in  l_s3rMP sat_s3rMV;
                              } in  Text.ParserCombinators.ReadP.gather_gath sat_s3rMW sat_s3rMX;
                        };
              } in  Text.ParserCombinators.ReadP.Get [sat_s3rMY];
          Text.ParserCombinators.ReadP.Look f_s3rMZ [Occ=OnceL!] ->
              let {
                sat_s3rN2 [Occ=Once]
                  :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3nv3
                [LclId] =
                    [l_s3rMP f_s3rMZ] \r [s_s3rN0]
                        case f_s3rMZ s_s3rN0 of sat_s3rN1 {
                          __DEFAULT ->
                              Text.ParserCombinators.ReadP.gather_gath l_s3rMP sat_s3rN1;
                        };
              } in  Text.ParserCombinators.ReadP.Look [sat_s3rN2];
          Text.ParserCombinators.ReadP.Fail ->
              Text.ParserCombinators.ReadP.Fail [];
          Text.ParserCombinators.ReadP.Result k_s3rN3 [Occ=Once!]
                                              p_s3rN4 [Occ=Once] ->
              let {
                sat_s3rN7 [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nv3
                [LclId] =
                    [l_s3rMP p_s3rN4] \u []
                        Text.ParserCombinators.ReadP.gather_gath l_s3rMP p_s3rN4; } in
              let {
                sat_s3rN5 [Occ=Once] :: GHC.Base.String
                [LclId] =
                    [l_s3rMP] \u [] l_s3rMP GHC.Types.[];
              } in 
                case k_s3rN3 sat_s3rN5 of sat_s3rN6 {
                  __DEFAULT ->
                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                          sat_s3rN6 sat_s3rN7;
                };
          Text.ParserCombinators.ReadP.Final _ [Occ=Dead] -> lvl3_r3oqH;
        };

Text.ParserCombinators.ReadP.gather1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ((GHC.Base.String, a) -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),1*C1(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [ds_s3rN9 eta_s3rNa]
        let {
          sat_s3rNf [Occ=Once]
            :: a_a3nuK
               -> Text.ParserCombinators.ReadP.P
                    (GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3ngn)
          [LclId] =
              [eta_s3rNa] \r [a1_s3rNb]
                  let {
                    sat_s3rNe [Occ=Once]
                      :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [eta_s3rNa a1_s3rNb] \r [s_s3rNc]
                            let {
                              sat_s3rNd [Occ=Once] :: (GHC.Base.String, a_a3nuK)
                              [LclId] =
                                  CCCS (,)! [s_s3rNc a1_s3rNb];
                            } in  eta_s3rNa sat_s3rNd;
                  } in 
                    Text.ParserCombinators.ReadP.Result [sat_s3rNe
                                                         Text.ParserCombinators.ReadP.Fail];
        } in 
          case ds_s3rN9 sat_s3rNf of sat_s3rNg {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.gather_gath GHC.Base.id sat_s3rNg;
          };

Text.ParserCombinators.ReadP.gather
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (GHC.Base.String, a)
[GblId, Arity=2, Str=<C(S),1*C1(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.gather1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Text.ParserCombinators.ReadP.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$trModule4];

Text.ParserCombinators.ReadP.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Text.ParserCombinators.ReadP"#;

Text.ParserCombinators.ReadP.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$trModule2];

Text.ParserCombinators.ReadP.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Text.ParserCombinators.ReadP.$trModule3
                                     Text.ParserCombinators.ReadP.$trModule1];

$krep_r3oqI :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcChar
                                              GHC.Types.[]];

$krep1_r3oqJ :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r3oqI GHC.Types.[]];

$krep2_r3oqK :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc[]
                                              $krep1_r3oqJ];

$krep3_r3oqL :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep4_r3oqM :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_r3oqK GHC.Types.[]];

$krep5_r3oqN :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r3oqL $krep4_r3oqM];

$krep6_r3oqO :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Tuple.$tc(,)
                                              $krep5_r3oqN];

$krep7_r3oqP :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep6_r3oqO GHC.Types.[]];

$krep8_r3oqQ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc[]
                                              $krep7_r3oqP];

Text.ParserCombinators.ReadP.$tcP2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "P"#;

Text.ParserCombinators.ReadP.$tcP1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tcP2];

Text.ParserCombinators.ReadP.$tcP :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4287589432649596960##
                                    9029773818181158220##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tcP1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep9_r3oqR :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r3oqL GHC.Types.[]];

Text.ParserCombinators.ReadP.$tc'Fail1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Text.ParserCombinators.ReadP.$tcP
                                              $krep9_r3oqR];

Text.ParserCombinators.ReadP.$tc'Fail3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Fail"#;

Text.ParserCombinators.ReadP.$tc'Fail2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Fail3];

Text.ParserCombinators.ReadP.$tc'Fail :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16564457091671581868##
                                    4540703186775139959##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Fail2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Fail1];

$krep10_r3oqS :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [Text.ParserCombinators.ReadP.$tc'Fail1
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Result1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r3oqL $krep10_r3oqS];

Text.ParserCombinators.ReadP.$tc'Result3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Result"#;

Text.ParserCombinators.ReadP.$tc'Result2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Result3];

Text.ParserCombinators.ReadP.$tc'Result :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14629176799732153257##
                                    2029199220309899277##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Result2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Result1];

Text.ParserCombinators.ReadP.$tc'Final1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r3oqQ
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Final3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Final"#;

Text.ParserCombinators.ReadP.$tc'Final2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Final3];

Text.ParserCombinators.ReadP.$tc'Final :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9825883373667767852##
                                    1277540149077833820##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Final2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Final1];

$krep11_r3oqT :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r3oqK
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Look1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r3oqT
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Look3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Look"#;

Text.ParserCombinators.ReadP.$tc'Look2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Look3];

Text.ParserCombinators.ReadP.$tc'Look :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11302519862508684236##
                                    969530656846011597##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Look2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Look1];

$krep12_r3oqU :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r3oqI
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Get1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep12_r3oqU
                                         Text.ParserCombinators.ReadP.$tc'Fail1];

Text.ParserCombinators.ReadP.$tc'Get3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Get"#;

Text.ParserCombinators.ReadP.$tc'Get2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tc'Get3];

Text.ParserCombinators.ReadP.$tc'Get :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10806119809527641225##
                                    14618661019746688366##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tc'Get2
                                    1#
                                    Text.ParserCombinators.ReadP.$tc'Get1];

Text.ParserCombinators.ReadP.$tcReadP2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ReadP"#;

Text.ParserCombinators.ReadP.$tcReadP1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadP.$tcReadP2];

Text.ParserCombinators.ReadP.$tcReadP :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15640243629783811470##
                                    8988027559298507146##
                                    Text.ParserCombinators.ReadP.$trModule
                                    Text.ParserCombinators.ReadP.$tcReadP1
                                    0#
                                    GHC.Types.krep$*Arr*];

Text.ParserCombinators.ReadP.$fApplicativeReadP4
  :: forall b a.
     Text.ParserCombinators.ReadP.ReadP (a -> b)
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [m1_s3rNh m2_s3rNi k_s3rNj]
        let {
          sat_s3rNo [Occ=Once]
            :: (a_a3nK0 -> b_a3nK1) -> Text.ParserCombinators.ReadP.P b1_a3nIU
          [LclId] =
              [m2_s3rNi k_s3rNj] \r [a1_s3rNk]
                  let {
                    sat_s3rNn [Occ=Once]
                      :: a_a3nK0 -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [k_s3rNj a1_s3rNk] \r [a2_s3rNl]
                            let {
                              sat_s3rNm [Occ=Once] :: b_a3nK1
                              [LclId] =
                                  [a1_s3rNk a2_s3rNl] \u [] a1_s3rNk a2_s3rNl;
                            } in  k_s3rNj sat_s3rNm;
                  } in  m2_s3rNi sat_s3rNn;
        } in  m1_s3rNh sat_s3rNo;

Text.ParserCombinators.ReadP.$fApplicativeReadP2
  :: forall a b.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [a1_s3rNp a2_s3rNq eta_s3rNr]
        let {
          lvl4_s3rNs [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [a2_s3rNq eta_s3rNr] \u []
                  let {
                    sat_s3rNu [Occ=Once]
                      :: b_a3nKt -> Text.ParserCombinators.ReadP.P b1_a3ngn
                    [LclId] =
                        [eta_s3rNr] \r [a4_s3rNt] eta_s3rNr a4_s3rNt;
                  } in  a2_s3rNq sat_s3rNu; } in
        let {
          sat_s3rNw [Occ=Once]
            :: a_a3nKs -> Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [lvl4_s3rNs] \r [x_s3rNv] lvl4_s3rNs;
        } in  a1_s3rNp sat_s3rNw;

Text.ParserCombinators.ReadP.$fApplicativeReadP3
  :: forall a b c.
     (a -> b -> c)
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (c -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C(U))><C(S),1*C1(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [f1_s3rNx x_s3rNy eta_s3rNz eta1_s3rNA]
        let {
          sat_s3rNG [Occ=Once]
            :: a_a3nKg -> Text.ParserCombinators.ReadP.P b1_a3ngn
          [LclId] =
              [f1_s3rNx eta_s3rNz eta1_s3rNA] \r [x1_s3rNB]
                  let {
                    a1_s3rNC [Occ=OnceL!, Dmd=<L,C(U)>] :: b_a3nKh -> c_a3nKi
                    [LclId] =
                        [f1_s3rNx x1_s3rNB] \u [] f1_s3rNx x1_s3rNB; } in
                  let {
                    sat_s3rNF [Occ=Once]
                      :: b_a3nKh -> Text.ParserCombinators.ReadP.P b1_a3ngn
                    [LclId] =
                        [eta1_s3rNA a1_s3rNC] \r [a2_s3rND]
                            let {
                              sat_s3rNE [Occ=Once] :: c_a3nKi
                              [LclId] =
                                  [a1_s3rNC a2_s3rND] \u [] a1_s3rNC a2_s3rND;
                            } in  eta1_s3rNA sat_s3rNE;
                  } in  eta_s3rNz sat_s3rNF;
        } in  x_s3rNy sat_s3rNG;

Text.ParserCombinators.ReadP.$fApplicativeReadP1
  :: forall b a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (a -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [x_s3rNH eta_s3rNI eta1_s3rNJ]
        let {
          sat_s3rNO [Occ=Once]
            :: a_a3nKC -> Text.ParserCombinators.ReadP.P b1_X3nkp
          [LclId] =
              [eta_s3rNI eta1_s3rNJ] \r [x1_s3rNK]
                  let {
                    lvl4_s3rNL [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_X3nkp
                    [LclId] =
                        [eta1_s3rNJ x1_s3rNK] \u [] eta1_s3rNJ x1_s3rNK; } in
                  let {
                    sat_s3rNN [Occ=Once]
                      :: b_a3nKD -> Text.ParserCombinators.ReadP.P b1_X3nkp
                    [LclId] =
                        [lvl4_s3rNL] \r [a1_s3rNM] lvl4_s3rNL;
                  } in  eta_s3rNI sat_s3rNN;
        } in  x_s3rNH sat_s3rNO;

$c>>_r3oqV
  :: forall a b.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> forall b1.
        (b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [eta_s3rNP eta1_s3rNQ k_s3rNR]
        let {
          lvl4_s3rNS [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
          [LclId] =
              [eta1_s3rNQ k_s3rNR] \u [] eta1_s3rNQ k_s3rNR; } in
        let {
          sat_s3rNU [Occ=Once]
            :: a_a3nJi -> Text.ParserCombinators.ReadP.P b1_a3nIU
          [LclId] =
              [lvl4_s3rNS] \r [a1_s3rNT] lvl4_s3rNS;
        } in  eta_s3rNP sat_s3rNU;

Text.ParserCombinators.ReadP.$fMonadReadP_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP b
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] $c>>_r3oqV eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$fApplicativeReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Text.ParserCombinators.ReadP.$fFunctorReadP
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP5
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP4
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP3
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP2
                                           Text.ParserCombinators.ReadP.$fApplicativeReadP1];

Text.ParserCombinators.ReadP.$fMonadReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Text.ParserCombinators.ReadP.$fApplicativeReadP
                                     Text.ParserCombinators.ReadP.$fMonadReadP1
                                     Text.ParserCombinators.ReadP.$fMonadReadP_$c>>
                                     Text.ParserCombinators.ReadP.$fApplicativeReadP5
                                     Text.ParserCombinators.ReadP.$fMonadFailReadP1];

Text.ParserCombinators.ReadP.between1
  :: forall open close a.
     Text.ParserCombinators.ReadP.ReadP open
     -> Text.ParserCombinators.ReadP.ReadP close
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,1*C1(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [open1_s3rNV close1_s3rNW p_s3rNX k_s3rNY]
        let {
          lvl4_s3rNZ [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3nIU
          [LclId] =
              [close1_s3rNW p_s3rNX k_s3rNY] \u []
                  let {
                    sat_s3rO4 [Occ=Once]
                      :: a_a3nui -> Text.ParserCombinators.ReadP.P b_a3nIU
                    [LclId] =
                        [close1_s3rNW k_s3rNY] \r [a1_s3rO0]
                            let {
                              lvl5_s3rO1 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3nIU
                              [LclId] =
                                  [k_s3rNY a1_s3rO0] \u [] k_s3rNY a1_s3rO0; } in
                            let {
                              sat_s3rO3 [Occ=Once]
                                :: close_a3nuh -> Text.ParserCombinators.ReadP.P b_a3nIU
                              [LclId] =
                                  [lvl5_s3rO1] \r [a2_s3rO2] lvl5_s3rO1;
                            } in  close1_s3rNW sat_s3rO3;
                  } in  p_s3rNX sat_s3rO4; } in
        let {
          sat_s3rO6 [Occ=Once]
            :: open_a3nug -> Text.ParserCombinators.ReadP.P b_a3nIU
          [LclId] =
              [lvl4_s3rNZ] \r [a1_s3rO5] lvl4_s3rNZ;
        } in  open1_s3rNV sat_s3rO6;

Text.ParserCombinators.ReadP.between
  :: forall open close a.
     Text.ParserCombinators.ReadP.ReadP open
     -> Text.ParserCombinators.ReadP.ReadP close
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,C(U)><L,1*C1(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.between1 eta_B4 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$wcount [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Prim.Int#
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,U><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [ww_s3rO7 w_s3rO8 w1_s3rO9]
        case <# [0# ww_s3rO7] of {
          __DEFAULT -> w1_s3rO9 GHC.Types.[];
          1# ->
              let {
                $wxs_s3rOb [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                  :: GHC.Prim.Int#
                     -> forall b1.
                        ([a_s3ogB] -> Text.ParserCombinators.ReadP.P b1)
                        -> Text.ParserCombinators.ReadP.P b1
                [LclId, Arity=2, Str=<S,1*U><L,C(U)>, Unf=OtherCon []] =
                    sat-only [w_s3rO8 $wxs_s3rOb] \r [ww1_s3rOc w2_s3rOd]
                        case ww1_s3rOc of ds1_s3rOe {
                          __DEFAULT ->
                              case -# [ds1_s3rOe 1#] of r_s3rOf {
                                __DEFAULT ->
                                    let {
                                      sat_s3rOk [Occ=Once]
                                        :: a_s3ogB -> Text.ParserCombinators.ReadP.P b1_s3ogu
                                      [LclId] =
                                          [$wxs_s3rOb w2_s3rOd r_s3rOf] \r [a1_s3rOg]
                                              let {
                                                sat_s3rOj [Occ=Once]
                                                  :: [a_s3ogB]
                                                     -> Text.ParserCombinators.ReadP.P b1_s3ogu
                                                [LclId] =
                                                    [w2_s3rOd a1_s3rOg] \r [a2_s3rOh]
                                                        let {
                                                          sat_s3rOi [Occ=Once] :: [a_s3ogB]
                                                          [LclId] =
                                                              CCCS :! [a1_s3rOg a2_s3rOh];
                                                        } in  w2_s3rOd sat_s3rOi;
                                              } in  $wxs_s3rOb r_s3rOf sat_s3rOj;
                                    } in  w_s3rO8 sat_s3rOk;
                              };
                          1# ->
                              let {
                                sat_s3rOn [Occ=Once]
                                  :: a_s3ogB -> Text.ParserCombinators.ReadP.P b1_s3ogu
                                [LclId] =
                                    [w2_s3rOd] \r [a1_s3rOl]
                                        let {
                                          sat_s3rOm [Occ=Once] :: [a_s3ogB]
                                          [LclId] =
                                              CCCS :! [a1_s3rOl GHC.Types.[]];
                                        } in  w2_s3rOd sat_s3rOm;
                              } in  w_s3rO8 sat_s3rOn;
                        };
              } in  $wxs_s3rOb ww_s3rO7 w1_s3rO9;
        };

Text.ParserCombinators.ReadP.count1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3rOo w1_s3rOp w2_s3rOq]
        case w_s3rOo of {
          GHC.Types.I# ww1_s3rOs [Occ=Once] ->
              Text.ParserCombinators.ReadP.$wcount ww1_s3rOs w1_s3rOp w2_s3rOq;
        };

Text.ParserCombinators.ReadP.count
  :: forall a.
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.count1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.option1
  :: forall a.
     a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
    [] \r [x_s3rOt p_s3rOu eta_s3rOv]
        let {
          sat_s3rOx [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [x_s3rOt eta_s3rOv] \u [] eta_s3rOv x_s3rOt;
        } in 
          case p_s3rOu eta_s3rOv of sat_s3rOw {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3rOw sat_s3rOx;
          };

Text.ParserCombinators.ReadP.option
  :: forall a.
     a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.option1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.optional1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),1*C1(U)><L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [p_s3rOy eta_s3rOz]
        let {
          lvl4_s3rOA :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [eta_s3rOz] \u [] eta_s3rOz GHC.Tuple.(); } in
        let {
          sat_s3rOC [Occ=Once]
            :: a_a3nw0 -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [lvl4_s3rOA] \r [a1_s3rOB] lvl4_s3rOA;
        } in 
          case p_s3rOy sat_s3rOC of sat_s3rOD {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3rOD lvl4_s3rOA;
          };

Text.ParserCombinators.ReadP.optional
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP ()
[GblId, Arity=2, Str=<C(S),1*C1(U)><L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.optional1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.endBy3 [Occ=LoopBreaker]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,C(U)><C(S),C(U)>, Unf=OtherCon []] =
    [] \r [p_s3rOE eta_s3rOF]
        let {
          sat_s3rOM [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [p_s3rOE eta_s3rOF] \u []
                  let {
                    sat_s3rOL [Occ=Once]
                      :: a_a3nwo -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [p_s3rOE eta_s3rOF] \r [a1_s3rOH]
                            let {
                              sat_s3rOK [Occ=Once]
                                :: [a_a3nwo] -> Text.ParserCombinators.ReadP.P b_a3ngn
                              [LclId] =
                                  [eta_s3rOF a1_s3rOH] \r [a2_s3rOI]
                                      let {
                                        sat_s3rOJ [Occ=Once] :: [a_a3nwo]
                                        [LclId] =
                                            CCCS :! [a1_s3rOH a2_s3rOI];
                                      } in  eta_s3rOF sat_s3rOJ;
                            } in  Text.ParserCombinators.ReadP.endBy3 p_s3rOE sat_s3rOK;
                  } in  p_s3rOE sat_s3rOL;
        } in 
          case eta_s3rOF GHC.Types.[] of sat_s3rOG {
            __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3rOG sat_s3rOM;
          };

Text.ParserCombinators.ReadP.many
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=2, Str=<L,C(U)><C(S),C(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.endBy3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.many2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),C(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [p_s3rON eta_s3rOO]
        let {
          sat_s3rOT [Occ=Once]
            :: a_a3nwe -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [p_s3rON eta_s3rOO] \r [a1_s3rOP]
                  let {
                    sat_s3rOS [Occ=Once]
                      :: [a_a3nwe] -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [eta_s3rOO a1_s3rOP] \r [a2_s3rOQ]
                            let {
                              sat_s3rOR [Occ=Once] :: [a_a3nwe]
                              [LclId] =
                                  CCCS :! [a1_s3rOP a2_s3rOQ];
                            } in  eta_s3rOO sat_s3rOR;
                  } in  Text.ParserCombinators.ReadP.endBy3 p_s3rON sat_s3rOS;
        } in  p_s3rON sat_s3rOT;

Text.ParserCombinators.ReadP.many1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=2, Str=<C(S),C(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.many2 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.endBy4
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3rOU sep1_s3rOV eta_s3rOW]
        let {
          p1_s3rOX [Occ=OnceL, Dmd=<L,C(U)>]
            :: forall b1.
               (a_a3nwx -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              [p_s3rOU sep1_s3rOV] \r [k_s3rOY]
                  let {
                    sat_s3rP3 [Occ=Once]
                      :: a_a3nwx -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [sep1_s3rOV k_s3rOY] \r [a1_s3rOZ]
                            let {
                              lvl4_s3rP0 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3rOY a1_s3rOZ] \u [] k_s3rOY a1_s3rOZ; } in
                            let {
                              sat_s3rP2 [Occ=Once]
                                :: sep_a3nwy -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [lvl4_s3rP0] \r [a2_s3rP1] lvl4_s3rP0;
                            } in  sep1_s3rOV sat_s3rP2;
                  } in  p_s3rOU sat_s3rP3; } in
        let {
          sat_s3rPb [Occ=Once]
            :: a_a3nwx -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [sep1_s3rOV eta_s3rOW p1_s3rOX] \r [a1_s3rP4]
                  let {
                    lvl4_s3rP5 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [eta_s3rOW p1_s3rOX a1_s3rP4] \u []
                            let {
                              sat_s3rP8 [Occ=Once]
                                :: [a_a3nwx] -> Text.ParserCombinators.ReadP.P b_a3ngn
                              [LclId] =
                                  [eta_s3rOW a1_s3rP4] \r [a2_s3rP6]
                                      let {
                                        sat_s3rP7 [Occ=Once] :: [a_a3nwx]
                                        [LclId] =
                                            CCCS :! [a1_s3rP4 a2_s3rP6];
                                      } in  eta_s3rOW sat_s3rP7;
                            } in  Text.ParserCombinators.ReadP.endBy3 p1_s3rOX sat_s3rP8; } in
                  let {
                    sat_s3rPa [Occ=Once]
                      :: sep_a3nwy -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [lvl4_s3rP5] \r [a2_s3rP9] lvl4_s3rP5;
                  } in  sep1_s3rOV sat_s3rPa;
        } in  p_s3rOU sat_s3rPb;

Text.ParserCombinators.ReadP.endBy1
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.endBy4 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.skipMany2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,C(U)><C(S),1*C1(U)>, Unf=OtherCon []] =
    [] \r [p_s3rPc eta_s3rPd]
        case eta_s3rPd GHC.Tuple.() of lvl4_s3rPe [Dmd=<S,U>] {
          __DEFAULT ->
              let {
                sat_s3rPg [Occ=Once]
                  :: [a_a3nwN] -> Text.ParserCombinators.ReadP.P b_a3ngn
                [LclId] =
                    [lvl4_s3rPe] \r [a1_s3rPf] lvl4_s3rPe;
              } in  Text.ParserCombinators.ReadP.endBy3 p_s3rPc sat_s3rPg;
        };

Text.ParserCombinators.ReadP.skipMany
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP ()
[GblId, Arity=2, Str=<L,C(U)><C(S),1*C1(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.skipMany2 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.skipMany3
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),C(U)><L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [p_s3rPh eta_s3rPi]
        let {
          lvl4_s3rPj [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [p_s3rPh eta_s3rPi] \u []
                  case eta_s3rPi GHC.Tuple.() of lvl5_s3rPk [Dmd=<S,U>] {
                    __DEFAULT ->
                        let {
                          sat_s3rPm [Occ=Once]
                            :: [a_a3nwY] -> Text.ParserCombinators.ReadP.P b_a3ngn
                          [LclId] =
                              [lvl5_s3rPk] \r [a1_s3rPl] lvl5_s3rPk;
                        } in  Text.ParserCombinators.ReadP.endBy3 p_s3rPh sat_s3rPm;
                  }; } in
        let {
          sat_s3rPo [Occ=Once]
            :: a_a3nwY -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [lvl4_s3rPj] \r [a1_s3rPn] lvl4_s3rPj;
        } in  p_s3rPh sat_s3rPo;

Text.ParserCombinators.ReadP.skipMany1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP ()
[GblId, Arity=2, Str=<C(S),C(U)><L,1*C1(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.skipMany3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.sepBy3
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3rPp sep1_s3rPq eta_s3rPr]
        let {
          m2_s3rPs [Occ=OnceL, Dmd=<L,C(U)>]
            :: forall b1.
               (a_a3nx6 -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              [p_s3rPp sep1_s3rPq] \r [k_s3rPt]
                  let {
                    lvl4_s3rPu [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [p_s3rPp k_s3rPt] \u [] p_s3rPp k_s3rPt; } in
                  let {
                    sat_s3rPw [Occ=Once]
                      :: sep_a3nx7 -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [lvl4_s3rPu] \r [a1_s3rPv] lvl4_s3rPu;
                  } in  sep1_s3rPq sat_s3rPw; } in
        let {
          sat_s3rPB [Occ=Once]
            :: a_a3nx6 -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [eta_s3rPr m2_s3rPs] \r [a1_s3rPx]
                  let {
                    sat_s3rPA [Occ=Once]
                      :: [a_a3nx6] -> Text.ParserCombinators.ReadP.P b_a3ngn
                    [LclId] =
                        [eta_s3rPr a1_s3rPx] \r [a2_s3rPy]
                            let {
                              sat_s3rPz [Occ=Once] :: [a_a3nx6]
                              [LclId] =
                                  CCCS :! [a1_s3rPx a2_s3rPy];
                            } in  eta_s3rPr sat_s3rPz;
                  } in  Text.ParserCombinators.ReadP.endBy3 m2_s3rPs sat_s3rPA;
        } in  p_s3rPp sat_s3rPB;

Text.ParserCombinators.ReadP.sepBy1
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.sepBy3 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.endBy2
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,C(U)><L,C(U)><C(S),C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3rPC sep1_s3rPD eta_s3rPE]
        let {
          sat_s3rPL [Occ=Once] :: Text.ParserCombinators.ReadP.ReadP a_a3nxl
          [LclId] =
              [p_s3rPC sep1_s3rPD] \r [k_s3rPF]
                  let {
                    sat_s3rPK [Occ=Once]
                      :: a_a3nxl -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [sep1_s3rPD k_s3rPF] \r [a1_s3rPG]
                            let {
                              lvl4_s3rPH [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3rPF a1_s3rPG] \u [] k_s3rPF a1_s3rPG; } in
                            let {
                              sat_s3rPJ [Occ=Once]
                                :: sep_a3nxm -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [lvl4_s3rPH] \r [a2_s3rPI] lvl4_s3rPH;
                            } in  sep1_s3rPD sat_s3rPJ;
                  } in  p_s3rPC sat_s3rPK;
        } in  Text.ParserCombinators.ReadP.endBy3 sat_s3rPL eta_s3rPE;

Text.ParserCombinators.ReadP.endBy
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Str=<L,C(U)><L,C(U)><C(S),C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.endBy2 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.sepBy2
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3rPM sep1_s3rPN eta_s3rPO]
        let {
          sat_s3rPQ [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [eta_s3rPO] \u [] eta_s3rPO GHC.Types.[];
        } in 
          case
              Text.ParserCombinators.ReadP.sepBy3 p_s3rPM sep1_s3rPN eta_s3rPO
          of
          sat_s3rPP
          { __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3rPP sat_s3rPQ;
          };

Text.ParserCombinators.ReadP.sepBy
  :: forall a sep.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP sep
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.sepBy2 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$fMonadFailReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fail.C:MonadFail! [Text.ParserCombinators.ReadP.$fMonadReadP
                                                   Text.ParserCombinators.ReadP.$fMonadFailReadP1];

Text.ParserCombinators.ReadP.$fAlternativeReadP2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),C(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [v_s3rPR eta_s3rPS]
        let {
          some_v_s3rPT [Occ=LoopBreaker]
            :: forall b1.
               ([a_a3nIa] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              sat-only [v_s3rPR some_v_s3rPT] \r [eta1_s3rPU]
                  let {
                    sat_s3rQ2 [Occ=Once]
                      :: a_a3nIa -> Text.ParserCombinators.ReadP.P b1_X3nkZ
                    [LclId] =
                        [some_v_s3rPT eta1_s3rPU] \r [x_s3rPV]
                            let {
                              sat_s3rQ1 [Occ=Once] :: Text.ParserCombinators.ReadP.P b1_X3nkZ
                              [LclId] =
                                  [eta1_s3rPU x_s3rPV] \u []
                                      let {
                                        sat_s3rQ0 [Occ=Once] :: [a_a3nIa]
                                        [LclId] =
                                            CCCS :! [x_s3rPV GHC.Types.[]];
                                      } in  eta1_s3rPU sat_s3rQ0; } in
                            let {
                              sat_s3rPY [Occ=Once]
                                :: [a_a3nIa] -> Text.ParserCombinators.ReadP.P b1_X3nkZ
                              [LclId] =
                                  [eta1_s3rPU x_s3rPV] \r [a1_s3rPW]
                                      let {
                                        sat_s3rPX [Occ=Once] :: [a_a3nIa]
                                        [LclId] =
                                            CCCS :! [x_s3rPV a1_s3rPW];
                                      } in  eta1_s3rPU sat_s3rPX;
                            } in 
                              case some_v_s3rPT sat_s3rPY of sat_s3rPZ {
                                __DEFAULT ->
                                    Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                        sat_s3rPZ sat_s3rQ1;
                              };
                  } in  v_s3rPR sat_s3rQ2;
        } in  some_v_s3rPT eta_s3rPS;

Text.ParserCombinators.ReadP.$fAlternativeReadP1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<C(S),C(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [v_s3rQ3 eta_s3rQ4]
        let {
          many_v_s3rQ5 [Occ=LoopBreaker]
            :: forall b1.
               ([a_a3nIm] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              sat-only [v_s3rQ3 many_v_s3rQ5] \r [k_s3rQ6]
                  let {
                    sat_s3rQd [Occ=Once] :: Text.ParserCombinators.ReadP.P b1_a3nvJ
                    [LclId] =
                        [k_s3rQ6] \u [] k_s3rQ6 GHC.Types.[]; } in
                  let {
                    sat_s3rQb [Occ=Once]
                      :: a_a3nIm -> Text.ParserCombinators.ReadP.P b1_a3nvJ
                    [LclId] =
                        [many_v_s3rQ5 k_s3rQ6] \r [x_s3rQ7]
                            let {
                              sat_s3rQa [Occ=Once]
                                :: [a_a3nIm] -> Text.ParserCombinators.ReadP.P b1_a3nvJ
                              [LclId] =
                                  [k_s3rQ6 x_s3rQ7] \r [a1_s3rQ8]
                                      let {
                                        sat_s3rQ9 [Occ=Once] :: [a_a3nIm]
                                        [LclId] =
                                            CCCS :! [x_s3rQ7 a1_s3rQ8];
                                      } in  k_s3rQ6 sat_s3rQ9;
                            } in  many_v_s3rQ5 sat_s3rQa;
                  } in 
                    case v_s3rQ3 sat_s3rQb of sat_s3rQc {
                      __DEFAULT ->
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                              sat_s3rQc sat_s3rQd;
                    };
        } in  many_v_s3rQ5 eta_s3rQ4;

Text.ParserCombinators.ReadP.$fAlternativeReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Text.ParserCombinators.ReadP.$fApplicativeReadP
                                           Text.ParserCombinators.ReadP.$fAlternativeReadP4
                                           Text.ParserCombinators.ReadP.$fAlternativeReadP3
                                           Text.ParserCombinators.ReadP.$fAlternativeReadP2
                                           Text.ParserCombinators.ReadP.$fAlternativeReadP1];

Text.ParserCombinators.ReadP.$fMonadPlusReadP [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus Text.ParserCombinators.ReadP.ReadP
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [Text.ParserCombinators.ReadP.$fAlternativeReadP
                                         Text.ParserCombinators.ReadP.$fMonadReadP
                                         Text.ParserCombinators.ReadP.$fAlternativeReadP4
                                         Text.ParserCombinators.ReadP.$fAlternativeReadP3];

Text.ParserCombinators.ReadP.chainr3
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3rQe op_s3rQf eta_s3rQg]
        let {
          scan_s3rQh [Occ=LoopBreaker]
            :: forall b1.
               (a_a3nxM -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              sat-only [p_s3rQe op_s3rQf scan_s3rQh] \r [k_s3rQi]
                  let {
                    sat_s3rQr [Occ=Once]
                      :: a_a3nxM -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [op_s3rQf scan_s3rQh k_s3rQi] \r [a1_s3rQj]
                            let {
                              sat_s3rQq [Occ=Once] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3rQi a1_s3rQj] \u [] k_s3rQi a1_s3rQj; } in
                            let {
                              sat_s3rQo [Occ=Once]
                                :: (a_a3nxM -> a_a3nxM -> a_a3nxM)
                                   -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [scan_s3rQh k_s3rQi a1_s3rQj] \r [a2_s3rQk]
                                      let {
                                        sat_s3rQn [Occ=Once]
                                          :: a_a3nxM -> Text.ParserCombinators.ReadP.P b1_a3nIU
                                        [LclId] =
                                            [k_s3rQi a1_s3rQj a2_s3rQk] \r [a3_s3rQl]
                                                let {
                                                  sat_s3rQm [Occ=Once] :: a_a3nxM
                                                  [LclId] =
                                                      [a1_s3rQj a2_s3rQk a3_s3rQl] \u []
                                                          a2_s3rQk a1_s3rQj a3_s3rQl;
                                                } in  k_s3rQi sat_s3rQm;
                                      } in  scan_s3rQh sat_s3rQn;
                            } in 
                              case op_s3rQf sat_s3rQo of sat_s3rQp {
                                __DEFAULT ->
                                    Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                        sat_s3rQp sat_s3rQq;
                              };
                  } in  p_s3rQe sat_s3rQr;
        } in  scan_s3rQh eta_s3rQg;

Text.ParserCombinators.ReadP.chainr1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.chainr3 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.chainr2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3rQs op_s3rQt x_s3rQu eta_s3rQv]
        let {
          sat_s3rQx [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [x_s3rQu eta_s3rQv] \u [] eta_s3rQv x_s3rQu;
        } in 
          case
              Text.ParserCombinators.ReadP.chainr3 p_s3rQs op_s3rQt eta_s3rQv
          of
          sat_s3rQw
          { __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3rQw sat_s3rQx;
          };

Text.ParserCombinators.ReadP.chainr
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.chainr2 eta_B4 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.chainl3
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3rQy op_s3rQz eta_s3rQA]
        let {
          rest_s3rQB [Occ=LoopBreaker]
            :: a_a3nyq
               -> forall b1.
                  (a_a3nyq -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<L,U><L,C(U)>, Unf=OtherCon []] =
              sat-only [p_s3rQy op_s3rQz rest_s3rQB] \r [x_s3rQC eta1_s3rQD]
                  let {
                    sat_s3rQK [Occ=Once] :: Text.ParserCombinators.ReadP.P b1_X3nls
                    [LclId] =
                        [x_s3rQC eta1_s3rQD] \u [] eta1_s3rQD x_s3rQC; } in
                  let {
                    sat_s3rQI [Occ=Once]
                      :: (a_a3nyq -> a_a3nyq -> a_a3nyq)
                         -> Text.ParserCombinators.ReadP.P b1_X3nls
                    [LclId] =
                        [p_s3rQy rest_s3rQB x_s3rQC eta1_s3rQD] \r [a1_s3rQE]
                            let {
                              sat_s3rQH [Occ=Once]
                                :: a_a3nyq -> Text.ParserCombinators.ReadP.P b1_X3nls
                              [LclId] =
                                  [rest_s3rQB x_s3rQC eta1_s3rQD a1_s3rQE] \r [a2_s3rQF]
                                      let {
                                        sat_s3rQG [Occ=Once] :: a_a3nyq
                                        [LclId] =
                                            [x_s3rQC a1_s3rQE a2_s3rQF] \u []
                                                a1_s3rQE x_s3rQC a2_s3rQF;
                                      } in  rest_s3rQB sat_s3rQG eta1_s3rQD;
                            } in  p_s3rQy sat_s3rQH;
                  } in 
                    case op_s3rQz sat_s3rQI of sat_s3rQJ {
                      __DEFAULT ->
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                              sat_s3rQJ sat_s3rQK;
                    }; } in
        let {
          sat_s3rQM [Occ=Once]
            :: a_a3nyq -> Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [eta_s3rQA rest_s3rQB] \r [a1_s3rQL] rest_s3rQB a1_s3rQL eta_s3rQA;
        } in  p_s3rQy sat_s3rQM;

Text.ParserCombinators.ReadP.chainl1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Str=<C(S),C(U)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.chainl3 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.chainl2
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [p_s3rQN op_s3rQO x_s3rQP eta_s3rQQ]
        let {
          sat_s3rQS [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3ngn
          [LclId] =
              [x_s3rQP eta_s3rQQ] \u [] eta_s3rQQ x_s3rQP;
        } in 
          case
              Text.ParserCombinators.ReadP.chainl3 p_s3rQN op_s3rQO eta_s3rQQ
          of
          sat_s3rQR
          { __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_s3rQR sat_s3rQS;
          };

Text.ParserCombinators.ReadP.chainl
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP (a -> a -> a)
     -> a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=4,
 Str=<C(S),C(U)><L,C(U)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.chainl2 eta_B4 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.<++2 [Occ=LoopBreaker]
  :: GHC.Prim.Int#
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s3rQT eta_s3rQU]
        case ds_s3rQT of ds1_s3rQV {
          __DEFAULT ->
              let {
                lvl4_s3rQW [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_X3nlD
                [LclId] =
                    [eta_s3rQU ds1_s3rQV] \u []
                        case -# [ds1_s3rQV 1#] of sat_s3rQX {
                          __DEFAULT -> Text.ParserCombinators.ReadP.<++2 sat_s3rQX eta_s3rQU;
                        }; } in
              let {
                sat_s3rQZ [Occ=Once]
                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_X3nlD
                [LclId] =
                    [lvl4_s3rQW] \r [a_s3rQY] lvl4_s3rQW;
              } in  Text.ParserCombinators.ReadP.Get [sat_s3rQZ];
          0# -> eta_s3rQU GHC.Tuple.();
        };

Text.ParserCombinators.ReadP.$w<++ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId, Arity=3, Str=<L,1*C1(U)><L,C(U)><L,U>, Unf=OtherCon []] =
    [] \r [w_s3rR0 w1_s3rR1 w2_s3rR2]
        let {
          lvl4_s3rR3 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P a_s3ohU
          [LclId] =
              [w_s3rR0] \u []
                  w_s3rR0 Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
        let {
          probe_s3rR4 [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadP.P a_s3ohU
               -> [GHC.Types.Char]
               -> GHC.Prim.Int#
               -> forall b1.
                  (a_s3ohU -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=4, Str=<S,1*U><L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w1_s3rR1 probe_s3rR4] \r [ds_s3rR5
                                                  ds1_s3rR6
                                                  n_s3rR7
                                                  eta_s3rR8]
                  case ds_s3rR5 of wild_s3rR9 {
                    Text.ParserCombinators.ReadP.Get f_s3rRa [Occ=Once!] ->
                        case ds1_s3rR6 of {
                          [] -> w1_s3rR1 eta_s3rR8;
                          : c_s3rRc [Occ=Once] s_s3rRd [Occ=Once] ->
                              case +# [n_s3rR7 1#] of sat_s3rRf {
                                __DEFAULT ->
                                    case f_s3rRa c_s3rRc of sat_s3rRe {
                                      __DEFAULT ->
                                          probe_s3rR4 sat_s3rRe s_s3rRd sat_s3rRf eta_s3rR8;
                                    };
                              };
                        };
                    Text.ParserCombinators.ReadP.Look f_s3rRg [Occ=Once!] ->
                        case f_s3rRg ds1_s3rR6 of sat_s3rRh {
                          __DEFAULT -> probe_s3rR4 sat_s3rRh ds1_s3rR6 n_s3rR7 eta_s3rR8;
                        };
                    Text.ParserCombinators.ReadP.Fail -> w1_s3rR1 eta_s3rR8;
                    Text.ParserCombinators.ReadP.Result _ [Occ=Dead] _ [Occ=Dead] ->
                        let {
                          sat_s3rRl [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b1_X3nlg
                          [LclId] =
                              [eta_s3rR8 wild_s3rR9] \r [a1_s3rRk]
                                  Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                                      wild_s3rR9 eta_s3rR8;
                        } in  Text.ParserCombinators.ReadP.<++2 n_s3rR7 sat_s3rRl;
                    Text.ParserCombinators.ReadP.Final _ [Occ=Dead] ->
                        Text.ParserCombinators.ReadP.$fAlternativeP_$c>>=
                            wild_s3rR9 eta_s3rR8;
                  }; } in
        let {
          sat_s3rRo [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3ohX
          [LclId] =
              [w2_s3rR2 lvl4_s3rR3 probe_s3rR4] \r [a1_s3rRn]
                  probe_s3rR4 lvl4_s3rR3 a1_s3rRn 0# w2_s3rR2;
        } in  Unit# [sat_s3rRo];

Text.ParserCombinators.ReadP.<++1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,1*C1(U)><L,C(U)><L,U>m2, Unf=OtherCon []] =
    [] \r [w_s3rRp w1_s3rRq w2_s3rRr]
        case
            Text.ParserCombinators.ReadP.$w<++ w_s3rRp w1_s3rRq w2_s3rRr
        of
        { Unit# ww1_s3rRt [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_s3rRt];
        };

Text.ParserCombinators.ReadP.<++
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=3, Str=<L,1*C1(U)><L,C(U)><L,U>m2, Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.<++1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.manyTill1
  :: forall a end.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP end
     -> forall b.
        ([a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,C(U)><L,C(U)><L,U>, Unf=OtherCon []] =
    [] \r [p_s3rRu end1_s3rRv eta_s3rRw]
        let {
          scan_s3rRx [Occ=OnceL, Dmd=<L,C(U)>]
            :: forall b1.
               ([a_a3nB6] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,1*C1(U)>, Unf=OtherCon []] =
              [end1_s3rRv] \r [k_s3rRy]
                  let {
                    lvl4_s3rRz [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [k_s3rRy] \u [] k_s3rRy GHC.Types.[]; } in
                  let {
                    sat_s3rRB [Occ=Once]
                      :: end_a3nB7 -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [lvl4_s3rRz] \r [a1_s3rRA] lvl4_s3rRz;
                  } in  end1_s3rRv sat_s3rRB; } in
        let {
          scan1_s3rRC [Occ=OnceL]
            :: forall b1.
               ([a_a3nB6] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
              [p_s3rRu scan2_s3rRD] \r [k_s3rRE]
                  let {
                    sat_s3rRJ [Occ=Once]
                      :: a_a3nB6 -> Text.ParserCombinators.ReadP.P b1_X3nOr
                    [LclId] =
                        [scan2_s3rRD k_s3rRE] \r [a1_s3rRF]
                            let {
                              sat_s3rRI [Occ=Once]
                                :: [a_a3nB6] -> Text.ParserCombinators.ReadP.P b1_X3nOr
                              [LclId] =
                                  [k_s3rRE a1_s3rRF] \r [a2_s3rRG]
                                      let {
                                        sat_s3rRH [Occ=Once] :: [a_a3nB6]
                                        [LclId] =
                                            CCCS :! [a1_s3rRF a2_s3rRG];
                                      } in  k_s3rRE sat_s3rRH;
                            } in  scan2_s3rRD sat_s3rRI;
                  } in  p_s3rRu sat_s3rRJ;
          scan2_s3rRD [Occ=LoopBreaker]
            :: forall b1.
               ([a_a3nB6] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [scan_s3rRx scan1_s3rRC] \r [w_s3rRK]
                  case
                      Text.ParserCombinators.ReadP.$w<++ scan_s3rRx scan1_s3rRC w_s3rRK
                  of
                  { Unit# ww1_s3rRM [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_s3rRM];
                  };
        } in  scan2_s3rRD eta_s3rRw;

Text.ParserCombinators.ReadP.manyTill
  :: forall a end.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadP.ReadP end
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=3, Str=<L,C(U)><L,C(U)><L,U>, Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.manyTill1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.eof1
  :: forall b.
     (() -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)>m2,
 Unf=OtherCon []] =
    [] \r [k_s3rRN]
        let {
          lvl4_s3rRO [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b_a3nIU
          [LclId] =
              [k_s3rRN] \u [] k_s3rRN GHC.Tuple.(); } in
        let {
          sat_s3rRT [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_a3nIU
          [LclId] =
              [lvl4_s3rRO] \r [a_s3rRP]
                  case a_s3rRP of {
                    [] -> lvl4_s3rRO;
                    : _ [Occ=Dead] _ [Occ=Dead] ->
                        Text.ParserCombinators.ReadP.Fail [];
                  };
        } in  Text.ParserCombinators.ReadP.Look [sat_s3rRT];

Text.ParserCombinators.ReadP.eof
  :: Text.ParserCombinators.ReadP.ReadP ()
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.eof1 eta_B1;

Text.ParserCombinators.ReadP.satisfy1
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Types.Char -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [p_s3rRU k_s3rRV]
        let {
          sat_s3rRY [Occ=Once]
            :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_X3nNg
          [LclId] =
              [p_s3rRU k_s3rRV] \r [a_s3rRW]
                  case p_s3rRU a_s3rRW of {
                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail [];
                    GHC.Types.True -> k_s3rRV a_s3rRW;
                  };
        } in  Text.ParserCombinators.ReadP.Get [sat_s3rRY];

Text.ParserCombinators.ReadP.satisfy
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> Text.ParserCombinators.ReadP.ReadP GHC.Types.Char
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.satisfy1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.char1
  :: GHC.Types.Char
     -> forall b.
        (GHC.Types.Char -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [c_s3rRZ eta_s3rS0]
        let {
          sat_s3rS7 [Occ=Once]
            :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_X3nNg
          [LclId] =
              [c_s3rRZ eta_s3rS0] \r [a_s3rS1]
                  case c_s3rRZ of {
                    GHC.Types.C# x_s3rS3 [Occ=Once] ->
                        case a_s3rS1 of wild1_s3rS4 {
                          GHC.Types.C# y_s3rS5 [Occ=Once] ->
                              case eqChar# [x_s3rS3 y_s3rS5] of {
                                __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                1# -> eta_s3rS0 wild1_s3rS4;
                              };
                        };
                  };
        } in  Text.ParserCombinators.ReadP.Get [sat_s3rS7];

Text.ParserCombinators.ReadP.char
  :: GHC.Types.Char
     -> Text.ParserCombinators.ReadP.ReadP GHC.Types.Char
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.char1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$wstring [InlPrag=NOUSERINLINE[0]]
  :: GHC.Base.String
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3rS8 w1_s3rS9]
        let {
          scan_s3rSa [Occ=LoopBreaker]
            :: [GHC.Types.Char]
               -> [GHC.Types.Char]
               -> forall b1.
                  (GHC.Base.String -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=3, Str=<S,1*U><L,1*U><L,1*C1(U)>, Unf=OtherCon []] =
              sat-only [w_s3rS8 scan_s3rSa] \r [ds_s3rSb ds1_s3rSc eta_s3rSd]
                  case ds_s3rSb of {
                    [] -> eta_s3rSd w_s3rS8;
                    : x_s3rSf [Occ=Once!] xs_s3rSg [Occ=Once] ->
                        case ds1_s3rSc of {
                          [] -> Text.ParserCombinators.ReadP.Fail [];
                          : y_s3rSi [Occ=Once!] ys_s3rSj [Occ=Once] ->
                              case x_s3rSf of {
                                GHC.Types.C# x1_s3rSl [Occ=Once] ->
                                    case y_s3rSi of {
                                      GHC.Types.C# y1_s3rSn [Occ=Once] ->
                                          case eqChar# [x1_s3rSl y1_s3rSn] of {
                                            __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                            1# ->
                                                let {
                                                  lvl4_s3rSp [Occ=OnceL]
                                                    :: Text.ParserCombinators.ReadP.P b1_a3ngn
                                                  [LclId] =
                                                      [scan_s3rSa eta_s3rSd xs_s3rSg ys_s3rSj] \u []
                                                          scan_s3rSa
                                                              xs_s3rSg ys_s3rSj eta_s3rSd; } in
                                                let {
                                                  sat_s3rSr [Occ=Once]
                                                    :: GHC.Types.Char
                                                       -> Text.ParserCombinators.ReadP.P b1_a3ngn
                                                  [LclId] =
                                                      [lvl4_s3rSp] \r [a_s3rSq] lvl4_s3rSp;
                                                } in  Text.ParserCombinators.ReadP.Get [sat_s3rSr];
                                          };
                                    };
                              };
                        };
                  }; } in
        let {
          sat_s3rSt [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3oig
          [LclId] =
              [w_s3rS8 w1_s3rS9 scan_s3rSa] \r [a_s3rSs]
                  scan_s3rSa w_s3rS8 a_s3rSs w1_s3rS9;
        } in  Unit# [sat_s3rSt];

Text.ParserCombinators.ReadP.string1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Base.String
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_s3rSu w1_s3rSv]
        case Text.ParserCombinators.ReadP.$wstring w_s3rSu w1_s3rSv of {
          Unit# ww1_s3rSx [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_s3rSx];
        };

Text.ParserCombinators.ReadP.string
  :: GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadP GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.string1 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$wmunch [InlPrag=NOUSERINLINE[0]]
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3rSy w1_s3rSz]
        let {
          scan_s3rSA [Occ=LoopBreaker]
            :: [GHC.Types.Char]
               -> forall b1.
                  ([GHC.Types.Char] -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<S,1*U><L,1*C1(U)>, Unf=OtherCon []] =
              sat-only [w_s3rSy scan_s3rSA] \r [ds_s3rSB eta_s3rSC]
                  case ds_s3rSB of {
                    [] -> eta_s3rSC GHC.Types.[];
                    : c_s3rSE cs_s3rSF [Occ=Once] ->
                        case w_s3rSy c_s3rSE of {
                          GHC.Types.False -> eta_s3rSC GHC.Types.[];
                          GHC.Types.True ->
                              let {
                                lvl4_s3rSH [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_X3nlq
                                [LclId] =
                                    [scan_s3rSA eta_s3rSC c_s3rSE cs_s3rSF] \u []
                                        let {
                                          sat_s3rSK [Occ=Once]
                                            :: [GHC.Types.Char]
                                               -> Text.ParserCombinators.ReadP.P b1_X3nlq
                                          [LclId] =
                                              [eta_s3rSC c_s3rSE] \r [a_s3rSI]
                                                  let {
                                                    sat_s3rSJ [Occ=Once] :: [GHC.Types.Char]
                                                    [LclId] =
                                                        CCCS :! [c_s3rSE a_s3rSI];
                                                  } in  eta_s3rSC sat_s3rSJ;
                                        } in  scan_s3rSA cs_s3rSF sat_s3rSK; } in
                              let {
                                sat_s3rSM [Occ=Once]
                                  :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b1_X3nlq
                                [LclId] =
                                    [lvl4_s3rSH] \r [a_s3rSL] lvl4_s3rSH;
                              } in  Text.ParserCombinators.ReadP.Get [sat_s3rSM];
                        };
                  }; } in
        let {
          sat_s3rSO [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3oiq
          [LclId] =
              [w1_s3rSz scan_s3rSA] \r [a_s3rSN] scan_s3rSA a_s3rSN w1_s3rSz;
        } in  Unit# [sat_s3rSO];

Text.ParserCombinators.ReadP.munch2 [InlPrag=NOUSERINLINE[0]]
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_s3rSP w1_s3rSQ]
        case Text.ParserCombinators.ReadP.$wmunch w_s3rSP w1_s3rSQ of {
          Unit# ww1_s3rSS [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_s3rSS];
        };

Text.ParserCombinators.ReadP.munch
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> Text.ParserCombinators.ReadP.ReadP GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.munch2 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.$wmunch1 [InlPrag=NOUSERINLINE[0]]
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Types.Char -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_s3rST w1_s3rSU]
        let {
          sat_s3rT2 [Occ=Once]
            :: GHC.Types.Char -> Text.ParserCombinators.ReadP.P b_s3oix
          [LclId] =
              [w_s3rST w1_s3rSU] \r [a_s3rSV]
                  case w_s3rST a_s3rSV of {
                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail [];
                    GHC.Types.True ->
                        let {
                          sat_s3rSZ [Occ=Once]
                            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_s3oix
                          [LclId] =
                              [w1_s3rSU a_s3rSV] \r [a1_s3rSX]
                                  let {
                                    sat_s3rSY [Occ=Once] :: GHC.Base.String
                                    [LclId] =
                                        CCCS :! [a_s3rSV a1_s3rSX];
                                  } in  w1_s3rSU sat_s3rSY;
                        } in 
                          case Text.ParserCombinators.ReadP.$wmunch w_s3rST sat_s3rSZ of {
                            Unit# ww1_s3rT1 [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww1_s3rT1];
                          };
                  };
        } in  Unit# [sat_s3rT2];

Text.ParserCombinators.ReadP.munch3 [InlPrag=NOUSERINLINE[0]]
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> forall b.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [w_s3rT3 w1_s3rT4]
        case Text.ParserCombinators.ReadP.$wmunch1 w_s3rT3 w1_s3rT4 of {
          Unit# ww1_s3rT6 [Occ=Once] ->
              Text.ParserCombinators.ReadP.Get [ww1_s3rT6];
        };

Text.ParserCombinators.ReadP.munch1
  :: (GHC.Types.Char -> GHC.Types.Bool)
     -> Text.ParserCombinators.ReadP.ReadP GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>m1,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.munch3 eta_B2 eta_B1;

Text.ParserCombinators.ReadP.skipSpaces2 [Occ=LoopBreaker]
  :: [GHC.Types.Char]
     -> forall b.
        (() -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s3rT7 eta_s3rT8]
        case ds_s3rT7 of {
          [] -> eta_s3rT8 GHC.Tuple.();
          : c_s3rTa [Occ=Once!] s_s3rTb [Occ=Once*] ->
              case c_s3rTa of {
                GHC.Types.C# ww1_s3rTd ->
                    case ord# [ww1_s3rTd] of sat_s3rTf {
                      __DEFAULT ->
                          case int2Word# [sat_s3rTf] of x_s3rTe [Dmd=<S,U>] {
                            __DEFAULT ->
                                case leWord# [x_s3rTe 887##] of {
                                  __DEFAULT ->
                                      case ord# [ww1_s3rTd] of sat_s3rTi {
                                        __DEFAULT ->
                                            case
                                                __pkg_ccall base-4.11.0.0 [sat_s3rTi
                                                                           GHC.Prim.realWorld#]
                                            of
                                            { Unit# ds2_s3rTl [Occ=Once!] ->
                                                  case ds2_s3rTl of {
                                                    __DEFAULT ->
                                                        let {
                                                          lvl4_s3rTn [Occ=OnceL]
                                                            :: Text.ParserCombinators.ReadP.P
                                                                 b_a3ngn
                                                          [LclId] =
                                                              [eta_s3rT8 s_s3rTb] \u []
                                                                  Text.ParserCombinators.ReadP.skipSpaces2
                                                                      s_s3rTb eta_s3rT8; } in
                                                        let {
                                                          sat_s3rTp [Occ=Once]
                                                            :: GHC.Types.Char
                                                               -> Text.ParserCombinators.ReadP.P
                                                                    b_a3ngn
                                                          [LclId] =
                                                              [lvl4_s3rTn] \r [a_s3rTo] lvl4_s3rTn;
                                                        } in 
                                                          Text.ParserCombinators.ReadP.Get [sat_s3rTp];
                                                    0# -> eta_s3rT8 GHC.Tuple.();
                                                  };
                                            };
                                      };
                                  1# ->
                                      case x_s3rTe of wild1_s3rTq {
                                        __DEFAULT ->
                                            case minusWord# [wild1_s3rTq 9##] of sat_s3rTr {
                                              __DEFAULT ->
                                                  case leWord# [sat_s3rTr 4##] of {
                                                    __DEFAULT ->
                                                        case wild1_s3rTq of {
                                                          __DEFAULT -> eta_s3rT8 GHC.Tuple.();
                                                          160## ->
                                                              let {
                                                                lvl4_s3rTu [Occ=OnceL]
                                                                  :: Text.ParserCombinators.ReadP.P
                                                                       b_a3ngn
                                                                [LclId] =
                                                                    [eta_s3rT8 s_s3rTb] \u []
                                                                        Text.ParserCombinators.ReadP.skipSpaces2
                                                                            s_s3rTb eta_s3rT8; } in
                                                              let {
                                                                sat_s3rTw [Occ=Once]
                                                                  :: GHC.Types.Char
                                                                     -> Text.ParserCombinators.ReadP.P
                                                                          b_a3ngn
                                                                [LclId] =
                                                                    [lvl4_s3rTu] \r [a_s3rTv]
                                                                        lvl4_s3rTu;
                                                              } in 
                                                                Text.ParserCombinators.ReadP.Get [sat_s3rTw];
                                                        };
                                                    1# ->
                                                        let {
                                                          lvl4_s3rTx [Occ=OnceL]
                                                            :: Text.ParserCombinators.ReadP.P
                                                                 b_a3ngn
                                                          [LclId] =
                                                              [eta_s3rT8 s_s3rTb] \u []
                                                                  Text.ParserCombinators.ReadP.skipSpaces2
                                                                      s_s3rTb eta_s3rT8; } in
                                                        let {
                                                          sat_s3rTz [Occ=Once]
                                                            :: GHC.Types.Char
                                                               -> Text.ParserCombinators.ReadP.P
                                                                    b_a3ngn
                                                          [LclId] =
                                                              [lvl4_s3rTx] \r [a_s3rTy] lvl4_s3rTx;
                                                        } in 
                                                          Text.ParserCombinators.ReadP.Get [sat_s3rTz];
                                                  };
                                            };
                                        32## ->
                                            let {
                                              lvl4_s3rTA [Occ=OnceL]
                                                :: Text.ParserCombinators.ReadP.P b_a3ngn
                                              [LclId] =
                                                  [eta_s3rT8 s_s3rTb] \u []
                                                      Text.ParserCombinators.ReadP.skipSpaces2
                                                          s_s3rTb eta_s3rT8; } in
                                            let {
                                              sat_s3rTC [Occ=Once]
                                                :: GHC.Types.Char
                                                   -> Text.ParserCombinators.ReadP.P b_a3ngn
                                              [LclId] =
                                                  [lvl4_s3rTA] \r [a_s3rTB] lvl4_s3rTA;
                                            } in  Text.ParserCombinators.ReadP.Get [sat_s3rTC];
                                      };
                                };
                          };
                    };
              };
        };

Text.ParserCombinators.ReadP.skipSpaces1
  :: forall b.
     (() -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,C(U)>m2, Unf=OtherCon []] =
    [] \r [k_s3rTD]
        let {
          sat_s3rTF [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P b_X3nNv
          [LclId] =
              [k_s3rTD] \r [a_s3rTE]
                  Text.ParserCombinators.ReadP.skipSpaces2 a_s3rTE k_s3rTD;
        } in  Text.ParserCombinators.ReadP.Look [sat_s3rTF];

Text.ParserCombinators.ReadP.skipSpaces
  :: Text.ParserCombinators.ReadP.ReadP ()
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,C(U)>m2, Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.skipSpaces1 eta_B1;

Text.ParserCombinators.ReadP.Get
  :: forall a.
     (GHC.Types.Char -> Text.ParserCombinators.ReadP.P a)
     -> Text.ParserCombinators.ReadP.P a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m1,
 Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Get [eta_B1];

Text.ParserCombinators.ReadP.Look
  :: forall a.
     (GHC.Base.String -> Text.ParserCombinators.ReadP.P a)
     -> Text.ParserCombinators.ReadP.P a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Look [eta_B1];

Text.ParserCombinators.ReadP.Fail
  :: forall a. Text.ParserCombinators.ReadP.P a
[GblId[DataCon], Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE Text.ParserCombinators.ReadP.Fail! [];

Text.ParserCombinators.ReadP.Result
  :: forall a.
     a
     -> Text.ParserCombinators.ReadP.P a
     -> Text.ParserCombinators.ReadP.P a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m4,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadP.Result [eta_B2 eta_B1];

Text.ParserCombinators.ReadP.Final
  :: forall a.
     [(a, GHC.Base.String)] -> Text.ParserCombinators.ReadP.P a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m5,
 Unf=OtherCon []] =
    [] \r [eta_B1] Text.ParserCombinators.ReadP.Final [eta_B1];

